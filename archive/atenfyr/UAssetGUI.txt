Project Path: arc_atenfyr_UAssetGUI_3pr5ag3e

Source Tree:

```txt
arc_atenfyr_UAssetGUI_3pr5ag3e
├── LICENSE
├── NOTICE.md
├── README.md
├── UAssetAPI
├── UAssetGUI
│   ├── AboutForm.Designer.cs
│   ├── AboutForm.cs
│   ├── AboutForm.resx
│   ├── ColorfulTreeView.cs
│   ├── FileContainerForm.Designer.cs
│   ├── FileContainerForm.cs
│   ├── FileContainerForm.resx
│   ├── FindForm.Designer.cs
│   ├── FindForm.cs
│   ├── FindForm.resx
│   ├── Form1.Designer.cs
│   ├── Form1.cs
│   ├── Form1.resx
│   ├── GitHubAPI.cs
│   ├── GlobalSuppressions.cs
│   ├── IScriptInterface.cs
│   ├── LICENSE
│   ├── MapStructTypeOverrideForm.Designer.cs
│   ├── MapStructTypeOverrideForm.cs
│   ├── MapStructTypeOverrideForm.resx
│   ├── MarkdownViewer.Designer.cs
│   ├── MarkdownViewer.cs
│   ├── MarkdownViewer.resx
│   ├── Microsoft.CodeAnalysis.CSharp.dll.gz
│   ├── Microsoft.CodeAnalysis.dll.gz
│   ├── NOTICE.md
│   ├── Program.cs
│   ├── ProgressBarForm.Designer.cs
│   ├── ProgressBarForm.cs
│   ├── ProgressBarForm.resx
│   ├── Properties
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── Resources
│   │   ├── ExampleScripts
│   │   │   ├── Hello_world.cs
│   │   │   └── Set_all_visible_floats_to_100.cs
│   │   ├── dancing_cat.gif
│   │   └── icon.ico
│   ├── ScriptAssemblyLoadContext.cs
│   ├── SettingsForm.Designer.cs
│   ├── SettingsForm.cs
│   ├── SettingsForm.resx
│   ├── TableHandler.cs
│   ├── TextPrompt.Designer.cs
│   ├── TextPrompt.cs
│   ├── TextPrompt.resx
│   ├── UAGConfig.cs
│   ├── UAGPalette.cs
│   ├── UAGTheme.cs
│   ├── UAGUtils.cs
│   ├── UAssetGUI.csproj
│   ├── UAssetGUI.csproj.user
│   └── retoc.exe.gz
└── UAssetGUI.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 - 2026 atenfyr

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`NOTICE.md`:

```md
# Notices
The following is a list of applicable licensing information for all the third-party material used, in whole or in part, within this software.

## UAssetAPI
https://github.com/atenfyr/UAssetAPI
```
MIT License

Copyright (c) 2025 Atenfyr

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## repak
https://github.com/trumank/repak
```
MIT License

Copyright 2024 Truman Kilen, spuds

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## retoc
https://github.com/trumank/retoc
```
MIT License

Copyright (c) 2025 Truman Kilen and Archengius

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## Json.NET
https://github.com/JamesNK/Newtonsoft.Json
```
The MIT License (MIT)

Copyright (c) 2007 James Newton-King

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

## dotmore
https://github.com/mattmc3/dotmore
```
The MIT License (MIT)

Copyright (c) 2014 mattmc3

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## ZstdNet
https://github.com/skbkontur/ZstdNet
```
BSD License

For ZstdNet software

Copyright (c) 2016-present, SKB Kontur. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name SKB Kontur nor the names of its contributors may be used to
   endorse or promote products derived from this software without specific
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## zstd
https://github.com/facebook/zstd
```
BSD License

For Zstandard software

Copyright (c) Meta Platforms, Inc. and affiliates. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name Facebook, nor Meta, nor the names of its contributors may
   be used to endorse or promote products derived from this software without
   specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## UEAssetToolkitGenerator
https://github.com/LongerWarrior/UEAssetToolkitGenerator

### License
```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```
### Statement of Modification
Major portions of the source code that is adapted from UEAssetToolkitGenerator have been modified for usage in UAssetAPI through changes in code formatting, nomenclature, and serialization specifics in order to improve the effectiveness of the serialization across different engine versions and assets and to improve integration with newer versions of UAssetAPI. The relevant portions of source code have been sufficiently adapted such that no improper serialization or other unexpected behavior should be construed as having originated from any portion of the original work or any of its contributors.

### Original NOTICE text file information
The NOTICE text file bundled with the referenced project is not included in this copyright notice because none of the notices in that file pertain to any part of the work that is adapted for usage in UAssetAPI. Please see the original repository for more detailed copyright information.

## DiscordRichPresence
https://github.com/Lachee/discord-rpc-csharp
```
MIT License

Copyright (c) 2021 Lachee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## FolderBrowserEx
https://github.com/evaristocuesta/FolderBrowserEx
```
MIT License

Copyright (c) 2020 Evaristo Cuesta

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## markdig
https://github.com/xoofx/markdig
```
Copyright (c) 2018-2019, Alexandre Mutel
All rights reserved.

Redistribution and use in source and binary forms, with or without modification
, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this 
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, 
   this list of conditions and the following disclaimer in the documentation 
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## Roslyn
https://github.com/dotnet/roslyn
```
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## dotnet
https://github.com/dotnet/dotnet
```
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

```

`README.md`:

```md
# UAssetGUI
[![Release](https://img.shields.io/github/v/release/atenfyr/UAssetGUI.svg?style=flat-square)](https://github.com/atenfyr/UAssetGUI/releases/latest)
[![Downloads](https://img.shields.io/github/downloads/atenfyr/UAssetGUI/total.svg?style=flat-square)](https://github.com/atenfyr/UAssetGUI/releases)
[![Issues](https://img.shields.io/github/issues/atenfyr/UAssetGUI.svg?style=flat-square)](https://github.com/atenfyr/UAssetGUI/issues)
[![CI Status](https://img.shields.io/github/actions/workflow/status/atenfyr/UAssetGUI/build.yml?label=CI)](https://github.com/atenfyr/UAssetGUI/actions)
[![License](https://img.shields.io/github/license/atenfyr/UAssetGUI.svg?style=flat-square)](https://github.com/atenfyr/UAssetGUI/blob/master/LICENSE.md)

UAssetGUI is a tool designed for low-level examination and modification of Unreal Engine game assets by hand.

<img src="https://i.imgur.com/cibmlbW.png" align="center">

## Installation
You can find pre-built binaries of UAssetGUI in the [Releases tab of this repository](https://github.com/atenfyr/UAssetGUI/releases).

## Command line arguments
You can run the program with command line arguments to perform various tasks, such as exporting and importing from UAssetAPI JSON without opening the GUI.

In the following cases, the engine version can either be specified as an EngineVersion enum entry (e.g. `VER_UE4_23` to refer to 4.23, `VER_UE5_0` to refer to 5.0, etc.) or as an integer (e.g. `23` to refer to 4.23, `29` to refer to 5.0, etc.). Specifying a set of mappings is optional, but if specified, must be the name of a file within the Mappings config directory (with no extension).

### Export to JSON
```
UAssetGUI tojson <source> <destination> <engine version> [mappings name]
```

Example 1: `UAssetGUI tojson A.uasset B.json VER_UE5_1`

Example 2: `UAssetGUI tojson A.uasset B.json 27 Astro`

### Import from JSON
```
UAssetGUI fromjson <source> <destination> [mappings name]
```

Example 1: `UAssetGUI fromjson B.json A.umap`

Example 2: `UAssetGUI fromjson B.json A.umap Outriders`

### Open a specific file in the GUI
```
UAssetGUI [file name] [engine version] [mappings name]
```

Example 1: `UAssetGUI` (to simply open the GUI without opening a file)

Example 2: `UAssetGUI test.uasset`

Example 3: `UAssetGUI test.uasset 23`

Example 4: `UAssetGUI test.uasset VER_UE5_4 Bellwright`

## Compilation
If you'd like to compile UAssetGUI for yourself, read on:

### Prerequisites
* Visual Studio 2022 or later
* Git

### Initial Setup
1. Clone the UAssetGUI repository:

```sh
git clone https://github.com/atenfyr/UAssetGUI.git
```

2. Switch to the new UAssetGUI directory:

```sh
cd UAssetGUI
```

3. Pull the required submodules:

```sh
git submodule update --init
```

4. Open the `UAssetGUI.sln` solution file in Visual Studio, right-click on the UAssetGUI project in the Solution Explorer, and click "Set as Startup Project."

5. Right-click on the solution name in the Solution Explorer, and press "Restore Nuget Packages."

6. Press the "Start" button or press F5 to compile and open UAssetGUI.

## Contributing
Any contributions, whether through pull requests or issues, that you make are greatly appreciated.

If you have an Unreal Engine .uasset file that displays "failed to maintain binary equality," feel free to submit an issue on [the UAssetAPI issues page](https://github.com/atenfyr/UAssetAPI/issues) with a copy of the asset in question along with the name of the game, the Unreal version that it was cooked with, and a mappings file for the game, if needed.

Please note: Your issue will NOT be reviewed if your issue cannot be replicated due to no test asset being provided.

## License
UAssetAPI and UAssetGUI are distributed under the MIT license, which you can view in detail in the [LICENSE file](LICENSE).

```

`UAssetGUI.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33103.184
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UAssetAPI", "UAssetAPI\UAssetAPI\UAssetAPI.csproj", "{178417EC-1177-413E-BE85-C83AECD64279}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UAssetAPI.Tests", "UAssetAPI\UAssetAPI.Tests\UAssetAPI.Tests.csproj", "{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UAssetGUI", "UAssetGUI\UAssetGUI.csproj", "{88A998F1-C512-416F-ADED-120E50AFE6F3}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UAssetAPI.Benchmark", "UAssetAPI\UAssetAPI.Benchmark\UAssetAPI.Benchmark.csproj", "{A74E7E85-1797-477C-AEC1-583AE7D109D0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		DebugTracing|Any CPU = DebugTracing|Any CPU
		DebugTracing|x64 = DebugTracing|x64
		DebugTracing|x86 = DebugTracing|x86
		DebugVerbose|Any CPU = DebugVerbose|Any CPU
		DebugVerbose|x64 = DebugVerbose|x64
		DebugVerbose|x86 = DebugVerbose|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
		ReleaseX|Any CPU = ReleaseX|Any CPU
		ReleaseX|x64 = ReleaseX|x64
		ReleaseX|x86 = ReleaseX|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|x64.ActiveCfg = Debug|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|x64.Build.0 = Debug|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|x86.ActiveCfg = Debug|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|x86.Build.0 = Debug|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|Any CPU.ActiveCfg = DebugTracing|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|Any CPU.Build.0 = DebugTracing|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|x64.ActiveCfg = DebugTracing|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|x64.Build.0 = DebugTracing|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|x86.ActiveCfg = DebugTracing|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|x86.Build.0 = DebugTracing|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|Any CPU.ActiveCfg = DebugVerbose|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|Any CPU.Build.0 = DebugVerbose|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|x64.ActiveCfg = DebugVerbose|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|x64.Build.0 = DebugVerbose|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|x86.ActiveCfg = DebugVerbose|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|x86.Build.0 = DebugVerbose|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|Any CPU.Build.0 = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|x64.ActiveCfg = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|x64.Build.0 = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|x86.ActiveCfg = Release|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|x86.Build.0 = Release|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.ReleaseX|Any CPU.ActiveCfg = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.ReleaseX|Any CPU.Build.0 = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.ReleaseX|x64.ActiveCfg = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.ReleaseX|x64.Build.0 = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.ReleaseX|x86.ActiveCfg = Release|x86
		{178417EC-1177-413E-BE85-C83AECD64279}.ReleaseX|x86.Build.0 = Release|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|x64.ActiveCfg = Debug|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|x64.Build.0 = Debug|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|x86.ActiveCfg = Debug|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|x86.Build.0 = Debug|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|Any CPU.ActiveCfg = DebugTracing|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|Any CPU.Build.0 = DebugTracing|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|x64.ActiveCfg = DebugTracing|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|x64.Build.0 = DebugTracing|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|x86.ActiveCfg = DebugTracing|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|x86.Build.0 = DebugTracing|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|Any CPU.ActiveCfg = DebugVerbose|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|Any CPU.Build.0 = DebugVerbose|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|x64.ActiveCfg = DebugVerbose|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|x64.Build.0 = DebugVerbose|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|x86.ActiveCfg = DebugVerbose|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|x86.Build.0 = DebugVerbose|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|Any CPU.Build.0 = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|x64.ActiveCfg = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|x64.Build.0 = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|x86.ActiveCfg = Release|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|x86.Build.0 = Release|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.ReleaseX|Any CPU.ActiveCfg = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.ReleaseX|Any CPU.Build.0 = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.ReleaseX|x64.ActiveCfg = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.ReleaseX|x64.Build.0 = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.ReleaseX|x86.ActiveCfg = Release|x86
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.ReleaseX|x86.Build.0 = Release|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Debug|x64.ActiveCfg = Debug|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Debug|x64.Build.0 = Debug|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Debug|x86.ActiveCfg = Debug|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Debug|x86.Build.0 = Debug|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugTracing|Any CPU.ActiveCfg = DebugTracing|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugTracing|Any CPU.Build.0 = DebugTracing|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugTracing|x64.ActiveCfg = DebugTracing|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugTracing|x64.Build.0 = DebugTracing|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugTracing|x86.ActiveCfg = DebugTracing|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugTracing|x86.Build.0 = DebugTracing|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugVerbose|Any CPU.ActiveCfg = DebugVerbose|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugVerbose|Any CPU.Build.0 = DebugVerbose|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugVerbose|x64.ActiveCfg = DebugVerbose|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugVerbose|x64.Build.0 = DebugVerbose|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugVerbose|x86.ActiveCfg = DebugVerbose|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.DebugVerbose|x86.Build.0 = DebugVerbose|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Release|Any CPU.Build.0 = Release|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Release|x64.ActiveCfg = Release|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Release|x64.Build.0 = Release|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Release|x86.ActiveCfg = Release|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.Release|x86.Build.0 = Release|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.ReleaseX|Any CPU.ActiveCfg = ReleaseX|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.ReleaseX|Any CPU.Build.0 = ReleaseX|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.ReleaseX|x64.ActiveCfg = ReleaseX|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.ReleaseX|x64.Build.0 = ReleaseX|Any CPU
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.ReleaseX|x86.ActiveCfg = ReleaseX|x86
		{88A998F1-C512-416F-ADED-120E50AFE6F3}.ReleaseX|x86.Build.0 = ReleaseX|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|x64.Build.0 = Debug|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|x86.ActiveCfg = Debug|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|x86.Build.0 = Debug|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|Any CPU.ActiveCfg = DebugTracing|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|Any CPU.Build.0 = DebugTracing|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|x64.ActiveCfg = DebugTracing|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|x64.Build.0 = DebugTracing|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|x86.ActiveCfg = DebugTracing|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|x86.Build.0 = DebugTracing|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|Any CPU.ActiveCfg = DebugVerbose|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|Any CPU.Build.0 = DebugVerbose|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|x64.ActiveCfg = DebugVerbose|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|x64.Build.0 = DebugVerbose|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|x86.ActiveCfg = DebugVerbose|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|x86.Build.0 = DebugVerbose|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|Any CPU.Build.0 = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|x64.ActiveCfg = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|x64.Build.0 = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|x86.ActiveCfg = Release|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|x86.Build.0 = Release|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.ReleaseX|Any CPU.ActiveCfg = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.ReleaseX|Any CPU.Build.0 = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.ReleaseX|x64.ActiveCfg = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.ReleaseX|x64.Build.0 = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.ReleaseX|x86.ActiveCfg = Release|x86
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.ReleaseX|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7A4553E8-6A4B-46A5-B429-7F9128492CAD}
	EndGlobalSection
EndGlobal

```

`UAssetGUI/AboutForm.Designer.cs`:

```cs

namespace UAssetGUI
{
    partial class AboutForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.closeButton = new System.Windows.Forms.Button();
            this.licenseButton = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.noticeButton = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // closeButton
            // 
            this.closeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.closeButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.closeButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.closeButton.ForeColor = System.Drawing.SystemColors.ControlText;
            this.closeButton.Location = new System.Drawing.Point(320, 274);
            this.closeButton.Name = "closeButton";
            this.closeButton.Size = new System.Drawing.Size(75, 26);
            this.closeButton.TabIndex = 4;
            this.closeButton.Text = "Close";
            this.closeButton.UseVisualStyleBackColor = true;
            this.closeButton.Click += new System.EventHandler(this.closeButton_Click);
            // 
            // licenseButton
            // 
            this.licenseButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.licenseButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.licenseButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.licenseButton.ForeColor = System.Drawing.SystemColors.ControlText;
            this.licenseButton.Location = new System.Drawing.Point(12, 274);
            this.licenseButton.Name = "licenseButton";
            this.licenseButton.Size = new System.Drawing.Size(103, 26);
            this.licenseButton.TabIndex = 2;
            this.licenseButton.Text = "View license...";
            this.licenseButton.UseVisualStyleBackColor = true;
            this.licenseButton.Click += new System.EventHandler(this.licenseButton_Click);
            // 
            // label1
            // 
            this.label1.Dock = System.Windows.Forms.DockStyle.Top;
            this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F);
            this.label1.Location = new System.Drawing.Point(0, 0);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(407, 271);
            this.label1.TabIndex = 1;
            this.label1.Text = "AboutText should be overridden before displaying this form";
            this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // noticeButton
            // 
            this.noticeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.noticeButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.noticeButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.noticeButton.ForeColor = System.Drawing.SystemColors.ControlText;
            this.noticeButton.Location = new System.Drawing.Point(121, 274);
            this.noticeButton.Name = "noticeButton";
            this.noticeButton.Size = new System.Drawing.Size(161, 26);
            this.noticeButton.TabIndex = 3;
            this.noticeButton.Text = "View 3rd-party software...";
            this.noticeButton.UseVisualStyleBackColor = true;
            this.noticeButton.Click += new System.EventHandler(this.noticeButton_Click);
            // 
            // AboutForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(407, 312);
            this.Controls.Add(this.noticeButton);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.licenseButton);
            this.Controls.Add(this.closeButton);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.Name = "AboutForm";
            this.Text = "About";
            this.Load += new System.EventHandler(this.AboutForm_Load);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Button closeButton;
        private System.Windows.Forms.Button licenseButton;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Button noticeButton;
    }
}
```

`UAssetGUI/AboutForm.cs`:

```cs
using System;
using System.IO;
using System.Reflection;
using System.Windows.Forms;

namespace UAssetGUI
{
    public partial class AboutForm : Form
    {
        public string AboutText
        {
            get
            {
                return label1.Text;
            }
            set
            {
                label1.Text = value;
            }
        }

        public AboutForm()
        {
            InitializeComponent();
        }

        private Form1 BaseForm;
        private void AboutForm_Load(object sender, EventArgs e)
        {
            if (this.Owner is Form1) BaseForm = (Form1)this.Owner;

            UAGPalette.RefreshTheme(this);
            this.AdjustFormPosition();
        }

        private void closeButton_Click(object sender, EventArgs e)
        {
            this.Dispose();
        }

        private void licenseButton_Click(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                string rawMarkdownText = string.Empty;
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("UAssetGUI.LICENSE"))
                {
                    if (stream != null)
                    {
                        using (StreamReader reader = new StreamReader(stream))
                        {
                            if (reader != null) rawMarkdownText = reader.ReadToEnd().Trim();
                        }
                    }
                }

                if (string.IsNullOrEmpty(rawMarkdownText))
                {
                    UAGUtils.OpenURL("https://github.com/" + Form1.GitHubRepo + "/blob/master/LICENSE");
                    return;
                }

                var formPopup = new MarkdownViewer();
                formPopup.MarkdownToDisplay = "```\n" + rawMarkdownText + "\n```";
                formPopup.Text = "License";
                formPopup.StartPosition = FormStartPosition.CenterParent;
                formPopup.ShowDialog(this);
            });
        }

        private void noticeButton_Click(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                string rawMarkdownText = string.Empty;
                using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("UAssetGUI.NOTICE.md"))
                {
                    if (stream != null)
                    {
                        using (StreamReader reader = new StreamReader(stream))
                        {
                            if (reader != null) rawMarkdownText = reader.ReadToEnd().Trim();
                        }
                    }
                }

                if (string.IsNullOrEmpty(rawMarkdownText))
                {
                    UAGUtils.OpenURL("https://github.com/" + Form1.GitHubRepo + "/blob/master/NOTICE.md");
                    return;
                }

                var formPopup = new MarkdownViewer();
                formPopup.MarkdownToDisplay = rawMarkdownText;
                formPopup.Text = "List of 3rd-party software";
                formPopup.StartPosition = FormStartPosition.CenterParent;
                formPopup.ShowDialog(this);
            });
        }
    }
}

```

`UAssetGUI/AboutForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UAssetGUI/ColorfulTreeView.cs`:

```cs
using System.Drawing;
using System.Windows.Forms;

namespace UAssetGUI
{
    public class ColorfulTreeView : TreeView
    {
        public ColorfulTreeView() : base()
        {
            this.DrawMode = TreeViewDrawMode.OwnerDrawText;
            NodeMouseClick += (sender, args) => { if (args.Button == MouseButtons.Right) SelectedNode = args.Node; };
        }

        protected override void OnDrawNode(DrawTreeNodeEventArgs e)
        {
            if (!e.Node.IsVisible) return;
            if (e.Node.Bounds.IsEmpty) return;

            Font font = e.Node.NodeFont ?? e.Node.TreeView.Font;
            Color fore = e.Node.ForeColor;
            if (fore == Color.Empty) fore = e.Node.TreeView.ForeColor;
            if (e.Node == e.Node.TreeView.SelectedNode)
            {
                fore = UAGPalette.HighlightForeColor;
                e.Graphics.FillRectangle(new SolidBrush(UAGPalette.HighlightBackColor), e.Bounds);
                ControlPaint.DrawFocusRectangle(e.Graphics, e.Bounds, fore, UAGPalette.HighlightBackColor);
                TextRenderer.DrawText(e.Graphics, e.Node.Text, font, e.Bounds, fore, UAGPalette.HighlightBackColor, TextFormatFlags.GlyphOverhangPadding);
            }
            else
            {
                e.Graphics.FillRectangle(new SolidBrush(UAGPalette.BackColor), e.Bounds);
                TextRenderer.DrawText(e.Graphics, e.Node.Text, font, e.Bounds, fore, TextFormatFlags.GlyphOverhangPadding);
            }
        }
    }
}

```

`UAssetGUI/FileContainerForm.Designer.cs`:

```cs
using System.Windows.Forms;

namespace UAssetGUI
{
    partial class FileContainerForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            splitContainer1 = new SplitContainer();
            loadButton = new Button();
            loadTreeView = new ColorfulTreeView();
            saveButton = new Button();
            saveTreeView = new ColorfulTreeView();
            menuStrip1 = new MenuStrip();
            fileToolStripMenuItem = new ToolStripMenuItem();
            loadToolStripMenuItem = new ToolStripMenuItem();
            saveToolStripMenuItem = new ToolStripMenuItem();
            stageFromDiskToolStripMenuItem = new ToolStripMenuItem();
            stageFromDiskToPathToolStripMenuItem = new ToolStripMenuItem();
            editToolStripMenuItem = new ToolStripMenuItem();
            cutToolStripMenuItem = new ToolStripMenuItem();
            copyToolStripMenuItem = new ToolStripMenuItem();
            pasteToolStripMenuItem = new ToolStripMenuItem();
            deleteToolStripMenuItem = new ToolStripMenuItem();
            viewToolStripMenuItem = new ToolStripMenuItem();
            expandAllToolStripMenuItem = new ToolStripMenuItem();
            collapseAllToolStripMenuItem = new ToolStripMenuItem();
            toggleFlatViewToolStripMenuItem = new ToolStripMenuItem();
            applyFilterToolStripMenuItem = new ToolStripMenuItem();
            refreshToolStripMenuItem = new ToolStripMenuItem();
            utilsToolStripMenuItem = new ToolStripMenuItem();
            extractAllToolStripMenuItem = new ToolStripMenuItem();
            extractAllBackgroundWorker = new System.ComponentModel.BackgroundWorker();
            setRetocCommandLineParametersToolStripMenuItem = new ToolStripMenuItem();
            ((System.ComponentModel.ISupportInitialize)splitContainer1).BeginInit();
            splitContainer1.Panel1.SuspendLayout();
            splitContainer1.Panel2.SuspendLayout();
            splitContainer1.SuspendLayout();
            menuStrip1.SuspendLayout();
            SuspendLayout();
            // 
            // splitContainer1
            // 
            splitContainer1.Dock = DockStyle.Top;
            splitContainer1.Location = new System.Drawing.Point(6, 30);
            splitContainer1.Margin = new Padding(4, 3, 4, 3);
            splitContainer1.Name = "splitContainer1";
            // 
            // splitContainer1.Panel1
            // 
            splitContainer1.Panel1.Controls.Add(loadButton);
            splitContainer1.Panel1.Controls.Add(loadTreeView);
            // 
            // splitContainer1.Panel2
            // 
            splitContainer1.Panel2.Controls.Add(saveButton);
            splitContainer1.Panel2.Controls.Add(saveTreeView);
            splitContainer1.Size = new System.Drawing.Size(828, 448);
            splitContainer1.SplitterDistance = 406;
            splitContainer1.TabIndex = 1;
            splitContainer1.SplitterMoved += splitContainer1_SplitterMoved;
            // 
            // loadButton
            // 
            loadButton.Anchor = AnchorStyles.Top;
            loadButton.FlatStyle = FlatStyle.Flat;
            loadButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            loadButton.ForeColor = System.Drawing.SystemColors.ControlText;
            loadButton.Location = new System.Drawing.Point(145, 3);
            loadButton.Margin = new Padding(4, 3, 4, 3);
            loadButton.Name = "loadButton";
            loadButton.Size = new System.Drawing.Size(120, 42);
            loadButton.TabIndex = 3;
            loadButton.Text = "Load...";
            loadButton.UseVisualStyleBackColor = true;
            loadButton.Click += loadButton_Click;
            // 
            // loadTreeView
            // 
            loadTreeView.AllowDrop = true;
            loadTreeView.BackColor = System.Drawing.Color.LightGray;
            loadTreeView.DrawMode = TreeViewDrawMode.OwnerDrawText;
            loadTreeView.Location = new System.Drawing.Point(0, 51);
            loadTreeView.Name = "loadTreeView";
            loadTreeView.Size = new System.Drawing.Size(408, 394);
            loadTreeView.TabIndex = 0;
            loadTreeView.BeforeExpand += treeView_BeforeExpand;
            loadTreeView.NodeMouseClick += loadTreeView_NodeMouseClick;
            loadTreeView.NodeMouseDoubleClick += treeView_NodeMouseDoubleClick;
            // 
            // saveButton
            // 
            saveButton.Anchor = AnchorStyles.Top;
            saveButton.FlatStyle = FlatStyle.Flat;
            saveButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            saveButton.ForeColor = System.Drawing.SystemColors.ControlText;
            saveButton.Location = new System.Drawing.Point(147, 3);
            saveButton.Margin = new Padding(4, 3, 4, 3);
            saveButton.Name = "saveButton";
            saveButton.Size = new System.Drawing.Size(120, 42);
            saveButton.TabIndex = 4;
            saveButton.Text = "Save...";
            saveButton.UseVisualStyleBackColor = true;
            saveButton.Click += saveButton_Click;
            // 
            // saveTreeView
            // 
            saveTreeView.AllowDrop = true;
            saveTreeView.BackColor = System.Drawing.Color.LightGray;
            saveTreeView.DrawMode = TreeViewDrawMode.OwnerDrawText;
            saveTreeView.Location = new System.Drawing.Point(0, 51);
            saveTreeView.Name = "saveTreeView";
            saveTreeView.Size = new System.Drawing.Size(416, 397);
            saveTreeView.TabIndex = 0;
            saveTreeView.BeforeExpand += treeView_BeforeExpand;
            saveTreeView.NodeMouseClick += saveTreeView_NodeMouseClick;
            saveTreeView.NodeMouseDoubleClick += treeView_NodeMouseDoubleClick;
            // 
            // menuStrip1
            // 
            menuStrip1.ImageScalingSize = new System.Drawing.Size(24, 24);
            menuStrip1.Items.AddRange(new ToolStripItem[] { fileToolStripMenuItem, editToolStripMenuItem, viewToolStripMenuItem, utilsToolStripMenuItem });
            menuStrip1.Location = new System.Drawing.Point(6, 6);
            menuStrip1.Name = "menuStrip1";
            menuStrip1.Padding = new Padding(7, 2, 0, 2);
            menuStrip1.Size = new System.Drawing.Size(828, 24);
            menuStrip1.TabIndex = 2;
            menuStrip1.Text = "menuStrip1";
            // 
            // fileToolStripMenuItem
            // 
            fileToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { loadToolStripMenuItem, saveToolStripMenuItem, stageFromDiskToolStripMenuItem, stageFromDiskToPathToolStripMenuItem });
            fileToolStripMenuItem.Name = "fileToolStripMenuItem";
            fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
            fileToolStripMenuItem.Text = "File";
            // 
            // loadToolStripMenuItem
            // 
            loadToolStripMenuItem.Name = "loadToolStripMenuItem";
            loadToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.O;
            loadToolStripMenuItem.Size = new System.Drawing.Size(206, 22);
            loadToolStripMenuItem.Text = "Open";
            loadToolStripMenuItem.Click += loadToolStripMenuItem_Click;
            // 
            // saveToolStripMenuItem
            // 
            saveToolStripMenuItem.Name = "saveToolStripMenuItem";
            saveToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.S;
            saveToolStripMenuItem.Size = new System.Drawing.Size(206, 22);
            saveToolStripMenuItem.Text = "Save";
            saveToolStripMenuItem.Click += saveToolStripMenuItem_Click;
            // 
            // stageFromDiskToolStripMenuItem
            // 
            stageFromDiskToolStripMenuItem.Name = "stageFromDiskToolStripMenuItem";
            stageFromDiskToolStripMenuItem.Size = new System.Drawing.Size(206, 22);
            stageFromDiskToolStripMenuItem.Text = "Stage from disk...";
            stageFromDiskToolStripMenuItem.Click += stageFromDiskToolStripMenuItem_Click;
            // 
            // stageFromDiskToPathToolStripMenuItem
            // 
            stageFromDiskToPathToolStripMenuItem.Name = "stageFromDiskToPathToolStripMenuItem";
            stageFromDiskToPathToolStripMenuItem.Size = new System.Drawing.Size(206, 22);
            stageFromDiskToPathToolStripMenuItem.Text = "Stage from disk to path...";
            stageFromDiskToPathToolStripMenuItem.Click += stageFromDiskToPathToolStripMenuItem_Click;
            // 
            // editToolStripMenuItem
            // 
            editToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { cutToolStripMenuItem, copyToolStripMenuItem, pasteToolStripMenuItem, deleteToolStripMenuItem });
            editToolStripMenuItem.Name = "editToolStripMenuItem";
            editToolStripMenuItem.Size = new System.Drawing.Size(39, 20);
            editToolStripMenuItem.Text = "Edit";
            // 
            // cutToolStripMenuItem
            // 
            cutToolStripMenuItem.Name = "cutToolStripMenuItem";
            cutToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            cutToolStripMenuItem.Text = "Cut";
            cutToolStripMenuItem.Click += cutToolStripMenuItem_Click;
            // 
            // copyToolStripMenuItem
            // 
            copyToolStripMenuItem.Name = "copyToolStripMenuItem";
            copyToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            copyToolStripMenuItem.Text = "Copy";
            copyToolStripMenuItem.Click += copyToolStripMenuItem_Click;
            // 
            // pasteToolStripMenuItem
            // 
            pasteToolStripMenuItem.Name = "pasteToolStripMenuItem";
            pasteToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            pasteToolStripMenuItem.Text = "Paste";
            pasteToolStripMenuItem.Click += pasteToolStripMenuItem_Click;
            // 
            // deleteToolStripMenuItem
            // 
            deleteToolStripMenuItem.Name = "deleteToolStripMenuItem";
            deleteToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            deleteToolStripMenuItem.Text = "Delete";
            deleteToolStripMenuItem.Click += deleteToolStripMenuItem_Click;
            // 
            // viewToolStripMenuItem
            // 
            viewToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { expandAllToolStripMenuItem, collapseAllToolStripMenuItem, toggleFlatViewToolStripMenuItem, applyFilterToolStripMenuItem, refreshToolStripMenuItem });
            viewToolStripMenuItem.Name = "viewToolStripMenuItem";
            viewToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
            viewToolStripMenuItem.Text = "View";
            // 
            // expandAllToolStripMenuItem
            // 
            expandAllToolStripMenuItem.Name = "expandAllToolStripMenuItem";
            expandAllToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.M;
            expandAllToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            expandAllToolStripMenuItem.Text = "Expand All";
            expandAllToolStripMenuItem.Click += expandAllToolStripMenuItem_Click;
            // 
            // collapseAllToolStripMenuItem
            // 
            collapseAllToolStripMenuItem.Name = "collapseAllToolStripMenuItem";
            collapseAllToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.L;
            collapseAllToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            collapseAllToolStripMenuItem.Text = "Collapse All";
            collapseAllToolStripMenuItem.Click += collapseAllToolStripMenuItem_Click;
            // 
            // toggleFlatViewToolStripMenuItem
            // 
            toggleFlatViewToolStripMenuItem.Name = "toggleFlatViewToolStripMenuItem";
            toggleFlatViewToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            toggleFlatViewToolStripMenuItem.Text = "Toggle flat view";
            toggleFlatViewToolStripMenuItem.Click += toggleFlatViewToolStripMenuItem_Click;
            // 
            // applyFilterToolStripMenuItem
            // 
            applyFilterToolStripMenuItem.Name = "applyFilterToolStripMenuItem";
            applyFilterToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            applyFilterToolStripMenuItem.Text = "Apply filter...";
            applyFilterToolStripMenuItem.Click += applyFilterToolStripMenuItem_Click;
            // 
            // refreshToolStripMenuItem
            // 
            refreshToolStripMenuItem.Name = "refreshToolStripMenuItem";
            refreshToolStripMenuItem.ShortcutKeys = Keys.F5;
            refreshToolStripMenuItem.Size = new System.Drawing.Size(180, 22);
            refreshToolStripMenuItem.Text = "Refresh";
            refreshToolStripMenuItem.Click += refreshToolStripMenuItem_Click;
            // 
            // utilsToolStripMenuItem
            // 
            utilsToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { extractAllToolStripMenuItem, setRetocCommandLineParametersToolStripMenuItem });
            utilsToolStripMenuItem.Name = "utilsToolStripMenuItem";
            utilsToolStripMenuItem.Size = new System.Drawing.Size(42, 20);
            utilsToolStripMenuItem.Text = "Utils";
            // 
            // extractAllToolStripMenuItem
            // 
            extractAllToolStripMenuItem.Name = "extractAllToolStripMenuItem";
            extractAllToolStripMenuItem.Size = new System.Drawing.Size(271, 22);
            extractAllToolStripMenuItem.Text = "Extract all...";
            extractAllToolStripMenuItem.Click += extractAllToolStripMenuItem_Click;
            // 
            // extractAllBackgroundWorker
            // 
            extractAllBackgroundWorker.WorkerReportsProgress = true;
            extractAllBackgroundWorker.WorkerSupportsCancellation = true;
            extractAllBackgroundWorker.DoWork += extractAllBackgroundWorker_DoWork;
            extractAllBackgroundWorker.ProgressChanged += extractAllBackgroundWorker_ProgressChanged;
            extractAllBackgroundWorker.RunWorkerCompleted += extractAllBackgroundWorker_RunWorkerCompleted;
            // 
            // setRetocCommandLineParametersToolStripMenuItem
            // 
            setRetocCommandLineParametersToolStripMenuItem.Name = "setRetocCommandLineParametersToolStripMenuItem";
            setRetocCommandLineParametersToolStripMenuItem.Size = new System.Drawing.Size(271, 22);
            setRetocCommandLineParametersToolStripMenuItem.Text = "Set extra retoc command line parameters...";
            setRetocCommandLineParametersToolStripMenuItem.Click += setRetocCommandLineParametersToolStripMenuItem_Click;
            // 
            // FileContainerForm
            // 
            AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            AutoScaleMode = AutoScaleMode.Font;
            ClientSize = new System.Drawing.Size(840, 487);
            Controls.Add(splitContainer1);
            Controls.Add(menuStrip1);
            Name = "FileContainerForm";
            Padding = new Padding(6);
            Text = "UAssetGUI";
            Load += FileContainerForm_Load;
            Shown += FileContainerForm_Shown;
            SizeChanged += FileContainerForm_SizeChanged;
            splitContainer1.Panel1.ResumeLayout(false);
            splitContainer1.Panel2.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)splitContainer1).EndInit();
            splitContainer1.ResumeLayout(false);
            menuStrip1.ResumeLayout(false);
            menuStrip1.PerformLayout();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion
        internal ColorfulTreeView saveTreeView;
        internal ColorfulTreeView loadTreeView;
        internal System.Windows.Forms.SplitContainer splitContainer1;
        private System.Windows.Forms.Button loadButton;
        private System.Windows.Forms.Button saveButton;
        private System.Windows.Forms.ToolStripMenuItem editToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem copyToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem pasteToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem deleteToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem viewToolStripMenuItem;
        internal System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem loadToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem stageFromDiskToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem saveToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem expandAllToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem collapseAllToolStripMenuItem;
        private ToolStripMenuItem refreshToolStripMenuItem;
        private ToolStripMenuItem cutToolStripMenuItem;
        private ToolStripMenuItem utilsToolStripMenuItem;
        private ToolStripMenuItem extractAllToolStripMenuItem;
        internal System.ComponentModel.BackgroundWorker extractAllBackgroundWorker;
        private ToolStripMenuItem stageFromDiskToPathToolStripMenuItem;
        private ToolStripMenuItem toggleFlatViewToolStripMenuItem;
        private ToolStripMenuItem applyFilterToolStripMenuItem;
        private ToolStripMenuItem setRetocCommandLineParametersToolStripMenuItem;
    }
}
```

`UAssetGUI/FileContainerForm.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using UAssetAPI;
using UAssetAPI.UnrealTypes;

namespace UAssetGUI
{
    public enum InteropType
    {
        Pak,
        Retoc
    }

    public enum RetocEngineVersion
    {
        UE4_25 = EngineVersion.VER_UE4_25,
        UE4_26 = EngineVersion.VER_UE4_26,
        UE4_27 = EngineVersion.VER_UE4_27,
        UE5_0 = EngineVersion.VER_UE5_0,
        UE5_1 = EngineVersion.VER_UE5_1,
        UE5_2 = EngineVersion.VER_UE5_2,
        UE5_3 = EngineVersion.VER_UE5_3,
        UE5_4 = EngineVersion.VER_UE5_4,
        UE5_5 = EngineVersion.VER_UE5_5,
        UE5_6 = EngineVersion.VER_UE5_6,
        UE5_7 = EngineVersion.VER_UE5_7,
    }

    public struct RetocManifest
    {
        [JsonProperty("oplog")]
        public RetocOpLog OpLog;
    }

    public struct RetocOpLog
    {
        [JsonProperty("entries")]
        public List<RetocOp> Entries;
    }

    public struct RetocOp
    {
        [JsonProperty("packagestoreentry")]
        public RetocPackageStoreEntry PackageStoreEntry;
        [JsonProperty("packagedata")]
        public List<RetocChunkData> PackageData;
        [JsonProperty("bulkdata")]
        public List<RetocChunkData> BulkData;
    }

    public struct RetocPackageStoreEntry
    {
        [JsonProperty("packagename")]
        public string PackageName;
    }

    public struct RetocChunkData
    {
        [JsonProperty("id")]
        public string ID;
        [JsonProperty("filename")]
        public string FileName;
    }

    public partial class FileContainerForm : Form
    {
        public IDictionary<TreeView, DirectoryTree> DirectoryTreeMap = new Dictionary<TreeView, DirectoryTree>();
        public string CurrentContainerPath;
        public IDictionary<TreeView, bool> FlatViewEnabled = new Dictionary<TreeView, bool>();
        public IDictionary<TreeView, string> Filter = new Dictionary<TreeView, string>();
        public PakVersion Version = PakVersion.V4;
        public InteropType InteropType = InteropType.Pak;
        public string MountPoint = "../../../";
        public static string RetocExtraCommands
        {
            get { return UAGConfig.Data.RetocExtraCommands; }
            set { UAGConfig.Data.RetocExtraCommands = value; UAGConfig.Save(); }
        }

        public FileContainerForm()
        {
            InitializeComponent();
        }

        public Form1 BaseForm;
        public TreeView SelectedTreeView;
        private void FileContainerForm_Load(object sender, EventArgs e)
        {
            this.Text = BaseForm.DisplayVersion;

            UAGPalette.RefreshTheme(this);
            this.AdjustFormPosition(BaseForm);

            this.cutToolStripMenuItem.ShortcutKeyDisplayString = UAGUtils.ShortcutToText(Keys.Control | Keys.X);
            this.copyToolStripMenuItem.ShortcutKeyDisplayString = UAGUtils.ShortcutToText(Keys.Control | Keys.C);
            this.pasteToolStripMenuItem.ShortcutKeyDisplayString = UAGUtils.ShortcutToText(Keys.Control | Keys.V);
            this.deleteToolStripMenuItem.ShortcutKeyDisplayString = UAGUtils.ShortcutToText(Keys.Delete);

            this.loadTreeView.AllowDrop = true;
            this.loadTreeView.DragEnter += new DragEventHandler(event_DragEnter);
            this.loadTreeView.DragDrop += new DragEventHandler(loadTreeView_DragDrop);
            this.saveTreeView.AllowDrop = true;
            this.saveTreeView.DragEnter += new DragEventHandler(event_DragEnter);
            this.saveTreeView.DragDrop += new DragEventHandler(saveTreeView_DragDrop);

            menuStrip1.Renderer = new UAGMenuStripRenderer();
            foreach (ToolStripMenuItem entry in menuStrip1.Items)
            {
                entry.DropDownOpened += (sender, args) =>
                {
                    isDropDownOpened[entry] = true;
                };
                entry.DropDownClosed += (sender, args) =>
                {
                    isDropDownOpened[entry] = false;
                };
            }

            // extract repak_bind.dll if available
            string libsPath = Path.Combine(UAGConfig.ConfigFolder, "Libraries");
            string repakBindPath = Path.Combine(libsPath, "repak_bind.dll");
            if (!HasAlreadyExtractedRepak || !File.Exists(repakBindPath))
            {
                HasAlreadyExtractedRepak = true;
                Program.ExtractCompressedResource("UAssetAPI.repak_bind.dll.gz", repakBindPath, typeof(UAsset).Assembly);
                if (File.Exists(repakBindPath)) NativeLibrary.Load(repakBindPath);
            }

            LoadContainer(CurrentContainerPath);
            RefreshTreeView(saveTreeView);
        }

        private static volatile Dictionary<ToolStripItem, bool> isDropDownOpened = new Dictionary<ToolStripItem, bool>();
        public static bool IsDropDownOpened(ToolStripItem item)
        {
            if (!isDropDownOpened.ContainsKey(item)) return false;
            return isDropDownOpened[item];
        }

        public void AddDirectoryItemChildrenToTreeView(DirectoryTreeItem treeItem, PointingFileTreeNode dad, string filter, bool forceAddChildrenOfChildren = false, bool disableDynamicTree = false)
        {
            if (!UAGConfig.Data.EnableDynamicTree) disableDynamicTree = true;
            dad.ChildrenInitialized = forceAddChildrenOfChildren || disableDynamicTree;
            foreach (KeyValuePair<string, DirectoryTreeItem> directoryItem in treeItem.Children)
            {
                if (directoryItem.Value.Children.Count > 0 || string.IsNullOrEmpty(filter) || directoryItem.Value.FullPath.Contains(filter))
                {
                    var newDad = new PointingFileTreeNode(directoryItem.Value.Name, directoryItem.Value);
                    newDad.ChildrenInitialized = false;
                    dad.Nodes.Add(newDad);
                    if (dad.ChildrenInitialized) AddDirectoryItemChildrenToTreeView(directoryItem.Value, newDad, filter, false, disableDynamicTree);
                }
            }
        }

        public void ExpandedToHashSet(TreeNodeCollection nodes, HashSet<string> hashSet)
        {
            foreach (TreeNode node in nodes)
            {
                if (node is PointingFileTreeNode pftNode)
                {
                    if (pftNode.IsExpanded) hashSet.Add(pftNode.Pointer.FullPath);
                    ExpandedToHashSet(pftNode.Nodes, hashSet);
                }
            }
        }

        // this method doesn't collapse already-expanded nodes
        public void HashSetToExpanded(TreeNodeCollection nodes, HashSet<string> hashSet)
        {
            foreach (TreeNode node in nodes)
            {
                if (node is PointingFileTreeNode pftNode)
                {
                    if (hashSet.Contains(pftNode.Pointer.FullPath)) pftNode.Expand();
                    HashSetToExpanded(pftNode.Nodes, hashSet);
                }
            }
        }

        public PointingFileTreeNode GetSpecificNode(TreeNodeCollection nodes, string fullPath)
        {
            foreach (TreeNode node in nodes)
            {
                if (node is PointingFileTreeNode pftNode)
                {
                    if (fullPath == pftNode.Pointer.FullPath) return pftNode;
                    if (fullPath.StartsWith(pftNode.Pointer.FullPath)) // we know this is an ancestor node
                    {
                        if (!pftNode.ChildrenInitialized) InitializeChildren(pftNode);
                        var gotten = GetSpecificNode(node.Nodes, fullPath);
                        if (gotten != null) return gotten;
                        break; // obviously no sibling node to this node can be also an ancestor node
                    }
                }
            }
            return null;
        }

        public PointingFileTreeNode GetSpecificNode(TreeView treeView, string fullPath)
        {
            return GetSpecificNode(treeView.Nodes, fullPath);
        }

        public PointingFileTreeNode GetSpecificNode(string fullPath)
        {
            var res = GetSpecificNode(loadTreeView, fullPath);
            if (res != null) return res;
            res = GetSpecificNode(saveTreeView, fullPath);
            if (res != null) return res;

            return null;
        }

        public DirectoryTreeItem GetFromPackageName(TreeView treeView, string packageName)
        {
            DirectoryTree tree = DirectoryTreeMap[treeView];
            if (tree?.PackagePathToNode == null || !tree.PackagePathToNode.ContainsKey(packageName)) return null;
            return tree.PackagePathToNode[packageName];
        }

        public void RefreshTreeView(TreeView treeView)
        {
            if (!FlatViewEnabled.ContainsKey(treeView)) FlatViewEnabled[treeView] = false;
            UAGUtils.InvokeUI(() => RefreshTreeViewInner(treeView, FlatViewEnabled[treeView]));
        }

        private int PruneChildren(PointingFileTreeNode branchNode)
        {
            if (branchNode?.Nodes == null) return 0;

            int n = 0;
            for (int nodeIdx = 0; nodeIdx < branchNode.Nodes.Count; nodeIdx++)
            {
                if (branchNode.Nodes[nodeIdx] != null && branchNode.Nodes[nodeIdx] is PointingFileTreeNode pftn)
                {
                    if (pftn.Pointer == null) continue;
                    if (!pftn.Pointer.IsFile && pftn.Nodes.Count == 0)
                    {
                        // directories with no children need to be removed
                        branchNode.Nodes.RemoveAt(nodeIdx);
                        n++;
                        nodeIdx--;
                    }
                    else
                    {
                        n += PruneChildren(pftn);
                    }
                }
            }
            return n;
        }

        private void RefreshTreeViewInner(TreeView treeView, bool flatView)
        {
            treeView.SuspendLayout();

            // get existing expanded nodes
            HashSet<string> FullPathsOfNodesToExpand = new HashSet<string>();
            ExpandedToHashSet(treeView.Nodes, FullPathsOfNodesToExpand);

            if (treeView == saveTreeView)
            {
                // update directory tree
                string[] stagingFiles = UAGConfig.GetStagingFiles(this.CurrentContainerPath, out string[] fixedPathsOnDisk);
                DirectoryTreeMap[treeView] = new DirectoryTree(this, stagingFiles, fixedPathsOnDisk);
            }

            if (!Filter.ContainsKey(treeView)) Filter[treeView] = null;
            string filter = Filter[treeView];
            bool filterExists = !string.IsNullOrEmpty(filter);

            treeView.Nodes.Clear();
            DirectoryTree currentTree = DirectoryTreeMap[treeView];
            if (flatView && currentTree?.RootNodesFlat != null)
            {
                List<TreeNode> nodes = new List<TreeNode>();
                foreach (KeyValuePair<string, DirectoryTreeItem> directoryItem in currentTree.RootNodesFlat.OrderBy(p => p.Value.FullPath))
                {
                    // we can just filter here because in flat view nodes never have children
                    if (string.IsNullOrEmpty(filter) || directoryItem.Value.FullPath.Contains(filter))
                    {
                        var dad = new PointingFileTreeNode(directoryItem.Value.FullPath, directoryItem.Value);
                        nodes.Add(dad);
                    }
                }
                treeView.Nodes.AddRange(nodes.ToArray());
            }
            else
            {
                if (currentTree?.RootNodes != null)
                {
                    List<PointingFileTreeNode> nodes = new List<PointingFileTreeNode>();
                    foreach (KeyValuePair<string, DirectoryTreeItem> directoryItem in currentTree.RootNodes)
                    {
                        var dad = new PointingFileTreeNode(directoryItem.Value.Name, directoryItem.Value);
                        nodes.Add(dad);
                        AddDirectoryItemChildrenToTreeView(directoryItem.Value, dad, filter, false, filterExists); // disable dynamic tree if filtering
                    }

                    // filter has been applied to files, but we need to prune empty branches now
                    if (filterExists)
                    {
                        for (int iter = 0; iter < 20; iter++) // max 20 iterations
                        {
                            int numPruned = 0;
                            for (int nodeIdx = 0; nodeIdx < nodes.Count; nodeIdx++)
                            {
                                if (nodes[nodeIdx] != null && nodes[nodeIdx] is PointingFileTreeNode pftn)
                                {
                                    if (pftn.Pointer == null) continue;
                                    if (!pftn.Pointer.IsFile && pftn.Nodes.Count == 0)
                                    {
                                        // directories with no children need to be removed
                                        nodes.RemoveAt(nodeIdx);
                                        numPruned++;
                                        nodeIdx--;
                                    }
                                    else
                                    {
                                        numPruned += PruneChildren(pftn);
                                    }
                                }
                            }

                            if (numPruned == 0) break; // nothing else to prune
                        }
                    }

                    treeView.Nodes.AddRange(nodes.ToArray());
                }

                treeView.Sort();
            }

            HashSetToExpanded(treeView.Nodes, FullPathsOfNodesToExpand);

            if (treeView.Nodes.Count > 0)
            {
                treeView.BackColor = UAGPalette.BackColor;
            }
            else
            {
                treeView.BackColor = UAGPalette.InactiveColor;
            }

            treeView.ResumeLayout();
        }

        public void UnloadContainer()
        {
            CurrentContainerPath = null;
            DirectoryTreeMap[loadTreeView] = null;
            Version = PakVersion.V4;
            InteropType = InteropType.Pak;
            MountPoint = "../../../";

            RefreshTreeView(loadTreeView);
            this.Text = BaseForm.DisplayVersion + " - " + CurrentContainerPath;
            SelectedTreeView = saveTreeView;
        }

        public void LoadContainerPak(string path)
        {
            if (path == null) return;
            try
            {
                CurrentContainerPath = path;
                InteropType = InteropType.Pak;

                string[] allFiles = Array.Empty<string>();
                using (FileStream stream = new FileStream(CurrentContainerPath, FileMode.Open))
                {
                    var pakReader = new PakBuilder().Reader(stream);
                    allFiles = pakReader.Files();
                    Version = pakReader.GetVersion();
                    MountPoint = pakReader.GetMountPoint();
                }

                // if the MountPoint starts with "../../../", then let's adjust all files so we can just change the MountPoint to that
                string mpPrefix = "../../../";
                string Prefix = "";
                if (MountPoint.StartsWith(mpPrefix))
                {
                    Prefix = MountPoint.Substring(mpPrefix.Length);
                    MountPoint = mpPrefix;

                    for (int i = 0; i < allFiles.Length; i++)
                    {
                        allFiles[i] = Path.Combine(Prefix, allFiles[i]);
                    }
                }

                DirectoryTreeMap[loadTreeView] = new DirectoryTree(this, allFiles, null, Prefix);
                RefreshTreeView(loadTreeView);

                this.Text = BaseForm.DisplayVersion + " - " + CurrentContainerPath;
                SelectedTreeView = loadTreeView;
            }
            catch (Exception ex)
            {
                UAGUtils.InvokeUI(() => { MessageBox.Show("Failed to open file! " + ex.Message, "Uh oh!"); });

                UnloadContainer();
            }
        }

        public static readonly string ReadOnlyTempPath = Path.Combine(UAGConfig.TempFolder, "UAG_read_only");
        public static readonly string RetocTempPath = Path.Combine(UAGConfig.TempFolder, "UAG_retoc");

        public void LoadContainerUtoc(string path)
        {
            if (path == null) return;

            bool retocAvailable = false;
            string outputText = string.Empty; string errorText = string.Empty;
            try
            {
                retocAvailable = SendCommandToRetoc($"{RetocExtraCommands} --version", out outputText, out errorText) && outputText.Contains("retoc_cli");
            }
            catch (Exception ex)
            {
                UAGUtils.InvokeUI(() =>
                {
                    MessageBox.Show("Failed to launch retoc:\n\n" + ex.Message + "\n" + ex.StackTrace, "Uh oh!");
                });
                return;
            }

            if (!retocAvailable)
            {
                UAGUtils.InvokeUI(() =>
                {
                    MessageBox.Show("Failed to launch retoc:\n\n" + outputText + "\n" + errorText, "Uh oh!");
                });
                return;
            }

            try
            {
                CurrentContainerPath = path;
                InteropType = InteropType.Retoc;
                Version = PakVersion.V11;
                MountPoint = "../../../"; // retoc always uses this mount point

                // extract file manifest
                string tempPathForPakstore = Path.Combine(RetocTempPath, $"pakstore_{Path.GetRandomFileName()}");
                Directory.CreateDirectory(RetocTempPath);
                Directory.CreateDirectory(tempPathForPakstore);

                string expectedManifestPath = Path.Combine(tempPathForPakstore, "pakstore.json");
                UAGUtils.DeleteFileQuick(expectedManifestPath);
                bool extractedManifest = FileContainerForm.SendCommandToRetoc($"{RetocExtraCommands} manifest \"{Path.GetDirectoryName(path)}\"", out _, out _, false, tempPathForPakstore);
                RetocManifest manifestData = JsonConvert.DeserializeObject<RetocManifest>(File.ReadAllText(expectedManifestPath));

                if (manifestData.OpLog.Entries == null) throw new InvalidOperationException("Failed to extract manifest");

                // process manifest
                List<string> allFilesList = new List<string>();
                foreach (RetocOp op in manifestData.OpLog.Entries)
                {
                    if (op.PackageData == null) continue;
                    foreach (RetocChunkData chunk in op.PackageData)
                    {
                        if (!string.IsNullOrEmpty(chunk.FileName))
                        {
                            // we expect the filename to always start with MountPoint, but we check anyways
                            allFilesList.Add(chunk.FileName.StartsWith(MountPoint) ? chunk.FileName.Substring(MountPoint.Length) : chunk.FileName);
                        }
                    }
                }

                string[] allFiles = allFilesList.ToArray();
                DirectoryTreeMap[loadTreeView] = new DirectoryTree(this, allFiles, null, string.Empty);
                RefreshTreeView(loadTreeView);

                this.Text = BaseForm.DisplayVersion + " - " + CurrentContainerPath;
                SelectedTreeView = loadTreeView;
            }
            catch (Exception ex)
            {
                UAGUtils.InvokeUI(() => { MessageBox.Show("Failed to open file! " + ex.Message, "Uh oh!"); });

                UnloadContainer();
            }
        }

        public void LoadContainer(string path)
        {
            if (path == null) return;

            string ext = Path.GetExtension(path);
            switch(ext)
            {
                case ".pak":
                    LoadContainerPak(path);
                    break;
                case ".utoc":
                    LoadContainerUtoc(path);
                    break;
                case ".ucas":
                    LoadContainerUtoc(Path.ChangeExtension(path, ".utoc"));
                    break;
                default:
                    UAGUtils.InvokeUI(() => { MessageBox.Show($"Unknown file extension {ext}", "Uh oh!"); });
                    break;
            }
        }

        public bool SaveContainer(string path)
        {
            if (path == null) return false;
            string[] stagingFiles = UAGConfig.GetStagingFiles(this.CurrentContainerPath, out string[] fixedPathsOnDisk);
            if (stagingFiles == null || fixedPathsOnDisk == null || stagingFiles.Length != fixedPathsOnDisk.Length) return false;

            switch (Path.GetExtension(path))
            {
                case ".pak":
                    using (FileStream stream = new FileStream(path, FileMode.Create))
                    {
                        var pakWriter = new PakBuilder().Writer(stream, Version, MountPoint);
                        for (int i = 0; i < stagingFiles.Length; i++)
                        {
                            string ext = Path.GetExtension(fixedPathsOnDisk[i]);
                            if (ext == ".bak" || fixedPathsOnDisk[i].EndsWith(".bak.json")) continue;
                            pakWriter.WriteFile(stagingFiles[i], File.ReadAllBytes(fixedPathsOnDisk[i]));
                        }
                        pakWriter.WriteIndex();
                    }
                    break;
                case ".utoc":
                    string engVer = ((RetocEngineVersion)BaseForm.ParsingVersion).ToString();
                    FileContainerForm.SendCommandToRetoc($"{RetocExtraCommands} to-zen --version {engVer} \"{UAGConfig.GetStagingDirectory(path)}\" \"{path}\"", out _, out _);
                    break;
            }

            return true;
        }

        public static bool SendCommandToRetoc(string args, out string outputText, out string errorText, bool displayConsole = false, string workingDirectory = null)
        {
            outputText = null;
            errorText = null;

            string libsPath = Path.Combine(UAGConfig.ConfigFolder, "Libraries");
            string retocPath = Path.Combine(libsPath, "retoc.exe");
            Directory.CreateDirectory(UAGConfig.ConfigFolder);
            Directory.CreateDirectory(libsPath);

            if (!HasAlreadyExtractedRetoc || !File.Exists(retocPath)) ExtractRetoc();

            Process process = new Process();
            process.StartInfo.FileName = retocPath;
            process.StartInfo.Arguments = args;
            process.StartInfo.WorkingDirectory = workingDirectory ?? libsPath;
            process.StartInfo.UseShellExecute = displayConsole ? true : false;
            process.StartInfo.RedirectStandardOutput = displayConsole ? false : true;
            process.StartInfo.RedirectStandardError = displayConsole ? false : true;
            process.StartInfo.CreateNoWindow = displayConsole ? false : true;

            process.Start();

            if (process.StartInfo.RedirectStandardOutput) outputText = process.StandardOutput.ReadToEnd().TrimEnd();
            if (process.StartInfo.RedirectStandardError) errorText = process.StandardError.ReadToEnd().TrimEnd();
            process.WaitForExit();
            int errorCode = process.ExitCode;
            process.Close();

            return errorCode == 0;
        }

        private static bool HasAlreadyExtractedRetoc = false;
        private static bool HasAlreadyExtractedRepak = false;
        public static string ExtractRetoc()
        {
            HasAlreadyExtractedRetoc = true;
            string libsPath = Path.Combine(UAGConfig.ConfigFolder, "Libraries");
            Directory.CreateDirectory(UAGConfig.ConfigFolder);
            Directory.CreateDirectory(libsPath);

            return Program.ExtractCompressedResource($"UAssetGUI.retoc.exe.gz", Path.Combine(libsPath, "retoc.exe"));
        }

        public void ForceResize()
        {
            splitContainer1.Size = new Size(this.Size.Width - 28, this.Size.Height - menuStrip1.Size.Height - 50);
            splitContainer1.Panel1.Size = new Size(splitContainer1.SplitterDistance, splitContainer1.Size.Height);
            splitContainer1.Panel2.Size = new Size(splitContainer1.Size.Width - splitContainer1.SplitterDistance, splitContainer1.Size.Height);
            loadButton.Location = new Point((splitContainer1.Panel1.Size.Width - loadButton.Size.Width) / 2, loadButton.Location.Y);
            saveButton.Location = new Point((splitContainer1.Panel2.Size.Width - saveButton.Size.Width) / 2, saveButton.Location.Y);
            loadTreeView.Location = new Point(0, loadButton.Location.Y + loadButton.Size.Height + 6);
            loadTreeView.Size = new Size(splitContainer1.Panel1.Size.Width, splitContainer1.Panel1.Size.Height - loadTreeView.Location.Y);
            saveTreeView.Location = new Point(0, saveButton.Location.Y + saveButton.Size.Height + 6);
            saveTreeView.Size = new Size(splitContainer1.Panel2.Size.Width, splitContainer1.Panel2.Size.Height - saveTreeView.Location.Y);
        }

        private void FileContainerForm_SizeChanged(object sender, EventArgs e)
        {
            ForceResize();
        }

        private void splitContainer1_SplitterMoved(object sender, SplitterEventArgs e)
        {
            ForceResize();
        }

        private void FileContainerForm_Shown(object sender, EventArgs e)
        {
            splitContainer1.SplitterDistance = (this.Size.Width - 28) / 2;
            ForceResize();
        }

        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            switch (keyData)
            {
                case Keys.Control | Keys.X:
                    cutToolStripMenuItem.PerformClick();
                    return true;
                case Keys.Control | Keys.C:
                    copyToolStripMenuItem.PerformClick();
                    return true;
                case Keys.Control | Keys.V:
                    pasteToolStripMenuItem.PerformClick();
                    return true;
                case Keys.Delete:
                    deleteToolStripMenuItem.PerformClick();
                    return true;
            }

            return base.ProcessCmdKey(ref msg, keyData);
        }

        private void expandAllToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.SelectedTreeView?.ExpandAll();
        }

        private void collapseAllToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.SelectedTreeView?.CollapseAll();
        }

        private void refreshToolStripMenuItem_Click(object sender, EventArgs e)
        {
            RefreshTreeView(loadTreeView);
            RefreshTreeView(saveTreeView);
        }

        private void loadButton_Click(object sender, EventArgs e)
        {
            loadToolStripMenuItem.PerformClick();
        }

        private void saveButton_Click(object sender, EventArgs e)
        {
            saveToolStripMenuItem.PerformClick();
        }

        private void treeView_NodeMouseDoubleClick(object sender, TreeNodeMouseClickEventArgs e)
        {
            if (e?.Node != null && e.Node is PointingFileTreeNode pftNode)
            {
                if (pftNode.Pointer.IsFile) pftNode.Pointer.OpenFile();
            }
        }

        private DirectoryTreeItem copiedPftNode = null;
        private bool shouldDeleteCopiedPftNode = false;
        private void copyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (this.SelectedTreeView?.SelectedNode is PointingFileTreeNode pftNode)
            {
                if (pftNode == null) return;

                copiedPftNode = pftNode.Pointer;
                shouldDeleteCopiedPftNode = false;
            }
        }

        private void pasteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (this.SelectedTreeView?.SelectedNode is PointingFileTreeNode pftNode)
            {
                if (copiedPftNode == null || pftNode == null) return;
                DirectoryTreeItem clipboardNode = copiedPftNode;

                if (string.IsNullOrEmpty(pftNode.Pointer.FixedPathOnDisk)) return; // only allow pasting into staging
                DirectoryTreeItem targetDirectory = pftNode.Pointer;
                if (targetDirectory.IsFile) targetDirectory = targetDirectory.Parent;

                string desiredStagingPath = Path.Combine(targetDirectory?.FullPath ?? string.Empty, clipboardNode.Name);
                clipboardNode.StageFile(desiredStagingPath);

                if (shouldDeleteCopiedPftNode)
                {
                    clipboardNode.DeleteFile();
                    shouldDeleteCopiedPftNode = false;
                }
            }
        }

        private void deleteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (this.SelectedTreeView?.SelectedNode is PointingFileTreeNode pftNode)
            {
                if (pftNode == null) return;
                if (string.IsNullOrEmpty(pftNode.Pointer.FixedPathOnDisk)) return; // only allow deleting from staging

                pftNode.Pointer.DeleteFile();
            }
        }

        private void cutToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (this.SelectedTreeView?.SelectedNode is PointingFileTreeNode pftNode)
            {
                if (pftNode == null) return;
                if (string.IsNullOrEmpty(pftNode.Pointer.FixedPathOnDisk)) return; // only allow cutting from staging

                copiedPftNode = pftNode.Pointer;
                shouldDeleteCopiedPftNode = true;
            }
        }

        private void event_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop)) e.Effect = DragDropEffects.Copy;
        }

        private void loadTreeView_DragDrop(object sender, DragEventArgs e)
        {
            string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
            if (files.Length > 0) LoadContainer(files[0]);
        }

        private void saveTreeView_DragDrop(object sender, DragEventArgs e)
        {
            string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
            if (files.Length > 0)
            {
                UAGConfig.StageFile(files[0], CurrentContainerPath);
                this.RefreshTreeView(this.saveTreeView);
            }
        }

        private void loadTreeView_NodeMouseClick(object sender, TreeNodeMouseClickEventArgs e)
        {
            saveTreeView.SelectedNode = null;
            this.SelectedTreeView = loadTreeView;
        }

        private void saveTreeView_NodeMouseClick(object sender, TreeNodeMouseClickEventArgs e)
        {
            loadTreeView.SelectedNode = null;
            this.SelectedTreeView = saveTreeView;
        }

        private void loadToolStripMenuItem_Click(object sender, EventArgs e)
        {
            using (System.Windows.Forms.OpenFileDialog openFileDialog = new System.Windows.Forms.OpenFileDialog())
            {
                openFileDialog.Filter = "Unreal Engine Container Files (*.pak, *.utoc)|*.pak;*.utoc|All files (*.*)|*.*";
                openFileDialog.FilterIndex = 1;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    LoadContainer(openFileDialog.FileName);
                }
            }
        }

        private void saveToolStripMenuItem_Click(object sender, EventArgs e)
        {
            using (System.Windows.Forms.SaveFileDialog dialog = new System.Windows.Forms.SaveFileDialog())
            {
                dialog.Filter = ".pak Container Files (*.pak)|*.pak|.utoc Container Files (*.utoc)|*.utoc|All files (*.*)|*.*";
                dialog.FilterIndex = 1;
                dialog.RestoreDirectory = true;

                DialogResult res = dialog.ShowDialog();
                if (res == DialogResult.OK)
                {
                    bool success = SaveContainer(dialog.FileName);
                    if (!success) MessageBox.Show("Failed to save!", "Uh oh!");
                }
                else if (res != DialogResult.Cancel)
                {
                    MessageBox.Show("Failed to save!", "Uh oh!");
                }
            }
        }

        private void stageFromDiskToolStripMenuItem_Click(object sender, EventArgs e)
        {
            using (System.Windows.Forms.OpenFileDialog openFileDialog = new System.Windows.Forms.OpenFileDialog())
            {
                openFileDialog.Filter = "All files (*.*)|*.*";
                openFileDialog.FilterIndex = 1;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    UAGConfig.StageFile(openFileDialog.FileName, CurrentContainerPath);
                    this.RefreshTreeView(this.saveTreeView);
                }
            }
        }

        private void stageFromDiskToPathToolStripMenuItem_Click(object sender, EventArgs e)
        {
            using (System.Windows.Forms.OpenFileDialog openFileDialog = new System.Windows.Forms.OpenFileDialog())
            {
                openFileDialog.Filter = "All files (*.*)|*.*";
                openFileDialog.FilterIndex = 1;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    TextPrompt replacementPrompt = new TextPrompt()
                    {
                        DisplayText = "What path should this object be staged to?",
                        Text = this.Text
                    };

                    replacementPrompt.StartPosition = FormStartPosition.CenterParent;
                    replacementPrompt.PrefilledText = Path.GetFileName(openFileDialog.FileName) ?? string.Empty;

                    string newFileName = null;
                    if (replacementPrompt.ShowDialog(ParentForm) == DialogResult.OK)
                    {
                        newFileName = string.Join("_", replacementPrompt.OutputText.Replace('\\', '/').Split(Path.GetInvalidPathChars(), StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
                    }

                    replacementPrompt.Dispose();

                    if (newFileName != null)
                    {
                        UAGConfig.StageFile(openFileDialog.FileName, CurrentContainerPath, newFileName);
                        this.RefreshTreeView(this.saveTreeView);
                    }
                }
            }
        }

        private void InitializeChildren(PointingFileTreeNode ptn)
        {
            if (!ptn.ChildrenInitialized)
            {
                ptn.Nodes.Clear();
                if (!Filter.ContainsKey(ptn.TreeView)) Filter[ptn.TreeView] = null;
                AddDirectoryItemChildrenToTreeView(ptn.Pointer, ptn, Filter[ptn.TreeView], true);
            }
        }

        private void treeView_BeforeExpand(object sender, TreeViewCancelEventArgs e)
        {
            if (e.Node is PointingFileTreeNode ptn) InitializeChildren(ptn);
        }

        private void ExtractVisit(DirectoryTreeItem processingNode, ProgressBarForm progressBarForm, FileStream stream2 = null, PakReader reader2 = null)
        {
            if (processingNode.IsFile)
            {
                UAGConfig.ExtractFile(processingNode, this.InteropType, stream2, reader2);
                extractAllBackgroundWorker.ReportProgress(0); // the percentage we pass in is unused
                return;
            }

            foreach (var entry in processingNode.Children)
            {
                if (extractAllBackgroundWorker.CancellationPending) break;
                ExtractVisit(entry.Value, progressBarForm, stream2, reader2);
            }
        }

        private ProgressBarForm progressBarForm;
        private void extractAllToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!DirectoryTreeMap.TryGetValue(loadTreeView, out DirectoryTree loadedTree) || loadedTree == null)
            {
                MessageBox.Show("Please load a container first to extract it.", "Notice");
                return;
            }

            switch(InteropType)
            {
                case InteropType.Pak:
                    if (extractAllBackgroundWorker.IsBusy) return;

                    int numFiles = loadedTree.GetNumFiles();

                    UAGUtils.InvokeUI(() =>
                    {
                        progressBarForm = new ProgressBarForm();
                        progressBarForm.Value = 0;
                        progressBarForm.Maximum = numFiles;
                        progressBarForm.Text = this.Text;
                        progressBarForm.BaseForm = this;
                        progressBarForm.Show(this);
                    });

                    extractAllBackgroundWorker.RunWorkerAsync();
                    break;
                case InteropType.Retoc:
                    if (extractAllBackgroundWorker.IsBusy) return;
                    extractAllBackgroundWorker.RunWorkerAsync();
                    break;
                default:
                    MessageBox.Show($"This operation is not supported for the current interop type ({InteropType.ToString()}).", "Notice");
                    break;
            }
        }

        private void extractAllBackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            Directory.CreateDirectory(UAGConfig.ExtractedFolder);

            switch (InteropType)
            {
                case InteropType.Pak:
                    if (!DirectoryTreeMap.TryGetValue(loadTreeView, out DirectoryTree loadedTree) || loadedTree == null) throw new InvalidOperationException("No container loaded");

                    using (FileStream stream = new FileStream(this.CurrentContainerPath, FileMode.Open))
                    {
                        var reader = new PakBuilder().Reader(stream);
                        foreach (var entry in loadedTree.RootNodes)
                        {
                            if (extractAllBackgroundWorker.CancellationPending) break;
                            ExtractVisit(entry.Value, progressBarForm, stream, reader);
                        }
                    }

                    if (extractAllBackgroundWorker.CancellationPending)
                    {
                        e.Cancel = true;
                        return;
                    }
                    UAGUtils.OpenDirectory(UAGConfig.ExtractedFolder);
                    break;
                case InteropType.Retoc:
                    FileContainerForm.SendCommandToRetoc($"{RetocExtraCommands} to-legacy \"{Path.GetDirectoryName(CurrentContainerPath)}\" \"{UAGConfig.ExtractedFolder}\"", out _, out _, true);
                    UAGUtils.OpenDirectory(UAGConfig.ExtractedFolder);
                    break;
            }
        }

        private void extractAllBackgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            UAGUtils.InvokeUI(() => progressBarForm.Progress(1));
        }

        private void extractAllBackgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                if (e.Cancelled)
                {
                    MessageBox.Show("Operation canceled.", "Notice");
                }
                else if (e.Error != null)
                {
                    MessageBox.Show("An error occured during extraction! " + e.Error.Message, "Uh oh!");
                }
                else
                {
                    MessageBox.Show(progressBarForm == null ? "Operation completed." : ("Extracted " + progressBarForm.Value + " files successfully."), "Notice");
                }
                progressBarForm?.Close();
            });
        }

        private void toggleFlatViewToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!FlatViewEnabled.ContainsKey(SelectedTreeView)) FlatViewEnabled[SelectedTreeView] = false;
            FlatViewEnabled[SelectedTreeView] = !FlatViewEnabled[SelectedTreeView];
            RefreshTreeView(SelectedTreeView);
        }

        private void applyFilterToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                TextPrompt replacementPrompt = new TextPrompt()
                {
                    DisplayText = "Enter a string to search for (or empty to remove):",
                    Text = this.Text,
                    AllowEmptyText = true
                };

                replacementPrompt.StartPosition = FormStartPosition.CenterParent;
                replacementPrompt.PrefilledText = string.Empty;

                string filter = null;
                if (replacementPrompt.ShowDialog(ParentForm) == DialogResult.OK)
                {
                    filter = replacementPrompt.OutputText;
                }

                replacementPrompt.Dispose();

                if (filter != null && loadTreeView != null)
                {
                    this.Filter[loadTreeView] = filter;
                    RefreshTreeView(loadTreeView);
                }
            });
        }

        private void setRetocCommandLineParametersToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                TextPrompt replacementPrompt = new TextPrompt()
                {
                    DisplayText = "Extra retoc command line parameters:",
                    Text = this.Text,
                    AllowEmptyText = true
                };

                replacementPrompt.StartPosition = FormStartPosition.CenterParent;
                replacementPrompt.PrefilledText = RetocExtraCommands;

                if (replacementPrompt.ShowDialog(ParentForm) == DialogResult.OK)
                {
                    RetocExtraCommands = replacementPrompt.OutputText;
                }

                replacementPrompt.Dispose();
            });
        }
    }

    public class PointingFileTreeNode : TreeNode
    {
        public DirectoryTreeItem Pointer;
        public bool ChildrenInitialized = false;

        public PointingFileTreeNode(string text, DirectoryTreeItem item) : base(text)
        {
            Pointer = item;
            //NodeFont = new Font(new FontFamily("Microsoft Sans Serif"), 8.25f);

            this.ContextMenuStrip = new ContextMenuStrip();
            ToolStripMenuItem tsmItem = null;

            if (Pointer.IsFile)
            {
                tsmItem = new ToolStripMenuItem("Open");
                tsmItem.Click += (sender, args) => Pointer.OpenFile();
                this.ContextMenuStrip.Items.Add(tsmItem);
            }

            if (Pointer.FixedPathOnDisk == null)
            {
                tsmItem = new ToolStripMenuItem("Extract");
                tsmItem.Click += (sender, args) =>
                {
                    string outPath = UAGConfig.ExtractFile(Pointer, item.ParentForm.InteropType);
                    if (outPath == null) return;
                    if ((Path.GetExtension(outPath)?.Length ?? 0) > 0) outPath = Path.GetDirectoryName(outPath);
                    UAGUtils.OpenDirectory(outPath);
                };
                this.ContextMenuStrip.Items.Add(tsmItem);
                tsmItem = new ToolStripMenuItem("Stage");
                tsmItem.Click += (sender, args) => Pointer.StageFile();
                this.ContextMenuStrip.Items.Add(tsmItem);
                tsmItem = new ToolStripMenuItem("Stage to path...");
                tsmItem.Click += (sender, args) => Pointer.StageFileToPath();
                this.ContextMenuStrip.Items.Add(tsmItem);
            }

            if (Pointer.FixedPathOnDisk != null)
            {
                tsmItem = new ToolStripMenuItem("Delete");
                tsmItem.Click += (sender, args) => Pointer.DeleteFile();
                this.ContextMenuStrip.Items.Add(tsmItem);
            }
        }
    }

    public class DirectoryTree
    {
        public FileContainerForm ParentForm;
        public IDictionary<string, DirectoryTreeItem> RootNodes;
        public IDictionary<string, DirectoryTreeItem> RootNodesFlat;
        public IDictionary<string, DirectoryTreeItem> PackagePathToNode;

        public DirectoryTree(FileContainerForm parentForm)
        {
            RootNodes = new Dictionary<string, DirectoryTreeItem>();
            RootNodesFlat = new Dictionary<string, DirectoryTreeItem>();
            PackagePathToNode = new Dictionary<string, DirectoryTreeItem>();
            ParentForm = parentForm;
        }

        public DirectoryTree(FileContainerForm parentForm, string[] paths, string[] fixedAssetsOnDisk = null, string prefix = null)
        {
            RootNodes = new Dictionary<string, DirectoryTreeItem>();
            RootNodesFlat = new Dictionary<string, DirectoryTreeItem>();
            PackagePathToNode = new Dictionary<string, DirectoryTreeItem>();
            ParentForm = parentForm;

            if (fixedAssetsOnDisk != null && fixedAssetsOnDisk.Length == paths.Length)
            {
                for (int i = 0; i < paths.Length; i++) this.CreateNode(paths[i], fixedAssetsOnDisk[i], prefix);
            }
            else
            {
                for (int i = 0; i < paths.Length; i++) this.CreateNode(paths[i], null, prefix);
            }
        }

        private static int GetNumFilesVisit(DirectoryTreeItem item)
        {
            if (item.IsFile) return 1;

            int numFiles = 0; // to count directories too, set to 1
            foreach (var entry in item.Children) numFiles += GetNumFilesVisit(entry.Value);
            return numFiles;
        }

        public int GetNumFiles()
        {
            int numFiles = 0;
            foreach (var entry in RootNodes) numFiles += GetNumFilesVisit(entry.Value);
            return numFiles;
        }

        public DirectoryTreeItem GetRootNode(string component)
        {
            if (RootNodes.TryGetValue(component, out var node)) return node;
            return null;
        }

        public DirectoryTreeItem GetNode(string path)
        {
            string[] pathComponents = path.Split('/');
            if (pathComponents.Length == 0) return null;
            if (!RootNodes.ContainsKey(pathComponents[0])) return null;

            DirectoryTreeItem currentItem = RootNodes[pathComponents[0]];
            for (int i = 1; i < pathComponents.Length; i++)
            {
                currentItem = currentItem.Children[pathComponents[i]];
            }
            return currentItem;
        }

        private static readonly Regex ProjectWithContentPrefixRegex = new Regex(@"^\/?[^\s\/]+\/Content", RegexOptions.Compiled);

        public DirectoryTreeItem CreateNode(string path, string fixedAssetOnDisk = null, string prefix = null)
        {
            string[] pathComponents = path.Split('/');
            if (pathComponents.Length == 0) return null;

            string[] fixedAssetOnDiskComponents = fixedAssetOnDisk?.Split(Path.DirectorySeparatorChar) ?? Array.Empty<string>();
            string startingFixedAssetOnDisk = string.Empty;
            if (fixedAssetOnDiskComponents.Length > pathComponents.Length)
            {
                string[] fixedAssetOnDiskComponentsNuevo = new string[fixedAssetOnDiskComponents.Length - pathComponents.Length];
                Array.Copy(fixedAssetOnDiskComponents, fixedAssetOnDiskComponentsNuevo, fixedAssetOnDiskComponentsNuevo.Length);
                startingFixedAssetOnDisk = string.Join(Path.DirectorySeparatorChar, fixedAssetOnDiskComponentsNuevo);
            }

            if (!RootNodes.ContainsKey(pathComponents[0]))
            {
                string ext = Path.GetExtension(pathComponents[0]);
                if (ext.Length > 1 && (ext == ".uexp" || ext == ".ubulk" || ext == ".bak")) return null;

                RootNodes[pathComponents[0]] = new DirectoryTreeItem(ParentForm, pathComponents[0], pathComponents[0], ext.Length > 1, prefix);
            }

            DirectoryTreeItem currentItem = RootNodes[pathComponents[0]];
            if (startingFixedAssetOnDisk.Length > 0)
            {
                startingFixedAssetOnDisk = Path.Combine(startingFixedAssetOnDisk, pathComponents[0]);
                currentItem.FixedPathOnDisk = startingFixedAssetOnDisk;
            }

            for (int i = 1; i < pathComponents.Length; i++)
            {
                string ext = Path.GetExtension(pathComponents[i]);
                if (ext.Length > 1 && (ext == ".uexp" || ext == ".ubulk" || ext == ".bak" || pathComponents[i].EndsWith(".bak.json"))) return null;

                if (!currentItem.Children.ContainsKey(pathComponents[i]))
                {
                    currentItem.Children[pathComponents[i]] = new DirectoryTreeItem(ParentForm, pathComponents[i], currentItem.FullPath + "/" + pathComponents[i], ext.Length > 1, prefix);
                    currentItem.Children[pathComponents[i]].Parent = currentItem;
                }
                currentItem = currentItem.Children[pathComponents[i]];

                if (startingFixedAssetOnDisk.Length > 0)
                {
                    startingFixedAssetOnDisk = Path.Combine(startingFixedAssetOnDisk, pathComponents[i]);
                    currentItem.FixedPathOnDisk = startingFixedAssetOnDisk;
                }
            }

            RootNodesFlat[currentItem.FullPath.Replace('\\', '/').Replace(Path.DirectorySeparatorChar, '/')] = currentItem;

            // todo, this algorithm needs to be fixed for plugins
            // Engine/Plugins/Animation/ControlRig/Content/Controls/ControlRigGizmoMaterial.uasset => /ControlRig/Controls/ControlRigGizmoMaterial
            string packageName = Path.ChangeExtension(currentItem.FullPath, null).Replace('\\', '/').Replace(Path.DirectorySeparatorChar, '/').Replace("Engine/Content/", "Engine/");
            packageName = ProjectWithContentPrefixRegex.Replace(packageName, "/Game", 1);
            if (!packageName.StartsWith('/')) packageName = '/' + packageName;
            PackagePathToNode[packageName] = currentItem;

            return currentItem;
        }
    }

    public class DirectoryTreeItem
    {
        public FileContainerForm ParentForm;
        public string Name;
        public string FullPath;
        public string FixedPathOnDisk;
        public string Prefix;
        public bool IsFile = false;
        public DirectoryTreeItem Parent;
        public IDictionary<string, DirectoryTreeItem> Children;

        public string SaveFileToTemp(InteropType interopType, string outputPathDirectory = null, FileStream stream2 = null, PakReader reader2 = null)
        {
            outputPathDirectory = outputPathDirectory ?? Path.Combine(FileContainerForm.ReadOnlyTempPath, Path.GetFileNameWithoutExtension(ParentForm.CurrentContainerPath));
            
            string outputPath1 = Path.Combine(outputPathDirectory, FullPath.Replace('/', Path.DirectorySeparatorChar));
            string outputPath2 = Path.Combine(outputPathDirectory, Path.ChangeExtension(FullPath, ".uexp").Replace('/', Path.DirectorySeparatorChar));
            string outputPath3 = Path.Combine(outputPathDirectory, Path.ChangeExtension(FullPath, ".ubulk").Replace('/', Path.DirectorySeparatorChar));
            Directory.CreateDirectory(Path.GetDirectoryName(outputPath1)); // same directory as outputPath2, no need to create that one too

            if (FixedPathOnDisk != null)
            {
                File.Copy(FixedPathOnDisk, outputPath1, true);
                try { File.Copy(Path.ChangeExtension(FixedPathOnDisk, ".uexp"), outputPath2, true); } catch { }
                try { File.Copy(Path.ChangeExtension(FixedPathOnDisk, ".ubulk"), outputPath3, true); } catch { }
                return outputPath1;
            }

            switch(interopType)
            {
                case InteropType.Pak:
                    {
                        if (reader2 == null || stream2 == null)
                        {
                            using (FileStream stream = new FileStream(ParentForm.CurrentContainerPath, FileMode.Open))
                            {
                                var reader = new PakBuilder().Reader(stream);

                                byte[] res = reader.Get(stream, FullPath.Substring(Prefix?.Length ?? 0));
                                if (res != null)
                                {
                                    UAGUtils.DeleteFileQuick(outputPath1);
                                    File.WriteAllBytes(outputPath1, res);
                                }
                                else
                                {
                                    return null;
                                }

                                res = reader.Get(stream, Path.ChangeExtension(FullPath.Substring(Prefix?.Length ?? 0), ".uexp"));
                                UAGUtils.DeleteFileQuick(outputPath2);
                                if (res != null) File.WriteAllBytes(outputPath2, res);

                                res = reader.Get(stream, Path.ChangeExtension(FullPath.Substring(Prefix?.Length ?? 0), ".ubulk"));
                                UAGUtils.DeleteFileQuick(outputPath3);
                                if (res != null) File.WriteAllBytes(outputPath3, res);
                            }
                        }
                        else
                        {
                            byte[] res = reader2.Get(stream2, FullPath.Substring(Prefix?.Length ?? 0));
                            if (res != null)
                            {
                                File.WriteAllBytes(outputPath1, res);
                            }
                            else
                            {
                                return null;
                            }

                            res = reader2.Get(stream2, Path.ChangeExtension(FullPath.Substring(Prefix?.Length ?? 0), ".uexp"));
                            if (res != null) File.WriteAllBytes(outputPath2, res);
                            res = reader2.Get(stream2, Path.ChangeExtension(FullPath.Substring(Prefix?.Length ?? 0), ".ubulk"));
                            if (res != null) File.WriteAllBytes(outputPath3, res);
                        }
                    }
                    break;
                case InteropType.Retoc:
                    string targetPath = FullPath.Substring(Prefix?.Length ?? 0);
                    string origPathPrefix = Path.Combine(FileContainerForm.RetocTempPath, "RetocFiles");
                    bool retocSuccess = FileContainerForm.SendCommandToRetoc($"{FileContainerForm.RetocExtraCommands ?? string.Empty} to-legacy --filter \"{targetPath}\" \"{Path.GetDirectoryName(ParentForm.CurrentContainerPath)}\" \"{origPathPrefix}\"", out _, out _);
                    if (!retocSuccess) return null;

                    string origPath1 = Path.Combine(origPathPrefix, targetPath);
                    UAGUtils.MoveFileQuick(Path.ChangeExtension(origPath1, "uasset"), outputPath1, true);
                    UAGUtils.MoveFileQuick(Path.ChangeExtension(origPath1, "umap"), outputPath1, true);
                    UAGUtils.MoveFileQuick(Path.ChangeExtension(origPath1, "uexp"), outputPath2, true);
                    UAGUtils.MoveFileQuick(Path.ChangeExtension(origPath1, "ubulk"), outputPath3, true);
                    break;
            }

            return outputPath1;
        }

        public void OpenFile()
        {
            string outputPath = FixedPathOnDisk != null ? FixedPathOnDisk : this.SaveFileToTemp(this.ParentForm.InteropType);
            if (outputPath == null)
            {
                MessageBox.Show("Unable to open file!", "Uh oh!");
                return;
            }

            string ext = Path.GetExtension(outputPath);
            if (ext == ".uasset" || ext == ".umap")
            {
                this.ParentForm.BaseForm.LoadFileAt(outputPath, this.ParentForm);
                this.ParentForm.BaseForm.Focus();
            }
            else
            {
                new Process
                {
                    StartInfo = new ProcessStartInfo(outputPath) { UseShellExecute = true }
                }.Start(); // open externally
            }
        }

        public void StageFile(string newPath = null)
        {
            if (newPath == null) newPath = this.FullPath;

            UAGConfig.StageFile(this, this.ParentForm.InteropType, newPath);
            this.ParentForm.RefreshTreeView(this.ParentForm.saveTreeView);

            var generatedNode = this.ParentForm.GetSpecificNode(this.ParentForm.saveTreeView, newPath);
            if (generatedNode == null) return;
            generatedNode.EnsureVisible();
            this.ParentForm.saveTreeView.SelectedNode = generatedNode;
        }

        public void StageFileToPath()
        {
            UAGUtils.InvokeUI(() =>
            {
                TextPrompt replacementPrompt = new TextPrompt()
                {
                    DisplayText = "What path should this object be staged to?"
                };

                replacementPrompt.StartPosition = FormStartPosition.CenterParent;
                replacementPrompt.PrefilledText = this.FullPath ?? string.Empty;

                string newFileName = null;
                if (replacementPrompt.ShowDialog(ParentForm) == DialogResult.OK)
                {
                    newFileName = string.Join("_", replacementPrompt.OutputText.Replace('\\', '/').Split(Path.GetInvalidPathChars(), StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
                }

                replacementPrompt.Dispose();

                if (newFileName != null)
                {
                    this.StageFile(newFileName);
                }
            });
        }

        public void DeleteFile()
        {
            if (FixedPathOnDisk == null) return;

            bool success = UAGUtils.DeleteFileQuick(FixedPathOnDisk);
            UAGUtils.DeleteFileQuick(Path.ChangeExtension(FixedPathOnDisk, ".uexp"));
            UAGUtils.DeleteFileQuick(Path.ChangeExtension(FixedPathOnDisk, ".ubulk"));
            
            if (!success)
            {
                UAGUtils.DeleteDirectoryQuick(FixedPathOnDisk, true);
            }

            FixedPathOnDisk = null;
            this.ParentForm.RefreshTreeView(this.ParentForm.saveTreeView);
        }

        public DirectoryTreeItem(FileContainerForm parentForm, string name, string fullPath, bool isFile, string prefix)
        {
            ParentForm = parentForm;
            FullPath = fullPath;
            Name = Path.GetFileName(name);
            IsFile = isFile;
            Prefix = prefix;
            Children = new Dictionary<string, DirectoryTreeItem>();
        }

        public DirectoryTreeItem(FileContainerForm parentForm)
        {
            ParentForm = parentForm;
            Children = new Dictionary<string, DirectoryTreeItem>();
        }
    }
}

```

`UAssetGUI/FileContainerForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="menuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="extractAllBackgroundWorker.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>132, 17</value>
  </metadata>
</root>
```

`UAssetGUI/FindForm.Designer.cs`:

```cs

namespace UAssetGUI
{
    partial class FindForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.closeButton = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.searchForBox = new System.Windows.Forms.TextBox();
            this.nextButton = new System.Windows.Forms.Button();
            this.searchDirectionGroupBox = new System.Windows.Forms.GroupBox();
            this.searchDirBackwardButton = new System.Windows.Forms.RadioButton();
            this.searchDirForwardButton = new System.Windows.Forms.RadioButton();
            this.optionsGroupBox = new System.Windows.Forms.GroupBox();
            this.useRegexCheckBox = new System.Windows.Forms.CheckBox();
            this.caseSensitiveCheckBox = new System.Windows.Forms.CheckBox();
            this.progressBar1 = new System.Windows.Forms.ProgressBar();
            this.searchDirectionGroupBox.SuspendLayout();
            this.optionsGroupBox.SuspendLayout();
            this.SuspendLayout();
            // 
            // closeButton
            // 
            this.closeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.closeButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.closeButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.closeButton.ForeColor = System.Drawing.SystemColors.ControlText;
            this.closeButton.Location = new System.Drawing.Point(224, 124);
            this.closeButton.Name = "closeButton";
            this.closeButton.Size = new System.Drawing.Size(75, 26);
            this.closeButton.TabIndex = 6;
            this.closeButton.Text = "Close";
            this.closeButton.UseVisualStyleBackColor = true;
            this.closeButton.Click += new System.EventHandler(this.closeButton_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(12, 19);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(59, 13);
            this.label1.TabIndex = 6;
            this.label1.Text = "Search for:";
            // 
            // searchForBox
            // 
            this.searchForBox.Location = new System.Drawing.Point(77, 16);
            this.searchForBox.Name = "searchForBox";
            this.searchForBox.Size = new System.Drawing.Size(222, 20);
            this.searchForBox.TabIndex = 0;
            // 
            // nextButton
            // 
            this.nextButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.nextButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.nextButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.nextButton.ForeColor = System.Drawing.SystemColors.ControlText;
            this.nextButton.Location = new System.Drawing.Point(143, 124);
            this.nextButton.Name = "nextButton";
            this.nextButton.Size = new System.Drawing.Size(75, 26);
            this.nextButton.TabIndex = 5;
            this.nextButton.Text = "Next";
            this.nextButton.UseVisualStyleBackColor = true;
            this.nextButton.Click += new System.EventHandler(this.nextButton_Click);
            // 
            // searchDirectionGroupBox
            // 
            this.searchDirectionGroupBox.Controls.Add(this.searchDirBackwardButton);
            this.searchDirectionGroupBox.Controls.Add(this.searchDirForwardButton);
            this.searchDirectionGroupBox.Location = new System.Drawing.Point(200, 42);
            this.searchDirectionGroupBox.Name = "searchDirectionGroupBox";
            this.searchDirectionGroupBox.Size = new System.Drawing.Size(99, 65);
            this.searchDirectionGroupBox.TabIndex = 11;
            this.searchDirectionGroupBox.TabStop = false;
            this.searchDirectionGroupBox.Text = "Search direction";
            // 
            // searchDirBackwardButton
            // 
            this.searchDirBackwardButton.AutoSize = true;
            this.searchDirBackwardButton.Location = new System.Drawing.Point(6, 42);
            this.searchDirBackwardButton.Name = "searchDirBackwardButton";
            this.searchDirBackwardButton.Size = new System.Drawing.Size(73, 17);
            this.searchDirBackwardButton.TabIndex = 4;
            this.searchDirBackwardButton.TabStop = true;
            this.searchDirBackwardButton.Text = "Backward";
            this.searchDirBackwardButton.UseVisualStyleBackColor = true;
            // 
            // searchDirForwardButton
            // 
            this.searchDirForwardButton.AutoSize = true;
            this.searchDirForwardButton.Location = new System.Drawing.Point(6, 19);
            this.searchDirForwardButton.Name = "searchDirForwardButton";
            this.searchDirForwardButton.Size = new System.Drawing.Size(63, 17);
            this.searchDirForwardButton.TabIndex = 3;
            this.searchDirForwardButton.TabStop = true;
            this.searchDirForwardButton.Text = "Forward";
            this.searchDirForwardButton.UseVisualStyleBackColor = true;
            // 
            // optionsGroupBox
            // 
            this.optionsGroupBox.Controls.Add(this.useRegexCheckBox);
            this.optionsGroupBox.Controls.Add(this.caseSensitiveCheckBox);
            this.optionsGroupBox.Location = new System.Drawing.Point(15, 42);
            this.optionsGroupBox.Name = "optionsGroupBox";
            this.optionsGroupBox.Size = new System.Drawing.Size(164, 65);
            this.optionsGroupBox.TabIndex = 12;
            this.optionsGroupBox.TabStop = false;
            this.optionsGroupBox.Text = "Options";
            // 
            // useRegexCheckBox
            // 
            this.useRegexCheckBox.AutoSize = true;
            this.useRegexCheckBox.Location = new System.Drawing.Point(6, 42);
            this.useRegexCheckBox.Name = "useRegexCheckBox";
            this.useRegexCheckBox.Size = new System.Drawing.Size(74, 17);
            this.useRegexCheckBox.TabIndex = 2;
            this.useRegexCheckBox.Text = "Use regex";
            this.useRegexCheckBox.UseVisualStyleBackColor = true;
            // 
            // caseSensitiveCheckBox
            // 
            this.caseSensitiveCheckBox.AutoSize = true;
            this.caseSensitiveCheckBox.Location = new System.Drawing.Point(6, 19);
            this.caseSensitiveCheckBox.Name = "caseSensitiveCheckBox";
            this.caseSensitiveCheckBox.Size = new System.Drawing.Size(94, 17);
            this.caseSensitiveCheckBox.TabIndex = 1;
            this.caseSensitiveCheckBox.Text = "Case sensitive";
            this.caseSensitiveCheckBox.UseVisualStyleBackColor = true;
            // 
            // progressBar1
            // 
            this.progressBar1.Location = new System.Drawing.Point(15, 126);
            this.progressBar1.Name = "progressBar1";
            this.progressBar1.Size = new System.Drawing.Size(114, 23);
            this.progressBar1.TabIndex = 13;
            // 
            // FindForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(311, 162);
            this.Controls.Add(this.progressBar1);
            this.Controls.Add(this.optionsGroupBox);
            this.Controls.Add(this.searchDirectionGroupBox);
            this.Controls.Add(this.nextButton);
            this.Controls.Add(this.searchForBox);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.closeButton);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.Name = "FindForm";
            this.Text = "Find";
            this.Load += new System.EventHandler(this.FindForm_Load);
            this.searchDirectionGroupBox.ResumeLayout(false);
            this.searchDirectionGroupBox.PerformLayout();
            this.optionsGroupBox.ResumeLayout(false);
            this.optionsGroupBox.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button closeButton;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox searchForBox;
        private System.Windows.Forms.Button nextButton;
        private System.Windows.Forms.GroupBox searchDirectionGroupBox;
        private System.Windows.Forms.RadioButton searchDirBackwardButton;
        private System.Windows.Forms.RadioButton searchDirForwardButton;
        private System.Windows.Forms.GroupBox optionsGroupBox;
        private System.Windows.Forms.CheckBox useRegexCheckBox;
        private System.Windows.Forms.CheckBox caseSensitiveCheckBox;
        private System.Windows.Forms.ProgressBar progressBar1;
    }
}
```

`UAssetGUI/FindForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace UAssetGUI
{
    public partial class FindForm : Form
    {
        public string SearchTerm = string.Empty;
        public bool UseRegex = false;
        public Regex RegularExpression;
        public bool CaseSensitive = false;
        public SearchDirection CurrentSearchDirection = SearchDirection.Forward;

        public FindForm()
        {
            InitializeComponent();
            progressBar1.Visible = false;
            searchDirForwardButton.Tag = SearchDirection.Forward;
            searchDirBackwardButton.Tag = SearchDirection.Backward;
            searchDirForwardButton.Checked = true;
        }

        private Form1 BaseForm;
        private void FindForm_Load(object sender, EventArgs e)
        {
            if (this.Owner is Form1) BaseForm = (Form1)this.Owner;

            UAGPalette.RefreshTheme(this);
            this.AdjustFormPosition();
        }

        private void SyncSettings()
        {
            SearchTerm = searchForBox.Text.Trim();
            CaseSensitive = caseSensitiveCheckBox.Checked;
            UseRegex = useRegexCheckBox.Checked;
            CurrentSearchDirection = (SearchDirection)(searchDirectionGroupBox.Controls.OfType<RadioButton>().FirstOrDefault(n => n.Checked).Tag);

            if (UseRegex)
            {
                RegexOptions ourOptions = RegexOptions.Compiled | RegexOptions.Multiline;
                if (!CaseSensitive) ourOptions |= RegexOptions.IgnoreCase;
                RegularExpression = new Regex(SearchTerm, ourOptions);
            }
        }

        private void closeButton_Click(object sender, EventArgs e)
        {
            if (ts != null) ts.Cancel();
            this.Dispose();
        }

        private bool DoesTextQualify(string txt)
        {
            if (UseRegex) return RegularExpression.IsMatch(txt);
            return CaseSensitive ? txt.Contains(SearchTerm) : (txt.IndexOf(SearchTerm, StringComparison.OrdinalIgnoreCase) >= 0);
        }

        private void TraverseToPopulatePreviouslyExpandedNodes(ISet<TreeNode> previouslyExpandedNodes, TreeNodeCollection nodes)
        {
            foreach (TreeNode node in nodes)
            {
                if (node.IsExpanded) previouslyExpandedNodes.Add(node);
                TraverseToPopulatePreviouslyExpandedNodes(previouslyExpandedNodes, node.Nodes);
            }
        }

        private void PerformSearch(CancellationToken cancelToken)
        {
            bool foundSomething = false; bool wasCanceled = false; TreeNode originalNode = null; TreeNode examiningNode = null; int minRow = -1;

            ISet<TreeNode> previouslyExpandedNodes = new HashSet<TreeNode>();

            UAGUtils.InvokeUI(() =>
            {
                progressBar1.Visible = true;
                progressBar1.Value = 0;
                progressBar1.Maximum = BaseForm.treeView1.GetNodeCount(true);
                BaseForm.dataGridView1.SuspendLayout();
                BaseForm.treeView1.SuspendLayout();
                BaseForm.treeView1.BeginUpdate();

                originalNode = BaseForm.treeView1.SelectedNode;
                examiningNode = BaseForm.treeView1.SelectedNode;
                minRow = BaseForm.dataGridView1.SelectedRows.Count > 0 ? BaseForm.dataGridView1.SelectedRows[0].Index : (BaseForm.dataGridView1.SelectedCells.Count > 0 ? BaseForm.dataGridView1.SelectedCells[0].RowIndex : -1);

                // store previously expanded nodes; could take a second
                TraverseToPopulatePreviouslyExpandedNodes(previouslyExpandedNodes, BaseForm.treeView1.Nodes);
            });

            try
            {
                while (examiningNode != null)
                {
                    if (cancelToken.IsCancellationRequested)
                    {
                        foundSomething = false; wasCanceled = true;
                        MessageBox.Show("Operation canceled.");
                        break;
                    }

                    UAGUtils.InvokeUI(() =>
                    {
                        // if dynamic tree, expand
                        if (examiningNode is PointingTreeNode ptn)
                        {
                            if (!ptn.ChildrenInitialized)
                            {
                                BaseForm.tableEditor.FillOutSubnodes(ptn, false);
                            }
                        }

                        BaseForm.treeView1.SelectedNode = examiningNode;
                        BaseForm.UpdateModeFromSelectedNode(examiningNode);

                        // check node name
                        if (DoesTextQualify(examiningNode.Text) && examiningNode != originalNode)
                        {
                            foundSomething = true;
                            return;
                        }

                        // check dgv
                        if (BaseForm.dataGridView1 != null && BaseForm.dataGridView1.Enabled && BaseForm.dataGridView1.Visible && BaseForm.dataGridView1.Rows.Count > 0)
                        {
                            int rowNum = CurrentSearchDirection == SearchDirection.Forward ? 0 : BaseForm.dataGridView1.Rows.Count - 1;
                            bool isSatisfied = false;
                            while (!isSatisfied)
                            {
                                int oldRowNum = rowNum;

                                rowNum += CurrentSearchDirection == SearchDirection.Forward ? 1 : -1;
                                isSatisfied = CurrentSearchDirection == SearchDirection.Forward ? rowNum >= BaseForm.dataGridView1.Rows.Count : rowNum < 0;

                                DataGridViewRow row = BaseForm.dataGridView1.Rows[oldRowNum];
                                if (minRow >= 0 && CurrentSearchDirection == SearchDirection.Forward && oldRowNum <= minRow) continue;
                                if (minRow >= 0 && CurrentSearchDirection == SearchDirection.Backward && oldRowNum >= minRow) continue;

                                if (row == null || row.Cells == null) continue;
                                foreach (DataGridViewCell cell in row.Cells)
                                {
                                    if (cell == null || cell.Value == null) continue;

                                    if (DoesTextQualify(cell.Value.ToString()))
                                    {
                                        if (!cell.Displayed) BaseForm.dataGridView1.FirstDisplayedScrollingRowIndex = row.Index;
                                        BaseForm.treeView1.SelectedNode.EnsureVisible();
                                        row.Selected = true;
                                        cell.Selected = true;
                                        foundSomething = true;
                                    }

                                    if (foundSomething) return;
                                }

                                if (foundSomething) return;
                            }
                        }

                        if (foundSomething) return;
                        minRow = -1;

                        if (progressBar1.Value < progressBar1.Maximum) progressBar1.Value++;
                        examiningNode = UAGFindUtils.GetNextNode(examiningNode, CurrentSearchDirection, previouslyExpandedNodes, BaseForm.tableEditor);
                    });

                    if (foundSomething) break;
                }
            }
            finally
            {
                UAGUtils.InvokeUI(() =>
                {
                    progressBar1.Value = progressBar1.Maximum;
                    BaseForm.dataGridView1.ResumeLayout();
                    BaseForm.treeView1.ResumeLayout();
                    BaseForm.treeView1.EndUpdate();

                    if (!foundSomething)
                    {
                        BaseForm.treeView1.SelectedNode = originalNode;
                        BaseForm.UpdateModeFromSelectedNode(originalNode);
                        if (!wasCanceled) MessageBox.Show("0 results found.");
                    }
                });
            }
        }

        private readonly CancellationTokenSource ts = new CancellationTokenSource();
        private void nextButton_Click(object sender, EventArgs e)
        {
            SyncSettings();
            if (BaseForm.tableEditor == null || BaseForm.tableEditor.asset == null) return;

            Task.Run(() =>
            {
                PerformSearch(ts.Token);
            });
        }
    }

    public enum SearchDirection
    {
        Forward,
        Backward
    }

    public static class UAGFindUtils
    {
        public static TreeNode GetLastNode(TreeNode node, TableHandler handler)
        {
            // if dynamic tree, expand
            if (node is PointingTreeNode ptn)
            {
                if (!ptn.ChildrenInitialized)
                {
                    handler.FillOutSubnodes(ptn, false);
                }
            }

            if (node.Nodes.Count == 0) return node;
            return GetLastNode(node.Nodes[node.Nodes.Count - 1], handler);
        }

        public static TreeNode GetNextNode(TreeNode node, SearchDirection dir, ISet<TreeNode> previouslyExpandedNodes, TableHandler handler, bool canGoDown = true)
        {
            if (node == null) return null;

            if (dir == SearchDirection.Forward)
            {
                if (node.Nodes.Count != 0 && canGoDown) return node.Nodes[0]; // go down one

                // we don't need this node anymore
                if (previouslyExpandedNodes.Contains(node))
                {
                    node.Expand();
                }
                else
                {
                    node.Collapse();
                }

                if (node.NextNode != null) return node.NextNode; // go forward one
                return GetNextNode(node.Parent, dir, previouslyExpandedNodes, handler, false); // go up one
            }
            else if (dir == SearchDirection.Backward)
            {
                // we don't need this node anymore
                if (previouslyExpandedNodes.Contains(node))
                {
                    node.Expand();
                }
                else
                {
                    node.Collapse();
                }

                if (node.PrevNode != null && node.PrevNode.Nodes.Count != 0) return GetLastNode(node.PrevNode, handler); // go backwards one (to previous sibling's last descendant)
                if (node.PrevNode != null) return node.PrevNode; // go backwards one (to previous sibling directly)
                return node.Parent; // go up one (to parent)
            }

            return null;
        }
    }
}

```

`UAssetGUI/FindForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UAssetGUI/Form1.Designer.cs`:

```cs
using System.Windows.Forms;

namespace UAssetGUI
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
            DataGridViewCellStyle dataGridViewCellStyle1 = new DataGridViewCellStyle();
            menuStrip1 = new MenuStrip();
            fileToolStripMenuItem = new ToolStripMenuItem();
            openToolStripMenuItem = new ToolStripMenuItem();
            openContainersToolStripMenuItem = new ToolStripMenuItem();
            saveToolStripMenuItem = new ToolStripMenuItem();
            saveAsToolStripMenuItem = new ToolStripMenuItem();
            editToolStripMenuItem = new ToolStripMenuItem();
            copyToolStripMenuItem = new ToolStripMenuItem();
            pasteToolStripMenuItem = new ToolStripMenuItem();
            deleteToolStripMenuItem = new ToolStripMenuItem();
            findToolStripMenuItem = new ToolStripMenuItem();
            mapStructTypeOverridesToolStripMenuItem = new ToolStripMenuItem();
            settingsToolStripMenuItem = new ToolStripMenuItem();
            viewToolStripMenuItem = new ToolStripMenuItem();
            expandAllToolStripMenuItem = new ToolStripMenuItem();
            collapseAllToolStripMenuItem = new ToolStripMenuItem();
            refreshToolStripMenuItem = new ToolStripMenuItem();
            recalculateNodesToolStripMenuItem = new ToolStripMenuItem();
            utilsToolStripMenuItem = new ToolStripMenuItem();
            executeScriptToolStripMenuItem = new ToolStripMenuItem();
            editScriptToolStripMenuItem = new ToolStripMenuItem();
            importMappingsToolStripMenuItem = new ToolStripMenuItem();
            patchusmapWithsavVersionInfoToolStripMenuItem = new ToolStripMenuItem();
            listValidPropertiesToolStripMenuItem = new ToolStripMenuItem();
            helpToolStripMenuItem = new ToolStripMenuItem();
            configDirToolStripMenuItem = new ToolStripMenuItem();
            issuesToolStripMenuItem = new ToolStripMenuItem();
            githubToolStripMenuItem = new ToolStripMenuItem();
            apiLinkToolStripMenuItem1 = new ToolStripMenuItem();
            dataGridView1 = new DataGridView();
            columnHeader1 = new ColumnHeader();
            comboSpecifyVersion = new ComboBox();
            nameMapContext = new ContextMenuStrip(components);
            replaceAllReferencesToolStripMenuItem = new ToolStripMenuItem();
            importBinaryData = new Button();
            exportBinaryData = new Button();
            setBinaryData = new Button();
            comboSpecifyMappings = new ComboBox();
            splitContainer1 = new SplitContainer();
            treeView1 = new ColorfulTreeView();
            menuStrip1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)dataGridView1).BeginInit();
            nameMapContext.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)splitContainer1).BeginInit();
            splitContainer1.Panel1.SuspendLayout();
            splitContainer1.Panel2.SuspendLayout();
            splitContainer1.SuspendLayout();
            SuspendLayout();
            // 
            // menuStrip1
            // 
            menuStrip1.ImageScalingSize = new System.Drawing.Size(24, 24);
            menuStrip1.Items.AddRange(new ToolStripItem[] { fileToolStripMenuItem, editToolStripMenuItem, viewToolStripMenuItem, utilsToolStripMenuItem, helpToolStripMenuItem });
            menuStrip1.Location = new System.Drawing.Point(6, 6);
            menuStrip1.Name = "menuStrip1";
            menuStrip1.Padding = new Padding(7, 2, 0, 2);
            menuStrip1.Size = new System.Drawing.Size(921, 24);
            menuStrip1.TabIndex = 0;
            menuStrip1.Text = "menuStrip1";
            // 
            // fileToolStripMenuItem
            // 
            fileToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { openToolStripMenuItem, openContainersToolStripMenuItem, saveToolStripMenuItem, saveAsToolStripMenuItem });
            fileToolStripMenuItem.Name = "fileToolStripMenuItem";
            fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
            fileToolStripMenuItem.Text = "File";
            // 
            // openToolStripMenuItem
            // 
            openToolStripMenuItem.Name = "openToolStripMenuItem";
            openToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.O;
            openToolStripMenuItem.Size = new System.Drawing.Size(224, 22);
            openToolStripMenuItem.Text = "Open";
            openToolStripMenuItem.Click += openToolStripMenuItem_Click;
            // 
            // openContainersToolStripMenuItem
            // 
            openContainersToolStripMenuItem.Name = "openContainersToolStripMenuItem";
            openContainersToolStripMenuItem.Size = new System.Drawing.Size(224, 22);
            openContainersToolStripMenuItem.Text = "Open containers...";
            openContainersToolStripMenuItem.Click += openContainersToolStripMenuItem_Click;
            // 
            // saveToolStripMenuItem
            // 
            saveToolStripMenuItem.Enabled = false;
            saveToolStripMenuItem.Name = "saveToolStripMenuItem";
            saveToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.S;
            saveToolStripMenuItem.Size = new System.Drawing.Size(224, 22);
            saveToolStripMenuItem.Text = "Save";
            saveToolStripMenuItem.Click += saveToolStripMenuItem_Click;
            // 
            // saveAsToolStripMenuItem
            // 
            saveAsToolStripMenuItem.Enabled = false;
            saveAsToolStripMenuItem.Name = "saveAsToolStripMenuItem";
            saveAsToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.Shift | Keys.S;
            saveAsToolStripMenuItem.Size = new System.Drawing.Size(224, 22);
            saveAsToolStripMenuItem.Text = "Save As";
            saveAsToolStripMenuItem.Click += saveAsToolStripMenuItem_Click;
            // 
            // editToolStripMenuItem
            // 
            editToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { copyToolStripMenuItem, pasteToolStripMenuItem, deleteToolStripMenuItem, findToolStripMenuItem, mapStructTypeOverridesToolStripMenuItem, settingsToolStripMenuItem });
            editToolStripMenuItem.Name = "editToolStripMenuItem";
            editToolStripMenuItem.Size = new System.Drawing.Size(39, 20);
            editToolStripMenuItem.Text = "Edit";
            // 
            // copyToolStripMenuItem
            // 
            copyToolStripMenuItem.Name = "copyToolStripMenuItem";
            copyToolStripMenuItem.Size = new System.Drawing.Size(240, 22);
            copyToolStripMenuItem.Text = "Copy";
            copyToolStripMenuItem.Click += copyToolStripMenuItem_Click;
            // 
            // pasteToolStripMenuItem
            // 
            pasteToolStripMenuItem.Name = "pasteToolStripMenuItem";
            pasteToolStripMenuItem.Size = new System.Drawing.Size(240, 22);
            pasteToolStripMenuItem.Text = "Paste";
            pasteToolStripMenuItem.Click += pasteToolStripMenuItem_Click;
            // 
            // deleteToolStripMenuItem
            // 
            deleteToolStripMenuItem.Name = "deleteToolStripMenuItem";
            deleteToolStripMenuItem.Size = new System.Drawing.Size(240, 22);
            deleteToolStripMenuItem.Text = "Delete";
            deleteToolStripMenuItem.Click += deleteToolStripMenuItem_Click;
            // 
            // findToolStripMenuItem
            // 
            findToolStripMenuItem.Enabled = false;
            findToolStripMenuItem.Name = "findToolStripMenuItem";
            findToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.F;
            findToolStripMenuItem.Size = new System.Drawing.Size(240, 22);
            findToolStripMenuItem.Text = "Find...";
            findToolStripMenuItem.Click += findToolStripMenuItem_Click;
            // 
            // mapStructTypeOverridesToolStripMenuItem
            // 
            mapStructTypeOverridesToolStripMenuItem.Name = "mapStructTypeOverridesToolStripMenuItem";
            mapStructTypeOverridesToolStripMenuItem.Size = new System.Drawing.Size(240, 22);
            mapStructTypeOverridesToolStripMenuItem.Text = "Edit map struct type overrides...";
            mapStructTypeOverridesToolStripMenuItem.Click += mapStructTypeOverridesToolStripMenuItem_Click;
            // 
            // settingsToolStripMenuItem
            // 
            settingsToolStripMenuItem.Name = "settingsToolStripMenuItem";
            settingsToolStripMenuItem.Size = new System.Drawing.Size(240, 22);
            settingsToolStripMenuItem.Text = "Settings...";
            settingsToolStripMenuItem.Click += settingsToolStripMenuItem_Click;
            // 
            // viewToolStripMenuItem
            // 
            viewToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { expandAllToolStripMenuItem, collapseAllToolStripMenuItem, refreshToolStripMenuItem, recalculateNodesToolStripMenuItem });
            viewToolStripMenuItem.Name = "viewToolStripMenuItem";
            viewToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
            viewToolStripMenuItem.Text = "View";
            // 
            // expandAllToolStripMenuItem
            // 
            expandAllToolStripMenuItem.Name = "expandAllToolStripMenuItem";
            expandAllToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.M;
            expandAllToolStripMenuItem.Size = new System.Drawing.Size(260, 22);
            expandAllToolStripMenuItem.Text = "Expand All";
            expandAllToolStripMenuItem.Click += expandAllToolStripMenuItem_Click;
            // 
            // collapseAllToolStripMenuItem
            // 
            collapseAllToolStripMenuItem.Name = "collapseAllToolStripMenuItem";
            collapseAllToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.L;
            collapseAllToolStripMenuItem.Size = new System.Drawing.Size(260, 22);
            collapseAllToolStripMenuItem.Text = "Collapse All";
            collapseAllToolStripMenuItem.Click += collapseAllToolStripMenuItem_Click;
            // 
            // refreshToolStripMenuItem
            // 
            refreshToolStripMenuItem.Name = "refreshToolStripMenuItem";
            refreshToolStripMenuItem.ShortcutKeys = Keys.F5;
            refreshToolStripMenuItem.Size = new System.Drawing.Size(260, 22);
            refreshToolStripMenuItem.Text = "Refresh";
            refreshToolStripMenuItem.Click += refreshToolStripMenuItem_Click;
            // 
            // recalculateNodesToolStripMenuItem
            // 
            recalculateNodesToolStripMenuItem.Name = "recalculateNodesToolStripMenuItem";
            recalculateNodesToolStripMenuItem.ShortcutKeys = Keys.Shift | Keys.F5;
            recalculateNodesToolStripMenuItem.Size = new System.Drawing.Size(260, 22);
            recalculateNodesToolStripMenuItem.Text = "Recalculate Nodes";
            recalculateNodesToolStripMenuItem.Click += refreshFullToolStripMenuItem_Click;
            // 
            // utilsToolStripMenuItem
            // 
            utilsToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { executeScriptToolStripMenuItem, editScriptToolStripMenuItem, importMappingsToolStripMenuItem, patchusmapWithsavVersionInfoToolStripMenuItem, listValidPropertiesToolStripMenuItem });
            utilsToolStripMenuItem.Name = "utilsToolStripMenuItem";
            utilsToolStripMenuItem.Size = new System.Drawing.Size(42, 20);
            utilsToolStripMenuItem.Text = "Utils";
            // 
            // executeScriptToolStripMenuItem
            // 
            executeScriptToolStripMenuItem.Name = "executeScriptToolStripMenuItem";
            executeScriptToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
            executeScriptToolStripMenuItem.Text = "Execute script...";
            // 
            // executeScriptToolStripMenuItem
            // 
            editScriptToolStripMenuItem.Name = "editScriptToolStripMenuItem";
            editScriptToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
            editScriptToolStripMenuItem.Text = "Edit script...";
            // 
            // importMappingsToolStripMenuItem
            // 
            importMappingsToolStripMenuItem.Name = "importMappingsToolStripMenuItem";
            importMappingsToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
            importMappingsToolStripMenuItem.Text = "Import mappings...";
            importMappingsToolStripMenuItem.Click += importMappingsToolStripMenuItem_Click;
            // 
            // patchusmapWithsavVersionInfoToolStripMenuItem
            // 
            patchusmapWithsavVersionInfoToolStripMenuItem.Name = "patchusmapWithsavVersionInfoToolStripMenuItem";
            patchusmapWithsavVersionInfoToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
            patchusmapWithsavVersionInfoToolStripMenuItem.Text = "Patch .usmap with .sav version info...";
            patchusmapWithsavVersionInfoToolStripMenuItem.Click += patchusmapWithsavVersionInfoToolStripMenuItem_Click;
            // 
            // listValidPropertiesToolStripMenuItem
            // 
            listValidPropertiesToolStripMenuItem.Name = "listValidPropertiesToolStripMenuItem";
            listValidPropertiesToolStripMenuItem.Size = new System.Drawing.Size(269, 22);
            listValidPropertiesToolStripMenuItem.Text = "Dump serializable properties...";
            listValidPropertiesToolStripMenuItem.Click += listValidPropertiesToolStripMenuItem_Click;
            // 
            // helpToolStripMenuItem
            // 
            helpToolStripMenuItem.DropDownItems.AddRange(new ToolStripItem[] { configDirToolStripMenuItem, issuesToolStripMenuItem, githubToolStripMenuItem, apiLinkToolStripMenuItem1 });
            helpToolStripMenuItem.Name = "helpToolStripMenuItem";
            helpToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
            helpToolStripMenuItem.Text = "Help";
            // 
            // configDirToolStripMenuItem
            // 
            configDirToolStripMenuItem.Name = "configDirToolStripMenuItem";
            configDirToolStripMenuItem.Size = new System.Drawing.Size(199, 22);
            configDirToolStripMenuItem.Text = "Open config directory...";
            configDirToolStripMenuItem.Click += configDirToolStripMenuItem_Click;
            // 
            // issuesToolStripMenuItem
            // 
            issuesToolStripMenuItem.Name = "issuesToolStripMenuItem";
            issuesToolStripMenuItem.Size = new System.Drawing.Size(199, 22);
            issuesToolStripMenuItem.Text = "Give feedback";
            issuesToolStripMenuItem.Click += issuesToolStripMenuItem_Click;
            // 
            // githubToolStripMenuItem
            // 
            githubToolStripMenuItem.Name = "githubToolStripMenuItem";
            githubToolStripMenuItem.Size = new System.Drawing.Size(199, 22);
            githubToolStripMenuItem.Text = "UAssetGUI on GitHub";
            githubToolStripMenuItem.Click += githubToolStripMenuItem_Click;
            // 
            // apiLinkToolStripMenuItem1
            // 
            apiLinkToolStripMenuItem1.Name = "apiLinkToolStripMenuItem1";
            apiLinkToolStripMenuItem1.Size = new System.Drawing.Size(199, 22);
            apiLinkToolStripMenuItem1.Text = "UAssetAPI on GitHub";
            apiLinkToolStripMenuItem1.Click += apiLinkToolStripMenuItem_Click;
            // 
            // dataGridView1
            // 
            dataGridView1.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.AllCells;
            dataGridView1.BackgroundColor = System.Drawing.Color.FromArgb(211, 211, 211);
            dataGridView1.BorderStyle = BorderStyle.Fixed3D;
            dataGridView1.ClipboardCopyMode = DataGridViewClipboardCopyMode.EnableWithoutHeaderText;
            dataGridView1.ColumnHeadersBorderStyle = DataGridViewHeaderBorderStyle.Single;
            dataGridViewCellStyle1.Alignment = DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle1.BackColor = System.Drawing.SystemColors.Control;
            dataGridViewCellStyle1.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, 0);
            dataGridViewCellStyle1.ForeColor = System.Drawing.SystemColors.WindowText;
            dataGridViewCellStyle1.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle1.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle1.WrapMode = DataGridViewTriState.True;
            dataGridView1.ColumnHeadersDefaultCellStyle = dataGridViewCellStyle1;
            dataGridView1.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            dataGridView1.Dock = DockStyle.Fill;
            dataGridView1.EditMode = DataGridViewEditMode.EditProgrammatically;
            dataGridView1.EnableHeadersVisualStyles = false;
            dataGridView1.Location = new System.Drawing.Point(0, 0);
            dataGridView1.Margin = new Padding(4, 3, 4, 3);
            dataGridView1.Name = "dataGridView1";
            dataGridView1.RowHeadersBorderStyle = DataGridViewHeaderBorderStyle.Single;
            dataGridView1.RowHeadersWidth = 60;
            dataGridView1.RowHeadersWidthSizeMode = DataGridViewRowHeadersWidthSizeMode.DisableResizing;
            dataGridView1.RowTemplate.Resizable = DataGridViewTriState.True;
            dataGridView1.Size = new System.Drawing.Size(508, 483);
            dataGridView1.TabIndex = 2;
            dataGridView1.CellContentClick += dataGridClickCell;
            dataGridView1.CellDoubleClick += dataGridView1_CellDoubleClick;
            dataGridView1.CellEndEdit += dataGridView1_CellEndEdit;
            dataGridView1.CellEnter += dataGridView1_CellEnter;
            dataGridView1.CellValueChanged += dataGridEditCell;
            dataGridView1.EditingControlShowing += dataGridView1_EditingControlShowing;
            // 
            // columnHeader1
            // 
            columnHeader1.Text = "";
            columnHeader1.Width = 200;
            // 
            // comboSpecifyVersion
            // 
            comboSpecifyVersion.DrawMode = DrawMode.OwnerDrawFixed;
            comboSpecifyVersion.DropDownStyle = ComboBoxStyle.DropDownList;
            comboSpecifyVersion.FlatStyle = FlatStyle.Flat;
            comboSpecifyVersion.FormattingEnabled = true;
            comboSpecifyVersion.Location = new System.Drawing.Point(844, 3);
            comboSpecifyVersion.Margin = new Padding(4, 3, 4, 3);
            comboSpecifyVersion.Name = "comboSpecifyVersion";
            comboSpecifyVersion.Size = new System.Drawing.Size(89, 24);
            comboSpecifyVersion.TabIndex = 3;
            comboSpecifyVersion.DrawItem += comboSpecifyVersion_DrawItem;
            comboSpecifyVersion.SelectedIndexChanged += comboSpecifyVersion_SelectedIndexChanged;
            // 
            // nameMapContext
            // 
            nameMapContext.ImageScalingSize = new System.Drawing.Size(24, 24);
            nameMapContext.Items.AddRange(new ToolStripItem[] { replaceAllReferencesToolStripMenuItem });
            nameMapContext.Name = "treeNodeContext";
            nameMapContext.Size = new System.Drawing.Size(197, 26);
            // 
            // replaceAllReferencesToolStripMenuItem
            // 
            replaceAllReferencesToolStripMenuItem.Name = "replaceAllReferencesToolStripMenuItem";
            replaceAllReferencesToolStripMenuItem.Size = new System.Drawing.Size(196, 22);
            replaceAllReferencesToolStripMenuItem.Text = "Replace all references...";
            replaceAllReferencesToolStripMenuItem.Click += replaceAllReferencesToolStripMenuItem_Click;
            // 
            // importBinaryData
            // 
            importBinaryData.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, 0);
            importBinaryData.Location = new System.Drawing.Point(444, 1);
            importBinaryData.Margin = new Padding(4, 3, 4, 3);
            importBinaryData.Name = "importBinaryData";
            importBinaryData.Size = new System.Drawing.Size(88, 27);
            importBinaryData.TabIndex = 4;
            importBinaryData.Text = "Import";
            importBinaryData.UseVisualStyleBackColor = true;
            importBinaryData.Click += importBinaryData_Click;
            // 
            // exportBinaryData
            // 
            exportBinaryData.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, 0);
            exportBinaryData.Location = new System.Drawing.Point(539, 1);
            exportBinaryData.Margin = new Padding(4, 3, 4, 3);
            exportBinaryData.Name = "exportBinaryData";
            exportBinaryData.Size = new System.Drawing.Size(88, 27);
            exportBinaryData.TabIndex = 5;
            exportBinaryData.Text = "Export";
            exportBinaryData.UseVisualStyleBackColor = true;
            exportBinaryData.Click += exportBinaryData_Click;
            // 
            // setBinaryData
            // 
            setBinaryData.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, 0);
            setBinaryData.Location = new System.Drawing.Point(634, 1);
            setBinaryData.Margin = new Padding(4, 3, 4, 3);
            setBinaryData.Name = "setBinaryData";
            setBinaryData.Size = new System.Drawing.Size(88, 27);
            setBinaryData.TabIndex = 6;
            setBinaryData.Text = "Set to null...";
            setBinaryData.UseVisualStyleBackColor = true;
            setBinaryData.Click += setBinaryData_Click;
            // 
            // comboSpecifyMappings
            // 
            comboSpecifyMappings.DrawMode = DrawMode.OwnerDrawFixed;
            comboSpecifyMappings.DropDownStyle = ComboBoxStyle.DropDownList;
            comboSpecifyMappings.FlatStyle = FlatStyle.Flat;
            comboSpecifyMappings.FormattingEnabled = true;
            comboSpecifyMappings.Location = new System.Drawing.Point(728, 3);
            comboSpecifyMappings.Margin = new Padding(4, 3, 4, 3);
            comboSpecifyMappings.Name = "comboSpecifyMappings";
            comboSpecifyMappings.Size = new System.Drawing.Size(108, 24);
            comboSpecifyMappings.TabIndex = 3;
            comboSpecifyMappings.DrawItem += comboSpecifyVersion_DrawItem;
            comboSpecifyMappings.SelectedIndexChanged += comboSpecifyMappings_SelectedIndexChanged;
            // 
            // splitContainer1
            // 
            splitContainer1.Dock = DockStyle.Fill;
            splitContainer1.FixedPanel = FixedPanel.Panel1;
            splitContainer1.Location = new System.Drawing.Point(6, 30);
            splitContainer1.Margin = new Padding(4, 3, 4, 3);
            splitContainer1.Name = "splitContainer1";
            // 
            // splitContainer1.Panel1
            // 
            splitContainer1.Panel1.Controls.Add(treeView1);
            // 
            // splitContainer1.Panel2
            // 
            splitContainer1.Panel2.Controls.Add(dataGridView1);
            splitContainer1.Size = new System.Drawing.Size(921, 483);
            splitContainer1.SplitterDistance = 408;
            splitContainer1.SplitterWidth = 5;
            splitContainer1.TabIndex = 7;
            // 
            // treeView1
            // 
            treeView1.BackColor = System.Drawing.Color.FromArgb(211, 211, 211);
            treeView1.Dock = DockStyle.Fill;
            treeView1.DrawMode = TreeViewDrawMode.OwnerDrawText;
            treeView1.HideSelection = false;
            treeView1.Location = new System.Drawing.Point(0, 0);
            treeView1.Margin = new Padding(4, 3, 4, 3);
            treeView1.Name = "treeView1";
            treeView1.ShowLines = false;
            treeView1.ShowNodeToolTips = true;
            treeView1.Size = new System.Drawing.Size(408, 483);
            treeView1.TabIndex = 1;
            treeView1.BeforeExpand += treeView1_BeforeExpand;
            treeView1.BeforeSelect += treeView1_BeforeSelect;
            treeView1.AfterSelect += treeView1_AfterSelect;
            treeView1.KeyDown += treeView1_KeyDown;
            // 
            // Form1
            // 
            AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            AutoScaleMode = AutoScaleMode.Font;
            ClientSize = new System.Drawing.Size(933, 519);
            Controls.Add(comboSpecifyMappings);
            Controls.Add(setBinaryData);
            Controls.Add(exportBinaryData);
            Controls.Add(importBinaryData);
            Controls.Add(comboSpecifyVersion);
            Controls.Add(splitContainer1);
            Controls.Add(menuStrip1);
            MainMenuStrip = menuStrip1;
            Margin = new Padding(4, 3, 4, 3);
            Name = "Form1";
            Padding = new Padding(6);
            Text = "UAssetGUI";
            Activated += Form1_Activated;
            Load += Form1_Load;
            menuStrip1.ResumeLayout(false);
            menuStrip1.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)dataGridView1).EndInit();
            nameMapContext.ResumeLayout(false);
            splitContainer1.Panel1.ResumeLayout(false);
            splitContainer1.Panel2.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)splitContainer1).EndInit();
            splitContainer1.ResumeLayout(false);
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem openToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem saveAsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem editToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem copyToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem pasteToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem deleteToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem findToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem viewToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem expandAllToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem collapseAllToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem helpToolStripMenuItem;
        private ColumnHeader columnHeader1;
        private ToolStripMenuItem refreshToolStripMenuItem;
        private ToolStripMenuItem recalculateNodesToolStripMenuItem;
        private ToolStripMenuItem apiLinkToolStripMenuItem1;
        private ToolStripMenuItem githubToolStripMenuItem;
        private ToolStripMenuItem replaceAllReferencesToolStripMenuItem;
        public ContextMenuStrip nameMapContext;
        private ToolStripMenuItem issuesToolStripMenuItem;
        private ToolStripMenuItem configDirToolStripMenuItem;
        private ToolStripMenuItem mapStructTypeOverridesToolStripMenuItem;
        public ComboBox comboSpecifyVersion;
        private ToolStripMenuItem settingsToolStripMenuItem;
        public Button importBinaryData;
        public Button exportBinaryData;
        public Button setBinaryData;
        internal ToolStripMenuItem saveToolStripMenuItem;
        public ComboBox comboSpecifyMappings;
        private ToolStripMenuItem listValidPropertiesToolStripMenuItem;
        private ToolStripMenuItem utilsToolStripMenuItem;
        private ToolStripMenuItem patchusmapWithsavVersionInfoToolStripMenuItem;
        private ToolStripMenuItem importMappingsToolStripMenuItem;
        public ToolStripMenuItem executeScriptToolStripMenuItem;
        public ToolStripMenuItem editScriptToolStripMenuItem;
        private ToolStripMenuItem openContainersToolStripMenuItem;
    }
}


```

`UAssetGUI/Form1.cs`:

```cs
using DiscordRPC;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Metadata;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using UAssetAPI;
using UAssetAPI.ExportTypes;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetGUI
{
    public partial class Form1 : Form
    {
        public EngineVersion ParsingVersion = EngineVersion.UNKNOWN;
        public Usmap ParsingMappings = null;
        internal DataGridView dataGridView1;
        internal ColorfulTreeView treeView1;
        internal SplitContainer splitContainer1;
        internal MenuStrip menuStrip1;
        internal AC7Decrypt ac7decrypt;

        public TableHandler tableEditor;
        public ByteViewer byteView1;
        public TextBox jsonView;

        private DiscordRpcClient _discordRpc = null;

        public static readonly string UsmapInstructionsNotice = "If you have a .usmap file for this game, go to Utils --> Import Mappings... and select your .usmap file to import.";

        private void DisposeDiscordRpc()
        {
            if (_discordRpc == null || _discordRpc.IsDisposed) return;
            _discordRpc.ClearPresence();
            _discordRpc.Dispose();
        }

        internal DiscordRpcClient DiscordRPC
        {
            get
            {
                if (_discordRpc == null || _discordRpc.IsDisposed)
                {
                    _discordRpc = new DiscordRpcClient("1035701531342811156");
                    _discordRpc.Initialize();
                }
                else if (!_discordRpc.IsInitialized)
                {
                    _discordRpc.Initialize();
                }
                return _discordRpc;
            }
        }

        public string DisplayVersion
        {
            get
            {
                return "UAssetGUI v" + UAGUtils._displayVersion;
            }
        }

        public Form1()
        {
            InitializeComponent();

            UAGUtils.InitializeInvoke(this);

            UAGUtils.InvokeUI(() =>
            {
                try
                {
                    UAGConfig.Load();

                    Assembly assembly = Assembly.GetExecutingAssembly();
                    UAGUtils._displayVersion = assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion;

                    // version suffix based on nature of the build
#if RELEASEX
                    UAGUtils._displayVersion += "x";
#elif DEBUG || DEBUGVERBOSE || DEBUGTRACING
                    UAGUtils._displayVersion += "d";
#endif

                    string gitVersionGUI = string.Empty;
                    using (Stream stream = assembly.GetManifestResourceStream("UAssetGUI.git_commit.txt"))
                    {
                        if (stream != null)
                        {
                            using (StreamReader reader = new StreamReader(stream))
                            {
                                if (reader != null) gitVersionGUI = reader.ReadToEnd().Trim();
                            }
                        }
                    }

                    if (!gitVersionGUI.All("0123456789abcdef".Contains)) gitVersionGUI = string.Empty;

                    string gitVersionAPI = string.Empty;
                    using (Stream stream = typeof(PropertyData).Assembly.GetManifestResourceStream("UAssetAPI.git_commit.txt"))
                    {
                        if (stream != null)
                        {
                            using (StreamReader reader = new StreamReader(stream))
                            {
                                if (reader != null) gitVersionAPI = reader.ReadToEnd().Trim();
                            }
                        }
                    }

                    if (!gitVersionAPI.All("0123456789abcdef".Contains)) gitVersionAPI = string.Empty;

                    if (!string.IsNullOrEmpty(gitVersionGUI))
                    {
                        UAGUtils._displayVersion += " (" + gitVersionGUI;
                        if (!string.IsNullOrEmpty(gitVersionAPI))
                        {
                            UAGUtils._displayVersion += " - " + gitVersionAPI;
                        }
                        UAGUtils._displayVersion += ")";
                    }

                    this.Text = DisplayVersion;
                    this.AllowDrop = true;
                    dataGridView1.Visible = true;

                    // Extra data viewer
                    byteView1 = new ByteViewer
                    {
                        Dock = DockStyle.Fill,
                        AutoScroll = true,
                        AutoSize = true,
                        Visible = false
                    };
                    splitContainer1.Panel2.Controls.Add(byteView1);

                    jsonView = new TextBox
                    {
                        Dock = DockStyle.Fill,
                        Visible = false,
                        AutoSize = true,
                        Multiline = true,
                        ReadOnly = true,
                        MaxLength = int.MaxValue,
                        ScrollBars = ScrollBars.Both,
                    };
                    splitContainer1.Panel2.Controls.Add(jsonView);

                    jsonView.TextChanged += (object sender, EventArgs e) => { if (tableEditor == null) return; tableEditor.dirtySinceLastLoad = true; SetUnsavedChanges(true); };

                    importBinaryData.Visible = false;
                    exportBinaryData.Visible = false;
                    setBinaryData.Visible = false;

                    // Enable double buffering to look nicer
                    if (!SystemInformation.TerminalServerSession)
                    {
                        Type ourGridType = dataGridView1.GetType();
                        PropertyInfo pi = ourGridType.GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic);
                        pi.SetValue(dataGridView1, true, null);
                    }

                    // Auto resizing
                    SizeChanged += frm_sizeChanged;
                    FormClosing += frm_closing;

                    // position of ByteViewer buttons depends on splitter location so resize if splitter moves
                    splitContainer1.SplitterMoved += (sender, e) => { ForceResize(); };
                    splitContainer1.SplitterDistance = UAGPalette.InitialSplitterDistance;

                    // Drag-and-drop support
                    DragEnter += new DragEventHandler(frm_DragEnter);
                    DragDrop += new DragEventHandler(frm_DragDrop);

                    dataGridView1.MouseWheel += dataGridView1_MouseWheel;
                    //dataGridView1.EditMode = UAGConfig.Data.DoubleClickToEdit ? DataGridViewEditMode.EditProgrammatically : DataGridViewEditMode.EditOnEnter;

                    menuStrip1.Renderer = new UAGMenuStripRenderer();
                    foreach (ToolStripMenuItem entry in menuStrip1.Items)
                    {
                        entry.DropDownOpened += (sender, args) =>
                        {
                            isDropDownOpened[entry] = true;
                        };
                        entry.DropDownClosed += (sender, args) =>
                        {
                            isDropDownOpened[entry] = false;
                        };
                    }

                    ac7decrypt = new AC7Decrypt();

                    UpdateRPC();
                }
                catch (Exception ex)
                {
                    MessageBox.Show("An error occured while initializing!\n" + ex.GetType() + ": " + ex.Message + "\n\nUAssetGUI will now close.", "UAssetGUI");
                    Environment.Exit(1); // kill the process
                }
            });
        }

        private static Dictionary<ToolStripItem, bool> isDropDownOpened = new Dictionary<ToolStripItem, bool>();
        public static bool IsDropDownOpened(ToolStripItem item)
        {
            if (!isDropDownOpened.ContainsKey(item)) return false;
            return isDropDownOpened[item];
        }

        private List<string> allMappingsKeys = new List<string>();

        public void OpenFileContainerForm(string path = null)
        {
            var test = new FileContainerForm();
            test.CurrentContainerPath = path;
            test.BaseForm = this;
            test.Show();
        }

        internal void UpdateMappings(string newSelection = null, bool alsoCheckVersion = true)
        {
            UAGConfig.LoadMappings();
            UAGUtils.InvokeUI(() =>
            {
                allMappingsKeys.Clear();
                allMappingsKeys.Add("No mappings");
                allMappingsKeys.AddRange(UAGConfig.AllMappings.Keys.OrderBy(s => s).ToArray());
                comboSpecifyMappings.Items.Clear();
                comboSpecifyMappings.Items.AddRange(allMappingsKeys.ToArray());

                string initialSelection = newSelection == null ? (allMappingsKeys.Contains(UAGConfig.Data.PreferredMappings) ? UAGConfig.Data.PreferredMappings : allMappingsKeys[0]) : newSelection;

                bool success = false;
                for (int i = 0; i < allMappingsKeys.Count; i++)
                {
                    if (allMappingsKeys[i] == initialSelection)
                    {
                        comboSpecifyMappings.SelectedIndex = i;
                        success = true;
                        break;
                    }
                }

                if (!success)
                {
                    comboSpecifyMappings.SelectedIndex = 0;
                }

                UpdateComboSpecifyMappings(alsoCheckVersion);
            });
        }

        private string[] versionOptionsKeys = new string[]
        {
            "Unknown",
            "4.0",
            "4.1",
            "4.2",
            "4.3",
            "4.4",
            "4.5",
            "4.6",
            "4.7",
            "4.8",
            "4.9",
            "4.10",
            "4.11",
            "4.12",
            "4.13",
            "4.14",
            "4.15",
            "4.16",
            "4.17",
            "4.18",
            "4.19",
            "4.20",
            "4.21",
            "4.22",
            "4.23",
            "4.24",
            "4.25",
            "4.26",
            "4.27",
            "5.0EA",
            "5.0",
            "5.1",
            "5.2",
            "5.3",
            "5.4",
            "5.5",
            "5.6",
            "5.7",
        };

        private EngineVersion[] versionOptionsValues = new EngineVersion[]
        {
            EngineVersion.UNKNOWN,
            EngineVersion.VER_UE4_0,
            EngineVersion.VER_UE4_1,
            EngineVersion.VER_UE4_2,
            EngineVersion.VER_UE4_3,
            EngineVersion.VER_UE4_4,
            EngineVersion.VER_UE4_5,
            EngineVersion.VER_UE4_6,
            EngineVersion.VER_UE4_7,
            EngineVersion.VER_UE4_8,
            EngineVersion.VER_UE4_9,
            EngineVersion.VER_UE4_10,
            EngineVersion.VER_UE4_11,
            EngineVersion.VER_UE4_12,
            EngineVersion.VER_UE4_13,
            EngineVersion.VER_UE4_14,
            EngineVersion.VER_UE4_15,
            EngineVersion.VER_UE4_16,
            EngineVersion.VER_UE4_17,
            EngineVersion.VER_UE4_18,
            EngineVersion.VER_UE4_19,
            EngineVersion.VER_UE4_20,
            EngineVersion.VER_UE4_21,
            EngineVersion.VER_UE4_22,
            EngineVersion.VER_UE4_23,
            EngineVersion.VER_UE4_24,
            EngineVersion.VER_UE4_25,
            EngineVersion.VER_UE4_26,
            EngineVersion.VER_UE4_27,
            EngineVersion.VER_UE5_0EA,
            EngineVersion.VER_UE5_0,
            EngineVersion.VER_UE5_1,
            EngineVersion.VER_UE5_2,
            EngineVersion.VER_UE5_3,
            EngineVersion.VER_UE5_4,
            EngineVersion.VER_UE5_5,
            EngineVersion.VER_UE5_6,
            EngineVersion.VER_UE5_7,
        };

        public static readonly string GitHubRepo = "atenfyr/UAssetGUI";
        private Version latestOnlineVersion = null;
        private void Form1_Load(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                // sync size from config
                if (UAGConfig.Data.RestoreSize)
                {
                    this.Size = new Size(UAGConfig.Data.StartupWidth, UAGConfig.Data.StartupHeight);
                }

                UAGPalette.InitializeTheme();
                UAGPalette.RefreshTheme(this);

                // load mappings and update combo box
                UpdateMappings(null, false);

                // load scripts
                UAGConfig.RefreshAllScriptIDs();

                // update version combo box
                string initialSelection = versionOptionsKeys[0];
                try
                {
                    initialSelection = UAGConfig.Data.PreferredVersion;
                }
                catch
                {
                    initialSelection = versionOptionsKeys[0];
                }

                comboSpecifyVersion.Items.AddRange(versionOptionsKeys);
                comboSpecifyVersion.SelectedIndex = 0;

                for (int i = 0; i < versionOptionsKeys.Length; i++)
                {
                    if (versionOptionsKeys[i] == initialSelection)
                    {
                        comboSpecifyVersion.SelectedIndex = i;
                        break;
                    }
                }

                UpdateComboSpecifyVersion();

                // set text for copy/paste/delete
                this.copyToolStripMenuItem.ShortcutKeyDisplayString = UAGUtils.ShortcutToText(Keys.Control | Keys.C);
                this.pasteToolStripMenuItem.ShortcutKeyDisplayString = UAGUtils.ShortcutToText(Keys.Control | Keys.V);
                this.deleteToolStripMenuItem.ShortcutKeyDisplayString = UAGUtils.ShortcutToText(Keys.Delete);

                this.menuStrip1.Items.OfType<ToolStripMenuItem>().ToList().ForEach(tsmi =>
                {
                    tsmi.MouseHover += (sender, arg) => ((ToolStripDropDownItem)sender).ShowDropDown();
                });

                // Fetch the latest version from github
                Task.Run(() =>
                {
                    latestOnlineVersion = GitHubAPI.GetLatestVersionFromGitHub(GitHubRepo);
                }).ContinueWith(res =>
                {
                    if (UAGConfig.Data.EnableUpdateNotice && latestOnlineVersion != null && latestOnlineVersion.IsUAGVersionLower())
                    {
                        DialogResult updateBoxRes = MessageBox.Show("A new version of UAssetGUI (v" + latestOnlineVersion + ") is available to download!\nWould you like to open the webpage in your browser?", "Notice", MessageBoxButtons.YesNo);
                        switch (updateBoxRes)
                        {
                            case DialogResult.Yes:
                                UAGUtils.OpenURL("https://github.com/" + GitHubRepo + "/releases/latest");
                                break;
                            default:
                                break;
                        }
                    }
                }, TaskScheduler.FromCurrentSynchronizationContext());

                UpdateVersionFromMappings();

                // Command line parameter support
                string[] args = Environment.GetCommandLineArgs();
                if (args.Length > 1)
                {
                    EngineVersion selectedVer = EngineVersion.UNKNOWN;

                    if (args.Length > 2)
                    {
                        if (int.TryParse(args[2], out int selectedVerRaw)) selectedVer = EngineVersion.VER_UE4_0 + selectedVerRaw;
                        else Enum.TryParse(args[2], out selectedVer);
                    }
                    if (args.Length > 3)
                    {
                        UpdateMappings(args[3]);
                    }

                    if (selectedVer > EngineVersion.UNKNOWN) SetParsingVersion(selectedVer);
                    LoadFileAt(args[1]);
                }
            });
        }

        private ISet<string> unknownTypes = new HashSet<string>();
        private ISet<string> rawStructTypes = new HashSet<string>();
        private int numRawStructs = 0;
        private bool RecordUnknownProperty(PropertyData dat)
        {
            if (dat == null) return false;

            if (dat is UnknownPropertyData unknownDat)
            {
                string serializingType = unknownDat?.SerializingPropertyType?.Value;
                if (!string.IsNullOrEmpty(serializingType))
                {
                    unknownTypes.Add(serializingType);
                    return true;
                }
            }
            if (dat is RawStructPropertyData unknownDat2)
            {
                numRawStructs++;
                string serializingType = unknownDat2?.StructType?.ToString();
                if (!string.IsNullOrEmpty(serializingType))
                {
                    rawStructTypes.Add(serializingType);
                    return true;
                }
            }
            return false;
        }

        private void GetUnknownProperties(PropertyData dat)
        {
            RecordUnknownProperty(dat);

            if (dat is ArrayPropertyData arrDat)
            {
                for (int i = 0; i < arrDat.Value.Length; i++) GetUnknownProperties(arrDat.Value[i]);
            }
            else if (dat is StructPropertyData strucDat)
            {
                for (int i = 0; i < strucDat.Value.Count; i++) GetUnknownProperties(strucDat.Value[i]);
            }
            else if (dat is MapPropertyData mapDat)
            {
                foreach (var entry in mapDat.Value)
                {
                    GetUnknownProperties(entry.Key);
                    GetUnknownProperties(entry.Value);
                }
            }
        }

        public uint GetFileSignature(string path, out byte[] nextBytes)
        {
            byte[] buffer = new byte[4];
            uint res = uint.MaxValue;
            nextBytes = new byte[32];

            using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read))
            {
                if (fs.Read(buffer, 0, buffer.Length) == buffer.Length) res = BitConverter.ToUInt32(buffer, 0);
                fs.Read(nextBytes, 0, nextBytes.Length);
            }

            return res;
        }

        public void LoadFileAt(string filePath, FileContainerForm parentContainerForm = null)
        {
            UAGUtils.InvokeUI(() => LoadFileAtInternal(filePath, parentContainerForm));
        }

        public DateTime LastLoadTimestamp = DateTime.UtcNow;
        private void LoadFileAtInternal(string filePath, FileContainerForm parentContainerForm = null)
        {
            dataGridView1.Visible = true;
            byteView1.Visible = false;
            jsonView.Visible = false;

            bool didACE7Decrypt = false;
            string jsonTracingPath = null;

            try
            {
                UAsset targetAsset;
                string fileExtension = Path.GetExtension(filePath);
                string savingPath = filePath;
                bool desiredSetUnsavedChanges = false;
                switch (fileExtension)
                {
                    case ".json":
                        try
                        {
                            savingPath = Path.ChangeExtension(filePath, "uasset");
                            using (var sr = new FileStream(filePath, FileMode.Open))
                            {
                                targetAsset = UAsset.DeserializeJson(sr);
                            }
                            targetAsset.Mappings = ParsingMappings;
                            targetAsset.FilePath = filePath;
                            desiredSetUnsavedChanges = true;
                        }
                        catch (JsonSerializationException ex)
                        {
                            if (ex?.Message != null && ex.Message.Contains("Cannot deserialize the current JSON array")) // OK because Newtonsoft.Json does not translate exceptions
                            {
                                UAGUtils.InvokeUI(() => { MessageBox.Show("Failed to open this file! This file is likely an FModel/CUE4Parse JSON file, which cannot be directly loaded into UAssetGUI.\n\nPlease export assets to JSON using UAssetGUI (File -> Save As), or look into other tools such as JsonAsAsset (https://github.com/JsonAsAsset/JsonAsAsset) for interpreting CUE4Parse JSON.", "Uh oh!"); });
                                return;
                            }
                            else
                            {
                                throw;
                            }
                        }
                        break;
                    case ".pak":
                    case ".utoc":
                    case ".ucas":
                        OpenFileContainerForm(filePath);
                        return;
                    default:
                        MapStructTypeOverrideForm.LoadFromConfig();

                        uint sig = GetFileSignature(filePath, out byte[] nextBytes);

                        uint nextFourBytes = uint.MaxValue;
                        uint ue4CookedHeaderSize = uint.MaxValue;
                        if (nextBytes.Length >= 4) nextFourBytes = BitConverter.ToUInt32(nextBytes.Take(4).ToArray());
                        if (nextBytes.Length >= 24) ue4CookedHeaderSize = BitConverter.ToUInt32(nextBytes.Skip(20).Take(4).ToArray());

                        if (sig == UAsset.ACE7_MAGIC)
                        {
                            // Decrypt file in-situ
                            ac7decrypt.Decrypt(filePath, filePath);
                            didACE7Decrypt = true;
                        }
                        else if (sig != UAsset.UASSET_MAGIC)
                        {
                            // check if opened .usmap
                            if (Path.GetExtension(filePath) == ".usmap")
                            {
                                ImportMappingsFromPathInteractive(filePath);
                            }
                            // check if accidentally opened .uexp
                            else if (Path.GetExtension(filePath) == ".uexp")
                            {
                                MessageBox.Show("Failed to open this file! This is a .uexp file, which cannot be read directly. Please open the respective .uasset file instead.", "Uh oh!");
                            }
                            // check if Zen asset for custom popup
                            // this definitely has potential for false positives, but it will still filter out basically any other file type, if it mattered that much i'd just actually parse the thing
                            else if (Path.GetExtension(filePath) == ".uasset" && (sig == 0 || sig == 1) && nextFourBytes > 40 && nextFourBytes < 1e9) // IsUnversioned reasonable, HeaderSize reasonable
                            {
                                DialogResult messageBoxRes = MessageBox.Show("Failed to open this file! UE5 Zen Loader assets cannot be loaded directly into UAssetGUI. You could try to instead open the corresponding .utoc container file in UAssetGUI. You could also execute retoc directly from the command line.\n\nWould you like to open the GitHub page for retoc?", "Uh oh!", MessageBoxButtons.YesNo);
                                switch (messageBoxRes)
                                {
                                    case DialogResult.Yes:
                                        UAGUtils.OpenURL("https://github.com/trumank/retoc");
                                        break;
                                    default:
                                        break;
                                }
                            }
                            else if (Path.GetExtension(filePath) == ".uasset" && nextFourBytes == 0 && ue4CookedHeaderSize > 40 && ue4CookedHeaderSize < 1e9) // zero FName, CookedHeaderSize reasonable
                            {
                                DialogResult messageBoxRes = MessageBox.Show("Failed to open this file! UE4 Zen Loader assets cannot be loaded directly into UAssetGUI. You could try to instead open the corresponding .utoc container file in UAssetGUI. You could also execute retoc directly from the command line.\n\nWould you like to open the GitHub page for retoc?", "Uh oh!", MessageBoxButtons.YesNo);
                                switch (messageBoxRes)
                                {
                                    case DialogResult.Yes:
                                        UAGUtils.OpenURL("https://github.com/trumank/retoc");
                                        break;
                                    default:
                                        break;
                                }
                            }
                            else
                            {
                                MessageBox.Show("Failed to open this file! File format not recognized", "Uh oh!");
                            }
                            return;
                        }

                        targetAsset = new UAsset(ParsingVersion);
                        targetAsset.FilePath = filePath;
                        targetAsset.Mappings = ParsingMappings;
                        targetAsset.CustomSerializationFlags = (CustomSerializationFlags)UAGConfig.Data.CustomSerializationFlags;
                        if (MapStructTypeOverrideForm.MapStructTypeOverride != null) targetAsset.MapStructTypeOverride = MapStructTypeOverrideForm.MapStructTypeOverride;

                        var strmRaw = targetAsset.PathToStream(filePath);

                        // check: are we being loaded from a container? if so, pre-load the asset to grab any dependencies before loading properly
                        if (parentContainerForm != null && targetAsset != null)
                        {
                            // repeat pre-load up to 3 times, or until no more assets are failed to access
                            for (int preloadIter = 0; preloadIter < 3; preloadIter++)
                            {
                                if (targetAsset.OtherAssetsFailedToAccess != null) targetAsset.OtherAssetsFailedToAccess.Clear();
                                targetAsset.CustomSerializationFlags |= CustomSerializationFlags.SkipLoadingExports; // skip loading exports for pre-load (significant speed-up)
                                targetAsset.Read(new AssetBinaryReader(strmRaw, targetAsset));

                                if (targetAsset.OtherAssetsFailedToAccess == null || targetAsset.OtherAssetsFailedToAccess.Count == 0) break;
                                foreach (FName otherAsset in targetAsset.OtherAssetsFailedToAccess)
                                {
                                    if (otherAsset == null) continue;
                                    DirectoryTreeItem targetItem = parentContainerForm.GetFromPackageName(parentContainerForm.loadTreeView, otherAsset.ToString());
                                    targetItem?.SaveFileToTemp(parentContainerForm.InteropType);
                                }
                            }

                            // reset everything for the real load
                            targetAsset = new UAsset(ParsingVersion);
                            targetAsset.FilePath = filePath;
                            targetAsset.Mappings = ParsingMappings;
                            targetAsset.CustomSerializationFlags = (CustomSerializationFlags)UAGConfig.Data.CustomSerializationFlags;
                            if (MapStructTypeOverrideForm.MapStructTypeOverride != null) targetAsset.MapStructTypeOverride = MapStructTypeOverrideForm.MapStructTypeOverride;

                            strmRaw = targetAsset.PathToStream(filePath);
                        }

#if DEBUGTRACING
                        var strm = new UAssetAPI.Trace.TraceStream(strmRaw, filePath);
                        UAssetAPI.Trace.LoggingAspect.Start(strm);
                        targetAsset.Read(new AssetBinaryReader(strm, targetAsset));
                        jsonTracingPath = UAssetAPI.Trace.LoggingAspect.Stop();
#else
                        targetAsset.Read(new AssetBinaryReader(strmRaw, targetAsset));
#endif
                        break;
                }

                currentSavingPath = savingPath;
                SetUnsavedChanges(false);

                tableEditor = new TableHandler(dataGridView1, targetAsset, treeView1, jsonView);
                tableEditor.ParentContainer = parentContainerForm;

                saveToolStripMenuItem.Enabled = !IsReadOnly();
                saveAsToolStripMenuItem.Enabled = true;
                findToolStripMenuItem.Enabled = true;
                //stageToolStripMenuItem.Enabled = true;

                tableEditor.FillOutTree(!UAGConfig.Data.EnableDynamicTree);
                tableEditor.Load();

                UAGPalette.RefreshTheme(this);

                bool hasDuplicates = false;
                HashSet<string> nameMapRefs = new HashSet<string>();
                foreach (FString x in tableEditor.asset.GetNameMapIndexList())
                {
                    if (nameMapRefs.Contains(x.Value))
                    {
                        hasDuplicates = true;
                        break;
                    }
                    nameMapRefs.Add(x.Value);
                }
                nameMapRefs = null;

                int failedCategoryCount = 0;
                unknownTypes = new HashSet<string>();
                rawStructTypes = new HashSet<string>();
                numRawStructs = 0;
                foreach (Export cat in tableEditor.asset.Exports)
                {
                    if (cat is RawExport) failedCategoryCount++;
                    if (cat is NormalExport usNormal)
                    {
                        foreach (PropertyData dat in usNormal.Data) GetUnknownProperties(dat);
                    }
                }

                bool failedToMaintainBinaryEquality = !string.IsNullOrEmpty(tableEditor.asset.FilePath) && !tableEditor.asset.FilePath.EndsWith(".json") && !tableEditor.asset.VerifyBinaryEquality();

#if DEBUGTRACING
                if (jsonTracingPath != null && (failedToMaintainBinaryEquality || failedCategoryCount > 0))
                {
                    // if ser-hex-viewer available (https://github.com/trumank/ser-hex), run that
                    try
                    {
                        Process.Start(new ProcessStartInfo("ser-hex-viewer", "\"" + jsonTracingPath + "\"") { UseShellExecute = false });
                    }
                    catch { }
                }
#endif

                if (didACE7Decrypt)
                {
                    MessageBox.Show("This file uses Ace Combat 7 encryption and was decrypted in-situ.", "Notice");
                }

                if (failedCategoryCount > 0)
                {
                    MessageBox.Show("Failed to parse " + failedCategoryCount + " export" + (failedCategoryCount == 1 ? "" : "s") + "!", "Notice");
                }

                if (hasDuplicates)
                {
                    MessageBox.Show("Encountered duplicate name map entries! Serialized FNames will coalesce to one of the entries in the map and binary equality may not be maintained.", "Notice");
                }

                if (unknownTypes.Count > 0)
                {
                    MessageBox.Show("Encountered " + unknownTypes.Count + " unknown property type" + (unknownTypes.Count == 1 ? "" : "s") + ":\n" + string.Join(", ", unknownTypes) + (failedToMaintainBinaryEquality ? "" : "\n\nThe asset will still parse normally."), "Notice");
                }

                if (rawStructTypes.Count > 0)
                {
                    MessageBox.Show("Encountered " + numRawStructs + " struct" + (numRawStructs == 1 ? "" : "s") + " that could not be parsed, and " + (numRawStructs == 1 ? "was" : "were") + " instead read as an array of bytes. " + (numRawStructs == 1 ? "It has the following type" : "They have the following types") + ":\n" + string.Join(", ", rawStructTypes) + (failedToMaintainBinaryEquality ? "" : "\n\nThe asset will still parse normally."), "Notice");
                }

                if (tableEditor.asset.HasUnversionedProperties && tableEditor.asset.Mappings == null)
                {
                    MessageBox.Show("Failed to parse unversioned properties! Exports cannot be parsed for this asset unless a valid set of mappings is provided. " + UsmapInstructionsNotice, "Notice");
                }

                if (tableEditor.asset.HasUnversionedProperties && failedCategoryCount > 0 && (tableEditor.asset.OtherAssetsFailedToAccess?.Count ?? 0) > 0)
                {
                    string formattedListOfFailedToAccessAssets = string.Join("\n", tableEditor.asset.OtherAssetsFailedToAccess);
                    MessageBox.Show("UAssetAPI attempted to access the following assets, but failed to do so. Some errors may potentially be resolved by giving it access to these assets. You can either include them in the same directory, or reconstruct the game's Content directory tree.\n\n" + formattedListOfFailedToAccessAssets, "Notice");
                }

                if (failedToMaintainBinaryEquality)
                {
                    MessageBox.Show("Failed to maintain binary equality! UAssetAPI may not be able to parse this particular asset correctly, and you may not be able to load this file in-game if modified.", "Uh oh!");
                }

                if (!tableEditor.asset.IsUnversioned)
                {
                    EngineVersion calculatedVer = tableEditor.asset.GetEngineVersion();
                    if (calculatedVer != EngineVersion.UNKNOWN) SetParsingVersion(calculatedVer);
                }
                if (desiredSetUnsavedChanges) SetUnsavedChanges(desiredSetUnsavedChanges);
            }
            catch (Exception ex)
            {
                string formattedListOfFailedToAccessAssets = null;
                if (tableEditor?.asset != null && tableEditor.asset.HasUnversionedProperties && (tableEditor.asset.OtherAssetsFailedToAccess?.Count ?? 0) > 0)
                {
                    formattedListOfFailedToAccessAssets = string.Join("\n", tableEditor.asset.OtherAssetsFailedToAccess);
                }

                //MessageBox.Show(ex.StackTrace);
                currentSavingPath = "";
                SetUnsavedChanges(false);
                tableEditor = null;
                saveToolStripMenuItem.Enabled = false;
                saveAsToolStripMenuItem.Enabled = false;
                findToolStripMenuItem.Enabled = false;
                //stageToolStripMenuItem.Enabled = false;

                treeView1.Nodes.Clear();
                dataGridView1.Columns.Clear();
                dataGridView1.Rows.Clear();
                UAGPalette.RefreshTheme(this);

                switch (ex)
                {
                    case IOException _:
                        MessageBox.Show("Failed to open this file! Please make sure the specified engine version is correct.", "Uh oh!");
                        break;
                    case FormatException formatEx:
                        MessageBox.Show("Failed to parse this file!\n" + formatEx.GetType() + ": " + formatEx.Message, "Uh oh!");
                        break;
                    case UnknownEngineVersionException _:
                        MessageBox.Show("Please specify an engine version using the dropdown at the upper-right corner of this window before opening an unversioned asset.", "Uh oh!");
                        break;
                    default:
                        MessageBox.Show("Encountered an unknown error when trying to open this file!\n" + ex.GetType() + ": " + ex.Message, "Uh oh!");
                        break;
                }

                if (formattedListOfFailedToAccessAssets != null)
                {
                    MessageBox.Show("UAssetAPI attempted to access the following assets, but failed to do so. It's possible that this error could be resolved by giving it access to these assets. You can either include them in the same directory, or reconstruct the game's Content directory tree.\n\n" + formattedListOfFailedToAccessAssets, "Notice");
                }
            }
            finally
            {
                LastLoadTimestamp = DateTime.UtcNow;
                UpdateRPC();

                treeView1.Select();
            }
        }

        public bool IsReadOnly()
        {
            int idx = currentSavingPath.Replace(Path.DirectorySeparatorChar, '/').LastIndexOf(ReadOnlyPathKeyword);
            return idx >= 0;
        }

        public bool existsUnsavedChanges = false;
        public static readonly string ReadOnlyPathKeyword = "UAG_read_only/";
        public void SetUnsavedChanges(bool flag)
        {
            existsUnsavedChanges = flag;
            if (string.IsNullOrEmpty(currentSavingPath))
            {
                this.Text = DisplayVersion;
            }
            else
            {
                string formattedCurrentSavingPath = currentSavingPath;
                int idx = currentSavingPath.Replace(Path.DirectorySeparatorChar, '/').LastIndexOf(ReadOnlyPathKeyword);
                if (idx >= 0)
                {
                    formattedCurrentSavingPath = formattedCurrentSavingPath.Substring(idx + ReadOnlyPathKeyword.Length);
                }

                if (existsUnsavedChanges)
                {
                    this.Text = DisplayVersion + " - *" + formattedCurrentSavingPath;
                }
                else
                {
                    this.Text = DisplayVersion + " - " + formattedCurrentSavingPath;
                }
            }
        }

        private void openToolStripMenuItem_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog openFileDialog = new OpenFileDialog())
            {
                openFileDialog.Filter = "Unreal Assets (*.uasset, *.umap, *.json)|*.uasset;*.umap;*.json|All files (*.*)|*.*";
                openFileDialog.FilterIndex = 1;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    LoadFileAt(openFileDialog.FileName);
                }
            }
        }

        internal string currentSavingPath = "";

        private bool ForceSave(string path)
        {
            if (tableEditor != null && !string.IsNullOrEmpty(currentSavingPath))
            {
                if (UAGConfig.Data.EnableBak && File.Exists(path)) File.Copy(path, path + ".bak", true);
                if (UAGConfig.Data.EnableBak && File.Exists(Path.ChangeExtension(path, "uexp"))) File.Copy(Path.ChangeExtension(path, "uexp"), Path.ChangeExtension(path, "uexp") + ".bak", true);

                tableEditor.Save(true);

                bool isLooping = true;
                while (isLooping)
                {
                    isLooping = false;
                    try
                    {
                        try
                        {
                            if (UAGConfig.Data.EnableBakJson && File.Exists(path))
                            {
                                var targetAsset = new UAsset(ParsingVersion);
                                targetAsset.FilePath = tableEditor.asset.FilePath;
                                targetAsset.Mappings = tableEditor.asset.Mappings;
                                targetAsset.CustomSerializationFlags = tableEditor.asset.CustomSerializationFlags;
                                if (MapStructTypeOverrideForm.MapStructTypeOverride != null) targetAsset.MapStructTypeOverride = MapStructTypeOverrideForm.MapStructTypeOverride;

                                var strmRaw = targetAsset.PathToStream(targetAsset.FilePath);
                                targetAsset.Read(new AssetBinaryReader(strmRaw, targetAsset));

                                File.WriteAllText(path + ".bak.json", targetAsset.SerializeJson(Newtonsoft.Json.Formatting.Indented));
                            }
                        }
                        catch (Exception ex)
                        {
                            MessageBox.Show("Failed to save JSON backup! " + ex.Message, "Uh oh!");
                        }

                        tableEditor.asset.Write(path);
                        SetUnsavedChanges(false);
                        tableEditor.Load();

                        return true;
                    }
                    catch (NameMapOutOfRangeException ex)
                    {
                        try
                        {
                            tableEditor.asset.AddNameReference(ex.RequiredName);
                            isLooping = true;
                        }
                        catch (Exception ex2)
                        {
                            MessageBox.Show("Failed to save! " + ex2.Message, "Uh oh!");
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show("Failed to save! " + ex.Message, "Uh oh!");
                    }
                }
            }
            else
            {
                MessageBox.Show("Failed to save!", "Uh oh!");
            }
            return false;
        }

        private void saveAsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (tableEditor?.asset == null) return;

            using (SaveFileDialog dialog = new SaveFileDialog())
            {
                dialog.Filter = "Unreal Assets (*.uasset, *.umap)|*.uasset;*.umap|UAssetAPI JSON (*.json)|*.json|All files (*.*)|*.*";
                dialog.FilterIndex = 1;
                dialog.RestoreDirectory = true;

                DialogResult res = dialog.ShowDialog();
                if (res == DialogResult.OK)
                {
                    if (Path.GetExtension(dialog.FileName) == ".json")
                    {
                        // JSON export
                        string jsonSerializedAsset = tableEditor.asset.SerializeJson(Newtonsoft.Json.Formatting.Indented);
                        File.WriteAllText(dialog.FileName, jsonSerializedAsset);
                    }
                    else
                    {
                        currentSavingPath = dialog.FileName;
                        ForceSave(currentSavingPath);
                    }
                }
                else if (res != DialogResult.Cancel)
                {
                    MessageBox.Show("Failed to save!", "Uh oh!");
                }
            }
        }

        private void saveToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ForceSave(currentSavingPath);
        }

        private void expandAllToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tableEditor?.ChangeAllExpansionStatus(true);
        }

        private void collapseAllToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tableEditor?.ChangeAllExpansionStatus(false);
        }

        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            if (treeView1?.SelectedNode != null && treeView1.SelectedNode is PointingTreeNode pointerNode && pointerNode.Type == PointingTreeNodeType.Kismet) return base.ProcessCmdKey(ref msg, keyData);

            switch (keyData)
            {
                case Keys.Control | Keys.C:
                    if (tableEditor == null || dataGridView1.IsCurrentCellInEditMode) break;
                    copyToolStripMenuItem.PerformClick();
                    return true;
                case Keys.Control | Keys.V:
                    if (dataGridView1.ReadOnly || !dataGridView1.AllowUserToAddRows) break;
                    if (tableEditor == null || dataGridView1.IsCurrentCellInEditMode) break;
                    pasteToolStripMenuItem.PerformClick();
                    return true;
                case Keys.Delete:
                    if (dataGridView1.ReadOnly || !dataGridView1.AllowUserToAddRows) break;
                    if (tableEditor == null || dataGridView1.IsCurrentCellInEditMode) break;
                    deleteToolStripMenuItem.PerformClick();
                    return true;
            }

            return base.ProcessCmdKey(ref msg, keyData);
        }

        private string CopyIndividual(int rowIndex)
        {
            object objectToCopy = null;

            switch (tableEditor.mode)
            {
                case TableHandlerMode.ExportData:
                    if (treeView1.SelectedNode is PointingTreeNode pointerNode)
                    {
                        if (pointerNode.Type == PointingTreeNodeType.ByteArray)
                        {
                            string parsedData = BitConverter.ToString(pointerNode.Pointer is RawExport ? ((RawExport)pointerNode.Pointer).Data : ((NormalExport)pointerNode.Pointer).Extras)?.Replace("-", " ");
                            return string.IsNullOrWhiteSpace(parsedData) ? "zero" : parsedData;
                        }
                        else if (pointerNode.Type == PointingTreeNodeType.KismetByteArray)
                        {
                            string parsedData = BitConverter.ToString(((StructExport)pointerNode.Pointer).ScriptBytecodeRaw)?.Replace("-", " ");
                            return string.IsNullOrWhiteSpace(parsedData) ? "zero" : parsedData;
                        }
                        else if (pointerNode.Pointer is StructPropertyData copyingDat1)
                        {
                            if (treeView1.Focused) objectToCopy = copyingDat1;
                            if (rowIndex >= 0 && !treeView1.Focused && copyingDat1.Value.Count > rowIndex) objectToCopy = copyingDat1.Value[rowIndex];
                        }
                        else if (pointerNode.Pointer is ArrayPropertyData copyingDat2)
                        {
                            if (treeView1.Focused) objectToCopy = copyingDat2;
                            if (rowIndex >= 0 && !treeView1.Focused && copyingDat2.Value.Length > rowIndex) objectToCopy = copyingDat2.Value[rowIndex];
                        }
                        else if (pointerNode.Pointer is PointingDictionaryEntry copyingDat3)
                        {
                            // don't allow copying the dictionary entry itself
                            if (rowIndex >= 0) objectToCopy = treeView1.ContainsFocus ? null : (rowIndex == 0 ? copyingDat3.Entry.Key : copyingDat3.Entry.Value);
                        }
                        else if (pointerNode.Pointer is PropertyData[] copyingDat4)
                        {
                            if (treeView1.Focused) objectToCopy = copyingDat4;
                            if (rowIndex >= 0 && !treeView1.Focused && copyingDat4.Length > rowIndex) objectToCopy = copyingDat4[rowIndex];
                        }
                        else if (pointerNode.Pointer is Export || (treeView1.Focused && pointerNode.WillCopyWholeExport))
                        {
                            switch (pointerNode.Type)
                            {
                                case PointingTreeNodeType.Normal:
                                    var copyingDat5 = tableEditor.asset.Exports[pointerNode.ExportNum];
                                    if (treeView1.Focused)
                                    {
                                        objectToCopy = copyingDat5;
                                    }
                                    else if (copyingDat5 is NormalExport copyingDat6)
                                    {
                                        if (rowIndex >= 0 && !treeView1.Focused && copyingDat6.Data.Count > rowIndex) objectToCopy = copyingDat6.Data[rowIndex];
                                    }
                                    break;
                            }
                        }
                    }
                    break;
            }

            if (objectToCopy != null)
            {
                return tableEditor.asset.SerializeJsonObject(objectToCopy, Newtonsoft.Json.Formatting.None);
            }

            // fallback to copying raw row data
            if (rowIndex >= 0)
            {
                var currentRow = dataGridView1.Rows[rowIndex];
                string[] newClipboardText = new string[currentRow.Cells.Count];
                for (int i = 0; i < currentRow.Cells.Count; i++)
                {
                    newClipboardText[i] = currentRow.Cells[i].Value?.ToString() ?? string.Empty;
                }
                return JsonConvert.SerializeObject(newClipboardText, Formatting.None);
            }

            return null;
        }

        private void copyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (tableEditor == null) return;

            string fullData = null;
            if (dataGridView1.SelectedRows.Count > 0)
            {
                Dictionary<int, string> dataByRowIndex = new Dictionary<int, string>();
                foreach (DataGridViewRow row in dataGridView1.SelectedRows)
                {
                    dataByRowIndex[row.Index] = CopyIndividual(row.Index).Replace("\r", "").Replace("\n", "");
                }
                fullData = string.Join('\n', dataByRowIndex.OrderBy(entry => entry.Key).Select(entry => entry.Value)); // sort values by key ascending
            }
            else
            {
                fullData = CopyIndividual(-1);
            }

            if (fullData != null) Clipboard.SetText(fullData);
        }

        private TreeNode SearchForTreeNode(TreeView node, int expNum)
        {
            foreach (TreeNode entry in node.Nodes)
            {
                TreeNode res = SearchForTreeNode(entry, expNum);
                if (res != null) return res;
            }
            return null;
        }

        private TreeNode SearchForTreeNode(TreeNode node, int expNum)
        {
            foreach (TreeNode entry in node.Nodes)
            {
                if (node is PointingTreeNode pointerNode2 && pointerNode2.ExportNum == expNum) return pointerNode2;

                TreeNode res = SearchForTreeNode(entry, expNum);
                if (res != null) return res;
            }
            return null;
        }

        private void PasteIndividual(int rowIndex, string dat)
        {
            PropertyData deserializedClipboard = null;
            try
            {
                deserializedClipboard = tableEditor.asset.DeserializeJsonObject<PropertyData>(dat);
            }
            catch (Exception)
            {
                // the thing we're trying to paste probably isn't a PropertyData
            }

            switch (tableEditor.mode)
            {
                case TableHandlerMode.ExportData:
                    if (treeView1.SelectedNode is PointingTreeNode pointerNode)
                    {
                        if (pointerNode.Type == PointingTreeNodeType.ByteArray)
                        {
                            try
                            {
                                if (pointerNode.Pointer is RawExport)
                                {
                                    ((RawExport)pointerNode.Pointer).Data = dat == "zero" ? new byte[0] : UAPUtils.ConvertHexStringToByteArray(dat);
                                }
                                else if (pointerNode.Pointer is NormalExport)
                                {
                                    ((NormalExport)pointerNode.Pointer).Extras = dat == "zero" ? new byte[0] : UAPUtils.ConvertHexStringToByteArray(dat);
                                }
                            }
                            catch (Exception)
                            {
                                // the thing we're trying to paste probably isn't a byte array
                            }

                            SetUnsavedChanges(true);
                            if (tableEditor != null)
                            {
                                tableEditor.Load();
                            }
                            return;
                        }
                        else if (pointerNode.Type == PointingTreeNodeType.KismetByteArray)
                        {
                            try
                            {
                                ((StructExport)pointerNode.Pointer).ScriptBytecodeRaw = dat == "zero" ? new byte[0] : UAPUtils.ConvertHexStringToByteArray(dat);
                            }
                            catch (Exception)
                            {
                                // the thing we're trying to paste probably isn't a byte array
                            }

                            SetUnsavedChanges(true);
                            if (tableEditor != null)
                            {
                                tableEditor.Load();
                            }
                            return;
                        }
                        else if (pointerNode.Pointer is StructPropertyData copyingDat1 && deserializedClipboard != null)
                        {
                            if (rowIndex < 0) return;
                            copyingDat1.Value.Insert(rowIndex, deserializedClipboard);

                            SetUnsavedChanges(true);
                            if (tableEditor != null)
                            {
                                tableEditor.Load();
                            }
                            return;
                        }
                        else if (pointerNode.Pointer is ArrayPropertyData copyingDat2 && deserializedClipboard != null)
                        {
                            if (rowIndex < 0) return;
                            List<PropertyData> origArr = copyingDat2.Value.ToList();
                            origArr.Insert(rowIndex, deserializedClipboard);
                            copyingDat2.Value = origArr.ToArray();

                            SetUnsavedChanges(true);
                            if (tableEditor != null)
                            {
                                tableEditor.Load();
                            }
                            return;
                        }
                        else if (pointerNode.Pointer is NormalExport copyingDat3 && deserializedClipboard != null)
                        {
                            if (rowIndex < 0) return;
                            copyingDat3.Data.Insert(rowIndex, deserializedClipboard);

                            SetUnsavedChanges(true);
                            if (tableEditor != null)
                            {
                                tableEditor.Load();
                            }
                            return;
                        }
                        else
                        {
                            // check if we're pasting a whole export
                            Export deserExport = null;
                            try
                            {
                                deserExport = tableEditor.asset.DeserializeJsonObject<Export>(dat);
                            }
                            catch (Exception)
                            {
                                // the thing we're trying to paste probably isn't an Export
                            }

                            if (deserExport != null)
                            {
                                // add a new export after the current one
                                tableEditor.asset.Exports.Insert(pointerNode.ExportNum + 1, deserExport);

                                if (tableEditor != null)
                                {
                                    SetUnsavedChanges(true);
                                    tableEditor.Save(true);
                                    tableEditor.FillOutTree(!UAGConfig.Data.EnableDynamicTree);

                                    TreeNode newNode = SearchForTreeNode(treeView1, pointerNode.ExportNum + 1);
                                    newNode.EnsureVisible();
                                    newNode.ExpandAll();
                                }
                            }
                        }
                    }
                    break;
            }

            // fallback to pasting raw row data
            if (rowIndex >= 0)
            {
                try
                {
                    string[] rawData = JsonConvert.DeserializeObject<string[]>(dat);
                    dataGridView1.Rows.Insert(rowIndex, rawData);
                    SetUnsavedChanges(true);
                    return;
                }
                catch (Exception)
                {
                    // the thing we're trying to paste probably isn't a string array
                }
            }
        }

        private void pasteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (tableEditor == null) return;
            int rowIndex = dataGridView1.SelectedCells.Count > 0 ? dataGridView1.SelectedCells[0].RowIndex : -1;

            string[] allDats = Clipboard.GetText().Split('\n');
            foreach (string dat in allDats)
            {
                PasteIndividual(rowIndex, dat);
                rowIndex += 1; // paste after new row
            }
        }

        private void deleteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (tableEditor == null) return;
            int rowIndex = dataGridView1.SelectedCells.Count > 0 ? dataGridView1.SelectedCells[0].RowIndex : -1;

            switch (tableEditor.mode)
            {
                case TableHandlerMode.ExportData:
                    if (treeView1.SelectedNode is PointingTreeNode pointerNode)
                    {
                        if (pointerNode.Type == PointingTreeNodeType.ByteArray)
                        {
                            if (pointerNode.Pointer is RawExport)
                            {
                                ((RawExport)pointerNode.Pointer).Data = new byte[0];
                            }
                            else if (pointerNode.Pointer is NormalExport)
                            {
                                ((NormalExport)pointerNode.Pointer).Extras = new byte[0];
                            }

                            return;
                        }
                        else if (pointerNode.Type == PointingTreeNodeType.KismetByteArray)
                        {
                            ((StructExport)pointerNode.Pointer).ScriptBytecodeRaw = new byte[0];

                            return;
                        }
                        else if (pointerNode.Pointer is StructPropertyData copyingDat1)
                        {
                            if (rowIndex < 0 || rowIndex >= copyingDat1.Value.Count) return;
                            copyingDat1.Value.RemoveAt(rowIndex);

                            SetUnsavedChanges(true);
                            if (tableEditor != null)
                            {
                                tableEditor.Load();
                            }
                            return;
                        }
                        else if (pointerNode.Pointer is ArrayPropertyData copyingDat2)
                        {
                            if (rowIndex < 0 || rowIndex >= copyingDat2.Value.Length) return;
                            List<PropertyData> origArr = copyingDat2.Value.ToList();
                            origArr.RemoveAt(rowIndex);
                            copyingDat2.Value = origArr.ToArray();

                            SetUnsavedChanges(true);
                            if (tableEditor != null)
                            {
                                tableEditor.Load();
                            }
                            return;
                        }
                        else if (pointerNode.Pointer is Export || (treeView1.Focused && pointerNode.WillCopyWholeExport))
                        {
                            switch (pointerNode.Type)
                            {
                                case PointingTreeNodeType.Normal:
                                    if (treeView1.Focused)
                                    {
                                        DialogResult res = MessageBox.Show("Are you sure you want to delete this export?\nTHIS OPERATION CANNOT BE UNDONE!", DisplayVersion, MessageBoxButtons.OKCancel);
                                        if (res != DialogResult.OK) break;

                                        tableEditor.asset.Exports.RemoveAt(pointerNode.ExportNum);

                                        SetUnsavedChanges(true);
                                        tableEditor.Save(true);
                                        tableEditor.FillOutTree(!UAGConfig.Data.EnableDynamicTree);

                                        TreeNode newNode = SearchForTreeNode(treeView1, pointerNode.ExportNum);
                                        if (newNode != null)
                                        {
                                            newNode.EnsureVisible();
                                            newNode.Expand();
                                        }
                                    }
                                    else if (pointerNode.Pointer is NormalExport copyingDat3)
                                    {
                                        if (rowIndex < 0 || rowIndex >= copyingDat3.Data.Count) return;
                                        copyingDat3.Data.RemoveAt(rowIndex);

                                        SetUnsavedChanges(true);
                                        if (tableEditor != null)
                                        {
                                            tableEditor.Load();
                                        }
                                    }

                                    return;
                            }

                            return;
                        }

                    }
                    break;
            }

            // fallback to just deleting the whole row and refreshing
            if (rowIndex >= 0)
            {
                foreach (DataGridViewCell cell in dataGridView1.Rows[rowIndex].Cells) cell.Value = null;
                SetUnsavedChanges(true);
                if (tableEditor != null)
                {
                    tableEditor.Save(true);
                }
            }
        }

        private void dataGridEditCell(object sender, EventArgs e)
        {
            if (tableEditor != null && tableEditor.readyToSave)
            {
                tableEditor.Save(false);
            }
        }

        private void dataGridClickCell(object sender, DataGridViewCellEventArgs e)
        {
            if (dataGridView1.CurrentCell != null && dataGridView1.CurrentCell.Style != null && dataGridView1.CurrentCell.Style.Font != null && dataGridView1.CurrentCell.Style.Font.Underline == true)
            {
                switch (dataGridView1.CurrentCell.Tag)
                {
                    case "CategoryJump":
                        DataGridViewCell previousCell = dataGridView1.Rows[dataGridView1.CurrentCell.RowIndex].Cells[dataGridView1.CurrentCell.ColumnIndex - 1];
                        if (previousCell == null || previousCell.Value == null) return;

                        int jumpingTo = -1;
                        if (previousCell.Value is string) int.TryParse((string)previousCell.Value, out jumpingTo);
                        if (previousCell.Value is int) jumpingTo = (int)previousCell.Value;
                        if (jumpingTo < 0) return;

                        TreeNode topSelectingNode = treeView1.Nodes[treeView1.Nodes.Count - 1];
                        if (topSelectingNode.Nodes.Count > (jumpingTo - 1))
                        {
                            topSelectingNode = topSelectingNode.Nodes[jumpingTo - 1];
                            if (topSelectingNode.Nodes.Count > 0)
                            {
                                topSelectingNode = topSelectingNode.Nodes[0];
                            }
                        }
                        treeView1.SelectedNode = topSelectingNode;
                        break;
                    case "ChildJump":
                        int jumpingIndex = dataGridView1.CurrentCell.RowIndex;
                        if (jumpingIndex < 0 || jumpingIndex >= treeView1.SelectedNode.Nodes.Count)
                        {
                            MessageBox.Show("Please select View -> Recalculate Nodes before attempting to jump to this node.", "Notice");
                        }
                        else
                        {
                            treeView1.SelectedNode = treeView1.SelectedNode.Nodes[jumpingIndex];
                        }
                        break;
                }
            }
        }

        public void UpdateModeFromSelectedNode(TreeNode e)
        {
            if (e == null) return;

            string selectedNodeText = e.Text;
            string parentSelectedNodeText = e.Parent?.Text;
            if (tableEditor != null)
            {
                tableEditor.mode = TableHandlerMode.ExportData;
                switch (selectedNodeText)
                {
                    case "General Information":
                        tableEditor.mode = TableHandlerMode.GeneralInformation;
                        break;
                    case "Name Map":
                        tableEditor.mode = TableHandlerMode.NameMap;
                        break;
                    case "Soft Object Paths":
                        tableEditor.mode = TableHandlerMode.SoftObjectPathList;
                        break;
                    case "Import Data":
                        tableEditor.mode = TableHandlerMode.Imports;
                        break;
                    case "Export Information":
                        tableEditor.mode = TableHandlerMode.ExportInformation;
                        break;
                    case "Depends Map":
                        tableEditor.mode = TableHandlerMode.DependsMap;
                        break;
                    case "Soft Package References":
                        tableEditor.mode = TableHandlerMode.SoftPackageReferences;
                        break;
                    case "World Tile Info":
                        tableEditor.mode = TableHandlerMode.WorldTileInfo;
                        break;
                    case "Data Resources":
                        tableEditor.mode = TableHandlerMode.DataResources;
                        break;
                    case "Custom Version Container":
                        tableEditor.mode = TableHandlerMode.CustomVersionContainer;
                        break;
                }

                if (parentSelectedNodeText == "World Tile Info") tableEditor.mode = TableHandlerMode.WorldTileInfo;

                tableEditor.Load();
            }
        }

        private void treeView1_BeforeSelect(object sender, TreeViewCancelEventArgs e)
        {
            if (tableEditor != null && tableEditor.dirtySinceLastLoad)
            {
                // force refresh before tabbing out if we need to finalize changes before serialization (typically, when null entries exist to get rid of)
                // we don't just do this every time for performance reasons
                tableEditor.Save(true);
            }
        }

        private void treeView1_AfterSelect(object sender, TreeViewEventArgs e)
        {
            UpdateModeFromSelectedNode(e.Node);
            UAGUtils.InvokeUI(treeView1.Select);
        }

        private void dataGridView1_MouseWheel(object sender, MouseEventArgs e)
        {
            if (dataGridView1.SelectedCells.Count < 1) return;
            if (!UAGConfig.Data.ChangeValuesOnScroll) return;
            var selectedCell = dataGridView1.SelectedCells[0];
            if (selectedCell.ReadOnly) return;

            int deltaDir = e.Delta > 0 ? -1 : 1;

            bool didSomething = true;
            if (selectedCell.Value is int)
            {
                selectedCell.Value = (int)selectedCell.Value + deltaDir;
            }
            else if (selectedCell.Value is float)
            {
                selectedCell.Value = (float)selectedCell.Value + deltaDir;
            }
            else if (selectedCell.Value is bool)
            {
                selectedCell.Value = !(bool)selectedCell.Value;
            }
            else if (selectedCell.Value is string)
            {
                string rawVal = (string)selectedCell.Value;
                string rawValLower = rawVal.ToLowerInvariant();
                if (int.TryParse(rawVal, out int castedInt))
                {
                    selectedCell.Value = (castedInt + deltaDir).ToString();
                }
                else if (float.TryParse(rawVal, out float castedFloat))
                {
                    selectedCell.Value = (castedFloat + deltaDir).ToString();
                }
                else if (rawValLower == "true" || rawValLower == "false")
                {
                    selectedCell.Value = (rawValLower == "true" ? false : true).ToString();
                }
                else if (rawValLower == Encoding.UTF8.HeaderName || rawValLower == Encoding.Unicode.HeaderName || rawValLower == Encoding.ASCII.HeaderName)
                {
                    selectedCell.Value = (rawValLower == Encoding.ASCII.HeaderName || rawValLower == Encoding.UTF8.HeaderName) ? Encoding.Unicode.HeaderName : Encoding.UTF8.HeaderName;
                }
                else
                {
                    didSomething = false;
                }
            }
            else
            {
                didSomething = false;
            }

            if (didSomething)
            {
                dataGridView1.RefreshEdit();
                if (e is HandledMouseEventArgs ee)
                {
                    ee.Handled = true;
                }
            }
        }

        public void ForceResize()
        {
            if (byteView1 != null) byteView1.Refresh();
            if (jsonView != null) jsonView.Refresh();

            comboSpecifyVersion.Location = new Point(this.splitContainer1.Location.X + this.splitContainer1.Size.Width - this.comboSpecifyVersion.Width, this.menuStrip1.Size.Height - this.comboSpecifyVersion.Size.Height - 2);
            comboSpecifyMappings.Location = new Point(comboSpecifyVersion.Location.X - 5 - comboSpecifyMappings.Width, comboSpecifyVersion.Location.Y);

            // :skull_emoji:
            importBinaryData.Location = new Point(Math.Max(menuStrip1.Left + menuStrip1.GetPreferredSize(Size.Empty).Width, splitContainer1.Location.X + splitContainer1.SplitterDistance + splitContainer1.SplitterWidth), comboSpecifyVersion.Location.Y);
            exportBinaryData.Location = new Point(importBinaryData.Location.X + importBinaryData.Size.Width + 5, importBinaryData.Location.Y);
            setBinaryData.Location = new Point(exportBinaryData.Location.X + exportBinaryData.Size.Width + 5, importBinaryData.Location.Y);
            importBinaryData.Size = new Size(importBinaryData.Width, comboSpecifyVersion.Height); importBinaryData.Font = new Font(importBinaryData.Font.FontFamily, 6.75f, importBinaryData.Font.Style);
            exportBinaryData.Size = new Size(exportBinaryData.Width, comboSpecifyVersion.Height); exportBinaryData.Font = importBinaryData.Font;
            setBinaryData.Size = new Size(setBinaryData.Width, comboSpecifyVersion.Height); setBinaryData.Font = importBinaryData.Font;
        }

        private void frm_sizeChanged(object sender, EventArgs e)
        {
            ForceResize();
        }

        private void frm_closing(object sender, FormClosingEventArgs e)
        {
            if (UAGConfig.Data.RestoreSize)
            {
                UAGConfig.Data.StartupWidth = this.Size.Width;
                UAGConfig.Data.StartupHeight = this.Size.Height;
                UAGConfig.Save();
            }

            if (existsUnsavedChanges && !IsReadOnly())
            {
                DialogResult res = MessageBox.Show("Do you want to save your changes?", DisplayVersion, MessageBoxButtons.YesNoCancel);
                switch (res)
                {
                    case DialogResult.Yes:
                        if (!ForceSave(currentSavingPath)) e.Cancel = true;
                        break;
                    case DialogResult.Cancel:
                        e.Cancel = true;
                        break;
                }
            }

            if (!e.Cancel) DisposeDiscordRpc();

            // delete temp folder
            UAGUtils.DeleteDirectoryQuick(UAGConfig.TempFolder, true);
        }

        private void frm_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop)) e.Effect = DragDropEffects.Copy;
        }

        private void frm_DragDrop(object sender, DragEventArgs e)
        {
            string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
            if (files.Length > 0) LoadFileAt(files[0]);
        }

        private void refreshToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (tableEditor != null)
            {
                tableEditor.Save(true);
            }
        }

        private void refreshFullToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (tableEditor != null)
            {
                tableEditor.Save(true);
                tableEditor.FillOutTree(!UAGConfig.Data.EnableDynamicTree);
            }
        }

        private void issuesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.OpenURL("https://github.com/" + GitHubRepo + "/issues");
        }

        private void githubToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.OpenURL("https://github.com/" + GitHubRepo);
        }

        private void apiLinkToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.OpenURL("https://github.com/atenfyr/UAssetAPI");
        }

        public void SetParsingVersion(EngineVersion ver)
        {
            if (ver == ParsingVersion) return;

            for (int i = 0; i < versionOptionsValues.Length; i++)
            {
                if (versionOptionsValues[i] == ver)
                {
                    comboSpecifyVersion.SelectedIndex = i;
                    UpdateComboSpecifyVersion();
                    return;
                }
            }

            string verStringRepresentation = "(" + Convert.ToString((int)ver) + ")";
            comboSpecifyVersion.Items.Add(verStringRepresentation);
            Array.Resize(ref versionOptionsKeys, versionOptionsKeys.Length + 1);
            versionOptionsKeys[versionOptionsKeys.Length - 1] = verStringRepresentation;
            Array.Resize(ref versionOptionsValues, versionOptionsValues.Length + 1);
            versionOptionsValues[versionOptionsValues.Length - 1] = ver;
            comboSpecifyVersion.SelectedIndex = versionOptionsKeys.Length - 1;
            UpdateComboSpecifyVersion();
        }

        private void UpdateComboSpecifyVersion()
        {
            ParsingVersion = versionOptionsValues[comboSpecifyVersion.SelectedIndex];
            UAGConfig.Data.PreferredVersion = versionOptionsKeys[comboSpecifyVersion.SelectedIndex];
            UAGConfig.Save();
        }

        private void UpdateComboSpecifyMappings(bool alsoCheckVersion = true)
        {
            if (!UAGConfig.TryGetMappings(allMappingsKeys[comboSpecifyMappings.SelectedIndex], out ParsingMappings)) comboSpecifyMappings.SelectedIndex = 0;
            if (tableEditor?.asset != null) tableEditor.asset.Mappings = ParsingMappings;
            UAGConfig.Data.PreferredMappings = allMappingsKeys[comboSpecifyMappings.SelectedIndex];
            UAGConfig.Save();

            if (alsoCheckVersion) UpdateVersionFromMappings();
        }

        private void UpdateVersionFromMappings()
        {
            comboSpecifyVersion.Enabled = !_UpdateVersionFromMappings();
        }

        private bool _UpdateVersionFromMappings()
        {
            if (comboSpecifyVersion.Items.Count == 0) return false;

            // update version information if we have it
            if (ParsingMappings != null)
            {
                var detVer = UAsset.GetEngineVersion(ParsingMappings.FileVersionUE4, ParsingMappings.FileVersionUE5, ParsingMappings.CustomVersionContainer);
                if (detVer != EngineVersion.UNKNOWN)
                {
                    SetParsingVersion(detVer);
                    return true;
                }
            }
            return false;
        }

        private void comboSpecifyVersion_SelectedIndexChanged(object sender, EventArgs e)
        {
            UpdateComboSpecifyVersion();
        }

        private void comboSpecifyMappings_SelectedIndexChanged(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                UpdateComboSpecifyMappings();
            });
        }

        private void treeView1_KeyDown(object sender, KeyEventArgs e)
        {
            if (ModifierKeys == Keys.Shift)
            {
                TreeNode newNode = null;
                if (e.KeyCode.HasFlag(Keys.Up)) // SHIFT + UP = navigate to previous node @ same level
                {
                    newNode = treeView1.SelectedNode.PrevNode;
                    e.Handled = true;
                }
                else if (e.KeyCode.HasFlag(Keys.Down)) // SHIFT + DOWN = navigate to next node @ same level
                {
                    newNode = treeView1.SelectedNode.NextNode;
                    e.Handled = true;
                }

                if (newNode != null)
                {
                    treeView1.SelectedNode = newNode;
                    treeView1.SelectedNode.EnsureVisible();
                }
            }
        }

        private ContextMenuStrip _currentDataGridViewStrip;
        public ContextMenuStrip CurrentDataGridViewStrip
        {
            get
            {
                return _currentDataGridViewStrip;
            }
            set
            {
                _currentDataGridViewStrip = value;
                //UAGUtils.InvokeUI(UpdateDataGridViewWithExpectedStrip);
            }
        }

        public void ResetCurrentDataGridViewStrip()
        {
            _currentDataGridViewStrip = null;
            //UAGUtils.InvokeUI(UpdateDataGridViewWithExpectedStrip);
        }

        private void UpdateDataGridViewWithExpectedStrip()
        {
            foreach (DataGridViewRow row in dataGridView1.Rows) UAGUtils.UpdateContextMenuStripOfRow(row, CurrentDataGridViewStrip);
        }

        private void dataGridView1_EditingControlShowing(object sender, DataGridViewEditingControlShowingEventArgs e)
        {
            if (_currentDataGridViewStrip == null)
            {
                e.Control.ContextMenuStrip = null;
                return;
            }
            e.Control.ContextMenuStrip = UAGUtils.MergeContextMenus(e.Control.ContextMenuStrip, _currentDataGridViewStrip);
        }

        private void replaceAllReferencesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            DataGridViewTextBoxEditingControl dadControl = dataGridView1.EditingControl as DataGridViewTextBoxEditingControl;
            if (dadControl == null) return;

            int changingRow = dadControl.EditingControlRowIndex;
            FString replacingName = tableEditor?.asset?.GetNameReference(changingRow);
            if (replacingName == null) return;

            TextPrompt replacementPrompt = new TextPrompt()
            {
                DisplayText = "Enter a string to replace references of this name with"
            };

            replacementPrompt.StartPosition = FormStartPosition.CenterParent;

            if (replacementPrompt.ShowDialog(this) == DialogResult.OK)
            {
                FString newTxt = FString.FromString(replacementPrompt.OutputText);
                int numReplaced = tableEditor.ReplaceAllReferencesInNameMap(replacingName, newTxt);
                dataGridView1.Rows[changingRow].Cells[0].Value = newTxt.Value;
                dataGridView1.Rows[changingRow].Cells[1].Value = newTxt.Encoding.HeaderName;
                dataGridView1.RefreshEdit();
                MessageBox.Show("Successfully replaced " + numReplaced + " reference" + (numReplaced == 1 ? "" : "s") + ".", this.Text);
            }
            replacementPrompt.Dispose();
        }

        private void mapStructTypeOverridesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var mstoForm = new MapStructTypeOverrideForm();
            mstoForm.StartPosition = FormStartPosition.CenterParent;
            mstoForm.ShowDialog();
            mstoForm.Dispose();
        }

        private void comboSpecifyVersion_DrawItem(object sender, DrawItemEventArgs e)
        {
            var combo = sender as ComboBox;
            if (e.Index < 0 || e.Index >= combo.Items.Count) return;

            Color fontColor = UAGPalette.ForeColor;
            if ((e.State & DrawItemState.Selected) == DrawItemState.Selected)
            {
                e.Graphics.FillRectangle(new SolidBrush(UAGPalette.HighlightBackColor), e.Bounds);
                fontColor = UAGPalette.BackColor;
            }
            else
            {
                e.Graphics.FillRectangle(new SolidBrush(UAGPalette.ButtonBackColor), e.Bounds);
            }

            e.Graphics.DrawString(combo.Items[e.Index].ToString(), e.Font, new SolidBrush(fontColor), new Point(e.Bounds.X, e.Bounds.Y));
        }

        private void settingsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var ajustesForm = new SettingsForm();
            ajustesForm.StartPosition = FormStartPosition.CenterParent;
            ajustesForm.ShowDialog(this);
            ajustesForm.Dispose();
        }

        private void importBinaryData_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog openFileDialog = new OpenFileDialog())
            {
                openFileDialog.Filter = "Binary data (*.dat)|*.dat|All files (*.*)|*.*";
                openFileDialog.FilterIndex = 1;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    if (treeView1.SelectedNode is PointingTreeNode pointerNode && (pointerNode.Type == PointingTreeNodeType.ByteArray || pointerNode.Type == PointingTreeNodeType.KismetByteArray))
                    {
                        byte[] rawData = File.ReadAllBytes(openFileDialog.FileName);
                        if (pointerNode.Type == PointingTreeNodeType.KismetByteArray)
                        {
                            ((StructExport)pointerNode.Pointer).ScriptBytecodeRaw = rawData;
                        }
                        else if (pointerNode.Pointer is NormalExport usCategory)
                        {
                            usCategory.Extras = rawData;
                        }
                        else if (pointerNode.Pointer is RawExport usRawCategory)
                        {
                            usRawCategory.Data = rawData;
                        }

                        SetUnsavedChanges(true);
                        if (tableEditor != null)
                        {
                            tableEditor.Save(true);
                        }
                    }
                }
            }
        }

        private void exportBinaryData_Click(object sender, EventArgs e)
        {
            using (SaveFileDialog dialog = new SaveFileDialog())
            {
                dialog.Filter = "Binary data (*.dat)|*.dat|All files (*.*)|*.*";
                dialog.FilterIndex = 1;
                dialog.RestoreDirectory = true;

                DialogResult res = dialog.ShowDialog();
                if (res == DialogResult.OK)
                {
                    if (treeView1.SelectedNode is PointingTreeNode pointerNode && (pointerNode.Type == PointingTreeNodeType.ByteArray || pointerNode.Type == PointingTreeNodeType.KismetByteArray))
                    {
                        byte[] rawData = new byte[0];
                        if (pointerNode.Type == PointingTreeNodeType.KismetByteArray)
                        {
                            rawData = ((StructExport)pointerNode.Pointer).ScriptBytecodeRaw;
                        }
                        else if (pointerNode.Pointer is NormalExport usCategory)
                        {
                            rawData = usCategory.Extras;
                        }
                        else if (pointerNode.Pointer is RawExport usRawCategory)
                        {
                            rawData = usRawCategory.Data;
                        }

                        File.WriteAllBytes(dialog.FileName, rawData);
                    }
                }
            }
        }

        private void setBinaryData_Click(object sender, EventArgs e)
        {
            TextPrompt replacementPrompt = new TextPrompt()
            {
                DisplayText = "How many null bytes?"
            };

            replacementPrompt.StartPosition = FormStartPosition.CenterParent;

            if (replacementPrompt.ShowDialog(this) == DialogResult.OK)
            {
                if (int.TryParse(replacementPrompt.OutputText, out int numBytes) && treeView1.SelectedNode is PointingTreeNode pointerNode && (pointerNode.Type == PointingTreeNodeType.ByteArray || pointerNode.Type == PointingTreeNodeType.KismetByteArray))
                {
                    if (pointerNode.Type == PointingTreeNodeType.KismetByteArray)
                    {
                        ((StructExport)pointerNode.Pointer).ScriptBytecodeRaw = new byte[numBytes];
                    }
                    else if (pointerNode.Pointer is NormalExport usCategory)
                    {
                        usCategory.Extras = new byte[numBytes];
                    }
                    else if (pointerNode.Pointer is RawExport usRawCategory)
                    {
                        usRawCategory.Data = new byte[numBytes];
                    }

                    SetUnsavedChanges(true);
                    if (tableEditor != null)
                    {
                        tableEditor.Save(true);
                    }
                }
            }

            replacementPrompt.Dispose();
        }

        private void findToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var findForm = new FindForm();
            findForm.StartPosition = FormStartPosition.CenterParent;
            findForm.Owner = this;
            findForm.Show();
        }

        private int lastRowNum = -1;
        private void dataGridView1_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
        {
            if (UAGConfig.Data.DoubleClickToEdit) dataGridView1.BeginEdit(true);
        }

        private void dataGridView1_CellEnter(object sender, DataGridViewCellEventArgs e)
        {
            if (!UAGConfig.Data.DoubleClickToEdit || (dataGridView1?.SelectedCells?.Count > 0 && dataGridView1.SelectedCells[0].RowIndex == lastRowNum)) dataGridView1.BeginEdit(true);
            lastRowNum = -1;
        }

        private void dataGridView1_CellEndEdit(object sender, DataGridViewCellEventArgs e)
        {
            lastRowNum = e.RowIndex;
        }

        private readonly HashSet<string> invalidBaseFolders = new HashSet<string>() { "AIModule", "ALAudio", "AVEncoder", "AVIWriter", "Advertising", "Analytics", "Android", "AnimGraphRuntime", "AnimationCore", "AppFramework", "Apple", "ApplicationCore", "AssetRegistry", "AudioAnalyzer", "AudioCaptureCore", "AudioCaptureImplementations", "AudioExtensions", "AudioMixer", "AudioMixerCore", "AudioPlatformConfiguration", "AugmentedReality", "AutomationMessages", "AutomationWorker", "BlueprintRuntime", "BuildSettings", "CEF3Utils", "CUDA/Source", "Cbor", "CinematicCamera", "ClientPilot", "ClothingSystemRuntimeCommon", "ClothingSystemRuntimeInterface", "ClothingSystemRuntimeNv", "CookedIterativeFile", "Core", "CoreUObject", "CrashReportCore", "CrunchCompression", "D3D12RHI", "Datasmith", "DeveloperSettings", "EmptyRHI", "Engine", "EngineMessages", "EngineSettings", "Experimental", "ExternalRPCRegistry", "EyeTracker", "Foliage", "FriendsAndChat", "GameMenuBuilder", "GameplayMediaEncoder", "GameplayTags", "GameplayTasks", "HardwareSurvey", "HeadMountedDisplay", "IESFile", "IOS", "IPC", "ImageCore", "ImageWrapper", "ImageWriteQueue", "InputCore", "InputDevice", "InstallBundleManager", "Json", "JsonUtilities", "Landscape", "Launch", "LevelSequence", "Linux/AudioMixerSDL", "LiveLinkInterface", "LiveLinkMessageBusFramework", "Lumin/LuminRuntimeSettings", "MRMesh", "Mac", "MaterialShaderQualitySettings", "Media", "MediaAssets", "MediaInfo", "MediaUtils", "MeshDescription", "MeshUtilitiesCommon", "Messaging", "MessagingCommon", "MessagingRpc", "MoviePlayer", "MovieScene", "MovieSceneCapture", "MovieSceneTracks", "NVidia/GeForceNOW", "NavigationSystem", "Navmesh", "Net", "NetworkFile", "NetworkFileSystem", "NetworkReplayStreaming", "Networking", "NonRealtimeAudioRenderer", "NullDrv", "NullInstallBundleManager", "Online", "OpenGLDrv", "Overlay", "PacketHandlers", "PakFile", "PerfCounters", "PhysXCooking", "PhysicsCore", "PlatformThirdPartyHelpers/PosixShim", "Portal", "PreLoadScreen", "Projects", "PropertyAccess", "PropertyPath", "RHI", "RSA", "RawMesh", "RenderCore", "Renderer", "RigVM", "RuntimeAssetCache", "SandboxFile", "Serialization", "SessionMessages", "SessionServices", "SignalProcessing", "Slate", "SlateCore", "SlateNullRenderer", "SlateRHIRenderer", "Sockets", "SoundFieldRendering", "StaticMeshDescription", "StreamingFile", "StreamingPauseRendering", "SynthBenchmark", "TimeManagement", "Toolbox", "TraceLog", "UE4Game", "UELibrary", "UMG", "Unix/UnixCommonStartup", "UnrealAudio", "VectorVM", "VirtualProduction/StageDataCore", "VulkanRHI", "WebBrowser", "WebBrowserTexture", "WidgetCarousel", "Windows", "XmlParser" };
        private readonly HashSet<string> invalidExtraFolders = new HashSet<string>() { "AkAudio", "ClothingSystemRuntime", "SQEXSEAD" };
        private readonly string PROJECT_NAME_PREFIX = "/Script/";
        private readonly string CONTENT_NAME_PREFIX = "/Game/";
        public string GetProjectName()
        {
            if (tableEditor?.asset == null) return null;
            if (UAGConfig.Data.PreferredMappings != "No mappings" && UAGConfig.Data.PreferredMappings != "Mappings") return UAGConfig.Data.PreferredMappings;

            // use PackageName if available
            string pName = tableEditor.asset.FolderName?.Value;
            if (pName != null && pName.StartsWith(CONTENT_NAME_PREFIX))
            {
                string[] pName_inside = pName.Substring(CONTENT_NAME_PREFIX.Length, pName.Length - CONTENT_NAME_PREFIX.Length).Split('/');
                if (pName_inside.Length > 0) return pName_inside[0];
            }

            // check for C++ module name (not great)
            List<string> validPossibleProjectNames = new List<string>();
            var allPossibleFNames = tableEditor.asset.GetNameMapIndexList();
            foreach (FString n in allPossibleFNames)
            {
                string pkg = n.ToString();
                if (!pkg.StartsWith(PROJECT_NAME_PREFIX)) continue;
                string pkg_inside = pkg.Substring(PROJECT_NAME_PREFIX.Length, pkg.Length - PROJECT_NAME_PREFIX.Length);
                if (invalidBaseFolders.Contains(pkg_inside)) continue;
                if (invalidExtraFolders.Contains(pkg_inside)) continue;
                validPossibleProjectNames.Add(pkg_inside);
            }

            if (validPossibleProjectNames.Count != 1) return "Unknown";
            return validPossibleProjectNames[0];
        }

        private RichPresence rp;
        public void UpdateRPC()
        {
            if (DiscordRPC == null || !DiscordRPC.IsInitialized || DiscordRPC.IsDisposed) return;
            if (!UAGConfig.Data.EnableDiscordRPC) return;

            UAGUtils.InvokeUI(() =>
            {
                if (dataGridView1 == null) return;

                string currPath = currentSavingPath;
                DateTime lastOpenedTime = LastLoadTimestamp;

                bool isEditingAsset = saveToolStripMenuItem?.Enabled ?? false;
                if (string.IsNullOrEmpty(currPath)) isEditingAsset = false;

                if (rp == null)
                {
                    rp = new RichPresence
                    {
                        Timestamps = new Timestamps(),
                        Assets = new Assets()
                        {
                            LargeImageKey = "main_logo"
                        }
                    };
                }

                string projName = GetProjectName();
                rp.Details = projName == null ? string.Empty : ("Project: " + projName + " (" + UAGConfig.Data.PreferredVersion + ")");
                rp.State = isEditingAsset ? ("File: " + Path.GetFileName(currPath)) : "Idling";
                rp.Timestamps.Start = lastOpenedTime;

                DiscordRPC.SetPresence(rp);
            });
        }

        private void treeView1_BeforeExpand(object sender, TreeViewCancelEventArgs e)
        {
            if (tableEditor?.asset == null) return;

            if (e.Node is PointingTreeNode ptn)
            {
                if (!ptn.ChildrenInitialized)
                {
                    tableEditor.FillOutSubnodes(ptn, false);
                }
            }
        }

        private void configDirToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.OpenDirectory(UAGConfig.ConfigFolder);
        }

        /*private void mappingsDirToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.OpenDirectory(UAGConfig.MappingsFolder);
        }*/

        private string DumpMappings(string searchName, bool recursive, Dictionary<string, string> customAnnotations = null)
        {
            string annotatedOutput = ParsingMappings.GetAllPropertiesAnnotated(searchName, tableEditor?.asset, customAnnotations, recursive);
            return UAGConfig.SaveCustomFile(searchName + ".txt", annotatedOutput, Path.Combine("ClassDumps", UAGConfig.Data.PreferredMappings));
        }

        private bool TryDumpParticular()
        {
            var selectedNode = treeView1.SelectedNode as PointingTreeNode;
            if (selectedNode == null) return false;

            FName searchName = null;
            Dictionary<string, string> customAnnotations = new Dictionary<string, string>();
            if (selectedNode?.Pointer != null && selectedNode.Pointer is Export exp)
            {
                searchName = exp.GetClassTypeForAncestry(null, out _);
                if (selectedNode.Pointer is NormalExport nExp)
                {
                    foreach (var entry in nExp.Data)
                    {
                        customAnnotations[entry.Name?.Value?.Value ?? FString.NullCase] = "!";
                    }
                }
                else if (selectedNode.Pointer is DataTableExport datExp && datExp.Table?.Data != null)
                {
                    foreach (var entry in datExp.Table.Data)
                    {
                        customAnnotations[entry.Name?.Value?.Value ?? FString.NullCase] = "!";
                    }
                }
            }
            else if (selectedNode?.Pointer != null && selectedNode.Pointer is StructPropertyData strucDat)
            {
                searchName = strucDat.StructType;
            }

            if (searchName?.Value?.Value == null) return false;

            UAGUtils.OpenURL(DumpMappings(searchName.Value.Value, true, customAnnotations));

            return true;
        }

        // if mappings are provided, give list of valid props
        private void listValidPropertiesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                if (ParsingMappings == null)
                {
                    MessageBox.Show("No mappings found. " + UsmapInstructionsNotice, Text);
                    return;
                }

                if (TryDumpParticular()) return;

                DialogResult res = MessageBox.Show("This operation will dump ALL classes in the mappings file to text. This may take a while. Proceed?", DisplayVersion, MessageBoxButtons.OKCancel);
                switch (res)
                {
                    case DialogResult.OK:
                        var timer = new Stopwatch();
                        string outputPath = null;
                        int numDumped = 0;
                        timer.Start();
                        foreach (var schema in ParsingMappings.Schemas)
                        {
                            outputPath = DumpMappings(schema.Key, false);
                            numDumped++;
                        }
                        timer.Stop();
                        if (outputPath != null) UAGUtils.OpenDirectory(Path.GetDirectoryName(outputPath));
                        MessageBox.Show(numDumped + " " + (numDumped == 1 ? "class" : "classes") + " successfully dumped in " + timer.Elapsed.TotalMilliseconds + " ms.", Name);
                        break;
                }
            });
        }

        /*private int ExtractIOStore(string inPath, string outPath)
        {
            var test = new IOStoreContainer(inPath);
            test.BeginRead();
            int numExtracted = test.Extract(outPath);
            test.EndRead();
            return numExtracted;
        }

        private void extractIOStoreToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string inPath = null;
            using (OpenFileDialog openFileDialog = new OpenFileDialog())
            {
                openFileDialog.Filter = "IO Store Container (*.utoc)|*.utoc|All files (*.*)|*.*";
                openFileDialog.FilterIndex = 1;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    inPath = openFileDialog.FileName;
                }
            }

            if (inPath == null) return;

            string outPath = null;
            FolderBrowserEx.FolderBrowserDialog outputFolderDialog = new FolderBrowserEx.FolderBrowserDialog();
            outputFolderDialog.Title = "Select a folder to extract to";

            if (outputFolderDialog.ShowDialog() == DialogResult.OK)
            {
                outPath = outputFolderDialog.SelectedFolder;
            }
            outputFolderDialog.Dispose();

            if (outPath == null) return;

            Stopwatch timer = new Stopwatch();
            timer.Start();
            int numExtracted = ExtractIOStore(inPath, outPath);
            timer.Stop();

            MessageBox.Show("Extracted " + numExtracted + " files in " + timer.ElapsedMilliseconds + " ms.", this.Text);
        }*/

        private string SelectMappings()
        {
            using (OpenFileDialog openFileDialog = new OpenFileDialog())
            {
                openFileDialog.Filter = "Unreal mappings file (*.usmap)|*.usmap|All files (*.*)|*.*";
                openFileDialog.FilterIndex = 1;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    return openFileDialog.FileName;
                }
            }

            return null;
        }

        private void patchusmapWithsavVersionInfoToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                string patchPath = SelectMappings();
                if (patchPath == null) return;

                string inPath = null;
                using (OpenFileDialog openFileDialog = new OpenFileDialog())
                {
                    openFileDialog.Filter = "Unreal save game (*.sav, *.savegame)|*.sav;*.savegame|All files (*.*)|*.*";
                    openFileDialog.FilterIndex = 1;
                    openFileDialog.RestoreDirectory = true;

                    if (openFileDialog.ShowDialog() == DialogResult.OK)
                    {
                        inPath = openFileDialog.FileName;
                    }
                }

                if (inPath == null) return;

                bool success = true;
                Stopwatch timer = new Stopwatch();
                timer.Start();
                try
                {
                    var thing = new SaveGame(inPath);
                    thing.PatchUsmap(patchPath);
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Failed to patch mappings! " + ex.GetType() + ": " + ex.Message, "Uh oh!");
                    success = false;
                }
                finally
                {
                    timer.Stop();
                    UpdateMappings();
                    if (success) MessageBox.Show("Operation completed in " + timer.ElapsedMilliseconds + " ms.", this.Text);
                }
            });
        }

        private void ImportMappingsFromPathInteractive(string importPath)
        {
            UAGUtils.InvokeUI(() =>
            {
                string newFileName = Path.GetFileNameWithoutExtension(importPath);

                // special case if just "Mappings.usmap"
                if (newFileName == "Mappings")
                {
                    TextPrompt replacementPrompt = new TextPrompt()
                    {
                        DisplayText = "What is the name of the game these mappings are for?"
                    };

                    replacementPrompt.StartPosition = FormStartPosition.CenterParent;

                    if (replacementPrompt.ShowDialog(this) == DialogResult.OK)
                    {
                        newFileName = string.Join("_", replacementPrompt.OutputText.Split(Path.GetInvalidFileNameChars(), StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
                    }

                    replacementPrompt.Dispose();
                }

                try
                {
                    File.Copy(importPath, Path.ChangeExtension(Path.Combine(UAGConfig.MappingsFolder, newFileName), ".usmap"), true);
                    if (UAGConfig.AllMappings.ContainsKey(newFileName)) UAGConfig.AllMappings.Remove(newFileName);
                    UpdateMappings(newFileName);
                }
                catch
                {
                    MessageBox.Show("Failed to import mappings!", "Uh oh!");
                }
            });
        }

        private void importMappingsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                string importPath = SelectMappings();
                if (importPath == null) return;
                ImportMappingsFromPathInteractive(importPath);
            });
        }

        private void openContainersToolStripMenuItem_Click(object sender, EventArgs e)
        {
            OpenFileContainerForm();
        }

        private void stageToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (tableEditor?.asset == null) return;

            ForceSave(currentSavingPath); // even if read only, let's just save over it anyways here; only purpose of the read only stuff is so the user doesn't get confused
            // UAGConfig.StageFile(files[0], CurrentContainerPath);
            // this.RefreshTreeView(this.saveTreeView);

            if (UAGConfig.DifferentStagingPerPak)
            {
                // pick first open form we can find to do it with, otherwise we can't do it
                foreach (var form in Application.OpenForms)
                {
                    if (form is FileContainerForm fcForm)
                    {
                        UAGConfig.StageFile(currentSavingPath, fcForm.CurrentContainerPath);
                        fcForm.RefreshTreeView(fcForm.saveTreeView);
                        return;
                    }
                }

                MessageBox.Show("Please open a .pak file first to stage assets.", "Notice");
            }
            else
            {
                // check if any file container form exists, if not, open one
                bool needToOpenFileContainerForm = true;
                foreach (var form in Application.OpenForms)
                {
                    if (form is FileContainerForm fcForm)
                    {
                        needToOpenFileContainerForm = false;
                        break;
                    }
                }

                if (needToOpenFileContainerForm) OpenFileContainerForm();

                // stage it and refresh all open file container forms
                UAGConfig.StageFile(currentSavingPath, null);
                foreach (var form in Application.OpenForms)
                {
                    if (form is FileContainerForm fcForm)
                    {
                        fcForm.RefreshTreeView(fcForm.saveTreeView);
                        fcForm.Activate();
                    }
                }
            }
        }

        // the following three methods were developed using the following example code as reference: https://github.com/andersstorhaug/SingleFileScripting/tree/main
        // that example was prepared by andersstorhaug, with portions of code derived from Roslyn (see NOTICE.md)

        internal static MetadataReference GetReference(Type type)
        {
            return GetReference(type.Assembly);
        }

        internal static MetadataReference GetReference(Assembly asm)
        {
            unsafe
            {
                return asm.TryGetRawMetadata(out var blob, out var length)
                    ? AssemblyMetadata.Create(ModuleMetadata.CreateFromMetadata((IntPtr)blob, length)).GetReference()
                    : throw new InvalidOperationException($"Could not get raw metadata for assembly {asm.ToString()}");
            }
        }

        private volatile int customAsmId = 0;
        internal Dictionary<string, string> lastCompiledScriptText = new Dictionary<string, string>(); // ID vs text when last compiled
        internal Dictionary<string, ScriptAssemblyLoadContext> compiledScriptsAsms = new Dictionary<string, ScriptAssemblyLoadContext>(); // ID vs asm
        internal Dictionary<string, Func<object[], Task>> compiledScripts = new Dictionary<string, Func<object[], Task>>(); // ID vs entryPointDelegate

        [MethodImpl(MethodImplOptions.NoInlining)]
        internal Task ExecuteScript(string scriptText, string scriptID)
        {
            if (scriptText == null) throw new ArgumentException("scriptText is null");
            if (scriptID == null) throw new ArgumentException("scriptID is null");
            if (!UAGConfig.Data.AllowUntrustedScripts) throw new ArgumentException("AllowUntrustedScripts is not enabled");

            Func<object[], Task> entryPointDelegate = null;
            if (!compiledScripts.TryGetValue(scriptID, out entryPointDelegate) || entryPointDelegate == null || !lastCompiledScriptText.ContainsKey(scriptID) || lastCompiledScriptText[scriptID] != scriptText)
            {
                if (compiledScriptsAsms.ContainsKey(scriptID)) compiledScriptsAsms[scriptID]?.Unload();
                compiledScriptsAsms[scriptID] = null;
                lastCompiledScriptText[scriptID] = null;
                compiledScripts[scriptID] = null;

                ScriptAssemblyLoadContext assemblyLoadContext = new ScriptAssemblyLoadContext();

                List<MetadataReference> references = [
                    GetReference(typeof(object)),
                    GetReference(typeof(System.Windows.Forms.Form)),
                    GetReference(typeof(UAssetAPI.UAsset)),
                    GetReference(typeof(UAssetGUI.Form1))
                ];

                foreach (AssemblyName asmName in typeof(UAssetGUI.Form1).Assembly.GetReferencedAssemblies())
                {
                    references.Add(GetReference(Assembly.Load(asmName)));
                }

                // add imports
                string[] imports = ["System", "System.Collections.Generic", "System.Linq", "System.Windows.Forms", "UAssetAPI", "UAssetAPI.ExportTypes", "UAssetAPI.PropertyTypes.Objects", "UAssetAPI.PropertyTypes.Structs", "UAssetAPI.UnrealTypes", "UAssetAPI.FieldTypes", "UAssetAPI.Unversioned", "UAssetAPI.JSON", "UAssetAPI.Kismet", "UAssetAPI.CustomVersions", "UAssetGUI"];
                StringBuilder finalScriptText = new StringBuilder();
                foreach (string newImport in imports)
                {
                    finalScriptText.AppendLine($"using {newImport};");
                }
                finalScriptText.Append(scriptText);

                // parse syntax
                SyntaxTree syntaxTree = SyntaxFactory.ParseSyntaxTree(finalScriptText.ToString(), new CSharpParseOptions(kind: SourceCodeKind.Script, languageVersion: LanguageVersion.Latest));

                // compile
                var compilation = CSharpCompilation.CreateScriptCompilation(
                    assemblyName: "Script" + customAsmId + "_" + scriptID,
                    syntaxTree,
                    references,
                    returnType: null,
                    globalsType: typeof(RoslynGlobals));
                customAsmId++;

                var peStream = new MemoryStream(); // don't need to dispose
                var pdbStream = new MemoryStream(); // don't need to dispose
                var result = compilation.Emit(peStream, pdbStream, xmlDocumentationStream: null, win32Resources: null, manifestResources: null,
                    new EmitOptions(
                        debugInformationFormat: DebugInformationFormat.PortablePdb,
                        pdbChecksumAlgorithm: default(HashAlgorithmName)));

                if (!result.Success)
                {
                    string errorText = "Errors occurred during compilation\n\n";
                    foreach (var exception in result.Diagnostics)
                    {
                        errorText += exception.ToString() + "\n";
                    }
                    throw new ArgumentException(errorText);
                }

                // load asm
                peStream.Seek(0, SeekOrigin.Begin);
                pdbStream.Seek(0, SeekOrigin.Begin);
                var scriptAssembly = assemblyLoadContext.LoadFromStream(peStream, pdbStream);

                // get entry point
                var entryPoint = compilation.GetEntryPoint(CancellationToken.None) ?? throw new InvalidOperationException("Entry point could not be determined");
                var entryPointType = scriptAssembly.GetType($"{entryPoint.ContainingNamespace.MetadataName}.{entryPoint.ContainingType.MetadataName}", throwOnError: true, ignoreCase: false);
                var entryPointMethod = entryPointType?.GetTypeInfo().GetDeclaredMethod(entryPoint.MetadataName) ?? throw new InvalidOperationException("Entry point method could not be determined");
                entryPointDelegate = entryPointMethod.CreateDelegate<Func<object[], Task>>();

                compiledScriptsAsms[scriptID] = assemblyLoadContext;
                lastCompiledScriptText[scriptID] = scriptText;
                compiledScripts[scriptID] = entryPointDelegate;
            }

            return entryPointDelegate.Invoke([new RoslynGlobals() { Interface = new ScriptInterfaceWrapper(this) }, null]);
        }

        public class RoslynGlobals
        {
            public IScriptInterface Interface;
        }

        internal void executeScriptSubItem_Click(object sender, EventArgs e)
        {
            string scriptID = ((ToolStripMenuItem)sender).Tag as string;
            string scriptText = scriptID == null ? null : UAGConfig.GetScriptTextByID(scriptID);
            if (scriptText == null)
            {
                UAGUtils.InvokeUI(() =>
                {
                    MessageBox.Show("Failed to read script", "Uh oh!");
                    UAGConfig.RefreshAllScriptIDs();
                });
                return;
            }

            Task.Run(() =>
            {
                try
                {
                    ExecuteScript(scriptText, scriptID).Wait();
                }
                catch (AggregateException ae)
                {
                    string errText = "";
                    foreach (var ex in ae.InnerExceptions)
                    {
                        errText += "\n\n" + ex.GetType().ToString() + ": " + ex.Message + "\n" + ex.StackTrace;
                    }

                    UAGUtils.InvokeUI(() =>
                    {
                        MessageBox.Show("Script threw an exception" + errText, "Uh oh!");
                        UAGConfig.RefreshAllScriptIDs();
                    });
                }
                catch (Exception ex)
                {
                    string errText = "\n\n" + ex.GetType().ToString() + ": " + ex.Message + "\n" + ex.StackTrace;

                    UAGUtils.InvokeUI(() =>
                    {
                        MessageBox.Show("Failed to execute script" + errText, "Uh oh!");
                        UAGConfig.RefreshAllScriptIDs();
                    });
                }
            });
        }

        internal void editScriptSubItem_Click(object sender, EventArgs e)
        {
            string scriptId = ((ToolStripMenuItem)sender).Tag as string;
            if (scriptId == null)
            {
                UAGUtils.InvokeUI(() =>
                {
                    MessageBox.Show("Failed to get script ID", "Uh oh!");
                    UAGConfig.RefreshAllScriptIDs();
                });
                return;
            }

            string newScriptPath = UAGConfig.CreateAndReturnPathToScript(scriptId);
            if (newScriptPath == null)
            {
                MessageBox.Show("Failed to find script on disk", "Uh oh!");
                UAGConfig.RefreshAllScriptIDs();
            }
            else
            {
                new Process()
                {
                    StartInfo = new ProcessStartInfo()
                    {
                        UseShellExecute = true,
                        FileName = newScriptPath
                    }
                }.Start();
            }
        }

        internal void executeScriptNewItem_Click(object sender, EventArgs e)
        {
            TextPrompt replacementPrompt = new TextPrompt()
            {
                DisplayText = "What would you like to name your new script?"
            };

            replacementPrompt.StartPosition = FormStartPosition.CenterParent;

            if (replacementPrompt.ShowDialog(this) == DialogResult.OK)
            {
                string newScriptName = string.Join("_", replacementPrompt.OutputText.Replace(' ', '_').Split(Path.GetInvalidFileNameChars(), StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
                string newScriptPath = UAGConfig.CreateAndReturnPathToScript(newScriptName);
                if (newScriptPath == null)
                {
                    MessageBox.Show("Failed to create new script", "Uh oh!");
                }
                else
                {
                    new Process()
                    {
                        StartInfo = new ProcessStartInfo()
                        {
                            UseShellExecute = true,
                            FileName = newScriptPath
                        }
                    }.Start();
                }
            }

            replacementPrompt.Dispose();
        }

        private bool hasActivatedBefore = false;
        private void Form1_Activated(object sender, EventArgs e)
        {
            // if first time the form is ever activated, check if FileContainerForm is open, if so then activate that
            if (hasActivatedBefore) return;
            hasActivatedBefore = true;
            foreach (var form in Application.OpenForms)
            {
                if (form is FileContainerForm fcForm)
                {
                    fcForm.Activate();
                    break;
                }
            }
        }
    }
}

```

`UAssetGUI/Form1.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="menuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>166, 17</value>
  </metadata>
  <metadata name="nameMapContext.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`UAssetGUI/GitHubAPI.cs`:

```cs
using System;
using System.Net;

namespace UAssetGUI
{
    public static class GitHubAPI
    {
        public static string CombineURI(params string[] uris)
        {
            string output = "";
            foreach (string uriBit in uris)
            {
                output += uriBit.Trim('/') + "/";
            }
            return output.TrimEnd('/');
        }

        public static string GetLatestVersionURL(string repo)
        {
            return CombineURI("https://github.com", repo, "releases", "latest");
        }

        public static Version GetLatestVersionFromGitHub(string repo)
        {
            try
            {
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create(GetLatestVersionURL(repo));
                request.Method = "GET";
                request.AllowAutoRedirect = false;
                request.ContentType = "application/json; charset=utf-8";
                request.UserAgent = "UAssetGUI/" + UAGUtils._displayVersion;

                string newURL = null;
                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                {
                    newURL = response.Headers["location"];
                }

                if (string.IsNullOrEmpty(newURL)) return null;
                string[] splitURL = newURL.Split('/');

                string finalVersionBit = splitURL[splitURL.Length - 1];
                if (finalVersionBit[0] == 'v') finalVersionBit = finalVersionBit.Substring(1);
                finalVersionBit = finalVersionBit.Replace(".0-alpha.", ".");

                Version.TryParse(finalVersionBit, out Version foundVersion);
                return foundVersion;
            }
            catch (Exception ex)
            {
                if (ex is WebException || ex is FormatException) return null;
                throw;
            }
        }
    }
}

```

`UAssetGUI/GlobalSuppressions.cs`:

```cs

// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc.

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>", Scope = "member", Target = "~M:UAssetGUI.Form1.openToolStripMenuItem_Click(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>", Scope = "member", Target = "~M:UAssetGUI.Form1.saveToolStripMenuItem_Click(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>", Scope = "member", Target = "~M:UAssetGUI.Form1.menuStrip1_ItemClicked(System.Object,System.Windows.Forms.ToolStripItemClickedEventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>", Scope = "member", Target = "~M:UAssetGUI.Form1.saveAsToolStripMenuItem_Click(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>", Scope = "member", Target = "~M:UAssetGUI.Form1.frm_sizeChanged(System.Object,System.EventArgs)")]
```

`UAssetGUI/IScriptInterface.cs`:

```cs
using System.Windows.Forms;
using UAssetAPI;

namespace UAssetGUI
{
    /// <summary>
    /// Interface used for interacting with UAssetGUI scripts. An instance is provided as a global variable called "Interface" in all scripts.
    /// </summary>
    public interface IScriptInterface
    {
        public string GetDisplayVersion();
        public TableHandler GetTableHandler();
        public Form1 GetBaseForm();
        public ColorfulTreeView GetTreeView();
        public FileContainerForm GetFileContainerForm();
        public UAsset GetLoadedAsset();
    }

    public class ScriptInterfaceWrapper : IScriptInterface
    {
        private Form1 baseForm;
        public string GetDisplayVersion()
        {
            return baseForm?.DisplayVersion;
        }
        public TableHandler GetTableHandler()
        {
            return baseForm?.tableEditor;
        }
        public Form1 GetBaseForm()
        {
            return baseForm;
        }
        public ColorfulTreeView GetTreeView()
        {
            return baseForm?.treeView1;
        }
        public FileContainerForm GetFileContainerForm()
        {
            foreach (var form in Application.OpenForms)
            {
                if (form is FileContainerForm fcForm)
                {
                    return fcForm;
                }
            }
            return null;
        }
        public UAsset GetLoadedAsset()
        {
            return baseForm?.tableEditor?.asset;
        }

        public ScriptInterfaceWrapper(Form1 baseForm)
        {
            this.baseForm = baseForm;
        }
    }
}

```

`UAssetGUI/LICENSE`:

```
MIT License

Copyright (c) 2020 - 2026 atenfyr

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`UAssetGUI/MapStructTypeOverrideForm.Designer.cs`:

```cs
namespace UAssetGUI
{
    partial class MapStructTypeOverrideForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            this.mstoDataGridView = new System.Windows.Forms.DataGridView();
            this.infoLabel = new System.Windows.Forms.Label();
            this.refreshButton = new System.Windows.Forms.Button();
            this.closeButton = new System.Windows.Forms.Button();
            this.exportButton = new System.Windows.Forms.Button();
            this.importButton = new System.Windows.Forms.Button();
            this.resetButton = new System.Windows.Forms.Button();
            ((System.ComponentModel.ISupportInitialize)(this.mstoDataGridView)).BeginInit();
            this.SuspendLayout();
            // 
            // mstoDataGridView
            // 
            this.mstoDataGridView.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.mstoDataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.AllCells;
            this.mstoDataGridView.BackgroundColor = System.Drawing.Color.LightGray;
            this.mstoDataGridView.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
            this.mstoDataGridView.ClipboardCopyMode = System.Windows.Forms.DataGridViewClipboardCopyMode.EnableWithoutHeaderText;
            this.mstoDataGridView.ColumnHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.Single;
            dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle1.BackColor = System.Drawing.SystemColors.Control;
            dataGridViewCellStyle1.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F);
            dataGridViewCellStyle1.ForeColor = System.Drawing.SystemColors.WindowText;
            dataGridViewCellStyle1.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle1.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle1.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.mstoDataGridView.ColumnHeadersDefaultCellStyle = dataGridViewCellStyle1;
            this.mstoDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.mstoDataGridView.EditMode = System.Windows.Forms.DataGridViewEditMode.EditOnEnter;
            this.mstoDataGridView.EnableHeadersVisualStyles = false;
            this.mstoDataGridView.Location = new System.Drawing.Point(12, 52);
            this.mstoDataGridView.Name = "mstoDataGridView";
            this.mstoDataGridView.RowHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.Single;
            this.mstoDataGridView.RowHeadersWidth = 60;
            this.mstoDataGridView.RowHeadersWidthSizeMode = System.Windows.Forms.DataGridViewRowHeadersWidthSizeMode.DisableResizing;
            this.mstoDataGridView.Size = new System.Drawing.Size(545, 289);
            this.mstoDataGridView.TabIndex = 1;
            this.mstoDataGridView.CellEndEdit += new System.Windows.Forms.DataGridViewCellEventHandler(this.mstoDataGridView_CellEndEdit);
            // 
            // infoLabel
            // 
            this.infoLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.infoLabel.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.25F);
            this.infoLabel.Location = new System.Drawing.Point(13, 9);
            this.infoLabel.Name = "infoLabel";
            this.infoLabel.Size = new System.Drawing.Size(544, 40);
            this.infoLabel.TabIndex = 0;
            this.infoLabel.Text = "blah blah blah";
            this.infoLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // refreshButton
            // 
            this.refreshButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.refreshButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.refreshButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.refreshButton.Location = new System.Drawing.Point(12, 347);
            this.refreshButton.Name = "refreshButton";
            this.refreshButton.Size = new System.Drawing.Size(75, 26);
            this.refreshButton.TabIndex = 2;
            this.refreshButton.Text = "Refresh";
            this.refreshButton.UseVisualStyleBackColor = true;
            this.refreshButton.Click += new System.EventHandler(this.refreshButton_Click);
            // 
            // closeButton
            // 
            this.closeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.closeButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.closeButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.closeButton.ForeColor = System.Drawing.SystemColors.ControlText;
            this.closeButton.Location = new System.Drawing.Point(482, 347);
            this.closeButton.Name = "closeButton";
            this.closeButton.Size = new System.Drawing.Size(75, 26);
            this.closeButton.TabIndex = 3;
            this.closeButton.Text = "Close";
            this.closeButton.UseVisualStyleBackColor = true;
            this.closeButton.Click += new System.EventHandler(this.closeButton_Click);
            // 
            // exportButton
            // 
            this.exportButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.exportButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.exportButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.exportButton.Location = new System.Drawing.Point(174, 347);
            this.exportButton.Name = "exportButton";
            this.exportButton.Size = new System.Drawing.Size(75, 26);
            this.exportButton.TabIndex = 4;
            this.exportButton.Text = "Export";
            this.exportButton.UseVisualStyleBackColor = true;
            this.exportButton.Click += new System.EventHandler(this.exportButton_Click);
            // 
            // importButton
            // 
            this.importButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.importButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.importButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.importButton.Location = new System.Drawing.Point(93, 347);
            this.importButton.Name = "importButton";
            this.importButton.Size = new System.Drawing.Size(75, 26);
            this.importButton.TabIndex = 5;
            this.importButton.Text = "Import";
            this.importButton.UseVisualStyleBackColor = true;
            this.importButton.Click += new System.EventHandler(this.importButton_Click);
            // 
            // resetButton
            // 
            this.resetButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.resetButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.resetButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            this.resetButton.Location = new System.Drawing.Point(401, 347);
            this.resetButton.Name = "resetButton";
            this.resetButton.Size = new System.Drawing.Size(75, 26);
            this.resetButton.TabIndex = 6;
            this.resetButton.Text = "Reset";
            this.resetButton.UseVisualStyleBackColor = true;
            this.resetButton.Click += new System.EventHandler(this.resetButton_Click);
            // 
            // MapStructTypeOverrideForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(569, 379);
            this.Controls.Add(this.resetButton);
            this.Controls.Add(this.importButton);
            this.Controls.Add(this.exportButton);
            this.Controls.Add(this.closeButton);
            this.Controls.Add(this.refreshButton);
            this.Controls.Add(this.infoLabel);
            this.Controls.Add(this.mstoDataGridView);
            this.Name = "MapStructTypeOverrideForm";
            this.Text = "Map Struct Type Overrides";
            this.Load += new System.EventHandler(this.MapStructTypeOverrideForm_Load);
            this.Resize += new System.EventHandler(this.MapStructTypeOverrideForm_Resize);
            ((System.ComponentModel.ISupportInitialize)(this.mstoDataGridView)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion
        private System.Windows.Forms.Label infoLabel;
        internal System.Windows.Forms.DataGridView mstoDataGridView;
        private System.Windows.Forms.Button refreshButton;
        private System.Windows.Forms.Button closeButton;
        private System.Windows.Forms.Button exportButton;
        private System.Windows.Forms.Button importButton;
        private System.Windows.Forms.Button resetButton;
    }
}
```

`UAssetGUI/MapStructTypeOverrideForm.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using System.Windows.Forms;
using UAssetAPI;
using UAssetAPI.UnrealTypes;

namespace UAssetGUI
{
    public partial class MapStructTypeOverrideForm : Form
    {
        public static Dictionary<string, Tuple<FString, FString>> MapStructTypeOverride = null;

        public MapStructTypeOverrideForm()
        {
            InitializeComponent();

            infoLabel.Text = "This table maps MapProperty names to the type of the structs within them. You can use header dumps to determine these values if necessary.";

            if (!SystemInformation.TerminalServerSession)
            {
                Type ourGridType = mstoDataGridView.GetType();
                PropertyInfo pi = ourGridType.GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic);
                pi.SetValue(mstoDataGridView, true, null);
            }
        }

        private static void CheckIfMapStructTypeOverrideIsNull()
        {
            if (MapStructTypeOverride == null) MapStructTypeOverride = new UAsset().MapStructTypeOverride;
        }

        private void MapStructTypeOverrideForm_Resize(object sender, EventArgs e)
        {
            ForceResize();
        }

        public void ForceResize()
        {
            mstoDataGridView.Height = closeButton.Location.Y - infoLabel.Location.Y - infoLabel.Height - 9;
        }

        private void AddColumns(string[] ourColumns)
        {
            for (int i = 0; i < ourColumns.Length; i++)
            {
                DataGridViewColumn dgc = new DataGridViewTextBoxColumn
                {
                    HeaderText = ourColumns[i]
                };

                dgc.AutoSizeMode = DataGridViewAutoSizeColumnMode.AllCells;
                if (i >= (ourColumns.Length - 1))
                {
                    dgc.AutoSizeMode = DataGridViewAutoSizeColumnMode.Fill;
                }

                dgc.SortMode = DataGridViewColumnSortMode.NotSortable;
                mstoDataGridView.Columns.Add(dgc);
            }
        }

        private void MapStructTypeOverrideForm_Load(object sender, EventArgs e)
        {
            CheckIfMapStructTypeOverrideIsNull();

            UAGPalette.RefreshTheme(this);
            ForceResize();
            this.AdjustFormPosition();

            LoadOntoDGV();
        }

        private void SaveFromDGV()
        {
            CheckIfMapStructTypeOverrideIsNull();

            MapStructTypeOverride.Clear();
            foreach (DataGridViewRow row in mstoDataGridView.Rows)
            {
                string mapName = row.Cells[0].Value as string;
                string keyName = row.Cells[1].Value as string;
                string valueName = row.Cells[2].Value as string;
                if (mapName == null || keyName == null || valueName == null) continue;
                MapStructTypeOverride.Add(mapName, new Tuple<FString, FString>(FString.FromString(keyName), FString.FromString(valueName)));
            }
            SaveToConfig();
        }

        private void LoadOntoDGV()
        {
            CheckIfMapStructTypeOverrideIsNull();

            mstoDataGridView.Visible = true;
            mstoDataGridView.Columns.Clear();
            mstoDataGridView.Rows.Clear();
            mstoDataGridView.AllowUserToAddRows = true;
            mstoDataGridView.ReadOnly = false;
            mstoDataGridView.BackgroundColor = UAGPalette.DataGridViewActiveColor;
            AddColumns(new string[] { "Map Name", "Key Struct Type Name", "Value Struct Type Name" });

            foreach (KeyValuePair<string, Tuple<FString, FString>> entry in MapStructTypeOverride)
            {
                mstoDataGridView.Rows.Add(new object[] { entry.Key.ToString(), entry.Value.Item1?.ToString() ?? FString.NullCase, entry.Value.Item2?.ToString() ?? FString.NullCase });
            }
        }

        internal static void SaveToConfig()
        {
            CheckIfMapStructTypeOverrideIsNull();

            UAGConfig.Data.MapStructTypeOverride = ExportData(Formatting.None);
            UAGConfig.Save();
        }

        internal static void LoadFromConfig()
        {
            CheckIfMapStructTypeOverrideIsNull();

            ImportData(UAGConfig.Data.MapStructTypeOverride);
        }

        private static void ImportData(string data)
        {
            if (data == null) return;
            CheckIfMapStructTypeOverrideIsNull();

            Dictionary<string, string[]> temp = JsonConvert.DeserializeObject<Dictionary<string, string[]>>(data);
            if (temp == null || temp.Count == 0) return;

            MapStructTypeOverride.Clear();
            foreach (KeyValuePair<string, string[]> entry in temp)
            {
                MapStructTypeOverride.Add(entry.Key, new Tuple<FString, FString>(FString.FromString(entry.Value[0]), FString.FromString(entry.Value[1])));
            }
        }

        private static string ExportData(Formatting formatting = Formatting.Indented)
        {
            CheckIfMapStructTypeOverrideIsNull();

            StringBuilder sb = new StringBuilder();
            StringWriter sw = new StringWriter(sb);

            using (JsonWriter writer = new JsonTextWriter(sw))
            {
                writer.Formatting = formatting;

                writer.WriteStartObject();
                foreach (KeyValuePair<string, Tuple<FString, FString>> entry in MapStructTypeOverride)
                {
                    writer.WritePropertyName(entry.Key.ToString());
                    writer.WriteStartArray();
                    writer.WriteValue(entry.Value.Item1?.ToString());
                    writer.WriteValue(entry.Value.Item2?.ToString());
                    writer.WriteEnd();
                }
                writer.WriteEndObject();
            }

            return sb.ToString();
        }

        private void mstoDataGridView_CellEndEdit(object sender, DataGridViewCellEventArgs e)
        {
            SaveFromDGV();
        }

        private void refreshButton_Click(object sender, EventArgs e)
        {
            LoadOntoDGV();
        }

        private void closeButton_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        private void importButton_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog openFileDialog = new OpenFileDialog())
            {
                openFileDialog.Filter = "Map Struct Type Override JSON (*.json)|*.json|All files (*.*)|*.*";
                openFileDialog.FilterIndex = 1;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    ImportData(File.ReadAllText(openFileDialog.FileName));
                    LoadOntoDGV();
                    SaveToConfig();
                }
            }
        }

        private void exportButton_Click(object sender, EventArgs e)
        {
            using (SaveFileDialog dialog = new SaveFileDialog())
            {
                dialog.Filter = "Map Struct Type Override JSON (*.json)|*.json|All files (*.*)|*.*";
                dialog.FilterIndex = 1;
                dialog.RestoreDirectory = true;

                DialogResult res = dialog.ShowDialog();
                if (res == DialogResult.OK)
                {
                    SaveFromDGV();
                    File.WriteAllText(dialog.FileName, ExportData());
                }
            }
        }

        private void resetButton_Click(object sender, EventArgs e)
        {
            DialogResult res = MessageBox.Show("Are you sure you want to reset the table to its defaults?", this.Text, MessageBoxButtons.OKCancel);
            if (res != DialogResult.OK) return;

            MapStructTypeOverride = null;
            CheckIfMapStructTypeOverrideIsNull();
            LoadOntoDGV();
            SaveToConfig();
        }
    }
}

```

`UAssetGUI/MapStructTypeOverrideForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UAssetGUI/MarkdownViewer.Designer.cs`:

```cs
namespace UAssetGUI
{
    partial class MarkdownViewer
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            browser1 = new System.Windows.Forms.WebBrowser();
            closeButton = new System.Windows.Forms.Button();
            SuspendLayout();
            // 
            // browser1
            // 
            browser1.Dock = System.Windows.Forms.DockStyle.Top;
            browser1.Location = new System.Drawing.Point(0, 0);
            browser1.Name = "browser1";
            browser1.Size = new System.Drawing.Size(619, 408);
            browser1.TabIndex = 0;
            browser1.Navigating += browser1_Navigating;
            // 
            // closeButton
            // 
            closeButton.Anchor = System.Windows.Forms.AnchorStyles.None;
            closeButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            closeButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            closeButton.ForeColor = System.Drawing.SystemColors.ControlText;
            closeButton.Location = new System.Drawing.Point(518, 414);
            closeButton.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            closeButton.Name = "closeButton";
            closeButton.Size = new System.Drawing.Size(88, 30);
            closeButton.TabIndex = 5;
            closeButton.Text = "Close";
            closeButton.UseVisualStyleBackColor = true;
            closeButton.Click += closeButton_Click;
            // 
            // MarkdownViewer
            // 
            AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            ClientSize = new System.Drawing.Size(619, 454);
            Controls.Add(closeButton);
            Controls.Add(browser1);
            Font = new System.Drawing.Font("Microsoft Sans Serif", 10F);
            Name = "MarkdownViewer";
            Text = "MarkdownViewer";
            Load += MarkdownViewer_Load;
            Resize += MarkdownViewer_Resize;
            ResumeLayout(false);
        }

        #endregion

        private System.Windows.Forms.WebBrowser browser1;
        private System.Windows.Forms.Button closeButton;
    }
}
```

`UAssetGUI/MarkdownViewer.cs`:

```cs
using Markdig;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace UAssetGUI
{
    public partial class MarkdownViewer : Form
    {
        public string MarkdownToDisplay = string.Empty;

        public MarkdownViewer()
        {
            InitializeComponent();
        }

        private void MarkdownViewer_Load(object sender, EventArgs e)
        {
            UAGPalette.RefreshTheme(this);
            this.AdjustFormPosition();

            var pipeline = new MarkdownPipelineBuilder().UseAdvancedExtensions().Build();
            string stylingHTML = "<!DOCTYPE html><html><head><style>html{font-family:Arial,Helvetica,sans-serif;background-color:" + ColorTranslator.ToHtml(this.BackColor) + ";color:" + ColorTranslator.ToHtml(this.ForeColor) + "}a{color:" + ColorTranslator.ToHtml(UAGPalette.LinkColor) + "}</style></head>";
            string finalHTML = stylingHTML + "<body>" + Markdown.ToHtml(MarkdownToDisplay, pipeline) + "</body></html>";

            this.browser1.DocumentText = finalHTML;

            ForceResize();
        }

        private void closeButton_Click(object sender, EventArgs e)
        {
            this.Dispose();
        }

        internal void ForceResize()
        {
            this.browser1.Size = new Size(this.ClientSize.Width, this.ClientSize.Height - this.closeButton.Height - 20);
            this.closeButton.Location = new Point(this.ClientSize.Width - this.closeButton.Width - 10, this.ClientSize.Height - this.closeButton.Height - 10);
        }

        private void MarkdownViewer_Resize(object sender, EventArgs e)
        {
            ForceResize();
        }

        private void browser1_Navigating(object sender, WebBrowserNavigatingEventArgs e)
        {
            string scheme = e.Url?.Scheme;
            if (scheme == "http" || scheme == "https")
            {
                e.Cancel = true;
                UAGUtils.OpenURL(e.Url.ToString());
            }
            // otherwise, presumably "navigating" to raw HTML (scheme == "about")
            // not really worried about implementing this in a more secure way
        }
    }
}

```

`UAssetGUI/MarkdownViewer.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema 

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UAssetGUI/NOTICE.md`:

```md
# Notices
The following is a list of applicable licensing information for all the third-party material used, in whole or in part, within this software.

## UAssetAPI
https://github.com/atenfyr/UAssetAPI
```
MIT License

Copyright (c) 2025 Atenfyr

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## repak
https://github.com/trumank/repak
```
MIT License

Copyright 2024 Truman Kilen, spuds

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## retoc
https://github.com/trumank/retoc
```
MIT License

Copyright (c) 2025 Truman Kilen and Archengius

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## Json.NET
https://github.com/JamesNK/Newtonsoft.Json
```
The MIT License (MIT)

Copyright (c) 2007 James Newton-King

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

## dotmore
https://github.com/mattmc3/dotmore
```
The MIT License (MIT)

Copyright (c) 2014 mattmc3

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## ZstdNet
https://github.com/skbkontur/ZstdNet
```
BSD License

For ZstdNet software

Copyright (c) 2016-present, SKB Kontur. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name SKB Kontur nor the names of its contributors may be used to
   endorse or promote products derived from this software without specific
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## zstd
https://github.com/facebook/zstd
```
BSD License

For Zstandard software

Copyright (c) Meta Platforms, Inc. and affiliates. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name Facebook, nor Meta, nor the names of its contributors may
   be used to endorse or promote products derived from this software without
   specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## UEAssetToolkitGenerator
https://github.com/LongerWarrior/UEAssetToolkitGenerator

### License
```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```
### Statement of Modification
Major portions of the source code that is adapted from UEAssetToolkitGenerator have been modified for usage in UAssetAPI through changes in code formatting, nomenclature, and serialization specifics in order to improve the effectiveness of the serialization across different engine versions and assets and to improve integration with newer versions of UAssetAPI. The relevant portions of source code have been sufficiently adapted such that no improper serialization or other unexpected behavior should be construed as having originated from any portion of the original work or any of its contributors.

### Original NOTICE text file information
The NOTICE text file bundled with the referenced project is not included in this copyright notice because none of the notices in that file pertain to any part of the work that is adapted for usage in UAssetAPI. Please see the original repository for more detailed copyright information.

## DiscordRichPresence
https://github.com/Lachee/discord-rpc-csharp
```
MIT License

Copyright (c) 2021 Lachee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## FolderBrowserEx
https://github.com/evaristocuesta/FolderBrowserEx
```
MIT License

Copyright (c) 2020 Evaristo Cuesta

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## markdig
https://github.com/xoofx/markdig
```
Copyright (c) 2018-2019, Alexandre Mutel
All rights reserved.

Redistribution and use in source and binary forms, with or without modification
, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this 
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, 
   this list of conditions and the following disclaimer in the documentation 
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## Roslyn
https://github.com/dotnet/roslyn
```
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## dotnet
https://github.com/dotnet/dotnet
```
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

```

`UAssetGUI/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Loader;
using System.Security.Cryptography;
using System.Windows.Forms;
using UAssetAPI;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetGUI
{
    public static class Program
    {
        [DllImport("user32.dll")]
        private static extern bool SetProcessDPIAware();

        internal static string ExtractCompressedResource(string resourceName, string outPath, Assembly targetAsm = null)
        {
            using (var stream = (targetAsm ?? typeof(Program).Assembly).GetManifestResourceStream(resourceName))
            {
                if (stream == null) return null;

                // compare hash of new compressed data to hash of compressed data already on disk (saved as .sha256 file)
                // this avoids unnecessary disk writes and improves load time
                byte[] newStreamHash = Array.Empty<byte>();
                using (SHA256 hash = SHA256.Create())
                {
                    newStreamHash = hash.ComputeHash(stream);
                    stream.Seek(0, SeekOrigin.Begin);
                }

                byte[] currentStreamHash = Array.Empty<byte>();
                string streamHashPath = Path.ChangeExtension(outPath, Path.GetExtension(outPath) + ".sha256");
                try
                {
                    if (File.Exists(streamHashPath)) currentStreamHash = File.ReadAllBytes(streamHashPath);
                }
                catch
                {
                    currentStreamHash = Array.Empty<byte>();
                }

                if (currentStreamHash.Length > 0 && newStreamHash.Length > 0 && currentStreamHash.SequenceEqual(newStreamHash) && File.Exists(outPath))
                {
                    // hashes are equal, OK to skip decompress/write routine
                    return outPath;
                }

                try
                {
                    using (FileStream newFileStream = File.Open(outPath, FileMode.Create, FileAccess.Write))
                    {
                        using (var gzipStream = new GZipStream(stream, CompressionMode.Decompress))
                        {
                            gzipStream.CopyTo(newFileStream);
                        }
                    }

                    // write new hash
                    File.WriteAllBytes(streamHashPath, newStreamHash);

                    return outPath;
                }
                catch (Exception ex) when (ex is IOException || ex is UnauthorizedAccessException || ex is DirectoryNotFoundException || ex is FileNotFoundException)
                {
                    // OK as long as the file exists, probably another instance of the software is already open
                    return File.Exists(outPath) ? outPath : null;
                }
            }
        }

        private static List<Type> strongRefs = new List<Type>();
        static Program()
        {
            try
            {
                // extract .dll.gz resources and load them on demand
                AssemblyLoadContext.Default.Resolving += (context, assemblyName) =>
                {
                    string libsPath = Path.Combine(UAGConfig.ConfigFolder, "Libraries");
                    Directory.CreateDirectory(UAGConfig.ConfigFolder);
                    Directory.CreateDirectory(libsPath);

                    string outPath = ExtractCompressedResource("UAssetGUI." + assemblyName.Name + ".dll.gz", Path.Combine(libsPath, assemblyName.Name + ".dll"));
                    if (outPath == null) return null; // if not found, fall back to default behavior
                    return Assembly.LoadFrom(outPath);
                };

                strongRefs.Add(typeof(System.Collections.Immutable.ImmutableArray));
                strongRefs.Add(typeof(System.Reflection.Metadata.MetadataReader));
            }
            catch (Exception ex)
            {
                Clipboard.SetText(ex.ToString());
            }
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        public static void Main()
        {
            try
            {
                if (Environment.OSVersion.Version.Major >= 6) SetProcessDPIAware();
                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);
                Application.SetDefaultFont(new Font(new FontFamily("Microsoft Sans Serif"), 8.25f)); // default font changed in .NET Core 3.0

                string[] args = Environment.GetCommandLineArgs();
                if (args.Length >= 2)
                {
                    Usmap selectedMappings = null;

                    switch (args[1].ToLowerInvariant())
                    {
                        // tojson <source> <destination> <engine version> [mappings name]
                        // UAssetGUI tojson A.umap B.json 23 Outriders
                        case "tojson":
                            UAGConfig.LoadMappings();

                            if (args.Length < 5) break;
                            if (args.Length >= 6) UAGConfig.TryGetMappings(args[5], out selectedMappings);

                            EngineVersion selectedVer = EngineVersion.UNKNOWN;
                            if (int.TryParse(args[4], out int selectedVerRaw)) selectedVer = EngineVersion.VER_UE4_0 + selectedVerRaw;
                            else Enum.TryParse(args[4], out selectedVer);

                            string jsonSerializedAsset = new UAsset(args[2], selectedVer, selectedMappings).SerializeJson(Newtonsoft.Json.Formatting.Indented);
                            File.WriteAllText(args[3], jsonSerializedAsset);
                            return;
                        // fromjson <source> <destination> [mappings name]
                        // UAssetGUI fromjson B.json A.umap Outriders
                        case "fromjson":
                            UAGConfig.LoadMappings();

                            if (args.Length < 4) break;
                            if (args.Length >= 5) UAGConfig.TryGetMappings(args[4], out selectedMappings);

                            UAsset jsonDeserializedAsset = null;
                            using (var sr = new FileStream(args[2], FileMode.Open))
                            {
                                jsonDeserializedAsset = UAsset.DeserializeJson(sr);
                            }

                            if (jsonDeserializedAsset != null)
                            {
                                jsonDeserializedAsset.Mappings = selectedMappings;
                                jsonDeserializedAsset.FilePath = args[2];
                                jsonDeserializedAsset.Write(args[3]);
                            }
                            return;
                    }
                }

                Form1 f1 = new Form1
                {
                    Size = new System.Drawing.Size(1000, 700)
                };
                Application.Run(f1);
            }
            catch (Exception ex)
            {
                Clipboard.SetText(ex.ToString());
            }
        }
    }
}

```

`UAssetGUI/ProgressBarForm.Designer.cs`:

```cs
namespace UAssetGUI
{
    partial class ProgressBarForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            ProgressBar = new System.Windows.Forms.ProgressBar();
            cancelButton = new System.Windows.Forms.Button();
            label1 = new System.Windows.Forms.Label();
            SuspendLayout();
            // 
            // ProgressBar
            // 
            ProgressBar.Location = new System.Drawing.Point(18, 17);
            ProgressBar.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            ProgressBar.Name = "ProgressBar";
            ProgressBar.Size = new System.Drawing.Size(201, 51);
            ProgressBar.TabIndex = 14;
            // 
            // cancelButton
            // 
            cancelButton.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right;
            cancelButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            cancelButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            cancelButton.ForeColor = System.Drawing.SystemColors.ControlText;
            cancelButton.Location = new System.Drawing.Point(134, 79);
            cancelButton.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            cancelButton.Name = "cancelButton";
            cancelButton.Size = new System.Drawing.Size(90, 31);
            cancelButton.TabIndex = 15;
            cancelButton.Text = "Cancel...";
            cancelButton.UseVisualStyleBackColor = true;
            cancelButton.Click += cancelButton_Click;
            // 
            // label1
            // 
            label1.Location = new System.Drawing.Point(16, 79);
            label1.Name = "label1";
            label1.Size = new System.Drawing.Size(95, 30);
            label1.TabIndex = 16;
            label1.Text = "label1";
            label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // ProgressBarForm
            // 
            AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            ClientSize = new System.Drawing.Size(237, 122);
            Controls.Add(label1);
            Controls.Add(cancelButton);
            Controls.Add(ProgressBar);
            FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            MaximizeBox = false;
            MinimizeBox = false;
            Name = "ProgressBarForm";
            Text = "ProgressBarForm";
            Load += ProgressBarForm_Load;
            ResumeLayout(false);
        }

        #endregion

        public System.Windows.Forms.ProgressBar ProgressBar;
        private System.Windows.Forms.Button cancelButton;
        private System.Windows.Forms.Label label1;
    }
}
```

`UAssetGUI/ProgressBarForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace UAssetGUI
{
    public partial class ProgressBarForm : Form
    {
        public Form BaseForm;
        public int Value;
        public int Maximum;

        private const int CP_NOCLOSE_BUTTON = 0x200;
        protected override CreateParams CreateParams
        {
            get
            {
                CreateParams myCp = base.CreateParams;
                myCp.ClassStyle = myCp.ClassStyle | CP_NOCLOSE_BUTTON;
                return myCp;
            }
        }

        public void Progress(int numToAdd)
        {
            Value += numToAdd;
            UpdateGUI();
        }

        public void UpdateGUI()
        {
            ProgressBar.Value = Value;
            label1.Text = ProgressBar.Value.ToString() + "/" + ProgressBar.Maximum.ToString();
        }

        public ProgressBarForm()
        {
            InitializeComponent();
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            if (BaseForm is FileContainerForm fcForm) fcForm.extractAllBackgroundWorker.CancelAsync();
        }

        private void ProgressBarForm_Load(object sender, EventArgs e)
        {
            ProgressBar.Value = Value;
            ProgressBar.Minimum = 0;
            ProgressBar.Maximum = Maximum;
            UAGPalette.RefreshTheme(this);
            this.AdjustFormPosition(BaseForm);
        }
    }
}

```

`UAssetGUI/ProgressBarForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema 

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UAssetGUI/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace UAssetGUI.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("UAssetGUI.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] dancing_cat {
            get {
                object obj = ResourceManager.GetObject("dancing_cat", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to // this example script displays a simple message to the user
        ///UAGUtils.InvokeUI(() =&gt;
        ///{
        ///    MessageBox.Show(&quot;Welcome to scripting with C# in UAssetGUI!\n\n&quot; + Interface.GetBaseForm().GetProjectName() + &quot;\n&quot; + Interface.GetDisplayVersion(), &quot;Hello, world!&quot;);
        ///});
        ///.
        /// </summary>
        internal static string Hello_world {
            get {
                return ResourceManager.GetString("Hello_world", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Icon similar to (Icon).
        /// </summary>
        internal static System.Drawing.Icon icon {
            get {
                object obj = ResourceManager.GetObject("icon", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to // this example script changes the value of all float entries in the currently selected node to 100
        ///UAGUtils.InvokeUI(() =&gt;
        ///{
        ///    // get currently selected node
        ///    int numChanged = 0;
        ///    var pointingTreeNode = Interface.GetTreeView().SelectedNode as PointingTreeNode;
        ///    if (pointingTreeNode.Type == PointingTreeNodeType.Normal &amp;&amp; pointingTreeNode.Pointer is NormalExport normalExport)
        ///    {
        ///        // update all FloatProperty and DoubleProperty entries in normalExport
        ///        foreach (PropertyData [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string Set_all_visible_floats_to_100 {
            get {
                return ResourceManager.GetString("Set_all_visible_floats_to_100", resourceCulture);
            }
        }
    }
}

```

`UAssetGUI/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="dancing_cat" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\dancing_cat.gif;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="Hello_world" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\ExampleScripts\Hello_world.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
  <data name="icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\icon.ico;System.Drawing.Icon, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Set_all_visible_floats_to_100" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\ExampleScripts\Set_all_visible_floats_to_100.cs;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;utf-8</value>
  </data>
</root>
```

`UAssetGUI/Resources/ExampleScripts/Hello_world.cs`:

```cs
UAGUtils.InvokeUI(() =>
{
    // Your code goes here
    MessageBox.Show("Welcome to scripting with C# in UAssetGUI!\n\n" + Interface.GetBaseForm().GetProjectName() + "\n" + Interface.GetDisplayVersion(), "Hello, world!");
});

```

`UAssetGUI/Resources/ExampleScripts/Set_all_visible_floats_to_100.cs`:

```cs
// this example script changes the value of all float entries in the currently selected node to 100
int numChanged = 0;

void DoSwaps(List<PropertyData> props)
{
    foreach (PropertyData propData in props)
    {
        if (propData is FloatPropertyData floatPropData)
        {
            floatPropData.Value = 100;
            numChanged++;
        }
        if (propData is DoublePropertyData doublePropData)
        {
            doublePropData.Value = 100;
            numChanged++;
        }
    }
}

// UAGUtils.InvokeUI ensures that a block of code runs on the UI thread
// you should always use this whenever you are accessing UI components
// e.g. GetTreeView(), GetBaseForm()
UAGUtils.InvokeUI(() =>
{
    // get currently selected node
    var pointingTreeNode = Interface.GetTreeView().SelectedNode as PointingTreeNode;
    if (pointingTreeNode == null) return;

    if (pointingTreeNode.Pointer is NormalExport normalExport) DoSwaps(normalExport.Data);
    if (pointingTreeNode.Pointer is ArrayPropertyData arrProp) DoSwaps(arrProp.Value.ToList());
    if (pointingTreeNode.Pointer is StructPropertyData structProp) DoSwaps(structProp.Value);
    if (pointingTreeNode.Pointer is PropertyData[] arr) DoSwaps(arr.ToList());
    // more lines can be added here for other types of pointingTreeNode.Pointer

    // update display if we changed anything
    if (numChanged > 0)
    {
        Interface.GetTableHandler().Load();
        Interface.GetBaseForm().SetUnsavedChanges(true);
    }

    MessageBox.Show("Modified " + numChanged + " entries", Interface.GetDisplayVersion());
});

```

`UAssetGUI/ScriptAssemblyLoadContext.cs`:

```cs
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;

namespace UAssetGUI
{
    public class ScriptAssemblyLoadContext : AssemblyLoadContext
    {
        public ScriptAssemblyLoadContext() : base("ScriptAssemblyLoadContext", isCollectible: true)
        {

        }
    }
}

```

`UAssetGUI/SettingsForm.Designer.cs`:

```cs
namespace UAssetGUI
{
    partial class SettingsForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            infoLabel = new System.Windows.Forms.Label();
            closeButton = new System.Windows.Forms.Button();
            label1 = new System.Windows.Forms.Label();
            label2 = new System.Windows.Forms.Label();
            aboutButton = new System.Windows.Forms.Button();
            themeComboBox = new System.Windows.Forms.ComboBox();
            favoriteThingBox = new System.Windows.Forms.TextBox();
            valuesOnScroll = new System.Windows.Forms.CheckBox();
            numericUpDown1 = new System.Windows.Forms.NumericUpDown();
            label3 = new System.Windows.Forms.Label();
            enableDiscordRpc = new System.Windows.Forms.CheckBox();
            enableDynamicTree = new System.Windows.Forms.CheckBox();
            doubleClickToEdit = new System.Windows.Forms.CheckBox();
            enableBak = new System.Windows.Forms.CheckBox();
            restoreSize = new System.Windows.Forms.CheckBox();
            enableUpdateNotice = new System.Windows.Forms.CheckBox();
            enablePrettyBytecode = new System.Windows.Forms.CheckBox();
            label4 = new System.Windows.Forms.Label();
            customSerializationFlagsBox = new System.Windows.Forms.CheckedListBox();
            pictureBox1 = new System.Windows.Forms.PictureBox();
            enableBakJson = new System.Windows.Forms.CheckBox();
            allowUntrustedScriptsBox = new System.Windows.Forms.CheckBox();
            ((System.ComponentModel.ISupportInitialize)numericUpDown1).BeginInit();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).BeginInit();
            SuspendLayout();
            // 
            // infoLabel
            // 
            infoLabel.Anchor = System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right;
            infoLabel.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.25F);
            infoLabel.Location = new System.Drawing.Point(15, 10);
            infoLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            infoLabel.Name = "infoLabel";
            infoLabel.Size = new System.Drawing.Size(392, 46);
            infoLabel.TabIndex = 1;
            infoLabel.Text = "Settings:";
            infoLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // closeButton
            // 
            closeButton.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right;
            closeButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            closeButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            closeButton.ForeColor = System.Drawing.SystemColors.ControlText;
            closeButton.Location = new System.Drawing.Point(319, 357);
            closeButton.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            closeButton.Name = "closeButton";
            closeButton.Size = new System.Drawing.Size(88, 30);
            closeButton.TabIndex = 4;
            closeButton.Text = "Close";
            closeButton.UseVisualStyleBackColor = true;
            closeButton.Click += closeButton_Click;
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.25F);
            label1.Location = new System.Drawing.Point(72, 72);
            label1.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            label1.Name = "label1";
            label1.Size = new System.Drawing.Size(53, 16);
            label1.TabIndex = 15;
            label1.Text = "Theme:";
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.25F);
            label2.Location = new System.Drawing.Point(22, 102);
            label2.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            label2.Name = "label2";
            label2.Size = new System.Drawing.Size(96, 16);
            label2.TabIndex = 16;
            label2.Text = "Favorite Thing:";
            // 
            // aboutButton
            // 
            aboutButton.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left;
            aboutButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            aboutButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold);
            aboutButton.ForeColor = System.Drawing.SystemColors.ControlText;
            aboutButton.Location = new System.Drawing.Point(14, 357);
            aboutButton.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            aboutButton.Name = "aboutButton";
            aboutButton.Size = new System.Drawing.Size(88, 30);
            aboutButton.TabIndex = 7;
            aboutButton.Text = "About...";
            aboutButton.UseVisualStyleBackColor = true;
            aboutButton.Click += aboutButton_Click;
            // 
            // themeComboBox
            // 
            themeComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            themeComboBox.FormattingEnabled = true;
            themeComboBox.Location = new System.Drawing.Point(142, 70);
            themeComboBox.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            themeComboBox.Name = "themeComboBox";
            themeComboBox.Size = new System.Drawing.Size(252, 23);
            themeComboBox.TabIndex = 2;
            themeComboBox.SelectedIndexChanged += themeComboBox_SelectedIndexChanged;
            // 
            // favoriteThingBox
            // 
            favoriteThingBox.Location = new System.Drawing.Point(142, 100);
            favoriteThingBox.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            favoriteThingBox.Name = "favoriteThingBox";
            favoriteThingBox.Size = new System.Drawing.Size(252, 23);
            favoriteThingBox.TabIndex = 3;
            favoriteThingBox.TextChanged += favoriteThingBox_TextChanged;
            // 
            // valuesOnScroll
            // 
            valuesOnScroll.AutoSize = true;
            valuesOnScroll.Location = new System.Drawing.Point(215, 198);
            valuesOnScroll.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            valuesOnScroll.Name = "valuesOnScroll";
            valuesOnScroll.Size = new System.Drawing.Size(151, 19);
            valuesOnScroll.TabIndex = 7;
            valuesOnScroll.Text = "Change values on scroll";
            valuesOnScroll.UseVisualStyleBackColor = true;
            valuesOnScroll.CheckedChanged += valuesOnScroll_CheckedChanged;
            // 
            // numericUpDown1
            // 
            numericUpDown1.Location = new System.Drawing.Point(142, 130);
            numericUpDown1.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            numericUpDown1.Name = "numericUpDown1";
            numericUpDown1.Size = new System.Drawing.Size(252, 23);
            numericUpDown1.TabIndex = 4;
            numericUpDown1.ValueChanged += numericUpDown1_ValueChanged;
            // 
            // label3
            // 
            label3.AutoSize = true;
            label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.25F);
            label3.Location = new System.Drawing.Point(82, 130);
            label3.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            label3.Name = "label3";
            label3.Size = new System.Drawing.Size(45, 16);
            label3.TabIndex = 17;
            label3.Text = "Zoom:";
            // 
            // enableDiscordRpc
            // 
            enableDiscordRpc.AutoSize = true;
            enableDiscordRpc.Location = new System.Drawing.Point(29, 198);
            enableDiscordRpc.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            enableDiscordRpc.Name = "enableDiscordRpc";
            enableDiscordRpc.Size = new System.Drawing.Size(129, 19);
            enableDiscordRpc.TabIndex = 6;
            enableDiscordRpc.Text = "Enable Discord RPC";
            enableDiscordRpc.UseVisualStyleBackColor = true;
            enableDiscordRpc.CheckedChanged += enableDiscordRpc_CheckedChanged;
            // 
            // enableDynamicTree
            // 
            enableDynamicTree.AutoSize = true;
            enableDynamicTree.Location = new System.Drawing.Point(29, 251);
            enableDynamicTree.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            enableDynamicTree.Name = "enableDynamicTree";
            enableDynamicTree.Size = new System.Drawing.Size(133, 19);
            enableDynamicTree.TabIndex = 10;
            enableDynamicTree.Text = "Enable dynamic tree";
            enableDynamicTree.UseVisualStyleBackColor = true;
            enableDynamicTree.CheckedChanged += enableDynamicTree_CheckedChanged;
            // 
            // doubleClickToEdit
            // 
            doubleClickToEdit.AutoSize = true;
            doubleClickToEdit.Location = new System.Drawing.Point(29, 225);
            doubleClickToEdit.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            doubleClickToEdit.Name = "doubleClickToEdit";
            doubleClickToEdit.Size = new System.Drawing.Size(128, 19);
            doubleClickToEdit.TabIndex = 8;
            doubleClickToEdit.Text = "Double click to edit";
            doubleClickToEdit.UseVisualStyleBackColor = true;
            doubleClickToEdit.CheckedChanged += doubleClickToEdit_CheckedChanged;
            // 
            // enableBak
            // 
            enableBak.AutoSize = true;
            enableBak.Location = new System.Drawing.Point(215, 278);
            enableBak.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            enableBak.Name = "enableBak";
            enableBak.Size = new System.Drawing.Size(157, 19);
            enableBak.TabIndex = 13;
            enableBak.Text = "Enable .bak files (.uasset)";
            enableBak.UseVisualStyleBackColor = true;
            enableBak.CheckedChanged += enableBak_CheckedChanged;
            // 
            // restoreSize
            // 
            restoreSize.AutoSize = true;
            restoreSize.Location = new System.Drawing.Point(215, 251);
            restoreSize.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            restoreSize.Name = "restoreSize";
            restoreSize.Size = new System.Drawing.Size(156, 19);
            restoreSize.TabIndex = 11;
            restoreSize.Text = "Restore GUI size on open";
            restoreSize.UseVisualStyleBackColor = true;
            restoreSize.CheckedChanged += restoreSize_CheckedChanged;
            // 
            // enableUpdateNotice
            // 
            enableUpdateNotice.AutoSize = true;
            enableUpdateNotice.Location = new System.Drawing.Point(29, 278);
            enableUpdateNotice.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            enableUpdateNotice.Name = "enableUpdateNotice";
            enableUpdateNotice.Size = new System.Drawing.Size(137, 19);
            enableUpdateNotice.TabIndex = 12;
            enableUpdateNotice.Text = "Enable update notice";
            enableUpdateNotice.UseVisualStyleBackColor = true;
            enableUpdateNotice.CheckedChanged += enableUpdateNotice_CheckedChanged;
            // 
            // enablePrettyBytecode
            // 
            enablePrettyBytecode.AutoSize = true;
            enablePrettyBytecode.Location = new System.Drawing.Point(215, 225);
            enablePrettyBytecode.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            enablePrettyBytecode.Name = "enablePrettyBytecode";
            enablePrettyBytecode.Size = new System.Drawing.Size(147, 19);
            enablePrettyBytecode.TabIndex = 9;
            enablePrettyBytecode.Text = "Enable pretty bytecode";
            enablePrettyBytecode.UseVisualStyleBackColor = true;
            enablePrettyBytecode.CheckedChanged += enablePrettyBytecode_CheckedChanged;
            // 
            // label4
            // 
            label4.AutoSize = true;
            label4.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.25F);
            label4.Location = new System.Drawing.Point(82, 161);
            label4.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            label4.Name = "label4";
            label4.Size = new System.Drawing.Size(44, 16);
            label4.TabIndex = 18;
            label4.Text = "Flags:";
            // 
            // customSerializationFlagsBox
            // 
            customSerializationFlagsBox.CheckOnClick = true;
            customSerializationFlagsBox.FormattingEnabled = true;
            customSerializationFlagsBox.Location = new System.Drawing.Point(142, 161);
            customSerializationFlagsBox.Name = "customSerializationFlagsBox";
            customSerializationFlagsBox.ScrollAlwaysVisible = true;
            customSerializationFlagsBox.SelectionMode = System.Windows.Forms.SelectionMode.None;
            customSerializationFlagsBox.Size = new System.Drawing.Size(252, 22);
            customSerializationFlagsBox.TabIndex = 5;
            customSerializationFlagsBox.Click += customSerializationFlagsBox_Click;
            // 
            // pictureBox1
            // 
            pictureBox1.Location = new System.Drawing.Point(6, 10);
            pictureBox1.Name = "pictureBox1";
            pictureBox1.Size = new System.Drawing.Size(61, 78);
            pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            pictureBox1.TabIndex = 23;
            pictureBox1.TabStop = false;
            pictureBox1.Visible = false;
            // 
            // enableBakJson
            // 
            enableBakJson.AutoSize = true;
            enableBakJson.Location = new System.Drawing.Point(29, 305);
            enableBakJson.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            enableBakJson.Name = "enableBakJson";
            enableBakJson.Size = new System.Drawing.Size(146, 19);
            enableBakJson.TabIndex = 14;
            enableBakJson.Text = "Enable .bak files (.json)";
            enableBakJson.UseVisualStyleBackColor = true;
            enableBakJson.CheckedChanged += enableBakJson_CheckedChanged;
            // 
            // allowUntrustedScriptsBox
            // 
            allowUntrustedScriptsBox.AutoSize = true;
            allowUntrustedScriptsBox.Location = new System.Drawing.Point(215, 305);
            allowUntrustedScriptsBox.Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            allowUntrustedScriptsBox.Name = "allowUntrustedScriptsBox";
            allowUntrustedScriptsBox.Size = new System.Drawing.Size(147, 19);
            allowUntrustedScriptsBox.TabIndex = 24;
            allowUntrustedScriptsBox.Text = "Allow untrusted scripts";
            allowUntrustedScriptsBox.UseVisualStyleBackColor = true;
            allowUntrustedScriptsBox.CheckedChanged += allowUntrustedScriptsBox_CheckedChanged;
            // 
            // SettingsForm
            // 
            AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            ClientSize = new System.Drawing.Size(421, 395);
            Controls.Add(allowUntrustedScriptsBox);
            Controls.Add(enableBakJson);
            Controls.Add(pictureBox1);
            Controls.Add(customSerializationFlagsBox);
            Controls.Add(label4);
            Controls.Add(enablePrettyBytecode);
            Controls.Add(enableUpdateNotice);
            Controls.Add(restoreSize);
            Controls.Add(enableBak);
            Controls.Add(doubleClickToEdit);
            Controls.Add(enableDynamicTree);
            Controls.Add(enableDiscordRpc);
            Controls.Add(label3);
            Controls.Add(numericUpDown1);
            Controls.Add(valuesOnScroll);
            Controls.Add(favoriteThingBox);
            Controls.Add(themeComboBox);
            Controls.Add(aboutButton);
            Controls.Add(label2);
            Controls.Add(label1);
            Controls.Add(closeButton);
            Controls.Add(infoLabel);
            FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            Margin = new System.Windows.Forms.Padding(4, 3, 4, 3);
            Name = "SettingsForm";
            Text = "Settings";
            FormClosing += SettingsForm_FormClosing;
            Load += SettingsForm_Load;
            ((System.ComponentModel.ISupportInitialize)numericUpDown1).EndInit();
            ((System.ComponentModel.ISupportInitialize)pictureBox1).EndInit();
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private System.Windows.Forms.Label infoLabel;
        private System.Windows.Forms.Button closeButton;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Button aboutButton;
        private System.Windows.Forms.ComboBox themeComboBox;
        private System.Windows.Forms.CheckBox valuesOnScroll;
        private System.Windows.Forms.CheckBox enableDiscordRpc;
        private System.Windows.Forms.CheckBox enableDynamicTree;
        private System.Windows.Forms.CheckBox doubleClickToEdit;
        private System.Windows.Forms.CheckBox enableBak;
        private System.Windows.Forms.CheckBox restoreSize;
        private System.Windows.Forms.CheckBox enableUpdateNotice;
        private System.Windows.Forms.CheckBox enablePrettyBytecode;
        internal System.Windows.Forms.NumericUpDown numericUpDown1;
        internal System.Windows.Forms.Label label3;
        internal System.Windows.Forms.TextBox favoriteThingBox;
        internal System.Windows.Forms.CheckedListBox customSerializationFlagsBox;
        internal System.Windows.Forms.Label label4;
        private System.Windows.Forms.PictureBox pictureBox1;
        private System.Windows.Forms.CheckBox enableBakJson;
        private System.Windows.Forms.CheckBox allowUntrustedScriptsBox;
    }
}
```

`UAssetGUI/SettingsForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using UAssetAPI;

namespace UAssetGUI
{
    public partial class SettingsForm : Form
    {
        public SettingsForm()
        {
            InitializeComponent();
            numericUpDown1.MouseWheel += NumericUpDown1_MouseWheel;
        }

        private Form1 BaseForm;
        private bool _readyToUpdateTheme = false;
        private void SettingsForm_Load(object sender, EventArgs e)
        {
            if (this.Owner is Form1) BaseForm = (Form1)this.Owner;

            customSerializationFlagsBox.BeginUpdate();
            customSerializationFlagsBox.Items.Clear();
            List<CustomSerializationFlags> allFlags = Enum.GetValues(typeof(CustomSerializationFlags)).Cast<CustomSerializationFlags>().ToList();
            int entryIdx = 0;
            for (int i = 0; i < allFlags.Count; i++)
            {
                CustomSerializationFlags option = allFlags[i];
                if (option == 0) continue;

                customSerializationFlagsBox.Items.Add(option.ToString());
                customSerializationFlagsBox.SetItemChecked(entryIdx++, (UAGConfig.Data.CustomSerializationFlags & (int)option) > 0);
            }
            customSerializationFlagsBox.EndUpdate();

            themeComboBox.DataSource = Enum.GetValues(typeof(UAGTheme));
            themeComboBox.SelectedIndex = (int)UAGPalette.GetCurrentTheme();
            valuesOnScroll.Checked = UAGConfig.Data.ChangeValuesOnScroll;
            doubleClickToEdit.Checked = UAGConfig.Data.DoubleClickToEdit;
            enableDiscordRpc.Checked = UAGConfig.Data.EnableDiscordRPC;
            enableDynamicTree.Checked = UAGConfig.Data.EnableDynamicTree;
            favoriteThingBox.Text = UAGConfig.Data.FavoriteThing;
            numericUpDown1.Value = UAGConfig.Data.DataZoom;
            enableBak.Checked = UAGConfig.Data.EnableBak;
            enablePrettyBytecode.Checked = UAGConfig.Data.EnablePrettyBytecode;
            restoreSize.Checked = UAGConfig.Data.RestoreSize;
            enableUpdateNotice.Checked = UAGConfig.Data.EnableUpdateNotice;
            enableBakJson.Checked = UAGConfig.Data.EnableBakJson;
            allowUntrustedScriptsBox.Checked = UAGConfig.Data.AllowUntrustedScripts;

            UAGPalette.RefreshTheme(this);
            this.AdjustFormPosition();
            _readyToUpdateTheme = true;
        }

        private void closeButton_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        private void aboutButton_Click(object sender, EventArgs e)
        {
            var softwareAgeInYears = (int.Parse(DateTime.Now.ToString("yyyyMMdd")) - 20200723) / 10000;

            UAGUtils.InvokeUI(() =>
            {
                var formPopup = new AboutForm();

                formPopup.AboutText = (this.Owner as Form1).DisplayVersion + "\n" +
                "By atenfyr\n" +
                "\nThank you to trumank, LongerWarrior, Kaiheilos, and others for all your generous contributions to this software\n" +
                "\nThank you to the love of my life for listening to me and supporting me despite not caring at all about any of this\n" +
                "\nThank you for using this thing even after " + softwareAgeInYears + " years\n";

                formPopup.StartPosition = FormStartPosition.CenterParent;
                formPopup.ShowDialog(this);
            });
        }

        private void themeComboBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (!_readyToUpdateTheme) return;
            Enum.TryParse(themeComboBox.SelectedValue.ToString(), out UAGTheme nextTheme);
            UAGPalette.SetCurrentTheme(nextTheme);
            UAGPalette.RefreshTheme(BaseForm);
            UAGPalette.RefreshTheme(this);
        }

        private void valuesOnScroll_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.ChangeValuesOnScroll = valuesOnScroll.Checked;
        }

        private void enableDynamicTree_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.EnableDynamicTree = enableDynamicTree.Checked;
        }

        private void doubleClickToEdit_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.DoubleClickToEdit = doubleClickToEdit.Checked;
            //BaseForm.dataGridView1.EditMode = UAGConfig.Data.DoubleClickToEdit ? DataGridViewEditMode.EditProgrammatically : DataGridViewEditMode.EditOnEnter;
        }

        private void enableBak_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.EnableBak = enableBak.Checked;
        }

        private void restoreSize_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.RestoreSize = restoreSize.Checked;
        }

        private void enableUpdateNotice_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.EnableUpdateNotice = enableUpdateNotice.Checked;
        }

        private void enablePrettyBytecode_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.EnablePrettyBytecode = enablePrettyBytecode.Checked;
        }

        private void enableBakJson_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.EnableBakJson = enableBakJson.Checked;
        }

        private void allowUntrustedScriptsBox_CheckedChanged(object sender, EventArgs e)
        {
            if (allowUntrustedScriptsBox.Checked && !UAGConfig.Data.AllowUntrustedScripts)
            {
                DialogResult result = MessageBox.Show("Scripts in UAssetGUI can potentially execute malicious code and cause damage to your computer. Never execute any scripts that you do not fully trust.\n\nWould you like to continue?", BaseForm.DisplayVersion, MessageBoxButtons.OKCancel);
                if (result == DialogResult.OK)
                {
                    UAGConfig.Data.AllowUntrustedScripts = allowUntrustedScriptsBox.Checked;
                    UAGConfig.RefreshAllScriptIDs();
                }
                else
                {
                    UAGConfig.Data.AllowUntrustedScripts = false;
                    allowUntrustedScriptsBox.Checked = false;
                }

                return;
            }

            UAGConfig.Data.AllowUntrustedScripts = allowUntrustedScriptsBox.Checked;
            UAGConfig.RefreshAllScriptIDs();
        }

        private void enableDiscordRpc_CheckedChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.EnableDiscordRPC = enableDiscordRpc.Checked;
            if (UAGConfig.Data.EnableDiscordRPC)
            {
                BaseForm.UpdateRPC();
            }
            else
            {
                BaseForm.DiscordRPC.ClearPresence();
            }
        }

        private bool isCurrentlyComicSans = false;
        private void favoriteThingBox_TextChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.FavoriteThing = favoriteThingBox.Text;
            string favoriteThingLowered = UAGConfig.Data.FavoriteThing.ToLowerInvariant().Trim();

            if (UAGPalette.IsComicSans())
            {
                isCurrentlyComicSans = true;
                UAGPalette.RefreshTheme(BaseForm);
                UAGPalette.RefreshTheme(this);
            }
            else if (isCurrentlyComicSans)
            {
                isCurrentlyComicSans = false;
                UAGPalette.RefreshTheme(BaseForm);
                UAGPalette.RefreshTheme(this);
            }

            if (favoriteThingLowered == "atenfyr" || favoriteThingLowered == "adolescent")
            {
                // need MemoryStream to remain open until we're done using the image
                // no need to dispose MemoryStream so let's just let GC handle it once image stops being used
                var strm = new MemoryStream(Properties.Resources.dancing_cat);
                this.pictureBox1.Image = Image.FromStream(strm);
                this.pictureBox1.Visible = true;
            }
            else
            {
                this.pictureBox1.Visible = false;
            }
        }

        private void SettingsForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            UAGConfig.Save();
            UAGPalette.RefreshTheme(BaseForm);
            UAGPalette.RefreshTheme(this);
        }

        private void numericUpDown1_ValueChanged(object sender, EventArgs e)
        {
            UAGConfig.Data.DataZoom = (int)numericUpDown1.Value;
            UAGPalette.RefreshTheme(BaseForm);
            UAGPalette.RefreshTheme(this);

            // Refresh dgv row heights
            UAGUtils.InvokeUI(() =>
            {
                if (BaseForm.tableEditor != null)
                {
                    BaseForm.tableEditor.Save(true);
                }
            });
        }

        private void customSerializationFlagsBox_Click(object sender, EventArgs e)
        {
            // this logic is here to prevent default list box selection logic

            // The following block of code is modified and adapted from source code on StackOverflow created and licensed by user Hath, copyright 2008: https://stackoverflow.com/a/334672
            // The original code is adapted for usage in this software under the terms of the CC BY-SA 2.5 license: https://creativecommons.org/licenses/by-sa/2.5/
            /*
                UNLESS OTHERWISE AGREED TO BY THE PARTIES IN WRITING, LICENSOR OFFERS THE
                WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND
                CONCERNING THE MATERIALS, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
                INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS
                FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT
                OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR
                NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED
                WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
            */
            for (int i = 0; i < customSerializationFlagsBox.Items.Count; i++)
            {
                if (customSerializationFlagsBox.GetItemRectangle(i).Contains(customSerializationFlagsBox.PointToClient(MousePosition)))
                {
                    customSerializationFlagsBox.SetItemChecked(i, !customSerializationFlagsBox.GetItemChecked(i));
                }
            }

            // update config
            CustomSerializationFlags res = 0;
            for (int i = 0; i < customSerializationFlagsBox.Items.Count; i++)
            {
                string item = customSerializationFlagsBox.Items[i] as string;
                if (item == null) continue;
                if (customSerializationFlagsBox.GetItemChecked(i))
                {
                    res |= Enum.Parse<CustomSerializationFlags>(item);
                }
            }

            UAGConfig.Data.CustomSerializationFlags = (int)res;
        }

        private void NumericUpDown1_MouseWheel(object sender, MouseEventArgs e)
        {
            // override default scroll logic to prevent weird +3 problem
            if (e.Delta == 0) return;
            ((HandledMouseEventArgs)e).Handled = true;

            UAGUtils.InvokeUI(() =>
            {
                decimal newValue = numericUpDown1.Value + (e.Delta > 0 ? 1 : -1);
                if (newValue < numericUpDown1.Minimum) newValue = numericUpDown1.Minimum;
                if (newValue > numericUpDown1.Maximum) newValue = numericUpDown1.Maximum;
                numericUpDown1.Value = newValue;
            });
        }
    }
}

```

`UAssetGUI/SettingsForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UAssetGUI/TableHandler.cs`:

```cs
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Windows.Forms;
using UAssetAPI;
using UAssetAPI.CustomVersions;
using UAssetAPI.ExportTypes;
using UAssetAPI.Kismet.Bytecode;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.UnrealTypes;
using static UAssetAPI.Kismet.KismetSerializer;

namespace UAssetGUI
{
    public enum TableHandlerMode
    {
        None = -1,
        GeneralInformation,
        NameMap,
        SoftObjectPathList,
        Imports,
        ExportInformation,
        SoftPackageReferences,
        DependsMap,
        WorldTileInfo,
        DataResources,
        CustomVersionContainer,
        ExportData
    }

    public enum ExportDetailsParseType
    {
        None = -1,
        Int,
        FPackageIndex,
        FName,
        EObjectFlags,
        Long,
        Bool,
        Guid,
        UInt,
        FPackageIndexList
    }

    public enum PointingTreeNodeType
    {
        Normal,
        StructData,
        ClassData,
        EnumData,
        UPropertyData,
        ByteArray,
        Dummy,
        UserDefinedStructData,
        Kismet,
        KismetByteArray
    }

    public class PointingTreeNode : TreeNode
    {
        public object Pointer;
        public PointingTreeNodeType Type;
        public int ExportNum;
        public bool WillCopyWholeExport;

        private bool _childrenInitialized = false;
        public bool ChildrenInitialized
        {
            get
            {
                return _childrenInitialized;
            }
            set
            {
                if (UAGConfig.Data.EnableDynamicTree && Type != PointingTreeNodeType.Dummy && !_childrenInitialized && value && this.Nodes.Count > 0 && this.Nodes[0] is PointingTreeNode m && m.Type == PointingTreeNodeType.Dummy) this.Nodes.RemoveAt(0);
                _childrenInitialized = value;
            }
        }

        public PointingTreeNode(string label, object pointer, PointingTreeNodeType type = 0, int exportNum = -1, bool willCopyWholeExport = false)
        {
            Pointer = pointer;
            Type = type;
            this.Text = label;
            ExportNum = exportNum;
            WillCopyWholeExport = willCopyWholeExport;

            if (UAGConfig.Data.EnableDynamicTree && Type != PointingTreeNodeType.Dummy && pointer != null)
            {
                this.Nodes.Clear();
                this.Nodes.Add(new PointingTreeNode("", null, PointingTreeNodeType.Dummy, -1, false));
            }
        }
    }

    public class ExportPointingTreeNode : PointingTreeNode
    {
        public string ObjectName;

        public ExportPointingTreeNode(string objectName, object pointer, PointingTreeNodeType type = 0, int exportNum = -1, bool willCopyWholeExport = false)
            : base("Export " + (exportNum + 1) + " (" + objectName + ")", pointer, type, exportNum, willCopyWholeExport)
        {
            ObjectName = objectName;

            ToolStripMenuItem tsmItem = new ToolStripMenuItem("Copy object name");
            tsmItem.Click += (sender, args) => Clipboard.SetText(ObjectName);
            this.ContextMenuStrip = new ContextMenuStrip();
            this.ContextMenuStrip.Items.Add(tsmItem);
        }
    }

    public class PointingDictionaryEntry
    {
        public KeyValuePair<PropertyData, PropertyData> Entry;
        public object Pointer;

        public PointingDictionaryEntry(KeyValuePair<PropertyData, PropertyData> entry, object pointer)
        {
            Entry = entry;
            Pointer = pointer;
        }
    }

    public class TableHandler
    {
        public TableHandlerMode mode;
        public UAsset asset;
        public TreeView treeView1;
        public DataGridView dataGridView1;
        public TextBox jsonView;
        public FileContainerForm ParentContainer;

        public bool readyToSave = true;
        public bool dirtySinceLastLoad = false; 

        public static Color ARGBtoRGB(Color ARGB)
        {
            double alpha = ARGB.A / 255.0;
            return Color.FromArgb(
                255,
                (int)((ARGB.R * alpha) + (255 * (1 - alpha))),
                (int)((ARGB.G * alpha) + (255 * (1 - alpha))),
                (int)((ARGB.B * alpha) + (255 * (1 - alpha)))
            );
        }

        public void FillOutSubnodes(PointingTreeNode topNode, bool fillAllSubNodes)
        {
            if (topNode.ChildrenInitialized) return;

            topNode.ChildrenInitialized = true;
            if (topNode.Pointer is NormalExport me1)
            {
                for (int j = 0; j < me1.Data.Count; j++) InterpretThing(me1.Data[j], topNode, topNode.ExportNum, fillAllSubNodes);
            }
            else if (topNode.Pointer is PropertyData me)
            {
                switch (me.PropertyType.Value)
                {
                    case "StructProperty":
                    case "ClothLODData":
                        var struc = (StructPropertyData)me;
                        for (int j = 0; j < struc.Value.Count; j++)
                        {
                            InterpretThing(struc.Value[j], topNode, topNode.ExportNum, fillAllSubNodes);
                        }
                        break;
                    case "SetProperty":
                    case "ArrayProperty":
                        var arr = (ArrayPropertyData)me;

                        for (int j = 0; j < arr.Value.Length; j++)
                        {
                            InterpretThing(arr.Value[j], topNode, topNode.ExportNum, fillAllSubNodes);
                        }
                        break;
                    case "MapProperty":
                        var mapp = (MapPropertyData)me;

                        foreach (var entry in mapp.Value)
                        {
                            entry.Key.Name = FName.DefineDummy(asset, "Key");
                            entry.Value.Name = FName.DefineDummy(asset, "Value");

                            var softEntryNode = new PointingTreeNode(mapp.Name.Value.Value + " (2)", new PointingDictionaryEntry(entry, mapp), 0, topNode.ExportNum);
                            topNode.Nodes.Add(softEntryNode);
                            InterpretThing(entry.Key, softEntryNode, topNode.ExportNum, fillAllSubNodes);
                            InterpretThing(entry.Value, softEntryNode, topNode.ExportNum, fillAllSubNodes);
                        }
                        break;
                    case "NiagaraVariableBase":
                    case "NiagaraVariable":
                    case "NiagaraVariableWithOffset":
                        InterpretThing(((NiagaraVariableBasePropertyData)me).TypeDef, topNode, topNode.ExportNum, fillAllSubNodes);
                        break;
                }
            }
        }

        public void FillOutTree(bool fillAllSubNodes)
        {
            int numDependsInts = 0;
            if (asset.DependsMap != null)
            {
                foreach (var entry in asset.DependsMap) numDependsInts += entry.Length;
            }
            // if numDependsInts == 0, then it's really just unused

            treeView1.BeginUpdate();
            treeView1.Nodes.Clear();
            treeView1.BackColor = UAGPalette.BackColor;
            treeView1.Nodes.Add(new PointingTreeNode("General Information", null));
            if (asset.SoftObjectPathList != null && (asset.SoftObjectPathList.Count > 0 || !asset.IsFilterEditorOnly)) treeView1.Nodes.Add(new PointingTreeNode("Soft Object Paths", null));
            treeView1.Nodes.Add(new PointingTreeNode("Name Map", null));
            treeView1.Nodes.Add(new PointingTreeNode("Import Data", null));
            treeView1.Nodes.Add(new PointingTreeNode("Export Information", null));
            if (numDependsInts != 0) treeView1.Nodes.Add(new PointingTreeNode("Depends Map", null));
            if (asset.SoftPackageReferenceList != null) treeView1.Nodes.Add(new PointingTreeNode("Soft Package References", null));
            if (asset.WorldTileInfo != null)
            {
                treeView1.Nodes.Add(new PointingTreeNode("World Tile Info", null));
                PointingTreeNode worldInfoNode = (PointingTreeNode)treeView1.Nodes[treeView1.Nodes.Count - 1];
                worldInfoNode.Nodes.Add(new PointingTreeNode("Layer (5)", asset.WorldTileInfo.Layer));
                worldInfoNode.Nodes.Add(new PointingTreeNode("LODList (" + asset.WorldTileInfo.LODList.Length + ")", asset.WorldTileInfo.LODList));
                PointingTreeNode lodListNode = (PointingTreeNode)treeView1.Nodes[treeView1.Nodes.Count - 1];
                for (int i = 0; i < asset.WorldTileInfo.LODList.Length; i++)
                {
                    lodListNode.Nodes.Add(new PointingTreeNode("LOD entry #" + (i + 1), asset.WorldTileInfo.LODList[i]));
                }
            }
            if (asset.ObjectVersionUE5 >= ObjectVersionUE5.DATA_RESOURCES) treeView1.Nodes.Add(new PointingTreeNode("Data Resources", null));
            treeView1.Nodes.Add(new PointingTreeNode("Custom Version Container", null));
            treeView1.Nodes.Add(new PointingTreeNode("Export Data", null));

            PointingTreeNode superTopNode = (PointingTreeNode)treeView1.Nodes[treeView1.Nodes.Count - 1];
            for (int i = 0; i < asset.Exports.Count; i++)
            {
                Export baseUs = asset.Exports[i];
                var categoryNode = new ExportPointingTreeNode(baseUs.ObjectName.Value.Value, null, 0, i, true);
                superTopNode.Nodes.Add(categoryNode);
                switch (baseUs)
                {
                    case RawExport us3:
                        {
                            var parentNode = new PointingTreeNode("Raw Data (" + us3.Data.Length + " B)", us3, PointingTreeNodeType.ByteArray, i);
                            parentNode.ChildrenInitialized = true;
                            categoryNode.Nodes.Add(parentNode);
                            break;
                        }
                    case NormalExport us:
                        {
                            var parentNode = new PointingTreeNode((baseUs.ClassIndex.IsImport() ? baseUs.ClassIndex.ToImport(asset).ObjectName.Value.Value : baseUs.ClassIndex.Index.ToString()) + " (" + us.Data.Count + ")", us, 0, i);
                            categoryNode.Nodes.Add(parentNode);

                            if (fillAllSubNodes)
                            {
                                for (int j = 0; j < us.Data.Count; j++) InterpretThing(us.Data[j], parentNode, i, fillAllSubNodes);
                            }

                            bool hasChildren = false;
                            for (int j = 0; j < us.Data.Count; j++)
                            {
                                if (hasChildrenProperties.Contains(us.Data[j].PropertyType.Value))
                                {
                                    hasChildren = true;
                                    break;
                                }
                            }
                            if (!hasChildren) parentNode.ChildrenInitialized = true;

                            if (us is StringTableExport us2)
                            {
                                var parentNode2 = new PointingTreeNode((us2.Table?.TableNamespace?.ToString() ?? FString.NullCase) + " (" + us2.Table.Count + ")", us2.Table, 0, i);
                                parentNode2.ChildrenInitialized = true;
                                categoryNode.Nodes.Add(parentNode2);
                            }

                            if (us is StructExport structUs)
                            {
                                var parentNode2 = new PointingTreeNode("UStruct Data", structUs, PointingTreeNodeType.StructData, i);
                                parentNode2.ChildrenInitialized = true;
                                categoryNode.Nodes.Add(parentNode2);
                                if (structUs.ScriptBytecode == null)
                                {
                                    var bytecodeNode = new PointingTreeNode("ScriptBytecode (" + structUs.ScriptBytecodeRaw.Length + " B)", structUs, PointingTreeNodeType.KismetByteArray, i);
                                    bytecodeNode.ChildrenInitialized = true;
                                    parentNode2.Nodes.Add(bytecodeNode);
                                }
                                else
                                {
                                    var bytecodeNode = new PointingTreeNode("ScriptBytecode (" + structUs.ScriptBytecode.Length + " instructions)", structUs, PointingTreeNodeType.Kismet, i);
                                    bytecodeNode.ChildrenInitialized = true;
                                    parentNode2.Nodes.Add(bytecodeNode);
                                }
                            }

                            if (us is UserDefinedStructExport us6)
                            {
                                var parentNode2 = new PointingTreeNode("UserDefinedStruct Data (" + us6.StructData.Count + ")", us, PointingTreeNodeType.UserDefinedStructData, i);
                                parentNode2.ChildrenInitialized = true;
                                categoryNode.Nodes.Add(parentNode2);

                                for (int j = 0; j < us6.StructData.Count; j++) InterpretThing(us6.StructData[j], parentNode2, i, fillAllSubNodes);
                            }

                            if (us is ClassExport)
                            {
                                var parentNode2 = new PointingTreeNode("UClass Data", (ClassExport)us, PointingTreeNodeType.ClassData, i);
                                parentNode2.ChildrenInitialized = true;
                                categoryNode.Nodes.Add(parentNode2);
                            }

                            if (us is PropertyExport)
                            {
                                var parentNode2 = new PointingTreeNode("UProperty Data", (PropertyExport)us, PointingTreeNodeType.UPropertyData, i);
                                parentNode2.ChildrenInitialized = true;
                                categoryNode.Nodes.Add(parentNode2);
                            }

                            if (us is DataTableExport us4)
                            {
                                var parentNode2 = new PointingTreeNode("Table Info (" + us4.Table.Data.Count + ")", us4.Table, 0, i);
                                parentNode2.ChildrenInitialized = true;
                                categoryNode.Nodes.Add(parentNode2);
                                foreach (StructPropertyData entry in us4.Table.Data)
                                {
                                    string decidedName = entry.Name.Value.Value;

                                    var structNode = new PointingTreeNode(decidedName + " (" + entry.Value.Count + ")", entry, 0, i);
                                    parentNode2.Nodes.Add(structNode);
                                    if (fillAllSubNodes)
                                    {
                                        for (int j = 0; j < entry.Value.Count; j++)
                                        {
                                            InterpretThing(entry.Value[j], structNode, i, fillAllSubNodes);
                                        }
                                    }
                                }
                            }

                            if (us is EnumExport us5)
                            {
                                var parentNode2 = new PointingTreeNode("Enum Data", us5, PointingTreeNodeType.EnumData, i);
                                parentNode2.ChildrenInitialized = true;
                                categoryNode.Nodes.Add(parentNode2);
                            }

                            {
                                var parentNode3 = new PointingTreeNode("Extra Data (" + us.Extras.Length + " B)", us, PointingTreeNodeType.ByteArray, i);
                                parentNode3.ChildrenInitialized = true;
                                categoryNode.Nodes.Add(parentNode3);
                            }

                            break;
                        }
                }
            }

            treeView1.SelectedNode = treeView1.Nodes[0];
            treeView1.EndUpdate();
        }

        private HashSet<string> hasChildrenProperties = new HashSet<string>()
        {
            "StructProperty",
            "ClothLODData",
            "SetProperty",
            "ArrayProperty",
            "GameplayTagContainer",
            "MapProperty",
            "MulticastDelegateProperty",
            "Box",
            "Box2D",
            "Box2f",
            "NiagaraVariableBase",
            "NiagaraVariable",
            "NiagaraVariableWithOffset"
        };

        private void InterpretThing(PropertyData me, PointingTreeNode ourNode, int exportNum, bool fillAllSubNodes)
        {
            ourNode.ChildrenInitialized = true;
            if (me == null) return;
            switch (me.PropertyType.Value)
            {
                case "StructProperty":
                case "ClothLODData":
                    var struc = (StructPropertyData)me;

                    string decidedName = struc.Name.Value.Value;
                    if (ourNode.Pointer is PropertyData && ((PropertyData)ourNode.Pointer).Name.Equals(decidedName)) decidedName = struc.StructType.Value.Value;

                    var structNode = new PointingTreeNode(decidedName + " (" + struc.Value.Count + ")", struc, 0, exportNum);
                    ourNode.Nodes.Add(structNode);

                    bool hasChildren = false;
                    if (fillAllSubNodes)
                    {
                        for (int j = 0; j < struc.Value.Count; j++)
                        {
                            InterpretThing(struc.Value[j], structNode, exportNum, fillAllSubNodes);
                        }
                    }
                    else
                    {
                        // check if there is children
                        for (int j = 0; j < struc.Value.Count; j++)
                        {
                            if (hasChildrenProperties.Contains(struc.Value[j].PropertyType.Value))
                            {
                                hasChildren = true;
                                break;
                            }
                        }
                    }

                    if (!hasChildren) structNode.ChildrenInitialized = true;
                    break;
                case "SetProperty":
                case "ArrayProperty":
                    var arr = (ArrayPropertyData)me;

                    var arrNode = new PointingTreeNode(arr.Name.Value.Value + " (" + arr.Value.Length + ")", arr, 0, exportNum);
                    ourNode.Nodes.Add(arrNode);

                    bool hasChildren2 = false;
                    if (fillAllSubNodes)
                    {
                        for (int j = 0; j < arr.Value.Length; j++)
                        {
                            InterpretThing(arr.Value[j], arrNode, exportNum, fillAllSubNodes);
                        }
                    }
                    else
                    {
                        // check if there is children
                        for (int j = 0; j < arr.Value.Length; j++)
                        {
                            if (hasChildrenProperties.Contains(arr.Value[j].PropertyType.Value))
                            {
                                hasChildren2 = true;
                                break;
                            }
                        }
                    }

                    if (!hasChildren2) arrNode.ChildrenInitialized = true;
                    break;
                case "GameplayTagContainer":
                    var arr2 = (GameplayTagContainerPropertyData)me;

                    var arrNode2 = new PointingTreeNode(arr2.Name.Value.Value + " (" + arr2.Value.Length + ")", arr2, 0, exportNum);
                    ourNode.Nodes.Add(arrNode2);
                    break;
                case "MapProperty":
                    var mapp = (MapPropertyData)me;

                    var mapNode = new PointingTreeNode(mapp.Name.Value.Value + " (" + mapp.Value.Keys.Count + ")", mapp, 0, exportNum);
                    ourNode.Nodes.Add(mapNode);

                    foreach (var entry in mapp.Value)
                    {
                        entry.Key.Name = FName.DefineDummy(asset, "Key");
                        entry.Value.Name = FName.DefineDummy(asset, "Value");

                        var softEntryNode = new PointingTreeNode(mapp.Name.Value.Value + " (2)", new PointingDictionaryEntry(entry, mapp), 0, exportNum);
                        mapNode.Nodes.Add(softEntryNode);
                        InterpretThing(entry.Key, softEntryNode, exportNum, fillAllSubNodes);
                        InterpretThing(entry.Value, softEntryNode, exportNum, fillAllSubNodes);
                    }

                    mapNode.ChildrenInitialized = true;
                    break;
                case "MulticastDelegateProperty":
                    var mdp = (MulticastDelegatePropertyData)me;

                    ourNode.Nodes.Add(new PointingTreeNode(mdp.Name.Value.Value + " (" + mdp.Value.Length + ")", mdp.Value, 0, exportNum));
                    break;
                case "Box":
                    {
                        var box = (BoxPropertyData)me;

                        ourNode.Nodes.Add(new PointingTreeNode(box.Name.Value.Value + " (2)", box, 0, exportNum));
                    }
                    break;
                case "Box2D":
                    {
                        var box = (Box2DPropertyData)me;

                        ourNode.Nodes.Add(new PointingTreeNode(box.Name.Value.Value + " (2)", box, 0, exportNum));
                    }
                    break;
                case "Box2f":
                    {
                        var box = (Box2fPropertyData)me;

                        ourNode.Nodes.Add(new PointingTreeNode(box.Name.Value.Value + " (2)", box, 0, exportNum));
                    }
                    break;
                case "NiagaraVariableBase":
                case "NiagaraVariable":
                case "NiagaraVariableWithOffset":
                    InterpretThing(((NiagaraVariableBasePropertyData)me).TypeDef, ourNode, exportNum, fillAllSubNodes);
                    break;
            }
        }

        private void AddRowsForArray(PropertyData[] arr)
        {
            if (arr.Length == 0) return;

            List<DataGridViewRow> rows = new List<DataGridViewRow>();
            for (int i = 0; i < arr.Length; i++)
            {
                PropertyData thisPD = arr[i];
                if (thisPD == null) continue;

                //try
                {
                    int columnIndexer = -1;
                    int absoluteColumnIndexer = columnIndexer;
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(dataGridView1);
                    row.Cells[++columnIndexer].Value = thisPD.Name.ToString();
                    row.Cells[++columnIndexer].Value = thisPD.PropertyType.ToString();
                    if (thisPD is UnknownPropertyData)
                    {
                        row.Cells[columnIndexer].Value = ((UnknownPropertyData)thisPD).SerializingPropertyType.ToString();
                        row.Cells[++columnIndexer].Value = "Unknown ser.";
                        row.Cells[++columnIndexer].Value = ((UnknownPropertyData)thisPD).Value.ConvertByteArrayToString();
                    }
                    else
                    {
                        switch (thisPD.PropertyType.Value)
                        {
                            case "BoolProperty":
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = ((BoolPropertyData)thisPD).Value.ToString();
                                break;
                            case "FloatProperty":
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = ((FloatPropertyData)thisPD).Value.ToString();
                                break;
                            case "DoubleProperty":
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = ((DoublePropertyData)thisPD).Value.ToString();
                                break;
                            case "FrameNumber":
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = ((FrameNumberPropertyData)thisPD).Value.Value.ToString();
                                break;
                            case "ObjectProperty":
                                var objData = (ObjectPropertyData)thisPD;
                                int decidedIndex = objData.Value?.Index ?? 0;
                                row.Cells[++columnIndexer].Value = decidedIndex;
                                if (decidedIndex != 0) UAGUtils.UpdateObjectPropertyValues(asset, row, dataGridView1, objData.Value);
                                break;
                            case "SoftObjectProperty":
                                var objData2 = (SoftObjectPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = objData2.Value.AssetPath.PackageName == null ? FString.NullCase : objData2.Value.AssetPath.PackageName.ToString();
                                row.Cells[columnIndexer].ToolTipText = "AssetPath.PackageName";
                                row.Cells[++columnIndexer].Value = objData2.Value.AssetPath.AssetName == null ? FString.NullCase : objData2.Value.AssetPath.AssetName.ToString();
                                row.Cells[columnIndexer].ToolTipText = "AssetPath.AssetName";
                                row.Cells[++columnIndexer].Value = objData2.Value.SubPathString == null ? FString.NullCase : objData2.Value.SubPathString.ToString();
                                row.Cells[columnIndexer].ToolTipText = "SubPathString";
                                break;
                            case "RichCurveKey":
                                var curveData = (RichCurveKeyPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = curveData.Value.InterpMode;
                                row.Cells[++columnIndexer].Value = curveData.Value.TangentMode;
                                row.Cells[++columnIndexer].Value = curveData.Value.Time;
                                row.Cells[++columnIndexer].Value = curveData.Value.Value;
                                row.Cells[++columnIndexer].Value = curveData.Value.ArriveTangent;
                                row.Cells[++columnIndexer].Value = curveData.Value.LeaveTangent;
                                break;
                            case "TextProperty":
                                var txtData = (TextPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = txtData.HistoryType.ToString();
                                row.Cells[columnIndexer].ToolTipText = "HistoryType";
                                switch (txtData.HistoryType)
                                {
                                    case TextHistoryType.None:
                                        row.Cells[++columnIndexer].Value = txtData?.CultureInvariantString == null ? FString.NullCase : txtData.CultureInvariantString.ToString();
                                        row.Cells[columnIndexer].ToolTipText = "CultureInvariantString";
                                        break;
                                    case TextHistoryType.Base:
                                        row.Cells[++columnIndexer].Value = txtData?.Namespace == null ? FString.NullCase : txtData.Namespace.ToString();
                                        row.Cells[columnIndexer].ToolTipText = "Namespace";
                                        row.Cells[++columnIndexer].Value = txtData?.Value == null ? FString.NullCase : txtData.Value.ToString();
                                        row.Cells[columnIndexer].ToolTipText = "Key";
                                        row.Cells[++columnIndexer].Value = txtData?.CultureInvariantString == null ? FString.NullCase : txtData.CultureInvariantString.ToString();
                                        row.Cells[columnIndexer].ToolTipText = "CultureInvariantString";
                                        break;
                                    case TextHistoryType.StringTableEntry:
                                        row.Cells[++columnIndexer].Value = txtData?.TableId == null ? FString.NullCase : txtData.TableId.ToString();
                                        row.Cells[columnIndexer].ToolTipText = "TableId";
                                        row.Cells[++columnIndexer].Value = txtData?.Value == null ? FString.NullCase : txtData.Value.ToString();
                                        row.Cells[columnIndexer].ToolTipText = "Key";
                                        break;
                                    case TextHistoryType.RawText:
                                        row.Cells[++columnIndexer].Value = txtData?.Value == null ? FString.NullCase : txtData.Value.ToString();
                                        row.Cells[columnIndexer].ToolTipText = "Value";
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            case "NameProperty":
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = ((NamePropertyData)thisPD).ToString();
                                break;
                            case "ViewTargetBlendParams":
                                var viewTargetBlendParamsData = (ViewTargetBlendParamsPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = viewTargetBlendParamsData.BlendTime;
                                row.Cells[++columnIndexer].Value = viewTargetBlendParamsData.BlendFunction;
                                row.Cells[++columnIndexer].Value = viewTargetBlendParamsData.BlendExp;
                                row.Cells[++columnIndexer].Value = viewTargetBlendParamsData.bLockOutgoing;
                                break;
                            case "EnumProperty":
                                var enumData = (EnumPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = enumData.EnumType?.Value?.Value == null ? FString.NullCase : enumData.EnumType.ToString();
                                row.Cells[++columnIndexer].Value = enumData.Value?.Value?.Value == null ? FString.NullCase : enumData.Value.ToString();
                                //row.Cells[5].Value = enumData.Extra;
                                break;
                            case "ByteProperty":
                                var byteData = (BytePropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = byteData.GetEnumBase()?.Value.Value == null ? FString.NullCase : byteData.GetEnumBase()?.Value.Value;
                                if (byteData.ByteType == BytePropertyType.Byte)
                                {
                                    row.Cells[++columnIndexer].Value = byteData.Value;
                                }
                                else
                                {
                                    row.Cells[++columnIndexer].Value = byteData.GetEnumFull()?.Value.Value == null ? FString.NullCase : byteData.GetEnumFull()?.Value.Value;
                                }
                                break;
                            case "StructProperty":
                            case "ClothLODData":
                                row.Cells[++columnIndexer].Value = ((StructPropertyData)thisPD).StructType?.ToString() ?? FString.NullCase;
                                break;
                            case "ArrayProperty":
                            case "SetProperty":
                                row.Cells[++columnIndexer].Value = ((ArrayPropertyData)thisPD).ArrayType?.ToString() ?? FString.NullCase;
                                break;
                            case "GameplayTagContainer":
                            case "MapProperty":
                            case "SkeletalMeshSamplingLODBuiltData":
                                break;
                            case "Box":
                            case "Box2D":
                            case "Box2f":
                                row.Cells[++columnIndexer].Value = string.Empty;
                                break;
                            case "MulticastDelegateProperty":
                                var mdpData = (MulticastDelegatePropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                break;
                            case "LinearColor":
                                var colorData = (LinearColorPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[columnIndexer].ReadOnly = true;
                                if (colorData.RawValue != null)
                                {
                                    row.Cells[columnIndexer].Style.BackColor = ARGBtoRGB(LinearHelpers.Convert(colorData.Value));
                                    row.Cells[columnIndexer].ToolTipText = "Preview";
                                }
                                row.Cells[++columnIndexer].Value = colorData.Value.R;
                                row.Cells[columnIndexer].ToolTipText = "Red";
                                row.Cells[++columnIndexer].Value = colorData.Value.G;
                                row.Cells[columnIndexer].ToolTipText = "Green";
                                row.Cells[++columnIndexer].Value = colorData.Value.B;
                                row.Cells[columnIndexer].ToolTipText = "Blue";
                                row.Cells[++columnIndexer].Value = colorData.Value.A;
                                row.Cells[columnIndexer].ToolTipText = "Alpha";
                                break;
                            case "Color":
                                var colorData2 = (ColorPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[columnIndexer].ReadOnly = true;
                                if (colorData2.RawValue != null)
                                {
                                    row.Cells[columnIndexer].Style.BackColor = colorData2.Value;
                                    row.Cells[columnIndexer].ToolTipText = "Preview";
                                }
                                row.Cells[++columnIndexer].Value = colorData2.Value.R;
                                row.Cells[columnIndexer].ToolTipText = "Red";
                                row.Cells[++columnIndexer].Value = colorData2.Value.G;
                                row.Cells[columnIndexer].ToolTipText = "Green";
                                row.Cells[++columnIndexer].Value = colorData2.Value.B;
                                row.Cells[columnIndexer].ToolTipText = "Blue";
                                row.Cells[++columnIndexer].Value = colorData2.Value.A;
                                row.Cells[columnIndexer].ToolTipText = "Alpha";
                                break;
                            case "Vector":
                                var vectorData = (VectorPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = vectorData.Value.X;
                                row.Cells[columnIndexer].ToolTipText = "X";
                                row.Cells[++columnIndexer].Value = vectorData.Value.Y;
                                row.Cells[columnIndexer].ToolTipText = "Y";
                                row.Cells[++columnIndexer].Value = vectorData.Value.Z;
                                row.Cells[columnIndexer].ToolTipText = "Z";
                                break;
                            case "Vector2D":
                                var vector2DData = (Vector2DPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = vector2DData.Value.X;
                                row.Cells[columnIndexer].ToolTipText = "X";
                                row.Cells[++columnIndexer].Value = vector2DData.Value.Y;
                                row.Cells[columnIndexer].ToolTipText = "Y";
                                break;
                            case "Vector4":
                                var vector4DData = (Vector4PropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = vector4DData.Value.X;
                                row.Cells[columnIndexer].ToolTipText = "X";
                                row.Cells[++columnIndexer].Value = vector4DData.Value.Y;
                                row.Cells[columnIndexer].ToolTipText = "Y";
                                row.Cells[++columnIndexer].Value = vector4DData.Value.Z;
                                row.Cells[columnIndexer].ToolTipText = "Z";
                                row.Cells[++columnIndexer].Value = vector4DData.Value.W;
                                row.Cells[columnIndexer].ToolTipText = "W";
                                break;
                            case "Plane":
                                var planeData = (PlanePropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = planeData.Value.X;
                                row.Cells[columnIndexer].ToolTipText = "X (Xx)";
                                row.Cells[++columnIndexer].Value = planeData.Value.Y;
                                row.Cells[columnIndexer].ToolTipText = "Y (+Yy)";
                                row.Cells[++columnIndexer].Value = planeData.Value.Z;
                                row.Cells[columnIndexer].ToolTipText = "Z (+Zz)";
                                row.Cells[++columnIndexer].Value = planeData.Value.W;
                                row.Cells[columnIndexer].ToolTipText = "W (= W)";
                                break;
                            case "IntPoint":
                                var intPointData = (IntPointPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = intPointData.Value[0];
                                row.Cells[++columnIndexer].Value = intPointData.Value[1];
                                break;
                            case "IntVector2":
                                var intVector2Data = (IntVector2PropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = intVector2Data.Value.X;
                                row.Cells[columnIndexer].ToolTipText = "X";
                                row.Cells[++columnIndexer].Value = intVector2Data.Value.Y;
                                row.Cells[columnIndexer].ToolTipText = "Y";
                                break;
                            case "IntVector":
                                var intVectorData = (IntVectorPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = intVectorData.Value.X;
                                row.Cells[columnIndexer].ToolTipText = "X";
                                row.Cells[++columnIndexer].Value = intVectorData.Value.Y;
                                row.Cells[columnIndexer].ToolTipText = "Y";
                                row.Cells[++columnIndexer].Value = intVectorData.Value.Z;
                                row.Cells[columnIndexer].ToolTipText = "Z";
                                break;
                            case "FloatRange":
                                var floatRangeData = (FloatRangePropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = floatRangeData.LowerBound;
                                row.Cells[columnIndexer].ToolTipText = "LowerBound";
                                row.Cells[++columnIndexer].Value = floatRangeData.UpperBound;
                                row.Cells[columnIndexer].ToolTipText = "UpperBound";
                                break;
                            case "Guid":
                                var guidData = (GuidPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = guidData.Value.ConvertToString();
                                break;
                            case "Rotator":
                                var rotatorData = (RotatorPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = rotatorData.Value.Roll;
                                row.Cells[columnIndexer].ToolTipText = "Roll (X)";
                                row.Cells[++columnIndexer].Value = rotatorData.Value.Pitch;
                                row.Cells[columnIndexer].ToolTipText = "Pitch (Y)";
                                row.Cells[++columnIndexer].Value = rotatorData.Value.Yaw;
                                row.Cells[columnIndexer].ToolTipText = "Yaw (Z)";
                                break;
                            case "Quat":
                                var quatData = (QuatPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = quatData.Value.X;
                                row.Cells[columnIndexer].ToolTipText = "X";
                                row.Cells[++columnIndexer].Value = quatData.Value.Y;
                                row.Cells[columnIndexer].ToolTipText = "Y";
                                row.Cells[++columnIndexer].Value = quatData.Value.Z;
                                row.Cells[columnIndexer].ToolTipText = "Z";
                                row.Cells[++columnIndexer].Value = quatData.Value.W;
                                row.Cells[columnIndexer].ToolTipText = "W";
                                break;
                            case "PerPlatformBool":
                                {
                                    var PerPlatformData = (PerPlatformBoolPropertyData)thisPD;
                                    row.Cells[++columnIndexer].Value = string.Empty;
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 0 ? PerPlatformData.Value[0].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[0]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 1 ? PerPlatformData.Value[1].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[1]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 2 ? PerPlatformData.Value[2].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[2]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 3 ? PerPlatformData.Value[3].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[3]";
                                }
                                break;
                            case "PerPlatformInt":
                                {
                                    var PerPlatformData = (PerPlatformIntPropertyData)thisPD;
                                    row.Cells[++columnIndexer].Value = string.Empty;
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 0 ? PerPlatformData.Value[0].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[0]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 1 ? PerPlatformData.Value[1].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[1]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 2 ? PerPlatformData.Value[2].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[2]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 3 ? PerPlatformData.Value[3].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[3]";
                                }
                                break;
                            case "PerPlatformFloat":
                                {
                                    var PerPlatformData = (PerPlatformFloatPropertyData)thisPD;
                                    row.Cells[++columnIndexer].Value = string.Empty;
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 0 ? PerPlatformData.Value[0].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[0]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 1 ? PerPlatformData.Value[1].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[1]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 2 ? PerPlatformData.Value[2].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[2]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 3 ? PerPlatformData.Value[3].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[3]";
                                }
                                break;
                            case "PerPlatformFrameRate":
                                {
                                    var PerPlatformData = (PerPlatformFrameRatePropertyData)thisPD;
                                    row.Cells[++columnIndexer].Value = string.Empty;
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 0 ? PerPlatformData.Value[0].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[0]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 1 ? PerPlatformData.Value[1].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[1]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 2 ? PerPlatformData.Value[2].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[2]";
                                    row.Cells[++columnIndexer].Value = PerPlatformData.Value.Length > 3 ? PerPlatformData.Value[3].ToString() : string.Empty;
                                    row.Cells[columnIndexer].ToolTipText = "[3]";
                                }
                                break;
                            case "NiagaraVariableBase":
                            case "NiagaraVariable":
                            case "NiagaraVariableWithOffset":
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = ((NiagaraVariableBasePropertyData)thisPD).VariableName;
                                row.Cells[columnIndexer].ToolTipText = "VariableName";
                                row.Cells[++columnIndexer].Value = "NiagaraTypeDefinition"; // just for display really
                                row.Cells[columnIndexer].ToolTipText = "TypeDef";
                                if (thisPD.PropertyType.Value == "NiagaraVariable")
                                {
                                    row.Cells[++columnIndexer].Value = ((NiagaraVariablePropertyData)thisPD).VarData.ConvertByteArrayToString();
                                    row.Cells[columnIndexer].ToolTipText = "VarData";
                                }
                                else if (thisPD.PropertyType.Value == "NiagaraVariableWithOffset")
                                {
                                    row.Cells[++columnIndexer].Value = ((NiagaraVariableWithOffsetPropertyData)thisPD).VariableOffset;
                                    row.Cells[columnIndexer].ToolTipText = "VariableOffset";
                                }
                                break;
                            case "SmartName":
                                var smartNameData = (SmartNamePropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = smartNameData.DisplayName == null ? FString.NullCase : smartNameData.DisplayName.ToString();
                                row.Cells[columnIndexer].ToolTipText = "DisplayName";
                                if (asset.GetCustomVersion<FAnimPhysObjectVersion>() < FAnimPhysObjectVersion.RemoveUIDFromSmartNameSerialize)
                                {
                                    row.Cells[++columnIndexer].Value = smartNameData.SmartNameID;
                                    row.Cells[columnIndexer].ToolTipText = "SmartNameID";
                                }
                                if (asset.GetCustomVersion<FAnimPhysObjectVersion>() < FAnimPhysObjectVersion.SmartNameRefactorForDeterministicCooking)
                                {
                                    row.Cells[++columnIndexer].Value = smartNameData.TempGUID.ConvertToString();
                                    row.Cells[columnIndexer].ToolTipText = "TempGUID";
                                }
                                break;
                            case "StrProperty":
                                var strPropData = (StrPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = (strPropData.Value?.Encoding ?? Encoding.UTF8).HeaderName;
                                row.Cells[++columnIndexer].Value = strPropData.Value?.Value == null ? FString.NullCase : Convert.ToString(strPropData.Value.Value);
                                break;
                            case "SoftObjectPath":
                            case "SoftAssetPath":
                            case "SoftClassPath":
                            case "StringAssetReference":
                                var sopPropData = (SoftObjectPathPropertyData)thisPD;
                                row.Cells[++columnIndexer].Value = string.Empty;
                                if (asset.ObjectVersion < ObjectVersion.VER_UE4_ADDED_SOFT_OBJECT_PATH)
                                {
                                    row.Cells[++columnIndexer].Value = sopPropData.Path == null ? FString.NullCase : sopPropData.Path.ToString();
                                    row.Cells[columnIndexer].ToolTipText = "Path";
                                }
                                else
                                {
                                    row.Cells[++columnIndexer].Value = sopPropData.Value.AssetPath.PackageName == null ? FString.NullCase : sopPropData.Value.AssetPath.PackageName.ToString();
                                    row.Cells[columnIndexer].ToolTipText = "AssetPath.PackageName";
                                    row.Cells[++columnIndexer].Value = sopPropData.Value.AssetPath.AssetName == null ? FString.NullCase : sopPropData.Value.AssetPath.AssetName.ToString();
                                    row.Cells[columnIndexer].ToolTipText = "AssetPath.AssetName";
                                    row.Cells[++columnIndexer].Value = sopPropData.Value.SubPathString == null ? FString.NullCase : sopPropData.Value.SubPathString.ToString();
                                    row.Cells[columnIndexer].ToolTipText = "SubPathString";
                                }
                                break;
                            default:
                                row.Cells[++columnIndexer].Value = string.Empty;
                                row.Cells[++columnIndexer].Value = Convert.ToString(thisPD.RawValue);
                                break;
                        }
                    }

                    long determinedOffset = asset.UseSeparateBulkDataFiles ? (thisPD.Offset - asset.Exports[0].SerialOffset) : thisPD.Offset;

                    row.Cells[absoluteColumnIndexer + 9].Value = thisPD.ArrayIndex;
                    row.Cells[absoluteColumnIndexer + 10].Value = determinedOffset < 0 ? "N/A" : determinedOffset.ToString();
                    row.Cells[absoluteColumnIndexer + 10].ReadOnly = true;
                    row.Cells[absoluteColumnIndexer + 11].Value = thisPD.IsZero.ToString();
                    row.HeaderCell.Value = Convert.ToString(i);
                    rows.Add(row);
                }
                //catch (Exception)
                //{

                //}
            }
            dataGridView1.Rows.AddRange(rows.ToArray());
        }

        /// <summary>
        /// Interpret a specific row in the current data grid view as a PropertyData instance and return it.
        /// </summary>
        /// <param name="rowNum">The row number.</param>
        /// <param name="original">The original PropertyData instance that this row was intended to represent. Used to clone values not represented in the display.</param>
        /// <param name="namesAreDummies">Whether or not the Name column is not serialized to disk (so shouldn't be appended to the name map).</param>
        /// <param name="useUnversionedProperties">Whether or not unversioned properties are being used. If true, namesAreDummies is overriden to be true.</param>
        /// <param name="expectedContext">Expected PropertySerializationContext, otherwise Normal.</param>
        /// <returns>The interpreted PropertyData instance.</returns>
        private PropertyData RowToPD(int rowNum, PropertyData original, bool namesAreDummies = false, bool useUnversionedProperties = false, PropertySerializationContext expectedContext = PropertySerializationContext.Normal)
        {
            if (useUnversionedProperties) namesAreDummies = true;

            try
            {
                DataGridViewRow row = dataGridView1.Rows[rowNum];
                int columnIndexer = -1;
                object nameB = row.Cells[++columnIndexer].Value;
                object typeB = row.Cells[++columnIndexer].Value;
                object transformB = row.Cells[++columnIndexer].Value;
                object value1B = row.Cells[++columnIndexer].Value;
                object value2B = row.Cells[++columnIndexer].Value;
                object value3B = row.Cells[++columnIndexer].Value;
                object value4B = row.Cells[++columnIndexer].Value;
                object value5B = row.Cells[++columnIndexer].Value;

                if (nameB == null || typeB == null) return null;
                if (!(nameB is string) || !(typeB is string)) return null;

                string name = ((string)nameB);
                string type = ((string)typeB)?.Trim();
                if (name.Equals(string.Empty) || type.Equals(string.Empty)) return null;

                FName nameName = namesAreDummies ? FName.DefineDummy(asset, name) : FName.FromString(asset, name);
                PropertyData finalProp = null;

                if (value1B != null && value1B is string && transformB != null && transformB is string && (string)transformB == "Unknown ser.")
                {
                    finalProp = new UnknownPropertyData(nameName)
                    {
                        Value = ((string)value1B).ConvertStringToByteArray()
                    };
                    ((UnknownPropertyData)finalProp).SetSerializingPropertyType(new FString(type));
                }
                else
                {
                    switch ((useUnversionedProperties ? FName.DefineDummy(asset, type) : FName.FromString(asset, type)).Value.Value)
                    {
                        case "TextProperty":
                            TextPropertyData decidedTextData = null;
                            if (original != null && original is TextPropertyData)
                            {
                                decidedTextData = (TextPropertyData)original;
                                decidedTextData.Name = nameName;
                            }
                            else
                            {
                                decidedTextData = new TextPropertyData(nameName);
                            }

                            TextHistoryType histType = TextHistoryType.Base;
                            if (transformB == null) return null;
                            if (transformB is string) Enum.TryParse((string)transformB, out histType);

                            decidedTextData.HistoryType = histType;
                            switch (histType)
                            {
                                case TextHistoryType.None:
                                    decidedTextData.Value = null;
                                    if (value1B != null && value1B is string) decidedTextData.CultureInvariantString = (string)value1B == FString.NullCase ? null : FString.FromString((string)value1B);
                                    break;
                                case TextHistoryType.Base:
                                    if (value1B == null || value2B == null || value3B == null || !(value1B is string) || !(value2B is string) || !(value3B is string)) return null;
                                    decidedTextData.Namespace = (string)value1B == FString.NullCase ? null : FString.FromString((string)value1B);
                                    decidedTextData.Value = (string)value2B == FString.NullCase ? null : FString.FromString((string)value2B);
                                    decidedTextData.CultureInvariantString = (string)value3B == FString.NullCase ? null : FString.FromString((string)value3B);
                                    break;
                                case TextHistoryType.StringTableEntry:
                                    if (value1B == null || !(value1B is string) || !(value2B is string)) return null;

                                    decidedTextData.TableId = FName.FromString(asset, (string)value1B);
                                    decidedTextData.Value = (string)value2B == FString.NullCase ? null : FString.FromString((string)value2B);
                                    break;
                                case TextHistoryType.RawText:
                                    if (value1B == null || !(value1B is string)) return null;
                                    decidedTextData.Value = (string)value1B == FString.NullCase ? null : FString.FromString((string)value1B);
                                    break;
                                default:
                                    break;
                            }

                            if (value4B != null && value4B is string) Enum.TryParse((string)value4B, out decidedTextData.Flags);

                            finalProp = decidedTextData;
                            break;
                        case "ObjectProperty":
                            ObjectPropertyData decidedObjData = null;
                            if (original != null && original is ObjectPropertyData)
                            {
                                decidedObjData = (ObjectPropertyData)original;
                                decidedObjData.Name = nameName;
                            }
                            else
                            {
                                decidedObjData = new ObjectPropertyData(nameName);
                            }

                            int objValue = int.MinValue;
                            if (transformB == null) return null;
                            if (transformB is string) int.TryParse((string)transformB, out objValue);
                            if (transformB is int) objValue = (int)transformB;
                            if (objValue == int.MinValue) return null;

                            decidedObjData.Value = new FPackageIndex(objValue);
                            UAGUtils.UpdateObjectPropertyValues(asset, row, dataGridView1, decidedObjData.Value);
                            finalProp = decidedObjData;
                            break;
                        case "RichCurveKey":
                            RichCurveKeyPropertyData decidedRCKProperty = null;
                            if (original != null && original is RichCurveKeyPropertyData)
                            {
                                decidedRCKProperty = (RichCurveKeyPropertyData)original;
                                decidedRCKProperty.Name = nameName;
                            }
                            else
                            {
                                decidedRCKProperty = new RichCurveKeyPropertyData(nameName);
                            }

                            FRichCurveKey nuevo = decidedRCKProperty.Value;

                            if (transformB is string) Enum.TryParse((string)transformB, out nuevo.InterpMode);
                            if (value1B is string) Enum.TryParse((string)value1B, out nuevo.TangentMode);

                            if (value2B is string) float.TryParse((string)value2B, out nuevo.Time);
                            if (value2B is int) nuevo.Time = (float)(int)value2B;
                            if (value2B is float) nuevo.Time = (float)value2B;
                            if (value3B is string) float.TryParse((string)value3B, out nuevo.Value);
                            if (value3B is int) nuevo.Value = (float)(int)value3B;
                            if (value3B is float) nuevo.Value = (float)value3B;
                            if (value4B is string) float.TryParse((string)value4B, out nuevo.ArriveTangent);
                            if (value4B is int) nuevo.ArriveTangent = (float)(int)value4B;
                            if (value4B is float) nuevo.ArriveTangent = (float)value4B;
                            if (value5B is string) float.TryParse((string)value5B, out nuevo.LeaveTangent);
                            if (value5B is int) nuevo.LeaveTangent = (float)(int)value5B;
                            if (value5B is float) nuevo.LeaveTangent = (float)value5B;

                            decidedRCKProperty.Value = nuevo;

                            finalProp = decidedRCKProperty;
                            break;
                        default:
                            PropertyData newThing = MainSerializer.TypeToClass(useUnversionedProperties ? FName.DefineDummy(asset, type) : FName.FromString(asset, type), nameName, null, null, null, asset);
                            if (original != null && original.GetType() == newThing.GetType())
                            {
                                newThing = original;
                                newThing.Name = nameName;
                            }

                            string[] existingStrings = new string[5];
                            if (value1B != null) existingStrings[0] = Convert.ToString(value1B);
                            if (value2B != null) existingStrings[1] = Convert.ToString(value2B);
                            if (value3B != null) existingStrings[2] = Convert.ToString(value3B);
                            if (value4B != null) existingStrings[3] = Convert.ToString(value4B);
                            if (transformB != null) existingStrings[4] = Convert.ToString(transformB);

                            newThing.FromString(existingStrings, asset);

                            // override for enums if needed to ensure Value is not dummy
                            if (namesAreDummies && newThing is EnumPropertyData newThingEnum && expectedContext != PropertySerializationContext.Normal)
                            {
                                // convert Value from dummy to non-dummy
                                newThingEnum.Value = FName.FromString(asset, newThingEnum.Value.ToString());
                            }

                            finalProp = newThing;
                            break;
                    }
                }

                string ArrayIndex = row.Cells[row.Cells.Count - 4]?.Value?.ToString() ?? "0";
                string isZero = row.Cells[row.Cells.Count - 2]?.Value?.ToString() ?? "false";

                int.TryParse(ArrayIndex, out finalProp.ArrayIndex);
                finalProp.IsZero = (isZero.ToLowerInvariant() == "true" || isZero == "1");
                return finalProp;
            }
            catch (Exception)
            {
                return null;
            }
        }

        public void ChangeAllExpansionStatus(bool expanding)
        {
            treeView1.BeginUpdate();
            foreach (TreeNode node in Collect(treeView1.Nodes))
            {
                if (expanding)
                {
                    node.Expand();
                }
                else
                {
                    node.Collapse();
                }
            }
            treeView1.EndUpdate();

            (treeView1.SelectedNode ?? treeView1.Nodes[0]).EnsureVisible();
        }

        private static IEnumerable<TreeNode> Collect(TreeNodeCollection nodes)
        {
            foreach (TreeNode node in nodes)
            {
                yield return node;
                foreach (TreeNode child in Collect(node.Nodes))
                {
                    yield return child;
                }
            }
        }

        internal int ReplaceAllReferencesInNameMap(FString antiguo, FString nuevo)
        {
            int replacedCount = 0;
            List<FName> allNamesThatExist = UAPUtils.FindAllInstances<FName>(asset);
            for (int i = 0; i < allNamesThatExist.Count; i++)
            {
                FName thisOne = allNamesThatExist[i];
                if (thisOne.Value == antiguo)
                {
                    thisOne.Value = nuevo;
                    replacedCount++;
                }
            }
            return replacedCount;
        }

        private void AddColumns(string[] ourColumns)
        {
            for (int i = 0; i < ourColumns.Length; i++)
            {
                DataGridViewColumn dgc = new DataGridViewTextBoxColumn
                {
                    HeaderText = ourColumns[i]
                };

                dgc.AutoSizeMode = DataGridViewAutoSizeColumnMode.AllCells;
                if (i >= (ourColumns.Length - 1))
                {
                    dgc.AutoSizeMode = DataGridViewAutoSizeColumnMode.Fill;
                }

                dgc.SortMode = DataGridViewColumnSortMode.NotSortable;
                dataGridView1.Columns.Add(dgc);
            }
        }

        private void ClearScreen()
        {
            dataGridView1.Columns.Clear();
            dataGridView1.Rows.Clear();
            dataGridView1.BackgroundColor = UAGPalette.InactiveColor;
        }

        public Form1 GetParentForm()
        {
            return (Form1) dataGridView1.Parent.Parent.Parent;
        }

        public void Load() // Updates the table with selected asset data
        {
            if (mode == TableHandlerMode.None)
            {
                ClearScreen();
                return;
            }

            var origForm = GetParentForm();
            var byteView1 = origForm.byteView1;
            byteView1.Visible = false;
            origForm.importBinaryData.Visible = false;
            origForm.exportBinaryData.Visible = false;
            origForm.setBinaryData.Visible = false;
            var jsonView = origForm.jsonView;
            jsonView.Visible = false;
            dataGridView1.Visible = true;
            dataGridView1.Columns.Clear();
            dataGridView1.Rows.Clear();
            dataGridView1.AllowUserToAddRows = true;
            dataGridView1.ReadOnly = false;

            dataGridView1.BackgroundColor = UAGPalette.DataGridViewActiveColor;
            readyToSave = false;
            dirtySinceLastLoad = false;

            origForm.ResetCurrentDataGridViewStrip();

            switch (mode)
            {
                case TableHandlerMode.GeneralInformation:
                    AddColumns(new string[] { "Property Name", "Value", "" });

                    dataGridView1.Rows.Add(new object[] { "LegacyFileVersion", asset.LegacyFileVersion.ToString() });
                    dataGridView1.Rows.Add(new object[] { "IsUnversioned", asset.IsUnversioned.ToString() });
                    dataGridView1.Rows.Add(new object[] { "FileVersionLicenseeUE", asset.FileVersionLicenseeUE.ToString() });
                    dataGridView1.Rows.Add(new object[] { "PackageGuid", asset.PackageGuid.ConvertToString() });
                    dataGridView1.Rows.Add(new object[] { "PackageFlags", asset.PackageFlags.ToString() });
                    dataGridView1.Rows.Add(new object[] { "PackageSource", asset.PackageSource.ToString() });
                    dataGridView1.Rows.Add(new object[] { asset.ObjectVersionUE5 >= ObjectVersionUE5.ADD_SOFTOBJECTPATH_LIST ? "PackageName" : "FolderName", asset.FolderName.Value });

                    dataGridView1.Rows[0].Cells[0].ToolTipText = "The package file version number when this package was saved. Unrelated to imports.";
                    dataGridView1.Rows[1].Cells[0].ToolTipText = "Should this asset not serialize its engine and custom versions?";
                    dataGridView1.Rows[2].Cells[0].ToolTipText = "The licensee file version. Used by some games to add their own Engine-level versioning.";
                    dataGridView1.Rows[3].Cells[0].ToolTipText = "Current ID for this package. Effectively unused.";
                    dataGridView1.Rows[4].Cells[0].ToolTipText = "The flags for this package.";
                    dataGridView1.Rows[5].Cells[0].ToolTipText = "Value that is used to determine if the package was saved by Epic, a licensee, modder, etc.";
                    dataGridView1.Rows[6].Cells[0].ToolTipText = asset.ObjectVersionUE5 >= ObjectVersionUE5.ADD_SOFTOBJECTPATH_LIST ? "The package name the file was last saved with." : "The Generic Browser folder name that this package lives in. Usually \"None\" in cooked assets.";

                    for (int i = 0; i < dataGridView1.Rows.Count; i++)
                    {
                        dataGridView1.Rows[i].HeaderCell.Value = Convert.ToString(i + 1);
                    }

                    dataGridView1.AllowUserToAddRows = false;
                    break;
                case TableHandlerMode.NameMap:
                    if (asset.GetCustomVersion<FReleaseObjectVersion>() < FReleaseObjectVersion.PropertiesSerializeRepCondition)
                    {
                        AddColumns(new string[] { "Name", "Case Preserving?", "Encoding", "" });

                        IReadOnlyList<FString> headerIndexList = asset.GetNameMapIndexList();
                        for (int num = 0; num < headerIndexList.Count; num++)
                        {
                            dataGridView1.Rows.Add(headerIndexList[num].Value, headerIndexList[num].IsCasePreserving, headerIndexList[num].Encoding.HeaderName);
                            dataGridView1.Rows[num].HeaderCell.Value = Convert.ToString(num);
                        }
                    }
                    else
                    {
                        AddColumns(new string[] { "Name", "Encoding", "" });

                        IReadOnlyList<FString> headerIndexList = asset.GetNameMapIndexList();
                        for (int num = 0; num < headerIndexList.Count; num++)
                        {
                            dataGridView1.Rows.Add(headerIndexList[num].Value, headerIndexList[num].Encoding.HeaderName);
                            dataGridView1.Rows[num].HeaderCell.Value = Convert.ToString(num);
                        }
                    }
                    //((Form1)dataGridView1.Parent).CurrentDataGridViewStrip = ((Form1)dataGridView1.Parent).nameMapContext;
                    break;
                case TableHandlerMode.SoftObjectPathList:
                    AddColumns(new string[] { "PackageName", "AssetName", "SubPathString", "" });

                    for (int num = 0; num < asset.SoftObjectPathList.Count; num++)
                    {
                        string a = asset.SoftObjectPathList[num].AssetPath.PackageName == null ? FString.NullCase : asset.SoftObjectPathList[num].AssetPath.PackageName.ToString();
                        string b = asset.SoftObjectPathList[num].AssetPath.AssetName == null ? FString.NullCase : asset.SoftObjectPathList[num].AssetPath.AssetName.ToString();
                        string c = asset.SoftObjectPathList[num].SubPathString == null ? FString.NullCase : asset.SoftObjectPathList[num].SubPathString.ToString();
                        dataGridView1.Rows.Add(a, b, c);
                        dataGridView1.Rows[num].HeaderCell.Value = Convert.ToString(num);
                    }
                    break;
                case TableHandlerMode.Imports:
                    AddColumns(new string[] { "ClassPackage", "ClassName", "OuterIndex", "ObjectName", "bImportOptional", "" });

                    for (int num = 0; num < asset.Imports.Count; num++)
                    {
                        dataGridView1.Rows.Add(asset.Imports[num].ClassPackage.ToString(), asset.Imports[num].ClassName.ToString(), asset.Imports[num].OuterIndex.Index, asset.Imports[num].ObjectName.ToString(), asset.Imports[num].bImportOptional);
                        dataGridView1.Rows[num].HeaderCell.Value = Convert.ToString(FPackageIndex.FromImport(num));
                    }
                    break;
                case TableHandlerMode.ExportInformation:
                    string[] allExportDetailsFields = Export.GetAllFieldNames(asset);
                    string[] allExportDetailsFields2 = new string[allExportDetailsFields.Length + 1];
                    allExportDetailsFields.CopyTo(allExportDetailsFields2, 0);
                    allExportDetailsFields2[allExportDetailsFields2.Length - 1] = "";
                    AddColumns(allExportDetailsFields2);

                    for (int num = 0; num < asset.Exports.Count; num++)
                    {
                        Export refer = asset.Exports[num];
                        string[] newCellsTooltips = new string[allExportDetailsFields.Length];
                        object[] newCells = new object[allExportDetailsFields.Length];
                        for (int num2 = 0; num2 < allExportDetailsFields.Length; num2++)
                        {
                            string cellTooltip = null;

                            object printingVal = refer.GetType().GetMember(allExportDetailsFields[num2])[0].GetValue(refer);
                            if (printingVal is FName parsingName)
                            {
                                string actualName = parsingName?.ToString();
                                if (actualName == null) actualName = FString.NullCase;
                                newCells[num2] = actualName;
                            }
                            else if (printingVal is FPackageIndex parsingIndex)
                            {
                                newCells[num2] = parsingIndex.Index;
                            }
                            else if (printingVal is List<FPackageIndex> parsingIndices)
                            {
                                newCells[num2] = parsingIndices.Count == 0 ? string.Empty : string.Join(",", parsingIndices.Select(x => x.Index).ToArray());
                            }
                            else
                            {
                                newCells[num2] = printingVal;
                            }

                            if (printingVal is int testInt)
                            {
                                if (testInt < 0) cellTooltip = new FPackageIndex(testInt).ToImport(asset).ObjectName.Value.Value;
                            }

                            newCellsTooltips[num2] = cellTooltip;
                        }

                        dataGridView1.Rows.Add(newCells);
                        dataGridView1.Rows[num].HeaderCell.Value = Convert.ToString(num + 1);

                        for (int num3 = 0; num3 < newCellsTooltips.Length; num3++)
                        {
                            if (!string.IsNullOrEmpty(newCellsTooltips[num3]))
                            {
                                dataGridView1.Rows[num].Cells[num3].ToolTipText = newCellsTooltips[num3];
                            }
                        }
                    }

                    break;
                case TableHandlerMode.DependsMap:
                    AddColumns(new string[] { "Export Index", "Value", "" });

                    if (asset.DependsMap == null) break;
                    for (int num = 0; num < asset.DependsMap.Count; num++)
                    {
                        for (int num2 = 0; num2 < asset.DependsMap[num].Length; num2++)
                        {
                            dataGridView1.Rows.Add((num + 1), asset.DependsMap[num][num2]);
                        }
                    }
                    break;
                case TableHandlerMode.SoftPackageReferences:
                    AddColumns(new string[] { "Value", "" });

                    if (asset.SoftPackageReferenceList == null) break;
                    for (int num = 0; num < asset.SoftPackageReferenceList.Count; num++)
                    {
                        dataGridView1.Rows.Add(asset.SoftPackageReferenceList[num]?.ToString() ?? FString.NullCase);
                    }
                    break;
                case TableHandlerMode.WorldTileInfo:
                    AddColumns(new string[] { "Property Name", "Value", "Value 2", "Value 3", "" });

                    if (treeView1.SelectedNode is PointingTreeNode wtlPointerNode)
                    {
                        if (wtlPointerNode.Pointer == null)
                        {
                            dataGridView1.Rows.Add(new object[] { "Position", asset.WorldTileInfo.Position[0], asset.WorldTileInfo.Position[1], asset.WorldTileInfo.Position[2] });
                            dataGridView1.Rows.Add(new object[] { "AbsolutePosition", asset.WorldTileInfo.AbsolutePosition[0], asset.WorldTileInfo.AbsolutePosition[1], asset.WorldTileInfo.AbsolutePosition[2] });
                            dataGridView1.Rows.Add(new object[] { "Bounds", asset.WorldTileInfo.Bounds?.ToString() ?? FString.NullCase });
                            dataGridView1.Rows.Add(new object[] { "Layer", "" });
                            dataGridView1.Rows.Add(new object[] { "bHideInTileView", asset.WorldTileInfo.bHideInTileView });
                            dataGridView1.Rows.Add(new object[] { "ParentTilePackageName", asset.WorldTileInfo.ParentTilePackageName?.ToString() ?? FString.NullCase });
                            dataGridView1.Rows.Add(new object[] { "LODList", "" });
                            dataGridView1.Rows.Add(new object[] { "ZOrder", asset.WorldTileInfo.ZOrder });
                        }
                        else if (wtlPointerNode.Pointer is FWorldTileLayer fWTL)
                        {
                            dataGridView1.Rows.Add(new object[] { "Name", fWTL.Name });
                            dataGridView1.Rows.Add(new object[] { "Reserved0", fWTL.Reserved0 });
                            dataGridView1.Rows.Add(new object[] { "Reserved1", fWTL.Reserved1?.ToString() ?? FString.NullCase });
                            dataGridView1.Rows.Add(new object[] { "StreamingDistance", fWTL.StreamingDistance });
                            dataGridView1.Rows.Add(new object[] { "DistanceStreamingEnabled", fWTL.DistanceStreamingEnabled });
                        }
                        else if (wtlPointerNode.Pointer is FWorldTileLODInfo fWTLI)
                        {
                            dataGridView1.Rows.Add(new object[] { "Name", fWTLI.RelativeStreamingDistance });
                            dataGridView1.Rows.Add(new object[] { "Reserved0", fWTLI.Reserved0 });
                            dataGridView1.Rows.Add(new object[] { "Reserved1", fWTLI.Reserved1 });
                            dataGridView1.Rows.Add(new object[] { "Reserved2", fWTLI.Reserved2 });
                            dataGridView1.Rows.Add(new object[] { "Reserved3", fWTLI.Reserved3 });
                        }
                    }

                    for (int i = 0; i < dataGridView1.Rows.Count; i++)
                    {
                        dataGridView1.Rows[i].HeaderCell.Value = Convert.ToString(i + 1);
                    }

                    // Modification is disabled
                    dataGridView1.AllowUserToAddRows = false;
                    dataGridView1.ReadOnly = true;
                    break;
                case TableHandlerMode.DataResources:
                    AddColumns(new string[] { "Index", "Flags", "SerialOffset", "DuplicateSerialOffset", "SerialSize", "RawSize", "OuterIndex", "LegacyBulkDataFlags", "" });

                    if (asset.DataResources == null) break;
                    for (int num = 0; num < asset.DataResources.Count; num++)
                    {
                        var dataResource = asset.DataResources[num];
                        dataGridView1.Rows.Add(new object[] { num, dataResource.Flags.ToString(), dataResource.SerialOffset.ToString(), dataResource.DuplicateSerialOffset.ToString(), dataResource.SerialSize.ToString(), dataResource.RawSize.ToString(), dataResource.OuterIndex.ToString(), dataResource.LegacyBulkDataFlags.ToString() });
                    }
                    break;
                case TableHandlerMode.CustomVersionContainer:
                    AddColumns(new string[] { "Name", "Version", "" });

                    if (asset.CustomVersionContainer == null) break;
                    for (int num = 0; num < asset.CustomVersionContainer.Count; num++)
                    {
                        dataGridView1.Rows.Add(new object[] { asset.CustomVersionContainer[num].FriendlyName == null ? Convert.ToString(asset.CustomVersionContainer[num].Key) : asset.CustomVersionContainer[num].FriendlyName, asset.CustomVersionContainer[num].Version });
                    }
                    break;
                case TableHandlerMode.ExportData:
                    if (treeView1.SelectedNode is PointingTreeNode pointerNode)
                    {
                        AddColumns(new string[] { "Name", "Type", "Variant", "Value", "Value 2", "Value 3", "Value 4", "Value 5", "ArrayIndex", "Serial Offset", "Is Zero", "" });
                        bool standardRendering = true;
                        PropertyData[] renderingArr = null;

                        if (pointerNode.Type == PointingTreeNodeType.ByteArray || pointerNode.Type == PointingTreeNodeType.KismetByteArray)
                        {
                            Control currentlyFocusedControl = origForm.ActiveControl;
                            dataGridView1.Visible = false;
                            byteView1.SetBytes(new byte[] { });
                            if (pointerNode.Type == PointingTreeNodeType.KismetByteArray)
                            {
                                byteView1.SetBytes(((StructExport)pointerNode.Pointer).ScriptBytecodeRaw);
                            }
                            else if (pointerNode.Pointer is RawExport)
                            {
                                byteView1.SetBytes(((RawExport)pointerNode.Pointer).Data);
                            }
                            else if (pointerNode.Pointer is NormalExport)
                            {
                                byteView1.SetBytes(((NormalExport)pointerNode.Pointer).Extras);
                            }
                            byteView1.Visible = true;
                            origForm.importBinaryData.Visible = true;
                            origForm.exportBinaryData.Visible = true;
                            origForm.setBinaryData.Visible = true;
                            currentlyFocusedControl.Focus();
                            origForm.ForceResize();
                            standardRendering = false;
                        }
                        else if (pointerNode.Type == PointingTreeNodeType.Kismet)
                        {
                            var bytecode = ((StructExport)pointerNode.Pointer).ScriptBytecode;
                            Control currentlyFocusedControl1 = origForm.ActiveControl;
                            if (UAGConfig.Data.EnablePrettyBytecode)
                            {
                                UAssetAPI.Kismet.KismetSerializer.asset = asset;
                                dataGridView1.Visible = false;
                                jsonView.Text = new JObject(new JProperty("Script", SerializeScript(bytecode))).ToString();
                                jsonView.Visible = true;
                                jsonView.ReadOnly = true;
                            }
                            else
                            {
                                dataGridView1.Visible = false;
                                jsonView.Text = asset.SerializeJsonObject(bytecode, true);
                                jsonView.Visible = true;
                                jsonView.ReadOnly = false;
                            }
                            currentlyFocusedControl1.Focus();
                            origForm.ForceResize();
                            standardRendering = false;
                        }
                        else
                        {
                            switch (pointerNode.Pointer)
                            {
                                case NormalExport usCategory:
                                    switch (pointerNode.Type)
                                    {
                                        case PointingTreeNodeType.Normal:
                                            for (int num = 0; num < usCategory.Data.Count; num++)
                                            {
                                                if (usCategory.Data[num] == null)
                                                {
                                                    usCategory.Data.RemoveAt(num);
                                                    num--;
                                                }
                                            }
                                            renderingArr = usCategory.Data.ToArray();
                                            break;
                                        case PointingTreeNodeType.UserDefinedStructData:
                                            var usCategoryUDS = (UserDefinedStructExport)usCategory;
                                            for (int num = 0; num < usCategoryUDS.StructData.Count; num++)
                                            {
                                                if (usCategoryUDS.StructData[num] == null)
                                                {
                                                    usCategoryUDS.StructData.RemoveAt(num);
                                                    num--;
                                                }
                                            }
                                            renderingArr = usCategoryUDS.StructData.ToArray();
                                            break;
                                        case PointingTreeNodeType.StructData:
                                            dataGridView1.Columns.Clear();
                                            AddColumns(new string[] { "Property Name", "Value", "Value 2", "Value 3", "Value 4", "Value 5", "" });

                                            StructExport strucCat = (StructExport)usCategory;
                                            List<DataGridViewRow> rows = new List<DataGridViewRow>();

                                            {
                                                ObjectPropertyData testProperty = new ObjectPropertyData(FName.DefineDummy(asset, "Super Struct"));
                                                testProperty.Value = strucCat.SuperStruct;

                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "Next";
                                                row.Cells[0].ToolTipText = "Next Field in the linked list";
                                                row.Cells[1].Value = strucCat.Field.Next;
                                                rows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "Super Struct";
                                                row.Cells[1].Value = testProperty.Value;
                                                UAGUtils.UpdateObjectPropertyValues(asset, row, dataGridView1, testProperty.Value, 2);
                                                rows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "ScriptBytecodeSize";
                                                row.Cells[0].ToolTipText = "Number of bytecode instructions in this UStruct";
                                                row.Cells[1].Value = strucCat.ScriptBytecodeSize;
                                                rows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "ScriptBytecode";
                                                row.Cells[1].Value = string.Empty;
                                                rows.Add(row);
                                            }

                                            // Header 1
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "---";
                                                row.Cells[1].Value = "CHILDREN";
                                                row.Cells[2].Value = "---";
                                                rows.Add(row);
                                            }

                                            for (int i = 0; i < strucCat.Children.Length; i++)
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = strucCat.Children[i];
                                                rows.Add(row);
                                            }

                                            // Header 2
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "---";
                                                row.Cells[1].Value = "LOADED PROPERTIES";
                                                row.Cells[2].Value = "---";
                                                rows.Add(row);
                                            }

                                            for (int i = 0; i < strucCat.LoadedProperties.Length; i++)
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = strucCat.LoadedProperties[i].Name.ToString();
                                                row.Cells[1].Value = strucCat.LoadedProperties[i].SerializedType.ToString();
                                                row.Cells[2].Value = strucCat.LoadedProperties[i].Flags.ToString();
                                                rows.Add(row);
                                            }

                                            // Header 3
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "---";
                                                row.Cells[1].Value = "END";
                                                row.Cells[2].Value = "---";
                                                rows.Add(row);
                                            }

                                            dataGridView1.Rows.AddRange(rows.ToArray());
                                            dataGridView1.ReadOnly = true;
                                            dataGridView1.AllowUserToAddRows = false;
                                            standardRendering = false;
                                            break;
                                        case PointingTreeNodeType.ClassData:
                                            dataGridView1.Columns.Clear();
                                            AddColumns(new string[] { "Property Name", "Value", "Value 2", "Value 3", "Value 4", "Value 5", "" });

                                            ClassExport bgcCat = (ClassExport)usCategory;
                                            List<DataGridViewRow> classRows = new List<DataGridViewRow>();

                                            {
                                                ObjectPropertyData testProperty = new ObjectPropertyData(FName.DefineDummy(asset, "Super Struct"));
                                                testProperty.Value = bgcCat.SuperStruct;

                                                DataGridViewRow row = new DataGridViewRow();
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "ClassFlags";
                                                row.Cells[1].Value = bgcCat.ClassFlags.ToString();
                                                classRows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "ClassWithin";
                                                row.Cells[1].Value = bgcCat.ClassWithin;
                                                row.Cells[2].Value = bgcCat.ClassWithin.IsImport() ? bgcCat.ClassWithin.ToImport(asset).ObjectName.ToString() : "";
                                                classRows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "ClassConfigName";
                                                row.Cells[1].Value = bgcCat.ClassConfigName.ToString();
                                                classRows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "ClassGeneratedBy";
                                                row.Cells[1].Value = bgcCat.ClassGeneratedBy;
                                                classRows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "bDeprecatedForceScriptOrder";
                                                row.Cells[1].Value = bgcCat.bDeprecatedForceScriptOrder;
                                                classRows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "bCooked";
                                                row.Cells[1].Value = bgcCat.bCooked;
                                                classRows.Add(row);
                                                row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "ClassDefaultObject";
                                                row.Cells[2].Value = bgcCat.ClassDefaultObject;
                                                row.Cells[3].Value = "Jump";
                                                row.Cells[3].Tag = "CategoryJump";
                                                DataGridViewCellStyle sty = new DataGridViewCellStyle();
                                                Font styFont = new Font(dataGridView1.Font.Name, UAGPalette.RecommendedFontSize, FontStyle.Underline);
                                                sty.Font = styFont;
                                                sty.ForeColor = UAGPalette.LinkColor;
                                                row.Cells[3].Style = sty;
                                                classRows.Add(row);
                                            }

                                            // Header 1
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "---";
                                                row.Cells[1].Value = "FUNCTION MAP";
                                                row.Cells[2].Value = "---";
                                                classRows.Add(row);
                                            }

                                            for (int i = 0; i < bgcCat.FuncMap.Count; i++)
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = bgcCat.FuncMap.Keys.ElementAt(i).ToString();
                                                row.Cells[2].Value = bgcCat.FuncMap[i].Index;
                                                if (bgcCat.FuncMap[i].Index != 0)
                                                {
                                                    row.Cells[3].Value = "Jump";
                                                    row.Cells[3].Tag = "CategoryJump";
                                                    DataGridViewCellStyle sty = new DataGridViewCellStyle();
                                                    Font styFont = new Font(dataGridView1.Font.Name, UAGPalette.RecommendedFontSize, FontStyle.Underline);
                                                    sty.Font = styFont;
                                                    sty.ForeColor = UAGPalette.LinkColor;
                                                    row.Cells[3].Style = sty;
                                                }
                                                classRows.Add(row);
                                            }

                                            // Header 2
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "---";
                                                row.Cells[1].Value = "END";
                                                row.Cells[2].Value = "---";
                                                classRows.Add(row);
                                            }

                                            dataGridView1.Rows.AddRange(classRows.ToArray());
                                            dataGridView1.ReadOnly = true;
                                            dataGridView1.AllowUserToAddRows = false;
                                            standardRendering = false;
                                            break;
                                        case PointingTreeNodeType.EnumData:
                                            dataGridView1.Columns.Clear();
                                            AddColumns(new string[] { "Name", "Value", "" });

                                            EnumExport enumCat = (EnumExport)usCategory;
                                            List<DataGridViewRow> enumRows = new List<DataGridViewRow>();

                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = "CppForm";
                                                row.Cells[0].ToolTipText = "How the enum was originally defined.";
                                                row.Cells[1].Value = enumCat.Enum.CppForm.ToString();
                                                enumRows.Add(row);
                                            }

                                            for (int i = 0; i < enumCat.Enum.Names.Count; i++)
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = enumCat.Enum.Names[i].Item1.ToString();
                                                row.Cells[1].Value = enumCat.Enum.Names[i].Item2.ToString();
                                                enumRows.Add(row);
                                            }

                                            dataGridView1.Rows.AddRange(enumRows.ToArray());
                                            standardRendering = false;
                                            break;
                                        case PointingTreeNodeType.UPropertyData:
                                            dataGridView1.Columns.Clear();
                                            AddColumns(new string[] { "Property Name", "Value", "Value 2", "Value 3", "Value 4", "Value 5", "" });

                                            PropertyExport uPropData = (PropertyExport)usCategory;
                                            List<DataGridViewRow> uPropRows = new List<DataGridViewRow>();

                                            {
                                                var allUPropFields = UAPUtils.GetOrderedFields(uPropData.Property.GetType());
                                                for (int i = 0; i < allUPropFields.Length; i++)
                                                {
                                                    FieldInfo currFieldInfo = allUPropFields[i];
                                                    string currFieldName = currFieldInfo.Name;
                                                    object currFieldValue = currFieldInfo.GetValue(uPropData.Property);
                                                    if (currFieldInfo.Name == "Next" && currFieldValue == null) continue;

                                                    DataGridViewRow row = new DataGridViewRow();
                                                    row.CreateCells(dataGridView1);
                                                    row.Cells[0].Value = currFieldName;
                                                    row.Cells[1].Value = currFieldValue.ToString();
                                                    if (currFieldValue is FPackageIndex fpi) UAGUtils.UpdateObjectPropertyValues(asset, row, dataGridView1, fpi, 2);
                                                    uPropRows.Add(row);
                                                }
                                            }

                                            dataGridView1.Rows.AddRange(uPropRows.ToArray());
                                            dataGridView1.ReadOnly = true;
                                            dataGridView1.AllowUserToAddRows = false;
                                            standardRendering = false;
                                            break;
                                    }

                                    break;
                                case FStringTable strUs:
                                    {
                                        dataGridView1.Columns.Clear();
                                        AddColumns(new string[] { "Key", "Encoding", "Source String", "Encoding", "" });
                                        List<DataGridViewRow> rows = new List<DataGridViewRow>();
                                        for (int i = 0; i < strUs.Count; i++)
                                        {
                                            FString key = strUs.Keys.ElementAt(i);
                                            FString value = strUs[i];

                                            DataGridViewRow row = new DataGridViewRow();
                                            row.CreateCells(dataGridView1);
                                            row.Cells[0].Value = key.FEncode();
                                            row.Cells[1].Value = key?.Encoding?.HeaderName ?? Encoding.UTF8.HeaderName;
                                            row.Cells[2].Value = value.FEncode();
                                            row.Cells[3].Value = value?.Encoding?.HeaderName ?? Encoding.UTF8.HeaderName;
                                            row.HeaderCell.Value = Convert.ToString(i);
                                            rows.Add(row);
                                        }
                                        dataGridView1.Rows.AddRange(rows.ToArray());
                                        standardRendering = false;
                                        break;
                                    }
                                case UDataTable dtUs:
                                    dtUs.Data.StripNullsFromList();
                                    renderingArr = dtUs.Data.ToArray();
                                    break;
                                case MapPropertyData usMap:
                                    {
                                        if (usMap.Value.Count > 0)
                                        {
                                            FName mapKeyType = usMap.KeyType;
                                            FName mapValueType = usMap.ValueType;
                                            if (usMap.Value.Count != 0)
                                            {
                                                mapKeyType = asset.HasUnversionedProperties ? FName.DefineDummy(asset, usMap.Value.Keys.ElementAt(0).PropertyType) : new FName(asset, usMap.Value.Keys.ElementAt(0).PropertyType);
                                                mapValueType = asset.HasUnversionedProperties ? FName.DefineDummy(asset, usMap.Value[0].PropertyType) : new FName(asset, usMap.Value[0].PropertyType);
                                            }

                                            List<DataGridViewRow> rows = new List<DataGridViewRow>();
                                            for (int i = 0; i < usMap.Value.Count; i++)
                                            {
                                                DataGridViewRow row = new DataGridViewRow();
                                                row.CreateCells(dataGridView1);
                                                row.Cells[0].Value = usMap.Name.ToString();
                                                row.Cells[1].Value = "MapEntry";
                                                row.Cells[2].Value = string.Empty;

                                                row.Cells[3].Value = "Jump";
                                                row.Cells[3].Tag = "ChildJump";

                                                DataGridViewCellStyle sty = new DataGridViewCellStyle();
                                                Font styFont = new Font(dataGridView1.Font.Name, UAGPalette.RecommendedFontSize, FontStyle.Underline);
                                                sty.Font = styFont;
                                                sty.ForeColor = UAGPalette.LinkColor;
                                                row.Cells[3].Style = sty;

                                                row.Cells[4].Value = mapKeyType.ToString();
                                                row.Cells[5].Value = mapValueType.ToString();
                                                row.HeaderCell.Value = Convert.ToString(i);
                                                row.Tag = new KeyValuePair<PropertyData, PropertyData>(usMap.Value.Keys.ElementAt(i), usMap.Value[i]);
                                                rows.Add(row);
                                            }
                                            dataGridView1.Rows.AddRange(rows.ToArray());
                                        }
                                        standardRendering = false;
                                        break;
                                    }
                                case StructPropertyData usStruct:
                                    usStruct.Value.StripNullsFromList();
                                    renderingArr = usStruct.Value.ToArray();
                                    break;
                                case ArrayPropertyData usArr:
                                    usArr.Value = usArr.Value.StripNullsFromArray();
                                    renderingArr = usArr.Value;
                                    break;
                                case GameplayTagContainerPropertyData usArr2:
                                    dataGridView1.Columns.Clear();
                                    AddColumns(new string[] { "Tag Name", "" });
                                    usArr2.Value = usArr2.Value.StripNullsFromArray();
                                    for (int i = 0; i < usArr2.Value.Length; i++)
                                    {
                                        dataGridView1.Rows.Add(usArr2.Value[i].ToString());
                                    }
                                    standardRendering = false;
                                    break;
                                case BoxPropertyData box1:
                                    {
                                        List<DataGridViewRow> rows = new List<DataGridViewRow>();

                                        DataGridViewRow row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "Min";
                                        row.Cells[1].Value = box1.Value.Min.X;
                                        row.Cells[2].Value = box1.Value.Min.Y;
                                        row.Cells[3].Value = box1.Value.Min.Z;
                                        row.HeaderCell.Value = Convert.ToString(0);
                                        rows.Add(row);

                                        row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "Max";
                                        row.Cells[1].Value = box1.Value.Max.X;
                                        row.Cells[2].Value = box1.Value.Max.Y;
                                        row.Cells[3].Value = box1.Value.Max.Z;
                                        row.HeaderCell.Value = Convert.ToString(1);
                                        rows.Add(row);

                                        row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "IsValid";
                                        row.Cells[1].Value = box1.Value.IsValid > 0;
                                        row.HeaderCell.Value = Convert.ToString(2);
                                        rows.Add(row);

                                        dataGridView1.Rows.AddRange(rows.ToArray());
                                    }

                                    dataGridView1.AllowUserToAddRows = false;
                                    standardRendering = false;
                                    break;
                                case Box2DPropertyData box1:
                                    {
                                        List<DataGridViewRow> rows = new List<DataGridViewRow>();

                                        DataGridViewRow row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "Min";
                                        row.Cells[1].Value = box1.Value.Min.X;
                                        row.Cells[2].Value = box1.Value.Min.Y;
                                        row.HeaderCell.Value = Convert.ToString(0);
                                        rows.Add(row);

                                        row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "Max";
                                        row.Cells[1].Value = box1.Value.Max.X;
                                        row.Cells[2].Value = box1.Value.Max.Y;
                                        row.HeaderCell.Value = Convert.ToString(1);
                                        rows.Add(row);

                                        row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "IsValid";
                                        row.Cells[1].Value = box1.Value.IsValid > 0;
                                        row.HeaderCell.Value = Convert.ToString(2);
                                        rows.Add(row);

                                        dataGridView1.Rows.AddRange(rows.ToArray());
                                    }

                                    dataGridView1.AllowUserToAddRows = false;
                                    standardRendering = false;
                                    break;
                                case Box2fPropertyData box1:
                                    {
                                        List<DataGridViewRow> rows = new List<DataGridViewRow>();

                                        DataGridViewRow row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "Min";
                                        row.Cells[1].Value = box1.Value.Min.X;
                                        row.Cells[2].Value = box1.Value.Min.Y;
                                        row.HeaderCell.Value = Convert.ToString(0);
                                        rows.Add(row);

                                        row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "Max";
                                        row.Cells[1].Value = box1.Value.Max.X;
                                        row.Cells[2].Value = box1.Value.Max.Y;
                                        row.HeaderCell.Value = Convert.ToString(1);
                                        rows.Add(row);

                                        row = new DataGridViewRow();
                                        row.CreateCells(dataGridView1);
                                        row.Cells[0].Value = "IsValid";
                                        row.Cells[1].Value = box1.Value.IsValid > 0;
                                        row.HeaderCell.Value = Convert.ToString(2);
                                        rows.Add(row);

                                        dataGridView1.Rows.AddRange(rows.ToArray());
                                    }

                                    dataGridView1.AllowUserToAddRows = false;
                                    standardRendering = false;
                                    break;
                                case PointingDictionaryEntry usDictEntry:
                                    dataGridView1.AllowUserToAddRows = false;
                                    var ourKey = usDictEntry.Entry.Key;
                                    var ourValue = usDictEntry.Entry.Value;
                                    if (ourKey != null) ourKey.Name = FName.DefineDummy(asset, "Key");
                                    if (ourValue != null) ourValue.Name = FName.DefineDummy(asset, "Value");
                                    renderingArr = [ourKey, ourValue];
                                    break;
                                case FDelegate[] usRealMDArr:
                                    for (int i = 0; i < usRealMDArr.Length; i++)
                                    {
                                        dataGridView1.Rows.Add(usRealMDArr[i].Delegate, "FDelegate", usRealMDArr[i].Object.Index);
                                    }
                                    standardRendering = false;
                                    break;
                                case PropertyData[] usRealArr:
                                    renderingArr = usRealArr;
                                    dataGridView1.AllowUserToAddRows = false;
                                    break;
                            }
                        }

                        if (standardRendering)
                        {
                            if (renderingArr != null)
                            {
                                if (renderingArr.Length > 0) AddRowsForArray(renderingArr);
                            }
                            else
                            {
                                ClearScreen();
                            }
                        }
                    }
                    else
                    {
                        ClearScreen();
                    }
                    break;
            }

            // go through each row and make sure it's a good height and width
            if (dataGridView1.Rows?.Count > 0)
            {
                dataGridView1.AutoResizeRowHeadersWidth(DataGridViewRowHeadersWidthSizeMode.AutoSizeToAllHeaders);
                for (int i = 0; i < dataGridView1.Rows.Count; i++)
                {
                    if (dataGridView1.Rows[i].Height < dataGridView1.RowTemplate.MinimumHeight) this.dataGridView1.AutoResizeRow(i);
                }
            }

            origForm.UpdateRPC();

            readyToSave = true;
            dataGridView1.ClearSelection();
            dataGridView1.CurrentCell = null;
        }

        public void Save(bool forceNewLoad) // Reads from the table and updates the asset data as needed
        {
            if (!readyToSave) return;
            if (dataGridView1?.Rows == null) return;

            switch (mode)
            {
                case TableHandlerMode.GeneralInformation:
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        string propertyName = (string)row.Cells[0].Value;
                        string propertyValue = (string)row.Cells[1].Value;
                        switch (propertyName)
                        {
                            case "LegacyFileVersion":
                                asset.LegacyFileVersion = Convert.ToInt32(propertyValue);
                                break;
                            case "IsUnversioned":
                                bool nextUvVal = propertyValue.ToLowerInvariant() == "true" || propertyValue == "1";
                                if (asset.IsUnversioned && !nextUvVal)
                                {
                                    // currently unversioned, switching to versioned
                                    // make all custom versions serialized
                                    foreach (CustomVersion cVer in asset.CustomVersionContainer)
                                    {
                                        cVer.IsSerialized = true;
                                    }
                                }
                                asset.IsUnversioned = nextUvVal;
                                break;
                            case "FileVersionLicenseeUE":
                                asset.FileVersionLicenseeUE = Convert.ToInt32(propertyValue);
                                break;
                            case "PackageGuid":
                                Guid newPackageGuid = propertyValue.ConvertToGUID();
                                if (newPackageGuid != Guid.Empty) asset.PackageGuid = newPackageGuid;
                                break;
                            case "PackageFlags":
                                if (Enum.TryParse(propertyValue, out EPackageFlags newPackageFlags)) asset.PackageFlags = newPackageFlags;
                                break;
                            case "PackageSource":
                                if (uint.TryParse(propertyValue, out uint newPackageSource)) asset.PackageSource = newPackageSource;
                                break;
                            case "FolderName":
                            case "PackageName":
                                asset.FolderName = FString.FromString(propertyValue, Encoding.UTF8.GetByteCount(propertyValue) == propertyValue.Length ? Encoding.UTF8 : Encoding.Unicode);
                                break;
                        }

                    }
                    break;
                case TableHandlerMode.NameMap:
                    bool hasCasePreservingColumn = asset.GetCustomVersion<FReleaseObjectVersion>() < FReleaseObjectVersion.PropertiesSerializeRepCondition;
                    asset.ClearNameIndexList();
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        int r = 0; bool isCasePreserving = true;

                        string ourValue = (string)row.Cells[r++].Value;
                        if (hasCasePreservingColumn)
                        {
                            object isCasePreservingTemp = row.Cells[r++].Value;
                            if (isCasePreservingTemp is string)
                            {
                                isCasePreserving = ((string)isCasePreservingTemp).Equals("1") || ((string)isCasePreservingTemp).ToLowerInvariant().Equals("true");
                            }
                            else if (isCasePreservingTemp is bool)
                            {
                                isCasePreserving = (bool)isCasePreservingTemp;
                            }
                        }
                        string encoding = (string)row.Cells[r++].Value;

                        if (string.IsNullOrWhiteSpace(encoding)) encoding = "ascii";
                        if (!string.IsNullOrWhiteSpace(ourValue))
                        {
                            var finalStr = FString.FromString(ourValue, encoding.Equals(Encoding.Unicode.HeaderName) ? Encoding.Unicode : Encoding.UTF8);
                            finalStr.IsCasePreserving = isCasePreserving;
                            asset.AddNameReference(finalStr, true);
                        }
                    }
                    break;
                case TableHandlerMode.SoftObjectPathList:
                    if (asset.SoftObjectPathList == null) asset.SoftObjectPathList = new List<FSoftObjectPath>();

                    asset.SoftObjectPathList.Clear();
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        string a = row.Cells[0].Value as string;
                        string b = row.Cells[1].Value as string;
                        string c = row.Cells[2].Value as string;

                        if (a == FString.NullCase) a = null;
                        if (b == FString.NullCase) b = null;
                        if (c == FString.NullCase) c = null;

                        // if all empty, then remove (invalid, probably just the last row)
                        if (a == null && b == null && c == null) continue;

                        FSoftObjectPath nuevo = new FSoftObjectPath(FName.FromString(asset, a), FName.FromString(asset, b), FString.FromString(c));
                        asset.SoftObjectPathList.Add(nuevo);
                    }
                    break;
                case TableHandlerMode.Imports:
                    asset.Imports = new List<Import>();
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        object val1 = row.Cells[0].Value;
                        object val2 = row.Cells[1].Value;
                        object val3 = row.Cells[2].Value;
                        object val4 = row.Cells[3].Value;
                        object val5 = row.Cells[4].Value;

                        bool realVal5 = false;
                        if (val5 is bool) realVal5 = (bool)val5;
                        if (val5 is string) realVal5 = ((string)val5).Equals("1") || ((string)val5).ToLowerInvariant().Equals("true");

                        if (val1 == null || val2 == null || val4 == null) continue;
                        if (!(val1 is string) || !(val2 is string) || !(val4 is string)) continue;

                        int realVal3 = 0;
                        if (val3 is string)
                        {
                            int.TryParse((string)val3, out realVal3);
                        }
                        else
                        {
                            realVal3 = Convert.ToInt32(val3);
                        }

                        string realVal1 = (string)val1;
                        string realVal2 = (string)val2;
                        string realVal4 = (string)val4;
                        if (string.IsNullOrWhiteSpace(realVal1) || string.IsNullOrWhiteSpace(realVal2) || string.IsNullOrWhiteSpace(realVal4)) continue;

                        FName parsedVal1 = FName.FromString(asset, realVal1);
                        FName parsedVal2 = FName.FromString(asset, realVal2);
                        FName parsedVal4 = FName.FromString(asset, realVal4);
                        asset.AddNameReference(parsedVal1.Value);
                        asset.AddNameReference(parsedVal2.Value);
                        asset.AddNameReference(parsedVal4.Value);
                        Import newLink = new Import(parsedVal1, parsedVal2, new FPackageIndex(realVal3), parsedVal4, realVal5);
                        asset.Imports.Add(newLink);
                    }
                    break;
                case TableHandlerMode.ExportInformation:
                    MemberInfo[] allExportDetailsFields = Export.GetAllObjectExportFields(asset);
                    ExportDetailsParseType[] parsingTypes = new ExportDetailsParseType[]
                    {
                        ExportDetailsParseType.FName,
                        ExportDetailsParseType.FPackageIndex,

                        ExportDetailsParseType.FPackageIndex,
                        ExportDetailsParseType.FPackageIndex,
                        ExportDetailsParseType.FPackageIndex,
                        ExportDetailsParseType.EObjectFlags,
                        ExportDetailsParseType.Long,
                        ExportDetailsParseType.Long,
                        ExportDetailsParseType.Long,
                        ExportDetailsParseType.Long,
                        ExportDetailsParseType.Bool,
                        ExportDetailsParseType.Bool,
                        ExportDetailsParseType.Bool,
                        ExportDetailsParseType.Guid,
                        ExportDetailsParseType.Bool,
                        ExportDetailsParseType.UInt,
                        ExportDetailsParseType.Bool,
                        ExportDetailsParseType.Bool,
                        ExportDetailsParseType.Bool,

                        ExportDetailsParseType.FPackageIndexList,
                        ExportDetailsParseType.FPackageIndexList,
                        ExportDetailsParseType.FPackageIndexList,
                        ExportDetailsParseType.FPackageIndexList,
                        ExportDetailsParseType.FPackageIndexList
                    };

                    int rowNum = 0;
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        bool isNewExport = false;
                        if (asset.Exports.Count <= rowNum)
                        {
                            // If we add a new category, we'll make a new NormalExport (None-terminated UProperty list). If you want to make some other kind of export, you'll need to do it manually with UAssetAPI
                            var newCat = new NormalExport(asset, Array.Empty<Byte>());
                            newCat.Data = new List<PropertyData>();
                            asset.Exports.Add(newCat);
                            isNewExport = true;
                        }

                        bool isInvalidRow = false;

                        for (int i = 0; i < allExportDetailsFields.Length; i++)
                        {
                            object currentVal = row.Cells[i].Value;
                            object settingVal = null;
                            switch (parsingTypes[i])
                            {
                                case ExportDetailsParseType.Int:
                                    settingVal = 0;
                                    if (currentVal is string)
                                    {
                                        int x = 0;
                                        int.TryParse((string)currentVal, out x);
                                        settingVal = x;
                                    }
                                    else
                                    {
                                        settingVal = Convert.ToInt32(currentVal);
                                    }
                                    break;
                                case ExportDetailsParseType.FPackageIndex:
                                    settingVal = 0;
                                    if (currentVal is string)
                                    {
                                        int x = 0;
                                        int.TryParse((string)currentVal, out x);
                                        settingVal = new FPackageIndex(x);
                                    }
                                    else
                                    {
                                        settingVal = new FPackageIndex(Convert.ToInt32(currentVal));
                                    }
                                    break;
                                case ExportDetailsParseType.FName:
                                    settingVal = null;
                                    if (currentVal is string rawFName)
                                    {
                                        settingVal = FName.FromString(asset, rawFName);
                                    }
                                    else
                                    {
                                        isInvalidRow = true;
                                    }
                                    break;
                                case ExportDetailsParseType.EObjectFlags:
                                    settingVal = EObjectFlags.RF_NoFlags;
                                    if (currentVal is string)
                                    {
                                        EObjectFlags x;
                                        Enum.TryParse((string)currentVal, out x);
                                        settingVal = x;
                                    }
                                    else if (currentVal is EObjectFlags)
                                    {
                                        settingVal = (EObjectFlags)currentVal;
                                    }
                                    break;
                                case ExportDetailsParseType.Long:
                                    settingVal = 0;
                                    if (currentVal is string)
                                    {
                                        long x = 0;
                                        long.TryParse((string)currentVal, out x);
                                        settingVal = x;
                                    }
                                    else
                                    {
                                        settingVal = Convert.ToInt64(currentVal);
                                    }
                                    break;
                                case ExportDetailsParseType.Bool:
                                    settingVal = false;
                                    if (currentVal is string)
                                    {
                                        settingVal = ((string)currentVal).Equals("1") || ((string)currentVal).ToLowerInvariant().Equals("true");
                                    }
                                    else if (currentVal is bool)
                                    {
                                        settingVal = (bool)currentVal;
                                    }
                                    else
                                    {
                                        settingVal = false;
                                    }
                                    break;
                                case ExportDetailsParseType.Guid:
                                    settingVal = new Guid();
                                    if (currentVal is string)
                                    {
                                        Guid x = new Guid();
                                        x = ((string)currentVal).ConvertToGUID();
                                        settingVal = x;
                                    }
                                    else if (currentVal is Guid)
                                    {
                                        settingVal = (Guid)currentVal;
                                    }
                                    break;
                                case ExportDetailsParseType.UInt:
                                    settingVal = 0;
                                    if (currentVal is string)
                                    {
                                        uint x = 0;
                                        uint.TryParse((string)currentVal, out x);
                                        settingVal = x;
                                    }
                                    else
                                    {
                                        settingVal = Convert.ToUInt32(currentVal);
                                    }
                                    break;
                                case ExportDetailsParseType.FPackageIndexList:
                                    var finalList = new List<FPackageIndex>();
                                    if (currentVal is string)
                                    {
                                        string[] separateInts = ((string)currentVal).Split(',');
                                        foreach (string separateInt in separateInts)
                                        {
                                            if (int.TryParse(separateInt.Trim(), out int x)) finalList.Add(new FPackageIndex(x));
                                        }
                                    }
                                    else if (currentVal is List<FPackageIndex>)
                                    {
                                        finalList = (List<FPackageIndex>)currentVal;
                                    }
                                    settingVal = finalList;
                                    break;
                            }

                            allExportDetailsFields[i].SetValue(asset.Exports[rowNum], settingVal);
                        }

                        if (isInvalidRow && isNewExport)
                        {
                            asset.Exports.RemoveAt(asset.Exports.Count - 1);
                        }
                        rowNum++;
                    }

                    // remove garbage exports
                    for (int num = 0; num < asset.Exports.Count; num++)
                    {
                        if (asset.Exports[num].ObjectName == null)
                        {
                            asset.Exports.RemoveAt(num);
                            num--;
                        }
                    }

                    break;
                case TableHandlerMode.DependsMap:
                    var newDM = new List<int[]>();
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        int[] vals = new int[2];
                        for (int i = 0; i < 2; i++)
                        {
                            if (row.Cells[i].Value is string)
                            {
                                bool result = int.TryParse((string)row.Cells[i].Value, out int x);
                                if (!result) return;
                                vals[i] = x;
                            }
                            else
                            {
                                vals[i] = Convert.ToInt32(row.Cells[i].Value);
                            }
                        }

                        if (vals[0] == 0) continue;

                        if (newDM.Count > vals[0])
                        {
                            var arr = newDM[vals[0]];
                            Array.Resize(ref arr, arr.Length + 1);
                            arr[arr.Length - 1] = vals[1];
                            newDM[vals[0]] = arr;
                        }
                        else
                        {
                            newDM.Insert(vals[0], new int[] { vals[1] });
                        }
                    }

                    int numDependsInts = 0;
                    foreach (var entry in newDM) numDependsInts += entry.Length;

                    if (asset.DependsMap == null && numDependsInts == 0) break;
                    asset.DependsMap = newDM;
                    break;
                case TableHandlerMode.SoftPackageReferences:
                    var newSPR = new List<FString>();
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        string strVal = (string)row.Cells[0].Value;
                        if (!string.IsNullOrEmpty(strVal)) newSPR.Add(FString.FromString(strVal));
                    }

                    if (asset.SoftPackageReferenceList == null && newSPR.Count == 0) break;
                    asset.SoftPackageReferenceList = newSPR;
                    break;
                case TableHandlerMode.WorldTileInfo:
                    // Modification is disabled

                    break;
                case TableHandlerMode.DataResources:
                    var newDR = new List<FObjectDataResource>();
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        if (row.Cells.Count < 8 || string.IsNullOrWhiteSpace(row.Cells[0]?.Value?.ToString())) continue;
                        EObjectDataResourceFlags.TryParse(row.Cells[1]?.Value?.ToString(), out EObjectDataResourceFlags flags);
                        long.TryParse(row.Cells[2]?.Value?.ToString(), out long SerialOffset);
                        long.TryParse(row.Cells[3]?.Value?.ToString(), out long DuplicateSerialOffset);
                        long.TryParse(row.Cells[4]?.Value?.ToString(), out long SerialSize);
                        long.TryParse(row.Cells[5]?.Value?.ToString(), out long RawSize);
                        int.TryParse(row.Cells[6]?.Value?.ToString(), out int OuterIndex);
                        uint.TryParse(row.Cells[7]?.Value?.ToString(), out uint LegacyBulkDataFlags);

                        FObjectDataResource nuevo = new FObjectDataResource(flags, SerialOffset, DuplicateSerialOffset, SerialSize, RawSize, new FPackageIndex(OuterIndex), LegacyBulkDataFlags);
                        newDR.Add(nuevo);
                    }

                    if (asset.DataResources == null && newDR.Count == 0) break;
                    asset.DataResources = newDR;
                    break;
                case TableHandlerMode.CustomVersionContainer:
                    asset.CustomVersionContainer = new List<CustomVersion>();
                    foreach (DataGridViewRow row in dataGridView1.Rows)
                    {
                        string rawCustomVersion = (string)row.Cells[0].Value;
                        Guid customVersionKey = CustomVersion.UnusedCustomVersionKey;
                        Guid parsedVersionKey = rawCustomVersion.ConvertToGUID();
                        if (parsedVersionKey == Guid.Empty)
                        {
                            customVersionKey = CustomVersion.GetCustomVersionGuidFromFriendlyName(rawCustomVersion);
                        }
                        else
                        {
                            customVersionKey = parsedVersionKey;
                        }
                        if (customVersionKey == CustomVersion.UnusedCustomVersionKey) continue;

                        int customVersionNumber;
                        if (row.Cells[1].Value is string)
                        {
                            if (!int.TryParse((string)row.Cells[1].Value, out customVersionNumber)) continue;
                        }
                        else
                        {
                            customVersionNumber = Convert.ToInt32(row.Cells[1].Value);
                        }

                        asset.CustomVersionContainer.Add(new CustomVersion(customVersionKey, customVersionNumber));
                    }
                    break;
                case TableHandlerMode.ExportData:
                    if (treeView1.SelectedNode is PointingTreeNode pointerNode)
                    {
                        if (pointerNode.Pointer is FStringTable usStrTable)
                        {
                            usStrTable.Clear();
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                DataGridViewRow row = dataGridView1.Rows[i];
                                object val0 = row.Cells[0].Value as string;
                                object val1 = row.Cells[1].Value as string;
                                object val2 = row.Cells[2].Value as string;
                                object val3 = row.Cells[3].Value as string;
                                if (val0 == null || val1 == null || val2 == null || val3 == null) continue;

                                FString key = ((string)val0).FDecode((string)val1);
                                FString value = ((string)val2).FDecode((string)val3);
                                usStrTable.Add(key, value);
                            }

                            pointerNode.Text = (usStrTable.TableNamespace?.ToString() ?? FString.NullCase) + " (" + usStrTable.Count + ")";
                        }
                        else if (pointerNode.Pointer is MapPropertyData usMap)
                        {
                            FName mapKeyType = usMap.KeyType;
                            FName mapValueType = usMap.ValueType;
                            if (usMap.Value.Count != 0)
                            {
                                mapKeyType = asset.HasUnversionedProperties ? FName.DefineDummy(asset, usMap.Value.Keys.ElementAt(0).PropertyType) : new FName(asset, usMap.Value.Keys.ElementAt(0).PropertyType);
                                mapValueType = asset.HasUnversionedProperties ? FName.DefineDummy(asset, usMap.Value[0].PropertyType) : new FName(asset, usMap.Value[0].PropertyType);
                            }

                            if (dataGridView1.Rows.Count > 0)
                            {
                                DataGridViewRow row = dataGridView1.Rows[0];
                                if (row.Cells.Count >= 6 && row.Cells[1].Value != null && row.Cells[4].Value != null && row.Cells[5].Value != null && row.Cells[1].Value.Equals("MapEntry"))
                                {
                                    FName newKey = FName.FromString(asset, row.Cells[4].Value as string);
                                    FName newVal = FName.FromString(asset, row.Cells[5].Value as string);
                                    if (newKey != null) mapKeyType = newKey;
                                    if (newVal != null) mapValueType = newVal;
                                }
                            }

                            // Failsafe
                            if (mapKeyType == null) mapKeyType = FName.FromString(asset, "IntProperty");
                            if (mapValueType == null) mapValueType = FName.FromString(asset, "IntProperty");

                            var newData = new TMap<PropertyData, PropertyData>();
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                DataGridViewRow row = dataGridView1.Rows[i];
                                if (row.Cells.Count <= 1 || row.Cells[1].Value == null || !row.Cells[1].Value.Equals("MapEntry")) continue;

                                if (row.Tag is KeyValuePair<PropertyData, PropertyData> dictBit && dictBit.Key.PropertyType == mapKeyType.Value && dictBit.Value.PropertyType == mapValueType.Value)
                                {
                                    newData.Add(dictBit.Key, dictBit.Value);
                                }
                                else
                                {
                                    var newKeyProp = MainSerializer.TypeToClass(mapKeyType, usMap.Name, null, null, null, asset);
                                    var newValProp = MainSerializer.TypeToClass(mapValueType, usMap.Name, null, null, null, asset);
                                    if (newKeyProp is StructPropertyData) ((StructPropertyData)newKeyProp).StructType = FName.DefineDummy(asset, "Generic");
                                    if (newValProp is StructPropertyData) ((StructPropertyData)newValProp).StructType = FName.DefineDummy(asset, "Generic");
                                    newData.Add(newKeyProp, newValProp);
                                }
                            }
                            usMap.Value = newData;

                            pointerNode.Text = usMap.Name.Value.Value + " (" + usMap.Value.Count + ")";
                        }
                        else if (pointerNode.Pointer is StructPropertyData usStruct)
                        {
                            int newCount = 0;
                            List<PropertyData> newData = new List<PropertyData>();
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                PropertyData val = RowToPD(i, usStruct.Value.ElementAtOrDefault(i), false, asset.HasUnversionedProperties);
                                if (val == null)
                                {
                                    dirtySinceLastLoad = true;
                                    newData.Add(null);
                                    continue;
                                    // deliberately do not increment newCount
                                }
                                newData.Add(val);
                                newCount++;
                            }
                            if (newData[newData.Count - 1] == null) newData.RemoveAt(newData.Count - 1);
                            usStruct.Value = newData;

                            string decidedName = usStruct.Name.Value.Value;
                            if (((PointingTreeNode)pointerNode.Parent).Pointer is PropertyData && ((PropertyData)((PointingTreeNode)pointerNode.Parent).Pointer).Name.Equals(decidedName)) decidedName = usStruct.StructType.Value.Value;
                            pointerNode.Text = decidedName + " (" + newCount + ")";
                        }
                        else if (pointerNode.Pointer is BoxPropertyData box1)
                        {
                            FVector min = new();
                            FVector max = new();
                            byte isValid = 0;
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                if (dataGridView1.Rows[i].Cells.Count < 1) continue;
                                string name = dataGridView1.Rows[i].Cells[0].Value.ToString().Trim();
                                switch (name)
                                {
                                    case "Min":
                                        if (dataGridView1.Rows[i].Cells.Count < 4) continue;
                                        {
                                            double.TryParse(dataGridView1.Rows[i].Cells[1].Value.ToString(), out double val1);
                                            double.TryParse(dataGridView1.Rows[i].Cells[2].Value.ToString(), out double val2);
                                            double.TryParse(dataGridView1.Rows[i].Cells[3].Value.ToString(), out double val3);
                                            min = new(val1, val2, val3);
                                        }
                                        break;
                                    case "Max":
                                        if (dataGridView1.Rows[i].Cells.Count < 4) continue;
                                        {
                                            double.TryParse(dataGridView1.Rows[i].Cells[1].Value.ToString(), out double val1);
                                            double.TryParse(dataGridView1.Rows[i].Cells[2].Value.ToString(), out double val2);
                                            double.TryParse(dataGridView1.Rows[i].Cells[3].Value.ToString(), out double val3);
                                            max = new(val1, val2, val3);
                                        }
                                        break;
                                    case "IsValid":
                                        if (dataGridView1.Rows[i].Cells.Count < 2) continue;
                                        var val = dataGridView1.Rows[i].Cells[1].Value.ToString();
                                        isValid = (val.Equals("1") || val.ToLowerInvariant().Equals("true")) ? (byte)1 : (byte)0;
                                        break;
                                }
                            }
                            box1.Value = new TBox<FVector>(min, max, isValid);
                        }
                        else if (pointerNode.Pointer is Box2DPropertyData box2)
                        {
                            FVector2D min = new();
                            FVector2D max = new();
                            byte isValid = 0;
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                if (dataGridView1.Rows[i].Cells.Count < 1) continue;
                                string name = dataGridView1.Rows[i].Cells[0].Value.ToString().Trim();
                                switch (name)
                                {
                                    case "Min":
                                        if (dataGridView1.Rows[i].Cells.Count < 3) continue;
                                        {
                                            double.TryParse(dataGridView1.Rows[i].Cells[1].Value.ToString(), out double val1);
                                            double.TryParse(dataGridView1.Rows[i].Cells[2].Value.ToString(), out double val2);
                                            min = new(val1, val2);
                                        }
                                        break;
                                    case "Max":
                                        if (dataGridView1.Rows[i].Cells.Count < 3) continue;
                                        {
                                            double.TryParse(dataGridView1.Rows[i].Cells[1].Value.ToString(), out double val1);
                                            double.TryParse(dataGridView1.Rows[i].Cells[2].Value.ToString(), out double val2);
                                            max = new(val1, val2);
                                        }
                                        break;
                                    case "IsValid":
                                        if (dataGridView1.Rows[i].Cells.Count < 2) continue;
                                        var val = dataGridView1.Rows[i].Cells[1].Value.ToString();
                                        isValid = (val.Equals("1") || val.ToLowerInvariant().Equals("true")) ? (byte)1 : (byte)0;
                                        break;
                                }
                            }
                            box2.Value = new TBox<FVector2D>(min, max, isValid);
                        }
                        else if (pointerNode.Pointer is Box2fPropertyData box3)
                        {
                            FVector2f min = new();
                            FVector2f max = new();
                            byte isValid = 0;
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                if (dataGridView1.Rows[i].Cells.Count < 1) continue;
                                string name = dataGridView1.Rows[i].Cells[0].Value.ToString().Trim();
                                switch (name)
                                {
                                    case "Min":
                                        if (dataGridView1.Rows[i].Cells.Count < 3) continue;
                                        {
                                            float.TryParse(dataGridView1.Rows[i].Cells[1].Value.ToString(), out float val1);
                                            float.TryParse(dataGridView1.Rows[i].Cells[2].Value.ToString(), out float val2);
                                            min = new(val1, val2);
                                        }
                                        break;
                                    case "Max":
                                        if (dataGridView1.Rows[i].Cells.Count < 3) continue;
                                        {
                                            float.TryParse(dataGridView1.Rows[i].Cells[1].Value.ToString(), out float val1);
                                            float.TryParse(dataGridView1.Rows[i].Cells[2].Value.ToString(), out float val2);
                                            max = new(val1, val2);
                                        }
                                        break;
                                    case "IsValid":
                                        if (dataGridView1.Rows[i].Cells.Count < 2) continue;
                                        var val = dataGridView1.Rows[i].Cells[1].Value.ToString();
                                        isValid = (val.Equals("1") || val.ToLowerInvariant().Equals("true")) ? (byte)1 : (byte)0;
                                        break;
                                }
                            }
                            box3.Value = new TBox<FVector2f>(min, max, isValid);
                        }
                        else if (pointerNode.Pointer is NormalExport usCat)
                        {
                            switch (pointerNode.Type)
                            {
                                case PointingTreeNodeType.Normal:
                                    List<PropertyData> newData = new List<PropertyData>();
                                    for (int i = 0; i < dataGridView1.Rows.Count; i++)
                                    {
                                        PropertyData val = RowToPD(i, usCat.Data.ElementAtOrDefault(i), false, asset.HasUnversionedProperties);
                                        if (val == null)
                                        {
                                            dirtySinceLastLoad = true;
                                            newData.Add(null);
                                            continue;
                                        }
                                        newData.Add(val);
                                    }
                                    if (newData[newData.Count - 1] == null) newData.RemoveAt(newData.Count - 1);
                                    usCat.Data = newData;
                                    pointerNode.Text = (usCat.ClassIndex.IsImport() ? usCat.ClassIndex.ToImport(asset).ObjectName.Value.Value : usCat.ClassIndex.Index.ToString()) + " (" + usCat.Data.Count + ")";
                                    break;
                                case PointingTreeNodeType.UserDefinedStructData:
                                    UserDefinedStructExport usCatUDS = (UserDefinedStructExport)usCat;
                                    List<PropertyData> newData2 = new List<PropertyData>();
                                    for (int i = 0; i < dataGridView1.Rows.Count; i++)
                                    {
                                        PropertyData val = RowToPD(i, usCatUDS.StructData.ElementAtOrDefault(i), false, asset.HasUnversionedProperties);
                                        if (val == null)
                                        {
                                            dirtySinceLastLoad = true;
                                            newData2.Add(null);
                                            continue;
                                        }
                                        newData2.Add(val);
                                    }
                                    if (newData2[newData2.Count - 1] == null) newData2.RemoveAt(newData2.Count - 1);
                                    usCatUDS.StructData = newData2;
                                    pointerNode.Text = "UserDefinedStruct Data (" + newData2.Count + ")";
                                    break;
                                case PointingTreeNodeType.EnumData:
                                    if (usCat is EnumExport enumCat)
                                    {
                                        enumCat.Enum = new UEnum();
                                        for (int i = 0; i < dataGridView1.Rows.Count; i++)
                                        {
                                            var currRow = dataGridView1.Rows[i];
                                            if (currRow == null || currRow.Cells.Count < 2) continue;

                                            string enumFrontValue = (string)currRow.Cells[0].Value;
                                            string enumValueValue = (string)currRow.Cells[1].Value;
                                            if (enumFrontValue == "CppForm")
                                            {
                                                Enum.TryParse(enumValueValue, out enumCat.Enum.CppForm);
                                            }
                                            else
                                            {
                                                long.TryParse(enumValueValue, out long enumValue);
                                                FName enumEntryName = FName.FromString(asset, enumFrontValue);
                                                if (enumEntryName != null) enumCat.Enum.Names.Add(new Tuple<FName, long>(enumEntryName, enumValue));
                                            }
                                        }
                                    }
                                    break;
                                case PointingTreeNodeType.Kismet:
                                    if (!UAGConfig.Data.EnablePrettyBytecode)
                                    {
                                        try
                                        {
                                            ((StructExport)pointerNode.Pointer).ScriptBytecode = asset.DeserializeJsonObject<KismetExpression[]>(jsonView.Text);
                                        }
                                        catch { }
                                    }
                                    break;
                            }
                        }
                        else if (pointerNode.Pointer is UDataTable dtUs)
                        {
                            int count = 0;
                            List<StructPropertyData> newData = new List<StructPropertyData>();
                            ///var numTimesNameUses = new Dictionary<string, int>();
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                PropertyData val = RowToPD(i, dtUs.Data.ElementAtOrDefault(i), false, false);
                                if (val == null || !(val is StructPropertyData))
                                {
                                    dirtySinceLastLoad = true;
                                    newData.Add(null);
                                    continue;
                                }

                                // Cannot be guaranteed
                                /*if (numTimesNameUses.ContainsKey(val.Name.Value.Value))
                                {
                                    numTimesNameUses[val.Name.Value.Value]++;
                                }
                                else
                                {
                                    numTimesNameUses.Add(val.Name.Value.Value, 0);
                                }
                                val.Name.Number = numTimesNameUses[val.Name.Value.Value];*/
                                newData.Add((StructPropertyData)val);
                                count++;
                            }
                            dtUs.Data = newData;
                            pointerNode.Text = "Table Info (" + count + ")";
                            break;
                        }
                        else if (pointerNode.Pointer is ArrayPropertyData usArr)
                        {
                            int count = 0;
                            List<PropertyData> newData = new List<PropertyData>();
                            List<PropertyData> origArr = usArr.Value.ToList();
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                PropertyData val = RowToPD(i, origArr.ElementAtOrDefault(i), !(origArr.ElementAtOrDefault(i) is StructPropertyData), asset.HasUnversionedProperties, PropertySerializationContext.Array);
                                if (val == null)
                                {
                                    dirtySinceLastLoad = true;
                                    newData.Add(null);
                                    continue;
                                    // deliberately do not increment count
                                }
                                count++;
                                newData.Add(val);
                            }
                            usArr.Value = newData.ToArray();
                            pointerNode.Text = usArr.Name.Value.Value + " (" + count + ")";
                        }
                        else if (pointerNode.Pointer is GameplayTagContainerPropertyData usArr2)
                        {
                            List<FName> newData = new List<FName>();
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                object val = dataGridView1.Rows[i].Cells[0].Value;
                                if (val == null || !(val is string)) continue;
                                newData.Add(FName.FromString(asset, (string)val));
                            }
                            usArr2.Value = newData.ToArray();
                            pointerNode.Text = usArr2.Name.Value.Value + " (" + usArr2.Value.Length + ")";
                        }
                        else if (pointerNode.Pointer is PointingDictionaryEntry usDictEntry)
                        {
                            MapPropertyData parentMap = ((PointingDictionaryEntry)pointerNode.Pointer).Pointer as MapPropertyData;

                            var allKeys = parentMap.Value.Keys.ToArray();
                            int currentEntry = -1;
                            for (int i = 0; i < parentMap.Value.Count; i++)
                            {
                                if (allKeys[i] == usDictEntry.Entry.Key)
                                {
                                    currentEntry = i;
                                    break;
                                }
                            }

                            PropertyData desiredKey = RowToPD(0, usDictEntry.Entry.Key, true, asset.HasUnversionedProperties, PropertySerializationContext.Map);
                            PropertyData desiredValue = RowToPD(1, usDictEntry.Entry.Value, true, asset.HasUnversionedProperties, PropertySerializationContext.Map);

                            if (currentEntry >= 0)
                            {
                                parentMap.Value.RemoveAt(currentEntry);
                                parentMap.Value.Insert(currentEntry, desiredKey, desiredValue);
                            }
                            else
                            {
                                parentMap.Value.Add(desiredKey, desiredValue);
                            }
                        }
                        else if (pointerNode.Pointer is PropertyData[] usRealArrEntry)
                        {
                            List<PropertyData> newData = new List<PropertyData>();
                            List<PropertyData> origArr = usRealArrEntry.ToList();
                            for (int i = 0; i < dataGridView1.Rows.Count; i++)
                            {
                                PropertyData val = RowToPD(i, origArr.ElementAtOrDefault(i), false, asset.HasUnversionedProperties);
                                if (val == null)
                                {
                                    dirtySinceLastLoad = true;
                                    continue;
                                }
                                newData.Add(val);
                            }
                            pointerNode.Pointer = newData.ToArray();
                        }
                    }
                    break;
            }

            if (forceNewLoad)
            {
                Load();
            }
            else
            {
                GetParentForm().UpdateRPC();
                GetParentForm().SetUnsavedChanges(true);
            }
        }

        public TableHandler(DataGridView dataGridView1, UAsset asset, TreeView treeView1, TextBox jsonView)
        {
            this.asset = asset;
            this.dataGridView1 = dataGridView1;
            this.treeView1 = treeView1;
            this.jsonView = jsonView;
            this.mode = 0;
        }
    }
}

```

`UAssetGUI/TextPrompt.Designer.cs`:

```cs
using System.Windows.Forms;

namespace UAssetGUI
{
    partial class TextPrompt
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.mainLabel = new System.Windows.Forms.Label();
            this.gamePathBox = new System.Windows.Forms.TextBox();
            this.cancelButton = new System.Windows.Forms.Button();
            this.okButton = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // mainLabel
            // 
            this.mainLabel.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.mainLabel.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F);
            this.mainLabel.Location = new System.Drawing.Point(12, 13);
            this.mainLabel.Name = "mainLabel";
            this.mainLabel.Size = new System.Drawing.Size(361, 20);
            this.mainLabel.TabIndex = 4;
            this.mainLabel.Text = "Select your game installation directory:";
            this.mainLabel.TextAlign = System.Drawing.ContentAlignment.TopCenter;
            // 
            // gamePathBox
            // 
            this.gamePathBox.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.gamePathBox.Location = new System.Drawing.Point(12, 47);
            this.gamePathBox.Name = "gamePathBox";
            this.gamePathBox.Size = new System.Drawing.Size(361, 20);
            this.gamePathBox.TabIndex = 0;
            this.gamePathBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.TextPrompt_KeyDown);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.cancelButton.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(51)))), ((int)(((byte)(51)))), ((int)(((byte)(51)))));
            this.cancelButton.FlatAppearance.BorderColor = System.Drawing.Color.Black;
            this.cancelButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.cancelButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.cancelButton.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(225)))), ((int)(((byte)(225)))), ((int)(((byte)(225)))));
            this.cancelButton.Location = new System.Drawing.Point(70, 79);
            this.cancelButton.MinimumSize = new System.Drawing.Size(0, 26);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(67, 26);
            this.cancelButton.TabIndex = 3;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = false;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            // 
            // okButton
            // 
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.okButton.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(51)))), ((int)(((byte)(51)))), ((int)(((byte)(51)))));
            this.okButton.FlatAppearance.BorderColor = System.Drawing.Color.Black;
            this.okButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.okButton.Font = new System.Drawing.Font("Arial", 8F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.okButton.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(225)))), ((int)(((byte)(225)))), ((int)(((byte)(225)))));
            this.okButton.Location = new System.Drawing.Point(15, 79);
            this.okButton.MinimumSize = new System.Drawing.Size(0, 26);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(49, 26);
            this.okButton.TabIndex = 2;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = false;
            this.okButton.Click += new System.EventHandler(this.okButton_Click);
            // 
            // TextPrompt
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(40)))), ((int)(((byte)(42)))), ((int)(((byte)(45)))));
            this.ClientSize = new System.Drawing.Size(385, 114);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.okButton);
            this.Controls.Add(this.gamePathBox);
            this.Controls.Add(this.mainLabel);
            this.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(225)))), ((int)(((byte)(225)))), ((int)(((byte)(225)))));
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.MaximizeBox = false;
            this.Name = "TextPrompt";
            this.Text = "InitialPathPrompt";
            this.Load += new System.EventHandler(this.InitialPathPrompt_Load);
            this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.TextPrompt_KeyDown);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label mainLabel;
        private System.Windows.Forms.TextBox gamePathBox;
        private Button okButton;
        private Button cancelButton;
    }
}
```

`UAssetGUI/TextPrompt.cs`:

```cs
using System;
using System.Drawing;
using System.Windows.Forms;

namespace UAssetGUI
{

    public partial class TextPrompt : Form
    {
        public string DisplayText = null;
        public string OutputText = null;
        public string PrefilledText = null;
        public bool AllowEmptyText = false;

        public TextPrompt()
        {
            InitializeComponent();
        }

        private void InitialPathPrompt_Load(object sender, EventArgs e)
        {
            mainLabel.Text = DisplayText;
            if (this.Owner is Form1 parentForm)
            {
                this.Text = parentForm.Text;
            }
            if (this.Owner is FileContainerForm parentForm2)
            {
                this.Text = parentForm2.Text;
            }
            UAGPalette.RefreshTheme(this);
            this.AdjustFormPosition();
            gamePathBox.Size = new Size(this.ClientSize.Width - 24, gamePathBox.ClientSize.Height);

            if (!string.IsNullOrEmpty(PrefilledText))
            {
                gamePathBox.Text = PrefilledText;
            }
        }

        private void RunOKButton()
        {
            if (AllowEmptyText || (gamePathBox.Text != null && gamePathBox.Text.Length > 0))
            {
                OutputText = gamePathBox.Text;
                this.DialogResult = DialogResult.OK;
                this.Close();
            }
        }

        private void okButton_Click(object sender, EventArgs e)
        {
            RunOKButton();
        }

        private void RunCancelButton()
        {
            OutputText = null;
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            RunCancelButton();
        }

        private void TextPrompt_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Return)
            {
                RunOKButton();
            }
            else if (e.KeyCode == Keys.Escape)
            {
                RunCancelButton();
            }
        }
    }
}

```

`UAssetGUI/TextPrompt.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UAssetGUI/UAGConfig.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using UAssetAPI;
using UAssetAPI.Unversioned;

namespace UAssetGUI
{
    public struct UAGConfigData
    {
        public string PreferredVersion;
        public string PreferredMappings;
        public string Theme;
        public string MapStructTypeOverride;
        public string FavoriteThing;
        public int DataZoom;
        public bool ChangeValuesOnScroll;
        public bool EnableDynamicTree;
        public bool EnableDiscordRPC;
        public bool DoubleClickToEdit;
        public bool EnableBak;
        public bool RestoreSize;
        public bool EnableUpdateNotice;
        public bool EnablePrettyBytecode;
        public int StartupWidth;
        public int StartupHeight;
        public int CustomSerializationFlags;
        public bool EnableBakJson;
        public bool AllowUntrustedScripts;
        public string RetocExtraCommands;

        public UAGConfigData()
        {
            PreferredVersion = string.Empty;
            Theme = string.Empty;
            MapStructTypeOverride = string.Empty;
            FavoriteThing = string.Empty;
            DataZoom = 0;
            ChangeValuesOnScroll = true;
            EnableDynamicTree = true;
            EnableDiscordRPC = true;
            DoubleClickToEdit = true;
            EnableBak = true;
            RestoreSize = true;
            EnableUpdateNotice = true;
            EnablePrettyBytecode = true;
            StartupWidth = 1000;
            StartupHeight = 700;
            CustomSerializationFlags = 0;
            EnableBakJson = false;
            AllowUntrustedScripts = false;
            RetocExtraCommands = string.Empty;
        }
    }

    public static class UAGConfig
    {
        public static UAGConfigData Data;
        public static Dictionary<string, string> AllMappings = new Dictionary<string, string>();
        public static List<string> AllScriptIDs = new List<string>();

        public readonly static string ConfigFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "UAssetGUI");
        public readonly static string MappingsFolder = Path.Combine(ConfigFolder, "Mappings");
        public readonly static string StagingFolder = Path.Combine(ConfigFolder, "Staging");
        public readonly static string ExtractedFolder = Path.Combine(ConfigFolder, "Extracted");
        public readonly static string ScriptsFolder = Path.Combine(ConfigFolder, "Scripts");
        public readonly static string TempFolder = Path.Combine(Path.GetTempPath(), "UAssetGUI");

        internal static bool DifferentStagingPerPak = false;

        public static void LoadMappings()
        {
            Directory.CreateDirectory(ConfigFolder);
            Directory.CreateDirectory(MappingsFolder);

            AllMappings.Clear();
            string[] allMappingFiles = Directory.GetFiles(MappingsFolder, "*.usmap", SearchOption.TopDirectoryOnly);
            foreach (string mappingPath in allMappingFiles)
            {
                AllMappings.Add(Path.GetFileNameWithoutExtension(mappingPath), mappingPath);
            }
        }

        public static string GetStagingDirectory(string pakPath)
        {
            string rootDir = DifferentStagingPerPak ? Path.Combine(StagingFolder, Path.GetFileNameWithoutExtension(pakPath)) : StagingFolder;
            Directory.CreateDirectory(rootDir);
            return rootDir;
        }

        public static string[] GetStagingFiles(string pakPath, out string[] fixedPathsOnDisk)
        {
            string rootDir = GetStagingDirectory(pakPath);

            fixedPathsOnDisk = Directory.GetFiles(rootDir, "*.*", SearchOption.AllDirectories);
            string[] res = new string[fixedPathsOnDisk.Length]; Array.Copy(fixedPathsOnDisk, res, fixedPathsOnDisk.Length);
            for (int i = 0; i < res.Length; i++)
            {
                res[i] = res[i].Replace(Path.DirectorySeparatorChar, '/').Substring(rootDir.Length).TrimStart('/');
            }

            return res;
        }

        public static void StageFile(string rawPathOnDisk, string CurrentContainerPath, string newPath = null)
        {
            if (newPath == null) newPath = Path.GetFileName(rawPathOnDisk);
            newPath = newPath.Replace('/', Path.DirectorySeparatorChar);

            var finalPath = DifferentStagingPerPak ? Path.Combine(StagingFolder, Path.GetFileNameWithoutExtension(CurrentContainerPath), newPath) : Path.Combine(StagingFolder, newPath);
            try { Directory.CreateDirectory(Path.GetDirectoryName(finalPath)); } catch { return; } // fail silently if cant make the directory we need

            UAGUtils.DeleteDirectoryQuick(finalPath, true);

            File.Copy(rawPathOnDisk, finalPath, true);
            try { File.Copy(Path.ChangeExtension(rawPathOnDisk, ".uexp"), Path.ChangeExtension(finalPath, ".uexp"), true); } catch { }
            try { File.Copy(Path.ChangeExtension(rawPathOnDisk, ".ubulk"), Path.ChangeExtension(finalPath, ".ubulk"), true); } catch { }
        }

        public static void StageFile(DirectoryTreeItem item, InteropType interopType, string newPath = null)
        {
            // recursive if we were given a directory
            if (!item.IsFile)
            {
                foreach (var child in item.Children) StageFile(child.Value, interopType, newPath == null ? null : Path.Combine(newPath, child.Value.Name));
                return;
            }

            if (newPath == null) newPath = item.FullPath;
            newPath = newPath.Replace('/', Path.DirectorySeparatorChar);

            string outputPath = item.SaveFileToTemp(interopType);
            var finalPath = DifferentStagingPerPak ? Path.Combine(StagingFolder, Path.GetFileNameWithoutExtension(item.ParentForm.CurrentContainerPath), newPath) : Path.Combine(StagingFolder, newPath);
            if (outputPath == null || finalPath == null) return;
            try { Directory.CreateDirectory(Path.GetDirectoryName(finalPath)); } catch { return; } // fail silently if cant make the directory we need

            UAGUtils.DeleteDirectoryQuick(finalPath, true); // if we turn a directory into a file, try and get rid of the directory

            UAGUtils.CopyFileQuick(outputPath, finalPath, true);
            UAGUtils.CopyFileQuick(Path.ChangeExtension(outputPath, ".uexp"), Path.ChangeExtension(finalPath, ".uexp"), true);
            UAGUtils.CopyFileQuick(Path.ChangeExtension(outputPath, ".ubulk"), Path.ChangeExtension(finalPath, ".ubulk"), true);
            UAGUtils.DeleteFileQuick(outputPath);
            UAGUtils.DeleteFileQuick(Path.ChangeExtension(outputPath, ".uexp"));
            UAGUtils.DeleteFileQuick(Path.ChangeExtension(outputPath, ".ubulk"));
        }

        public static string ExtractFile(DirectoryTreeItem item, InteropType interopType, FileStream stream2 = null, PakReader reader2 = null)
        {
            var finalPath = Path.Combine(ExtractedFolder, item.FullPath.Replace('/', Path.DirectorySeparatorChar));

            // recursive if we were given a directory
            if (!item.IsFile)
            {
                foreach (var child in item.Children) ExtractFile(child.Value, interopType, stream2, reader2);
                return finalPath;
            }

            return item.SaveFileToTemp(interopType, ExtractedFolder, stream2, reader2);
        }

        public static bool TryGetMappings(string name, out Usmap mappings)
        {
            if (AllMappings.TryGetValue(name, out string value))
            {
                try
                {
                    mappings = new Usmap(value);
                    return true;
                }
                catch 
                {
                    UAGUtils.InvokeUI(() =>
                    {
                        MessageBox.Show("Failed to parse mappings: " + name, "Notice");

                        // update list of mappings for good measure
                        foreach (var form in Application.OpenForms)
                        {
                            if (form is Form1 form1)
                            {
                                form1.UpdateMappings("No mappings", false);
                            }
                        }
                    });
                }
            }

            mappings = null;
            return false;
        }
        
        public static void RefreshAllScriptIDs()
        {
            Directory.CreateDirectory(ScriptsFolder);
            AllScriptIDs = Directory.GetFiles(ScriptsFolder, "*.cs", SearchOption.TopDirectoryOnly).Select(x => Path.GetFileNameWithoutExtension(x)).ToList();
            if (AllScriptIDs.Count == 0)
            {
                InstallBuiltInScripts();
            }

            UAGUtils.InvokeUI(() =>
            {
                foreach (var form in Application.OpenForms)
                {
                    if (form is Form1 form1)
                    {
                        {
                            List<ToolStripItem> subScriptItems = new List<ToolStripItem>();
                            foreach (string scriptID in AllScriptIDs)
                            {
                                ToolStripMenuItem newItem = new ToolStripMenuItem()
                                {
                                    Name = "executeScriptToolStripMenuItemSubScriptItem_" + scriptID,
                                    Size = form1.executeScriptToolStripMenuItem.Size,
                                    Text = scriptID.Replace('_', ' '),
                                    Tag = scriptID
                                };
                                newItem.Click += form1.executeScriptSubItem_Click;
                                subScriptItems.Add(newItem);
                            }
                            ToolStripMenuItem newItem2 = new ToolStripMenuItem()
                            {
                                Name = "executeScriptToolStripMenuItemSubScriptItem_New",
                                Size = form1.executeScriptToolStripMenuItem.Size,
                                Text = "Add new script...",
                            };
                            newItem2.Click += form1.executeScriptNewItem_Click;
                            subScriptItems.Add(newItem2);

                            form1.executeScriptToolStripMenuItem.DropDownItems.Clear();
                            form1.executeScriptToolStripMenuItem.DropDownItems.AddRange(subScriptItems.ToArray());
                        }
                        {
                            List<ToolStripItem> subScriptItems = new List<ToolStripItem>();
                            foreach (string scriptID in AllScriptIDs)
                            {
                                ToolStripMenuItem newItem = new ToolStripMenuItem()
                                {
                                    Name = "editScriptToolStripMenuItemSubScriptItem_" + scriptID,
                                    Size = form1.editScriptToolStripMenuItem.Size,
                                    Text = scriptID.Replace('_', ' '),
                                    Tag = scriptID
                                };
                                newItem.Click += form1.editScriptSubItem_Click;
                                subScriptItems.Add(newItem);
                            }
                            ToolStripMenuItem newItem2 = new ToolStripMenuItem()
                            {
                                Name = "editScriptToolStripMenuItemSubScriptItem_New",
                                Size = form1.editScriptToolStripMenuItem.Size,
                                Text = "Add new script...",
                            };
                            newItem2.Click += form1.executeScriptNewItem_Click;
                            subScriptItems.Add(newItem2);

                            form1.editScriptToolStripMenuItem.DropDownItems.Clear();
                            form1.editScriptToolStripMenuItem.DropDownItems.AddRange(subScriptItems.ToArray());
                        }

                        form1.executeScriptToolStripMenuItem.Enabled = UAGConfig.Data.AllowUntrustedScripts;
                        form1.editScriptToolStripMenuItem.Enabled = UAGConfig.Data.AllowUntrustedScripts;

                        UAGPalette.RefreshTheme(form1);
                    }
                }
            });
        }

        public static string GetScriptTextByID(string id)
        {
            Directory.CreateDirectory(ScriptsFolder);
            try
            {
                return File.ReadAllText(Path.ChangeExtension(Path.Combine(ScriptsFolder, id), "cs"));
            }
            catch
            {
                return null;
            }
        }

        public static string CreateAndReturnPathToScript(string id)
        {
            string newScriptPath = Path.ChangeExtension(Path.Combine(ScriptsFolder, id), "cs");
            if (File.Exists(newScriptPath)) return newScriptPath;
            try
            {
                File.WriteAllText(newScriptPath, Properties.Resources.Hello_world);
                RefreshAllScriptIDs();
                return newScriptPath;
            }
            catch
            {
                return null;
            }
        }

        public static bool InstallBuiltInScripts()
        {
            try
            {
                File.WriteAllText(Path.ChangeExtension(Path.Combine(ScriptsFolder, "Hello_world"), "cs"), Properties.Resources.Hello_world);
                File.WriteAllText(Path.ChangeExtension(Path.Combine(ScriptsFolder, "Set_all_visible_floats_to_100"), "cs"), Properties.Resources.Set_all_visible_floats_to_100);

                RefreshAllScriptIDs();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public static void Save()
        {
            SaveCustomFile("config.json", JsonConvert.SerializeObject(Data, Formatting.Indented));
        }

        public static string SaveCustomFile(string name, string text, string subFolder = null)
        {
            string outPath = Path.Combine(ConfigFolder, name);
            if (!string.IsNullOrEmpty(subFolder)) outPath = Path.Combine(ConfigFolder, subFolder, name);

            Directory.CreateDirectory(Path.GetDirectoryName(outPath));
            File.WriteAllText(outPath, text);

            return outPath;
        }

        public static void Load()
        {
            try
            {
                Directory.CreateDirectory(ConfigFolder);
                Data = JsonConvert.DeserializeObject<UAGConfigData>(File.ReadAllText(Path.Combine(ConfigFolder, "config.json")));
            }
            catch
            {
                Data = new UAGConfigData();
                Save();
            }
        }
    }
}

```

`UAssetGUI/UAGPalette.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;

namespace UAssetGUI
{
    public class UAGMenuStripRenderer : ToolStripProfessionalRenderer
    {
        protected override void OnRenderMenuItemBackground(ToolStripItemRenderEventArgs e)
        {
            UAGUtils.InvokeUI(() =>
            {
                if (!e.Item.Selected && !Form1.IsDropDownOpened(e.Item) && !FileContainerForm.IsDropDownOpened(e.Item))
                {
                    e.Item.ForeColor = UAGPalette.ForeColor;
                    base.OnRenderMenuItemBackground(e);
                }
                else
                {
                    e.Item.ForeColor = UAGPalette.HighlightForeColor;
                    e.Graphics.FillRectangle(new SolidBrush(UAGPalette.HighlightBackColor), new Rectangle(Point.Empty, e.Item.Size));
                }
            });
        }
    }


    public static class UAGPalette
    {
        public static Color BackColor = Color.White;
        public static Color ButtonBackColor = Color.FromArgb(240, 240, 240);
        public static Color ForeColor = Color.Black;
        public static Color HighlightBackColor = SystemColors.Highlight;
        public static Color HighlightForeColor = SystemColors.HighlightText;
        public static Color InactiveColor = Color.FromArgb(211, 211, 211);
        public static Color DataGridViewActiveColor = Color.FromArgb(240, 240, 240);
        public static Color LinkColor = Color.Blue;
        private static UAGTheme CurrentTheme = UAGTheme.Light;

        public static void InitializeTheme()
        {
            if (!string.IsNullOrEmpty(UAGConfig.Data.Theme)) Enum.TryParse(UAGConfig.Data.Theme, out CurrentTheme);
        }

        public static UAGTheme GetCurrentTheme()
        {
            return CurrentTheme;
        }

        public static void SetCurrentTheme(UAGTheme newTheme)
        {
            CurrentTheme = newTheme;
            UAGConfig.Data.Theme = CurrentTheme.ToString();
            UAGConfig.Save();
        }

        public static void RefreshTheme(Form frm)
        {
            UAGUtils.InvokeUI(() =>
            {
                RefreshThemeInternal(frm);
            });
        }

        /// <summary>
        /// null = check based on favorite thing, false = force no comic sans, true = force yes comic sans
        /// </summary>
        public static bool? IsComicSansOverride = null;
        public static bool IsComicSans()
        {
            if (IsComicSansOverride != null) return (bool)IsComicSansOverride;
            return UAGConfig.Data.FavoriteThing.ToLowerInvariant().Trim().StartsWith("comic sans");
        }


        private static Dictionary<Control, Font> oldFontSettings = null;
        private static void RefreshAllButtonsInControl(this Control ctrl, out bool needRefreshForComicSans)
        {
            needRefreshForComicSans = false;
            foreach (Control ctrl2 in ctrl.Controls)
            {
                if (ctrl2 is Button butto)
                {
                    butto.FlatStyle = FlatStyle.Flat;
                    butto.ForeColor = UAGPalette.ForeColor;
                    butto.FlatAppearance.BorderColor = UAGPalette.ForeColor;
                    butto.FlatAppearance.BorderSize = 1;
                    butto.BackColor = UAGPalette.ButtonBackColor;
                    butto.MinimumSize = new Size(0, 10);
                }
                if (ctrl2 is ComboBox combo)
                {
                    combo.ForeColor = UAGPalette.ForeColor;
                    combo.BackColor = UAGPalette.ButtonBackColor;
                    combo.FlatStyle = CurrentTheme == UAGTheme.Light ? FlatStyle.Standard : FlatStyle.Flat;
                }
                if (ctrl2 is GroupBox gp)
                {
                    gp.ForeColor = UAGPalette.ForeColor;
                }

                if (IsComicSans())
                {
                    if (oldFontSettings == null) oldFontSettings = new Dictionary<Control, Font>();
                    if (ctrl2.Font.FontFamily.Name != "Comic Sans MS")
                    {
                        oldFontSettings[ctrl2] = ctrl2.Font;
                        needRefreshForComicSans = true;
                    }
                    ctrl2.Font = new Font("Comic Sans MS", ctrl2.Font.Size, ctrl2.Font.Style);
                }
                else if (oldFontSettings != null)
                {
                    if (oldFontSettings.ContainsKey(ctrl2) && oldFontSettings[ctrl2] != null)
                    {
                        ctrl2.Font = oldFontSettings[ctrl2];
                        needRefreshForComicSans = true;
                    }
                    oldFontSettings[ctrl2] = null;
                }

                RefreshAllButtonsInControl(ctrl2, out bool needRefreshForComicSansInner);
                if (needRefreshForComicSansInner) needRefreshForComicSans = true;
            }
        }

        public static float RecommendedFontSize
        {
            get
            {
                return 8.25f + (float)UAGConfig.Data.DataZoom;
            }
        }

        private static void AdjustDGV(DataGridView dgv)
        {
            Color selectedDGVBackColor = dgv.Columns.Count > 0 ? UAGPalette.DataGridViewActiveColor : UAGPalette.InactiveColor;
            dgv.BackgroundColor = selectedDGVBackColor;
            dgv.ColumnHeadersDefaultCellStyle.Font = new Font(dgv.ColumnHeadersDefaultCellStyle.Font.FontFamily, RecommendedFontSize, dgv.ColumnHeadersDefaultCellStyle.Font.Style);
            dgv.ColumnHeadersDefaultCellStyle.BackColor = UAGPalette.BackColor; // intentional
            dgv.ColumnHeadersDefaultCellStyle.ForeColor = UAGPalette.ForeColor;
            dgv.ColumnHeadersDefaultCellStyle.SelectionBackColor = UAGPalette.HighlightBackColor;
            dgv.ColumnHeadersDefaultCellStyle.SelectionForeColor = UAGPalette.HighlightForeColor;
            dgv.RowHeadersDefaultCellStyle = dgv.ColumnHeadersDefaultCellStyle;
            dgv.DefaultCellStyle = dgv.ColumnHeadersDefaultCellStyle;

            int defaultNeededRowHeight = (int)(dgv.ColumnHeadersDefaultCellStyle.Font.Height * 1.5f);
            dgv.RowTemplate.MinimumHeight = defaultNeededRowHeight > 22 ? defaultNeededRowHeight : 22;
            dgv.RowTemplate.Height = dgv.RowTemplate.MinimumHeight;
        }

        private static void AdjustTreeView(ColorfulTreeView treeView1)
        {
            Color selectedListViewBackColor = treeView1.Nodes.Count > 0 ? UAGPalette.BackColor : UAGPalette.InactiveColor;
            treeView1.BackColor = selectedListViewBackColor;
            treeView1.ForeColor = UAGPalette.ForeColor;
            treeView1.Font = new Font(treeView1.Font.FontFamily, 8.25f + (float)UAGConfig.Data.DataZoom, treeView1.Font.Style);
        }

        private static void AdjustMenuStrip(MenuStrip menuStrip1)
        {
            menuStrip1.BackColor = UAGPalette.BackColor;
            menuStrip1.ForeColor = UAGPalette.ForeColor;
            foreach (ToolStripItem rootItem in menuStrip1.Items)
            {
                rootItem.BackColor = UAGPalette.BackColor;
                rootItem.ForeColor = UAGPalette.ForeColor;
                if (rootItem is ToolStripMenuItem rootMenuItem)
                {
                    foreach (ToolStripItem childItem in rootMenuItem.DropDownItems)
                    {
                        childItem.BackColor = UAGPalette.BackColor;
                        childItem.ForeColor = UAGPalette.ForeColor;
                        if (childItem is ToolStripMenuItem childItem_tsmi && childItem_tsmi.DropDownItems != null)
                        {
                            foreach (ToolStripItem childItem2 in childItem_tsmi.DropDownItems)
                            {
                                childItem2.BackColor = UAGPalette.BackColor;
                                childItem2.ForeColor = UAGPalette.ForeColor;
                            }
                        }
                    }
                }
            }
        }

        public static readonly int InitialSplitterDistance = 408;
        private static void RefreshThemeInternal(Form frm)
        {
            switch (CurrentTheme)
            {
                case UAGTheme.Light:
                    BackColor = Color.White;
                    ButtonBackColor = Color.FromArgb(240, 240, 240);
                    ForeColor = Color.Black;
                    HighlightBackColor = SystemColors.Highlight;
                    HighlightForeColor = SystemColors.HighlightText;
                    InactiveColor = Color.FromArgb(211, 211, 211);
                    DataGridViewActiveColor = Color.FromArgb(240, 240, 240);
                    LinkColor = Color.Blue;
                    break;
                case UAGTheme.Dark:
                    BackColor = Color.FromArgb(46, 46, 46);
                    ButtonBackColor = Color.FromArgb(61, 61, 61);
                    ForeColor = Color.White;
                    HighlightBackColor = Color.FromArgb(250, 148, 46);
                    HighlightForeColor = BackColor;
                    InactiveColor = Color.FromArgb(45, 45, 45);
                    DataGridViewActiveColor = Color.FromArgb(35, 35, 35);
                    LinkColor = Color.FromArgb(250, 148, 46);
                    break;
            }

            frm.RefreshAllButtonsInControl(out bool needRefreshForComicSans);

            frm.Icon = Properties.Resources.icon;
            frm.BackColor = UAGPalette.BackColor;
            frm.ForeColor = UAGPalette.ForeColor;
            if (frm is Form1 frm1)
            {
                AdjustTreeView(frm1.treeView1);
                AdjustMenuStrip(frm1.menuStrip1);

                frm1.jsonView.ForeColor = UAGPalette.ForeColor;
                frm1.jsonView.BackColor = UAGPalette.BackColor;
                frm1.jsonView.Font = new Font(frm1.jsonView.Font.FontFamily, RecommendedFontSize, frm1.jsonView.Font.Style);

                // ByteViewer has no support for changing the background color
                frm1.byteView1.ForeColor = Color.Black;
                frm1.byteView1.BackColor = Color.White;

                AdjustDGV(frm1.dataGridView1);

                // reset splitter if comic sans
                if (needRefreshForComicSans)
                {
                    frm1.splitContainer1.SplitterDistance = InitialSplitterDistance;
                }

                /*if (frm1.tableEditor != null)
                {
                    frm1.tableEditor.Save(true);
                }*/
            }
            if (frm is FileContainerForm frm3)
            {
                AdjustTreeView(frm3.saveTreeView);
                AdjustTreeView(frm3.loadTreeView);
                AdjustMenuStrip(frm3.menuStrip1);
            }
            if (frm is MapStructTypeOverrideForm frm2)
            {
                AdjustDGV(frm2.mstoDataGridView);
            }

            // fix some strange formatting issues with the comic sans easter egg
            // could just always execute this, but just in case this has other undesired effects, only execute it when needed
            // (not actually that big a deal if the comic sans easter egg breaks something, but a big deal if we break something else just to fix the easter egg...)
            if (frm is SettingsForm frm4 && needRefreshForComicSans)
            {
                frm4.numericUpDown1.Location = new Point(frm4.favoriteThingBox.Location.X, frm4.label3.Location.Y);
                frm4.numericUpDown1.Size = frm4.favoriteThingBox.Size;
                frm4.customSerializationFlagsBox.Location = new Point(frm4.favoriteThingBox.Location.X, frm4.label4.Location.Y);
                frm4.customSerializationFlagsBox.Size = frm4.favoriteThingBox.Size;
            }
        }
    }
}

```

`UAssetGUI/UAGTheme.cs`:

```cs
namespace UAssetGUI
{
    public enum UAGTheme
    {
        Light,
        Dark
    }
}

```

`UAssetGUI/UAGUtils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Reflection;
using System.Text;
using System.Windows.Forms;
using UAssetAPI;
using UAssetAPI.UnrealTypes;

namespace UAssetGUI
{
    public static class UAGUtils
    {
        internal static string _displayVersion = string.Empty;

        public static T TryGetElement<T>(this T[] array, int index)
        {
            if (array != null && index < array.Length)
            {
                return array[index];
            }
            return default(T);
        }

        public static object ArbitraryTryParse(this string input, Type type)
        {
            try
            {
                var converter = TypeDescriptor.GetConverter(type);
                if (converter != null)
                {
                    return converter.ConvertFromString(input);
                }
            }
            catch (NotSupportedException) { }
            return null;
        }

        public static ContextMenuStrip MergeContextMenus(ContextMenuStrip one, ContextMenuStrip two)
        {
            if (one == null) return two;
            if (two == null) return one;

            one.Items.AddRange(two.Items);
            return one;
        }

        // ((Form1)x.DataGridView.Parent).nameMapContext;
        public static void UpdateContextMenuStripOfRow(DataGridViewRow x, ContextMenuStrip strip)
        {
            x.ContextMenuStrip = MergeContextMenus(x.ContextMenuStrip, strip);
            x.HeaderCell.ContextMenuStrip = MergeContextMenus(x.HeaderCell.ContextMenuStrip, strip);
            foreach (DataGridViewCell y in x.Cells)
            {
                y.ContextMenuStrip = MergeContextMenus(y.ContextMenuStrip, strip);
            }
        }

        public static void AdjustFormPosition(this Form frm1, Form overrideOwner = null)
        {
            if (overrideOwner == null) overrideOwner = frm1.Owner;
            if (overrideOwner != null) frm1.Location = new Point((overrideOwner.Location.X + overrideOwner.Width / 2) - (frm1.Width / 2), (overrideOwner.Location.Y + overrideOwner.Height / 2) - (frm1.Height / 2));
        }

        public static void UpdateObjectPropertyValues(UAsset asset, DataGridViewRow row, DataGridView dgv, FPackageIndex objData, int column = 3)
        {
            if (dgv == null || row == null || objData == null) return;

            bool underlineStyle = false;
            if (objData.IsImport() && objData == null)
            {
                row.Cells[column].Value = string.Empty;
            }
            else
            {
                row.Cells[column].Value = objData.IsExport() ? "Jump" : (objData.IsImport() ? objData.ToImport(asset)?.ObjectName?.ToString() : string.Empty);
                row.Cells[column].Tag = "CategoryJump";
                if (objData.IsExport()) underlineStyle = true;
            }
            row.Cells[column].ReadOnly = objData.IsImport();

            DataGridViewCellStyle sty = new DataGridViewCellStyle();
            if (underlineStyle)
            {
                Font styFont = new Font(dgv.Font.Name, UAGPalette.RecommendedFontSize, FontStyle.Underline);
                sty.Font = styFont;
                sty.ForeColor = UAGPalette.LinkColor;
            }
            row.Cells[column].Style = sty;
        }

        public static T[] StripNullsFromArray<T>(this T[] usArr)
        {
            int c = 0;
            for (int num = 0; num < usArr.Length; num++)
            {
                if (usArr[num] != null) c++;
            }

            var newData = new T[c];
            int indexAdded = 0;
            for (int num = 0; num < usArr.Length; num++)
            {
                if (usArr[num] != null) newData[indexAdded++] = usArr[num];
            }
            return newData;
        }

        public static List<T> StripNullsFromList<T>(this List<T> usList)
        {
            for (int num = 0; num < usList.Count; num++)
            {
                if (usList[num] == null)
                {
                    usList.RemoveAt(num);
                    num--;
                }
            }
            return usList;
        }

        public static string ConvertByteArrayToString(this byte[] val)
        {
            if (val == null) return "";
            return BitConverter.ToString(val).Replace("-", " ");
        }

        public static byte[] ConvertStringToByteArray(this string val)
        {
            if (string.IsNullOrWhiteSpace(val)) return Array.Empty<byte>();
            string[] rawStringArr = val.Split(' ');
            byte[] byteArr = new byte[rawStringArr.Length];
            for (int i = 0; i < rawStringArr.Length; i++) byteArr[i] = Convert.ToByte(rawStringArr[i], 16);
            return byteArr;
        }

        public static string ShortcutToText(Keys shortcutKeys)
        {
            return TypeDescriptor.GetConverter(typeof(Keys)).ConvertToString(shortcutKeys);
        }

        /*
            UAssetGUI versions are formatted as follows: MAJOR.MINOR.BUILD
            * MAJOR - incremented for very big changes or backwards-incompatible changes
            * MINOR - incremented for notable changes
            * BUILD - incremented for bug fixes or very small improvements
        */
        public static bool IsUAGVersionLower(this Version v1)
        {
            Version fullUagVersion = new Version(Assembly.GetExecutingAssembly().GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion);
            return v1.CompareTo(fullUagVersion) > 0;
        }

        public static string FEncode(this FString val)
        {
            if (val == null) return FString.NullCase;
            return val.Value.Replace("\n", "\\n").Replace("\r", "\\r");
        }

        public static FString FDecode(this string val, string encodingHeaderName)
        {
            if (val == FString.NullCase) return null;
            return FString.FromString(val.Replace("\\n", "\n").Replace("\\r", "\r"), encodingHeaderName.Equals(Encoding.Unicode.HeaderName) ? Encoding.Unicode : Encoding.UTF8);
        }

        public static bool DeleteDirectoryQuick(string path, bool recursive)
        {
            try
            {
                if (!Directory.Exists(path)) return false;
                Directory.Delete(path, recursive);
                return true;
            }
            catch
            {
                return false;
            }
        }

        public static bool DeleteFileQuick(string path)
        {
            try
            {
                if (!File.Exists(path)) return false;
                File.Delete(path);
                return true;
            }
            catch
            {
                return false;
            }
        }

        public static bool MoveFileQuick(string source, string dest, bool overwrite)
        {
            try
            {
                if (!File.Exists(source)) return false;
                if (!overwrite && File.Exists(dest)) return false;
                File.Move(source, dest, overwrite);
                return true;
            }
            catch
            {
                return false;
            }
        }

        public static bool CopyFileQuick(string source, string dest, bool overwrite)
        {
            try
            {
                if (!File.Exists(source)) return false;
                if (!overwrite && File.Exists(dest)) return false;
                File.Copy(source, dest, overwrite);
                return true;
            }
            catch
            {
                return false;
            }
        }

        public static void OpenURL(string url)
        {
            Process.Start(new ProcessStartInfo(url) { UseShellExecute = true });
        }

        public static void OpenDirectory(string dir)
        {
            Process.Start(new ProcessStartInfo()
            {
                FileName = dir,
                UseShellExecute = true,
                Verb = "open"
            });
        }

        private static Control internalForm;
        public static void InitializeInvoke(Control control)
        {
            internalForm = control;
        }

        public static bool InvokeUI(Action act)
        {
            if (internalForm == null) return false;
            if (internalForm.InvokeRequired)
            {
                internalForm.Invoke(act);
            }
            else
            {
                act();
            }
            return true;
        }
    }
}

```

`UAssetGUI/UAssetGUI.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <ProjectGuid>{88A998F1-C512-416F-ADED-120E50AFE6F3}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <PublishSingleFile>true</PublishSingleFile>
    <SelfContained>false</SelfContained>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <AssemblyTitle>UAssetGUI</AssemblyTitle>
    <Product>UAssetGUI</Product>
    <Copyright>Copyright © Atenfyr 2024</Copyright>
    <AssemblyVersion>1.0.4.0</AssemblyVersion>
    <FileVersion>1.0.4.0</FileVersion>
    <OutputPath>bin\$(Configuration)\</OutputPath>
    <Configurations>Debug;Release;DebugVerbose;DebugTracing;ReleaseX</Configurations>
    <UseWindowsForms>true</UseWindowsForms>
    <SatelliteResourceLanguages>en</SatelliteResourceLanguages>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <IncludeSourceRevisionInInformationalVersion>false</IncludeSourceRevisionInInformationalVersion>
    <Platforms>AnyCPU;x86</Platforms>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|AnyCPU'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugTracing|AnyCPU'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugTracing|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>embedded</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseX|AnyCPU'">
    <DebugType>embedded</DebugType>
    <Optimize>True</Optimize>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'">
    <DebugType>embedded</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseX|x86'">
    <DebugType>embedded</DebugType>
    <Optimize>True</Optimize>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>Resources\icon.ico</ApplicationIcon>
    <GenerateResourceUsePreserializedResources>true</GenerateResourceUsePreserializedResources>
    <Version>1.0.4</Version>
  </PropertyGroup>
  <Target Name="BeforeBuildMigrated" BeforeTargets="PreBuildEvent">
    <Exec ContinueOnError="true" ConsoleToMsBuild="true" Command="git rev-parse --short HEAD">
      <Output TaskParameter="ConsoleOutput" PropertyName="GitCommit" />
    </Exec>
    <WriteLinesToFile File="$(ProjectDir)git_commit.txt" Overwrite="true" Lines="$(GitCommit)" />
  </Target>
  <Target Name="AfterBuildMigrated" AfterTargets="Build">
    <Delete Files="$(ProjectDir)git_commit.txt" />
  </Target>
  <ItemGroup>
    <Compile Remove="Resources\ExampleScripts\Hello_world.cs" />
    <Compile Remove="Resources\ExampleScripts\Set_all_visible_floats_to_100.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Remove="LICENSE" />
    <None Remove="Microsoft.CodeAnalysis.CSharp.dll.gz" />
    <None Remove="Microsoft.CodeAnalysis.dll.gz" />
    <None Remove="NOTICE.md" />
    <None Remove="retoc.exe.gz" />
  </ItemGroup>
  <ItemGroup>
    <Compile Update="ColorfulTreeView.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Update="FindForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="FindForm.Designer.cs">
      <DependentUpon>FindForm.cs</DependentUpon>
    </Compile>
    <Compile Update="AboutForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="AboutForm.Designer.cs">
      <DependentUpon>AboutForm.cs</DependentUpon>
    </Compile>
    <Compile Update="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Update="MapStructTypeOverrideForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="MapStructTypeOverrideForm.Designer.cs">
      <DependentUpon>MapStructTypeOverrideForm.cs</DependentUpon>
    </Compile>
    <Compile Update="SettingsForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="SettingsForm.Designer.cs">
      <DependentUpon>SettingsForm.cs</DependentUpon>
    </Compile>
    <Compile Update="TextPrompt.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="TextPrompt.Designer.cs">
      <DependentUpon>TextPrompt.cs</DependentUpon>
    </Compile>
    <EmbeddedResource Update="FindForm.resx">
      <DependentUpon>FindForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="AboutForm.resx">
      <DependentUpon>AboutForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="Form1.resx">
      <DependentUpon>Form1.cs</DependentUpon>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <EmbeddedResource Update="MapStructTypeOverrideForm.resx">
      <DependentUpon>MapStructTypeOverrideForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Update="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
      <DesignTime>True</DesignTime>
    </Compile>
    <EmbeddedResource Update="SettingsForm.resx">
      <DependentUpon>SettingsForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Update="TextPrompt.resx">
      <DependentUpon>TextPrompt.cs</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\ExampleScripts\Hello_world.cs" />
    <None Include="Resources\icon.ico" />
    <None Include="Resources\ExampleScripts\Set_all_visible_floats_to_100.cs" />
    <EmbeddedResource Include="git_commit.txt">
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
    <EmbeddedResource Include="LICENSE" />
    <EmbeddedResource Include="Microsoft.CodeAnalysis.CSharp.dll.gz">
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
    <EmbeddedResource Include="Microsoft.CodeAnalysis.dll.gz">
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
    <EmbeddedResource Include="NOTICE.md" />
    <EmbeddedResource Include="retoc.exe.gz" />
    <Content Include="next_patch_notes.txt" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\UAssetAPI\UAssetAPI\UAssetAPI.csproj" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="DiscordRichPresence" Version="1.1.1.14" />
    <PackageReference Include="FolderBrowserEx" Version="1.0.1" />
    <PackageReference Include="Markdig" Version="0.40.0" />
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="5.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="System.Collections.Immutable" Version="10.0.3" />
    <PackageReference Include="System.Reflection.Metadata" Version="10.0.3" />
    <PackageReference Include="System.Resources.Extensions" Version="8.0.0" />
  </ItemGroup>
</Project>
```

`UAssetGUI/UAssetGUI.csproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
  <ItemGroup>
    <Compile Update="AboutForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="FileContainerForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="MarkdownViewer.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Update="ProgressBarForm.cs">
      <SubType>Form</SubType>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Update="SettingsForm.resx">
      <SubType>Designer</SubType>
    </EmbeddedResource>
  </ItemGroup>
</Project>
```