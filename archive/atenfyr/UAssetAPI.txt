Project Path: arc_atenfyr_UAssetAPI_8ene9dq4

Source Tree:

```txt
arc_atenfyr_UAssetAPI_8ene9dq4
├── LICENSE
├── NOTICE.md
├── README.md
├── UAssetAPI
│   ├── AC7Decrypt.cs
│   ├── AssetBinaryReader.cs
│   ├── AssetBinaryWriter.cs
│   ├── CRCGenerator.cs
│   ├── CustomVersion.cs
│   ├── CustomVersions
│   │   └── CustomVersions.cs
│   ├── ExportTypes
│   │   ├── ClassExport.cs
│   │   ├── DataTableExport.cs
│   │   ├── EnumExport.cs
│   │   ├── Export.cs
│   │   ├── FieldExport.cs
│   │   ├── FunctionExport.cs
│   │   ├── LevelExport.cs
│   │   ├── MetaDataExport.cs
│   │   ├── NormalExport.cs
│   │   ├── PropertyExport.cs
│   │   ├── RawExport.cs
│   │   ├── StringTableExport.cs
│   │   ├── StructExport.cs
│   │   └── UserDefinedStructExport.cs
│   ├── FieldTypes
│   │   ├── EArrayDim.cs
│   │   ├── ELifetimeCondition.cs
│   │   ├── FField.cs
│   │   └── UField.cs
│   ├── Import.cs
│   ├── JSON
│   │   ├── ByteArrayJsonConverter.cs
│   │   ├── FNameJsonConverter.cs
│   │   ├── FPackageIndexJsonConverter.cs
│   │   ├── FSignedZeroJsonConverter.cs
│   │   ├── FStringJsonConverter.cs
│   │   ├── FStringTableJsonConverter.cs
│   │   ├── GuidJsonConverter.cs
│   │   ├── TMapJsonConverter.cs
│   │   └── UAssetContractResolver.cs
│   ├── Kismet
│   │   ├── Bytecode
│   │   │   ├── EBlueprintTextLiteralType.cs
│   │   │   ├── EExprToken.cs
│   │   │   ├── EScriptInstrumentationType.cs
│   │   │   ├── ExpressionSerializer.cs
│   │   │   ├── Expressions
│   │   │   │   ├── EX_AddMulticastDelegate.cs
│   │   │   │   ├── EX_ArrayConst.cs
│   │   │   │   ├── EX_ArrayGetByRef.cs
│   │   │   │   ├── EX_Assert.cs
│   │   │   │   ├── EX_BindDelegate.cs
│   │   │   │   ├── EX_BitFieldConst.cs
│   │   │   │   ├── EX_Breakpoint.cs
│   │   │   │   ├── EX_ByteConst.cs
│   │   │   │   ├── EX_CallMath.cs
│   │   │   │   ├── EX_CallMulticastDelegate.cs
│   │   │   │   ├── EX_CastBase.cs
│   │   │   │   ├── EX_ClassContext.cs
│   │   │   │   ├── EX_ClassSparseDataVariable.cs
│   │   │   │   ├── EX_ClearMulticastDelegate.cs
│   │   │   │   ├── EX_ComputedJump.cs
│   │   │   │   ├── EX_Context.cs
│   │   │   │   ├── EX_Context_FailSilent.cs
│   │   │   │   ├── EX_CrossInterfaceCast.cs
│   │   │   │   ├── EX_DefaultVariable.cs
│   │   │   │   ├── EX_DeprecatedOp4A.cs
│   │   │   │   ├── EX_DoubleConst.cs
│   │   │   │   ├── EX_DynamicCast.cs
│   │   │   │   ├── EX_EndArray.cs
│   │   │   │   ├── EX_EndArrayConst.cs
│   │   │   │   ├── EX_EndFunctionParms.cs
│   │   │   │   ├── EX_EndMap.cs
│   │   │   │   ├── EX_EndMapConst.cs
│   │   │   │   ├── EX_EndOfScript.cs
│   │   │   │   ├── EX_EndParmValue.cs
│   │   │   │   ├── EX_EndSet.cs
│   │   │   │   ├── EX_EndSetConst.cs
│   │   │   │   ├── EX_EndStructConst.cs
│   │   │   │   ├── EX_False.cs
│   │   │   │   ├── EX_FieldPathConst.cs
│   │   │   │   ├── EX_FinalFunction.cs
│   │   │   │   ├── EX_FloatConst.cs
│   │   │   │   ├── EX_InstanceDelegate.cs
│   │   │   │   ├── EX_InstanceVariable.cs
│   │   │   │   ├── EX_InstrumentationEvent.cs
│   │   │   │   ├── EX_Int64Const.cs
│   │   │   │   ├── EX_IntConst.cs
│   │   │   │   ├── EX_IntConstByte.cs
│   │   │   │   ├── EX_IntOne.cs
│   │   │   │   ├── EX_IntZero.cs
│   │   │   │   ├── EX_InterfaceContext.cs
│   │   │   │   ├── EX_InterfaceToObjCast.cs
│   │   │   │   ├── EX_Jump.cs
│   │   │   │   ├── EX_JumpIfNot.cs
│   │   │   │   ├── EX_Let.cs
│   │   │   │   ├── EX_LetBase.cs
│   │   │   │   ├── EX_LetBool.cs
│   │   │   │   ├── EX_LetDelegate.cs
│   │   │   │   ├── EX_LetMulticastDelegate.cs
│   │   │   │   ├── EX_LetObj.cs
│   │   │   │   ├── EX_LetValueOnPersistentFrame.cs
│   │   │   │   ├── EX_LetWeakObjPtr.cs
│   │   │   │   ├── EX_LocalFinalFunction.cs
│   │   │   │   ├── EX_LocalOutVariable.cs
│   │   │   │   ├── EX_LocalVariable.cs
│   │   │   │   ├── EX_LocalVirtualFunction.cs
│   │   │   │   ├── EX_MapConst.cs
│   │   │   │   ├── EX_MetaCast.cs
│   │   │   │   ├── EX_NameConst.cs
│   │   │   │   ├── EX_NoInterface.cs
│   │   │   │   ├── EX_NoObject.cs
│   │   │   │   ├── EX_Nothing.cs
│   │   │   │   ├── EX_NothingInt32.cs
│   │   │   │   ├── EX_ObjToInterfaceCast.cs
│   │   │   │   ├── EX_ObjectConst.cs
│   │   │   │   ├── EX_PopExecutionFlow.cs
│   │   │   │   ├── EX_PopExecutionFlowIfNot.cs
│   │   │   │   ├── EX_PrimitiveCast.cs
│   │   │   │   ├── EX_PropertyConst.cs
│   │   │   │   ├── EX_PushExecutionFlow.cs
│   │   │   │   ├── EX_RemoveMulticastDelegate.cs
│   │   │   │   ├── EX_Return.cs
│   │   │   │   ├── EX_RotationConst.cs
│   │   │   │   ├── EX_Self.cs
│   │   │   │   ├── EX_SetArray.cs
│   │   │   │   ├── EX_SetConst.cs
│   │   │   │   ├── EX_SetMap.cs
│   │   │   │   ├── EX_SetSet.cs
│   │   │   │   ├── EX_Skip.cs
│   │   │   │   ├── EX_SkipOffsetConst.cs
│   │   │   │   ├── EX_SoftObjectConst.cs
│   │   │   │   ├── EX_StringConst.cs
│   │   │   │   ├── EX_StructConst.cs
│   │   │   │   ├── EX_StructMemberContext.cs
│   │   │   │   ├── EX_SwitchValue.cs
│   │   │   │   ├── EX_TextConst.cs
│   │   │   │   ├── EX_Tracepoint.cs
│   │   │   │   ├── EX_TransformConst.cs
│   │   │   │   ├── EX_True.cs
│   │   │   │   ├── EX_UInt64Const.cs
│   │   │   │   ├── EX_UnicodeStringConst.cs
│   │   │   │   ├── EX_VariableBase.cs
│   │   │   │   ├── EX_Vector3fConst.cs
│   │   │   │   ├── EX_VectorConst.cs
│   │   │   │   ├── EX_VirtualFunction.cs
│   │   │   │   └── EX_WireTracepoint.cs
│   │   │   ├── FScriptText.cs
│   │   │   ├── KismetExpression.cs
│   │   │   └── KismetPropertyPointer.cs
│   │   └── KismetSerializer.cs
│   ├── MainSerializer.cs
│   ├── Pak
│   │   ├── Interop.cs
│   │   └── RePak.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── PropertyTypes
│   │   ├── Objects
│   │   │   ├── ArrayPropertyData.cs
│   │   │   ├── BoolPropertyData.cs
│   │   │   ├── BytePropertyData.cs
│   │   │   ├── DelegatePropertyData.cs
│   │   │   ├── DoublePropertyData.cs
│   │   │   ├── EnumPropertyData.cs
│   │   │   ├── FieldPathPropertyData.cs
│   │   │   ├── FloatPropertyData.cs
│   │   │   ├── Int16PropertyData.cs
│   │   │   ├── Int64PropertyData.cs
│   │   │   ├── Int8PropertyData.cs
│   │   │   ├── IntPropertyData.cs
│   │   │   ├── InterfacePropertyData.cs
│   │   │   ├── MapPropertyData.cs
│   │   │   ├── MulticastDelegatePropertyData.cs
│   │   │   ├── NamePropertyData.cs
│   │   │   ├── ObjectPropertyData.cs
│   │   │   ├── PropertyData.cs
│   │   │   ├── SetPropertyData.cs
│   │   │   ├── SoftObjectPropertyData.cs
│   │   │   ├── StrPropertyData.cs
│   │   │   ├── TextHistoryType.cs
│   │   │   ├── TextPropertyData.cs
│   │   │   ├── UInt16PropertyData.cs
│   │   │   ├── UInt32PropertyData.cs
│   │   │   ├── UInt64PropertyData.cs
│   │   │   ├── UnknownPropertyData.cs
│   │   │   └── WeakObjectPropertyData.cs
│   │   └── Structs
│   │       ├── ClothLODDataPropertyData.cs
│   │       ├── ClothTetherDataPropertyData.cs
│   │       ├── Core
│   │       │   ├── ColorPropertyData.cs
│   │       │   ├── DateTimePropertyData.cs
│   │       │   ├── GuidPropertyData.cs
│   │       │   └── TimespanPropertyData.cs
│   │       ├── Engine
│   │       │   ├── FontCharacterPropertyData.cs
│   │       │   ├── KeyHandleMapPropertyData.cs
│   │       │   ├── MaterialInputProperties.cs
│   │       │   ├── MaterialOverrideNanitePropertyData.cs
│   │       │   ├── NavAgentSelectorPropertyData.cs
│   │       │   ├── PerPlatformProperties.cs
│   │       │   ├── PerQualityProperties.cs
│   │       │   ├── RichCurveKeyPropertyData.cs
│   │       │   ├── SkeletalMeshSamplingLODBuiltDataPropertyData.cs
│   │       │   ├── SkeletalMeshSamplingRegionBuiltDataPropertyData.cs
│   │       │   ├── SmartNamePropertyData.cs
│   │       │   ├── StringCurveKeyPropertyData.cs
│   │       │   ├── ViewTargetBlendParamsPropertyData.cs
│   │       │   └── WeightedRandomSamplerPropertyData.cs
│   │       ├── GameplayTagContainerPropertyData.cs
│   │       ├── LevelSequenceObjectReferenceMapPropertyData.cs
│   │       ├── Math
│   │       │   ├── BoxPropertyData.cs
│   │       │   ├── IntPointPropertyData.cs
│   │       │   ├── IntVector2PropertyData.cs
│   │       │   ├── IntVectorPropertyData.cs
│   │       │   ├── LinearColorPropertyData.cs
│   │       │   ├── MatrixPropertyData.cs
│   │       │   ├── PlanePropertyData.cs
│   │       │   ├── QuatPropertyData.cs
│   │       │   ├── RotatorPropertyData.cs
│   │       │   ├── TwoVectorsPropertyData.cs
│   │       │   ├── Vector2DPropertyData.cs
│   │       │   ├── Vector2fPropertyData.cs
│   │       │   ├── Vector3fPropertyData.cs
│   │       │   ├── Vector4PropertyData.cs
│   │       │   ├── Vector4fPropertyData.cs
│   │       │   ├── VectorNetQuantizePropertyData.cs
│   │       │   └── VectorPropertyData.cs
│   │       ├── Movies
│   │       │   ├── FrameNumberPropertyData.cs
│   │       │   ├── MovieScene.cs
│   │       │   ├── MovieSceneChannel.cs
│   │       │   ├── MovieSceneDoubleChannelPropertyData.cs
│   │       │   ├── MovieSceneEvalTemplatePtrPropertyData.cs
│   │       │   ├── MovieSceneEvaluationFieldEntityTreePropertyData.cs
│   │       │   ├── MovieSceneEvaluationTree.cs
│   │       │   ├── MovieSceneEvaluationTreeNode.cs
│   │       │   ├── MovieSceneEventParametersPropertyData.cs
│   │       │   ├── MovieSceneFloatChannelPropertyData.cs
│   │       │   ├── MovieSceneFloatValuePropertyData.cs
│   │       │   ├── MovieSceneFrameRangePropertyData.cs
│   │       │   ├── MovieSceneGenerationLedgerPropertyData.cs
│   │       │   ├── MovieSceneSegment.cs
│   │       │   ├── MovieSceneSegmentPropertyData.cs
│   │       │   ├── MovieSceneTrackIdentifierPropertyData.cs
│   │       │   ├── MovieSceneValue.cs
│   │       │   └── NameCurveKeyPropertyData.cs
│   │       ├── Niagara
│   │       │   ├── NiagaraDataInterfaceGPUParamInfoPropertyData.cs
│   │       │   └── NiagaraVariablePropertyData.cs
│   │       ├── Ranges
│   │       │   └── FloatRangePropertyData.cs
│   │       ├── RawStructPropertyData.cs
│   │       ├── Slate
│   │       │   ├── DeprecateSlateVector2DPropertyData.cs
│   │       │   └── FontDataPropertyData.cs
│   │       ├── SoftObjectPathPropertyData.cs
│   │       └── StructPropertyData.cs
│   ├── Resources
│   │   └── AC7Key.bin
│   ├── UAPUtils.cs
│   ├── UAsset.cs
│   ├── UAssetAPI.csproj
│   ├── UnrealTypes
│   │   ├── EngineVersion.cs
│   │   ├── FFieldPath.cs
│   │   ├── FGatherableTextData.cs
│   │   ├── FLocMetadataObject.cs
│   │   ├── FName.cs
│   │   ├── FObjectDataResource.cs
│   │   ├── FObjectThumbnail.cs
│   │   ├── FPackageIndex.cs
│   │   ├── FPropertyTypeName.cs
│   │   ├── FString.cs
│   │   ├── FTextSourceData.cs
│   │   ├── FTextSourceSiteContext.cs
│   │   ├── FUniversalObjectLocatorFragment.cs
│   │   ├── FWorldTileInfo.cs
│   │   ├── Flags.cs
│   │   ├── ObjectVersion.cs
│   │   ├── Objects
│   │   │   ├── Core
│   │   │   │   └── Math
│   │   │   │       ├── FIntVector.cs
│   │   │   │       ├── FIntVector2.cs
│   │   │   │       ├── FLinearColor.cs
│   │   │   │       ├── FMatrix.cs
│   │   │   │       ├── FPlane.cs
│   │   │   │       ├── FQuat.cs
│   │   │   │       ├── FRotator.cs
│   │   │   │       ├── FTransform.cs
│   │   │   │       ├── FTwoVectors.cs
│   │   │   │       ├── FVector.cs
│   │   │   │       ├── FVector2D.cs
│   │   │   │       ├── FVector2f.cs
│   │   │   │       ├── FVector3f.cs
│   │   │   │       ├── FVector4.cs
│   │   │   │       ├── FVector4f.cs
│   │   │   │       ├── TBox.cs
│   │   │   │       └── TPerQualityLevel.cs
│   │   │   ├── Engine
│   │   │   │   ├── CoreUObject
│   │   │   │   │   ├── CoreUObjectEnums.cs
│   │   │   │   │   └── CoreUObjectStructs.cs
│   │   │   │   ├── EngineEnums.cs
│   │   │   │   ├── FFontCharacter.cs
│   │   │   │   ├── FRichCurveKey.cs
│   │   │   │   ├── FSkeletalMeshSamplingRegionBuiltData.cs
│   │   │   │   ├── FWeightedRandomSampler.cs
│   │   │   │   ├── GameFramework
│   │   │   │   │   └── UniqueNetIdReplPropertyData.cs
│   │   │   │   └── Niagara
│   │   │   │       └── FNiagaraDataInterfaceGPUParamInfo.cs
│   │   │   └── SlateCore
│   │   │       └── FFontData.cs
│   │   ├── TMap.cs
│   │   └── UE4VersionToObjectVersion.cs
│   ├── Unversioned
│   │   ├── FFragment.cs
│   │   ├── FUnversionedHeader.cs
│   │   ├── Oodle.cs
│   │   ├── SaveGame.cs
│   │   ├── Usmap.cs
│   │   └── UsmapBinaryReader.cs
│   ├── repak_bind.dll.gz
│   └── repak_bind.so.gz
├── UAssetAPI.Benchmark
│   ├── App.config
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── TestAssets
│   │   ├── B_Gamemode.uasset
│   │   ├── Begin_Player.uasset
│   │   ├── HUB_Restaurant.uexp
│   │   ├── HUB_Restaurant.umap
│   │   ├── PlayerBase01.uexp
│   │   ├── PlayerBase01.umap
│   │   ├── Staging_T2.uexp
│   │   ├── Staging_T2.umap
│   │   └── _asset_versions.json
│   └── UAssetAPI.Benchmark.csproj
├── UAssetAPI.Tests
│   ├── AssetUnitTests.cs
│   ├── CoolPropertyData.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── TestAssets
│   │   ├── TestACE7
│   │   │   ├── ex02_IGC_03_Subtitle.uasset
│   │   │   ├── ex02_IGC_03_Subtitle.uexp
│   │   │   ├── plwp_6aam_a0.uasset
│   │   │   └── plwp_6aam_a0.uexp
│   │   ├── TestCustomProperty
│   │   │   └── AlternateStartActor.uasset
│   │   ├── TestCustomSerializationStructsInMap
│   │   │   ├── wtf.uasset
│   │   │   └── wtf.uexp
│   │   ├── TestDuplicateNameMapEntries
│   │   │   ├── BIOME_AzureWeald.uasset
│   │   │   └── BIOME_AzureWeald.uexp
│   │   ├── TestEditorAssets
│   │   │   ├── TestActorBP.uasset
│   │   │   ├── TestMaterial.uasset
│   │   │   └── TestSoundClass.uasset
│   │   ├── TestImproperNameMapHashes
│   │   │   ├── OC_Gatling_DamageB_B.uasset
│   │   │   └── OC_Gatling_DamageB_B.uexp
│   │   ├── TestJson
│   │   │   ├── ABP_SMG_A.uasset
│   │   │   ├── ABP_SMG_A.uexp
│   │   │   ├── AssetDatabase_AutoGenerated.uasset
│   │   │   ├── AssetDatabase_AutoGenerated.uexp
│   │   │   ├── Atlas_6x4_Semi.uasset
│   │   │   ├── Atlas_6x4_Semi.uexp
│   │   │   ├── BlinkerLight_01.uasset
│   │   │   ├── BlinkerLight_01.uexp
│   │   │   ├── FrontDomeLight_2m.uasset
│   │   │   ├── FrontDomeLight_2m.uexp
│   │   │   ├── Items.uasset
│   │   │   ├── Items.uexp
│   │   │   ├── MGA_HeavyWeapon_Parent.uasset
│   │   │   ├── MGA_HeavyWeapon_Parent.uexp
│   │   │   ├── MTVehicleBaseBP.uasset
│   │   │   ├── MTVehicleBaseBP.uexp
│   │   │   ├── Map_FrontEnd_Hotel_LS_Night.uexp
│   │   │   ├── Map_FrontEnd_Hotel_LS_Night.umap
│   │   │   ├── MotorTown.usmap
│   │   │   ├── Outriders.usmap
│   │   │   ├── RaceSimDataAsset.uasset
│   │   │   ├── RaceSimDataAsset.uexp
│   │   │   ├── ReverseLight_01.uasset
│   │   │   ├── ReverseLight_01.uexp
│   │   │   ├── TaliLight_01.uasset
│   │   │   ├── TaliLight_01.uexp
│   │   │   ├── TurboAcres_Environment.uasset
│   │   │   ├── TurboAcres_Environment.uexp
│   │   │   ├── WPN_LockOnRifle.uasset
│   │   │   └── WPN_LockOnRifle.uexp
│   │   ├── TestManyAssets
│   │   │   ├── Astroneer
│   │   │   │   ├── Augment_BroadBrush.uasset
│   │   │   │   ├── DebugMenu.uasset
│   │   │   │   ├── LargeResourceCanister_IT.uasset
│   │   │   │   ├── ResourceProgressCurve.uasset
│   │   │   │   └── Staging_T2.umap
│   │   │   ├── Biodigital
│   │   │   │   ├── Roboto.uasset
│   │   │   │   └── RobotoTiny.uasset
│   │   │   ├── Bloodstained
│   │   │   │   ├── PB_DT_ItemMaster.uasset
│   │   │   │   ├── PB_DT_RandomizerRoomCheck.uasset
│   │   │   │   ├── m01SIP_000_BG.umap
│   │   │   │   ├── m01SIP_000_Gimmick.umap
│   │   │   │   ├── m02VIL_004_Gimmick.umap
│   │   │   │   └── m05SAN_000_Gimmick.umap
│   │   │   ├── BurningDaylight
│   │   │   │   ├── TestMap.uexp
│   │   │   │   └── TestMap.umap
│   │   │   ├── CodeVein
│   │   │   │   ├── SK_Inner_Female1.uasset
│   │   │   │   └── SK_Inner_Female1.uexp
│   │   │   ├── F1Manager2023
│   │   │   │   ├── F1Manager2023.usmap
│   │   │   │   ├── FixedStaff.uasset
│   │   │   │   ├── FixedStaff.uexp
│   │   │   │   ├── MI_F1_Driver_LoganSargeant_Visor.uasset
│   │   │   │   ├── MI_F1_Driver_LoganSargeant_Visor.uexp
│   │   │   │   ├── StaffPhotoData.uasset
│   │   │   │   └── StaffPhotoData.uexp
│   │   │   ├── LiesOfP
│   │   │   │   ├── ItemInfo.uasset
│   │   │   │   ├── ItemInfo.uexp
│   │   │   │   ├── LiesOfP.usmap
│   │   │   │   ├── SkillHitInfo.uasset
│   │   │   │   ├── SkillHitInfo.uexp
│   │   │   │   ├── SkillInfo.uasset
│   │   │   │   └── SkillInfo.uexp
│   │   │   ├── Liminal
│   │   │   │   ├── FinalCinematic.uasset
│   │   │   │   ├── FinalCinematic.uexp
│   │   │   │   ├── InCathedralCinematic.uasset
│   │   │   │   ├── InCathedralCinematic.uexp
│   │   │   │   ├── InventoryStruct.uasset
│   │   │   │   └── InventoryStruct.uexp
│   │   │   ├── MISC_426
│   │   │   │   ├── MainChar_BellySlice_BR.uasset
│   │   │   │   ├── MainChar_BellySlice_BR.uexp
│   │   │   │   ├── RaceSimDataAsset.uasset
│   │   │   │   └── RaceSimDataAsset.uexp
│   │   │   ├── MidAir
│   │   │   │   ├── AM_MedChar_Reload_RingLauncher.uasset
│   │   │   │   ├── AM_MedChar_Reload_RingLauncher.uexp
│   │   │   │   ├── WBP_PartyPlayerRow.uasset
│   │   │   │   └── WBP_PartyPlayerRow.uexp
│   │   │   ├── MutantYearZero
│   │   │   │   ├── ChroniclerpathCutscene.uasset
│   │   │   │   ├── ChroniclerpathCutscene.uexp
│   │   │   │   ├── MainCut.uasset
│   │   │   │   └── MainCut.uexp
│   │   │   ├── Palia
│   │   │   │   ├── DT_FishConfigs.uasset
│   │   │   │   ├── DT_FishConfigs.uexp
│   │   │   │   ├── DT_FishingLevelConfigs.uasset
│   │   │   │   ├── DT_FishingLevelConfigs.uexp
│   │   │   │   ├── DT_FishingLevelSegmentConfigs.uasset
│   │   │   │   ├── DT_FishingLevelSegmentConfigs.uexp
│   │   │   │   ├── DT_FishingLootConfigs.uasset
│   │   │   │   ├── DT_FishingLootConfigs.uexp
│   │   │   │   ├── DT_FishingNibbleConfig.uasset
│   │   │   │   ├── DT_FishingNibbleConfig.uexp
│   │   │   │   ├── DT_FishingNibbleLevelConfig.uasset
│   │   │   │   ├── DT_FishingNibbleLevelConfig.uexp
│   │   │   │   ├── DT_ShopConfigs.uasset
│   │   │   │   ├── DT_ShopConfigs.uexp
│   │   │   │   └── Palia.usmap
│   │   │   ├── Palworld
│   │   │   │   ├── BP_BuildObject_BaseCampWorkHard.uasset
│   │   │   │   ├── BP_BuildObject_BaseCampWorkHard.uexp
│   │   │   │   ├── BP_InteractableBox.uasset
│   │   │   │   ├── BP_InteractableBox.uexp
│   │   │   │   └── Palworld.usmap
│   │   │   ├── SnakePass
│   │   │   │   ├── MP00_GateTutorial.uasset
│   │   │   │   └── MP00_Intro.uasset
│   │   │   ├── StarlitSeason
│   │   │   │   ├── CharacterCostume_chr0001_DataTable.uasset
│   │   │   │   └── CharacterCostume_chr0001_DataTable.uexp
│   │   │   ├── Tekken
│   │   │   │   └── BP_TekkenPlayer_Modular.uasset
│   │   │   ├── TheBeastInside
│   │   │   │   ├── DV_ItemDescription.uasset
│   │   │   │   ├── DV_ItemDescription.uexp
│   │   │   │   ├── MF_CharacterEffects.uasset
│   │   │   │   └── MF_CharacterEffects.uexp
│   │   │   ├── TheOccupation
│   │   │   │   ├── LiftStruct.uasset
│   │   │   │   └── RecieverPneumaticTerminals.uasset
│   │   │   ├── ToTheCore
│   │   │   │   ├── BP_MimicCrate.uasset
│   │   │   │   └── BP_MimicCrate.uexp
│   │   │   └── VERSIONED
│   │   │       └── Assault_M1A1Thompson_WW2_DrumSuppressor.uasset
│   │   ├── TestMaterials
│   │   │   ├── M_COM_DetailMaster_B.uasset
│   │   │   ├── as_mt_base.uasset
│   │   │   └── as_mt_base.uexp
│   │   ├── TestUE5_1
│   │   │   └── UnderlyingEnumTypes
│   │   │       ├── NewDataTable.uasset
│   │   │       ├── NewDataTable.uexp
│   │   │       └── UnderlyingEnumTypes.usmap
│   │   ├── TestUE5_3
│   │   │   ├── Engine
│   │   │   │   ├── DefaultRecorderBoneCompression.uasset
│   │   │   │   ├── DefaultRecorderBoneCompression.uexp
│   │   │   │   ├── Engine.usmap
│   │   │   │   ├── Entry.uexp
│   │   │   │   ├── Entry.umap
│   │   │   │   ├── Entry_MODIFIED_INVALID_ENUM_INDEX.uexp
│   │   │   │   ├── Entry_MODIFIED_INVALID_ENUM_INDEX.umap
│   │   │   │   ├── OpenWorld.uexp
│   │   │   │   └── OpenWorld.umap
│   │   │   └── RON
│   │   │       ├── AmmoDataTable.uasset
│   │   │       ├── AmmoDataTable.uexp
│   │   │       └── ReadyOrNot.usmap
│   │   ├── TestUE5_4
│   │   │   ├── Bellwright
│   │   │   │   ├── Bellwright.usmap
│   │   │   │   └── Content
│   │   │   │       └── Mist
│   │   │   │           └── Characters
│   │   │   │               └── NPC
│   │   │   │                   └── Villager
│   │   │   │                       ├── HighSkill
│   │   │   │                       │   ├── ApprenticeBlacksmithNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeBlacksmithNPCTemplate.uexp
│   │   │   │                       │   ├── ApprenticeCarpenterNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeCarpenterNPCTemplate.uexp
│   │   │   │                       │   ├── ApprenticeEngineerNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeEngineerNPCTemplate.uexp
│   │   │   │                       │   ├── ApprenticeFarmerNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeFarmerNPCTemplate.uexp
│   │   │   │                       │   ├── ApprenticeHealerNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeHealerNPCTemplate.uexp
│   │   │   │                       │   ├── ApprenticeInkeeperNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeInkeeperNPCTemplate.uexp
│   │   │   │                       │   ├── ApprenticeLabourerNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeLabourerNPCTemplate.uexp
│   │   │   │                       │   ├── ApprenticeWeaverNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeWeaverNPCTemplate.uexp
│   │   │   │                       │   ├── ApprenticeWoodsmanNPCTemplate.uasset
│   │   │   │                       │   ├── ApprenticeWoodsmanNPCTemplate.uexp
│   │   │   │                       │   ├── HighNoTraitsVillagerIdleNPCTemplate.uasset
│   │   │   │                       │   ├── HighNoTraitsVillagerIdleNPCTemplate.uexp
│   │   │   │                       │   ├── HighVillagerIdleNPCTemplate.uasset
│   │   │   │                       │   └── HighVillagerIdleNPCTemplate.uexp
│   │   │   │                       ├── LowSkill
│   │   │   │                       │   ├── LowBeggarNPCTemplate.uasset
│   │   │   │                       │   ├── LowBeggarNPCTemplate.uexp
│   │   │   │                       │   ├── LowVillagerIdleNPCTemplate.uasset
│   │   │   │                       │   ├── LowVillagerIdleNPCTemplate.uexp
│   │   │   │                       │   ├── LowVillagerIdleNoTraitsNPCTemplate.uasset
│   │   │   │                       │   └── LowVillagerIdleNoTraitsNPCTemplate.uexp
│   │   │   │                       └── MediumSkill
│   │   │   │                           ├── MediumNoTraitsVillagerIdleNPCTemplate.uasset
│   │   │   │                           ├── MediumNoTraitsVillagerIdleNPCTemplate.uexp
│   │   │   │                           ├── MediumVillagerIdleNPCTemplate.uasset
│   │   │   │                           ├── MediumVillagerIdleNPCTemplate.uexp
│   │   │   │                           ├── NoviceBlacksmithNPCTemplate.uasset
│   │   │   │                           ├── NoviceBlacksmithNPCTemplate.uexp
│   │   │   │                           ├── NoviceCarpenterNPCTemplate.uasset
│   │   │   │                           ├── NoviceCarpenterNPCTemplate.uexp
│   │   │   │                           ├── NoviceEngineerNPCTemplate.uasset
│   │   │   │                           ├── NoviceEngineerNPCTemplate.uexp
│   │   │   │                           ├── NoviceFarmerNPCTemplate.uasset
│   │   │   │                           ├── NoviceFarmerNPCTemplate.uexp
│   │   │   │                           ├── NoviceHealerNPCTemplate.uasset
│   │   │   │                           ├── NoviceHealerNPCTemplate.uexp
│   │   │   │                           ├── NoviceInkeeperNPCTemplate.uasset
│   │   │   │                           ├── NoviceInkeeperNPCTemplate.uexp
│   │   │   │                           ├── NoviceLabourerNPCTemplate.uasset
│   │   │   │                           ├── NoviceLabourerNPCTemplate.uexp
│   │   │   │                           ├── NoviceWeaverNPCTemplate.uasset
│   │   │   │                           ├── NoviceWeaverNPCTemplate.uexp
│   │   │   │                           ├── NoviceWoodsmanNPCTemplate.uasset
│   │   │   │                           └── NoviceWoodsmanNPCTemplate.uexp
│   │   │   ├── Billiards
│   │   │   │   ├── 5.4.3-34507850+++UE5+Release-5.4-DeepSpace7.usmap
│   │   │   │   ├── BP_Table_Lamp.uasset
│   │   │   │   └── BP_Table_Lamp.uexp
│   │   │   ├── BlankGame
│   │   │   │   ├── BP_CubePawn.combined
│   │   │   │   ├── BP_CubePawn.uasset
│   │   │   │   ├── BP_CubePawn.uexp
│   │   │   │   ├── BlankGame_Dumper-7.usmap
│   │   │   │   ├── MI_BlueCube.uasset
│   │   │   │   ├── MI_BlueCube.uexp
│   │   │   │   ├── M_Cube.uasset
│   │   │   │   ├── M_Cube.uexp
│   │   │   │   ├── SM_BlueCube.uasset
│   │   │   │   └── SM_BlueCube.uexp
│   │   │   ├── JOY
│   │   │   │   ├── 5.4.3-34507850+++UE5+Release-5.4-JOY.usmap
│   │   │   │   ├── BP_GameMode_Base.uasset
│   │   │   │   └── BP_GameMode_Base.uexp
│   │   │   └── TheForeverWinter
│   │   │       ├── DA_DailyGiftList.uasset
│   │   │       ├── DA_DailyGiftList.uexp
│   │   │       └── TheForeverWinter.usmap
│   │   ├── TestUE5_5
│   │   │   └── BlankGame
│   │   │       ├── BP_Test.uasset
│   │   │       ├── BP_Test.uexp
│   │   │       ├── BlankUE5_5.usmap
│   │   │       ├── M_Cube_1.uasset
│   │   │       ├── M_Cube_1.uexp
│   │   │       ├── SM_Cube.uasset
│   │   │       ├── SM_Cube.ubulk
│   │   │       ├── SM_Cube.uexp
│   │   │       ├── T_Test.uasset
│   │   │       ├── T_Test.ubulk
│   │   │       ├── T_Test.uexp
│   │   │       ├── T_pl01_001_body_D.uasset
│   │   │       ├── T_pl01_001_body_D.uexp
│   │   │       ├── WBP_Hello.uasset
│   │   │       └── WBP_Hello.uexp
│   │   ├── TestUE5_6
│   │   │   └── BpThirdPerson
│   │   │       ├── BP_ThirdPersonCharacter.uasset
│   │   │       ├── BP_ThirdPersonCharacter.uexp
│   │   │       ├── ExplicitEnumValuesExample.usmap
│   │   │       ├── MI_Quinn_01.uasset
│   │   │       ├── MI_Quinn_01.uexp
│   │   │       ├── M_Mannequin.uasset
│   │   │       ├── M_Mannequin.uexp
│   │   │       ├── SKM_Quinn_Simple.uasset
│   │   │       ├── SKM_Quinn_Simple.uexp
│   │   │       ├── SM_Cube.uasset
│   │   │       ├── SM_Cube.ubulk
│   │   │       └── SM_Cube.uexp
│   │   └── TestUnknownProperties
│   │       ├── BP_DetPack_Charge.uasset
│   │       └── BP_DetPack_Charge.uexp
│   └── UAssetAPI.Tests.csproj
├── UAssetAPI.sln
└── docs
    ├── book.toml
    ├── correct_pages.py
    ├── correct_summary.py
    ├── css
    │   └── custom.css
    ├── generate_docs.bat
    ├── generate_docs.sh
    └── src
        ├── README.md
        ├── SUMMARY.md
        ├── SUMMARY_header.md
        ├── api
        │   ├── uassetapi.ac7decrypt.md
        │   ├── uassetapi.ac7xorkey.md
        │   ├── uassetapi.assetbinaryreader.md
        │   ├── uassetapi.assetbinarywriter.md
        │   ├── uassetapi.crcgenerator.md
        │   ├── uassetapi.customserializationflags.md
        │   ├── uassetapi.customversion.md
        │   ├── uassetapi.customversions.fanimphysobjectversion.md
        │   ├── uassetapi.customversions.fassetregistryversion.md
        │   ├── uassetapi.customversions.fcoreobjectversion.md
        │   ├── uassetapi.customversions.feditorobjectversion.md
        │   ├── uassetapi.customversions.ffortnitemainbranchobjectversion.md
        │   ├── uassetapi.customversions.ffortnitereleasebranchcustomobjectversion.md
        │   ├── uassetapi.customversions.fframeworkobjectversion.md
        │   ├── uassetapi.customversions.fniagaracustomversion.md
        │   ├── uassetapi.customversions.fniagaraobjectversion.md
        │   ├── uassetapi.customversions.freleaseobjectversion.md
        │   ├── uassetapi.customversions.fsequencerobjectversion.md
        │   ├── uassetapi.customversions.fue5releasestreamobjectversion.md
        │   ├── uassetapi.customversions.introducedattribute.md
        │   ├── uassetapi.exporttypes.classexport.md
        │   ├── uassetapi.exporttypes.datatableexport.md
        │   ├── uassetapi.exporttypes.eclassserializationcontrolextension.md
        │   ├── uassetapi.exporttypes.ecppform.md
        │   ├── uassetapi.exporttypes.eexportfilterflags.md
        │   ├── uassetapi.exporttypes.enumexport.md
        │   ├── uassetapi.exporttypes.export.md
        │   ├── uassetapi.exporttypes.fieldexport.md
        │   ├── uassetapi.exporttypes.fstringtable.md
        │   ├── uassetapi.exporttypes.functionexport.md
        │   ├── uassetapi.exporttypes.furl.md
        │   ├── uassetapi.exporttypes.levelexport.md
        │   ├── uassetapi.exporttypes.metadataexport.md
        │   ├── uassetapi.exporttypes.normalexport.md
        │   ├── uassetapi.exporttypes.objectmetadataentry.md
        │   ├── uassetapi.exporttypes.propertyexport.md
        │   ├── uassetapi.exporttypes.rawexport.md
        │   ├── uassetapi.exporttypes.serializedinterfacereference.md
        │   ├── uassetapi.exporttypes.stringtableexport.md
        │   ├── uassetapi.exporttypes.structexport.md
        │   ├── uassetapi.exporttypes.udatatable.md
        │   ├── uassetapi.exporttypes.uenum.md
        │   ├── uassetapi.exporttypes.userdefinedstructexport.md
        │   ├── uassetapi.fengineversion.md
        │   ├── uassetapi.fgenerationinfo.md
        │   ├── uassetapi.fieldtypes.earraydim.md
        │   ├── uassetapi.fieldtypes.elifetimecondition.md
        │   ├── uassetapi.fieldtypes.farrayproperty.md
        │   ├── uassetapi.fieldtypes.fboolproperty.md
        │   ├── uassetapi.fieldtypes.fbyteproperty.md
        │   ├── uassetapi.fieldtypes.fclassproperty.md
        │   ├── uassetapi.fieldtypes.fdelegateproperty.md
        │   ├── uassetapi.fieldtypes.fenumproperty.md
        │   ├── uassetapi.fieldtypes.ffield.md
        │   ├── uassetapi.fieldtypes.fgenericproperty.md
        │   ├── uassetapi.fieldtypes.finterfaceproperty.md
        │   ├── uassetapi.fieldtypes.fmapproperty.md
        │   ├── uassetapi.fieldtypes.fmulticastdelegateproperty.md
        │   ├── uassetapi.fieldtypes.fmulticastinlinedelegateproperty.md
        │   ├── uassetapi.fieldtypes.fnumericproperty.md
        │   ├── uassetapi.fieldtypes.fobjectproperty.md
        │   ├── uassetapi.fieldtypes.foptionalproperty.md
        │   ├── uassetapi.fieldtypes.fproperty.md
        │   ├── uassetapi.fieldtypes.fsetproperty.md
        │   ├── uassetapi.fieldtypes.fsoftclassproperty.md
        │   ├── uassetapi.fieldtypes.fsoftobjectproperty.md
        │   ├── uassetapi.fieldtypes.fstructproperty.md
        │   ├── uassetapi.fieldtypes.fweakobjectproperty.md
        │   ├── uassetapi.fieldtypes.uarrayproperty.md
        │   ├── uassetapi.fieldtypes.uassetclassproperty.md
        │   ├── uassetapi.fieldtypes.uassetobjectproperty.md
        │   ├── uassetapi.fieldtypes.uboolproperty.md
        │   ├── uassetapi.fieldtypes.ubyteproperty.md
        │   ├── uassetapi.fieldtypes.uclassproperty.md
        │   ├── uassetapi.fieldtypes.udelegateproperty.md
        │   ├── uassetapi.fieldtypes.udoubleproperty.md
        │   ├── uassetapi.fieldtypes.uenumproperty.md
        │   ├── uassetapi.fieldtypes.ufield.md
        │   ├── uassetapi.fieldtypes.ufloatproperty.md
        │   ├── uassetapi.fieldtypes.ugenericproperty.md
        │   ├── uassetapi.fieldtypes.uint16property.md
        │   ├── uassetapi.fieldtypes.uint64property.md
        │   ├── uassetapi.fieldtypes.uint8property.md
        │   ├── uassetapi.fieldtypes.uinterfaceproperty.md
        │   ├── uassetapi.fieldtypes.uintproperty.md
        │   ├── uassetapi.fieldtypes.ulazyobjectproperty.md
        │   ├── uassetapi.fieldtypes.umapproperty.md
        │   ├── uassetapi.fieldtypes.umulticastdelegateproperty.md
        │   ├── uassetapi.fieldtypes.umulticastinlinedelegateproperty.md
        │   ├── uassetapi.fieldtypes.umulticastsparsedelegateproperty.md
        │   ├── uassetapi.fieldtypes.unameproperty.md
        │   ├── uassetapi.fieldtypes.unumericproperty.md
        │   ├── uassetapi.fieldtypes.uobjectproperty.md
        │   ├── uassetapi.fieldtypes.uproperty.md
        │   ├── uassetapi.fieldtypes.usetproperty.md
        │   ├── uassetapi.fieldtypes.usoftclassproperty.md
        │   ├── uassetapi.fieldtypes.usoftobjectproperty.md
        │   ├── uassetapi.fieldtypes.ustrproperty.md
        │   ├── uassetapi.fieldtypes.ustructproperty.md
        │   ├── uassetapi.fieldtypes.utextproperty.md
        │   ├── uassetapi.fieldtypes.uuint16property.md
        │   ├── uassetapi.fieldtypes.uuint32property.md
        │   ├── uassetapi.fieldtypes.uuint64property.md
        │   ├── uassetapi.fieldtypes.uweakobjectproperty.md
        │   ├── uassetapi.import.md
        │   ├── uassetapi.inamemap.md
        │   ├── uassetapi.invalidmappingsexception.md
        │   ├── uassetapi.json.bytearrayjsonconverter.md
        │   ├── uassetapi.json.fnamejsonconverter.md
        │   ├── uassetapi.json.fpackageindexjsonconverter.md
        │   ├── uassetapi.json.fsignedzerojsonconverter.md
        │   ├── uassetapi.json.fstringjsonconverter.md
        │   ├── uassetapi.json.fstringtablejsonconverter.md
        │   ├── uassetapi.json.guidjsonconverter.md
        │   ├── uassetapi.json.tmapjsonconverter-2.md
        │   ├── uassetapi.json.uassetcontractresolver.md
        │   ├── uassetapi.kismet.bytecode.eblueprinttextliteraltype.md
        │   ├── uassetapi.kismet.bytecode.ecasttoken.md
        │   ├── uassetapi.kismet.bytecode.eexprtoken.md
        │   ├── uassetapi.kismet.bytecode.escriptinstrumentationtype.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_addmulticastdelegate.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_arrayconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_arraygetbyref.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_assert.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_binddelegate.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_bitfieldconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_breakpoint.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_byteconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_callmath.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_callmulticastdelegate.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_castbase.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_classcontext.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_classsparsedatavariable.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_clearmulticastdelegate.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_computedjump.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_context.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_context_failsilent.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_crossinterfacecast.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_defaultvariable.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_deprecatedop4a.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_doubleconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_dynamiccast.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endarray.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endarrayconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endfunctionparms.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endmap.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endmapconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endofscript.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endparmvalue.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endset.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endsetconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_endstructconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_false.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_fieldpathconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_finalfunction.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_floatconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_instancedelegate.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_instancevariable.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_instrumentationevent.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_int64const.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_intconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_intconstbyte.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_interfacecontext.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_interfacetoobjcast.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_intone.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_intzero.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_jump.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_jumpifnot.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_let.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_letbase.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_letbool.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_letdelegate.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_letmulticastdelegate.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_letobj.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_letvalueonpersistentframe.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_letweakobjptr.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_localfinalfunction.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_localoutvariable.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_localvariable.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_localvirtualfunction.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_mapconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_metacast.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_nameconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_nointerface.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_noobject.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_nothing.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_nothingint32.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_objectconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_objtointerfacecast.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_popexecutionflow.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_popexecutionflowifnot.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_primitivecast.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_propertyconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_pushexecutionflow.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_removemulticastdelegate.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_return.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_rotationconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_self.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_setarray.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_setconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_setmap.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_setset.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_skip.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_skipoffsetconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_softobjectconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_stringconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_structconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_structmembercontext.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_switchvalue.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_textconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_tracepoint.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_transformconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_true.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_uint64const.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_unicodestringconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_variablebase.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_vector3fconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_vectorconst.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_virtualfunction.md
        │   ├── uassetapi.kismet.bytecode.expressions.ex_wiretracepoint.md
        │   ├── uassetapi.kismet.bytecode.expressions.fkismetswitchcase.md
        │   ├── uassetapi.kismet.bytecode.expressionserializer.md
        │   ├── uassetapi.kismet.bytecode.fscripttext.md
        │   ├── uassetapi.kismet.bytecode.kismetexpression-1.md
        │   ├── uassetapi.kismet.bytecode.kismetexpression.md
        │   ├── uassetapi.kismet.bytecode.kismetpropertypointer.md
        │   ├── uassetapi.kismet.kismetserializer.md
        │   ├── uassetapi.mainserializer.md
        │   ├── uassetapi.namemapoutofrangeexception.md
        │   ├── uassetapi.pakbuilder.md
        │   ├── uassetapi.pakcompression.md
        │   ├── uassetapi.pakreader.md
        │   ├── uassetapi.pakversion.md
        │   ├── uassetapi.pakwriter.md
        │   ├── uassetapi.propertytypes.objects.ancestryinfo.md
        │   ├── uassetapi.propertytypes.objects.arraypropertydata.md
        │   ├── uassetapi.propertytypes.objects.assetobjectpropertydata.md
        │   ├── uassetapi.propertytypes.objects.boolpropertydata.md
        │   ├── uassetapi.propertytypes.objects.bytepropertydata.md
        │   ├── uassetapi.propertytypes.objects.bytepropertytype.md
        │   ├── uassetapi.propertytypes.objects.delegatepropertydata.md
        │   ├── uassetapi.propertytypes.objects.doublepropertydata.md
        │   ├── uassetapi.propertytypes.objects.enumpropertydata.md
        │   ├── uassetapi.propertytypes.objects.eoverriddenpropertyoperation.md
        │   ├── uassetapi.propertytypes.objects.epropertytagextension.md
        │   ├── uassetapi.propertytypes.objects.epropertytagflags.md
        │   ├── uassetapi.propertytypes.objects.etextflag.md
        │   ├── uassetapi.propertytypes.objects.etransformtype.md
        │   ├── uassetapi.propertytypes.objects.fdelegate.md
        │   ├── uassetapi.propertytypes.objects.fformatargumentdata.md
        │   ├── uassetapi.propertytypes.objects.fformatargumentvalue.md
        │   ├── uassetapi.propertytypes.objects.fieldpathpropertydata.md
        │   ├── uassetapi.propertytypes.objects.floatpropertydata.md
        │   ├── uassetapi.propertytypes.objects.fnumberformattingoptions.md
        │   ├── uassetapi.propertytypes.objects.fsoftobjectpath.md
        │   ├── uassetapi.propertytypes.objects.ftoplevelassetpath.md
        │   ├── uassetapi.propertytypes.objects.int16propertydata.md
        │   ├── uassetapi.propertytypes.objects.int64propertydata.md
        │   ├── uassetapi.propertytypes.objects.int8propertydata.md
        │   ├── uassetapi.propertytypes.objects.interfacepropertydata.md
        │   ├── uassetapi.propertytypes.objects.intpropertydata.md
        │   ├── uassetapi.propertytypes.objects.istruct-1.md
        │   ├── uassetapi.propertytypes.objects.mappropertydata.md
        │   ├── uassetapi.propertytypes.objects.multicastdelegatepropertydata.md
        │   ├── uassetapi.propertytypes.objects.multicastinlinedelegatepropertydata.md
        │   ├── uassetapi.propertytypes.objects.multicastsparsedelegatepropertydata.md
        │   ├── uassetapi.propertytypes.objects.namepropertydata.md
        │   ├── uassetapi.propertytypes.objects.objectpropertydata.md
        │   ├── uassetapi.propertytypes.objects.propertydata-1.md
        │   ├── uassetapi.propertytypes.objects.propertydata.md
        │   ├── uassetapi.propertytypes.objects.propertyserializationcontext.md
        │   ├── uassetapi.propertytypes.objects.setpropertydata.md
        │   ├── uassetapi.propertytypes.objects.softobjectpropertydata.md
        │   ├── uassetapi.propertytypes.objects.strpropertydata.md
        │   ├── uassetapi.propertytypes.objects.texthistorytype.md
        │   ├── uassetapi.propertytypes.objects.textpropertydata.md
        │   ├── uassetapi.propertytypes.objects.uint16propertydata.md
        │   ├── uassetapi.propertytypes.objects.uint32propertydata.md
        │   ├── uassetapi.propertytypes.objects.uint64propertydata.md
        │   ├── uassetapi.propertytypes.objects.unknownpropertydata.md
        │   ├── uassetapi.propertytypes.objects.weakobjectpropertydata.md
        │   ├── uassetapi.propertytypes.structs.box2dpropertydata.md
        │   ├── uassetapi.propertytypes.structs.box2fpropertydata.md
        │   ├── uassetapi.propertytypes.structs.boxpropertydata.md
        │   ├── uassetapi.propertytypes.structs.clothloddatacommonpropertydata.md
        │   ├── uassetapi.propertytypes.structs.clothloddatapropertydata.md
        │   ├── uassetapi.propertytypes.structs.clothtetherdatapropertydata.md
        │   ├── uassetapi.propertytypes.structs.colormaterialinputpropertydata.md
        │   ├── uassetapi.propertytypes.structs.colorpropertydata.md
        │   ├── uassetapi.propertytypes.structs.datetimepropertydata.md
        │   ├── uassetapi.propertytypes.structs.deprecateslatevector2dpropertydata.md
        │   ├── uassetapi.propertytypes.structs.esectionevaluationflags.md
        │   ├── uassetapi.propertytypes.structs.expressioninputpropertydata.md
        │   ├── uassetapi.propertytypes.structs.fentityandmetadataindex.md
        │   ├── uassetapi.propertytypes.structs.fentry.md
        │   ├── uassetapi.propertytypes.structs.fevaluationtreeentryhandle.md
        │   ├── uassetapi.propertytypes.structs.flevelsequencelegacyobjectreference.md
        │   ├── uassetapi.propertytypes.structs.floatrangepropertydata.md
        │   ├── uassetapi.propertytypes.structs.fmeshtomeshvertdata.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenechannel-1.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenedoublechannel.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenedoublevalue.md
        │   ├── uassetapi.propertytypes.structs.fmoviesceneevaluationfieldentitytree.md
        │   ├── uassetapi.propertytypes.structs.fmoviesceneevaluationkey.md
        │   ├── uassetapi.propertytypes.structs.fmoviesceneevaluationtree.md
        │   ├── uassetapi.propertytypes.structs.fmoviesceneevaluationtreenode.md
        │   ├── uassetapi.propertytypes.structs.fmoviesceneevaluationtreenodehandle.md
        │   ├── uassetapi.propertytypes.structs.fmoviesceneeventparameters.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenefloatchannel.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenefloatvalue.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenesegment.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenesubsectiondata.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenesubsectionfielddata.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenesubsequencetree.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenesubsequencetreeentry.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenetangentdata.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenetrackfielddata.md
        │   ├── uassetapi.propertytypes.structs.fmoviescenevalue-1.md
        │   ├── uassetapi.propertytypes.structs.fnamecurvekey.md
        │   ├── uassetapi.propertytypes.structs.fnavagentselector.md
        │   ├── uassetapi.propertytypes.structs.fontcharacterpropertydata.md
        │   ├── uassetapi.propertytypes.structs.fontdatapropertydata.md
        │   ├── uassetapi.propertytypes.structs.framenumberpropertydata.md
        │   ├── uassetapi.propertytypes.structs.fsectionevaluationdatatree.md
        │   ├── uassetapi.propertytypes.structs.fstringcurvekey.md
        │   ├── uassetapi.propertytypes.structs.gameplaytagcontainerpropertydata.md
        │   ├── uassetapi.propertytypes.structs.guidpropertydata.md
        │   ├── uassetapi.propertytypes.structs.intpointpropertydata.md
        │   ├── uassetapi.propertytypes.structs.intvector2propertydata.md
        │   ├── uassetapi.propertytypes.structs.intvectorpropertydata.md
        │   ├── uassetapi.propertytypes.structs.keyhandlemappropertydata.md
        │   ├── uassetapi.propertytypes.structs.levelsequenceobjectreferencemappropertydata.md
        │   ├── uassetapi.propertytypes.structs.linearcolorpropertydata.md
        │   ├── uassetapi.propertytypes.structs.materialattributesinputpropertydata.md
        │   ├── uassetapi.propertytypes.structs.materialoverridenanitepropertydata.md
        │   ├── uassetapi.propertytypes.structs.matrixpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenedoublechannelpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviesceneevaltemplateptrpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviesceneevaluationfieldentitytreepropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviesceneevaluationkeypropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviesceneeventparameterspropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenefloatchannelpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenefloatvaluepropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviesceneframerangepropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenegenerationledgerpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenesegmentidentifierpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenesegmentpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenesequenceidpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenesequenceinstancedataptrpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenesubsectionfielddatapropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenesubsequencetreepropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenetemplatepropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenetrackfielddatapropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenetrackidentifierpropertydata.md
        │   ├── uassetapi.propertytypes.structs.moviescenetrackimplementationptrpropertydata.md
        │   ├── uassetapi.propertytypes.structs.namecurvekeypropertydata.md
        │   ├── uassetapi.propertytypes.structs.navagentselectorpropertydata.md
        │   ├── uassetapi.propertytypes.structs.niagaradatachannelvariablepropertydata.md
        │   ├── uassetapi.propertytypes.structs.niagaradatainterfacegpuparaminfopropertydata.md
        │   ├── uassetapi.propertytypes.structs.niagaravariablebasepropertydata.md
        │   ├── uassetapi.propertytypes.structs.niagaravariablepropertydata.md
        │   ├── uassetapi.propertytypes.structs.niagaravariablewithoffsetpropertydata.md
        │   ├── uassetapi.propertytypes.structs.perplatformboolpropertydata.md
        │   ├── uassetapi.propertytypes.structs.perplatformfloatpropertydata.md
        │   ├── uassetapi.propertytypes.structs.perplatformframeratepropertydata.md
        │   ├── uassetapi.propertytypes.structs.perplatformintpropertydata.md
        │   ├── uassetapi.propertytypes.structs.perqualitylevelfloatpropertydata.md
        │   ├── uassetapi.propertytypes.structs.perqualitylevelintpropertydata.md
        │   ├── uassetapi.propertytypes.structs.planepropertydata.md
        │   ├── uassetapi.propertytypes.structs.quatpropertydata.md
        │   ├── uassetapi.propertytypes.structs.rawstructpropertydata.md
        │   ├── uassetapi.propertytypes.structs.richcurvekeypropertydata.md
        │   ├── uassetapi.propertytypes.structs.rotatorpropertydata.md
        │   ├── uassetapi.propertytypes.structs.scalarmaterialinputpropertydata.md
        │   ├── uassetapi.propertytypes.structs.sectionevaluationdatatreepropertydata.md
        │   ├── uassetapi.propertytypes.structs.skeletalmeshareaweightedtrianglesamplerpropertydata.md
        │   ├── uassetapi.propertytypes.structs.skeletalmeshsamplinglodbuiltdatapropertydata.md
        │   ├── uassetapi.propertytypes.structs.smartnamepropertydata.md
        │   ├── uassetapi.propertytypes.structs.softassetpathpropertydata.md
        │   ├── uassetapi.propertytypes.structs.softclasspathpropertydata.md
        │   ├── uassetapi.propertytypes.structs.softobjectpathpropertydata.md
        │   ├── uassetapi.propertytypes.structs.stringassetreferencepropertydata.md
        │   ├── uassetapi.propertytypes.structs.stringclassreferencepropertydata.md
        │   ├── uassetapi.propertytypes.structs.stringcurvekeypropertydata.md
        │   ├── uassetapi.propertytypes.structs.structpropertydata.md
        │   ├── uassetapi.propertytypes.structs.tevaluationtreeentrycontainer-1.md
        │   ├── uassetapi.propertytypes.structs.timespanpropertydata.md
        │   ├── uassetapi.propertytypes.structs.tmoviesceneevaluationtree-1.md
        │   ├── uassetapi.propertytypes.structs.twovectorspropertydata.md
        │   ├── uassetapi.propertytypes.structs.vector2dpropertydata.md
        │   ├── uassetapi.propertytypes.structs.vector2fpropertydata.md
        │   ├── uassetapi.propertytypes.structs.vector2materialinputpropertydata.md
        │   ├── uassetapi.propertytypes.structs.vector3fpropertydata.md
        │   ├── uassetapi.propertytypes.structs.vector4fpropertydata.md
        │   ├── uassetapi.propertytypes.structs.vector4propertydata.md
        │   ├── uassetapi.propertytypes.structs.vectormaterialinputpropertydata.md
        │   ├── uassetapi.propertytypes.structs.vectornetquantize100propertydata.md
        │   ├── uassetapi.propertytypes.structs.vectornetquantize10propertydata.md
        │   ├── uassetapi.propertytypes.structs.vectornetquantizenormalpropertydata.md
        │   ├── uassetapi.propertytypes.structs.vectornetquantizepropertydata.md
        │   ├── uassetapi.propertytypes.structs.vectorpropertydata.md
        │   ├── uassetapi.propertytypes.structs.viewtargetblendfunction.md
        │   ├── uassetapi.propertytypes.structs.viewtargetblendparamspropertydata.md
        │   ├── uassetapi.propertytypes.structs.weightedrandomsamplerpropertydata.md
        │   ├── uassetapi.repakinterop.md
        │   ├── uassetapi.streamcallbacks.md
        │   ├── uassetapi.structtypes.skeletalmeshsamplingregionbuiltdatapropertydata.md
        │   ├── uassetapi.uaputils.md
        │   ├── uassetapi.uasset.md
        │   ├── uassetapi.unknownengineversionexception.md
        │   ├── uassetapi.unrealbinaryreader.md
        │   ├── uassetapi.unrealbinarywriter.md
        │   ├── uassetapi.unrealtypes.comparer2-1.md
        │   ├── uassetapi.unrealtypes.dictionaryenumerator-2.md
        │   ├── uassetapi.unrealtypes.eaxis.md
        │   ├── uassetapi.unrealtypes.eclassflags.md
        │   ├── uassetapi.unrealtypes.efonthinting.md
        │   ├── uassetapi.unrealtypes.efontloadingpolicy.md
        │   ├── uassetapi.unrealtypes.efunctionflags.md
        │   ├── uassetapi.unrealtypes.einterpcurvemode.md
        │   ├── uassetapi.unrealtypes.emappednametype.md
        │   ├── uassetapi.unrealtypes.engineenums.animationcompressionformat.md
        │   ├── uassetapi.unrealtypes.engineenums.animationkeyformat.md
        │   ├── uassetapi.unrealtypes.engineenums.animphyscollisiontype.md
        │   ├── uassetapi.unrealtypes.engineenums.animphystwistaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.beam2sourcetargetmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.beam2sourcetargettangentmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.beammodifiertype.md
        │   ├── uassetapi.unrealtypes.engineenums.cylinderheightaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.distributionparammode.md
        │   ├── uassetapi.unrealtypes.engineenums.eactorupdateoverlapsmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eadditiveanimationtype.md
        │   ├── uassetapi.unrealtypes.engineenums.eadditivebaseposetype.md
        │   ├── uassetapi.unrealtypes.engineenums.eadmanagerdelegate.md
        │   ├── uassetapi.unrealtypes.engineenums.eairabsorptionmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.ealphablendoption.md
        │   ├── uassetapi.unrealtypes.engineenums.ealphachannelmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eangularconstraintmotion.md
        │   ├── uassetapi.unrealtypes.engineenums.eangulardrivemode.md
        │   ├── uassetapi.unrealtypes.engineenums.eanimalphainputtype.md
        │   ├── uassetapi.unrealtypes.engineenums.eanimassetcurveflags.md
        │   ├── uassetapi.unrealtypes.engineenums.eanimationmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eanimcurvetype.md
        │   ├── uassetapi.unrealtypes.engineenums.eanimgrouprole.md
        │   ├── uassetapi.unrealtypes.engineenums.eaniminterpolationtype.md
        │   ├── uassetapi.unrealtypes.engineenums.eanimlinkmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eanimnotifyeventtype.md
        │   ├── uassetapi.unrealtypes.engineenums.eantialiasingmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eapplicationstate.md
        │   ├── uassetapi.unrealtypes.engineenums.easpectratioaxisconstraint.md
        │   ├── uassetapi.unrealtypes.engineenums.eattachlocation.md
        │   ├── uassetapi.unrealtypes.engineenums.eattachmentrule.md
        │   ├── uassetapi.unrealtypes.engineenums.eattenuationdistancemodel.md
        │   ├── uassetapi.unrealtypes.engineenums.eattenuationshape.md
        │   ├── uassetapi.unrealtypes.engineenums.eattractorparticleselectionmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eaudiocomponentplaystate.md
        │   ├── uassetapi.unrealtypes.engineenums.eaudiofadercurve.md
        │   ├── uassetapi.unrealtypes.engineenums.eaudiooutputtarget.md
        │   ├── uassetapi.unrealtypes.engineenums.eaudiorecordingexporttype.md
        │   ├── uassetapi.unrealtypes.engineenums.eautoexposuremethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eautoexposuremethodui.md
        │   ├── uassetapi.unrealtypes.engineenums.eautopossessai.md
        │   ├── uassetapi.unrealtypes.engineenums.eautoreceiveinput.md
        │   ├── uassetapi.unrealtypes.engineenums.eaxisoption.md
        │   ├── uassetapi.unrealtypes.engineenums.ebeam2method.md
        │   ├── uassetapi.unrealtypes.engineenums.ebeamtapermethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eblendablelocation.md
        │   ├── uassetapi.unrealtypes.engineenums.eblendmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eblendspaceaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.ebloommethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eblueprintcompilemode.md
        │   ├── uassetapi.unrealtypes.engineenums.eblueprintnativizationflag.md
        │   ├── uassetapi.unrealtypes.engineenums.eblueprintpinstyletype.md
        │   ├── uassetapi.unrealtypes.engineenums.eblueprintstatus.md
        │   ├── uassetapi.unrealtypes.engineenums.eblueprinttype.md
        │   ├── uassetapi.unrealtypes.engineenums.ebodycollisionresponse.md
        │   ├── uassetapi.unrealtypes.engineenums.eboneaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.ebonecontrolspace.md
        │   ├── uassetapi.unrealtypes.engineenums.ebonefilteractionoption.md
        │   ├── uassetapi.unrealtypes.engineenums.ebonerotationsource.md
        │   ├── uassetapi.unrealtypes.engineenums.ebonespaces.md
        │   ├── uassetapi.unrealtypes.engineenums.ebonetranslationretargetingmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ebonevisibilitystatus.md
        │   ├── uassetapi.unrealtypes.engineenums.ebrushtype.md
        │   ├── uassetapi.unrealtypes.engineenums.ecameraalphablendmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ecameraanimplayspace.md
        │   ├── uassetapi.unrealtypes.engineenums.ecameraprojectionmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ecamerashakeattenuation.md
        │   ├── uassetapi.unrealtypes.engineenums.ecanbecharacterbase.md
        │   ├── uassetapi.unrealtypes.engineenums.ecancreateconnectionresponse.md
        │   ├── uassetapi.unrealtypes.engineenums.echannelmaskparametercolor.md
        │   ├── uassetapi.unrealtypes.engineenums.eclampmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eclearsceneoptions.md
        │   ├── uassetapi.unrealtypes.engineenums.eclothmassmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ecloudstoragedelegate.md
        │   ├── uassetapi.unrealtypes.engineenums.ecollisionchannel.md
        │   ├── uassetapi.unrealtypes.engineenums.ecollisionenabled.md
        │   ├── uassetapi.unrealtypes.engineenums.ecollisionresponse.md
        │   ├── uassetapi.unrealtypes.engineenums.ecollisiontraceflag.md
        │   ├── uassetapi.unrealtypes.engineenums.ecomponentcreationmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.ecomponentmobility.md
        │   ├── uassetapi.unrealtypes.engineenums.ecomponentsockettype.md
        │   ├── uassetapi.unrealtypes.engineenums.ecomponenttype.md
        │   ├── uassetapi.unrealtypes.engineenums.ecompositetexturemode.md
        │   ├── uassetapi.unrealtypes.engineenums.ecompositingsamplecount.md
        │   ├── uassetapi.unrealtypes.engineenums.econstraintframe.md
        │   ├── uassetapi.unrealtypes.engineenums.econstrainttransform.md
        │   ├── uassetapi.unrealtypes.engineenums.econtrolconstraint.md
        │   ├── uassetapi.unrealtypes.engineenums.econtrolleranalogstick.md
        │   ├── uassetapi.unrealtypes.engineenums.ecopytype.md
        │   ├── uassetapi.unrealtypes.engineenums.ecsgoper.md
        │   ├── uassetapi.unrealtypes.engineenums.ecurveblendoption.md
        │   ├── uassetapi.unrealtypes.engineenums.ecurvetablemode.md
        │   ├── uassetapi.unrealtypes.engineenums.ecustomdepthstencil.md
        │   ├── uassetapi.unrealtypes.engineenums.ecustommaterialoutputtype.md
        │   ├── uassetapi.unrealtypes.engineenums.ecustomtimestepsynchronizationstate.md
        │   ├── uassetapi.unrealtypes.engineenums.edecalblendmode.md
        │   ├── uassetapi.unrealtypes.engineenums.edecompressiontype.md
        │   ├── uassetapi.unrealtypes.engineenums.edefaultbackbufferpixelformat.md
        │   ├── uassetapi.unrealtypes.engineenums.edemoplayfailure.md
        │   ├── uassetapi.unrealtypes.engineenums.edepthoffieldfunctionvalue.md
        │   ├── uassetapi.unrealtypes.engineenums.edepthoffieldmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.edetachmentrule.md
        │   ├── uassetapi.unrealtypes.engineenums.edetailmode.md
        │   ├── uassetapi.unrealtypes.engineenums.edistributionvectorlockflags.md
        │   ├── uassetapi.unrealtypes.engineenums.edistributionvectormirrorflags.md
        │   ├── uassetapi.unrealtypes.engineenums.edofmode.md
        │   ├── uassetapi.unrealtypes.engineenums.edrawdebugitemtype.md
        │   ├── uassetapi.unrealtypes.engineenums.edrawdebugtrace.md
        │   ├── uassetapi.unrealtypes.engineenums.edynamicforcefeedbackaction.md
        │   ├── uassetapi.unrealtypes.engineenums.eearlyzpass.md
        │   ├── uassetapi.unrealtypes.engineenums.eeasingfunc.md
        │   ├── uassetapi.unrealtypes.engineenums.eedgraphpindirection.md
        │   ├── uassetapi.unrealtypes.engineenums.eemitterdynamicparametervalue.md
        │   ├── uassetapi.unrealtypes.engineenums.eemitternormalsmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eemitterrendermode.md
        │   ├── uassetapi.unrealtypes.engineenums.eendplayreason.md
        │   ├── uassetapi.unrealtypes.engineenums.eevaluatecurvetableresult.md
        │   ├── uassetapi.unrealtypes.engineenums.eevaluatordatasource.md
        │   ├── uassetapi.unrealtypes.engineenums.eevaluatormode.md
        │   ├── uassetapi.unrealtypes.engineenums.efastarrayserializerdeltaflags.md
        │   ├── uassetapi.unrealtypes.engineenums.efilterinterpolationtype.md
        │   ├── uassetapi.unrealtypes.engineenums.efontcachetype.md
        │   ├── uassetapi.unrealtypes.engineenums.efontimportcharacterset.md
        │   ├── uassetapi.unrealtypes.engineenums.eformatargumenttype.md
        │   ├── uassetapi.unrealtypes.engineenums.efrictioncombinemode.md
        │   ├── uassetapi.unrealtypes.engineenums.efullyloadpackagetype.md
        │   ├── uassetapi.unrealtypes.engineenums.efunctioninputtype.md
        │   ├── uassetapi.unrealtypes.engineenums.egbufferformat.md
        │   ├── uassetapi.unrealtypes.engineenums.egrammaticalgender.md
        │   ├── uassetapi.unrealtypes.engineenums.egrammaticalnumber.md
        │   ├── uassetapi.unrealtypes.engineenums.egraphaxisstyle.md
        │   ├── uassetapi.unrealtypes.engineenums.egraphdatastyle.md
        │   ├── uassetapi.unrealtypes.engineenums.egraphtype.md
        │   ├── uassetapi.unrealtypes.engineenums.ehascustomnavigablegeometry.md
        │   ├── uassetapi.unrealtypes.engineenums.ehitproxypriority.md
        │   ├── uassetapi.unrealtypes.engineenums.ehoriztextaligment.md
        │   ├── uassetapi.unrealtypes.engineenums.eimportancelevel.md
        │   ├── uassetapi.unrealtypes.engineenums.eimportanceweight.md
        │   ├── uassetapi.unrealtypes.engineenums.eindirectlightingcachequality.md
        │   ├── uassetapi.unrealtypes.engineenums.einertializationbonestate.md
        │   ├── uassetapi.unrealtypes.engineenums.einertializationspace.md
        │   ├── uassetapi.unrealtypes.engineenums.einertializationstate.md
        │   ├── uassetapi.unrealtypes.engineenums.einitialoscillatoroffset.md
        │   ├── uassetapi.unrealtypes.engineenums.einputevent.md
        │   ├── uassetapi.unrealtypes.engineenums.einterpmoveaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.einterptobehaviourtype.md
        │   ├── uassetapi.unrealtypes.engineenums.einterptrackmoverotmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ekinematicbonesupdatetophysics.md
        │   ├── uassetapi.unrealtypes.engineenums.elandscapecullingprecision.md
        │   ├── uassetapi.unrealtypes.engineenums.elegendposition.md
        │   ├── uassetapi.unrealtypes.engineenums.elerpinterpolationmode.md
        │   ├── uassetapi.unrealtypes.engineenums.elightingbuildquality.md
        │   ├── uassetapi.unrealtypes.engineenums.elightmappaddingtype.md
        │   ├── uassetapi.unrealtypes.engineenums.elightmaptype.md
        │   ├── uassetapi.unrealtypes.engineenums.elightunits.md
        │   ├── uassetapi.unrealtypes.engineenums.elinearconstraintmotion.md
        │   ├── uassetapi.unrealtypes.engineenums.elocationbonesocketselectionmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.elocationbonesocketsource.md
        │   ├── uassetapi.unrealtypes.engineenums.elocationemitterselectionmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.elocationskelvertsurfacesource.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialattributeblend.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialdecalresponse.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialdomain.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialexposedtextureproperty.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialexposedviewproperty.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialfunctionusage.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialmergetype.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialparameterassociation.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialpositiontransformsource.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialproperty.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialsamplertype.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialsceneattributeinputmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialshadingmodel.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialstencilcompare.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialtessellationmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialusage.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialvectorcoordtransform.md
        │   ├── uassetapi.unrealtypes.engineenums.ematerialvectorcoordtransformsource.md
        │   ├── uassetapi.unrealtypes.engineenums.ematrixcolumns.md
        │   ├── uassetapi.unrealtypes.engineenums.emaxconcurrentresolutionrule.md
        │   ├── uassetapi.unrealtypes.engineenums.emeshbufferaccess.md
        │   ├── uassetapi.unrealtypes.engineenums.emeshcamerafacingoptions.md
        │   ├── uassetapi.unrealtypes.engineenums.emeshcamerafacingupaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.emeshfeatureimportance.md
        │   ├── uassetapi.unrealtypes.engineenums.emeshinstancingreplacementmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.emeshlodselectiontype.md
        │   ├── uassetapi.unrealtypes.engineenums.emeshmergetype.md
        │   ├── uassetapi.unrealtypes.engineenums.emeshscreenalignment.md
        │   ├── uassetapi.unrealtypes.engineenums.emicrotransactiondelegate.md
        │   ├── uassetapi.unrealtypes.engineenums.emicrotransactionresult.md
        │   ├── uassetapi.unrealtypes.engineenums.emobilemsaasamplecount.md
        │   ├── uassetapi.unrealtypes.engineenums.emoduletype.md
        │   ├── uassetapi.unrealtypes.engineenums.emonochannelupmixmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.emontagenotifyticktype.md
        │   ├── uassetapi.unrealtypes.engineenums.emontageplayreturntype.md
        │   ├── uassetapi.unrealtypes.engineenums.emontagesubstepresult.md
        │   ├── uassetapi.unrealtypes.engineenums.emousecapturemode.md
        │   ├── uassetapi.unrealtypes.engineenums.emouselockmode.md
        │   ├── uassetapi.unrealtypes.engineenums.emovecomponentaction.md
        │   ├── uassetapi.unrealtypes.engineenums.emovementmode.md
        │   ├── uassetapi.unrealtypes.engineenums.enaturalsoundfalloffmode.md
        │   ├── uassetapi.unrealtypes.engineenums.enavdatagatheringmode.md
        │   ├── uassetapi.unrealtypes.engineenums.enavdatagatheringmodeconfig.md
        │   ├── uassetapi.unrealtypes.engineenums.enavigationoptionflag.md
        │   ├── uassetapi.unrealtypes.engineenums.enavigationqueryresult.md
        │   ├── uassetapi.unrealtypes.engineenums.enavlinkdirection.md
        │   ├── uassetapi.unrealtypes.engineenums.enavpathevent.md
        │   ├── uassetapi.unrealtypes.engineenums.enetdormancy.md
        │   ├── uassetapi.unrealtypes.engineenums.enetrole.md
        │   ├── uassetapi.unrealtypes.engineenums.enetworkfailure.md
        │   ├── uassetapi.unrealtypes.engineenums.enetworklagstate.md
        │   ├── uassetapi.unrealtypes.engineenums.enetworksmoothingmode.md
        │   ├── uassetapi.unrealtypes.engineenums.enodeadvancedpins.md
        │   ├── uassetapi.unrealtypes.engineenums.enodeenabledstate.md
        │   ├── uassetapi.unrealtypes.engineenums.enodetitletype.md
        │   ├── uassetapi.unrealtypes.engineenums.enoisefunction.md
        │   ├── uassetapi.unrealtypes.engineenums.enormalmode.md
        │   ├── uassetapi.unrealtypes.engineenums.enotifyfiltertype.md
        │   ├── uassetapi.unrealtypes.engineenums.enotifytriggermode.md
        │   ├── uassetapi.unrealtypes.engineenums.eobjecttypequery.md
        │   ├── uassetapi.unrealtypes.engineenums.eocclusioncombinemode.md
        │   ├── uassetapi.unrealtypes.engineenums.eopacitysourcemode.md
        │   ├── uassetapi.unrealtypes.engineenums.eoptimizationtype.md
        │   ├── uassetapi.unrealtypes.engineenums.eorbitchainmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eoscillatorwaveform.md
        │   ├── uassetapi.unrealtypes.engineenums.eoverlapfilteroption.md
        │   ├── uassetapi.unrealtypes.engineenums.epanningmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticleaxislock.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticleburstmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlecameraoffsetupdatemethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlecollisioncomplete.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlecollisionmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlecollisionresponse.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticledetailmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticleeventtype.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlescreenalignment.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlesignificancelevel.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlesortmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlesourceselectionmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlesubuvinterpmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlesysparamtype.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlesysteminsignificancereaction.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlesystemocclusionboundsmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticlesystemupdatemode.md
        │   ├── uassetapi.unrealtypes.engineenums.eparticleuvflipmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ephysbodyop.md
        │   ├── uassetapi.unrealtypes.engineenums.ephysicalmaterialmaskcolor.md
        │   ├── uassetapi.unrealtypes.engineenums.ephysicalsurface.md
        │   ├── uassetapi.unrealtypes.engineenums.ephysicstransformupdatemode.md
        │   ├── uassetapi.unrealtypes.engineenums.ephysicstype.md
        │   ├── uassetapi.unrealtypes.engineenums.epincontainertype.md
        │   ├── uassetapi.unrealtypes.engineenums.epinhidingmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eplaneconstraintaxissetting.md
        │   ├── uassetapi.unrealtypes.engineenums.eplatforminterfacedatatype.md
        │   ├── uassetapi.unrealtypes.engineenums.epostcopyoperation.md
        │   ├── uassetapi.unrealtypes.engineenums.epreviewanimationblueprintapplicationmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eprimaryassetcookrule.md
        │   ├── uassetapi.unrealtypes.engineenums.epriorityattenuationmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.eproxynormalcomputationmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.epscpoolmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.equitpreference.md
        │   ├── uassetapi.unrealtypes.engineenums.eradialimpulsefalloff.md
        │   ├── uassetapi.unrealtypes.engineenums.erawcurvetracktypes.md
        │   ├── uassetapi.unrealtypes.engineenums.eraytracingglobalilluminationtype.md
        │   ├── uassetapi.unrealtypes.engineenums.ereflectedandrefractedraytracedshadows.md
        │   ├── uassetapi.unrealtypes.engineenums.ereflectionsourcetype.md
        │   ├── uassetapi.unrealtypes.engineenums.ereflectionstype.md
        │   ├── uassetapi.unrealtypes.engineenums.erefractionmode.md
        │   ├── uassetapi.unrealtypes.engineenums.erelativetransformspace.md
        │   ├── uassetapi.unrealtypes.engineenums.erendererstencilmask.md
        │   ├── uassetapi.unrealtypes.engineenums.erenderfocusrule.md
        │   ├── uassetapi.unrealtypes.engineenums.ereporterlinestyle.md
        │   ├── uassetapi.unrealtypes.engineenums.ereverbsendmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.erichcurvecompressionformat.md
        │   ├── uassetapi.unrealtypes.engineenums.erichcurveextrapolation.md
        │   ├── uassetapi.unrealtypes.engineenums.erichcurveinterpmode.md
        │   ├── uassetapi.unrealtypes.engineenums.erichcurvekeytimecompressionformat.md
        │   ├── uassetapi.unrealtypes.engineenums.erichcurvetangentmode.md
        │   ├── uassetapi.unrealtypes.engineenums.erichcurvetangentweightmode.md
        │   ├── uassetapi.unrealtypes.engineenums.erootmotionaccumulatemode.md
        │   ├── uassetapi.unrealtypes.engineenums.erootmotionfinishvelocitymode.md
        │   ├── uassetapi.unrealtypes.engineenums.erootmotionmode.md
        │   ├── uassetapi.unrealtypes.engineenums.erootmotionrootlock.md
        │   ├── uassetapi.unrealtypes.engineenums.erootmotionsourcesettingsflags.md
        │   ├── uassetapi.unrealtypes.engineenums.erootmotionsourcestatusflags.md
        │   ├── uassetapi.unrealtypes.engineenums.erotatorquantization.md
        │   ├── uassetapi.unrealtypes.engineenums.eroundingmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eruntimevirtualtexturemainpasstype.md
        │   ├── uassetapi.unrealtypes.engineenums.eruntimevirtualtexturematerialtype.md
        │   ├── uassetapi.unrealtypes.engineenums.eruntimevirtualtexturemipvaluemode.md
        │   ├── uassetapi.unrealtypes.engineenums.esamplersourcemode.md
        │   ├── uassetapi.unrealtypes.engineenums.escenecapturecompositemode.md
        │   ├── uassetapi.unrealtypes.engineenums.escenecaptureprimitiverendermode.md
        │   ├── uassetapi.unrealtypes.engineenums.escenecapturesource.md
        │   ├── uassetapi.unrealtypes.engineenums.escenedepthprioritygroup.md
        │   ├── uassetapi.unrealtypes.engineenums.escenetextureid.md
        │   ├── uassetapi.unrealtypes.engineenums.escreenorientation.md
        │   ├── uassetapi.unrealtypes.engineenums.esendlevelcontrolmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.esettingsdof.md
        │   ├── uassetapi.unrealtypes.engineenums.esettingslockedaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.eshadowmapflags.md
        │   ├── uassetapi.unrealtypes.engineenums.eskeletalmeshgeoimportversions.md
        │   ├── uassetapi.unrealtypes.engineenums.eskeletalmeshskinningimportversions.md
        │   ├── uassetapi.unrealtypes.engineenums.eskincachedefaultbehavior.md
        │   ├── uassetapi.unrealtypes.engineenums.eskincacheusage.md
        │   ├── uassetapi.unrealtypes.engineenums.eskyatmospheretransformmode.md
        │   ├── uassetapi.unrealtypes.engineenums.eskylightsourcetype.md
        │   ├── uassetapi.unrealtypes.engineenums.eslategesture.md
        │   ├── uassetapi.unrealtypes.engineenums.esleepfamily.md
        │   ├── uassetapi.unrealtypes.engineenums.esounddistancecalc.md
        │   ├── uassetapi.unrealtypes.engineenums.esoundgroup.md
        │   ├── uassetapi.unrealtypes.engineenums.esoundspatializationalgorithm.md
        │   ├── uassetapi.unrealtypes.engineenums.esoundwavefftsize.md
        │   ├── uassetapi.unrealtypes.engineenums.esoundwaveloadingbehavior.md
        │   ├── uassetapi.unrealtypes.engineenums.esourcebuschannels.md
        │   ├── uassetapi.unrealtypes.engineenums.esourcebussendlevelcontrolmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.espawnactorcollisionhandlingmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.espeedtreegeometrytype.md
        │   ├── uassetapi.unrealtypes.engineenums.espeedtreelodtype.md
        │   ├── uassetapi.unrealtypes.engineenums.espeedtreewindtype.md
        │   ├── uassetapi.unrealtypes.engineenums.esplinecoordinatespace.md
        │   ├── uassetapi.unrealtypes.engineenums.esplinemeshaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.esplinepointtype.md
        │   ├── uassetapi.unrealtypes.engineenums.estandbytype.md
        │   ├── uassetapi.unrealtypes.engineenums.estaticmeshreductionterimationcriterion.md
        │   ├── uassetapi.unrealtypes.engineenums.estereolayershape.md
        │   ├── uassetapi.unrealtypes.engineenums.estereolayertype.md
        │   ├── uassetapi.unrealtypes.engineenums.estreamingvolumeusage.md
        │   ├── uassetapi.unrealtypes.engineenums.esubmixsendmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.esubuvboundingvertexcount.md
        │   ├── uassetapi.unrealtypes.engineenums.esuggestprojvelocitytraceoption.md
        │   ├── uassetapi.unrealtypes.engineenums.eteleporttype.md
        │   ├── uassetapi.unrealtypes.engineenums.etemperatureseveritytype.md
        │   ├── uassetapi.unrealtypes.engineenums.etextgender.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturecolorchannel.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturecompressionquality.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturelossycompressionamount.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturemipcount.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturemiploadoptions.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturemipvaluemode.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturepoweroftwosetting.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturerendertargetformat.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturesamplerfilter.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturesizingtype.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturesourcearttype.md
        │   ├── uassetapi.unrealtypes.engineenums.etexturesourceformat.md
        │   ├── uassetapi.unrealtypes.engineenums.etickinggroup.md
        │   ├── uassetapi.unrealtypes.engineenums.etimecodeprovidersynchronizationstate.md
        │   ├── uassetapi.unrealtypes.engineenums.etimelinedirection.md
        │   ├── uassetapi.unrealtypes.engineenums.etimelinelengthmode.md
        │   ├── uassetapi.unrealtypes.engineenums.etimelinesigtype.md
        │   ├── uassetapi.unrealtypes.engineenums.etimestretchcurvemapping.md
        │   ├── uassetapi.unrealtypes.engineenums.etracetypequery.md
        │   ├── uassetapi.unrealtypes.engineenums.etrackactivecondition.md
        │   ├── uassetapi.unrealtypes.engineenums.etracktoggleaction.md
        │   ├── uassetapi.unrealtypes.engineenums.etrail2sourcemethod.md
        │   ├── uassetapi.unrealtypes.engineenums.etrailsrenderaxisoption.md
        │   ├── uassetapi.unrealtypes.engineenums.etrailwidthmode.md
        │   ├── uassetapi.unrealtypes.engineenums.etransitionblendmode.md
        │   ├── uassetapi.unrealtypes.engineenums.etransitionlogictype.md
        │   ├── uassetapi.unrealtypes.engineenums.etransitiontype.md
        │   ├── uassetapi.unrealtypes.engineenums.etranslucencylightingmode.md
        │   ├── uassetapi.unrealtypes.engineenums.etranslucencytype.md
        │   ├── uassetapi.unrealtypes.engineenums.etranslucentsortpolicy.md
        │   ├── uassetapi.unrealtypes.engineenums.etravelfailure.md
        │   ├── uassetapi.unrealtypes.engineenums.etraveltype.md
        │   ├── uassetapi.unrealtypes.engineenums.etwitterintegrationdelegate.md
        │   ├── uassetapi.unrealtypes.engineenums.etwitterrequestmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.etypeadvanceanim.md
        │   ├── uassetapi.unrealtypes.engineenums.euiscalingrule.md
        │   ├── uassetapi.unrealtypes.engineenums.eupdaterateshiftbucket.md
        │   ├── uassetapi.unrealtypes.engineenums.euserdefinedstructurestatus.md
        │   ├── uassetapi.unrealtypes.engineenums.euvoutput.md
        │   ├── uassetapi.unrealtypes.engineenums.evectorfieldconstructionop.md
        │   ├── uassetapi.unrealtypes.engineenums.evectornoisefunction.md
        │   ├── uassetapi.unrealtypes.engineenums.evectorquantization.md
        │   ├── uassetapi.unrealtypes.engineenums.evertexpaintaxis.md
        │   ├── uassetapi.unrealtypes.engineenums.everticaltextaligment.md
        │   ├── uassetapi.unrealtypes.engineenums.eviewmodeindex.md
        │   ├── uassetapi.unrealtypes.engineenums.eviewtargetblendfunction.md
        │   ├── uassetapi.unrealtypes.engineenums.evirtualizationmode.md
        │   ├── uassetapi.unrealtypes.engineenums.evisibilityaggressiveness.md
        │   ├── uassetapi.unrealtypes.engineenums.evisibilitybasedanimtickoption.md
        │   ├── uassetapi.unrealtypes.engineenums.evisibilitytrackaction.md
        │   ├── uassetapi.unrealtypes.engineenums.evisibilitytrackcondition.md
        │   ├── uassetapi.unrealtypes.engineenums.evoicesamplerate.md
        │   ├── uassetapi.unrealtypes.engineenums.evolumelightingmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.ewalkableslopebehavior.md
        │   ├── uassetapi.unrealtypes.engineenums.ewindowmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ewindowtitlebarmode.md
        │   ├── uassetapi.unrealtypes.engineenums.ewindsourcetype.md
        │   ├── uassetapi.unrealtypes.engineenums.eworldpositionincludedoffsets.md
        │   ├── uassetapi.unrealtypes.engineenums.fnavigationsystemrunmode.md
        │   ├── uassetapi.unrealtypes.engineenums.modulationparammode.md
        │   ├── uassetapi.unrealtypes.engineenums.particlereplaystate.md
        │   ├── uassetapi.unrealtypes.engineenums.particlesystemlodmethod.md
        │   ├── uassetapi.unrealtypes.engineenums.reverbpreset.md
        │   ├── uassetapi.unrealtypes.engineenums.skeletalmeshoptimizationimportance.md
        │   ├── uassetapi.unrealtypes.engineenums.skeletalmeshoptimizationtype.md
        │   ├── uassetapi.unrealtypes.engineenums.skeletalmeshterminationcriterion.md
        │   ├── uassetapi.unrealtypes.engineenums.textureaddress.md
        │   ├── uassetapi.unrealtypes.engineenums.texturecompressionsettings.md
        │   ├── uassetapi.unrealtypes.engineenums.texturefilter.md
        │   ├── uassetapi.unrealtypes.engineenums.texturegroup.md
        │   ├── uassetapi.unrealtypes.engineenums.texturemipgensettings.md
        │   ├── uassetapi.unrealtypes.engineversion.md
        │   ├── uassetapi.unrealtypes.eobjectdataresourceflags.md
        │   ├── uassetapi.unrealtypes.eobjectdataresourceversion.md
        │   ├── uassetapi.unrealtypes.eobjectflags.md
        │   ├── uassetapi.unrealtypes.epackageflags.md
        │   ├── uassetapi.unrealtypes.epropertyflags.md
        │   ├── uassetapi.unrealtypes.erangeboundtypes.md
        │   ├── uassetapi.unrealtypes.ffieldpath.md
        │   ├── uassetapi.unrealtypes.ffontcharacter.md
        │   ├── uassetapi.unrealtypes.ffontdata.md
        │   ├── uassetapi.unrealtypes.fframenumber.md
        │   ├── uassetapi.unrealtypes.fframerate.md
        │   ├── uassetapi.unrealtypes.fframetime.md
        │   ├── uassetapi.unrealtypes.fgatherabletextdata.md
        │   ├── uassetapi.unrealtypes.fintvector.md
        │   ├── uassetapi.unrealtypes.fintvector2.md
        │   ├── uassetapi.unrealtypes.flinearcolor.md
        │   ├── uassetapi.unrealtypes.flocmetadataobject.md
        │   ├── uassetapi.unrealtypes.fmatrix.md
        │   ├── uassetapi.unrealtypes.fname.md
        │   ├── uassetapi.unrealtypes.fniagaradatainterfacegeneratedfunction.md
        │   ├── uassetapi.unrealtypes.fniagaradatainterfacegpuparaminfo.md
        │   ├── uassetapi.unrealtypes.fniagaravariablecommonreference.md
        │   ├── uassetapi.unrealtypes.fobjectdataresource.md
        │   ├── uassetapi.unrealtypes.fobjectthumbnail.md
        │   ├── uassetapi.unrealtypes.fpackageindex.md
        │   ├── uassetapi.unrealtypes.fplane.md
        │   ├── uassetapi.unrealtypes.fpropertytypename.md
        │   ├── uassetapi.unrealtypes.fpropertytypenameconverter.md
        │   ├── uassetapi.unrealtypes.fpropertytypenamenode.md
        │   ├── uassetapi.unrealtypes.fqualifiedframetime.md
        │   ├── uassetapi.unrealtypes.fquat.md
        │   ├── uassetapi.unrealtypes.frichcurvekey.md
        │   ├── uassetapi.unrealtypes.frotator.md
        │   ├── uassetapi.unrealtypes.fskeletalmeshareaweightedtrianglesampler.md
        │   ├── uassetapi.unrealtypes.fskeletalmeshsamplingregionbuiltdata.md
        │   ├── uassetapi.unrealtypes.fstring.md
        │   ├── uassetapi.unrealtypes.ftextsourcedata.md
        │   ├── uassetapi.unrealtypes.ftextsourcesitecontext.md
        │   ├── uassetapi.unrealtypes.ftimecode.md
        │   ├── uassetapi.unrealtypes.ftransform.md
        │   ├── uassetapi.unrealtypes.ftwovectors.md
        │   ├── uassetapi.unrealtypes.funiquenetid.md
        │   ├── uassetapi.unrealtypes.fvector.md
        │   ├── uassetapi.unrealtypes.fvector2d.md
        │   ├── uassetapi.unrealtypes.fvector2f.md
        │   ├── uassetapi.unrealtypes.fvector3f.md
        │   ├── uassetapi.unrealtypes.fvector4.md
        │   ├── uassetapi.unrealtypes.fvector4f.md
        │   ├── uassetapi.unrealtypes.fweightedrandomsampler.md
        │   ├── uassetapi.unrealtypes.fworldtileinfo.md
        │   ├── uassetapi.unrealtypes.fworldtilelayer.md
        │   ├── uassetapi.unrealtypes.fworldtilelodinfo.md
        │   ├── uassetapi.unrealtypes.iordereddictionary-2.md
        │   ├── uassetapi.unrealtypes.linearhelpers.md
        │   ├── uassetapi.unrealtypes.objectversion.md
        │   ├── uassetapi.unrealtypes.objectversionue5.md
        │   ├── uassetapi.unrealtypes.tbox-1.md
        │   ├── uassetapi.unrealtypes.tmap-2.md
        │   ├── uassetapi.unrealtypes.tperqualitylevel-1.md
        │   ├── uassetapi.unrealtypes.trange-1.md
        │   ├── uassetapi.unrealtypes.trangebound-1.md
        │   ├── uassetapi.unrealtypes.ue4versiontoobjectversion.md
        │   ├── uassetapi.unrealtypes.ue5versiontoobjectversion.md
        │   ├── uassetapi.unrealtypes.uniquenetidreplpropertydata.md
        │   ├── uassetapi.unrealtypes.universalobjectlocatorfragmentpropertydata.md
        │   ├── uassetapi.unversioned.ecompressionmethod.md
        │   ├── uassetapi.unversioned.ecustomversionserializationformat.md
        │   ├── uassetapi.unversioned.epropertytype.md
        │   ├── uassetapi.unversioned.esavegamefileversion.md
        │   ├── uassetapi.unversioned.ffragment.md
        │   ├── uassetapi.unversioned.funversionedheader.md
        │   ├── uassetapi.unversioned.oodle.md
        │   ├── uassetapi.unversioned.savegame.md
        │   ├── uassetapi.unversioned.usmap.md
        │   ├── uassetapi.unversioned.usmaparraydata.md
        │   ├── uassetapi.unversioned.usmapenum.md
        │   ├── uassetapi.unversioned.usmapenumdata.md
        │   ├── uassetapi.unversioned.usmapextensionlayoutversion.md
        │   ├── uassetapi.unversioned.usmapmapdata.md
        │   ├── uassetapi.unversioned.usmapproperty.md
        │   ├── uassetapi.unversioned.usmappropertydata.md
        │   ├── uassetapi.unversioned.usmapschema.md
        │   ├── uassetapi.unversioned.usmapschemapropertiesjsonconverter.md
        │   ├── uassetapi.unversioned.usmapstructdata.md
        │   ├── uassetapi.unversioned.usmapstructkind.md
        │   ├── uassetapi.unversioned.usmapversion.md
        │   └── uassetapi.usmapbinaryreader.md
        ├── guide
        │   ├── basic.md
        │   ├── build.md
        │   ├── extras.md
        │   └── img
        │       ├── basic1.png
        │       ├── basic2.png
        │       ├── basic2_1.png
        │       ├── basic3.png
        │       ├── basic4.png
        │       └── basic5.png
        └── samples
            ├── plwp_6aam_a0.uasset
            └── plwp_6aam_a0.uexp

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 - 2026 atenfyr

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`NOTICE.md`:

```md
# Notices
The following is a list of applicable licensing information for all the third-party material used, in whole or in part, within this software.

## repak
https://github.com/trumank/repak
```
MIT License

Copyright 2024 Truman Kilen, spuds

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## Json.NET
https://github.com/JamesNK/Newtonsoft.Json
```
The MIT License (MIT)

Copyright (c) 2007 James Newton-King

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

## dotmore
https://github.com/mattmc3/dotmore
```
The MIT License (MIT)

Copyright (c) 2014 mattmc3

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## ZstdNet
https://github.com/skbkontur/ZstdNet
```
BSD License

For ZstdNet software

Copyright (c) 2016-present, SKB Kontur. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name SKB Kontur nor the names of its contributors may be used to
   endorse or promote products derived from this software without specific
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## zstd
https://github.com/facebook/zstd
```
BSD License

For Zstandard software

Copyright (c) Meta Platforms, Inc. and affiliates. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name Facebook, nor Meta, nor the names of its contributors may
   be used to endorse or promote products derived from this software without
   specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

## UEAssetToolkitGenerator
https://github.com/LongerWarrior/UEAssetToolkitGenerator

### License
```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```
### Statement of Modification
Major portions of the source code that is adapted from UEAssetToolkitGenerator have been modified for usage in UAssetAPI through changes in code formatting, nomenclature, and serialization specifics in order to improve the effectiveness of the serialization across different engine versions and assets and to improve integration with newer versions of UAssetAPI. The relevant portions of source code have been sufficiently adapted such that no improper serialization or other unexpected behavior should be construed as having originated from any portion of the original work or any of its contributors.

### Original NOTICE text file information
The NOTICE text file bundled with the referenced project is not included in this copyright notice because none of the notices in that file pertain to any part of the work that is adapted for usage in UAssetAPI. Please see the original repository for more detailed copyright information.

```

`README.md`:

```md
# UAssetAPI
[![CI Status](https://img.shields.io/github/actions/workflow/status/atenfyr/UAssetAPI/build.yml?label=CI)](https://github.com/atenfyr/UAssetAPI/actions)
[![Issues](https://img.shields.io/github/issues/atenfyr/UAssetAPI.svg?style=flat-square)](https://github.com/atenfyr/UAssetAPI/issues)
[![License](https://img.shields.io/github/license/atenfyr/UAssetAPI.svg?style=flat-square)](https://github.com/atenfyr/UAssetAPI/blob/master/LICENSE.md)

UAssetAPI is a low-level .NET library for reading and writing Unreal Engine game assets.

<img src="https://i.imgur.com/GZbr93m.png" align="center">

## Features
- Low-level read/write capability for a wide variety of cooked and uncooked .uasset files from ~4.13 to 5.3
- Support for more than 100 property types and 12 export types
- Support for JSON export and import to a proprietary format that maintains binary equality
- Support for reading and writing raw Kismet (blueprint) bytecode
- Reading capability for the unofficial .usmap format to parse ambiguous and unversioned properties
- Robust fail-safes for many properties and exports that fail serialization
- Automatic reflection for new property types in other loaded assemblies

## Usage
To get started using UAssetAPI, first build the API using the [Build Instructions guide](https://atenfyr.github.io/UAssetAPI/guide/build.html) and learn how to perform basic operations on your cooked .uasset files using the [Basic Usage guide](https://atenfyr.github.io/UAssetAPI/guide/basic.html).

UAssetGUI, a graphical wrapper around UAssetAPI which allows you to directly view and modify game assets by hand, is also available and can be downloaded for free on GitHub at [https://github.com/atenfyr/UAssetGUI/releases](https://github.com/atenfyr/UAssetGUI/releases).

## Contributing
All contributions, whether through pull requests or issues, that you may make are greatly appreciated.

I am particularly interested in .uasset files that have their `VerifyBinaryEquality()` method return false (or display "failed to maintain binary equality" within [UAssetGUI](https://github.com/atenfyr/UAssetGUI)); if you encounter such an asset, feel free to submit an issue here with a copy of the asset in question along with the name of the game and the Unreal version that it was cooked with.

Please note: Your issue will NOT be reviewed if your issue cannot be replicated due to no test asset being provided.

## License
UAssetAPI and UAssetGUI are distributed under the MIT license, which you can view in detail in the [LICENSE file](LICENSE).

```

`UAssetAPI.Benchmark/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
</configuration>
```

`UAssetAPI.Benchmark/Program.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using UAssetAPI.CustomVersions;
using UAssetAPI.ExportTypes;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.Benchmark
{
    public class Program
    {
        private static double BenchmarkAsset(string path, EngineVersion ver, Usmap mappings = null)
        {
            var timer = new Stopwatch();
            timer.Start();
            var loaded = new UAsset(path, ver, mappings);
            timer.Stop();

            bool passBinaryEq = false;
            try
            {
                passBinaryEq = loaded.VerifyBinaryEquality();
            }
            catch { passBinaryEq = false; }

            if (!passBinaryEq)
            {
                try
                {
                    loaded.Write("test.uasset");
                }
                catch { }
            }

            int numPassedExportsTotal = 0;
            int numExportsTotal = 0;
            try
            {
                foreach (Export testExport in loaded.Exports)
                {
                    if (testExport is not RawExport)
                    {
                        numPassedExportsTotal += 1;
                    }
                    numExportsTotal += 1;
                }
            }
            catch { }

            Console.WriteLine(Path.GetFileName(path) + " parsed in " + timer.Elapsed.TotalMilliseconds + " ms");
            Console.WriteLine("Binary equality: " + (passBinaryEq ? "PASS" : "FAIL"));
            Console.WriteLine(numPassedExportsTotal + "/" + numExportsTotal + " exports (" + NumberToTwoDecimalPlaces(100 * numPassedExportsTotal / (double)numExportsTotal) + "%) passed");
            return timer.Elapsed.TotalMilliseconds;
        }

        private static string NumberToTwoDecimalPlaces(double num)
        {
            // avoid any other formatting (e.g. commas), just round decimal places
            int secondPart = (int)(num * 100 % 100);
            return (int)num + "." + (secondPart < 10 ? "0" : "") + secondPart;
        }

        private static HashSet<string> allowedExtensions = new HashSet<string>()
        {
            ".umap",
            ".uasset"
        };

        public static void Run(string[] args)
        {
            Dictionary<string, string> allTestAssetVersions = JsonConvert.DeserializeObject<Dictionary<string, string>>(File.ReadAllText(Path.Combine("TestAssets", "_asset_versions.json")));

            // initialize a uasset a few times for good measure
            for (int i = 0; i < 3; i++)
            {
                new UAsset(Path.Combine("TestAssets", "Staging_T2.umap"), EngineVersion.VER_UE4_23);
            }

            var timer = new Stopwatch();

            switch (args[0])
            {
                case "testset":
                    string[] allTestingAssets = Directory.GetFiles("TestAssets");
                    int num1 = 0;
                    double totalTime = 0;
                    foreach (string assetPath in allTestingAssets)
                    {
                        if (!allowedExtensions.Contains(Path.GetExtension(assetPath))) continue;
                        if (!allTestAssetVersions.ContainsKey(Path.GetFileNameWithoutExtension(assetPath))) continue;
                        totalTime += BenchmarkAsset(assetPath, (EngineVersion)Enum.Parse(typeof(EngineVersion), allTestAssetVersions[Path.GetFileNameWithoutExtension(assetPath)]));
                        num1 += 1;
                    }
                    Console.WriteLine("\n" + num1 + " assets parsed in " + NumberToTwoDecimalPlaces(totalTime) + " ms");
                    break;
                case "testall":
                    string[] allRelevantArgs = args.Skip(1).Take(args.Length - 2).ToArray();
                    string[] allTestingAssets2 = Directory.GetFiles(string.Join(" ", allRelevantArgs), "*.*", SearchOption.AllDirectories);
                    EngineVersion ver = (EngineVersion)Enum.Parse(typeof(EngineVersion), args[args.Length - 1]);

                    // load mappings
                    Usmap mappings = null;
                    timer.Restart();
                    foreach (string assetPath in allTestingAssets2)
                    {
                        if (Path.GetExtension(assetPath) == ".usmap")
                        {
                            timer.Start();
                            mappings = new Usmap();
                            mappings.SkipBlueprintSchemas = true;
                            mappings.Read(mappings.PathToReader(assetPath));
                            timer.Stop();
                            Console.WriteLine("Mappings parsed in " + NumberToTwoDecimalPlaces(timer.Elapsed.TotalMilliseconds) + " ms");
                            break;
                        }
                    }

                    // get num assets in total for status update
                    int numTotal = 0;
                    foreach (string assetPath in allTestingAssets2)
                    {
                        if (!allowedExtensions.Contains(Path.GetExtension(assetPath))) continue;
                        numTotal += 1;
                    }

                    int num = 0;
                    int numPassedBinaryEq = 0;
                    int numPassedAllExports = 0;
                    int numExportsTotal = 0;
                    int numPassedExportsTotal = 0;
                    timer.Restart();

                    int thresholdToForceStatusUpdate = numTotal / 4;
                    int numAtLastStatusUpdate = 0;
                    double lastMsGaveStatusUpdate = double.MinValue;
                    ISet<string> problemAssets = new HashSet<string>();
                    ISet<string> notEqualAssets = new HashSet<string>();
                    ISet<string> notParsed = new HashSet<string>();
                    Dictionary<string, Dictionary<int, string>> rawExports = new();
                    foreach (string assetPath in allTestingAssets2)
                    {
                        if (!allowedExtensions.Contains(Path.GetExtension(assetPath))) continue;

                        // give status update every once in a while
                        if (timer.Elapsed.TotalMilliseconds - lastMsGaveStatusUpdate >= 3000 || (timer.Elapsed.TotalMilliseconds - lastMsGaveStatusUpdate >= 500 && (num - numAtLastStatusUpdate) > thresholdToForceStatusUpdate))
                        {
                            lastMsGaveStatusUpdate = timer.Elapsed.TotalMilliseconds;
                            numAtLastStatusUpdate = num;
                            Console.WriteLine("[" + NumberToTwoDecimalPlaces(timer.Elapsed.TotalMilliseconds / 1000) + " s] " + num + "/" + numTotal + " assets parsed" + new string(' ', 15));
                            Console.Write("[" + NumberToTwoDecimalPlaces(timer.Elapsed.TotalMilliseconds / 1000) + " s] " + numPassedExportsTotal + "/" + numExportsTotal + " exports (" + NumberToTwoDecimalPlaces(numExportsTotal < 1 ? 0 : (numPassedExportsTotal / (double)numExportsTotal * 100)) + "%) passing" + new string(' ', 15));
                            Console.CursorTop -= 1;
                            Console.CursorLeft = 0;
                        }

                        timer.Start();
                        UAsset loaded = null;
                        try
                        {
                            loaded = new UAsset(assetPath, ver, mappings);
                        }
                        catch
                        {
                            timer.Stop();
                            numExportsTotal += loaded?.Exports?.Count ?? 0;
                            num += 1;
                            loaded = null;
                            notParsed.Add(assetPath);
                            continue;
                        }
                        timer.Stop();

                        bool isProblemAsset = false;
                        bool isNotEqual = false;
                        try
                        {
                            if (loaded.VerifyBinaryEquality())
                            {
                                numPassedBinaryEq += 1;
                            }
                            else
                            {
                                isProblemAsset = true;
                                isNotEqual = true;
                            }
                        }
                        catch
                        {
                            isProblemAsset = true;
                            isNotEqual = true;
                        }

                        bool passedAllExports = true;
                        try
                        {
                            for (int i = 0; i < loaded.Exports.Count; i++)
                            {
                                Export testExport = loaded.Exports[i];
                                if (testExport is RawExport)
                                {
                                    passedAllExports = false;
                                    if (!rawExports.ContainsKey(assetPath)) rawExports[assetPath] = [];
                                    var clas = testExport.ClassIndex.IsImport() ? testExport.ClassIndex.ToImport(loaded).ObjectName.ToString() : testExport.ClassIndex.ToExport(loaded).ObjectName.ToString();
                                    rawExports[assetPath].Add(i, clas);
                                    Console.WriteLine("Raw export found for " + assetPath + " at index " + i + " with class " + clas);
                                }
                                else
                                {
                                    numPassedExportsTotal += 1;
                                }
                                numExportsTotal += 1;
                            }
                        }
                        catch
                        {
                            passedAllExports = false;
                        }

                        if (passedAllExports)
                        {
                            numPassedAllExports += 1;
                        }
                        else
                        {
                            isProblemAsset = true;
                        }

                        if (isProblemAsset) problemAssets.Add(assetPath);
                        if (isNotEqual) notEqualAssets.Add(assetPath);
                        num += 1;
                        loaded = null;
                    }

                    Console.WriteLine();
                    Console.WriteLine(num + " assets parsed in " + NumberToTwoDecimalPlaces(timer.Elapsed.TotalMilliseconds) + " ms combined (" + NumberToTwoDecimalPlaces(timer.Elapsed.TotalMilliseconds / num) + " ms/asset, on average)");
                    Console.WriteLine(numExportsTotal + " exports were parsed (" + NumberToTwoDecimalPlaces(timer.Elapsed.TotalMilliseconds / numExportsTotal * 100) + " ms per 100 exports, on average)");
                    Console.WriteLine(numPassedExportsTotal + "/" + numExportsTotal + " exports (" + NumberToTwoDecimalPlaces(numPassedExportsTotal / (double)numExportsTotal * 100) + "%) passed");
                    Console.WriteLine(numPassedBinaryEq + "/" + num + " assets (" + NumberToTwoDecimalPlaces(numPassedBinaryEq / (double)num * 100) + "%) passed binary equality");
                    Console.WriteLine(numPassedAllExports + "/" + num + " assets (" + NumberToTwoDecimalPlaces(numPassedAllExports / (double)num * 100) + "%) passed on all exports");

                    if (notEqualAssets.Count > 0)
                    {
                        Console.WriteLine("\nList of non equal assets:");
                        File.WriteAllText("noneuqal_assets.txt", string.Join('\n', notEqualAssets));
                        Console.WriteLine("Written to noneuqal_assets.txt");
                    }

                    if (notParsed.Count > 0)
                    {
                        Console.WriteLine("\nList of not parsed assets:");
                        File.WriteAllText("nonparsed_assets.txt", string.Join('\n', notParsed));
                        Console.WriteLine("Written to nonparsed_assets.txt");
                    }

                    if (problemAssets.Count > 0)
                    {
                        int i = 0;
                        Console.WriteLine("\nList of problematic assets:");
                        foreach (string problemAsset in problemAssets)
                        {
                            Console.WriteLine(problemAsset);
                            i++;
                            if (i >= 50) break;
                        }
                        if (problemAssets.Count > 50) Console.WriteLine("...");

                        File.WriteAllText("problematic_assets.txt", string.Join('\n', problemAssets));
                        Console.WriteLine("Written to problematic_assets.txt");
                    }

                    if (rawExports.Count > 0)
                    {
                        Console.WriteLine("\nList of raw export assets:");
                        File.WriteAllText("raw_export.txt", JsonConvert.SerializeObject(rawExports, Formatting.Indented));
                        Console.WriteLine("Written to raw_export.txt");
                    }
                    break;
                case "testcpu":
                    int numCpuTrials = 5;
                    double trialSum = 0;
                    for (int i = 0; i < numCpuTrials; i++)
                    {
                        // load each time to avoid any weird stream optimizations
                        MemoryStream oneBigAsset = new UAsset().PathToStream(Path.Combine("TestAssets", "PlayerBase01.umap"));
                        var binReader = new AssetBinaryReader(oneBigAsset, null);

                        timer.Restart();
                        timer.Start();
                        new UAsset(binReader, EngineVersion.VER_UE4_22);
                        timer.Stop();

                        oneBigAsset.Dispose();
                        trialSum += timer.Elapsed.TotalMilliseconds;
                        Console.WriteLine("CPU trial " + (i + 1) + " completed in " + timer.Elapsed.TotalMilliseconds + " ms");
                    }
                    Console.WriteLine("\n" + numCpuTrials + " CPU trials completed in " + trialSum + " ms (" + (trialSum / numCpuTrials) + " ms/trial)");
                    break;
                case "test":
                    // replace "!" for " " as stupid hack lol...
                    Usmap singleMappings = null;
                    if (args.Length >= 4) singleMappings = new Usmap(args[3].Replace("!", " "));
                    BenchmarkAsset(args[1].Replace("!", " "), (EngineVersion)Enum.Parse(typeof(EngineVersion), args[2].Replace("!", " ")), singleMappings);
                    break;
                case "guesscustomversion":
                    timer.Restart();
                    timer.Start();
                    UAsset.GuessCustomVersionFromTypeAndEngineVersion(EngineVersion.VER_UE4_AUTOMATIC_VERSION, typeof(FReleaseObjectVersion));
                    timer.Stop();
                    Console.WriteLine("Custom version first retrieved in " + timer.Elapsed.TotalMilliseconds + " ms");

                    int numCustomVersionTrials = 20000;
                    EngineVersion testingEngineVersion = EngineVersion.VER_UE4_16;
                    timer.Restart();
                    timer.Start();
                    for (int i = 0; i < numCustomVersionTrials; i++)
                    {
                        UAsset.GuessCustomVersionFromTypeAndEngineVersion(testingEngineVersion, typeof(FReleaseObjectVersion));

                        testingEngineVersion += 1;
                        if (testingEngineVersion > EngineVersion.VER_UE4_27) testingEngineVersion = EngineVersion.VER_UE4_16;
                    }
                    timer.Stop();
                    Console.WriteLine("Custom version then retrieved " + numCustomVersionTrials + " times in " + timer.Elapsed.TotalMilliseconds + " ms (" + (timer.Elapsed.TotalMilliseconds / numCustomVersionTrials) + " ms/trial)");
                    break;
                case "longestnames":
                    timer.Restart();
                    timer.Start();
                    Assembly relevantAssembly = typeof(UAsset).Assembly;
                    List<string> lineas = new List<string>();
                    foreach (Type type in relevantAssembly.GetTypes())
                    {
                        if (type.IsEnum) continue;
                        lineas.Add(type.Name);
                        foreach (MemberInfo memb in type.GetMembers()) lineas.Add(memb.Name);
                    }

                    Console.WriteLine(string.Join('\n', lineas.OrderByDescending(x => x.Length).Distinct().Take(20)));
                    Console.WriteLine("Operation completed in " + timer.Elapsed.TotalMilliseconds + " ms");
                    timer.Stop();
                    break;
                case "dumpmappings":
                    {
                        string usmapPath = args[1];
                        Usmap usmapToDump = new Usmap(usmapPath);
                        if (args.Length >= 3)
                        {
                            string filterStr = args[2];
                            foreach (KeyValuePair<string, UsmapEnum> entry in usmapToDump.EnumMap)
                            {
                                if (!entry.Value.ModulePath.Contains(filterStr)) usmapToDump.EnumMap.Remove(entry.Key);
                            }
                            foreach (KeyValuePair<string, UsmapSchema> entry in usmapToDump.Schemas)
                            {
                                if (!entry.Value.ModulePath.Contains(filterStr)) usmapToDump.Schemas.Remove(entry.Key);
                            }
                        }
                        File.WriteAllText(Path.ChangeExtension(usmapPath, ".json"), usmapToDump.SerializeJSON(Formatting.Indented));
                    }
                    break;
            }
        }

        public static void Main(string[] args)
        {
#if DEBUG || DEBUG_VERBOSE
            //Run(new string[] { "abcd" });

            while (true)
            {
                Console.Write("Input: ");
                string inp = Console.ReadLine();
                if (string.IsNullOrWhiteSpace(inp)) return;
                Run(inp.Split(' '));
                Console.WriteLine();
            }
#else
            Run(args);
#endif
        }
    }
}

```

`UAssetAPI.Benchmark/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a74e7e85-1797-477c-aec1-583ae7d109d0")]

```

`UAssetAPI.Benchmark/TestAssets/_asset_versions.json`:

```json
{
  "HUB_Restaurant": "VER_UE4_22",
  "PlayerBase01": "VER_UE4_22",
  "Staging_T2": "VER_UE4_23"
}
```

`UAssetAPI.Benchmark/UAssetAPI.Benchmark.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <ProjectGuid>{A74E7E85-1797-477C-AEC1-583AE7D109D0}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <AssemblyTitle>UAssetAPI.Benchmark</AssemblyTitle>
    <Product>UAssetAPI.Benchmark</Product>
    <Copyright>Copyright © Atenfyr 2024</Copyright>
    <OutputPath>bin\$(Configuration)\</OutputPath>
    <Configurations>Debug;Release;DebugVerbose;DebugTracing</Configurations>
    <Platforms>AnyCPU;x86</Platforms>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|AnyCPU'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugTracing|AnyCPU'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugTracing|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'">
    <DebugType>pdbonly</DebugType>
  </PropertyGroup>
  <ItemGroup>
    <None Include="TestAssets\Staging_T2.uexp">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Include="TestAssets\Staging_T2.umap">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Include="TestAssets\_asset_versions.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Include="TestAssets\HUB_Restaurant.uexp">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Include="TestAssets\HUB_Restaurant.umap">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Include="TestAssets\PlayerBase01.uexp">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Include="TestAssets\PlayerBase01.umap">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\UAssetAPI\UAssetAPI.csproj" />
  </ItemGroup>
  <ItemGroup>
    <Compile Remove="obj\Debug Verbose\.NETFramework,Version=v4.7.2.AssemblyAttributes.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Update="TestAssets\Begin_Player.uasset">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Update="TestAssets\B_Gamemode.uasset">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>
</Project>
```

`UAssetAPI.Tests/AssetUnitTests.cs`:

```cs
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UAssetAPI.ExportTypes;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.Tests
{
    [TestClass]
    public class AssetUnitTests
    {
        /// <summary>
        /// Checks if two files have the same binary data.
        /// </summary>
        public void VerifyBinaryEquality(string file1, string file2)
        {
            int file1byte;
            int file2byte;
            FileStream fs1;
            FileStream fs2;

            if (file1 == file2) return;

            fs1 = new FileStream(file1, FileMode.Open);
            fs2 = new FileStream(file2, FileMode.Open);

            if (fs1.Length != fs2.Length)
            {
                fs1.Close();
                fs2.Close();
                Assert.IsTrue(false);
            }

            do
            {
                file1byte = fs1.ReadByte();
                file2byte = fs2.ReadByte();
            }
            while ((file1byte == file2byte) && (file1byte != -1));

            fs1.Close();
            fs2.Close();

            Assert.IsTrue((file1byte - file2byte) == 0);
        }

        /// <summary>
        /// Asserts that all exports in an asset have parsed correctly.
        /// </summary>
        /// <param name="tester">The asset to test.</param>
        public void AssertAllExportsParsedCorrectly(UAsset tester)
        {
            foreach (Export testExport in tester.Exports)
            {
                Assert.IsFalse(testExport is RawExport, $"Export '{testExport.ObjectName}' in '{tester.FilePath}' was not parsed correctly (RawExport)");
                if (testExport is FunctionExport funcExport)
                {
                    Assert.IsNotNull(funcExport.ScriptBytecode, $"FunctionExport '{testExport.ObjectName}' in '{tester.FilePath}' has null ScriptBytecode (failed to parse Kismet bytecode)");
                }
            }
        }

        /// <summary>
        /// Retrieves all the test assets in a particular folder.
        /// </summary>
        /// <param name="folder">The folder to check for test assets.</param>
        /// <returns>An array of paths to assets that should be tested.</returns>
        public string[] GetAllTestAssets(string folder)
        {
            List<string> allFilesToTest = Directory.GetFiles(folder, "*.uasset", SearchOption.AllDirectories).ToList();
            allFilesToTest.AddRange(Directory.GetFiles(folder, "*.umap", SearchOption.AllDirectories));
            return allFilesToTest.ToArray();
        }

        /// <summary>
        /// Tests <see cref="FSoftObjectPath"/> equality functionality including IEquatable implementation.
        /// </summary>
        [TestMethod]
        public void TestFSoftObjectPathEquality()
        {
            // Create a dummy asset for FName construction
            var dummyAsset = new UAsset(Path.Combine("TestAssets", "TestManyAssets", "Astroneer", "Augment_BroadBrush.uasset"), EngineVersion.VER_UE4_23);
            
            // Create test instances
            var packageName1 = new FName(dummyAsset, "TestPackage");
            var assetName1 = new FName(dummyAsset, "TestAsset");
            var subPath1 = new FString("SubPath1");
            
            var packageName2 = new FName(dummyAsset, "TestPackage");
            var assetName2 = new FName(dummyAsset, "TestAsset");
            var subPath2 = new FString("SubPath1");
            
            var packageName3 = new FName(dummyAsset, "DifferentPackage");
            var assetName3 = new FName(dummyAsset, "DifferentAsset");
            var subPath3 = new FString("SubPath2");

            var path1 = new FSoftObjectPath(packageName1, assetName1, subPath1);
            var path2 = new FSoftObjectPath(packageName2, assetName2, subPath2); // Same values
            var path3 = new FSoftObjectPath(packageName3, assetName3, subPath3); // Different values
            var path4 = new FSoftObjectPath(packageName1, assetName1, null); // Null subpath

            // Test IEquatable<FSoftObjectPath>.Equals
            Assert.IsTrue(path1.Equals(path2), "Equal paths should return true with typed Equals");
            Assert.IsTrue(path2.Equals(path1), "Equal paths should return true with typed Equals (symmetry)");
            Assert.IsFalse(path1.Equals(path3), "Different paths should return false with typed Equals");
            Assert.IsFalse(path1.Equals(path4), "Paths with different subpaths should return false with typed Equals");

            // Test object.Equals
            Assert.IsTrue(path1.Equals((object)path2), "Equal paths should return true with object Equals");
            Assert.IsFalse(path1.Equals((object)path3), "Different paths should return false with object Equals");
            Assert.IsFalse(path1.Equals(null), "Path should not equal null");
            Assert.IsFalse(path1.Equals("string"), "Path should not equal different type");

            // Test == operator
            Assert.IsTrue(path1 == path2, "Equal paths should return true with == operator");
            Assert.IsFalse(path1 == path3, "Different paths should return false with == operator");

            // Test != operator
            Assert.IsFalse(path1 != path2, "Equal paths should return false with != operator");
            Assert.IsTrue(path1 != path3, "Different paths should return true with != operator");

            // Test GetHashCode consistency
            Assert.IsTrue(path1.GetHashCode() == path2.GetHashCode(), "Equal paths should have equal hash codes");
            
            // Test with null values
            var pathWithNullPackage = new FSoftObjectPath(new FTopLevelAssetPath(null, assetName1), subPath1);
            var pathWithNullAsset = new FSoftObjectPath(new FTopLevelAssetPath(packageName1, null), subPath1);
            var pathWithNullSubPath = new FSoftObjectPath(packageName1, assetName1, null);
            
            Assert.IsFalse(path1.Equals(pathWithNullPackage), "Paths with null package should not equal non-null");
            Assert.IsFalse(path1.Equals(pathWithNullAsset), "Paths with null asset should not equal non-null");
            Assert.IsFalse(path1.Equals(pathWithNullSubPath), "Paths with null subpath should not equal non-null");
            
            // Test null equality
            var pathAllNull = new FSoftObjectPath(new FTopLevelAssetPath(null, null), null);
            var pathAllNull2 = new FSoftObjectPath(new FTopLevelAssetPath(null, null), null);
            Assert.IsTrue(pathAllNull.Equals(pathAllNull2), "Paths with all null values should be equal");
            
            // Test partial equality scenarios
            var pathSamePackageAsset = new FSoftObjectPath(new FTopLevelAssetPath(packageName1, assetName1), subPath3);
            Assert.IsFalse(path1.Equals(pathSamePackageAsset), "Paths with same package/asset but different subpath should not be equal");
            
            var pathSamePackageSubPath = new FSoftObjectPath(new FTopLevelAssetPath(packageName1, assetName3), subPath1);
            Assert.IsFalse(path1.Equals(pathSamePackageSubPath), "Paths with same package/subpath but different asset should not be equal");
            
            var pathSameAssetSubPath = new FSoftObjectPath(new FTopLevelAssetPath(packageName3, assetName1), subPath1);
            Assert.IsFalse(path1.Equals(pathSameAssetSubPath), "Paths with same asset/subpath but different package should not be equal");
        }

        /// <summary>
        /// Tests <see cref="FName.ToString"/> and <see cref="FName.FromString"/>.
        /// </summary>
        [TestMethod]
        public void TestNameConstruction()
        {
            var dummyAsset = new UAsset(Path.Combine("TestAssets", "TestManyAssets", "Astroneer", "Augment_BroadBrush.uasset"), EngineVersion.VER_UE4_23);

            FName test = FName.FromString(dummyAsset, "HelloWorld_0");
            Assert.IsTrue(test.Value.Value == "HelloWorld" && test.Number == 1);
            Assert.IsTrue(test.ToString() == "HelloWorld_0");

            test = FName.FromString(dummyAsset, "5_72");
            Assert.IsTrue(test.Value.Value == "5" && test.Number == 73);
            Assert.IsTrue(test.ToString() == "5_72");

            test = FName.FromString(dummyAsset, "_3");
            Assert.IsTrue(test.Value.Value == "_3" && test.Number == 0);
            Assert.IsTrue(test.ToString() == "_3");

            test = FName.FromString(dummyAsset, "hi_");
            Assert.IsTrue(test.Value.Value == "hi_" && test.Number == 0);
            Assert.IsTrue(test.ToString() == "hi_");

            test = FName.FromString(dummyAsset, "hi_01");
            Assert.IsTrue(test.Value.Value == "hi_01" && test.Number == 0);
            Assert.IsTrue(test.ToString() == "hi_01");

            test = FName.FromString(dummyAsset, "hi_10");
            Assert.IsTrue(test.Value.Value == "hi" && test.Number == 11);
            Assert.IsTrue(test.ToString() == "hi_10");

            test = FName.FromString(dummyAsset, "blah");
            Assert.IsTrue(test.Value.Value == "blah" && test.Number == 0);
            Assert.IsTrue(test.ToString() == "blah");

            test = new FName(dummyAsset, "HelloWorld", 2);
            Assert.IsTrue(test.ToString() == "HelloWorld_1");

            test = new FName(dummyAsset, "HelloWorld", 0);
            Assert.IsTrue(test.ToString() == "HelloWorld");
        }

        /// <summary>
        /// Tests modifying values within the class default object of an asset.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestCDOModification()
        {
            var tester = new UAsset(Path.Combine("TestAssets", "TestManyAssets", "Astroneer", "Augment_BroadBrush.uasset"), EngineVersion.VER_UE4_23);
            Assert.IsTrue(tester.VerifyBinaryEquality());

            NormalExport cdoExport = null;
            foreach (Export testExport in tester.Exports)
            {
                if (testExport.ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject))
                {
                    cdoExport = (NormalExport)testExport;
                    break;
                }
            }
            Assert.IsNotNull(cdoExport);

            cdoExport["PickupActor"] = new ObjectPropertyData() { Value = FPackageIndex.FromRawIndex(0) };

            Assert.IsTrue(cdoExport["PickupActor"] is ObjectPropertyData);
            Assert.IsTrue(((ObjectPropertyData)cdoExport["PickupActor"]).Value.Index == 0);
        }

        /// <summary>
        /// MapProperties contain no easy way to determine the type of structs within them.
        /// For C++ classes, it is impossible without access to the headers, but for blueprint classes, the correct serialization is contained within the UClass.
        /// In this test, we take an asset with custom struct serialization in a map and extract data from the ClassExport in order to determine the correct serialization for the structs.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestCustomSerializationStructsInMap()
        {
            var tester = new UAsset(Path.Combine("TestAssets", "TestCustomSerializationStructsInMap", "wtf.uasset"), EngineVersion.VER_UE4_25);
            Assert.IsTrue(tester.VerifyBinaryEquality());

            // Get the map property in export 2
            Export exportTwo = FPackageIndex.FromRawIndex(2).ToExport(tester);
            Assert.IsTrue(exportTwo is NormalExport);

            NormalExport exportTwoNormal = (NormalExport)exportTwo;

            var mapPropertyName = FName.FromString(tester, "KekWait");
            MapPropertyData testMap = exportTwoNormal[mapPropertyName] as MapPropertyData;
            Assert.IsNotNull(testMap);
            Assert.IsTrue(testMap == exportTwoNormal[mapPropertyName.Value.Value]);

            // Get the first entry of the map
            StructPropertyData entryKey = testMap?.Value?.Keys?.ElementAt(0) as StructPropertyData;
            StructPropertyData entryValue = testMap?.Value?[0] as StructPropertyData;
            Assert.IsNotNull(entryKey?.Value?[0]);
            Assert.IsNotNull(entryValue?.Value?[0]);

            // Check that the properties are correct
            Assert.IsTrue(entryKey.Value[0] is VectorPropertyData);
            Assert.IsTrue(entryValue.Value[0] is LinearColorPropertyData);
        }

        /// <summary>
        /// In this test, we examine a cooked asset that has been modified by an external tool.
        /// As a result of external modification, the asset now has new name map entries whose hashes were left empty.
        /// Binary equality is expected. Expected behavior is for UAssetAPI to detect this and override its normal hash algorithm.
        /// </summary>
        [TestMethod]
        public void TestImproperNameMapHashes()
        {
            var tester = new UAsset(Path.Combine("TestAssets", "TestImproperNameMapHashes", "OC_Gatling_DamageB_B.uasset"), EngineVersion.VER_UE4_25);
            Assert.IsTrue(tester.VerifyBinaryEquality());

            Dictionary<string, bool> testingEntries = new Dictionary<string, bool>();
            testingEntries["/Game/WeaponsNTools/GatlingGun/Overclocks/OC_BonusesAndPenalties/OC_Bonus_MovmentBonus_150p"] = false;
            testingEntries["/Game/WeaponsNTools/GatlingGun/Overclocks/OC_BonusesAndPenalties/OC_Bonus_MovmentBonus_150p.OC_Bonus_MovmentBonus_150p"] = false;

            foreach (KeyValuePair<FString, uint> overrideHashes in tester.OverrideNameMapHashes)
            {
                if (testingEntries.ContainsKey(overrideHashes.Key.Value))
                {
                    Assert.IsTrue(overrideHashes.Value == 0);
                    testingEntries[overrideHashes.Key.Value] = true;
                }
            }

            foreach (KeyValuePair<string, bool> testingEntry in testingEntries)
            {
                Assert.IsTrue(testingEntry.Value);
            }
        }

        /// <summary>
        /// In this test, we examine a cooked asset that has been modified by an external tool.
        /// As a result of external modification, two identical entries now exist in the name map, which never occurs in assets cooked by the Unreal Engine.
        /// Binary equality is not expected, but the asset must successfully parse anyways.
        /// </summary>
        [TestMethod]
        public void TestDuplicateNameMapEntries()
        {
            var tester = new UAsset(Path.Combine("TestAssets", "TestDuplicateNameMapEntries", "BIOME_AzureWeald.uasset"), EngineVersion.VER_UE4_25);

            // Make sure a duplicate entry actually exists
            bool duplicatesExist = false;
            Dictionary<string, bool> enumeratedEntries = new Dictionary<string, bool>();
            foreach (FString entry in tester.GetNameMapIndexList())
            {
                if (enumeratedEntries.ContainsKey(entry.Value) && enumeratedEntries[entry.Value])
                {
                    duplicatesExist = true;
                    break;
                }
                enumeratedEntries[entry.Value] = true;
            }
            Assert.IsTrue(duplicatesExist);

            // Make sure all exports parsed correctly
            AssertAllExportsParsedCorrectly(tester);
        }

        /// <summary>
        /// In this test, we have an asset with a few properties that UAssetAPI has no serialization for. (The properties do not actually exist in the engine itself, so this is expected behavior.)
        /// UAssetAPI must fallback to UnknownPropertyType to parse the asset correctly and maintain binary equality.
        /// </summary>
        [TestMethod]
        public void TestUnknownProperties()
        {
            var tester = new UAsset(Path.Combine("TestAssets", "TestUnknownProperties", "BP_DetPack_Charge.uasset"), EngineVersion.VER_UE4_25);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);

            // Check that only the expected unknown properties are present
            Dictionary<string, bool> newUnknownProperties = new Dictionary<string, bool>();
            newUnknownProperties.Add("GarbagePropty", false);
            newUnknownProperties.Add("EvenMoreGarbageTestingPropertyy", false);

            foreach (Export testExport in tester.Exports)
            {
                if (testExport is NormalExport normalTestExport)
                {
                    foreach (PropertyData prop in normalTestExport.Data)
                    {
                        if (prop is UnknownPropertyData unknownProp)
                        {
                            string serializingType = unknownProp?.SerializingPropertyType?.Value;
                            Assert.AreNotEqual(serializingType, null);
                            Assert.IsTrue(newUnknownProperties.ContainsKey(serializingType));
                            newUnknownProperties[serializingType] = true;
                        }
                    }
                }
            }

            foreach (KeyValuePair<string, bool> entry in newUnknownProperties)
            {
                Assert.IsTrue(entry.Value);
            }
        }

        private void TestManyAssetsSubsection(string game, EngineVersion version, Usmap mappings = null)
        {
            string[] allTestingAssets = GetAllTestAssets(Path.Combine("TestAssets", "TestManyAssets", game));
            foreach (string assetPath in allTestingAssets)
            {
                Console.WriteLine(assetPath);
                var tester = new UAsset(assetPath, version, mappings);
                Assert.IsTrue(tester.VerifyBinaryEquality());
                AssertAllExportsParsedCorrectly(tester);
                Console.WriteLine(tester.GetEngineVersion());
            }
        }

        private void TestUE5_3Subsection(string game, EngineVersion version, Usmap mappings = null)
        {
            string[] allTestingAssets = GetAllTestAssets(Path.Combine("TestAssets", "TestUE5_3", game));
            foreach (string assetPath in allTestingAssets)
            {
                Console.WriteLine(assetPath);
                var tester = new UAsset(assetPath, version, mappings);
                Assert.IsTrue(tester.VerifyBinaryEquality());
                AssertAllExportsParsedCorrectly(tester);
                Console.WriteLine(tester.GetEngineVersion());
            }
        }

        private void TestUE5_4Subsection(string game, EngineVersion version, Usmap mappings = null)
        {
            string[] allTestingAssets = GetAllTestAssets(Path.Combine("TestAssets", "TestUE5_4", game));
            foreach (string assetPath in allTestingAssets)
            {
                Console.WriteLine(assetPath);
                var tester = new UAsset(assetPath, version, mappings);
                Assert.IsTrue(tester.VerifyBinaryEquality());
                AssertAllExportsParsedCorrectly(tester);
                Console.WriteLine(tester.GetEngineVersion());
            }
        }

        private void TestUE5_5Subsection(string game, EngineVersion version, Usmap mappings = null)
        {
            string[] allTestingAssets = GetAllTestAssets(Path.Combine("TestAssets", "TestUE5_5", game));
            foreach (string assetPath in allTestingAssets)
            {
                Console.WriteLine(assetPath);
                var tester = new UAsset(assetPath, version, mappings);
                Assert.IsTrue(tester.VerifyBinaryEquality());
                AssertAllExportsParsedCorrectly(tester);
                Console.WriteLine(tester.GetEngineVersion());
            }
        }
        
        private void TestUE5_6Subsection(string game, EngineVersion version, Usmap mappings = null)
        {
            string[] allTestingAssets = GetAllTestAssets(Path.Combine("TestAssets", "TestUE5_6", game));
            foreach (string assetPath in allTestingAssets)
            {
                Console.WriteLine(assetPath);
                var tester = new UAsset(assetPath, version, mappings);
                Assert.IsTrue(tester.VerifyBinaryEquality());
                AssertAllExportsParsedCorrectly(tester);
                Console.WriteLine(tester.GetEngineVersion());
            }
        }

        /// <summary>
        /// Tests the GUID/string conversion operations to ensure that they match the Unreal implementation.
        /// </summary>
        [TestMethod]
        public void TestGUIDs()
        {
            string input = "{CF873D05-4977-597A-F120-7F9F90B1ED09}";
            Guid test = input.ConvertToGUID();
            Assert.IsTrue(test.ConvertToString() == input);
            Assert.IsTrue(test.ToByteArray().SequenceEqual(UAPUtils.ConvertHexStringToByteArray("05 3D 87 CF 7A 59 77 49 9F 7F 20 F1 09 ED B1 90")));
        }

        /// <summary>
        /// In this test, we examine a variety of assets from different games and ensure that they parse correctly and maintain binary equality.
        /// </summary>
        [TestMethod]
        public void TestManyAssets()
        {
            TestManyAssetsSubsection("Biodigital", EngineVersion.VER_UE4_14);
            TestManyAssetsSubsection("SnakePass", EngineVersion.VER_UE4_14);
            TestManyAssetsSubsection("Tekken", EngineVersion.VER_UE4_14);
            TestManyAssetsSubsection("MidAir", EngineVersion.VER_UE4_17);
            TestManyAssetsSubsection("MutantYearZero", EngineVersion.VER_UE4_17);
            TestManyAssetsSubsection("Bloodstained", EngineVersion.VER_UE4_18);
            TestManyAssetsSubsection("BurningDaylight", EngineVersion.VER_UE4_18);
            TestManyAssetsSubsection("CodeVein", EngineVersion.VER_UE4_18);
            TestManyAssetsSubsection("Liminal", EngineVersion.VER_UE4_18);
            TestManyAssetsSubsection("ToTheCore", EngineVersion.VER_UE4_18);
            TestManyAssetsSubsection("TheBeastInside", EngineVersion.VER_UE4_19);
            TestManyAssetsSubsection("TheOccupation", EngineVersion.VER_UE4_19);
            TestManyAssetsSubsection("Astroneer", EngineVersion.VER_UE4_23);
            TestManyAssetsSubsection("StarlitSeason", EngineVersion.VER_UE4_24);
            TestManyAssetsSubsection("MISC_426", EngineVersion.VER_UE4_26);
            TestManyAssetsSubsection("VERSIONED", EngineVersion.UNKNOWN);

            // traditional, NOT zen/io store. includes unversioned properties
            TestManyAssetsSubsection("LiesOfP", EngineVersion.VER_UE4_27, new Usmap(Path.Combine("TestAssets", "TestManyAssets", "LiesOfP", "LiesOfP.usmap")));
            TestManyAssetsSubsection("Palia", EngineVersion.VER_UE5_1, new Usmap(Path.Combine("TestAssets", "TestManyAssets", "Palia", "Palia.usmap")));
            TestManyAssetsSubsection("F1Manager2023", EngineVersion.VER_UE5_1, new Usmap(Path.Combine("TestAssets", "TestManyAssets", "F1Manager2023", "F1Manager2023.usmap")));
            TestManyAssetsSubsection("Palworld", EngineVersion.VER_UE5_1, new Usmap(Path.Combine("TestAssets", "TestManyAssets", "Palworld", "Palworld.usmap")));
        }

        /// <summary>
        /// In this test, we examine and modify a DataTable to ensure that it parses correctly and maintains binary equality.
        /// </summary>
        [TestMethod]
        public void TestDataTables()
        {
            var assetPath = Path.Combine("TestAssets", "TestManyAssets", "Bloodstained", "PB_DT_RandomizerRoomCheck.uasset");
            var tester = new UAsset(assetPath, EngineVersion.VER_UE4_18);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);
            Assert.IsTrue(tester.Exports.Count == 1);

            var ourDataTableExport = tester.Exports[0] as DataTableExport;
            var ourTable = ourDataTableExport?.Table;
            Assert.IsNotNull(ourTable);

            // Check out the first entry to make sure it's parsing alright, and flip all the flags for later testing
            StructPropertyData firstEntry = ourTable.Data[0];

            bool didFindTestName = false;
            for (int i = 0; i < firstEntry.Value.Count; i++)
            {
                var propData = firstEntry.Value[i];
                Console.WriteLine(i + ": " + propData.Name + ", " + propData.PropertyType);
                if (propData.Name == new FName(tester, "AcceleratorANDDoubleJump")) didFindTestName = true;
                if (propData is BoolPropertyData boolProp) boolProp.Value = !boolProp.Value;
            }
            Assert.IsTrue(didFindTestName);

            // Save the modified table
            tester.Write(Path.Combine("TestAssets", "MODIFIED.uasset"));

            // Load the modified table back in and make sure we're good
            var tester2 = new UAsset(Path.Combine("TestAssets", "MODIFIED.uasset"), EngineVersion.VER_UE4_18);
            Assert.IsTrue(tester2.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester2);
            Assert.IsTrue(tester2.Exports.Count == 1);

            // Flip the flags back to what they originally were
            firstEntry = (tester2.Exports[0] as DataTableExport)?.Table?.Data?[0];
            Assert.IsNotNull(firstEntry);
            for (int i = 0; i < firstEntry.Value.Count; i++)
            {
                if (firstEntry.Value[i] is BoolPropertyData boolProp) boolProp.Value = !boolProp.Value;
            }

            // Save and check that it's binary equal to what we originally had
            tester2.Write(tester2.FilePath);
            Assert.IsTrue(File.ReadAllBytes(assetPath).SequenceEqual(File.ReadAllBytes(Path.Combine("TestAssets", "MODIFIED.uasset"))));
        }

        private void TestJsonOnFile(string file, EngineVersion version, string subFolder = "TestJson", string mappingsFile = null)
        {
            Usmap mappings = string.IsNullOrEmpty(mappingsFile) ? null : new Usmap(Path.Combine("TestAssets", subFolder, mappingsFile));

            Console.WriteLine(file);
            var tester = new UAsset(Path.Combine("TestAssets", subFolder, file), version, mappings);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);

            string jsonSerializedAsset = tester.SerializeJson();
            File.WriteAllText(Path.Combine("TestAssets", subFolder, "raw.json"), jsonSerializedAsset);

            var tester2 = UAsset.DeserializeJson(File.ReadAllText(Path.Combine("TestAssets", subFolder, "raw.json")));
            tester2.Mappings = mappings;
            tester2.Write(Path.Combine("TestAssets", subFolder, "MODIFIED.uasset"));

            // For the assets we're testing binary equality is maintained and can be used as a metric of success, but binary equality is not guaranteed for all assets
            Assert.IsTrue(File.ReadAllBytes(Path.Combine("TestAssets", subFolder, file)).SequenceEqual(File.ReadAllBytes(Path.Combine("TestAssets", subFolder, "MODIFIED.uasset"))));
        }

        /// <summary>
        /// In this test, we serialize some assets to JSON and back to test if the JSON serialization system is functional.
        /// </summary>
        [TestMethod]
        public void TestJson()
        {
            TestJsonOnFile("PB_DT_RandomizerRoomCheck.uasset", EngineVersion.VER_UE4_18, Path.Combine("TestManyAssets", "Bloodstained"));
            TestJsonOnFile("m02VIL_004_Gimmick.umap", EngineVersion.VER_UE4_18, Path.Combine("TestManyAssets", "Bloodstained"));
            TestJsonOnFile("Staging_T2.umap", EngineVersion.VER_UE4_23, Path.Combine("TestManyAssets", "Astroneer"));
            TestJsonOnFile("Items.uasset", EngineVersion.VER_UE4_23); // string table
            //TestJsonOnFile("ABP_SMG_A.uasset", UE4Version.VER_UE4_25);
            TestJsonOnFile("WPN_LockOnRifle.uasset", EngineVersion.VER_UE4_25);
            TestJsonOnFile("Map_FrontEnd_Hotel_LS_Night.umap", EngineVersion.VER_UE4_27);
            TestJsonOnFile("AssetDatabase_AutoGenerated.uasset", EngineVersion.VER_UE4_27);
            TestJsonOnFile("RaceSimDataAsset.uasset", EngineVersion.VER_UE4_27);
            TestJsonOnFile("TurboAcres_Environment.uasset", EngineVersion.VER_UE4_27);
            TestJsonOnFile("MGA_HeavyWeapon_Parent.uasset", EngineVersion.VER_UE4_25, "TestJson", "Outriders.usmap");
            TestJsonOnFile("Atlas_6x4_Semi.uasset", EngineVersion.VER_UE5_5, "TestJson", "MotorTown.usmap");
        }

        /// <summary>
        /// In this test, we add a new property called "CoolProperty" in the tests assembly to test whether or not PropertyData-inheriting classes in dependent assemblies are registered by UAssetAPI.
        /// </summary>
        /// <see cref="CoolPropertyData"/>
        [TestMethod]
        public void TestCustomProperty()
        {
            var tester = new UAsset(Path.Combine("TestAssets", "TestCustomProperty", "AlternateStartActor.uasset"), EngineVersion.VER_UE4_23);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);

            // Make sure that there are no unknown properties, and that there is at least one CoolProperty with a value of 72
            bool hasCoolProperty = false;
            foreach (Export testExport in tester.Exports)
            {
                if (testExport is NormalExport normalTestExport)
                {
                    foreach (PropertyData prop in normalTestExport.Data)
                    {
                        Assert.IsFalse(prop is UnknownPropertyData);
                        if (prop is CoolPropertyData coolProp)
                        {
                            hasCoolProperty = true;
                            Assert.IsTrue(coolProp.Value == 72);
                        }
                    }
                }
            }
            Assert.IsTrue(hasCoolProperty);
        }

        /// <summary>
        /// In this test, we verify that Ace Combat 7 decryption works.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestACE7()
        {
            // Create copies of original files
            foreach (var path in Directory.GetFiles(Path.Combine("TestAssets", "TestACE7"), "*.*"))
            {
                File.Copy(path, path + ".bak", true);
            }

            // Decrypt them
            var decrypter = new AC7Decrypt();
            decrypter.Decrypt(Path.Combine("TestAssets", "TestACE7", "plwp_6aam_a0.uasset"), Path.Combine("TestAssets", "TestACE7", "plwp_6aam_a0.uasset"));
            decrypter.Decrypt(Path.Combine("TestAssets", "TestACE7", "ex02_IGC_03_Subtitle.uasset"), Path.Combine("TestAssets", "TestACE7", "ex02_IGC_03_Subtitle.uasset"));

            // Verify the files can be parsed
            var tester = new UAsset(Path.Combine("TestAssets", "TestACE7", "plwp_6aam_a0.uasset"), EngineVersion.VER_UE4_18);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);

            tester = new UAsset(Path.Combine("TestAssets", "TestACE7", "ex02_IGC_03_Subtitle.uasset"), EngineVersion.VER_UE4_18);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);

            // Encrypt them
            decrypter.Encrypt(Path.Combine("TestAssets", "TestACE7", "plwp_6aam_a0.uasset"), Path.Combine("TestAssets", "TestACE7", "plwp_6aam_a0.uasset"));
            decrypter.Encrypt(Path.Combine("TestAssets", "TestACE7", "ex02_IGC_03_Subtitle.uasset"), Path.Combine("TestAssets", "TestACE7", "ex02_IGC_03_Subtitle.uasset"));

            // Verify binary equality
            foreach (var path in Directory.GetFiles(Path.Combine("TestAssets", "TestACE7"), "*.bak"))
            {
                VerifyBinaryEquality(path, path.Substring(0, path.Length - 4));
            }
        }

        /// <summary>
        /// In this test, we verify that material assets parses correctly and maintains binary equality.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestMaterials()
        {
            // Verify the files can be parsed
            var tester = new UAsset(Path.Combine("TestAssets", "TestMaterials", "M_COM_DetailMaster_B.uasset"), EngineVersion.VER_UE4_18);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);

            tester = new UAsset(Path.Combine("TestAssets", "TestMaterials", "as_mt_base.uasset"), EngineVersion.VER_UE4_20);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);
        }

        /// <summary>
        /// In this test, we are trying to read a source asset.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestEditorAssets()
        {
            var soundClass = new UAsset(Path.Combine("TestAssets", "TestEditorAssets", "TestSoundClass.uasset"), EngineVersion.VER_UE4_27);
            Assert.IsTrue(soundClass.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(soundClass);

            var material = new UAsset(Path.Combine("TestAssets", "TestEditorAssets", "TestMaterial.uasset"), EngineVersion.VER_UE4_27);
            Assert.IsTrue(material.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(material);

            var blueprint = new UAsset(Path.Combine("TestAssets", "TestEditorAssets", "TestActorBP.uasset"), EngineVersion.VER_UE4_27);
            Assert.IsTrue(blueprint.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(blueprint);
        }
      
        /// <summary>
        /// In this test, we test several traditional assets specifically from Unreal Engine 5.3 games.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestTraditionalUE5_3()
        {
            TestUE5_3Subsection("Engine", EngineVersion.VER_UE5_3, new Usmap(Path.Combine("TestAssets", "TestUE5_3", "Engine", "Engine.usmap")));
            TestUE5_3Subsection("RON", EngineVersion.VER_UE5_3, new Usmap(Path.Combine("TestAssets", "TestUE5_3", "RON", "ReadyOrNot.usmap")));
        }

        /// <summary>
        /// In this test, we test several traditional assets specifically from Unreal Engine 5.4 games.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestTraditionalUE5_4()
        {
            TestUE5_4Subsection("BlankGame", EngineVersion.VER_UE5_4, new Usmap(Path.Combine("TestAssets", "TestUE5_4", "BlankGame", "BlankGame_Dumper-7.usmap")));
            TestUE5_4Subsection("Bellwright", EngineVersion.VER_UE5_4, new Usmap(Path.Combine("TestAssets", "TestUE5_4", "Bellwright", "Bellwright.usmap")));
            TestUE5_4Subsection("TheForeverWinter", EngineVersion.VER_UE5_4, new Usmap(Path.Combine("TestAssets", "TestUE5_4", "TheForeverWinter", "TheForeverWinter.usmap")));
            TestUE5_4Subsection("Billiards", EngineVersion.VER_UE5_4, new Usmap(Path.Combine("TestAssets", "TestUE5_4", "Billiards", "5.4.3-34507850+++UE5+Release-5.4-DeepSpace7.usmap")));
            TestUE5_4Subsection("JOY", EngineVersion.VER_UE5_4, new Usmap(Path.Combine("TestAssets", "TestUE5_4", "JOY", "5.4.3-34507850+++UE5+Release-5.4-JOY.usmap")));
        }

        /// <summary>
        /// In this test, we test several traditional assets specifically from Unreal Engine 5.5 games.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestTraditionalUE5_5()
        {
            TestUE5_5Subsection("BlankGame", EngineVersion.VER_UE5_5, new Usmap(Path.Combine("TestAssets", "TestUE5_5", "BlankGame", "BlankUE5_5.usmap")));
        }
        
        /// <summary>
        /// In this test, we test several traditional assets specifically from Unreal Engine 5.6 games.
        /// Binary equality is expected.
        /// </summary>
        [TestMethod]
        public void TestTraditionalUE5_6()
        {
            TestUE5_6Subsection("BpThirdPerson", EngineVersion.VER_UE5_6, new Usmap(Path.Combine("TestAssets", "TestUE5_6", "BpThirdPerson", "ExplicitEnumValuesExample.usmap")));
        }

        /// <summary>
        /// In this test, we test the Clone function, along with indexers for assets and exports.
        /// </summary>
        [TestMethod]
        public void TestClone()
        {
            var mappings = new Usmap(Path.Combine("TestAssets", "TestUE5_3", "RON", "ReadyOrNot.usmap"));

            // clone everything and check for binary equality
            var blueprint = new UAsset(Path.Combine("TestAssets", "TestUE5_3", "RON", "AmmoDataTable.uasset"), EngineVersion.VER_UE5_3, mappings);
            for (int i = 0; i < blueprint.Exports.Count; i++)
            {
                Export curExp = blueprint.Exports[i];
                if (curExp is NormalExport nExp)
                {
                    for (int j = 0; j < nExp.Data.Count; j++)
                    {
                        nExp.Data[j] = (PropertyData)nExp.Data[j].Clone();
                    }
                }
                if (curExp is DataTableExport dtExp)
                {
                    for (int j = 0; j < dtExp.Table.Data.Count; j++)
                    {
                        dtExp.Table.Data[j] = (StructPropertyData)dtExp.Table.Data[j].Clone();
                    }
                }
            }
            Assert.IsTrue(blueprint.VerifyBinaryEquality());

            // some basic tests with the indexers
            DataTableExport exp = (DataTableExport)blueprint["AmmoDataTable"];
            StructPropertyData struc = (StructPropertyData)exp["556x45JHP"];
            StructPropertyData nuevo = (StructPropertyData)struc.Clone();
            nuevo["Damage"] = new FloatPropertyData() { Value = 60 };
            exp["556x45JHP_MODIFIED"] = nuevo;

            // save, read again, and verify
            blueprint.Write(blueprint.FilePath);

            var blueprint2 = new UAsset(blueprint.FilePath, EngineVersion.VER_UE5_3, mappings);
            Assert.IsTrue(blueprint2.VerifyBinaryEquality());

            DataTableExport exp2 = (DataTableExport)blueprint["AmmoDataTable"];
            StructPropertyData struc2 = (StructPropertyData)exp["556x45JHP"];
            StructPropertyData struc2_2 = (StructPropertyData)exp["556x45JHP_MODIFIED"];
            Assert.IsTrue(struc2["Damage"] is FloatPropertyData blah2 && blah2.Value == 30);
            Assert.IsTrue(struc2_2["Damage"] is FloatPropertyData blah3 && blah3.Value == 60);
        }

        /// <summary>
        /// In this test, we save and load a .pak file to verify functionality of the repak interop.
        /// </summary>
        [TestMethod]
        public void TestRepak()
        {
            Console.WriteLine("Writing pak");
            using (FileStream stream = new FileStream("output2.pak", FileMode.Create))
            {
                var builder = new PakBuilder();
                var pak_writer = builder.Writer(stream);
                pak_writer.WriteFile("a_file.txt", Encoding.ASCII.GetBytes("some file contents\n"));
                pak_writer.WriteFile("another_file.txt", Encoding.ASCII.GetBytes("lorem ipsum\ndolor sit\n"));
                pak_writer.WriteFile("nested/file.txt", Encoding.ASCII.GetBytes("hello world\n"));
                pak_writer.WriteIndex();
            }
            Console.WriteLine("Reading pak");
            using (FileStream stream = new FileStream("output2.pak", FileMode.Open))
            {
                var builder = new PakBuilder();
                var pak_reader = builder.Reader(stream);
                foreach (var file in pak_reader.Files())
                {
                    Console.WriteLine($"File: {file}");
                    var bytes = pak_reader.Get(stream, file);
                    Console.WriteLine($"Contents: {Encoding.ASCII.GetString(bytes)}");
                }
            }
        }

        /// <summary>
        /// In this test, we parse a .usmap containing an OptionalProperty (as currently produced by Dumper-7) to verify compatibility.
        /// </summary>
        [TestMethod]
        public void TestUsmapWithOptionalProperty()
        {
            var usmap = new Usmap(Path.Combine("TestAssets", "TestUE5_4", "BlankGame", "BlankGame_Dumper-7.usmap"));
            Assert.AreEqual(31948, usmap.NameMap.Count);
            Assert.AreEqual(1565, usmap.EnumMap.Count);
            Assert.AreEqual(7657, usmap.Schemas.Count);
        }

        /// <summary>
        /// In this test, we parse a .usmap with explicit enum values.
        /// </summary>
        [TestMethod]
        public void TestUsmapWithExplicitEnumValues()
        {
            var usmap = new Usmap(Path.Combine("TestAssets", "TestUE5_6", "BpThirdPerson", "ExplicitEnumValuesExample.usmap"));
            Assert.AreEqual(36767, usmap.NameMap.Count);
            Assert.AreEqual(1739, usmap.EnumMap.Count);
            Assert.AreEqual(9230, usmap.Schemas.Count);
        }

        /// <summary>
        /// In this test, we do tests for various underlying enum types within a DataTable row to ensure that it parses correctly and maintains binary equality.
        /// </summary>
        [TestMethod]
        public void TestUnderlyingEnumTypes()
        {
            var usmap = new Usmap(Path.Combine("TestAssets", "TestUE5_1", "UnderlyingEnumTypes", "UnderlyingEnumTypes.usmap"));
            var assetPath = Path.Combine("TestAssets", "TestUE5_1", "UnderlyingEnumTypes", "NewDataTable.uasset");
            var tester = new UAsset(assetPath, EngineVersion.VER_UE5_1, usmap);
            Assert.IsTrue(tester.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester);
            Assert.IsTrue(tester.Exports.Count == 1);

            var ourDataTableExport = tester.Exports[0] as DataTableExport;
            var ourTable = ourDataTableExport?.Table;
            Assert.IsNotNull(ourTable);

            // Check out the first entry to make sure it's parsing alright
            StructPropertyData firstEntry = ourTable.Data[1];
            for (int i = 0; i < firstEntry.Value.Count; i++)
            {
                var propData = firstEntry.Value[i];
                if (propData is EnumPropertyData enumProp && enumProp.InnerType?.Value?.Value != "Int64Property") enumProp.Value = FName.DefineDummy(tester, "Two");
                if (propData is EnumPropertyData enumProp64 && enumProp64.InnerType?.Value?.Value == "Int64Property") enumProp64.Value = FName.DefineDummy(tester, "None");
            }

            // Save the modified table
            tester.Write(Path.Combine("TestAssets", "MODIFIED.uasset"));

            // Load the modified table back in and make sure we're good
            var tester2 = new UAsset(Path.Combine("TestAssets", "MODIFIED.uasset"), EngineVersion.VER_UE5_1, usmap);
            Assert.IsTrue(tester2.VerifyBinaryEquality());
            AssertAllExportsParsedCorrectly(tester2);
            Assert.IsTrue(tester2.Exports.Count == 1);

            firstEntry = (tester2.Exports[0] as DataTableExport)?.Table?.Data?[1];
            Assert.IsNotNull(firstEntry);
            Console.WriteLine($"{"#",-2} {"Name",-20} {"Type",-15} {"Sub Type",-15} {"Value",-10} Offset");
            Console.WriteLine("-------------------------------------------------------------------------");
            for (int i = 0; i < firstEntry.Value.Count; i++)
            {
                var propData = firstEntry.Value[i];
                if (propData is EnumPropertyData enumProp) {
                    Console.WriteLine($"{i}: {propData.Name,-20} {propData.PropertyType,-15} {enumProp.InnerType?.Value?.Value,-15} {propData.RawValue,-10} {propData.Offset}");
                }
                else
                {
                    Console.WriteLine($"{i}: {propData.Name,-20} {propData.PropertyType,-15} {"None",-15} {propData.RawValue,-10} {propData.Offset}");
                }
            }

            // Save and check that it's binary equal to what we originally had
            tester2.Write(tester2.FilePath);
            Assert.IsTrue(File.ReadAllBytes(assetPath).SequenceEqual(File.ReadAllBytes(Path.Combine("TestAssets", "MODIFIED.uasset"))));
        }

        public static MemoryStream PathToStream(string p)
        {
            using (FileStream origStream = File.Open(p, FileMode.Open, new FileInfo(p).IsReadOnly ? FileAccess.Read : FileAccess.ReadWrite))
            {
                MemoryStream completeStream = new MemoryStream();
                origStream.CopyTo(completeStream);

                try
                {
                    var targetFile = Path.ChangeExtension(p, "uexp");
                    if (File.Exists(targetFile))
                    {
                        using (FileStream newStream = File.Open(targetFile, FileMode.Open))
                        {
                            completeStream.Seek(0, SeekOrigin.End);
                            newStream.CopyTo(completeStream);
                        }
                    }
                }
                catch (FileNotFoundException) { }

                completeStream.Seek(0, SeekOrigin.Begin);
                return completeStream;
            }
        }

#if DEBUGTRACING
        [TestMethod]
        public void TestTracing()
        {
            Console.WriteLine("asdf");

            var stream = new UAssetAPI.Trace.TraceStream(PathToStream(Path.Combine("TestAssets", "TestMaterials", "M_COM_DetailMaster_B.uasset")));

            // Verify the files can be parsed

            Trace.LoggingAspect.Start(stream);
            var tester = new UAsset(new AssetBinaryReader(stream), EngineVersion.VER_UE4_18);
            Trace.LoggingAspect.Stop();

            //Assert.IsTrue(tester.VerifyBinaryEquality());
            //CheckAllExportsParsedCorrectly(tester);
        }
#endif

        [AssemblyCleanup()]
        public static void AssemblyCleanup()
        {
            foreach (var path in Directory.GetDirectories("."))
            {
                if (Path.GetFileName(path).Length < 4 || Path.GetFileName(path).Substring(0, 4).ToLowerInvariant() != "test") continue;
                try
                {
                    Directory.Delete(path, true);
                }
                catch { }
            }
        }
    }
}

```

`UAssetAPI.Tests/CoolPropertyData.cs`:

```cs
using System;
using System.IO;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.PropertyTypes.Objects
{
    /// <summary>
    /// Describes something very cool!
    /// </summary>
    public class CoolPropertyData : PropertyData<int>
    {
        public CoolPropertyData(FName name) : base(name)
        {

        }

        public CoolPropertyData()
        {

        }

        private static readonly FString CurrentPropertyType = new FString("CoolProperty");
        public override FString PropertyType { get { return CurrentPropertyType; } }

        public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
        {
            if (includeHeader)
            {
                this.ReadEndPropertyTag(reader);
            }
            Value = (int)reader.ReadByte();
        }

        public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
        {
            if (includeHeader)
            {
                this.WriteEndPropertyTag(writer);
            }

            writer.Write((byte)Value);
            return sizeof(byte);
        }

        public override string ToString()
        {
            return Convert.ToString(Value);
        }

        public override void FromString(string[] d, UAsset asset)
        {
            if (int.TryParse(d[0], out int x)) Value = x;
        }
    }
}
```

`UAssetAPI.Tests/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: ComVisible(false)]

[assembly: Guid("cb796120-5ef8-4e9d-bcdb-d2f60a4efc69")]

```

`UAssetAPI.Tests/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Tests.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("UAssetAPI.Tests.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}

```

`UAssetAPI.Tests/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UAssetAPI.Tests/TestAssets/TestACE7/ex02_IGC_03_Subtitle.uexp`:

```uexp
¸<­|þ¶Æ7df…
Ó!úx×%†$­’V„9º$iÜjÎC]eXM:WLcYÖ=ƒ¡
```

`UAssetAPI.Tests/UAssetAPI.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <ProjectGuid>{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}</ProjectGuid>
    <TargetFramework>net8.0</TargetFramework>
    <ProjectTypeGuids>{3AC096D0-A1C2-E12C-1390-A8335801FDAB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <VSToolsPath Condition="'$(VSToolsPath)' == ''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
    <ReferencePath>$(ProgramFiles)\Common Files\microsoft shared\VSTT\$(VisualStudioVersion)\UITestExtensionPackages</ReferencePath>
    <IsCodedUITest>False</IsCodedUITest>
    <TestProjectType>UnitTest</TestProjectType>
    <AssemblyTitle>UAssetAPI.Tests</AssemblyTitle>
    <Product>UAssetAPI.Tests</Product>
    <Copyright>Copyright © Atenfyr 2024</Copyright>
    <OutputPath>bin\$(Configuration)\</OutputPath>
    <Configurations>Debug;Release;DebugVerbose;DebugTracing</Configurations>
    <Platforms>AnyCPU;x86</Platforms>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|AnyCPU'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugTracing|AnyCPU'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugTracing|x86'">
    <DebugType>full</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'">
    <DebugType>pdbonly</DebugType>
  </PropertyGroup>
  <Import Project="$(VSToolsPath)\TeamTest\Microsoft.TestTools.targets" Condition="Exists('$(VSToolsPath)\TeamTest\Microsoft.TestTools.targets')" />
  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="MSTest.TestAdapter" Version="2.1.2" />
    <PackageReference Include="MSTest.TestFramework" Version="2.1.2" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.6.0" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\UAssetAPI\UAssetAPI.csproj" />
  </ItemGroup>
  <ItemGroup>
    <None Update="TestAssets\**\*.*">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>
```

`UAssetAPI.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33103.184
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UAssetAPI", "UAssetAPI\UAssetAPI.csproj", "{178417EC-1177-413E-BE85-C83AECD64279}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UAssetAPI.Tests", "UAssetAPI.Tests\UAssetAPI.Tests.csproj", "{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UAssetAPI.Benchmark", "UAssetAPI.Benchmark\UAssetAPI.Benchmark.csproj", "{A74E7E85-1797-477C-AEC1-583AE7D109D0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		DebugTracing|Any CPU = DebugTracing|Any CPU
		DebugTracing|x64 = DebugTracing|x64
		DebugVerbose|Any CPU = DebugVerbose|Any CPU
		DebugVerbose|x64 = DebugVerbose|x64
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|Any CPU.ActiveCfg = DebugTracing|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|Any CPU.Build.0 = DebugTracing|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|x64.ActiveCfg = DebugTracing|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugTracing|x64.Build.0 = DebugTracing|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|Any CPU.ActiveCfg = DebugVerbose|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|Any CPU.Build.0 = DebugVerbose|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|x64.ActiveCfg = DebugVerbose|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.DebugVerbose|x64.Build.0 = DebugVerbose|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|x64.ActiveCfg = Debug|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Debug|x64.Build.0 = Debug|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|Any CPU.Build.0 = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|x64.ActiveCfg = Release|Any CPU
		{178417EC-1177-413E-BE85-C83AECD64279}.Release|x64.Build.0 = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|Any CPU.ActiveCfg = DebugTracing|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|Any CPU.Build.0 = DebugTracing|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|x64.ActiveCfg = DebugTracing|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugTracing|x64.Build.0 = DebugTracing|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|Any CPU.ActiveCfg = DebugVerbose|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|Any CPU.Build.0 = DebugVerbose|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|x64.ActiveCfg = DebugVerbose|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.DebugVerbose|x64.Build.0 = DebugVerbose|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|x64.ActiveCfg = Debug|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Debug|x64.Build.0 = Debug|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|Any CPU.Build.0 = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|x64.ActiveCfg = Release|Any CPU
		{CB796120-5EF8-4E9D-BCDB-D2F60A4EFC69}.Release|x64.Build.0 = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|Any CPU.ActiveCfg = DebugTracing|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|Any CPU.Build.0 = DebugTracing|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|x64.ActiveCfg = DebugTracing|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugTracing|x64.Build.0 = DebugTracing|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|Any CPU.ActiveCfg = DebugVerbose|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|Any CPU.Build.0 = DebugVerbose|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|x64.ActiveCfg = DebugVerbose|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.DebugVerbose|x64.Build.0 = DebugVerbose|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Debug|x64.Build.0 = Debug|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|Any CPU.Build.0 = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|x64.ActiveCfg = Release|Any CPU
		{A74E7E85-1797-477C-AEC1-583AE7D109D0}.Release|x64.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7A4553E8-6A4B-46A5-B429-7F9128492CAD}
	EndGlobalSection
EndGlobal

```

`UAssetAPI/AC7Decrypt.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using UAssetAPI.ExportTypes;

namespace UAssetAPI
{
    /// <summary>
    /// XOR key for decrypting a particular Ace Combat 7 asset. 
    /// </summary>
    public class AC7XorKey
    {
        public int NameKey;
        public int Offset;
        public int pk1;
        public int pk2;

        public void SkipCount(int count)
        {
            int num = count % 217;
            pk1 += num;
            if (pk1 >= 217)
            {
                pk1 -= 217;
            }
            int num2 = count % 1024;
            pk2 += num2;
            if (pk2 >= 1024)
            {
                pk2 -= 1024;
            }
        }

        private static int CalcNameKey(string fname)
        {
            fname = fname.ToUpper();
            int num = 0;
            for (int i = 0; i < fname.Length; i++)
            {
                int num2 = (byte)fname[i];
                num ^= num2;
                num2 = num * 8;
                num2 ^= num;
                int num3 = num + num;
                num2 = ~num2;
                num2 = (num2 >> 7) & 1;
                num = num2 | num3;
            }
            return num;
        }

        private static void CalcPKeyFromNKey(int nkey, int dataoffset, out int pk1, out int pk2)
        {
            long num = (uint)((long)nkey * 7L);
            System.Numerics.BigInteger bigInteger = new System.Numerics.BigInteger(5440514381186227205L);
            num += dataoffset;
            System.Numerics.BigInteger bigInteger2 = bigInteger * num;
            long num2 = (long)(bigInteger2 >> 70);
            long num3 = num2 >> 63;
            num2 += num3;
            num3 = num2 * 217;
            num -= num3;
            pk1 = (int)(num & 0xFFFFFFFFu);
            long num4 = (uint)((long)nkey * 11L);
            num4 += dataoffset;
            num2 = 0L;
            num2 &= 0x3FF;
            num4 += num2;
            num4 &= 0x3FF;
            long num5 = num4 - num2;
            pk2 = (int)(num5 & 0xFFFFFFFFu);
        }

        /// <summary>
        /// Generates an encryption key for a particular asset on disk.
        /// </summary>
        /// <param name="fname">The name of the asset being encrypted on disk without the extension.</param>
        /// <returns>An encryption key for the asset.</returns>
        public AC7XorKey(string fname)
        {
            NameKey = CalcNameKey(fname); Offset = 4;
            CalcPKeyFromNKey(this.NameKey, this.Offset, out this.pk1, out this.pk2);
        }
    }

    /// <summary>
    /// Decryptor for Ace Combat 7 assets.
    /// </summary>
    public class AC7Decrypt
    {
        private static byte[] AC7FullKey = new byte[0];

        public AC7Decrypt()
        {
            if (AC7FullKey.Length == 0) AC7FullKey = Properties.Resources.AC7Key;
        }

        /// <summary>
        /// Decrypts an Ace Combat 7 encrypted asset on disk.
        /// </summary>
        /// <param name="input">The path to an encrypted asset on disk.</param>
        /// <param name="output">The path that the decrypted asset should be saved to.</param>
        public void Decrypt(string input, string output)
        {
            AC7XorKey xorKey = new AC7XorKey(Path.GetFileNameWithoutExtension(input));
            byte[] doneData = DecryptUAssetBytes(File.ReadAllBytes(input), xorKey);
            File.WriteAllBytes(output, doneData);
            try
            {
                byte[] doneData2 = DecryptUexpBytes(File.ReadAllBytes(Path.ChangeExtension(input, "uexp")), xorKey);
                File.WriteAllBytes(Path.ChangeExtension(output, "uexp"), doneData2);
            }
            catch { }
        }

        /// <summary>
        /// Encrypts an Ace Combat 7 encrypted asset on disk.
        /// </summary>
        /// <param name="input">The path to a decrypted asset on disk.</param>
        /// <param name="output">The path that the encrypted asset should be saved to.</param>
        public void Encrypt(string input, string output)
        {
            AC7XorKey xorKey = new AC7XorKey(Path.GetFileNameWithoutExtension(output));
            byte[] doneData = EncryptUAssetBytes(File.ReadAllBytes(input), xorKey);
            File.WriteAllBytes(output, doneData);
            try
            {
                byte[] doneData2 = EncryptUexpBytes(File.ReadAllBytes(Path.ChangeExtension(input, "uexp")), xorKey);
                File.WriteAllBytes(Path.ChangeExtension(output, "uexp"), doneData2);
            }
            catch { }
        }

        public byte[] DecryptUAssetBytes(byte[] uasset, AC7XorKey xorkey)
        {
            if (xorkey == null) throw new NullReferenceException("Null key provided");
            byte[] array = new byte[uasset.Length];
            BitConverter.GetBytes(UAsset.UASSET_MAGIC).CopyTo(array, 0);
            for (int i = 4; i < array.Length; i++)
            {
                array[i] = GetXorByte(uasset[i], ref xorkey);
            }
            return array;
        }

        public byte[] EncryptUAssetBytes(byte[] uasset, AC7XorKey xorkey)
        {
            if (xorkey == null) throw new NullReferenceException("Null key provided");
            byte[] array = new byte[uasset.Length];
            BitConverter.GetBytes(UAsset.ACE7_MAGIC).CopyTo(array, 0);
            for (int i = 4; i < array.Length; i++)
            {
                array[i] = GetXorByte(uasset[i], ref xorkey);
            }
            return array;
        }

        public byte[] DecryptUexpBytes(byte[] uexp, AC7XorKey xorkey)
        {
            if (xorkey == null) throw new NullReferenceException("Null key provided");
            byte[] array = new byte[uexp.Length];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = GetXorByte(uexp[i], ref xorkey);
            }
            BitConverter.GetBytes(UAsset.UASSET_MAGIC).CopyTo(array, array.Length - 4);
            return array;
        }

        public byte[] EncryptUexpBytes(byte[] uexp, AC7XorKey xorkey)
        {
            if (xorkey == null) throw new NullReferenceException("Null key provided");
            byte[] array = new byte[uexp.Length];
            for (int i = 0; i < uexp.Length; i++)
            {
                array[i] = GetXorByte(uexp[i], ref xorkey);
            }
            return array;
        }

        private static byte GetXorByte(byte tagb, ref AC7XorKey xorkey)
        {
            if (xorkey == null)
            {
                return tagb;
            }
            tagb = (byte)((uint)(tagb ^ AC7FullKey[xorkey.pk1 * 1024 + xorkey.pk2]) ^ 0x77u);
            xorkey.pk1++;
            xorkey.pk2++;
            if (xorkey.pk1 >= 217)
            {
                xorkey.pk1 = 0;
            }
            if (xorkey.pk2 >= 1024)
            {
                xorkey.pk2 = 0;
            }
            return tagb;
        }
    }
}

```

`UAssetAPI/AssetBinaryReader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using UAssetAPI.CustomVersions;
using UAssetAPI.Kismet.Bytecode;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI;

/// <summary>
/// Any binary reader used in the parsing of Unreal file types.
/// </summary>
public class UnrealBinaryReader : BinaryReader
{
    public UnrealBinaryReader(Stream stream) : base(stream) { }

    protected byte[] ReverseIfBigEndian(byte[] data)
    {
        if (!BitConverter.IsLittleEndian) Array.Reverse(data);
        return data;
    }

    public override short ReadInt16()
    {
        return BitConverter.ToInt16(ReverseIfBigEndian(base.ReadBytes(2)), 0);
    }

    public override ushort ReadUInt16()
    {
        return BitConverter.ToUInt16(ReverseIfBigEndian(base.ReadBytes(2)), 0);
    }

    public override int ReadInt32()
    {
        return BitConverter.ToInt32(ReverseIfBigEndian(base.ReadBytes(4)), 0);
    }

    public override uint ReadUInt32()
    {
        return BitConverter.ToUInt32(ReverseIfBigEndian(base.ReadBytes(4)), 0);
    }

    public override long ReadInt64()
    {
        return BitConverter.ToInt64(ReverseIfBigEndian(base.ReadBytes(8)), 0);
    }

    public override ulong ReadUInt64()
    {
        return BitConverter.ToUInt64(ReverseIfBigEndian(base.ReadBytes(8)), 0);
    }

    public override float ReadSingle()
    {
        return BitConverter.ToSingle(ReverseIfBigEndian(base.ReadBytes(4)), 0);
    }

    public override double ReadDouble()
    {
        return BitConverter.ToDouble(ReverseIfBigEndian(base.ReadBytes(8)), 0);
    }

    public bool ReadBooleanInt()
    {
        var i = ReadInt32();
        return i switch
        {
            1 => true,
            0 => false,
            _ => throw new FormatException($"Invalid boolean value {i}")
        };
    }

    public override string ReadString()
    {
        return ReadFString()?.Value;
    }

    public virtual FString ReadFString()
    {
        int length = this.ReadInt32();
        switch (length)
        {
            case < 0:
                var len = -length * 2;
                Span<byte> data = len < 512 ? stackalloc byte[len] : new byte[len];
                BaseStream.Read(data);
                return new FString(Encoding.Unicode.GetString(data[..^2]), Encoding.Unicode);
            case > 0:
                data = length < 512 ? stackalloc byte[length] : new byte[length];
                BaseStream.Read(data);
                return new FString(Encoding.UTF8.GetString(data[..^1]), Encoding.UTF8);
            default:
                return null;
        }
    }

    public virtual FString ReadUtf8String()
    {
        int length = this.ReadInt32();
        switch (length)
        {
            case < 0:
                throw new FormatException("Invalid UTF-8 string length");
            case > 0:
                Span<byte> data = length < 512 ? stackalloc byte[length] : new byte[length];
                BaseStream.Read(data);
                return new FString(Encoding.UTF8.GetString(data), Encoding.UTF8);
            default:
                return null;
        }
    }

    public virtual FString ReadNameMapString(out uint hashes)
    {
        hashes = 0;
        FString str = this.ReadFString();
        if (this is AssetBinaryReader abr)
        {
            if (abr.Asset is UAsset abrUa && abrUa.WillSerializeNameHashes != false && !string.IsNullOrEmpty(str.Value))
            {
                hashes = this.ReadUInt32();
                if (hashes < (1 << 10) && abrUa.ObjectVersion < ObjectVersion.VER_UE4_NAME_HASHES_SERIALIZED) // "i lied, there's actually no hashes"
                {
                    abrUa.WillSerializeNameHashes = false;
                    hashes = 0;
                    this.BaseStream.Position -= sizeof(uint);
                }
                else
                {
                    abrUa.WillSerializeNameHashes = true;
                }
            }
        }
        return str;
    }

    public List<CustomVersion> ReadCustomVersionContainer(ECustomVersionSerializationFormat format, List<CustomVersion> oldCustomVersionContainer = null, Usmap Mappings = null)
    {
        var newCustomVersionContainer = new List<CustomVersion>();
        var existingCustomVersions = new HashSet<Guid>();
        switch (format)
        {
            case ECustomVersionSerializationFormat.Enums:
                throw new NotImplementedException("Custom version serialization format Enums is currently unimplemented");
            case ECustomVersionSerializationFormat.Guids:
                int numCustomVersions = ReadInt32();
                for (int i = 0; i < numCustomVersions; i++)
                {
                    var customVersionID = new Guid(ReadBytes(16));
                    var customVersionNumber = ReadInt32();
                    newCustomVersionContainer.Add(new CustomVersion(customVersionID, customVersionNumber) { Name = ReadFString() });
                    existingCustomVersions.Add(customVersionID);
                }
                break;
            case ECustomVersionSerializationFormat.Optimized:
                numCustomVersions = ReadInt32();
                for (int i = 0; i < numCustomVersions; i++)
                {
                    var customVersionID = new Guid(ReadBytes(16));
                    var customVersionNumber = ReadInt32();
                    newCustomVersionContainer.Add(new CustomVersion(customVersionID, customVersionNumber));                      
                    existingCustomVersions.Add(customVersionID);
                }
                break;

        }    

        if (Mappings != null && Mappings.CustomVersionContainer != null && Mappings.CustomVersionContainer.Count > 0)
        {
            foreach (CustomVersion entry in Mappings.CustomVersionContainer)
            {
                if (!existingCustomVersions.Contains(entry.Key)) newCustomVersionContainer.Add(entry.SetIsSerialized(false));
            }
        }

        if (oldCustomVersionContainer != null)
        {
            foreach (CustomVersion entry in oldCustomVersionContainer)
            {
                if (!existingCustomVersions.Contains(entry.Key)) newCustomVersionContainer.Add(entry.SetIsSerialized(false));
            }
        }

        return newCustomVersionContainer;
    }
}

/// <summary>
/// Reads primitive data types from Unreal Engine assets.
/// </summary>
public class AssetBinaryReader : UnrealBinaryReader
{
    public UAsset Asset;
    public bool LoadUexp = true;

    public AssetBinaryReader(Stream stream, UAsset asset = null) : base(stream)
    {
        Asset = asset;
    }
    
    public AssetBinaryReader(Stream stream, bool inLoadUexp, UAsset asset = null) : base(stream)
    {
        Asset = asset;
        LoadUexp = inLoadUexp;
    }

    public virtual Guid? ReadPropertyGuid()
    {
        if (Asset.HasUnversionedProperties) return null;
        if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_PROPERTY_GUID_IN_PROPERTY_TAG)
        {
            bool hasPropertyGuid = ReadBoolean();
            if (hasPropertyGuid) return new Guid(ReadBytes(16));
        }
        return null;
    }

    public virtual FName ReadFName()
    {
        int nameMapPointer = this.ReadInt32();
        int number = this.ReadInt32();
        return new FName(Asset, nameMapPointer, number);
    }

    public T[] ReadArray<T>(Func<T> readElement)
    {
        int arrayLength = ReadInt32();
        if (arrayLength == 0) return [];
        T[] newData = new T[arrayLength];
        for (int i = 0; i < arrayLength; i++)
        {
            newData[i] = readElement();
        }
        return newData;
    }

    public FObjectThumbnail ReadObjectThumbnail()
    {
        var thumb = new FObjectThumbnail();

        thumb.Width = ReadInt32();
        thumb.Height = ReadInt32();
        var imageBytesCount = ReadInt32();
        thumb.CompressedImageData = imageBytesCount > 0 ? ReadBytes(imageBytesCount) : Array.Empty<byte>();

        return thumb;
    }

    public FLocMetadataObject ReadLocMetadataObject()
    {
        var locMetadataObject = new FLocMetadataObject();

        var valueCount = ReadInt32();
        if (valueCount > 0)
            throw new NotImplementedException("TODO: implement ReadLocMetadataObject");

        return locMetadataObject;
    }

    public string XFERSTRING()
    {
        List<byte> readData = new List<byte>();
        while (true)
        {
            byte newVal = this.ReadByte();
            if (newVal == 0) break;
            readData.Add(newVal);
        }
        return Encoding.UTF8.GetString(readData.ToArray());
    }

    public string XFERUNICODESTRING()
    {
        List<byte> readData = new List<byte>();
        while (true)
        {
            byte newVal1 = this.ReadByte();
            byte newVal2 = this.ReadByte();
            if (newVal1 == 0 && newVal2 == 0) break;
            readData.Add(newVal1);
            readData.Add(newVal2);
        }
        return Encoding.Unicode.GetString(readData.ToArray());
    }

    public void XFERTEXT()
    {

    }

    public FName XFERNAME()
    {
        return this.ReadFName();
    }

    public FName XFER_FUNC_NAME()
    {
        return this.XFERNAME();
    }

    public FPackageIndex XFERPTR()
    {
        return new FPackageIndex(this.ReadInt32());
    }

    public FPackageIndex XFER_FUNC_POINTER()
    {
        return this.XFERPTR();
    }

    public KismetPropertyPointer XFER_PROP_POINTER()
    {
        if (Asset.GetCustomVersion<FReleaseObjectVersion>() >= FReleaseObjectVersion.FFieldPathOwnerSerialization)
        {
            int numEntries = this.ReadInt32();
            FName[] allNames = new FName[numEntries];
            for (int i = 0; i < numEntries; i++)
            {
                allNames[i] = this.ReadFName();
            }
            FPackageIndex owner = this.XFER_OBJECT_POINTER();
            return new KismetPropertyPointer(new FFieldPath(allNames, owner, this.Asset.Exports.Count));
        }
        else
        {
            return new KismetPropertyPointer(this.XFERPTR());
        }
    }

    public FPackageIndex XFER_OBJECT_POINTER()
    {
        return this.XFERPTR();
    }

    public KismetExpression[] ReadExpressionArray(EExprToken endToken)
    {
        List<KismetExpression> newData = new List<KismetExpression>();
        KismetExpression currExpression = null;
        while (currExpression == null || currExpression.Token != endToken)
        {
            if (currExpression != null) newData.Add(currExpression);
            currExpression = ExpressionSerializer.ReadExpression(this);
        }
        return newData.ToArray();
    }
}

```

`UAssetAPI/AssetBinaryWriter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using UAssetAPI.CustomVersions;
using UAssetAPI.Kismet.Bytecode;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI
{
    /// <summary>
    /// Any binary writer used in the parsing of Unreal file types.
    /// </summary>
    public class UnrealBinaryWriter : BinaryWriter
    {
        public UnrealBinaryWriter() : base()
        {

        }

        public UnrealBinaryWriter(Stream stream) : base(stream)
        {

        }

        public UnrealBinaryWriter(Stream stream, Encoding encoding) : base(stream, encoding)
        {

        }

        public UnrealBinaryWriter(Stream stream, Encoding encoding, bool leaveOpen) : base(stream, encoding, leaveOpen)
        {

        }

        protected byte[] ReverseIfBigEndian(byte[] data)
        {
            if (!BitConverter.IsLittleEndian) Array.Reverse(data);
            return data;
        }

        public override void Write(short value)
        {
            this.Write(ReverseIfBigEndian(BitConverter.GetBytes(value)));
        }

        public override void Write(ushort value)
        {
            this.Write(ReverseIfBigEndian(BitConverter.GetBytes(value)));
        }

        public override void Write(int value)
        {
            this.Write(ReverseIfBigEndian(BitConverter.GetBytes(value)));
        }

        public override void Write(uint value)
        {
            this.Write(ReverseIfBigEndian(BitConverter.GetBytes(value)));
        }

        public override void Write(long value)
        {
            this.Write(ReverseIfBigEndian(BitConverter.GetBytes(value)));
        }

        public override void Write(ulong value)
        {
            this.Write(ReverseIfBigEndian(BitConverter.GetBytes(value)));
        }

        public override void Write(float value)
        {
            this.Write(ReverseIfBigEndian(BitConverter.GetBytes(value)));
        }

        public override void Write(double value)
        {
            this.Write(ReverseIfBigEndian(BitConverter.GetBytes(value)));
        }

        public override void Write(string value)
        {
            Write(new FString(value));
        }

        public virtual int Write(FString value)
        {
            switch (value?.Value)
            {
                case null:
                    this.Write((int)0);
                    return sizeof(int);
                default:
                    string nullTerminatedStr = value.Value + "\0";
                    this.Write(value.Encoding is UnicodeEncoding ? -nullTerminatedStr.Length : nullTerminatedStr.Length);
                    byte[] actualStrData = value.Encoding.GetBytes(nullTerminatedStr);
                    this.Write(actualStrData);
                    return actualStrData.Length + 4;
            }
        }

        public int WriteUtf8String(FString value)
        {
            switch (value?.Value)
            {
                case null:
                    this.Write((int)0);
                    return sizeof(int);
                default:
                    this.Write(value.Value.Length);
                    byte[] actualStrData = value.Encoding.GetBytes(value.Value);
                    this.Write(actualStrData);
                    return actualStrData.Length + 4;
            }
        }

        public void WriteCustomVersionContainer(ECustomVersionSerializationFormat format, List<CustomVersion> CustomVersionContainer)
        {
            // TODO: support for enum-based custom versions
            int num = CustomVersionContainer == null ? 0 : CustomVersionContainer.Count;

            switch (format)
            {
                case ECustomVersionSerializationFormat.Enums:
                    throw new NotImplementedException("Custom version serialization format Enums is currently unimplemented");
                case ECustomVersionSerializationFormat.Guids:
                    long numLoc = this.BaseStream.Position;
                    Write((int)0);

                    int realNum = 0;
                    for (int i = 0; i < num; i++)
                    {
                        if (CustomVersionContainer[i].Version <= 0 || !CustomVersionContainer[i].IsSerialized) continue;
                        realNum++;
                        Write(CustomVersionContainer[i].Key.ToByteArray());
                        Write(CustomVersionContainer[i].Version);
                        Write(CustomVersionContainer[i].Name);
                    }

                    long endLoc = this.BaseStream.Position;
                    this.Seek((int)numLoc, SeekOrigin.Begin);
                    Write(realNum);
                    this.Seek((int)endLoc, SeekOrigin.Begin);
                    break;
                case ECustomVersionSerializationFormat.Optimized:
                    numLoc = this.BaseStream.Position;
                    Write((int)0);

                    realNum = 0;
                    for (int i = 0; i < num; i++)
                    {
                        if (CustomVersionContainer[i].Version < 0 || !CustomVersionContainer[i].IsSerialized) continue;
                        realNum++;
                        Write(CustomVersionContainer[i].Key.ToByteArray());
                        Write(CustomVersionContainer[i].Version);
                    }

                    endLoc = this.BaseStream.Position;
                    this.Seek((int)numLoc, SeekOrigin.Begin);
                    Write(realNum);
                    this.Seek((int)endLoc, SeekOrigin.Begin);
                    break;
            }
        }
    }

    /// <summary>
    /// Writes primitive data types from Unreal Engine assets.
    /// </summary>
    public class AssetBinaryWriter : UnrealBinaryWriter
    {
        public UAsset Asset;

        public AssetBinaryWriter(UAsset asset) : base()
        {
            Asset = asset;
        }

        public AssetBinaryWriter(Stream stream, UAsset asset) : base(stream)
        {
            Asset = asset;
        }

        public AssetBinaryWriter(Stream stream, Encoding encoding, UAsset asset) : base(stream, encoding)
        {
            Asset = asset;
        }

        public AssetBinaryWriter(Stream stream, Encoding encoding, bool leaveOpen, UAsset asset) : base(stream, encoding, leaveOpen)
        {
            Asset = asset;
        }

        public virtual void Write(FName name)
        {
            if (name == null) name = new FName(Asset, 0, 0);
            this.Write(name.Index);
            this.Write(name.Number);
        }

        public virtual void WritePropertyGuid(Guid? guid)
        {
            if (Asset.HasUnversionedProperties) return;
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_PROPERTY_GUID_IN_PROPERTY_TAG)
            {
                Write(guid != null);
                if (guid != null) Write(((Guid)guid).ToByteArray());
            }
        }

        public virtual void Write(FObjectThumbnail thumbnail)
        {
            Write(thumbnail.Width);
            Write(thumbnail.Height);
            Write(thumbnail.CompressedImageData.Length);
            if (thumbnail.CompressedImageData.Length > 0)
                Write(thumbnail.CompressedImageData);
        }

        public virtual void Write(FLocMetadataObject metadataObject)
        {
            Write(metadataObject.Values.Count);
            if (metadataObject.Values.Count > 0)
                throw new NotImplementedException("TODO: implement Write(FLocMetadataObject)");
        }

        /*
        !!!!!

        THE FOLLOWING METHODS ARE INTENDED ONLY TO BE USED IN PARSING KISMET BYTECODE; PLEASE DO NOT USE THEM FOR ANY OTHER PURPOSE!

        !!!!!
        */

        /// <summary>This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!</summary>
        public int XFERSTRING(string val)
        {
            long startMetric = this.BaseStream.Position;
            this.Write(Encoding.UTF8.GetBytes(val + "\0"));
            return (int)(this.BaseStream.Position - startMetric);
        }

        /// <summary>This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!</summary>
        public int XFERUNICODESTRING(string val)
        {
            long startMetric = this.BaseStream.Position;
            this.Write(Encoding.Unicode.GetBytes(val + "\0"));
            return (int)(this.BaseStream.Position - startMetric);
        }

        /// <summary>This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!</summary>
        public int XFERNAME(FName val)
        {
            this.Write(val);
            return 12; // FScriptName's iCode offset is 12 bytes, not 8
        }

        /// <summary>This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!</summary>
        public int XFER_FUNC_NAME(FName val)
        {
            return this.XFERNAME(val);
        }

        private static readonly int PointerSize = sizeof(ulong);

        /// <summary>This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!</summary>
        public int XFERPTR(FPackageIndex val)
        {
            this.Write(val?.Index ?? 0);
            return PointerSize; // For the iCode offset, we return the size of a pointer in memory rather than the size of an FPackageIndex on disk
        }

        /// <summary>This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!</summary>
        public int XFER_FUNC_POINTER(FPackageIndex val)
        {
            return this.XFERPTR(val);
        }

        /// <summary>This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!</summary>
        public int XFER_PROP_POINTER(KismetPropertyPointer val)
        {
            if (Asset.GetCustomVersion<FReleaseObjectVersion>() >= FReleaseObjectVersion.FFieldPathOwnerSerialization)
            {
                this.Write(val.New.Path.Length);
                for (int i = 0; i < val.New.Path.Length; i++)
                {
                    this.XFERNAME(val.New.Path[i]);
                }
                this.XFER_OBJECT_POINTER(val.New.ResolvedOwner);
            }
            else
            {
                this.XFERPTR(val.Old);
            }
            return PointerSize;
        }

        /// <summary>This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!</summary>
        public int XFER_OBJECT_POINTER(FPackageIndex val)
        {
            return this.XFERPTR(val);
        }
    }
}

```

`UAssetAPI/CRCGenerator.cs`:

```cs
using System;
using System.Text;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI;

public static class CRCGenerator
{
    public static uint GenerateHash(FString text, bool disableCasePreservingHash, bool version420 = false)
    {
        return GenerateHash(text?.Value, text?.Encoding, disableCasePreservingHash, version420);
    }

    public static uint GenerateHash(string text, bool disableCasePreservingHash, bool version420 = false)
    {
        return GenerateHash(text, Encoding.UTF8, disableCasePreservingHash, version420);
    }

    public static uint GenerateHash(string text, Encoding encoding, bool disableCasePreservingHash, bool version420 = false)
    {
        uint algor1 = Strihash_DEPRECATED(text, encoding, version420);
        uint algor2 = disableCasePreservingHash ? 0 : StrCrc32(text);
        return (algor1 & 0xFFFF) | ((algor2 & 0xFFFF) << 16);
    }

    public static char ToUpper(char input)
    {
        return (char)((uint)input - ((((uint)input - 'a' < 26u) ? 1 : 0) << 5));
    }

    public static char ToUpperVersion420(char input)
    {
        return (char)((input < 256 ? (uint)unchecked((sbyte)input) : (uint)input) - ((((uint)input - 'a' < 26u) ? 1 : 0) << 5));
    }

    public static string ToUpper(string input)
    {
        var res = "";
        foreach (char x in input) res += ToUpper(x); // todo: revise for better perf if needed
        return res;
    }

    public static char ToLower(char input)
    {
        return (char)((uint)input + ((((uint)input - 'A' < 26u) ? 1 : 0) << 5));
    }

    public static string ToLower(string input, bool coalesceToSlash = false)
    {
        var res = "";
        foreach (char x in input)
        {
            char chosenX = x;
            if (coalesceToSlash && (chosenX == '.' || chosenX == ':')) chosenX = '/';
            res += ToLower(chosenX); // todo: revise for better perf if needed
        }
        return res;
    }

    public static FString ToLower(FString input, bool coalesceToSlash = false)
    {
        FString output = (FString)input.Clone();
        output.Value = ToLower(output.Value, coalesceToSlash);
        return output;
    }

    public static uint Strihash_DEPRECATED(string text, Encoding encoding, bool version420 = false)
    {
        uint hash = 0;
        byte[] rawDataForCharacter;
        for (int i = 0; i < text.Length; i++)
        {
            var next = Math.Min(i + 1, text.Length - 1);
            if (char.IsHighSurrogate(text[i]) && next != i && char.IsLowSurrogate(text[next]))
            {
                rawDataForCharacter = encoding.GetBytes( new [] { text[i], text[++i] });
            }
            else
            {
                char B = !version420 ? ToUpper(text[i]) : ToUpperVersion420(text[i]);
                rawDataForCharacter = encoding.GetBytes(new [] { B });
            }

            foreach (byte rawByte in rawDataForCharacter)
            {
                hash = ((hash >> 8) & 0x00FFFFFF) ^ CRCTable_DEPRECATED[(hash ^ rawByte) & 0x000000FF];
            }
        }
        return hash;
    }

    // Accurate as-is for both WIDECHAR and ANSICHAR
    public static uint StrCrc32(string text, uint CRC = 0)
    {
        CRC = ~CRC;
        for (int i = 0; i < text.Length; i++)
        {
            char Ch = text[i];
            CRC = (CRC >> 8) ^ CRCTablesSB8[0, (CRC ^ Ch) & 0xFF];
            Ch >>= 8;
            CRC = (CRC >> 8) ^ CRCTablesSB8[0, (CRC ^ Ch) & 0xFF];
            Ch >>= 8;
            CRC = (CRC >> 8) ^ CRCTablesSB8[0, (CRC ^ Ch) & 0xFF];
            Ch >>= 8;
            CRC = (CRC >> 8) ^ CRCTablesSB8[0, (CRC ^ Ch) & 0xFF];
        }
        return ~CRC;
    }

    public static readonly uint[] CRCTable_DEPRECATED =
    [
        0x00000000, 0x04C11DB7, 0x09823B6E, 0x0D4326D9, 0x130476DC, 0x17C56B6B, 0x1A864DB2, 0x1E475005, 0x2608EDB8, 0x22C9F00F, 0x2F8AD6D6, 0x2B4BCB61, 0x350C9B64, 0x31CD86D3, 0x3C8EA00A, 0x384FBDBD,
        0x4C11DB70, 0x48D0C6C7, 0x4593E01E, 0x4152FDA9, 0x5F15ADAC, 0x5BD4B01B, 0x569796C2, 0x52568B75, 0x6A1936C8, 0x6ED82B7F, 0x639B0DA6, 0x675A1011, 0x791D4014, 0x7DDC5DA3, 0x709F7B7A, 0x745E66CD,
        0x9823B6E0, 0x9CE2AB57, 0x91A18D8E, 0x95609039, 0x8B27C03C, 0x8FE6DD8B, 0x82A5FB52, 0x8664E6E5, 0xBE2B5B58, 0xBAEA46EF, 0xB7A96036, 0xB3687D81, 0xAD2F2D84, 0xA9EE3033, 0xA4AD16EA, 0xA06C0B5D,
        0xD4326D90, 0xD0F37027, 0xDDB056FE, 0xD9714B49, 0xC7361B4C, 0xC3F706FB, 0xCEB42022, 0xCA753D95, 0xF23A8028, 0xF6FB9D9F, 0xFBB8BB46, 0xFF79A6F1, 0xE13EF6F4, 0xE5FFEB43, 0xE8BCCD9A, 0xEC7DD02D,
        0x34867077, 0x30476DC0, 0x3D044B19, 0x39C556AE, 0x278206AB, 0x23431B1C, 0x2E003DC5, 0x2AC12072, 0x128E9DCF, 0x164F8078, 0x1B0CA6A1, 0x1FCDBB16, 0x018AEB13, 0x054BF6A4, 0x0808D07D, 0x0CC9CDCA,
        0x7897AB07, 0x7C56B6B0, 0x71159069, 0x75D48DDE, 0x6B93DDDB, 0x6F52C06C, 0x6211E6B5, 0x66D0FB02, 0x5E9F46BF, 0x5A5E5B08, 0x571D7DD1, 0x53DC6066, 0x4D9B3063, 0x495A2DD4, 0x44190B0D, 0x40D816BA,
        0xACA5C697, 0xA864DB20, 0xA527FDF9, 0xA1E6E04E, 0xBFA1B04B, 0xBB60ADFC, 0xB6238B25, 0xB2E29692, 0x8AAD2B2F, 0x8E6C3698, 0x832F1041, 0x87EE0DF6, 0x99A95DF3, 0x9D684044, 0x902B669D, 0x94EA7B2A,
        0xE0B41DE7, 0xE4750050, 0xE9362689, 0xEDF73B3E, 0xF3B06B3B, 0xF771768C, 0xFA325055, 0xFEF34DE2, 0xC6BCF05F, 0xC27DEDE8, 0xCF3ECB31, 0xCBFFD686, 0xD5B88683, 0xD1799B34, 0xDC3ABDED, 0xD8FBA05A,
        0x690CE0EE, 0x6DCDFD59, 0x608EDB80, 0x644FC637, 0x7A089632, 0x7EC98B85, 0x738AAD5C, 0x774BB0EB, 0x4F040D56, 0x4BC510E1, 0x46863638, 0x42472B8F, 0x5C007B8A, 0x58C1663D, 0x558240E4, 0x51435D53,
        0x251D3B9E, 0x21DC2629, 0x2C9F00F0, 0x285E1D47, 0x36194D42, 0x32D850F5, 0x3F9B762C, 0x3B5A6B9B, 0x0315D626, 0x07D4CB91, 0x0A97ED48, 0x0E56F0FF, 0x1011A0FA, 0x14D0BD4D, 0x19939B94, 0x1D528623,
        0xF12F560E, 0xF5EE4BB9, 0xF8AD6D60, 0xFC6C70D7, 0xE22B20D2, 0xE6EA3D65, 0xEBA91BBC, 0xEF68060B, 0xD727BBB6, 0xD3E6A601, 0xDEA580D8, 0xDA649D6F, 0xC423CD6A, 0xC0E2D0DD, 0xCDA1F604, 0xC960EBB3,
        0xBD3E8D7E, 0xB9FF90C9, 0xB4BCB610, 0xB07DABA7, 0xAE3AFBA2, 0xAAFBE615, 0xA7B8C0CC, 0xA379DD7B, 0x9B3660C6, 0x9FF77D71, 0x92B45BA8, 0x9675461F, 0x8832161A, 0x8CF30BAD, 0x81B02D74, 0x857130C3,
        0x5D8A9099, 0x594B8D2E, 0x5408ABF7, 0x50C9B640, 0x4E8EE645, 0x4A4FFBF2, 0x470CDD2B, 0x43CDC09C, 0x7B827D21, 0x7F436096, 0x7200464F, 0x76C15BF8, 0x68860BFD, 0x6C47164A, 0x61043093, 0x65C52D24,
        0x119B4BE9, 0x155A565E, 0x18197087, 0x1CD86D30, 0x029F3D35, 0x065E2082, 0x0B1D065B, 0x0FDC1BEC, 0x3793A651, 0x3352BBE6, 0x3E119D3F, 0x3AD08088, 0x2497D08D, 0x2056CD3A, 0x2D15EBE3, 0x29D4F654,
        0xC5A92679, 0xC1683BCE, 0xCC2B1D17, 0xC8EA00A0, 0xD6AD50A5, 0xD26C4D12, 0xDF2F6BCB, 0xDBEE767C, 0xE3A1CBC1, 0xE760D676, 0xEA23F0AF, 0xEEE2ED18, 0xF0A5BD1D, 0xF464A0AA, 0xF9278673, 0xFDE69BC4,
        0x89B8FD09, 0x8D79E0BE, 0x803AC667, 0x84FBDBD0, 0x9ABC8BD5, 0x9E7D9662, 0x933EB0BB, 0x97FFAD0C, 0xAFB010B1, 0xAB710D06, 0xA6322BDF, 0xA2F33668, 0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4
    ];

    public static readonly uint[,] CRCTablesSB8 = new uint[8, 256]
    {
        {
            0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
            0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
            0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
            0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
            0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
            0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
            0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
            0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
            0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
            0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
            0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
            0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
            0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
            0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
            0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
            0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
        },
        {
            0x00000000, 0x191b3141, 0x32366282, 0x2b2d53c3, 0x646cc504, 0x7d77f445, 0x565aa786, 0x4f4196c7, 0xc8d98a08, 0xd1c2bb49, 0xfaefe88a, 0xe3f4d9cb, 0xacb54f0c, 0xb5ae7e4d, 0x9e832d8e, 0x87981ccf,
            0x4ac21251, 0x53d92310, 0x78f470d3, 0x61ef4192, 0x2eaed755, 0x37b5e614, 0x1c98b5d7, 0x05838496, 0x821b9859, 0x9b00a918, 0xb02dfadb, 0xa936cb9a, 0xe6775d5d, 0xff6c6c1c, 0xd4413fdf, 0xcd5a0e9e,
            0x958424a2, 0x8c9f15e3, 0xa7b24620, 0xbea97761, 0xf1e8e1a6, 0xe8f3d0e7, 0xc3de8324, 0xdac5b265, 0x5d5daeaa, 0x44469feb, 0x6f6bcc28, 0x7670fd69, 0x39316bae, 0x202a5aef, 0x0b07092c, 0x121c386d,
            0xdf4636f3, 0xc65d07b2, 0xed705471, 0xf46b6530, 0xbb2af3f7, 0xa231c2b6, 0x891c9175, 0x9007a034, 0x179fbcfb, 0x0e848dba, 0x25a9de79, 0x3cb2ef38, 0x73f379ff, 0x6ae848be, 0x41c51b7d, 0x58de2a3c,
            0xf0794f05, 0xe9627e44, 0xc24f2d87, 0xdb541cc6, 0x94158a01, 0x8d0ebb40, 0xa623e883, 0xbf38d9c2, 0x38a0c50d, 0x21bbf44c, 0x0a96a78f, 0x138d96ce, 0x5ccc0009, 0x45d73148, 0x6efa628b, 0x77e153ca,
            0xbabb5d54, 0xa3a06c15, 0x888d3fd6, 0x91960e97, 0xded79850, 0xc7cca911, 0xece1fad2, 0xf5facb93, 0x7262d75c, 0x6b79e61d, 0x4054b5de, 0x594f849f, 0x160e1258, 0x0f152319, 0x243870da, 0x3d23419b,
            0x65fd6ba7, 0x7ce65ae6, 0x57cb0925, 0x4ed03864, 0x0191aea3, 0x188a9fe2, 0x33a7cc21, 0x2abcfd60, 0xad24e1af, 0xb43fd0ee, 0x9f12832d, 0x8609b26c, 0xc94824ab, 0xd05315ea, 0xfb7e4629, 0xe2657768,
            0x2f3f79f6, 0x362448b7, 0x1d091b74, 0x04122a35, 0x4b53bcf2, 0x52488db3, 0x7965de70, 0x607eef31, 0xe7e6f3fe, 0xfefdc2bf, 0xd5d0917c, 0xcccba03d, 0x838a36fa, 0x9a9107bb, 0xb1bc5478, 0xa8a76539,
            0x3b83984b, 0x2298a90a, 0x09b5fac9, 0x10aecb88, 0x5fef5d4f, 0x46f46c0e, 0x6dd93fcd, 0x74c20e8c, 0xf35a1243, 0xea412302, 0xc16c70c1, 0xd8774180, 0x9736d747, 0x8e2de606, 0xa500b5c5, 0xbc1b8484,
            0x71418a1a, 0x685abb5b, 0x4377e898, 0x5a6cd9d9, 0x152d4f1e, 0x0c367e5f, 0x271b2d9c, 0x3e001cdd, 0xb9980012, 0xa0833153, 0x8bae6290, 0x92b553d1, 0xddf4c516, 0xc4eff457, 0xefc2a794, 0xf6d996d5,
            0xae07bce9, 0xb71c8da8, 0x9c31de6b, 0x852aef2a, 0xca6b79ed, 0xd37048ac, 0xf85d1b6f, 0xe1462a2e, 0x66de36e1, 0x7fc507a0, 0x54e85463, 0x4df36522, 0x02b2f3e5, 0x1ba9c2a4, 0x30849167, 0x299fa026,
            0xe4c5aeb8, 0xfdde9ff9, 0xd6f3cc3a, 0xcfe8fd7b, 0x80a96bbc, 0x99b25afd, 0xb29f093e, 0xab84387f, 0x2c1c24b0, 0x350715f1, 0x1e2a4632, 0x07317773, 0x4870e1b4, 0x516bd0f5, 0x7a468336, 0x635db277,
            0xcbfad74e, 0xd2e1e60f, 0xf9ccb5cc, 0xe0d7848d, 0xaf96124a, 0xb68d230b, 0x9da070c8, 0x84bb4189, 0x03235d46, 0x1a386c07, 0x31153fc4, 0x280e0e85, 0x674f9842, 0x7e54a903, 0x5579fac0, 0x4c62cb81,
            0x8138c51f, 0x9823f45e, 0xb30ea79d, 0xaa1596dc, 0xe554001b, 0xfc4f315a, 0xd7626299, 0xce7953d8, 0x49e14f17, 0x50fa7e56, 0x7bd72d95, 0x62cc1cd4, 0x2d8d8a13, 0x3496bb52, 0x1fbbe891, 0x06a0d9d0,
            0x5e7ef3ec, 0x4765c2ad, 0x6c48916e, 0x7553a02f, 0x3a1236e8, 0x230907a9, 0x0824546a, 0x113f652b, 0x96a779e4, 0x8fbc48a5, 0xa4911b66, 0xbd8a2a27, 0xf2cbbce0, 0xebd08da1, 0xc0fdde62, 0xd9e6ef23,
            0x14bce1bd, 0x0da7d0fc, 0x268a833f, 0x3f91b27e, 0x70d024b9, 0x69cb15f8, 0x42e6463b, 0x5bfd777a, 0xdc656bb5, 0xc57e5af4, 0xee530937, 0xf7483876, 0xb809aeb1, 0xa1129ff0, 0x8a3fcc33, 0x9324fd72
        },
        {
            0x00000000, 0x01c26a37, 0x0384d46e, 0x0246be59, 0x0709a8dc, 0x06cbc2eb, 0x048d7cb2, 0x054f1685, 0x0e1351b8, 0x0fd13b8f, 0x0d9785d6, 0x0c55efe1, 0x091af964, 0x08d89353, 0x0a9e2d0a, 0x0b5c473d,
            0x1c26a370, 0x1de4c947, 0x1fa2771e, 0x1e601d29, 0x1b2f0bac, 0x1aed619b, 0x18abdfc2, 0x1969b5f5, 0x1235f2c8, 0x13f798ff, 0x11b126a6, 0x10734c91, 0x153c5a14, 0x14fe3023, 0x16b88e7a, 0x177ae44d,
            0x384d46e0, 0x398f2cd7, 0x3bc9928e, 0x3a0bf8b9, 0x3f44ee3c, 0x3e86840b, 0x3cc03a52, 0x3d025065, 0x365e1758, 0x379c7d6f, 0x35dac336, 0x3418a901, 0x3157bf84, 0x3095d5b3, 0x32d36bea, 0x331101dd,
            0x246be590, 0x25a98fa7, 0x27ef31fe, 0x262d5bc9, 0x23624d4c, 0x22a0277b, 0x20e69922, 0x2124f315, 0x2a78b428, 0x2bbade1f, 0x29fc6046, 0x283e0a71, 0x2d711cf4, 0x2cb376c3, 0x2ef5c89a, 0x2f37a2ad,
            0x709a8dc0, 0x7158e7f7, 0x731e59ae, 0x72dc3399, 0x7793251c, 0x76514f2b, 0x7417f172, 0x75d59b45, 0x7e89dc78, 0x7f4bb64f, 0x7d0d0816, 0x7ccf6221, 0x798074a4, 0x78421e93, 0x7a04a0ca, 0x7bc6cafd,
            0x6cbc2eb0, 0x6d7e4487, 0x6f38fade, 0x6efa90e9, 0x6bb5866c, 0x6a77ec5b, 0x68315202, 0x69f33835, 0x62af7f08, 0x636d153f, 0x612bab66, 0x60e9c151, 0x65a6d7d4, 0x6464bde3, 0x662203ba, 0x67e0698d,
            0x48d7cb20, 0x4915a117, 0x4b531f4e, 0x4a917579, 0x4fde63fc, 0x4e1c09cb, 0x4c5ab792, 0x4d98dda5, 0x46c49a98, 0x4706f0af, 0x45404ef6, 0x448224c1, 0x41cd3244, 0x400f5873, 0x4249e62a, 0x438b8c1d,
            0x54f16850, 0x55330267, 0x5775bc3e, 0x56b7d609, 0x53f8c08c, 0x523aaabb, 0x507c14e2, 0x51be7ed5, 0x5ae239e8, 0x5b2053df, 0x5966ed86, 0x58a487b1, 0x5deb9134, 0x5c29fb03, 0x5e6f455a, 0x5fad2f6d,
            0xe1351b80, 0xe0f771b7, 0xe2b1cfee, 0xe373a5d9, 0xe63cb35c, 0xe7fed96b, 0xe5b86732, 0xe47a0d05, 0xef264a38, 0xeee4200f, 0xeca29e56, 0xed60f461, 0xe82fe2e4, 0xe9ed88d3, 0xebab368a, 0xea695cbd,
            0xfd13b8f0, 0xfcd1d2c7, 0xfe976c9e, 0xff5506a9, 0xfa1a102c, 0xfbd87a1b, 0xf99ec442, 0xf85cae75, 0xf300e948, 0xf2c2837f, 0xf0843d26, 0xf1465711, 0xf4094194, 0xf5cb2ba3, 0xf78d95fa, 0xf64fffcd,
            0xd9785d60, 0xd8ba3757, 0xdafc890e, 0xdb3ee339, 0xde71f5bc, 0xdfb39f8b, 0xddf521d2, 0xdc374be5, 0xd76b0cd8, 0xd6a966ef, 0xd4efd8b6, 0xd52db281, 0xd062a404, 0xd1a0ce33, 0xd3e6706a, 0xd2241a5d,
            0xc55efe10, 0xc49c9427, 0xc6da2a7e, 0xc7184049, 0xc25756cc, 0xc3953cfb, 0xc1d382a2, 0xc011e895, 0xcb4dafa8, 0xca8fc59f, 0xc8c97bc6, 0xc90b11f1, 0xcc440774, 0xcd866d43, 0xcfc0d31a, 0xce02b92d,
            0x91af9640, 0x906dfc77, 0x922b422e, 0x93e92819, 0x96a63e9c, 0x976454ab, 0x9522eaf2, 0x94e080c5, 0x9fbcc7f8, 0x9e7eadcf, 0x9c381396, 0x9dfa79a1, 0x98b56f24, 0x99770513, 0x9b31bb4a, 0x9af3d17d,
            0x8d893530, 0x8c4b5f07, 0x8e0de15e, 0x8fcf8b69, 0x8a809dec, 0x8b42f7db, 0x89044982, 0x88c623b5, 0x839a6488, 0x82580ebf, 0x801eb0e6, 0x81dcdad1, 0x8493cc54, 0x8551a663, 0x8717183a, 0x86d5720d,
            0xa9e2d0a0, 0xa820ba97, 0xaa6604ce, 0xaba46ef9, 0xaeeb787c, 0xaf29124b, 0xad6fac12, 0xacadc625, 0xa7f18118, 0xa633eb2f, 0xa4755576, 0xa5b73f41, 0xa0f829c4, 0xa13a43f3, 0xa37cfdaa, 0xa2be979d,
            0xb5c473d0, 0xb40619e7, 0xb640a7be, 0xb782cd89, 0xb2cddb0c, 0xb30fb13b, 0xb1490f62, 0xb08b6555, 0xbbd72268, 0xba15485f, 0xb853f606, 0xb9919c31, 0xbcde8ab4, 0xbd1ce083, 0xbf5a5eda, 0xbe9834ed
        },
        {
            0x00000000, 0xb8bc6765, 0xaa09c88b, 0x12b5afee, 0x8f629757, 0x37def032, 0x256b5fdc, 0x9dd738b9, 0xc5b428ef, 0x7d084f8a, 0x6fbde064, 0xd7018701, 0x4ad6bfb8, 0xf26ad8dd, 0xe0df7733, 0x58631056,
            0x5019579f, 0xe8a530fa, 0xfa109f14, 0x42acf871, 0xdf7bc0c8, 0x67c7a7ad, 0x75720843, 0xcdce6f26, 0x95ad7f70, 0x2d111815, 0x3fa4b7fb, 0x8718d09e, 0x1acfe827, 0xa2738f42, 0xb0c620ac, 0x087a47c9,
            0xa032af3e, 0x188ec85b, 0x0a3b67b5, 0xb28700d0, 0x2f503869, 0x97ec5f0c, 0x8559f0e2, 0x3de59787, 0x658687d1, 0xdd3ae0b4, 0xcf8f4f5a, 0x7733283f, 0xeae41086, 0x525877e3, 0x40edd80d, 0xf851bf68,
            0xf02bf8a1, 0x48979fc4, 0x5a22302a, 0xe29e574f, 0x7f496ff6, 0xc7f50893, 0xd540a77d, 0x6dfcc018, 0x359fd04e, 0x8d23b72b, 0x9f9618c5, 0x272a7fa0, 0xbafd4719, 0x0241207c, 0x10f48f92, 0xa848e8f7,
            0x9b14583d, 0x23a83f58, 0x311d90b6, 0x89a1f7d3, 0x1476cf6a, 0xaccaa80f, 0xbe7f07e1, 0x06c36084, 0x5ea070d2, 0xe61c17b7, 0xf4a9b859, 0x4c15df3c, 0xd1c2e785, 0x697e80e0, 0x7bcb2f0e, 0xc377486b,
            0xcb0d0fa2, 0x73b168c7, 0x6104c729, 0xd9b8a04c, 0x446f98f5, 0xfcd3ff90, 0xee66507e, 0x56da371b, 0x0eb9274d, 0xb6054028, 0xa4b0efc6, 0x1c0c88a3, 0x81dbb01a, 0x3967d77f, 0x2bd27891, 0x936e1ff4,
            0x3b26f703, 0x839a9066, 0x912f3f88, 0x299358ed, 0xb4446054, 0x0cf80731, 0x1e4da8df, 0xa6f1cfba, 0xfe92dfec, 0x462eb889, 0x549b1767, 0xec277002, 0x71f048bb, 0xc94c2fde, 0xdbf98030, 0x6345e755,
            0x6b3fa09c, 0xd383c7f9, 0xc1366817, 0x798a0f72, 0xe45d37cb, 0x5ce150ae, 0x4e54ff40, 0xf6e89825, 0xae8b8873, 0x1637ef16, 0x048240f8, 0xbc3e279d, 0x21e91f24, 0x99557841, 0x8be0d7af, 0x335cb0ca,
            0xed59b63b, 0x55e5d15e, 0x47507eb0, 0xffec19d5, 0x623b216c, 0xda874609, 0xc832e9e7, 0x708e8e82, 0x28ed9ed4, 0x9051f9b1, 0x82e4565f, 0x3a58313a, 0xa78f0983, 0x1f336ee6, 0x0d86c108, 0xb53aa66d,
            0xbd40e1a4, 0x05fc86c1, 0x1749292f, 0xaff54e4a, 0x322276f3, 0x8a9e1196, 0x982bbe78, 0x2097d91d, 0x78f4c94b, 0xc048ae2e, 0xd2fd01c0, 0x6a4166a5, 0xf7965e1c, 0x4f2a3979, 0x5d9f9697, 0xe523f1f2,
            0x4d6b1905, 0xf5d77e60, 0xe762d18e, 0x5fdeb6eb, 0xc2098e52, 0x7ab5e937, 0x680046d9, 0xd0bc21bc, 0x88df31ea, 0x3063568f, 0x22d6f961, 0x9a6a9e04, 0x07bda6bd, 0xbf01c1d8, 0xadb46e36, 0x15080953,
            0x1d724e9a, 0xa5ce29ff, 0xb77b8611, 0x0fc7e174, 0x9210d9cd, 0x2aacbea8, 0x38191146, 0x80a57623, 0xd8c66675, 0x607a0110, 0x72cfaefe, 0xca73c99b, 0x57a4f122, 0xef189647, 0xfdad39a9, 0x45115ecc,
            0x764dee06, 0xcef18963, 0xdc44268d, 0x64f841e8, 0xf92f7951, 0x41931e34, 0x5326b1da, 0xeb9ad6bf, 0xb3f9c6e9, 0x0b45a18c, 0x19f00e62, 0xa14c6907, 0x3c9b51be, 0x842736db, 0x96929935, 0x2e2efe50,
            0x2654b999, 0x9ee8defc, 0x8c5d7112, 0x34e11677, 0xa9362ece, 0x118a49ab, 0x033fe645, 0xbb838120, 0xe3e09176, 0x5b5cf613, 0x49e959fd, 0xf1553e98, 0x6c820621, 0xd43e6144, 0xc68bceaa, 0x7e37a9cf,
            0xd67f4138, 0x6ec3265d, 0x7c7689b3, 0xc4caeed6, 0x591dd66f, 0xe1a1b10a, 0xf3141ee4, 0x4ba87981, 0x13cb69d7, 0xab770eb2, 0xb9c2a15c, 0x017ec639, 0x9ca9fe80, 0x241599e5, 0x36a0360b, 0x8e1c516e,
            0x866616a7, 0x3eda71c2, 0x2c6fde2c, 0x94d3b949, 0x090481f0, 0xb1b8e695, 0xa30d497b, 0x1bb12e1e, 0x43d23e48, 0xfb6e592d, 0xe9dbf6c3, 0x516791a6, 0xccb0a91f, 0x740cce7a, 0x66b96194, 0xde0506f1
        },
        {
            0x00000000, 0x3d6029b0, 0x7ac05360, 0x47a07ad0, 0xf580a6c0, 0xc8e08f70, 0x8f40f5a0, 0xb220dc10, 0x30704bc1, 0x0d106271, 0x4ab018a1, 0x77d03111, 0xc5f0ed01, 0xf890c4b1, 0xbf30be61, 0x825097d1,
            0x60e09782, 0x5d80be32, 0x1a20c4e2, 0x2740ed52, 0x95603142, 0xa80018f2, 0xefa06222, 0xd2c04b92, 0x5090dc43, 0x6df0f5f3, 0x2a508f23, 0x1730a693, 0xa5107a83, 0x98705333, 0xdfd029e3, 0xe2b00053,
            0xc1c12f04, 0xfca106b4, 0xbb017c64, 0x866155d4, 0x344189c4, 0x0921a074, 0x4e81daa4, 0x73e1f314, 0xf1b164c5, 0xccd14d75, 0x8b7137a5, 0xb6111e15, 0x0431c205, 0x3951ebb5, 0x7ef19165, 0x4391b8d5,
            0xa121b886, 0x9c419136, 0xdbe1ebe6, 0xe681c256, 0x54a11e46, 0x69c137f6, 0x2e614d26, 0x13016496, 0x9151f347, 0xac31daf7, 0xeb91a027, 0xd6f18997, 0x64d15587, 0x59b17c37, 0x1e1106e7, 0x23712f57,
            0x58f35849, 0x659371f9, 0x22330b29, 0x1f532299, 0xad73fe89, 0x9013d739, 0xd7b3ade9, 0xead38459, 0x68831388, 0x55e33a38, 0x124340e8, 0x2f236958, 0x9d03b548, 0xa0639cf8, 0xe7c3e628, 0xdaa3cf98,
            0x3813cfcb, 0x0573e67b, 0x42d39cab, 0x7fb3b51b, 0xcd93690b, 0xf0f340bb, 0xb7533a6b, 0x8a3313db, 0x0863840a, 0x3503adba, 0x72a3d76a, 0x4fc3feda, 0xfde322ca, 0xc0830b7a, 0x872371aa, 0xba43581a,
            0x9932774d, 0xa4525efd, 0xe3f2242d, 0xde920d9d, 0x6cb2d18d, 0x51d2f83d, 0x167282ed, 0x2b12ab5d, 0xa9423c8c, 0x9422153c, 0xd3826fec, 0xeee2465c, 0x5cc29a4c, 0x61a2b3fc, 0x2602c92c, 0x1b62e09c,
            0xf9d2e0cf, 0xc4b2c97f, 0x8312b3af, 0xbe729a1f, 0x0c52460f, 0x31326fbf, 0x7692156f, 0x4bf23cdf, 0xc9a2ab0e, 0xf4c282be, 0xb362f86e, 0x8e02d1de, 0x3c220dce, 0x0142247e, 0x46e25eae, 0x7b82771e,
            0xb1e6b092, 0x8c869922, 0xcb26e3f2, 0xf646ca42, 0x44661652, 0x79063fe2, 0x3ea64532, 0x03c66c82, 0x8196fb53, 0xbcf6d2e3, 0xfb56a833, 0xc6368183, 0x74165d93, 0x49767423, 0x0ed60ef3, 0x33b62743,
            0xd1062710, 0xec660ea0, 0xabc67470, 0x96a65dc0, 0x248681d0, 0x19e6a860, 0x5e46d2b0, 0x6326fb00, 0xe1766cd1, 0xdc164561, 0x9bb63fb1, 0xa6d61601, 0x14f6ca11, 0x2996e3a1, 0x6e369971, 0x5356b0c1,
            0x70279f96, 0x4d47b626, 0x0ae7ccf6, 0x3787e546, 0x85a73956, 0xb8c710e6, 0xff676a36, 0xc2074386, 0x4057d457, 0x7d37fde7, 0x3a978737, 0x07f7ae87, 0xb5d77297, 0x88b75b27, 0xcf1721f7, 0xf2770847,
            0x10c70814, 0x2da721a4, 0x6a075b74, 0x576772c4, 0xe547aed4, 0xd8278764, 0x9f87fdb4, 0xa2e7d404, 0x20b743d5, 0x1dd76a65, 0x5a7710b5, 0x67173905, 0xd537e515, 0xe857cca5, 0xaff7b675, 0x92979fc5,
            0xe915e8db, 0xd475c16b, 0x93d5bbbb, 0xaeb5920b, 0x1c954e1b, 0x21f567ab, 0x66551d7b, 0x5b3534cb, 0xd965a31a, 0xe4058aaa, 0xa3a5f07a, 0x9ec5d9ca, 0x2ce505da, 0x11852c6a, 0x562556ba, 0x6b457f0a,
            0x89f57f59, 0xb49556e9, 0xf3352c39, 0xce550589, 0x7c75d999, 0x4115f029, 0x06b58af9, 0x3bd5a349, 0xb9853498, 0x84e51d28, 0xc34567f8, 0xfe254e48, 0x4c059258, 0x7165bbe8, 0x36c5c138, 0x0ba5e888,
            0x28d4c7df, 0x15b4ee6f, 0x521494bf, 0x6f74bd0f, 0xdd54611f, 0xe03448af, 0xa794327f, 0x9af41bcf, 0x18a48c1e, 0x25c4a5ae, 0x6264df7e, 0x5f04f6ce, 0xed242ade, 0xd044036e, 0x97e479be, 0xaa84500e,
            0x4834505d, 0x755479ed, 0x32f4033d, 0x0f942a8d, 0xbdb4f69d, 0x80d4df2d, 0xc774a5fd, 0xfa148c4d, 0x78441b9c, 0x4524322c, 0x028448fc, 0x3fe4614c, 0x8dc4bd5c, 0xb0a494ec, 0xf704ee3c, 0xca64c78c
        },
        {
            0x00000000, 0xcb5cd3a5, 0x4dc8a10b, 0x869472ae, 0x9b914216, 0x50cd91b3, 0xd659e31d, 0x1d0530b8, 0xec53826d, 0x270f51c8, 0xa19b2366, 0x6ac7f0c3, 0x77c2c07b, 0xbc9e13de, 0x3a0a6170, 0xf156b2d5,
            0x03d6029b, 0xc88ad13e, 0x4e1ea390, 0x85427035, 0x9847408d, 0x531b9328, 0xd58fe186, 0x1ed33223, 0xef8580f6, 0x24d95353, 0xa24d21fd, 0x6911f258, 0x7414c2e0, 0xbf481145, 0x39dc63eb, 0xf280b04e,
            0x07ac0536, 0xccf0d693, 0x4a64a43d, 0x81387798, 0x9c3d4720, 0x57619485, 0xd1f5e62b, 0x1aa9358e, 0xebff875b, 0x20a354fe, 0xa6372650, 0x6d6bf5f5, 0x706ec54d, 0xbb3216e8, 0x3da66446, 0xf6fab7e3,
            0x047a07ad, 0xcf26d408, 0x49b2a6a6, 0x82ee7503, 0x9feb45bb, 0x54b7961e, 0xd223e4b0, 0x197f3715, 0xe82985c0, 0x23755665, 0xa5e124cb, 0x6ebdf76e, 0x73b8c7d6, 0xb8e41473, 0x3e7066dd, 0xf52cb578,
            0x0f580a6c, 0xc404d9c9, 0x4290ab67, 0x89cc78c2, 0x94c9487a, 0x5f959bdf, 0xd901e971, 0x125d3ad4, 0xe30b8801, 0x28575ba4, 0xaec3290a, 0x659ffaaf, 0x789aca17, 0xb3c619b2, 0x35526b1c, 0xfe0eb8b9,
            0x0c8e08f7, 0xc7d2db52, 0x4146a9fc, 0x8a1a7a59, 0x971f4ae1, 0x5c439944, 0xdad7ebea, 0x118b384f, 0xe0dd8a9a, 0x2b81593f, 0xad152b91, 0x6649f834, 0x7b4cc88c, 0xb0101b29, 0x36846987, 0xfdd8ba22,
            0x08f40f5a, 0xc3a8dcff, 0x453cae51, 0x8e607df4, 0x93654d4c, 0x58399ee9, 0xdeadec47, 0x15f13fe2, 0xe4a78d37, 0x2ffb5e92, 0xa96f2c3c, 0x6233ff99, 0x7f36cf21, 0xb46a1c84, 0x32fe6e2a, 0xf9a2bd8f,
            0x0b220dc1, 0xc07ede64, 0x46eaacca, 0x8db67f6f, 0x90b34fd7, 0x5bef9c72, 0xdd7beedc, 0x16273d79, 0xe7718fac, 0x2c2d5c09, 0xaab92ea7, 0x61e5fd02, 0x7ce0cdba, 0xb7bc1e1f, 0x31286cb1, 0xfa74bf14,
            0x1eb014d8, 0xd5ecc77d, 0x5378b5d3, 0x98246676, 0x852156ce, 0x4e7d856b, 0xc8e9f7c5, 0x03b52460, 0xf2e396b5, 0x39bf4510, 0xbf2b37be, 0x7477e41b, 0x6972d4a3, 0xa22e0706, 0x24ba75a8, 0xefe6a60d,
            0x1d661643, 0xd63ac5e6, 0x50aeb748, 0x9bf264ed, 0x86f75455, 0x4dab87f0, 0xcb3ff55e, 0x006326fb, 0xf135942e, 0x3a69478b, 0xbcfd3525, 0x77a1e680, 0x6aa4d638, 0xa1f8059d, 0x276c7733, 0xec30a496,
            0x191c11ee, 0xd240c24b, 0x54d4b0e5, 0x9f886340, 0x828d53f8, 0x49d1805d, 0xcf45f2f3, 0x04192156, 0xf54f9383, 0x3e134026, 0xb8873288, 0x73dbe12d, 0x6eded195, 0xa5820230, 0x2316709e, 0xe84aa33b,
            0x1aca1375, 0xd196c0d0, 0x5702b27e, 0x9c5e61db, 0x815b5163, 0x4a0782c6, 0xcc93f068, 0x07cf23cd, 0xf6999118, 0x3dc542bd, 0xbb513013, 0x700de3b6, 0x6d08d30e, 0xa65400ab, 0x20c07205, 0xeb9ca1a0,
            0x11e81eb4, 0xdab4cd11, 0x5c20bfbf, 0x977c6c1a, 0x8a795ca2, 0x41258f07, 0xc7b1fda9, 0x0ced2e0c, 0xfdbb9cd9, 0x36e74f7c, 0xb0733dd2, 0x7b2fee77, 0x662adecf, 0xad760d6a, 0x2be27fc4, 0xe0beac61,
            0x123e1c2f, 0xd962cf8a, 0x5ff6bd24, 0x94aa6e81, 0x89af5e39, 0x42f38d9c, 0xc467ff32, 0x0f3b2c97, 0xfe6d9e42, 0x35314de7, 0xb3a53f49, 0x78f9ecec, 0x65fcdc54, 0xaea00ff1, 0x28347d5f, 0xe368aefa,
            0x16441b82, 0xdd18c827, 0x5b8cba89, 0x90d0692c, 0x8dd55994, 0x46898a31, 0xc01df89f, 0x0b412b3a, 0xfa1799ef, 0x314b4a4a, 0xb7df38e4, 0x7c83eb41, 0x6186dbf9, 0xaada085c, 0x2c4e7af2, 0xe712a957,
            0x15921919, 0xdececabc, 0x585ab812, 0x93066bb7, 0x8e035b0f, 0x455f88aa, 0xc3cbfa04, 0x089729a1, 0xf9c19b74, 0x329d48d1, 0xb4093a7f, 0x7f55e9da, 0x6250d962, 0xa90c0ac7, 0x2f987869, 0xe4c4abcc
        },
        {
            0x00000000, 0xa6770bb4, 0x979f1129, 0x31e81a9d, 0xf44f2413, 0x52382fa7, 0x63d0353a, 0xc5a73e8e, 0x33ef4e67, 0x959845d3, 0xa4705f4e, 0x020754fa, 0xc7a06a74, 0x61d761c0, 0x503f7b5d, 0xf64870e9,
            0x67de9cce, 0xc1a9977a, 0xf0418de7, 0x56368653, 0x9391b8dd, 0x35e6b369, 0x040ea9f4, 0xa279a240, 0x5431d2a9, 0xf246d91d, 0xc3aec380, 0x65d9c834, 0xa07ef6ba, 0x0609fd0e, 0x37e1e793, 0x9196ec27,
            0xcfbd399c, 0x69ca3228, 0x582228b5, 0xfe552301, 0x3bf21d8f, 0x9d85163b, 0xac6d0ca6, 0x0a1a0712, 0xfc5277fb, 0x5a257c4f, 0x6bcd66d2, 0xcdba6d66, 0x081d53e8, 0xae6a585c, 0x9f8242c1, 0x39f54975,
            0xa863a552, 0x0e14aee6, 0x3ffcb47b, 0x998bbfcf, 0x5c2c8141, 0xfa5b8af5, 0xcbb39068, 0x6dc49bdc, 0x9b8ceb35, 0x3dfbe081, 0x0c13fa1c, 0xaa64f1a8, 0x6fc3cf26, 0xc9b4c492, 0xf85cde0f, 0x5e2bd5bb,
            0x440b7579, 0xe27c7ecd, 0xd3946450, 0x75e36fe4, 0xb044516a, 0x16335ade, 0x27db4043, 0x81ac4bf7, 0x77e43b1e, 0xd19330aa, 0xe07b2a37, 0x460c2183, 0x83ab1f0d, 0x25dc14b9, 0x14340e24, 0xb2430590,
            0x23d5e9b7, 0x85a2e203, 0xb44af89e, 0x123df32a, 0xd79acda4, 0x71edc610, 0x4005dc8d, 0xe672d739, 0x103aa7d0, 0xb64dac64, 0x87a5b6f9, 0x21d2bd4d, 0xe47583c3, 0x42028877, 0x73ea92ea, 0xd59d995e,
            0x8bb64ce5, 0x2dc14751, 0x1c295dcc, 0xba5e5678, 0x7ff968f6, 0xd98e6342, 0xe86679df, 0x4e11726b, 0xb8590282, 0x1e2e0936, 0x2fc613ab, 0x89b1181f, 0x4c162691, 0xea612d25, 0xdb8937b8, 0x7dfe3c0c,
            0xec68d02b, 0x4a1fdb9f, 0x7bf7c102, 0xdd80cab6, 0x1827f438, 0xbe50ff8c, 0x8fb8e511, 0x29cfeea5, 0xdf879e4c, 0x79f095f8, 0x48188f65, 0xee6f84d1, 0x2bc8ba5f, 0x8dbfb1eb, 0xbc57ab76, 0x1a20a0c2,
            0x8816eaf2, 0x2e61e146, 0x1f89fbdb, 0xb9fef06f, 0x7c59cee1, 0xda2ec555, 0xebc6dfc8, 0x4db1d47c, 0xbbf9a495, 0x1d8eaf21, 0x2c66b5bc, 0x8a11be08, 0x4fb68086, 0xe9c18b32, 0xd82991af, 0x7e5e9a1b,
            0xefc8763c, 0x49bf7d88, 0x78576715, 0xde206ca1, 0x1b87522f, 0xbdf0599b, 0x8c184306, 0x2a6f48b2, 0xdc27385b, 0x7a5033ef, 0x4bb82972, 0xedcf22c6, 0x28681c48, 0x8e1f17fc, 0xbff70d61, 0x198006d5,
            0x47abd36e, 0xe1dcd8da, 0xd034c247, 0x7643c9f3, 0xb3e4f77d, 0x1593fcc9, 0x247be654, 0x820cede0, 0x74449d09, 0xd23396bd, 0xe3db8c20, 0x45ac8794, 0x800bb91a, 0x267cb2ae, 0x1794a833, 0xb1e3a387,
            0x20754fa0, 0x86024414, 0xb7ea5e89, 0x119d553d, 0xd43a6bb3, 0x724d6007, 0x43a57a9a, 0xe5d2712e, 0x139a01c7, 0xb5ed0a73, 0x840510ee, 0x22721b5a, 0xe7d525d4, 0x41a22e60, 0x704a34fd, 0xd63d3f49,
            0xcc1d9f8b, 0x6a6a943f, 0x5b828ea2, 0xfdf58516, 0x3852bb98, 0x9e25b02c, 0xafcdaab1, 0x09baa105, 0xfff2d1ec, 0x5985da58, 0x686dc0c5, 0xce1acb71, 0x0bbdf5ff, 0xadcafe4b, 0x9c22e4d6, 0x3a55ef62,
            0xabc30345, 0x0db408f1, 0x3c5c126c, 0x9a2b19d8, 0x5f8c2756, 0xf9fb2ce2, 0xc813367f, 0x6e643dcb, 0x982c4d22, 0x3e5b4696, 0x0fb35c0b, 0xa9c457bf, 0x6c636931, 0xca146285, 0xfbfc7818, 0x5d8b73ac,
            0x03a0a617, 0xa5d7ada3, 0x943fb73e, 0x3248bc8a, 0xf7ef8204, 0x519889b0, 0x6070932d, 0xc6079899, 0x304fe870, 0x9638e3c4, 0xa7d0f959, 0x01a7f2ed, 0xc400cc63, 0x6277c7d7, 0x539fdd4a, 0xf5e8d6fe,
            0x647e3ad9, 0xc209316d, 0xf3e12bf0, 0x55962044, 0x90311eca, 0x3646157e, 0x07ae0fe3, 0xa1d90457, 0x579174be, 0xf1e67f0a, 0xc00e6597, 0x66796e23, 0xa3de50ad, 0x05a95b19, 0x34414184, 0x92364a30
        },
        {
            0x00000000, 0xccaa009e, 0x4225077d, 0x8e8f07e3, 0x844a0efa, 0x48e00e64, 0xc66f0987, 0x0ac50919, 0xd3e51bb5, 0x1f4f1b2b, 0x91c01cc8, 0x5d6a1c56, 0x57af154f, 0x9b0515d1, 0x158a1232, 0xd92012ac,
            0x7cbb312b, 0xb01131b5, 0x3e9e3656, 0xf23436c8, 0xf8f13fd1, 0x345b3f4f, 0xbad438ac, 0x767e3832, 0xaf5e2a9e, 0x63f42a00, 0xed7b2de3, 0x21d12d7d, 0x2b142464, 0xe7be24fa, 0x69312319, 0xa59b2387,
            0xf9766256, 0x35dc62c8, 0xbb53652b, 0x77f965b5, 0x7d3c6cac, 0xb1966c32, 0x3f196bd1, 0xf3b36b4f, 0x2a9379e3, 0xe639797d, 0x68b67e9e, 0xa41c7e00, 0xaed97719, 0x62737787, 0xecfc7064, 0x205670fa,
            0x85cd537d, 0x496753e3, 0xc7e85400, 0x0b42549e, 0x01875d87, 0xcd2d5d19, 0x43a25afa, 0x8f085a64, 0x562848c8, 0x9a824856, 0x140d4fb5, 0xd8a74f2b, 0xd2624632, 0x1ec846ac, 0x9047414f, 0x5ced41d1,
            0x299dc2ed, 0xe537c273, 0x6bb8c590, 0xa712c50e, 0xadd7cc17, 0x617dcc89, 0xeff2cb6a, 0x2358cbf4, 0xfa78d958, 0x36d2d9c6, 0xb85dde25, 0x74f7debb, 0x7e32d7a2, 0xb298d73c, 0x3c17d0df, 0xf0bdd041,
            0x5526f3c6, 0x998cf358, 0x1703f4bb, 0xdba9f425, 0xd16cfd3c, 0x1dc6fda2, 0x9349fa41, 0x5fe3fadf, 0x86c3e873, 0x4a69e8ed, 0xc4e6ef0e, 0x084cef90, 0x0289e689, 0xce23e617, 0x40ace1f4, 0x8c06e16a,
            0xd0eba0bb, 0x1c41a025, 0x92cea7c6, 0x5e64a758, 0x54a1ae41, 0x980baedf, 0x1684a93c, 0xda2ea9a2, 0x030ebb0e, 0xcfa4bb90, 0x412bbc73, 0x8d81bced, 0x8744b5f4, 0x4beeb56a, 0xc561b289, 0x09cbb217,
            0xac509190, 0x60fa910e, 0xee7596ed, 0x22df9673, 0x281a9f6a, 0xe4b09ff4, 0x6a3f9817, 0xa6959889, 0x7fb58a25, 0xb31f8abb, 0x3d908d58, 0xf13a8dc6, 0xfbff84df, 0x37558441, 0xb9da83a2, 0x7570833c,
            0x533b85da, 0x9f918544, 0x111e82a7, 0xddb48239, 0xd7718b20, 0x1bdb8bbe, 0x95548c5d, 0x59fe8cc3, 0x80de9e6f, 0x4c749ef1, 0xc2fb9912, 0x0e51998c, 0x04949095, 0xc83e900b, 0x46b197e8, 0x8a1b9776,
            0x2f80b4f1, 0xe32ab46f, 0x6da5b38c, 0xa10fb312, 0xabcaba0b, 0x6760ba95, 0xe9efbd76, 0x2545bde8, 0xfc65af44, 0x30cfafda, 0xbe40a839, 0x72eaa8a7, 0x782fa1be, 0xb485a120, 0x3a0aa6c3, 0xf6a0a65d,
            0xaa4de78c, 0x66e7e712, 0xe868e0f1, 0x24c2e06f, 0x2e07e976, 0xe2ade9e8, 0x6c22ee0b, 0xa088ee95, 0x79a8fc39, 0xb502fca7, 0x3b8dfb44, 0xf727fbda, 0xfde2f2c3, 0x3148f25d, 0xbfc7f5be, 0x736df520,
            0xd6f6d6a7, 0x1a5cd639, 0x94d3d1da, 0x5879d144, 0x52bcd85d, 0x9e16d8c3, 0x1099df20, 0xdc33dfbe, 0x0513cd12, 0xc9b9cd8c, 0x4736ca6f, 0x8b9ccaf1, 0x8159c3e8, 0x4df3c376, 0xc37cc495, 0x0fd6c40b,
            0x7aa64737, 0xb60c47a9, 0x3883404a, 0xf42940d4, 0xfeec49cd, 0x32464953, 0xbcc94eb0, 0x70634e2e, 0xa9435c82, 0x65e95c1c, 0xeb665bff, 0x27cc5b61, 0x2d095278, 0xe1a352e6, 0x6f2c5505, 0xa386559b,
            0x061d761c, 0xcab77682, 0x44387161, 0x889271ff, 0x825778e6, 0x4efd7878, 0xc0727f9b, 0x0cd87f05, 0xd5f86da9, 0x19526d37, 0x97dd6ad4, 0x5b776a4a, 0x51b26353, 0x9d1863cd, 0x1397642e, 0xdf3d64b0,
            0x83d02561, 0x4f7a25ff, 0xc1f5221c, 0x0d5f2282, 0x079a2b9b, 0xcb302b05, 0x45bf2ce6, 0x89152c78, 0x50353ed4, 0x9c9f3e4a, 0x121039a9, 0xdeba3937, 0xd47f302e, 0x18d530b0, 0x965a3753, 0x5af037cd,
            0xff6b144a, 0x33c114d4, 0xbd4e1337, 0x71e413a9, 0x7b211ab0, 0xb78b1a2e, 0x39041dcd, 0xf5ae1d53, 0x2c8e0fff, 0xe0240f61, 0x6eab0882, 0xa201081c, 0xa8c40105, 0x646e019b, 0xeae10678, 0x264b06e6
        }
    };
}

```

`UAssetAPI/CustomVersion.cs`:

```cs
using System;
using System.Collections.Generic;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI;

/// <summary>
/// A custom version. Controls more specific serialization than the main engine object version does.
/// </summary>
public class CustomVersion : ICloneable
{
    /// <summary>
    /// Static map of custom version GUIDs to the object or enum that they represent in the Unreal Engine. This list is not necessarily exhaustive, so feel free to add to it if need be.
    /// </summary>
    public static readonly Dictionary<Guid, string> GuidToCustomVersionStringMap = new Dictionary<Guid, string>()
    {
        { UnusedCustomVersionKey, "UnusedCustomVersionKey" },
        { UAPUtils.GUID(0xB0D832E4, 0x1F894F0D, 0xACCF7EB7, 0x36FD4AA2), "FBlueprintsObjectVersion" },
        { UAPUtils.GUID(0xE1C64328, 0xA22C4D53, 0xA36C8E86, 0x6417BD8C), "FBuildObjectVersion" },
        { UAPUtils.GUID(0x375EC13C, 0x06E448FB, 0xB50084F0, 0x262A717E), "FCoreObjectVersion" },
        { UAPUtils.GUID(0xE4B068ED, 0xF49442E9, 0xA231DA0B, 0x2E46BB41), "FEditorObjectVersion" },
        { UAPUtils.GUID(0xCFFC743F, 0x43B04480, 0x939114DF, 0x171D2073), "FFrameworkObjectVersion" },
        { UAPUtils.GUID(0xB02B49B5, 0xBB2044E9, 0xA30432B7, 0x52E40360), "FMobileObjectVersion" },
        { UAPUtils.GUID(0xA4E4105C, 0x59A149B5, 0xA7C540C4, 0x547EDFEE), "FNetworkingObjectVersion" },
        { UAPUtils.GUID(0x39C831C9, 0x5AE647DC, 0x9A449C17, 0x3E1C8E7C), "FOnlineObjectVersion" },
        { UAPUtils.GUID(0x78F01B33, 0xEBEA4F98, 0xB9B484EA, 0xCCB95AA2), "FPhysicsObjectVersion" },
        { UAPUtils.GUID(0x6631380F, 0x2D4D43E0, 0x8009CF27, 0x6956A95A), "FPlatformObjectVersion" },
        { UAPUtils.GUID(0x12F88B9F, 0x88754AFC, 0xA67CD90C, 0x383ABD29), "FRenderingObjectVersion" },
        { UAPUtils.GUID(0x7B5AE74C, 0xD2704C10, 0xA9585798, 0x0B212A5A), "FSequencerObjectVersion" },
        { UAPUtils.GUID(0xD7296918, 0x1DD64BDD, 0x9DE264A8, 0x3CC13884), "FVRObjectVersion" },
        { UAPUtils.GUID(0xC2A15278, 0xBFE74AFE, 0x6C1790FF, 0x531DF755), "FLoadTimesObjectVersion" },
        { UAPUtils.GUID(0x6EACA3D4, 0x40EC4CC1, 0xb7868BED, 0x9428FC5), "FGeometryObjectVersion" },
        { UAPUtils.GUID(0x29E575DD, 0xE0A34627, 0x9D10D276, 0x232CDCEA), "FAnimPhysObjectVersion" },
        { UAPUtils.GUID(0xAF43A65D, 0x7FD34947, 0x98733E8E, 0xD9C1BB05), "FAnimObjectVersion" },
        { UAPUtils.GUID(0x6B266CEC, 0x1EC74B8F, 0xA30BE4D9, 0x0942FC07), "FReflectionCaptureObjectVersion" },
        { UAPUtils.GUID(0x0DF73D61, 0xA23F47EA, 0xB72789E9, 0x0C41499A), "FAutomationObjectVersion" },
        { UAPUtils.GUID(0x601D1886, 0xAC644F84, 0xAA16D3DE, 0x0DEAC7D6), "FFortniteMainBranchObjectVersion" },
        { UAPUtils.GUID(0x9DFFBCD6, 0x494F0158, 0xE2211282, 0x3C92A888), "FEnterpriseObjectVersion" },
        { UAPUtils.GUID(0xF2AED0AC, 0x9AFE416F, 0x8664AA7F, 0xFA26D6FC), "FNiagaraObjectVersion" },
        { UAPUtils.GUID(0x174F1F0B, 0xB4C645A5, 0xB13F2EE8, 0xD0FB917D), "FDestructionObjectVersion" },
        { UAPUtils.GUID(0x35F94A83, 0xE258406C, 0xA31809F5, 0x9610247C), "FExternalPhysicsCustomObjectVersion" },
        { UAPUtils.GUID(0xB68FC16E, 0x8B1B42E2, 0xB453215C, 0x058844FE), "FExternalPhysicsMaterialCustomObjectVersion" },
        { UAPUtils.GUID(0xB2E18506, 0x4273CFC2, 0xA54EF4BB, 0x758BBA07), "FCineCameraObjectVersion" },
        { UAPUtils.GUID(0x64F58936, 0xFD1B42BA, 0xBA967289, 0xD5D0FA4E), "FVirtualProductionObjectVersion" },
        { UAPUtils.GUID(0x6f0ed827, 0xa6094895, 0x9c91998d, 0x90180ea4), "FMediaFrameworkObjectVersion" },
        { UAPUtils.GUID(0xAFE08691, 0x3A0D4952, 0xB673673B, 0x7CF22D1E), "FPoseDriverCustomVersion" },
        { UAPUtils.GUID(0xCB8AB0CD, 0xE78C4BDE, 0xA8621393, 0x14E9EF62), "FTempCustomVersion" },
        { UAPUtils.GUID(0x2EB5FDBD, 0x01AC4D10, 0x8136F38F, 0x3393A5DA), "FAnimationCustomVersion" },
        { UAPUtils.GUID(0x717F9EE7, 0xE9B0493A, 0x88B39132, 0x1B388107), "FAssetRegistryVersion" },
        { UAPUtils.GUID(0xFB680AF2, 0x59EF4BA3, 0xBAA819B5, 0x73C8443D), "FClothingAssetCustomVersion" },
        { UAPUtils.GUID(0x9C54D522, 0xA8264FBE, 0x94210746, 0x61B482D0), "FReleaseObjectVersion" },
        { UAPUtils.GUID(0x4A56EB40, 0x10F511DC, 0x92D3347E, 0xB2C96AE7), "FParticleSystemCustomVersion" },
        { UAPUtils.GUID(0xD78A4A00, 0xE8584697, 0xBAA819B5, 0x487D46B4), "FSkeletalMeshCustomVersion" },
        { UAPUtils.GUID(0x5579F886, 0x933A4C1F, 0x83BA087B, 0x6361B92F), "FRecomputeTangentCustomVersion" },
        { UAPUtils.GUID(0x612FBE52, 0xDA53400B, 0x910D4F91, 0x9FB1857C), "FOverlappingVerticesCustomVersion" },
        { UAPUtils.GUID(0x430C4D19, 0x71544970, 0x87699B69, 0xDF90B0E5), "FFoliageCustomVersion" },
        { UAPUtils.GUID(0xaafe32bd, 0x53954c14, 0xb66a5e25, 0x1032d1dd), "FProceduralFoliageCustomVersion" },
        { UAPUtils.GUID(0xab965196, 0x45d808fc, 0xb7d7228d, 0x78ad569e), "FLiveLinkCustomVersion" },
        { UAPUtils.GUID(0xE7086368, 0x6B234C58, 0x84391B70, 0x16265E91), "FFortniteReleaseBranchCustomObjectVersion" },
        { UAPUtils.GUID(0xD89B5E42, 0x24BD4D46, 0x8412ACA8, 0xDF641779), "FUE5ReleaseStreamObjectVersion" },
        { UAPUtils.GUID(0xFCF57AFA, 0x50764283, 0xB9A9E658, 0xFFA02D32), "FNiagaraCustomVersion" },
        { UAPUtils.GUID(0x697DD581, 0xE64f41AB, 0xAA4A51EC, 0xBEB7B628), "FUE5MainStreamObjectVersion" }

        // etc.
    };

    /// <summary>
    /// A GUID that represents an unused custom version.
    /// </summary>
    public static readonly Guid UnusedCustomVersionKey = UAPUtils.GUID(0, 0, 0, 0xF99D40C1);

    /// <summary>
    /// Returns the name of the object or enum that a custom version GUID represents, as specified in <see cref="GuidToCustomVersionStringMap"/>.
    /// </summary>
    /// <param name="guid">A GUID that represents a custom version.</param>
    /// <returns>A string that represents the friendly name of the corresponding custom version.</returns>
    public static string GetCustomVersionFriendlyNameFromGuid(Guid guid)
    {
        return GuidToCustomVersionStringMap.ContainsKey(guid) ? GuidToCustomVersionStringMap[guid] : null;
    }

    /// <summary>
    /// Returns the GUID of the custom version that the object or enum name provided represents.
    /// </summary>
    /// <param name="friendlyName">The name of a custom version object or enum.</param>
    /// <returns>A GUID that represents the custom version</returns>
    public static Guid GetCustomVersionGuidFromFriendlyName(string friendlyName)
    {
        foreach (KeyValuePair<Guid, string> entry in GuidToCustomVersionStringMap)
        {
            if (entry.Value == friendlyName) return entry.Key;
        }
        return UnusedCustomVersionKey;
    }

    public FString Name = null;
    public Guid Key;
    public string FriendlyName = null;
    public int Version;
    public bool IsSerialized = true;

    public CustomVersion SetIsSerialized(bool val)
    {
        this.IsSerialized = val;
        return this;
    }

    public object Clone()
    {
        return new CustomVersion(Key, Version)
        {
            Name = Name,
            FriendlyName = FriendlyName,
            IsSerialized = IsSerialized
        };
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CustomVersion"/> class given an object or enum name and a version number.
    /// </summary>
    /// <param name="friendlyName">The friendly name to use when initializing this custom version.</param>
    /// <param name="version">The version number to use when initializing this custom version.</param>
    public CustomVersion(string friendlyName, int version)
    {
        Key = GetCustomVersionGuidFromFriendlyName(friendlyName);
        FriendlyName = friendlyName;
        Version = version;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CustomVersion"/> class given a custom version GUID and a version number.
    /// </summary>
    /// <param name="key">The GUID to use when initializing this custom version.</param>
    /// <param name="version">The version number to use when initializing this custom version.</param>
    public CustomVersion(Guid key, int version)
    {
        Key = key;
        if (GuidToCustomVersionStringMap.ContainsKey(key)) FriendlyName = GuidToCustomVersionStringMap[key];
        Version = version;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CustomVersion"/> class.
    /// </summary>
    public CustomVersion()
    {
        Key = UnusedCustomVersionKey;
        Version = 0;
    }
}
```

`UAssetAPI/CustomVersions/CustomVersions.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.CustomVersions
{
    /// <summary>
    /// Represents the engine version at the time that a custom version was implemented.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class IntroducedAttribute : Attribute
    {
        public EngineVersion IntroducedVersion;

        public IntroducedAttribute(EngineVersion introducedVersion)
        {
            IntroducedVersion = introducedVersion;
        }
    }

    /// <summary>
    /// Custom serialization version for changes made in the //Fortnite/Main stream.
    /// </summary>
    public enum FFortniteMainBranchObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        /// <summary>World composition tile offset changed from 2d to 3d</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        WorldCompositionTile3DOffset,

        /// <summary>Minor material serialization optimization</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        MaterialInstanceSerializeOptimization_ShaderFName,

        /// <summary>Refactored cull distances to account for HLOD, explicit override and globals in priority</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        CullDistanceRefactor_RemovedDefaultDistance,
        [Introduced(EngineVersion.VER_UE4_20)]
        CullDistanceRefactor_NeverCullHLODsByDefault,
        [Introduced(EngineVersion.VER_UE4_20)]
        CullDistanceRefactor_NeverCullALODActorsByDefault,

        /// <summary>Support to remove morphtarget generated by bRemapMorphtarget</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        SaveGeneratedMorphTargetByEngine,

        /// <summary>Convert reduction setting options</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        ConvertReductionSettingOptions,

        /// <summary>Serialize the type of blending used for landscape layer weight static params</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        StaticParameterTerrainLayerWeightBlendType,

        /// <summary>Fix up None Named animation curve names,</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        FixUpNoneNameAnimationCurves,

        /// <summary>Ensure ActiveBoneIndices to have parents even not skinned for old assets</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        EnsureActiveBoneIndicesToContainParents,

        /// <summary>Serialize the instanced static mesh render data, to avoid building it at runtime</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        SerializeInstancedStaticMeshRenderData,

        /// <summary>Cache material quality node usage</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        CachedMaterialQualityNodeUsage,

        /// <summary>Font outlines no longer apply to drop shadows for new objects but we maintain the opposite way for backwards compat</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        FontOutlineDropShadowFixup,

        /// <summary>New skeletal mesh import workflow (Geometry only or animation only re-import )</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        NewSkeletalMeshImporterWorkflow,

        /// <summary>Migrate data from previous data structure to new one to support materials per LOD on the Landscape</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        NewLandscapeMaterialPerLOD,

        /// <summary>New Pose Asset data type</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        RemoveUnnecessaryTracksFromPose,

        /// <summary>Migrate Foliage TLazyObjectPtr to TSoftObjectPtr</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        FoliageLazyObjPtrToSoftObjPtr,

        /// <summary>TimelineTemplates store their derived names instead of dynamically generating. This code tied to this version was reverted and redone at a later date</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        REVERTED_StoreTimelineNamesInTemplate,

        /// <summary>Added BakePoseOverride for LOD setting</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        AddBakePoseOverrideForSkeletalMeshReductionSetting,

        /// <summary>TimelineTemplates store their derived names instead of dynamically generating</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        StoreTimelineNamesInTemplate,

        /// <summary>New Pose Asset data type</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        WidgetStopDuplicatingAnimations,

        /// <summary>Allow reducing of the base LOD, we need to store some imported model data so we can reduce again from the same data.</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        AllowSkeletalMeshToReduceTheBaseLOD,

        /// <summary>Curve Table size reduction</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        ShrinkCurveTableSize,

        /// <summary>Widgets upgraded with WidgetStopDuplicatingAnimations, may not correctly default-to-self for the widget parameter.</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        WidgetAnimationDefaultToSelfFail,

        /// <summary>HUDWidgets now require an element tag</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        FortHUDElementNowRequiresTag,

        /// <summary>Animation saved as bulk data when cooked</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        FortMappedCookedAnimation,

        /// <summary>Support Virtual Bone in Retarget Manager</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        SupportVirtualBoneInRetargeting,

        /// <summary>Fixup bad defaults in water metadata</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        FixUpWaterMetadata,

        /// <summary>Move the location of water metadata</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        MoveWaterMetadataToActor,

        /// <summary>Replaced lake collision component</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        ReplaceLakeCollision,

        /// <summary>Anim layer node names are now conformed by Guid</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        AnimLayerGuidConformation,

        /// <summary>Ocean collision component has become dynamic</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        MakeOceanCollisionTransient,

        /// <summary>FFieldPath will serialize the owner struct reference and only a short path to its property</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        FFieldPathOwnerSerialization,

        /// <summary>Simplified WaterBody post process material handling</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        FixUpUnderwaterPostProcessMaterial,

        /// <summary>A single water exclusion volume can now exclude N water bodies</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        SupportMultipleWaterBodiesPerExclusionVolume,

        /// <summary>Serialize rigvm operators one by one instead of the full byte code array to ensure determinism</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        RigVMByteCodeDeterminism,

        /// <summary>Serialize the physical materials generated by the render material</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        LandscapePhysicalMaterialRenderData,

        /// <summary>RuntimeVirtualTextureVolume fix transforms</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        FixupRuntimeVirtualTextureVolume,

        /// <summary>Retrieve water body collision components that were lost in cooked builds</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        FixUpRiverCollisionComponents,

        /// <summary>Fix duplicate spline mesh components on rivers</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        FixDuplicateRiverSplineMeshCollisionComponents,

        /// <summary>Indicates level has stable actor guids</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        ContainsStableActorGUIDs,

        /// <summary>Levelset Serialization support for BodySetup.</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        LevelsetSerializationSupportForBodySetup,

        /// <summary>Moving Chaos solver properties to allow them to exist in the project physics settings</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        ChaosSolverPropertiesMoved,

        /// <summary>Moving some UFortGameFeatureData properties and behaviors into the UGameFeatureAction pattern</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        GameFeatureData_MovedComponentListAndCheats,

        /// <summary>Add centrifugal forces for cloth</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        ChaosClothAddfictitiousforces,

        /// <summary>Chaos Convex StructureData supports different index sizes based on num verts/planes. Chaos FConvex uses array of FVec3s for vertices instead of particles (Merged from //UE4/Main)</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        ChaosConvexVariableStructureDataAndVerticesArray,

        /// <summary>Remove the WaterVelocityHeightTexture dependency on MPC_Landscape and LandscapeWaterIndo</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        RemoveLandscapeWaterInfo,

        // CHANGES BEYOND HERE ARE UE5 ONLY //

        /// <summary>Added the weighted value property type to store the cloths weight maps' low/high ranges</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosClothAddWeightedValue,

        /// <summary>Added the Long Range Attachment stiffness weight map</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosClothAddTetherStiffnessWeightMap,

        /// <summary>Fix corrupted LOD transition maps</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosClothFixLODTransitionMaps,

        /// <summary>Enable a few more weight maps to better art direct the cloth simulation</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosClothAddTetherScaleAndDragLiftWeightMaps,

        /// <summary>Enable material (edge, bending, and area stiffness) weight maps</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosClothAddMaterialWeightMaps,

        /// <summary>Added bShowCurve for movie scene float channel serialization</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        SerializeFloatChannelShowCurve,

        /// <summary>Minimize slack waste by using a single array for grass data</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        LandscapeGrassSingleArray,

        /// <summary>Add loop counters to sequencer's compiled sub-sequence data</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        AddedSubSequenceEntryWarpCounter,

        /// <summary>Water plugin is now component-based rather than actor based</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        WaterBodyComponentRefactor,

        /// <summary>Cooked BPGC storing editor-only asset tags</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        BPGCCookedEditorTags,

        /// <summary>Terrain layer weights are no longer considered material parameters</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        TTerrainLayerWeightsAreNotParameters,

        /// <summary>
        /// Anim Dynamics Node Gravity Override vector is now defined in world space, not simulation space.
        /// Legacy behavior can be maintained with a flag, which is set false by default for new nodes,
        /// true for nodes predating this change.
        /// </summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        GravityOverrideDefinedInWorldSpace,

        /// <summary>Anim Dynamics Node Physics parameters for each body in a chain are now stored in an array and can be edited.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        AnimDynamicsEditableChainParameters,

        /// <summary>Decoupled the generation of the water texture from the Water Brush and the landscape</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WaterZonesRefactor,

        /// <summary>Add faster damping calculations to the cloth simulation and rename previous Damping parameter to LocalDamping.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        ChaosClothFasterDamping,

        /// <summary>Migrated function handlers to the CDO/archetype data</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        MigratedFunctionHandlersToDefaults,

        /// <summary>Storing inertia tensor as vec3 instead of matrix.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        ChaosInertiaConvertedToVec3,

        /// <summary>Migrated event definitions to the CDO/archetype data</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        MigratedEventDefinitionToDefaults,

        /// <summary>Serialize LevelInstanceActorGuid on new ILevelInstanceInterface implementation</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        LevelInstanceActorGuidSerialize,

        /// <summary>Single-frame/key AnimDataModel patch-up</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        SingleFrameAndKeyAnimModel,

        /// <summary>Remapped bEvaluateWorldPositionOffset to bEvaluateWorldPositionOffsetInRayTracing</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        RemappedEvaluateWorldPositionOffsetInRayTracing,

        /// <summary>Water body collision settings are now those of the base UPrimitiveComponent, rather than duplicated in UWaterBodyComponent</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WaterBodyComponentCollisionSettingsRefactor,

        /// <summary>
        /// Introducing widget inherited named slots.  This wouldn't have required a version bump, except in the previous
        /// version, users could make NamedSlots and then Seed them with any random widgets, as a sorta 'default' setup.
        /// In order to preserve that, we're bumping the version so that we can set a new field on UNamedSlot to control
        /// if a widget exposes its named slot to everyone (even if it has content), which by default they wont any longer.
        /// </summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WidgetInheritedNamedSlots,

        /// <summary>Added water HLOD material</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WaterHLODSupportAdded,

        /// <summary>Moved parameters affecting Skeleton pose rendering from the PoseWatch class to the PoseWatchPoseElement class.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        PoseWatchMigrateSkeletonDrawParametersToPoseElement,

        /// <summary>Reset default value for Water exclusion volumes to make them more intuitive and support the "it just works" philosophy.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WaterExclusionVolumeExcludeAllDefault,

        /// <summary>Added water non-tessellated LOD</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WaterNontessellatedLODSupportAdded,

        /// <summary>Added FHierarchicalSimplification::SimplificationMethod</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        HierarchicalSimplificationMethodEnumAdded,

        /// <summary>Changed how world partition streaming cells are named</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WorldPartitionStreamingCellsNamingShortened,

        /// <summary>Serialize ContentBundleGuid in WorldPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WorldPartitionActorDescSerializeContentBundleGuid,

        /// <summary>Serialize IsActorRuntimeOnly in WorldPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WorldPartitionActorDescSerializeActorIsRuntimeOnly,

        /// <summary>Add Nanite Material Override option to materials and material instances.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        NaniteMaterialOverride,

        /// <summary>Serialize HLOD stats in HLODActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        WorldPartitionHLODActorDescSerializeStats,

        /// <summary>WorldPartitionStreamingSourceComponent property deprecation</summary>
        [Introduced(EngineVersion.VER_UE5_2)]
        WorldPartitionStreamingSourceComponentTargetDeprecation,

        /// <summary>Fixed localization gathering for external actor packages</summary>
        [Introduced(EngineVersion.VER_UE5_2)]
        FixedLocalizationGatherForExternalActorPackage,

        /// <summary>Change HLODActors to RuntimeCells mapping to use a GUID instead of the cell name</summary>
        [Introduced(EngineVersion.VER_UE5_2)]
        WorldPartitionHLODActorUseSourceCellGuid,

        /// <summary>Add an attribute to geometry collection to track internal faces, rather than relying on material ID numbering</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        ChaosGeometryCollectionInternalFacesAttribute,

        /// <summary>Dynamic cast nodes use an enumerated pure node state to include a value for the default setting</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        DynamicCastNodesUsePureStateEnum,

        /// <summary>Add FWorldPartitionActorFilter to FLevelInstanceActorDesc/FDataLayerInstanceDesc</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionActorFilter,

        /// <summary>Change the non-spatialized radius to blend to a pure 2D spatialized sound vs omnidirectional</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        AudioAttenuationNonSpatializedRadiusBlend,

        /// <summary>Serialize actor class descriptors</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionActorClassDescSerialize,

        /// <summary>FActorContainerID is now an FGuid instead of a uint64</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionFActorContainerIDu64ToGuid,

        /// <summary>FDataLayerInstanceDesc support for private data layers</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionPrivateDataLayers,

        /// <summary>Reduce size and improve behaviour of Chaos::FImplicitObjectUnion</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        ChaosImplicitObjectUnionBVHRefactor,

        /// <summary>FLevelInstanceActorDesc DeltaSerialize Filter</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        LevelInstanceActorDescDeltaSerializeFilter,

        /// <summary>Fix the Nanite landscape mesh non-deterministic DDC keys</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        FixNaniteLandscapeMeshDDCKey,

        /// <summary>Change how connection graphs are stored on Geometry Collections to an edge-array representation</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        ChaosGeometryCollectionConnectionEdgeGroup,

        /// <summary>Moved the water info mesh data and static water body meshes into new static mesh components for water bodies.</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WaterBodyStaticMeshComponents,

        /// <summary>Serialize invalid bounds in world partition actor descriptors</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionActorDescSerializeInvalidBounds,

        /// <summary>Upgrade Navigation Links to use 64 bits for the ID</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        NavigationLinkID32To64,

        /// <summary>Serialize editor only references in world partition actor descriptors</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionActorDescSerializeEditorOnlyReferences,

        /// <summary>Add support for soft object paths in actor descriptors</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionActorDescSerializeSoftObjectPathSupport,

        /// <summary>Don't serialize class descriptor GUIDs</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionClasDescGuidTransient,

        /// <summary>Serialize ActorDesc bIsMainWorldOnly</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionActorDescIsMainWorldOnly,

        /// <summary>FWorldPartitionActorFilter go back to FString serialize of AssetPaths to avoid FArchiveReplaceOrClearExternalReferences clearing CDO references on BP Compile</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionActorFilterStringAssetPath,

        /// <summary>Add FPackedLevelActorDesc for APackedLevelActor and support for APackedLevelActor Filters</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        PackedLevelActorDesc,

        /// <summary>Add customizable values for several UWorldPartitionRuntimeSpatialHash cvars</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionRuntimeSpatialHashCVarOverrides,

        /// <summary>WorldPartition HLOD now contains a source actors object</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionHLODSourceActorsRefactor,

        [Introduced(EngineVersion.VER_UE5_3)]
        WaterBodyStaticMeshRename,

        /// <summary>Geometry Collection now by-default converts vertex colors to sRGB when creating render data</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        GeometryCollectionConvertVertexColorToSRGB,

        /// <summary>Water bodies before this version need to update their water zone on load since they won't have been serialized yet.</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WaterOwningZonePointerFixup,

        /// <summary>Set flags on water static meshes to duplicate transient to avoid underlying static mesh duplication issue</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WaterBodyStaticMeshDuplicateTransient,

        /// <summary>Update paths to use the SkeletalClass</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        MVVMConvertPropertyPathToSkeletalClass,

        /// <summary>Fixup all flags/outering on static meshes on water bodies by rebuilding them completely</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WaterBodyStaticMeshFixup,

        /// <summary>Binding extensions for anim graph nodes</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        AnimGraphNodeBindingExtensions,

        /// <summary>Function data stores a map from work to debug operands</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        RigVMSaveDebugMapInGraphFunctionData,

        /// <summary>Fix missing binding extensions for some anim graph nodes</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        FixMissingAnimGraphNodeBindingExtensions,

        /// <summary>EditableWhenInherited: Skip custom serialization on non Archetypes</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        ISMComponentEditableWhenInheritedSkipSerialization,

        /// <summary>GrassTypes are now per-component, rather than per-landscape proxy :</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        LandscapeSupportPerComponentGrassTypes,

        /// <summary>World partition actor data layers activation logic operator support defaults for old maps</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        WorldPartitionDataLayersLogicOperatorAdded,

        /// <summary>Started sorting Possessables, Spawnables, and MovieSceneBindings for better search performance.</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        MovieSceneSortedBindings,

        /// <summary>Remove the UAnimCurveCompressionCodec::InstanceGuid which causes cook determinism issues</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        RemoveAnimCurveCompressionCodecInstanceGuid,

        /// <summary>Serialize the source HLOD Layer for HLOD actor descriptors.</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        WorldPartitionHLODActorDescSerializeSourceHLODLayer,

        /// <summary>Serialize custom editor bounds for HLOD actor descriptors.</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        WorldPartitionHLODActorDescSerializeEditorBounds,

        /// <summary>Changed default Local Exposure Contrast from 1.0 to 0.8 (reverted)</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        LocalExposureDefaultChangeFrom1_Reverted,

        /// <summary>Added support of external packaging of Data Layer Instances</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        AddDataLayerInstanceExternalPackage,

        /// <summary>Update paths to keep a flag if they are the widget BP</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        MVVMPropertyPathSelf,

        /// <summary>Enabled ObjectPtr property serialization for Dataflow nodes</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        AddDataflowObjectSerialization,

        /// <summary>Add anim notify rate scaling, defaults to on for new content, off for old content</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        AnimNotifyAddRateScale,

        /// <summary>Fix tangents for non-uniform build scales, and add a flag to optionally match the previous (incorrect) tangents</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        FixedTangentTransformForNonuniformBuildScale,

        /// <summary>AnimNode Layers will now start in a Shared Group, instead of being each one on a different group at runtime</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        AnimNodeRootDefaultGroupChange,

        /// <summary>Move AnimNext graphs to sub-entries of assets</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        AnimNextMoveGraphsToEntries,

        /// <summary>Removed debug information containing compressed data author, time etc. from animation DDC data as it introduces indeterminism</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        AnimationSequenceCompressedDataRemoveDebugData,

        /// <summary>Changes to Orthographic Camera default settings</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        OrthographicCameraDefaultSettings,

        /// <summary>Added settings to Landscape HLODs</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        LandscapeAddedHLODSettings,

        /// <summary>Skeletal Mesh uses Mesh Description to store mesh bulk data.</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        MeshDescriptionForSkeletalMesh,

        /// <summary>Skeletal Mesh optionally cooks half edge data per lod</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        SkeletalHalfEdgeData,

        /// <summary>Combine graph contexts for AnimNext graphs</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        AnimNextCombineGraphContexts,

        /// <summary>Combine parameter blocks and graphs</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        AnimNextCombineParameterBlocksAndGraphs,

        /// <summary>Move workspaces to a seperate plugin</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        AnimNextMoveWorkspaces,

        /// <summary>Level Instance Property overrides</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        LevelInstancePropertyOverrides,

        /// <summary>Added FVolumetricLightMapGridDesc in MapBuildData</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        VolumetricLightMapGridDescSupport,

        /// <summary>Introduce new structure for customizing the landscape edit layer behavior</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        IntroduceLandscapeEditLayerClass,

        /// <summary>Change workspaces to store asset references as external objects</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        AnimNextWorkspaceEntryConversion,

        /// <summary>Add support for anytype in dataflow</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        DataflowAnyTypeSupport,

        /// <summary>Adding a new flag in RBAN Solver Setting to be able to use manifolds</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        PhysicsAssetUseManifoldFlags,

        /// <summary>Added support for to record sim and query data of Shape Instance data in CVD</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        SimAndQueryDataSupportInChaosVisualDebugger,

        /// <summary>Add the imported asset dependencies to the Cloth Asset USD Import node</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        ChaosClothAssetUSDImportNodeAddAssetDependencies,

        /// <summary>Changed HitLighting to HitLightingForReflections, and HitLighting now means hit lighting for entire Lumen</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        LumenRayLightingModeOverrideEnum,

        /// <summary>PCGPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        PCGPartitionActorDesc,

        /// <summary>Target layers are now defined in the Landscape actor and not continuously synced from the assigned material.</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        LandscapeTargetLayersInLandscapeActor,

        /// <summary>Fix to get full name of templated type ( Tarray > TArray{Float} for example )</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        DataflowTemplatedTypeFix,

        /// <summary>Changes for LevelInstance support in StaticLighting</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        LevelInstanceStaticLightingSupport,

        /// <summary>PCGGridDescriptor</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        PCGGridDescriptor,

        /// <summary>AnimNext graphs now have public/private state</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        AnimNextGraphAccessSpecifiers,

        /// <summary>Added a more stable pixel depth offset mode.</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        MaterialPixelDepthOffsetMode,

        /// <summary>Added hideable pins to dataflow</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        DataflowHideablePins,

        /// <summary>Added multiple section import to the cloth asset skeletal mesh import node</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        ClothAssetSkeletalMeshMultiSectionImport,

        /// <summary>Serialize EditorBounds in WorldPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        WorldPartitionActorDescSerializeEditorBounds,

        /// <summary>Fixup for the data that has been damaged by LandscapeTargetLayersInLandscapeActor (loss of landscape layer info object assignments)</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        FixupLandscapeTargetLayersInLandscapeActor,

        //Allow custom import of morph target
        [Introduced(EngineVersion.VER_UE5_5)]
        MorphTargetCustomImport,

        /// <summary>Fix chaos cloth buckling stiffness parameter bug </summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        ChaosClothAllowZeroBucklingStiffness,

        /// <summary>LevelSequenceUpgradeDynamicBindings was removed but was intended for this position. Putting this here to make sure versioning of subsequent assets remains the same</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        LevelSequenceUpgradeDynamicBindings_NoOp,

        /// <summary>AddToFrontend GFA now defaults to unload plugin on exit frontend</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        GameFeatureDataActionAddToFrontendDefaultToUnload,

        /// <summary>Upgraded movie scene 'dynamic bindings' to use the new Custom Bindings system</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        LevelSequenceUpgradeDynamicBindings,

        /// <summary>Changed the precision for the stored rotation on kinematic targets to match the precision used in particles </summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        ChaosStoreKinematicTargetRotationAsSinglePrecision,

        /// <summary>PCG changes around the ApplyOnActor node, where we collapsed the TargetActor to the input pin.</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        PCGApplyOnActorNodeMoveTargetActorEdgeToInput,

        /// <summary>
        /// Deprecation of the bPlaying flag on FTimeline struct types in favor of a better
        /// PlayingStateTracker type to improve replication reliability
        /// </summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        TimelinePlayingStateTrackerDeprecation,

        /// <summary>Enable SkipOnlyEditorOnly style cooking of UStaticMeshComponent::MeshPaintTexture</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        MeshPaintTextureUsesEditorOnly,

        /// <summary>Fixup and synchronize some landscape properties that have moved to the property sharing/overriding system :</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        LandscapeBodyInstanceAsSharedProperty,

        /// <summary>Multiple changes to AnimNext modules, variables etc.</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        AnimNextModuleRefactor,

        /// <summary>Subsurface profile now has a guid to be able to select one of many in a Substrate material.</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        SubsurfaceProfileGuid,

        /// <summary>Added support for to record the new solver iteration settings in CVD</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        SolverIterationsDataSupportInChaosVisualDebugger,

        /// <summary>Updated FColorMaterialInput to use FLinearColor instead of FColor</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        MaterialInputUsesLinearColor,

        /// <summary>Updated editor only AFunctionalTest running logic to run tests editor world if the actors don't support PIE</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        FunctionalTestCanRunInEditorWorld,

        /// <summary>Added support for display name in the Visual Logger</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        VisualLoggerSupportDisplayName,

        /// <summary>Added support for the GyroscopicTorque flag in CVD</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        GyroscopicTorquesSupportInChaosVisualDebugger,

        /// <summary>Added managed array property serialization</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        AddManagedArrayCollectionPropertySerialization,

        /// <summary>Landscape texture patches in Texture Asset source mode now use proper resolution when calculating transform</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        LandscapeTexturePatchUsesTextureAssetResolution,

        /// <summary>Added support for relative transform in WorldPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        WorldPartitionActorDescSerializeRelativeTransform,

        /// <summary>Make sure scene graph entities are not public by default</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        SceneGraphEntitiesPrivateByDefault,

        /// <summary>Added debug color for physical materials</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        DebugColorForPhysicalMaterials,

        /// <summary>Added PreprocessedFontGeometry to FFontFaceData</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        AddedPreprocessedFontGeometry,

        /// <summary>Added Dynamic Mesh Sculpt Layer serialization</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        DynamicMeshSerializeSculptLayers,

        /// <summary>Fix reachable garbage object warnings from some legacy ASpatialHashRuntimeGridInfo actors</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        SpatialHashRuntimeGridInfoSpriteFixup,

        /// <summary>Removed UAnimSequence::bUseRawDataOnly flag alongside compression refactor</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        AnimSequenceRawDataOnlyFlagRemoval,

        /// <summary>HLOD relevancy of Level Instances was previously ignored, now taken into account. Reset to the default behavior.</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        ResetLevelInstanceHLODRelevancy,

        /// <summary>Updated default scene capture post-processing settings to reflect the underlying implementation overrides</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        SceneCaptureDefaultSettings,

        /// <summary>Add Cloth Asset Base class serialization</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        AddClothAssetBase,

        /// <summary>Add inline constant default values to the PCG graph nodes.</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        PCGInlineConstantDefaultValues,

        /// <summary>Add MaterialSubstrateSubsurfaceType type to UMaterialExpressionSubstrateSlabBSDF for replacing bUseSSSDifffusion</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        AddMaterialSubstrateSubsurfaceType,

        /// <summary>Added option to visualize runtime virtual textures' streamed mips only in PIE </summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        AddedRuntimeVirtualTextureUseStreamingMipsInEditorMode,

        /// <summary>Media plate holdout composite components have been replaced by a checkbox</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        MediaPlateHoldoutComponentRemoval,

        /// <summary>Changed PCG landscape cache default from "serialize at cook" to "never serialize"</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        PCGLandscapeCacheDefaultSerializationChanged,

        /// <summary>FSoftObjectPath::SubPathString changed to FUtf8String</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        SoftObjectPathUtf8SubPaths,

        /// <summary>FSoftObjectPath::SubPathString could be saved with trailing NULs and need truncating</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        SoftObjectPathTrailingNULsMaintained,

        /// <summary>Water body components no longer need to maintain their own PhysicalMaterial property since they are primitive components. After this version, leverage that one instead.</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        WaterBodyPhysicalMaterialPropertyRemoval,

        /// <summary>PCG fixed attribute set -> point conversion passing through empty point data as-is and violating output pin type.</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        PCGAttributeSetToPointAlwaysConverts,

        //Add per material slot overlay material data
        [Introduced(EngineVersion.VER_UE5_6)]
        MeshMaterialSlotOverlayMaterialAdded,

        /// <summary>Convert Sustrate glint density properly</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        ConvertGlintDensity,

        /// <summary>Introduced skinweight validation to avoid render crashes and disappearing simulation meshes</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        ClothAssetSkinweightsValidation,

        /// <summary>Switching verse from right handed to left handed</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        VerseRightToLeftHandedness,

        /// <summary>Added additional data required to record and represent particle data from the game thread (Kinematic targets, and SQ rejection reasons)</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        AdditionalGameThreadDataSupportInChaosVisualDebugger,

        /// <summary>Upgrade UMG widget blueprints using legacy animation API</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        UpgradeWidgetBlueprintLegacySequencePlayer,

        /// <summary>Changed clockwise detection algorithm for PCGSplineDirection node with the correct one, but add a version to not break previous nodes.</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        PCGSplineDirectionClockwiseFix,

        /// <summary>Rect Lights set in EV units had the wrong intensity (older files need a flag set to keep the old look)</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        RectLightFixedEVUnitConversion,

        /// <summary>Add particle bounds to data exported to CVD</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        ParticleInflatedBoundsInChaosVisualDebugger,

        /// <summary>Migrate properties from FLandscapeLayer to ULandscapeEditLayer</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        MigrateLandscapeEditLayerProperties,

        /// <summary>Added more context data to CVD's traced shapes so we can play it back at the solver stage level (not just game thread frames) </summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        ThreadContextDataInChaosVisualDebuggerDebugDrawData,

        /// <summary>Changed default grid mode in surface sampler to a version that's more intuitive and less error-prone</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        PCGChangedSurfaceSamplerDefaultGridCreationMode,

        /// <summary>Media plate overlay composite technique replacement with holdout composite</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        MediaPlateOverlayTechniqueRemoval,

        /// <summary>Added particle flag to allow/disallow partial island sleeping in the island the particle is in</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        PerParticleFlagToAllowPartialIslandSleepInConnectedIsland,

        /// <summary>Material Function Blend Deserialize Top/Bottom input nodes with clearer enum marker.</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        MaterialFunctionBlendTopBottomInputEnum,

        /// <summary>Cooked CPU-side morph target points are now stored internally in the same compressed format as the GPU morph data. </summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        MorphTargetCookedCPUDataCompressed,

        /// <summary>AnimNext variables converted to references</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        AnimNextVariableReferences,

        /// <summary>The default distortion rendering mode used by the Lens Component is now the Lens Distortion Scene View Extension</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        LensComponentDefaultToDistortionSVE,

        /// <summary>Animation default blend option changed from Linear to HermiteCubic (aka SmoothStep, ease in / ease out)</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        ChangeDefaultAlphaBlendType,

        /// <summary>Moved Position/Velocity/Projection Iteration Counts from FChaosVDFRigidParticleControlFlags to FChaosVDParticleDynamicMisc</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        PerParticleIterationCountMovedToDynamicMisc,

        /// <summary>Added missing custom serialization for some properties in the ParticleDynamicMisc structure used by the Chaos Visual Debugger</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        AddedMissingSerializationForPropertiesInDynamicMisc,

        /// <summary>Change default value for deprecated bEnableWorldPartitionGenerationSources</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        PCGDeprecateWorldPartitionGenerationSources,

        /// <summary>Refactored the composite (plugin) actor scene capture management.</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        CompositeActorSceneCaptureRefactor,

        /// <summary>Moved HLOD Layer properties to an editor only optional object</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        HLODLayerEditorOnlyObject,

        /// <summary>Deduplicated particle debug names serialization in the Chaos Visual Debugger</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        DeduplicatedDebugNameSerializationInCVD,

        /// <summary>Add BloomGaussianIntensity and BloomConvolutionIntensity</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        SpecializeBloomIntensity,

        /// <summary>Add support for world partition actor component descriptors</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        WorldPartitionActorComponentDesc,

        /// <summary>Migrate Non-Edit layer landscapes to use the edit layer (ULandscapeEditLayer) system</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        MigrateLandscapeNonEditLayerToEditLayer,

        /// <summary>FDynamicMeshAttributeSet has Morph Targets.</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        DynamicMeshAttributesMorphTargets,

        /// <summary>Introduce landscape advanced weight blending </summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        LandscapeAdvancedWeightBlending,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    };

    /// <summary>
    /// Custom serialization version for changes made in Dev-Framework stream.
    /// </summary>
    public enum FFrameworkObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        /// <summary>BodySetup's default instance collision profile is used by default when creating a new instance.</summary>
        [Introduced(EngineVersion.VER_UE4_12)]
        UseBodySetupCollisionProfile,

        /// <summary>Regenerate subgraph arrays correctly in animation blueprints to remove duplicates and add missing graphs that appear read only when edited</summary>
        [Introduced(EngineVersion.VER_UE4_12)]
        AnimBlueprintSubgraphFix,

        /// <summary>Static and skeletal mesh sockets now use the specified scale</summary>
        [Introduced(EngineVersion.VER_UE4_12)]
        MeshSocketScaleUtilization,

        /// <summary>Attachment rules are now explicit in how they affect location, rotation and scale</summary>
        [Introduced(EngineVersion.VER_UE4_12)]
        ExplicitAttachmentRules,

        /// <summary>Moved compressed anim data from uasset to the DDC</summary>
        [Introduced(EngineVersion.VER_UE4_12)]
        MoveCompressedAnimDataToTheDDC,

        /// <summary>Some graph pins created using legacy code seem to have lost the RF_Transactional flag, which causes issues with undo. Restore the flag at this version</summary>
        [Introduced(EngineVersion.VER_UE4_12)]
        FixNonTransactionalPins,

        /// <summary>Create new struct for SmartName, and use that for CurveName</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        SmartNameRefactor,

        /// <summary>Add Reference Skeleton to Rig</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        AddSourceReferenceSkeletonToRig,

        /// <summary>Refactor ConstraintInstance so that we have an easy way to swap behavior paramters</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        ConstraintInstanceBehaviorParameters,

        /// <summary>Pose Asset support mask per bone</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        PoseAssetSupportPerBoneMask,

        /// <summary>Physics Assets now use SkeletalBodySetup instead of BodySetup</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        PhysAssetUseSkeletalBodySetup,

        /// <summary>Remove SoundWave CompressionName</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        RemoveSoundWaveCompressionName,

        /// <summary>Switched render data for clothing over to unreal data, reskinned to the simulation mesh</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        AddInternalClothingGraphicalSkinning,

        /// <summary>Wheel force offset is now applied at the wheel instead of vehicle COM</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        WheelOffsetIsFromWheel,

        /// <summary>Move curve metadata to be saved in skeleton. Individual asset still saves some flag - i.e. disabled curve and editable or not, but major flag - i.e. material types - moves to skeleton and handle in one place</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        MoveCurveTypesToSkeleton,

        /// <summary>Cache destructible overlaps on save</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        CacheDestructibleOverlaps,

        /// <summary>Added serialization of materials applied to geometry cache objects</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        GeometryCacheMissingMaterials,

        /// <summary>Switch static and skeletal meshes to calculate LODs based on resolution-independent screen size</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        LODsUseResolutionIndependentScreenSize,

        /// <summary>Blend space post load verification</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        BlendSpacePostLoadSnapToGrid,

        /// <summary>Addition of rate scales to blend space samples</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        SupportBlendSpaceRateScale,

        /// <summary>LOD hysteresis also needs conversion from the LODsUseResolutionIndependentScreenSize version</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        LODHysteresisUseResolutionIndependentScreenSize,

        /// <summary>AudioComponent override subtitle priority default change</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        ChangeAudioComponentOverrideSubtitlePriorityDefault,

        /// <summary>Serialize hard references to sound files when possible</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        HardSoundReferences,

        /// <summary>Enforce const correctness in Animation Blueprint function graphs</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        EnforceConstInAnimBlueprintFunctionGraphs,

        /// <summary>Upgrade the InputKeySelector to use a text style</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        InputKeySelectorTextStyle,

        /// <summary>Represent a pins container type as an enum not 3 independent booleans</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        EdGraphPinContainerType,

        /// <summary>Switch asset pins to store as string instead of hard object reference</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        ChangeAssetPinsToString,

        /// <summary>Fix Local Variables so that the properties are correctly flagged as blueprint visible</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        LocalVariablesBlueprintVisible,

        /// <summary>Stopped serializing UField_Next so that UFunctions could be serialized in dependently of a UClass in order to allow us to do all UFunction loading in a single pass (after classes and CDOs are created)</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        RemoveUField_Next,

        /// <summary>Fix User Defined structs so that all members are correct flagged blueprint visible</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        UserDefinedStructsBlueprintVisible,

        /// <summary>FMaterialInput and FEdGraphPin store their name as FName instead of FString</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        PinsStoreFName,

        /// <summary>User defined structs store their default instance, which is used for initializing instances</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        UserDefinedStructsStoreDefaultInstance,

        /// <summary>Function terminator nodes serialize an FMemberReference rather than a name/class pair</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        FunctionTerminatorNodesUseMemberReference,

        /// <summary>Custom event and non-native interface event implementations add 'const' to reference parameters</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        EditableEventsUseConstRefParameters,

        /// <summary>No longer serialize the legacy flag that indicates this state, as it is now implied since we don't serialize the skeleton CDO</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        BlueprintGeneratedClassIsAlwaysAuthoritative,

        /// <summary>Enforce visibility of blueprint functions - e.g. raise an error if calling a private function from another blueprint:</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        EnforceBlueprintFunctionVisibility,

        /// <summary>ActorComponents now store their serialization index</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        StoringUCSSerializationIndex,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    };

    /// <summary>
    /// Custom serialization version for changes made in Dev-Core stream.
    /// </summary>
    public enum FCoreObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        [Introduced(EngineVersion.VER_UE4_12)]
        MaterialInputNativeSerialize,

        [Introduced(EngineVersion.VER_UE4_15)]
        EnumProperties,

        [Introduced(EngineVersion.VER_UE4_22)]
        SkeletalMaterialEditorDataStripping,

        [Introduced(EngineVersion.VER_UE4_25)]
        FProperties,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    };

    /// <summary>
    /// Custom serialization version for changes made in Dev-Editor stream.
    /// </summary>
    public enum FEditorObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        /// <summary>Localizable text gathered and stored in packages is now flagged with a localizable text gathering process version</summary>
        [Introduced(EngineVersion.VER_UE4_12)]
        GatheredTextProcessVersionFlagging,

        /// <summary>Fixed several issues with the gathered text cache stored in package headers</summary>
        [Introduced(EngineVersion.VER_UE4_12)]
        GatheredTextPackageCacheFixesV1,

        /// <summary>Added support for "root" meta-data (meta-data not associated with a particular object in a package)</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        RootMetaDataSupport,

        /// <summary>Fixed issues with how Blueprint bytecode was cached</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        GatheredTextPackageCacheFixesV2,

        /// <summary>Updated FFormatArgumentData to allow variant data to be marshaled from a BP into C++</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        TextFormatArgumentDataIsVariant,

        /// <summary>Changes to SplineComponent</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        SplineComponentCurvesInStruct,

        /// <summary>Updated ComboBox to support toggling the menu open, better controller support</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        ComboBoxControllerSupportUpdate,

        /// <summary>Refactor mesh editor materials</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        RefactorMeshEditorMaterials,

        /// <summary>Added UFontFace assets</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        AddedFontFaceAssets,

        /// <summary>Add UPROPERTY for TMap of Mesh section, so the serialize will be done normally (and export to text will work correctly)</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        UPropertryForMeshSection,

        /// <summary>Update the schema of all widget blueprints to use the WidgetGraphSchema</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        WidgetGraphSchema,

        /// <summary>Added a specialized content slot to the background blur widget</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        AddedBackgroundBlurContentSlot,

        /// <summary>Updated UserDefinedEnums to have stable keyed display names</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        StableUserDefinedEnumDisplayNames,

        /// <summary>Added "Inline" option to UFontFace assets</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        AddedInlineFontFaceAssets,

        /// <summary>Fix a serialization issue with static mesh FMeshSectionInfoMap FProperty</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        UPropertryForMeshSectionSerialize,

        /// <summary>Adding a version bump for the new fast widget construction in case of problems.</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        FastWidgetTemplates,

        /// <summary>Update material thumbnails to be more intelligent on default primitive shape for certain material types</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        MaterialThumbnailRenderingChanges,

        /// <summary>Introducing a new clipping system for Slate/UMG</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        NewSlateClippingSystem,

        /// <summary>MovieScene Meta Data added as native Serialization</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        MovieSceneMetaDataSerialization,

        /// <summary>Text gathered from properties now adds two variants: a version without the package localization ID (for use at runtime), and a version with it (which is editor-only)</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        GatheredTextEditorOnlyPackageLocId,

        /// <summary>Added AlwaysSign to FNumberFormattingOptions</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        AddedAlwaysSignNumberFormattingOption,

        /// <summary>Added additional objects that must be serialized as part of this new material feature</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        AddedMaterialSharedInputs,

        /// <summary>Added morph target section indices</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        AddedMorphTargetSectionIndices,

        /// <summary>Serialize the instanced static mesh render data, to avoid building it at runtime</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        SerializeInstancedStaticMeshRenderData,

        /// <summary>Change to MeshDescription serialization (moved to release)</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        MeshDescriptionNewSerialization_MovedToRelease,

        /// <summary>New format for mesh description attributes</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        MeshDescriptionNewAttributeFormat,

        /// <summary>Switch root component of SceneCapture actors from MeshComponent to SceneComponent</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        ChangeSceneCaptureRootComponent,

        /// <summary>StaticMesh serializes MeshDescription instead of RawMesh</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        StaticMeshDeprecatedRawMesh,

        /// <summary>MeshDescriptionBulkData contains a Guid used as a DDC key</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        MeshDescriptionBulkDataGuid,

        /// <summary>Change to MeshDescription serialization (removed FMeshPolygon::HoleContours)</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        MeshDescriptionRemovedHoles,

        /// <summary>Change to the WidgetCompoent WindowVisibilty default value</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        ChangedWidgetComponentWindowVisibilityDefault,

        /// <summary>Avoid keying culture invariant display strings during serialization to avoid non-deterministic cooking issues</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        CultureInvariantTextSerializationKeyStability,

        /// <summary>Change to UScrollBar and UScrollBox thickness property (removed implicit padding of 2, so thickness value must be incremented by 4).</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        ScrollBarThicknessChange,

        /// <summary>Deprecated LandscapeHoleMaterial</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        RemoveLandscapeHoleMaterial,

        /// <summary>MeshDescription defined by triangles instead of arbitrary polygons</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        MeshDescriptionTriangles,

        /// <summary>Add weighted area and angle when computing the normals</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        ComputeWeightedNormals,

        /// <summary>SkeletalMesh now can be rebuild in editor, no more need to re-import</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        SkeletalMeshBuildRefactor,

        /// <summary>Move all SkeletalMesh source data into a private uasset in the same package has the skeletalmesh</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        SkeletalMeshMoveEditorSourceDataToPrivateAsset,

        /// <summary>Parse text only if the number is inside the limits of its type</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        NumberParsingOptionsNumberLimitsAndClamping,

        /// <summary>Make sure we can have more then 255 material in the skeletal mesh source data</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        SkeletalMeshSourceDataSupport16bitOfMaterialNumber,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    };

    /// <summary>
    /// Custom serialization version for changes made in Dev-AnimPhys stream
    /// </summary>
    public enum FAnimPhysObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded,

        /// <summary>convert animnode look at to use just default axis instead of enum, which doesn't do much</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        ConvertAnimNodeLookAtAxis,

        /// <summary>Change FKSphylElem and FKBoxElem to use Rotators not Quats for easier editing</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        BoxSphylElemsUseRotators,

        /// <summary>Change thumbnail scene info and asset import data to be transactional</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        ThumbnailSceneInfoAndAssetImportDataAreTransactional,

        /// <summary>Enabled clothing masks rather than painting parameters directly</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        AddedClothingMaskWorkflow,

        /// <summary>Remove UID from smart name serialize, it just breaks determinism</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        RemoveUIDFromSmartNameSerialize,

        /// <summary>Convert FName Socket to FSocketReference and added TargetReference that support bone and socket</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        CreateTargetReference,

        /// <summary>Tune soft limit stiffness and damping coefficients</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        TuneSoftLimitStiffnessAndDamping,

        /// <summary>Fix possible inf/nans in clothing particle masses</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        FixInvalidClothParticleMasses,

        /// <summary>Moved influence count to cached data</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        CacheClothMeshInfluences,

        /// <summary>Remove GUID from Smart Names entirely + remove automatic name fixup</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        SmartNameRefactorForDeterministicCooking,

        /// <summary>rename the variable and allow individual curves to be set</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        RenameDisableAnimCurvesToAllowAnimCurveEvaluation,

        /// <summary>link curve to LOD, so curve metadata has to include LODIndex</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        AddLODToCurveMetaData,

        /// <summary>Fixed blend profile references persisting after paste when they aren't compatible</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        FixupBadBlendProfileReferences,

        /// <summary>Allowing multiple audio plugin settings</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        AllowMultipleAudioPluginSettings,

        /// <summary>Change RetargetSource reference to SoftObjectPtr</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        ChangeRetargetSourceReferenceToSoftObjectPtr,

        /// <summary>Save editor only full pose for pose asset</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        SaveEditorOnlyFullPoseForPoseAsset,

        /// <summary>Asset change and cleanup to facilitate new streaming system</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        GeometryCacheAssetDeprecation,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    }

    /// <summary>
    /// Custom serialization version for changes made in Release streams.
    /// </summary>
    public enum FReleaseObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        /// <summary>Static Mesh extended bounds radius fix</summary>
        [Introduced(EngineVersion.VER_UE4_11)]
        StaticMeshExtendedBoundsFix,

        /// <summary>Physics asset bodies are either in the sync scene or the async scene, but not both</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        NoSyncAsyncPhysAsset,

        /// <summary>ULevel was using TTransArray incorrectly (serializing the entire array in addition to individual mutations). converted to a TArray</summary>
        [Introduced(EngineVersion.VER_UE4_13)]
        LevelTransArrayConvertedToTArray,

        /// <summary>Add Component node templates now use their own unique naming scheme to ensure more reliable archetype lookups.</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        AddComponentNodeTemplateUniqueNames,

        /// <summary>Fix a serialization issue with static mesh FMeshSectionInfoMap FProperty</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        UPropertryForMeshSectionSerialize,

        /// <summary>Existing HLOD settings screen size to screen area conversion</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        ConvertHLODScreenSize,

        /// <summary>Adding mesh section info data for existing billboard LOD models</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        SpeedTreeBillboardSectionInfoFixup,

        /// <summary>Change FMovieSceneEventParameters::StructType to be a string asset reference from a TWeakObjectPtr UScriptStruct</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        EventSectionParameterStringAssetRef,

        /// <summary>Remove serialized irradiance map data from skylight.</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        SkyLightRemoveMobileIrradianceMap,

        /// <summary>rename bNoTwist to bAllowTwist</summary>
        [Introduced(EngineVersion.VER_UE4_17)]
        RenameNoTwistToAllowTwistInTwoBoneIK,

        /// <summary>Material layers serialization refactor</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        MaterialLayersParameterSerializationRefactor,

        /// <summary>Added disable flag to skeletal mesh data</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        AddSkeletalMeshSectionDisable,

        /// <summary>Removed objects that were serialized as part of this material feature</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        RemovedMaterialSharedInputCollection,

        /// <summary>HISMC Cluster Tree migration to add new data</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        HISMCClusterTreeMigration,

        /// <summary>Default values on pins in blueprints could be saved incoherently</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        PinDefaultValuesVerified,

        /// <summary>During copy and paste transition getters could end up with broken state machine references</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        FixBrokenStateMachineReferencesInTransitionGetters,

        /// <summary>Change to MeshDescription serialization</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        MeshDescriptionNewSerialization,

        /// <summary>Change to not clamp RGB values > 1 on linear color curves</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        UnclampRGBColorCurves,

        /// <summary>BugFix for FAnimObjectVersion::LinkTimeAnimBlueprintRootDiscovery.</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        LinkTimeAnimBlueprintRootDiscoveryBugFix,

        /// <summary>Change trail anim node variable deprecation</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        TrailNodeBlendVariableNameChange,

        /// <summary>Make sure the Blueprint Replicated Property Conditions are actually serialized properly.</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        PropertiesSerializeRepCondition,

        /// <summary>DepthOfFieldFocalDistance at 0 now disables DOF instead of DepthOfFieldFstop at 0.</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        FocalDistanceDisablesDOF,

        /// <summary>Removed versioning, but version entry must still exist to keep assets saved with this version loadable</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        Unused_SoundClass2DReverbSend,

        /// <summary>Groom asset version</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        GroomAssetVersion1,

        /// <summary>Groom asset version</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        GroomAssetVersion2,

        /// <summary>Store applied version of Animation Modifier to use when reverting</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        SerializeAnimModifierState,

        /// <summary>Groom asset version</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        GroomAssetVersion3,

        /// <summary>Upgrade filmback</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        DeprecateFilmbackSettings,

        /// <summary>custom collision type</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        CustomImplicitCollisionType,

        /// <summary>FFieldPath will serialize the owner struct reference and only a short path to its property</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        FFieldPathOwnerSerialization,

        /// <summary>Dummy version to allow us to Fix up the fact that ReleaseObjectVersion was changed elsewhere</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        ReleaseUE4VersionFixup,

        /// <summary>Pin types include a flag that propagates the 'CPF_UObjectWrapper' flag to generated properties</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        PinTypeIncludesUObjectWrapperFlag,

        /// <summary>Added Weight member to FMeshToMeshVertData</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        WeightFMeshToMeshVertData,

        /// <summary>Animation graph node bindings displayed as pins</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        AnimationGraphNodeBindingsDisplayedAsPins,

        /// <summary>Serialized rigvm offset segment paths</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        SerializeRigVMOffsetSegmentPaths,

        /// <summary>Upgrade AbcGeomCacheImportSettings for velocities</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        AbcVelocitiesSupport,

        /// <summary>Add margin support to Chaos Convex</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        MarginAddedToConvexAndBox,

        /// <summary>Add structure data to Chaos Convex</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        StructureDataAddedToConvex,

        /// <summary>Changed axis UI for LiveLink AxisSwitch Pre Processor</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        AddedFrontRightUpAxesToLiveLinkPreProcessor,

        /// <summary>Some sequencer event sections that were copy-pasted left broken links to the director BP</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        FixupCopiedEventSections,

        /// <summary>Serialize the number of bytes written when serializing function arguments</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        RemoteControlSerializeFunctionArgumentsSize,

        /// <summary>Add loop counters to sequencer's compiled sub-sequence data</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        AddedSubSequenceEntryWarpCounter,

        /// <summary>Remove default resolution limit of 512 pixels for cubemaps generated from long-lat sources</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        LonglatTextureCubeDefaultMaxResolution,

        // bake center of mass into chaos cache
        [Introduced(EngineVersion.VER_UE5_0)]
        GeometryCollectionCacheRemovesMassToLocal,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    }

    /// <summary>
    /// Version used for serializing asset registry caches, both runtime and editor
    /// </summary>
    public enum FAssetRegistryVersion
    {
        /// <summary>From before file versioning was implemented</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        PreVersioning = 0,

        /// <summary>The first version of the runtime asset registry to include file versioning.</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        HardSoftDependencies,

        /// <summary>Added FAssetRegistryState and support for piecemeal serialization</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        AddAssetRegistryState,

        /// <summary>AssetData serialization format changed, versions before this are not readable</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        ChangedAssetData,

        /// <summary>Removed MD5 hash from package data</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        RemovedMD5Hash,

        /// <summary>Added hard/soft manage references</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        AddedHardManage,

        /// <summary>Added MD5 hash of cooked package to package data</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        AddedCookedMD5Hash,

        /// <summary>Added UE::AssetRegistry::EDependencyProperty to each dependency</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        AddedDependencyFlags,

        /// <summary>Major tag format change that replaces USE_COMPACT_ASSET_REGISTRY:</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        FixedTags,

        /// <summary>Added Version information to AssetPackageData</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        WorkspaceDomain,

        /// <summary>Added ImportedClasses to AssetPackageData</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        PackageImportedClasses,

        /// <summary>A new version number of UE5 was added to FPackageFileSummary</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        PackageFileSummaryVersionChange,

        /// <summary>Change to linker export/import resource serializationn</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        ObjectResourceOptionalVersionChange,

        /// <summary>Added FIoHash for each FIoChunkId in the package to the AssetPackageData.</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        AddedChunkHashes,

        /// <summary>Classes are serialized as path names rather than short object names, e.g. /Script/Engine.StaticMesh</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        ClassPaths,

        /// <summary>Asset bundles are serialized as FTopLevelAssetPath instead of FSoftObjectPath, deprecated FAssetData::ObjectPath</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        RemoveAssetPathFNames,

        /// <summary>Added header with bFilterEditorOnlyData flag</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        AddedHeader,

        /// <summary>Added Extension to AssetPackageData.</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        AssetPackageDataHasExtension,		

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    }

    public enum FSequencerObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        /// <summary>Per-platform overrides player overrides for media sources changed name and type.</summary>
        [Introduced(EngineVersion.VER_UE4_14)]
        RenameMediaSourcePlatformPlayers,

        /// <summary>Enable root motion isn't the right flag to use, but force root lock</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        ConvertEnableRootMotionToForceRootLock,

        /// <summary>Convert multiple rows to tracks</summary>
        [Introduced(EngineVersion.VER_UE4_15)]
        ConvertMultipleRowsToTracks,

        /// <summary>When finished now defaults to restore state</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        WhenFinishedDefaultsToRestoreState,

        /// <summary>EvaluationTree added</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        EvaluationTree,

        /// <summary>When finished now defaults to project default</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        WhenFinishedDefaultsToProjectDefault,

        /// <summary>Use int range rather than float range in FMovieSceneSegment</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        FloatToIntConversion,

        /// <summary>Purged old spawnable blueprint classes from level sequence assets</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        PurgeSpawnableBlueprints,

        /// <summary>Finish UMG evaluation on end</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        FinishUMGEvaluation,

        /// <summary>Manual serialization of float channel</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        SerializeFloatChannel,

        /// <summary>Change the linear keys so they act the old way and interpolate always.</summary>
        [Introduced(EngineVersion.VER_UE4_22)]
        ModifyLinearKeysForOldInterp,

        /// <summary>Full Manual serialization of float channel</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        SerializeFloatChannelCompletely,

        /// <summary>Set ContinuouslyRespawn to false by default, added FMovieSceneSpawnable::bNetAddressableName</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        SpawnableImprovements,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    }

    public enum FFortniteReleaseBranchCustomObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        /// <summary>Custom 14.10 File Object Version</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        DisableLevelset_v14_10,

        /// <summary>Add the long range attachment tethers to the cloth asset to avoid a large hitch during the cloth's initialization.</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosClothAddTethersToCachedData,

        /// <summary>Chaos::TKinematicTarget no longer stores a full transform, only position/rotation.</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosKinematicTargetRemoveScale,

        /// <summary>Move UCSModifiedProperties out of ActorComponent and in to sparse storage</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        ActorComponentUCSModifiedPropertiesSparseStorage,

        /// <summary>Fixup Nanite meshes which were using the wrong material and didn't have proper UVs :</summary>
        [Introduced(EngineVersion.VER_UE5_2)]
        FixupNaniteLandscapeMeshes,

        /// <summary>Remove any cooked collision data from nanite landscape / editor spline meshes since collisions are not needed there :</summary>
        [Introduced(EngineVersion.VER_UE5_2)]
        RemoveUselessLandscapeMeshesCookedCollisionData,

        /// <summary>Serialize out UAnimCurveCompressionCodec::InstanceGUID to maintain deterministic DDC key generation in cooked-editor</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        SerializeAnimCurveCompressionCodecGuidOnCook,

        /// <summary>Fix the Nanite landscape mesh being reused because of a bad name</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        FixNaniteLandscapeMeshNames,

        /// <summary>Fixup and synchronize shared properties modified before the synchronicity enforcement</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        LandscapeSharedPropertiesEnforcement,

        /// <summary>Include the cell size when computing the cell guid</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionRuntimeCellGuidWithCellSize,

        /// <summary>Enable SkipOnlyEditorOnly style cooking of NaniteOverrideMaterial</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        NaniteMaterialOverrideUsesEditorOnly,

        /// <summary>Store game thread particles data in single precision</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        SinglePrecisonParticleData,

        /// <summary>UPCGPoint custom serialization</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        PCGPointStructuredSerializer,

        /// <summary>Deprecation of Nav Movement Properties and moving them to a new struct</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        NavMovementComponentMovingPropertiesToStruct,

        /// <summary>Add bone serialization for dynamic mesh attributes</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        DynamicMeshAttributesSerializeBones,

        /// <summary>-----new versions can be added above this line-------------------------------------------------</summary>
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    }

    public enum FUE5ReleaseStreamObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        /// <summary>Added Lumen reflections to new reflection enum, changed defaults</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        ReflectionMethodEnum,

        /// <summary>Serialize HLOD info in WorldPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        WorldPartitionActorDescSerializeHLODInfo,

        /// <summary>Removing Tessellation from materials and meshes.</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        RemovingTessellation,

        /// <summary>LevelInstance serialize runtime behavior</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        LevelInstanceSerializeRuntimeBehavior,

        /// <summary>Refactoring Pose Asset runtime data structures</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        PoseAssetRuntimeRefactor,

        /// <summary>Serialize the folder path of actor descs</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        WorldPartitionActorDescSerializeActorFolderPath,

        /// <summary>Change hair strands vertex format</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        HairStrandsVertexFormatChange,

        /// <summary>Added max linear and angular speed to Chaos bodies</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        AddChaosMaxLinearAngularSpeed,

        /// <summary>PackedLevelInstance version</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        PackedLevelInstanceVersion,

        /// <summary>PackedLevelInstance bounds fix</summary>
        [Introduced(EngineVersion.VER_UE5_0EA)]
        PackedLevelInstanceBoundsFix,

        /// <summary>Custom property anim graph nodes (linked anim graphs, control rig etc.) now use optional pin manager</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        CustomPropertyAnimGraphNodesUseOptionalPinManager,

        /// <summary>Add native double and int64 support to FFormatArgumentData</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        TextFormatArgumentData64bitSupport,

        /// <summary>Material layer stacks are no longer considered 'static parameters'</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        MaterialLayerStacksAreNotParameters,

        /// <summary>CachedExpressionData is moved from UMaterial to UMaterialInterface</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        MaterialInterfaceSavedCachedData,

        /// <summary>Add support for multiple cloth deformer LODs to be able to raytrace cloth with a different LOD than the one it is rendered with</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        AddClothMappingLODBias,

        /// <summary>Add support for different external actor packaging schemes</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        AddLevelActorPackagingScheme,

        /// <summary>Add support for linking to the attached parent actor in WorldPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        WorldPartitionActorDescSerializeAttachParent,

        /// <summary>Converted AActor GridPlacement to bIsSpatiallyLoaded flag</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ConvertedActorGridPlacementToSpatiallyLoadedFlag,

        /// <summary>Fixup for bad default value for GridPlacement_DEPRECATED</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ActorGridPlacementDeprecateDefaultValueFixup,

        /// <summary>PackedLevelActor started using FWorldPartitionActorDesc (not currently checked against but added as a security)</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        PackedLevelActorUseWorldPartitionActorDesc,

        /// <summary>Add support for actor folder objects</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        AddLevelActorFolders,

        /// <summary>Remove FSkeletalMeshLODModel bulk datas</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        RemoveSkeletalMeshLODModelBulkDatas,

        /// <summary>Exclude brightness from the EncodedHDRCubemap,</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ExcludeBrightnessFromEncodedHDRCubemap,

        /// <summary>Unified volumetric cloud component quality sample count slider between main and reflection views for consistency</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        VolumetricCloudSampleCountUnification,

        /// <summary>Pose asset GUID generated from source AnimationSequence</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        PoseAssetRawDataGUID,

        /// <summary>Convolution bloom now take into account FPostProcessSettings::BloomIntensity for scatter dispersion.</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ConvolutionBloomIntensity,

        /// <summary>Serialize FHLODSubActors instead of FGuids in WorldPartition HLODActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        WorldPartitionHLODActorDescSerializeHLODSubActors,

        /// <summary>Large Worlds - serialize double types as doubles</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        LargeWorldCoordinates,

        /// <summary>Deserialize old BP float and double types as real numbers for pins</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        BlueprintPinsUseRealNumbers,

        /// <summary>Changed shadow defaults for directional light components, version needed to not affect old things</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        UpdatedDirectionalLightShadowDefaults,

        /// <summary>Refresh geometry collections that had not already generated convex bodies.</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        GeometryCollectionConvexDefaults,

        /// <summary>Add faster damping calculations to the cloth simulation and rename previous Damping parameter to LocalDamping.</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosClothFasterDamping,

        /// <summary>Serialize LandscapeActorGuid in FLandscapeActorDesc sub class.</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        WorldPartitionLandscapeActorDescSerializeLandscapeActorGuid,

        /// <summary>add inertia tensor and rotation of mass to convex </summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        AddedInertiaTensorAndRotationOfMassAddedToConvex,

        /// <summary>Storing inertia tensor as vec3 instead of matrix.</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChaosInertiaConvertedToVec3,

        /// <summary>For Blueprint real numbers, ensure that legacy float data is serialized as single-precision</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        SerializeFloatPinDefaultValuesAsSinglePrecision,

        /// <summary>Upgrade the BlendMasks array in existing LayeredBoneBlend nodes</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        AnimLayeredBoneBlendMasks,

        /// <summary>Uses RG11B10 format to store the encoded reflection capture data on mobile</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        StoreReflectionCaptureEncodedHDRDataInRG11B10Format,

        /// <summary>Add WithSerializer type trait and implementation for FRawAnimSequenceTrack</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        RawAnimSequenceTrackSerializer,

        /// <summary>Removed font from FEditableTextBoxStyle, and added FTextBlockStyle instead.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        RemoveDuplicatedStyleInfo,

        /// <summary>Added member reference to linked anim graphs</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        LinkedAnimGraphMemberReference,

        /// <summary>Changed default tangent behavior for new dynamic mesh components</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        DynamicMeshComponentsDefaultUseExternalTangents,

        /// <summary>Added resize methods to media capture</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        MediaCaptureNewResizeMethods,

        /// <summary>Function data stores a map from work to debug operands</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        RigVMSaveDebugMapInGraphFunctionData,

        /// <summary>Changed default Local Exposure Contrast Scale from 1.0 to 0.8</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        LocalExposureDefaultChangeFrom1,

        /// <summary>Serialize bActorIsListedInSceneOutliner in WorldPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        WorldPartitionActorDescSerializeActorIsListedInSceneOutliner,

        /// <summary>Disabled opencolorio display configuration by default</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        OpenColorIODisabledDisplayConfigurationDefault,

        /// <summary>Serialize ExternalDataLayerAsset in WorldPartitionActorDesc</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        WorldPartitionExternalDataLayers,

        /// <summary>Fix Chaos Cloth fictitious angular scale bug that requires existing parameter rescaling.</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        ChaosClothFictitiousAngularVelocitySubframeFix,

        /// <summary>Store physics thread particles data in single precision</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        SinglePrecisonParticleDataPT,

        /// <summary>Orthographic Near and Far Plane Auto-resolve enabled by default</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        OrthographicAutoNearFarPlane,

        /// <summary>-----new versions can be added above this line-------------------------------------------------</summary>
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    }

    public enum FNiagaraObjectVersion
    {
        /// <summary>Before any version changes were made</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        [Introduced(EngineVersion.VER_UE4_21)]
        SkeletalMeshVertexSampling = 1,

        /// <summary>-----new versions can be added above this line-------------------------------------------------</summary>
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,

        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    }

    public enum FNiagaraCustomVersion
    {
        /// <summary>Before any version changes were made in niagara</summary>
        [Introduced(EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)]
        BeforeCustomVersionWasAdded = 0,

        /// <summary>Reworked vm external function binding to be more robust.</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        VMExternalFunctionBindingRework,

        /// <summary>Making all Niagara files reference the version number, allowing post loading recompilation if necessary.</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        PostLoadCompilationEnabled,

        /// <summary>Moved some runtime cost from external functions into the binding step and used variadic templates to neaten that code greatly.</summary>
        [Introduced(EngineVersion.VER_UE4_16)]
        VMExternalFunctionBindingReworkPartDeux,

        /// <summary>Moved per instance data needed for certain data interfaces out to it's own struct.</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        DataInterfacePerInstanceRework,

        /// <summary>Added shader maps and corresponding infrastructure</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        NiagaraShaderMaps,

        /// <summary>Combined Spawn, Update, and Event scripts into one graph.</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        UpdateSpawnEventGraphCombination,

        /// <summary>Reworked data layout to store float and int data separately.</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        DataSetLayoutRework,

        /// <summary>Reworked scripts to support emitter and system scripts</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        AddedEmitterAndSystemScripts,

        /// <summary>Rework of script execution contexts to allow better reuse and reduce overhead of parameter handling. </summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        ScriptExecutionContextRework,

        /// <summary>Removed the Niagara variable ID's making hookup impossible until next compile</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        RemovalOfNiagaraVariableIDs,

        /// <summary>System and emitter script simulations.</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        SystemEmitterScriptSimulations,

        /// <summary>Adding integer random to VM. TODO: The vm really needs its own versioning system that will force a recompile when changes.</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        IntegerRandom,

        /// <summary>Added emitter spawn attributes</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        AddedEmitterSpawnAttributes,

        /// <summary>cooking of shader maps and corresponding infrastructure</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        NiagaraShaderMapCooking,

        /// <summary>don't serialize shader maps for system scripts</summary>
        [Introduced(EngineVersion.VER_UE4_18)]
        NiagaraShaderMapCooking2,

        /// <summary>Added script rapid iteration variables, usually top-level module parameters...</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        AddedScriptRapidIterationVariables,

        /// <summary>Added type to data interface infos</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        AddedTypeToDataInterfaceInfos,

        /// <summary>Hooked up autogenerated default values for function call nodes.</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        EnabledAutogeneratedDefaultValuesForFunctionCallNodes,

        /// <summary>Now curve data interfaces have look-up tables on by default.</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        CurveLUTNowOnByDefault,

        /// <summary>Scripts now use a guid for identification instead of an index when there are more than one with the same usage.</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        ScriptsNowUseAGuidForIdentificationInsteadOfAnIndex,

        /// <summary>don't serialize shader maps for update scripts</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        NiagaraCombinedGPUSpawnUpdate,

        /// <summary>don't serialize shader maps for emitters that don't run on gpu.</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        DontCompileGPUWhenNotNeeded,

        [Introduced(EngineVersion.VER_UE4_19)]
        LifeCycleRework,

        /// <summary>We weren't serializing event data sets previously.</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        NowSerializingReadWriteDataSets,

        /// <summary>Forcing the internal parameter map vars to be reset between emitter calls.</summary>
        [Introduced(EngineVersion.VER_UE4_19)]
        TranslatorClearOutBetweenEmitters,

        /// <summary>added sampler shader params based on DI buffer descriptors</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        AddSamplerDataInterfaceParams,

        /// <summary>Need to force the GPU shaders to recompile</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        GPUShadersForceRecompileNeeded,

        /// <summary>The playback range for the timeline is now stored in the system editor data.</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        PlaybackRangeStoredOnSystem,

        /// <summary>All cached values will auto-recompile.</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        MovedToDerivedDataCache,

        /// <summary>Data interfaces are preallocated</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        DataInterfacesNotAllocated,

        /// <summary>emitter scripts are built using "Emitter." instead of the full name.</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        EmittersHaveGenericUniqueNames,

        /// <summary>no longer have compiler version enum value in this list, instead moved to a guid, which works better for the DDC</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        MovingTranslatorVersionToGuid,

        /// <summary>adding a parameter map in/out to the data set base node</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        AddingParamMapToDataSetBaseNode,

        /// <summary>refactor of CS parameters allowing regular params as well as buffers.</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        DataInterfaceComputeShaderParamRefactor,

        /// <summary>bumping version and forcing curves to regen their LUT on version change.</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        CurveLUTRegen,

        /// <summary>Changing the graph generation for assignment nodes so that it uses a "Begin Defaults" node where appropriate.</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        AssignmentNodeUsesBeginDefaults,

        /// <summary>Updating the usage flage bitmask for assignment nodes to match the part of the stack it's used in.</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        AssignmentNodeHasCorrectUsageBitmask,

        /// <summary>Emitter local space is compiled into the hlsl as a literal constant to expose it to emitter scripts and allow for some better optimization of particle transforms.</summary>
        [Introduced(EngineVersion.VER_UE4_20)]
        EmitterLocalSpaceLiteralConstant,

        /// <summary>The cpu cache of the texture is now directly serialized instead of using array property serialization.</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        TextureDataInterfaceUsesCustomSerialize,

        /// <summary>The texture data interface now streams size info</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        TextureDataInterfaceSizeSerialize,

        /// <summary>API to skeletal mesh interface was improved but requires a recompile and some graph fixup.</summary>
        [Introduced(EngineVersion.VER_UE4_21)]
        SkelMeshInterfaceAPIImprovements,

        /// <summary>Only do op add pin fixup on existing nodes which are before this version</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        ImproveLoadTimeFixupOfOpAddPins,

        /// <summary>Moved commonly used input metadata out of the strin/string property metadata map to actual properties on the metadata struct.</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        MoveCommonInputMetadataToProperties,

        /// <summary>Move to using the traversed graph hash and the base script id for the FNiagaraVMExecutableDataId instead of the change id guid to prevent invalidating the DDC.</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        UseHashesToIdentifyCompileStateOfTopLevelScripts,

        /// <summary>Reworked how the metadata is stored in NiagaraGraph from storing a Map of FNiagaraVariableMetaData to storing a map of UNiagaraScriptVariable* to be used with the Details panel.</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        MetaDataAndParametersUpdate,

        /// <summary>Moved the emitter inheritance data from the emitter handle to the emitter to allow for chained emitter inheritance.</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        MoveInheritanceDataFromTheEmitterHandleToTheEmitter,

        /// <summary>Add property to all Niagara scripts indicating whether or not they belong to the library</summary>
        [Introduced(EngineVersion.VER_UE4_23)]
        AddLibraryAssetProperty,

        /// <summary>Addding additional defines to the GPU script</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        AddAdditionalDefinesProperty,

        /// <summary>Remove the random compile id guids from the cached script usage and from the compile and script ids since the hashes serve the same purpose and are deterministic.</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        RemoveGraphUsageCompileIds,

        /// <summary>Adding UseRapidIterationParams and DetailLevelMask to the GPU script</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        AddRIAndDetailLevel,

        /// <summary>Changing the system and emitter compiled data to shared pointers to deal with lifetime issues in the editor.  They now are handled directly in system serialize.</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        ChangeEmitterCompiledDataToSharedRefs,

        /// <summary>Sorting on Renderers is disabled by default, we add a version to maintain existing systems that expected sorting to be enabled</summary>
        [Introduced(EngineVersion.VER_UE4_24)]
        DisableSortingByDefault,

        /// <summary>Convert TMap into TArray to save memory, TMap contains an inline allocator which pushes the size to 80 bytes</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        MemorySaving,

        /// <summary>Added a new value to the script usage enum, and we need a custom version to fix the existing bitfields.</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        AddSimulationStageUsageEnum,

        /// <summary>Save the functions generated by a GPU data interface inside FNiagaraDataInterfaceGPUParamInfo</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        AddGeneratedFunctionsToGPUParamInfo,

        /// <summary>Removed DetailLevel in favor of FNiagaraPlatfomSet based selection of per platform settings.</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        PlatformScalingRefactor,

        /// <summary>Promote parameters used across script executions to the Dataset, and Demote unused parameters.</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        PrecompileNamespaceFixup,

        /// <summary>Postload fixup in UNiagaraGraph to fixup VariableToScriptVariable map entries being null.</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        FixNullScriptVariables,

        /// <summary>Move FNiagaraVariableMetaData from storing scope enum to storing registered scope name.</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        PrecompileNamespaceFixup2,

        /// <summary>Enable the simulation stage flag by default in the usage bitmask of modules and functions</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        SimulationStageInUsageBitmask,

        /// <summary>Fix graph parameter map parameters on post load so that they all have a consisten parsable format and update the UI to show and filter based on these formats.</summary>
        [Introduced(EngineVersion.VER_UE4_25)]
        StandardizeParameterNames,

        /// <summary>Make sure that UNiagaraComponents only have override maps for User variables.</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        ComponentsOnlyHaveUserVariables,

        /// <summary>Refactor the options for UV settings on the ribbon renderer.</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        RibbonRendererUVRefactor,

        /// <summary>Replace the TypeDefinition in VariableBase with an index into the type registry</summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        VariablesUseTypeDefRegistry,

        /// <summary>Expand the visibility options of the scripts to be able to hide a script completely from the user </summary>
        [Introduced(EngineVersion.VER_UE4_26)]
        AddLibraryVisibilityProperty,

        [Introduced(EngineVersion.VER_UE4_26)]
        SignificanceHandlers,

        /// <summary>Added support for multiple versions of script data</summary>
        [Introduced(EngineVersion.VER_UE4_27)]
        ModuleVersioning,

        [Introduced(EngineVersion.VER_UE4_27)]
        MoveDefaultValueFromFNiagaraVariableMetaDataToUNiagaraScriptVariable,

        /// <summary>Changed the default mode from deterministic to non-deterministic which matches emitters</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        ChangeSystemDeterministicDefault,

        /// <summary>Update static switch pins to use the PersistentId from their script variable so that when they're renamed their values aren't lost when reallocating pins.</summary>
        [Introduced(EngineVersion.VER_UE5_0)]
        StaticSwitchFunctionPinsUsePersistentGuids,

        /// <summary>Extended visibility culling options and moved properties into their own struct.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        VisibilityCullingImprovements,

        [Introduced(EngineVersion.VER_UE5_1)]
        AddBakerCameraBookmarks,

        /// <summary>Function call node refresh from external changes has been refactored so that they don't need to populate their name bindings every load.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        PopulateFunctionCallNodePinNameBindings,

        /// <summary>Changed the default value for the component renderer's OnlyCreateComponentsOnParticleSpawn property</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        ComponentRendererSpawnProperty,

        /// <summary>Previous repopulate didn't handle module attributes like Particles.Module.Name so they need to be repopulated for renaming to work correctly.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        RepopulateFunctionCallNodePinNameBindings,

        /// <summary>Event spawns now optionally update Initial. attribute values. New default is true but old data is kept false to maintain existing behavior.</summary>
        [Introduced(EngineVersion.VER_UE5_1)]
        EventSpawnsUpdateInitialAttributeValues,

        /// <summary>Adds list of variadic parameters to the information about GPU functions.</summary>
        [Introduced(EngineVersion.VER_UE5_2)]
        AddVariadicParametersToGPUFunctionInfo,

        /// <summary>Some data fixup for NiagaraNodeWithDynamicPins.</summary>
        [Introduced(EngineVersion.VER_UE5_2)]
        DynamicPinNodeFixup,

        /// <summary>Ribbon renderer will default to unique ID rather than normalized age to make more things 'just work'</summary>
        [Introduced(EngineVersion.VER_UE5_3)]
        RibbonRendererLinkOrderDefaultIsUniqueID,

        /// <summary>Renderer SubImage Blends are enabled by default</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        SubImageBlendEnabledByDefault,

        /// <summary>Ribbon renderer will use geometry normals by default rather than screen / facing aligned normals</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        RibbonPlaneUseGeometryNormals,

        /// <summary>Actors velocity is used for the initial velocity before the component has any tracking, old assets use the old zero velocity</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        InitialOwnerVelocityFromActor,

        /// <summary>FNiagaraParameterBindingWithValue wouldn't necessarily have the appropriate ResolvedParameter namespace when it comes to emitter merging</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        ParameterBindingWithValueRenameFixup,

        /// <summary>Sim Cache moved to bulk data by default</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        SimCache_BulkDataVersion1,

        /// <summary>Decoupling of 'Template' and 'Inheritance'</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        InheritanceUxRefactor,

        /// <summary>NDC Read DIs will not override spawn group by default when spawning particles. Old content will remain unchanged.</summary>
        [Introduced(EngineVersion.VER_UE5_4)]
        NDCSpawnGroupOverrideDisabledByDefault,

        /// <summary>Before it was normalized age which can introduce flickering with sorting and random lifetimes</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        CustomSortingBindingToAge,

        /// <summary>Update Initial Mesh Orientation Module</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        StatelessInitialMeshOrientationV1,

        /// <summary>Hierarchy Editor was implemented</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        HierarchyEditorScriptSupport,

        /// <summary>Added loop delay enabled to emitter state</summary>
        [Introduced(EngineVersion.VER_UE5_5)]
        EmitterStateAddLoopDelayEnabled,

        /// <summary>Make sure that we serialize the UsageBitMask with the GPUFunctionInfo</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        SerializeUsageBitMaskToGPUFunctionInfo,

        /// <summary>Changed the interpolated spawn property into an enum</summary>
        [Introduced(EngineVersion.VER_UE5_6)]
        AddedNewInterpolatedSpawnMode,

        /// <summary>Adding user asset tag storage in UMetaData for all UPackages</summary>
        [Introduced(EngineVersion.VER_UE5_7)]
        UserAssetTagStorageInMetaData,

        /// <summary>
        /// DO NOT ADD A NEW VERSION UNLESS YOU HAVE TALKED TO THE NIAGARA LEAD. Mismanagement of these versions can lead to data loss if it is adjusted in multiple streams simultaneously.
        /// -----new versions can be added above this line-------------------------------------------------
        /// </summary>
        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE)]
        VersionPlusOne,


        [Introduced(EngineVersion.VER_UE4_AUTOMATIC_VERSION)]
        LatestVersion = VersionPlusOne - 1
    }
}
```

`UAssetAPI/ExportTypes/ClassExport.cs`:

```cs
using Newtonsoft.Json;
using System.IO;
using System.Linq;
using UAssetAPI.JSON;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// Represents an interface that a UClass (<see cref="ClassExport"/>) implements.
    /// </summary>
    public struct SerializedInterfaceReference
    {
        public int Class;
        public int PointerOffset;
        public bool bImplementedByK2;

        public SerializedInterfaceReference(int @class, int pointerOffset, bool bImplementedByK2)
        {
            Class = @class;
            PointerOffset = pointerOffset;
            this.bImplementedByK2 = bImplementedByK2;
        }
    }

    /// <summary>
    /// Represents an object class.
    /// </summary>
    public class ClassExport : StructExport
    {
        /// <summary>
        /// Map of all functions by name contained in this class
        /// </summary>
        [JsonConverter(typeof(TMapJsonConverter<FName, FPackageIndex>))]
        public TMap<FName, FPackageIndex> FuncMap;

        /// <summary>
        /// Class flags; See <see cref="EClassFlags"/> for more information
        /// </summary>
        public EClassFlags ClassFlags;

        /// <summary>
        /// The required type for the outer of instances of this class
        /// </summary>
        public FPackageIndex ClassWithin;

        /// <summary>
        /// Which Name.ini file to load Config variables out of
        /// </summary>
        public FName ClassConfigName;

        /// <summary>
        /// The list of interfaces which this class implements, along with the pointer property that is located at the offset of the interface's vtable.
        /// If the interface class isn't native, the property will be empty.
        /// </summary>
        public SerializedInterfaceReference[] Interfaces;

        /// <summary>
        /// This is the blueprint that caused the generation of this class, or null if it is a native compiled-in class
        /// </summary>
        public FPackageIndex ClassGeneratedBy;

        /// <summary>
        /// Does this class use deprecated script order?
        /// </summary>
        public bool bDeprecatedForceScriptOrder;

        /// <summary>
        /// Used to check if the class was cooked or not
        /// </summary>
        public bool bCooked;

        /// <summary>
        /// The class default object; used for delta serialization and object initialization
        /// </summary>
        public FPackageIndex ClassDefaultObject;

        public ClassExport(Export super) : base(super)
        {

        }

        public ClassExport(UAsset asset, byte[] extras) : base(asset, extras)
        {

        }

        public ClassExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);

            int numFuncIndexEntries = reader.ReadInt32();
            FuncMap = new TMap<FName, FPackageIndex>();
            for (int i = 0; i < numFuncIndexEntries; i++)
            {
                FName functionName = reader.ReadFName();
                FPackageIndex functionExport = FPackageIndex.FromRawIndex(reader.ReadInt32());

                FuncMap.Add(functionName, functionExport);
            }

            ClassFlags = (EClassFlags)reader.ReadUInt32();

            if (Asset.ObjectVersion < ObjectVersion.VER_UE4_CLASS_NOTPLACEABLE_ADDED)
            {
                ClassFlags ^= EClassFlags.CLASS_NotPlaceable;
            }

            ClassWithin = new FPackageIndex(reader.ReadInt32());
            ClassConfigName = reader.ReadFName();
            Asset.AddNameReference(ClassConfigName.Value);

            int numInterfaces = 0;
            long interfacesStart = 0;
            if (Asset.ObjectVersion < ObjectVersion.VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING)
            {
                interfacesStart = reader.BaseStream.Position;
                numInterfaces = reader.ReadInt32();
                reader.BaseStream.Seek(interfacesStart + sizeof(int) + numInterfaces * (sizeof(int) * 3), SeekOrigin.Begin);
            }

            // Linking procedure here; I don't think anything is really serialized during this
            ClassGeneratedBy = new FPackageIndex(reader.ReadInt32());

            long currentOffset = reader.BaseStream.Position;
            if (Asset.ObjectVersion < ObjectVersion.VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING)
            {
                reader.BaseStream.Seek(interfacesStart, SeekOrigin.Begin);
            }
            numInterfaces = reader.ReadInt32();
            Interfaces = new SerializedInterfaceReference[numInterfaces];
            for (int i = 0; i < numInterfaces; i++)
            {
                Interfaces[i] = new SerializedInterfaceReference(reader.ReadInt32(), reader.ReadInt32(), reader.ReadInt32() == 1);
            }
            if (Asset.ObjectVersion < ObjectVersion.VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING)
            {
                reader.BaseStream.Seek(currentOffset, SeekOrigin.Begin);
            }

            bDeprecatedForceScriptOrder = reader.ReadInt32() == 1;

            reader.ReadInt64(); // None

            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_ADD_COOKED_TO_UCLASS)
            {
                bCooked = reader.ReadInt32() == 1;
            }

            ClassDefaultObject = new FPackageIndex(reader.ReadInt32());

            // CDO serialization usually comes after this export has finished serializing
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            writer.Write(FuncMap.Count);
            for (int i = 0; i < FuncMap.Count; i++)
            {
                writer.Write(FuncMap.Keys.ElementAt(i));
                writer.Write(FuncMap[i].Index);
            }

            EClassFlags serializingClassFlags = ClassFlags;
            if (Asset.ObjectVersion < ObjectVersion.VER_UE4_CLASS_NOTPLACEABLE_ADDED)
            {
                serializingClassFlags ^= EClassFlags.CLASS_NotPlaceable;
            }
            writer.Write((uint)serializingClassFlags);

            writer.Write(ClassWithin.Index);
            writer.Write(ClassConfigName);

            if (Asset.ObjectVersion < ObjectVersion.VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING)
            {
                SerializeInterfaces(writer);
            }

            // Linking procedure here; I don't think anything is really serialized during this
            writer.Write(ClassGeneratedBy.Index);

            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING)
            {
                SerializeInterfaces(writer);
            }

            writer.Write(bDeprecatedForceScriptOrder ? 1 : 0);

            writer.Write(new FName(writer.Asset, "None"));

            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_ADD_COOKED_TO_UCLASS)
            {
                writer.Write(bCooked ? 1 : 0);
            }

            writer.Write(ClassDefaultObject.Index);
        }

        private void SerializeInterfaces(BinaryWriter writer)
        {
            writer.Write(Interfaces.Length);
            for (int i = 0; i < Interfaces.Length; i++)
            {
                writer.Write(Interfaces[i].Class);
                writer.Write(Interfaces[i].PointerOffset);
                writer.Write(Interfaces[i].bImplementedByK2 ? 1 : 0);
            }
        }
    }
}

```

`UAssetAPI/ExportTypes/DataTableExport.cs`:

```cs
using System.Collections.Generic;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;
using System.Reflection.PortableExecutable;

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// Imported spreadsheet table.
    /// </summary>
    public class UDataTable
    {
        public List<StructPropertyData> Data;

        public UDataTable()
        {
            Data = new List<StructPropertyData>();
        }

        public UDataTable(List<StructPropertyData> data)
        {
            Data = data;
        }
    }

    /// <summary>
    /// Export for an imported spreadsheet table. See <see cref="UDataTable"/>.
    /// </summary>
    public class DataTableExport : NormalExport
    {
        /// <summary>
        /// Gets or sets the value associated with the specified key. This operation loops linearly, so it may not be suitable for high-performance environments.
        /// </summary>
        /// <param name="key">The key associated with the value to get or set.</param>
        public override PropertyData this[FName key]
        {
            get
            {
                for (int i = 0; i < Data.Count; i++)
                {
                    if (Data[i].Name == key) return Data[i];
                }
                for (int i = 0; i < Table.Data.Count; i++)
                {
                    if (Table.Data[i].Name == key) return Table.Data[i];
                }
                return null;
            }
            set
            {
                value.Name = key;

                for (int i = 0; i < Data.Count; i++)
                {
                    if (Data[i].Name == key)
                    {
                        Data[i] = value;
                        return;
                    }
                }

                if (value is StructPropertyData)
                {
                    for (int i = 0; i < Table.Data.Count; i++)
                    {
                        if (Table.Data[i].Name == key)
                        {
                            Table.Data[i] = (StructPropertyData)value;
                            return;
                        }
                    }

                    Table.Data.Add((StructPropertyData)value);
                }
                else
                {
                    Data.Add(value);
                }
            }
        }

        /// <summary>
        /// Gets or sets the value associated with the specified key. This operation loops linearly, so it may not be suitable for high-performance environments.
        /// </summary>
        /// <param name="key">The key associated with the value to get or set.</param>
        public override PropertyData this[string key]
        {
            get
            {
                return this[FName.FromString(Asset, key)];
            }
            set
            {
                this[FName.FromString(Asset, key)] = value;
            }
        }

        public UDataTable Table;

        public DataTableExport(Export super) : base(super)
        {

        }

        public DataTableExport(UDataTable data, UAsset asset, byte[] extras) : base(asset, extras)
        {
            Table = data;
        }

        public DataTableExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);

            // Find an ObjectProperty named RowStruct
            FName decidedStructType = FName.DefineDummy(reader.Asset, "Generic");
            foreach (PropertyData thisData in Data)
            {
                if (thisData.Name.Value.Value == "RowStruct" && thisData is ObjectPropertyData thisObjData && thisObjData.Value.IsImport())
                {
                    decidedStructType = thisObjData.ToImport(reader.Asset).ObjectName;
                    break;
                }
            }

            if (decidedStructType.ToString() == "Generic")
            {
                // overrides here...
                FName exportClassTypeName = this.GetExportClassType();
                string exportClassType = exportClassTypeName.Value.Value;
                switch(exportClassType)
                {
                    case "CommonGenericInputActionDataTable":
                        decidedStructType = FName.DefineDummy(reader.Asset, "CommonInputActionDataBase");
                        break;
                }
            }

            Table = new UDataTable();

            int numEntries = reader.ReadInt32();
            FName pcen = reader.Asset.GetParentClassExportName(out FName pcen2);
            for (int i = 0; i < numEntries; i++)
            {
                FName rowName = reader.ReadFName();
                var nextStruct = new StructPropertyData(rowName)
                {
                    StructType = decidedStructType
                };
                nextStruct.Ancestry.Initialize(null, pcen, pcen2);
                nextStruct.Read(reader, false, 1);
                Table.Data.Add(nextStruct);
            }
        }

        public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
        {
            var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
            FName pcen = asset.GetParentClassExportName(out FName pcen2);
            ancestryNew.SetAsParent(pcen, pcen2);

            if (Data != null)
            {
                for (int i = 0; i < Data.Count; i++) Data[i]?.ResolveAncestries(asset, ancestryNew);
            }
            if (Table?.Data != null)
            {
                for (int i = 0; i < Table.Data.Count; i++) Table.Data[i]?.ResolveAncestries(asset, ancestryNew);
            }
            base.ResolveAncestries(asset, ancestrySoFar);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            // Find an ObjectProperty named RowStruct
            FName decidedStructType = FName.DefineDummy(writer.Asset, "Generic");
            foreach (PropertyData thisData in Data)
            {
                if (thisData.Name.Value.Value == "RowStruct" && thisData is ObjectPropertyData thisObjData)
                {
                    decidedStructType = thisObjData.ToImport(writer.Asset).ObjectName;
                    break;
                }
            }

            if (decidedStructType.ToString() == "Generic")
            {
                // overrides here...
                FName exportClassTypeName = this.GetExportClassType();
                string exportClassType = exportClassTypeName.Value.Value;
                switch (exportClassType)
                {
                    case "CommonGenericInputActionDataTable":
                        decidedStructType = FName.DefineDummy(writer.Asset, "CommonInputActionDataBase");
                        break;
                }
            }

            writer.Write(Table.Data.Count);
            for (int i = 0; i < Table.Data.Count; i++)
            {
                var thisDataTableEntry = Table.Data[i];
                thisDataTableEntry.StructType = decidedStructType;
                writer.Write(thisDataTableEntry.Name);
                thisDataTableEntry.Write(writer, false);
            }
        }
    }
}

```

`UAssetAPI/ExportTypes/EnumExport.cs`:

```cs
using System;
using System.Collections.Generic;
using UAssetAPI.CustomVersions;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.ExportTypes
{
    /// <summary>How this enum is declared in C++. Affects the internal naming of enum values.</summary>
    public enum ECppForm
    {
        Regular,
		Namespaced,
		EnumClass
    }

    /// <summary>
    /// Reflection data for an enumeration.
    /// </summary>
    public class UEnum
    {
        /// <summary>List of pairs of all enum names and values.</summary>
        public List<Tuple<FName, long>> Names;

        /// <summary>How the enum was originally defined.</summary>
        public ECppForm CppForm = ECppForm.Regular;

        public void Read(AssetBinaryReader reader, UAsset asset)
        {
            if (asset.ObjectVersion < ObjectVersion.VER_UE4_TIGHTLY_PACKED_ENUMS)
            {
                int numEntries = reader.ReadInt32();
                for (int i = 0; i < numEntries; i++)
                {
                    FName tempName = reader.ReadFName();
                    Names.Add(new Tuple<FName, long>(tempName, i));
                }
            }
            else if (asset.GetCustomVersion<FCoreObjectVersion>() < FCoreObjectVersion.EnumProperties)
            {
                int numEntries = reader.ReadInt32();
                for (int i = 0; i < numEntries; i++)
                {
                    FName tempName = reader.ReadFName();
                    byte tempVal = reader.ReadByte();
                    Names.Add(new Tuple<FName, long>(tempName, tempVal));
                }
            }
            else
            {
                int numEntries = reader.ReadInt32();
                for (int i = 0; i < numEntries; i++)
                {
                    FName tempName = reader.ReadFName();
                    long tempVal = reader.ReadInt64();
                    Names.Add(new Tuple<FName, long>(tempName, tempVal));
                }
            }

            if (asset.ObjectVersion < ObjectVersion.VER_UE4_ENUM_CLASS_SUPPORT)
            {
                bool bIsNamespace = reader.ReadInt32() == 1;
                CppForm = bIsNamespace ? ECppForm.Namespaced : ECppForm.Regular;
            }
            else
            {
                CppForm = (ECppForm)reader.ReadByte();
            }
        }

        public void Write(AssetBinaryWriter writer, UAsset asset)
        {
            writer.Write(Names.Count);
            if (asset.ObjectVersion < ObjectVersion.VER_UE4_TIGHTLY_PACKED_ENUMS)
            {
                var namesForSerialization = new Dictionary<long, FName>();
                for (int i = 0; i < Names.Count; i++) namesForSerialization.Add(Names[i].Item2, Names[i].Item1);
                for (int i = 0; i < Names.Count; i++)
                {
                    if (namesForSerialization.ContainsKey(i)) writer.Write(namesForSerialization[i]);
                }
            }
            else if (asset.GetCustomVersion<FCoreObjectVersion>() < FCoreObjectVersion.EnumProperties)
            {
                for (int i = 0; i < Names.Count; i++)
                {
                    writer.Write(Names[i].Item1);
                    writer.Write((byte)Names[i].Item2);
                }
            }
            else
            {
                for (int i = 0; i < Names.Count; i++)
                {
                    writer.Write(Names[i].Item1);
                    writer.Write(Names[i].Item2);
                }
            }

            if (asset.ObjectVersion < ObjectVersion.VER_UE4_ENUM_CLASS_SUPPORT)
            {
                writer.Write(CppForm == ECppForm.Namespaced ? 1 : 0);
            }
            else
            {
                writer.Write((byte)CppForm);
            }
        }

        public UEnum()
        {
            Names = new List<Tuple<FName, long>>();
        }
    }

    /// <summary>
    /// Export data for an enumeration. See <see cref="UEnum"/>.
    /// </summary>
    public class EnumExport : NormalExport
    {
        /// <summary>The enum that is stored in this export.</summary>
        public UEnum Enum;

        public EnumExport(Export super) : base(super)
        {

        }

        public EnumExport(UAsset asset, byte[] extras) : base(asset, extras)
        {

        }

        public EnumExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);

            Enum = new UEnum();
            Enum.Read(reader, Asset);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            Enum.Write(writer, Asset);
        }
    }
}

```

`UAssetAPI/ExportTypes/Export.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.ExportTypes
{
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
    internal class DisplayIndexOrderAttribute : Attribute
    {
        internal int DisplayingIndex = 0;
        internal bool IsIoStore = false;
        internal bool IsTraditional = true;
        internal DisplayIndexOrderAttribute(int displayingIndex, bool isIoStore = false, bool isTraditional = true)
        {
            DisplayingIndex = displayingIndex;
            IsIoStore = isIoStore;
            IsTraditional = isTraditional;
        }
    }

    /// <summary>
    /// Enum used to determine whether an export should be loaded or not on the client/server. Not actually a bitflag.
    /// </summary>
    public enum EExportFilterFlags : byte
    {
        None,
	    NotForClient,
	    NotForServer
    }

    /// <summary>
    /// UObject resource type for objects that are contained within this package and can be referenced by other packages.
    /// </summary>
    [JsonObject(MemberSerialization.OptOut)]
    public class Export : ICloneable
    {
        ///<summary>The name of the UObject represented by this resource.</summary>
        [DisplayIndexOrder(0, true)]
        public FName ObjectName;
        ///<summary>Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage</summary>
        [DisplayIndexOrder(1)]
        public FPackageIndex OuterIndex;
        ///<summary>Location of this export's class (import/other export). 0 = this export is a UClass</summary>
        [DisplayIndexOrder(2)]
        public FPackageIndex ClassIndex;
        ///<summary>Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct</summary>
        [DisplayIndexOrder(3)]
        public FPackageIndex SuperIndex;
        ///<summary>Location of this export's template (import/other export). 0 = there is some problem</summary>
        [DisplayIndexOrder(4)]
        public FPackageIndex TemplateIndex;
        ///<summary>The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.</summary>
        [DisplayIndexOrder(5, true)]
        public EObjectFlags ObjectFlags;
        ///<summary>The number of bytes to serialize when saving/loading this export's UObject.</summary>
        [DisplayIndexOrder(6, true)]
        public long SerialSize;
        ///<summary>The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.</summary>
        [DisplayIndexOrder(7, true)]
        public long SerialOffset;

        /// <summary>
        /// The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
        /// Serialized into packages using tagged property serialization as of <see cref="ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET"/> (5.4).
        /// </summary>
        [DisplayIndexOrder(8)]
        public long ScriptSerializationStartOffset;
        /// <summary>
        /// The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
        /// Serialized into packages using tagged property serialization as of <see cref="ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET"/> (5.4)
        /// </summary>
        [DisplayIndexOrder(9)]
        public long ScriptSerializationEndOffset;

        ///<summary>Was this export forced into the export table via OBJECTMARK_ForceTagExp?</summary>
        [DisplayIndexOrder(10)]
        public bool bForcedExport;
        ///<summary>Should this export not be loaded on clients?</summary>
        [DisplayIndexOrder(11, true)]
        public bool bNotForClient;
        ///<summary>Should this export not be loaded on servers?</summary>
        [DisplayIndexOrder(12, true)]
        public bool bNotForServer;
        ///<summary>If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated</summary>
        [DisplayIndexOrder(13)]
        public Guid PackageGuid;
        ///<summary></summary>
        [DisplayIndexOrder(14)]
        public bool IsInheritedInstance;
        ///<summary>If this export is a top-level package, this is the flags for the original package</summary>
        [DisplayIndexOrder(15)]
        public EPackageFlags PackageFlags;
        ///<summary>Should this export be always loaded in editor game?</summary>
        [DisplayIndexOrder(16)]
        public bool bNotAlwaysLoadedForEditorGame;
        ///<summary>Is this export an asset?</summary>
        [DisplayIndexOrder(17)]
        public bool bIsAsset;
        ///<summary></summary>
        [DisplayIndexOrder(18)]
        public bool GeneratePublicHash;

        /// <summary>
        /// The export table must serialize as a fixed size, this is used to index into a long list, which is later loaded into the array. -1 means dependencies are not present. These are contiguous blocks, so CreateBeforeSerializationDependencies starts at FirstExportDependency + SerializationBeforeSerializationDependencies.
        /// </summary>
        internal int FirstExportDependencyOffset;
        internal int SerializationBeforeSerializationDependenciesSize;
        internal int CreateBeforeSerializationDependenciesSize;
        internal int SerializationBeforeCreateDependenciesSize;
        internal int CreateBeforeCreateDependenciesSize;

        [DisplayIndexOrder(19)]
        public List<FPackageIndex> SerializationBeforeSerializationDependencies = new List<FPackageIndex>();
        [DisplayIndexOrder(20)]
        public List<FPackageIndex> CreateBeforeSerializationDependencies = new List<FPackageIndex>();
        [DisplayIndexOrder(21)]
        public List<FPackageIndex> SerializationBeforeCreateDependencies = new List<FPackageIndex>();
        [DisplayIndexOrder(22)]
        public List<FPackageIndex> CreateBeforeCreateDependencies = new List<FPackageIndex>();

        /// <summary>
        /// Miscellaneous, unparsed export data, stored as a byte array.
        /// </summary>
        public byte[] Extras;

        /// <summary>
        /// The asset that this export is parsed with.
        /// </summary>
        [JsonIgnore]
        public UAsset Asset;

        [JsonIgnore]
        internal bool alreadySerialized = false;

        public Export(UAsset asset, byte[] extras)
        {
            Asset = asset;
            Extras = extras;
        }

        public Export()
        {

        }

        public virtual void Read(AssetBinaryReader reader, int nextStarting = 0)
        {

        }

        /// <summary>
        /// Resolves the ancestry of all child properties of this export.
        /// </summary>
        public virtual void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
        {

        }

        public virtual void Write(AssetBinaryWriter writer)
        {

        }

        // https://github.com/EpicGames/UnrealEngine/commit/1952a8b65290bc5b492f87d57fce87c809e231a0
        // this commit doesn't seem to actually make any changes to how bools are serialized
        private bool ReadBit(AssetBinaryReader reader)
        {
            return reader.ReadInt32() == 1;
        }

        private void WriteBit(AssetBinaryWriter writer, bool b)
        {
            writer.Write(b ? 1 : 0);
        }

        public void ReadExportMapEntry(AssetBinaryReader reader)
        {
            Asset = reader.Asset;

            this.ClassIndex = new FPackageIndex(reader.ReadInt32());
            this.SuperIndex = new FPackageIndex(reader.ReadInt32());
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_TemplateIndex_IN_COOKED_EXPORTS)
            {
                this.TemplateIndex = new FPackageIndex(reader.ReadInt32());
            }
            this.OuterIndex = new FPackageIndex(reader.ReadInt32());
            this.ObjectName = reader.ReadFName();
            this.ObjectFlags = (EObjectFlags)reader.ReadUInt32();
            if (Asset.ObjectVersion < ObjectVersion.VER_UE4_64BIT_EXPORTMAP_SERIALSIZES)
            {
                this.SerialSize = reader.ReadInt32();
                this.SerialOffset = reader.ReadInt32();
            }
            else
            {
                this.SerialSize = reader.ReadInt64();
                this.SerialOffset = reader.ReadInt64();
            }
            this.bForcedExport = ReadBit(reader);
            this.bNotForClient = ReadBit(reader);
            this.bNotForServer = ReadBit(reader);
            if (Asset.ObjectVersionUE5 < ObjectVersionUE5.REMOVE_OBJECT_EXPORT_PACKAGE_GUID) this.PackageGuid = new Guid(reader.ReadBytes(16));
            if (Asset.ObjectVersionUE5 >= ObjectVersionUE5.TRACK_OBJECT_EXPORT_IS_INHERITED) this.IsInheritedInstance = ReadBit(reader);
            this.PackageFlags = (EPackageFlags)reader.ReadUInt32();
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_LOAD_FOR_EDITOR_GAME)
            {
                this.bNotAlwaysLoadedForEditorGame = ReadBit(reader);
            }
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_COOKED_ASSETS_IN_EDITOR_SUPPORT)
            {
                this.bIsAsset = ReadBit(reader);
            }
            if (Asset.ObjectVersionUE5 >= ObjectVersionUE5.OPTIONAL_RESOURCES)
            {
                this.GeneratePublicHash = ReadBit(reader);
            }
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS)
            {
                this.FirstExportDependencyOffset = reader.ReadInt32();
                this.SerializationBeforeSerializationDependenciesSize = reader.ReadInt32();
                this.CreateBeforeSerializationDependenciesSize = reader.ReadInt32();
                this.SerializationBeforeCreateDependenciesSize = reader.ReadInt32();
                this.CreateBeforeCreateDependenciesSize = reader.ReadInt32();
            }
            if (!Asset.HasUnversionedProperties && Asset.ObjectVersionUE5 >= ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET)
            {
                this.ScriptSerializationStartOffset = reader.ReadInt64();
                this.ScriptSerializationEndOffset = reader.ReadInt64();
            }
        }

        public static long GetExportMapEntrySize(UAsset asset)
        {
            AssetBinaryWriter testWriter = new AssetBinaryWriter(new MemoryStream(127), asset);
            new Export().WriteExportMapEntry(testWriter);
            
            long res = testWriter.BaseStream.Position;
            testWriter.Dispose();
            return res;
        }

        public void WriteExportMapEntry(AssetBinaryWriter writer)
        {
            Asset = writer.Asset;

            writer.Write(ClassIndex?.Index ?? 0);
            writer.Write(SuperIndex?.Index ?? 0);
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_TemplateIndex_IN_COOKED_EXPORTS)
            {
                writer.Write(TemplateIndex?.Index ?? 0);
            }
            writer.Write(OuterIndex?.Index ?? 0);
            writer.Write(ObjectName);
            writer.Write((uint)ObjectFlags);
            if (Asset.ObjectVersion < ObjectVersion.VER_UE4_64BIT_EXPORTMAP_SERIALSIZES)
            {
                writer.Write((int)SerialSize);
                writer.Write((int)SerialOffset);
            }
            else
            {
                writer.Write(SerialSize);
                writer.Write(SerialOffset);
            }
            WriteBit(writer, bForcedExport);
            WriteBit(writer, bNotForClient);
            WriteBit(writer, bNotForServer);
            if (Asset.ObjectVersionUE5 < ObjectVersionUE5.REMOVE_OBJECT_EXPORT_PACKAGE_GUID) writer.Write(PackageGuid.ToByteArray());
            if (Asset.ObjectVersionUE5 >= ObjectVersionUE5.TRACK_OBJECT_EXPORT_IS_INHERITED) WriteBit(writer, IsInheritedInstance);
            writer.Write((uint)PackageFlags);
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_LOAD_FOR_EDITOR_GAME)
            {
                WriteBit(writer, bNotAlwaysLoadedForEditorGame);
            }
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_COOKED_ASSETS_IN_EDITOR_SUPPORT)
            {
                WriteBit(writer, bIsAsset);
            }
            if (Asset.ObjectVersionUE5 >= ObjectVersionUE5.OPTIONAL_RESOURCES)
            {
                WriteBit(writer, GeneratePublicHash);
            }
            if (Asset.ObjectVersion >= ObjectVersion.VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS)
            {
                writer.Write(FirstExportDependencyOffset);
                writer.Write(SerializationBeforeSerializationDependenciesSize);
                writer.Write(CreateBeforeSerializationDependenciesSize);
                writer.Write(SerializationBeforeCreateDependenciesSize);
                writer.Write(CreateBeforeCreateDependenciesSize);
            }
            if (!Asset.HasUnversionedProperties && Asset.ObjectVersionUE5 >= ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET)
            {
                writer.Write(ScriptSerializationStartOffset);
                writer.Write(ScriptSerializationEndOffset);
            }
        }

        private static MemberInfo[] _allFields = null;
        private static void InitAllFields()
        {
            if (_allFields != null) return;
            _allFields = UAPUtils.GetOrderedMembers<Export>();
        }

        public static MemberInfo[] GetAllObjectExportFields(UAsset asset)
        {
            InitAllFields();

            var finalFields = new List<MemberInfo>();
            for (int i = 0; i < _allFields.Length; i++)
            {
                if (_allFields[i] == null) continue;
                DisplayIndexOrderAttribute attr = ((DisplayIndexOrderAttribute[])_allFields[i]?.GetCustomAttributes(typeof(DisplayIndexOrderAttribute), true))?[0];
                if (attr == null) continue;
                if (asset is UAsset && !attr.IsTraditional) continue;
                finalFields.Add(_allFields[i]);
            }
            return finalFields.ToArray();
        }

        public static string[] GetAllFieldNames(UAsset asset)
        {
            InitAllFields();

            MemberInfo[] relevantFields = GetAllObjectExportFields(asset);
            string[] allFieldNames = new string[relevantFields.Length];
            for (int i = 0; i < relevantFields.Length; i++)
            {
                allFieldNames[i] = relevantFields[i].Name;
            }
            return allFieldNames;
        }

        public FName GetExportClassType()
        {
            return this.ClassIndex.IsImport() ? this.ClassIndex.ToImport(Asset).ObjectName : FName.DefineDummy(Asset, this.ClassIndex.Index.ToString());
        }

        public FName GetClassTypeForAncestry(UAsset asset, out FName modulePath)
        {
            if (asset == null) asset = Asset;
            return GetClassTypeForAncestry(this.ClassIndex, asset, out modulePath);
        }

        public static FName GetClassTypeForAncestry(FPackageIndex classIndex, UAsset asset, out FName modulePath)
        {
            modulePath = null;
            if (classIndex.IsNull()) return null;
            if (classIndex.IsExport()) return classIndex.ToExport(asset).ObjectName;

            var imp = classIndex.ToImport(asset);
            if (imp.OuterIndex.IsImport()) modulePath = imp.OuterIndex.ToImport(asset).ObjectName;
            return imp.ObjectName;
        }

        public override string ToString()
        {
            InitAllFields();

            var sb = new StringBuilder();
            foreach (var info in _allFields)
            {
                DisplayIndexOrderAttribute attr = ((DisplayIndexOrderAttribute[])info?.GetCustomAttributes(typeof(DisplayIndexOrderAttribute), true))?[0];
                if (attr == null) continue;
                if (Asset is UAsset && !attr.IsTraditional) continue;

                var value = info.GetValue(this) ?? "(null)";
                sb.AppendLine(info.Name + ": " + value.ToString());
            }
            return sb.ToString();
        }

        public object Clone()
        {
            var res = (Export)MemberwiseClone();
            res.SerializationBeforeSerializationDependencies = this.SerializationBeforeSerializationDependencies.ToList();
            res.CreateBeforeSerializationDependencies = this.CreateBeforeSerializationDependencies.ToList();
            res.SerializationBeforeCreateDependencies = this.SerializationBeforeCreateDependencies.ToList();
            res.CreateBeforeCreateDependencies = this.CreateBeforeCreateDependencies.ToList();
            res.Extras = (byte[])this.Extras.Clone();
            res.PackageGuid = new Guid(this.PackageGuid.ToByteArray());
            return res;
        }

        /// <summary>
        /// Creates a child export instance with the same export details as the current export.
        /// </summary>
        /// <typeparam name="T">The type of child export to create.</typeparam>
        /// <returns>An instance of the child export type provided with the export details copied over.</returns>
        public T ConvertToChildExport<T>() where T : Export, new()
        {
            InitAllFields();

            Export res = new T();
            res.SerializationBeforeSerializationDependencies = this.SerializationBeforeSerializationDependencies.ToList();
            res.CreateBeforeSerializationDependencies = this.CreateBeforeSerializationDependencies.ToList();
            res.SerializationBeforeCreateDependencies = this.SerializationBeforeCreateDependencies.ToList();
            res.CreateBeforeCreateDependencies = this.CreateBeforeCreateDependencies.ToList();
            res.Asset = this.Asset;
            res.Extras = this.Extras;
            foreach (var info in _allFields)
            {
                info.SetValue(res, info.GetValue(this));
            }
            return (T)res;
        }
    }
}

```

`UAssetAPI/ExportTypes/FieldExport.cs`:

```cs
using UAssetAPI.FieldTypes;

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// Export data for a <see cref="UField"/>.
    /// </summary>
    public class FieldExport : NormalExport
    {
        public UField Field;

        public FieldExport(Export super) : base(super)
        {

        }

        public FieldExport(UAsset asset, byte[] extras) : base(asset, extras)
        {

        }

        public FieldExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);

            Field = new UField();
            Field.Read(reader);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            Field.Write(writer);
        }
    }
}

```

`UAssetAPI/ExportTypes/FunctionExport.cs`:

```cs
using System.IO;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// Export data for a blueprint function.
    /// </summary>
    public class FunctionExport : StructExport
    {
        public EFunctionFlags FunctionFlags;
        public FunctionExport(Export super) : base(super)
        {
            Asset = super.Asset;
            Extras = super.Extras;
        }

        public FunctionExport(UAsset asset, byte[] extras) : base(asset, extras)
        {

        }

        public FunctionExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);
            FunctionFlags = (EFunctionFlags)reader.ReadUInt32();
            // TODO
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write((uint)FunctionFlags);
            // TODO
        }
    }
}

```

`UAssetAPI/ExportTypes/LevelExport.cs`:

```cs
using System.Collections.Generic;
using UAssetAPI.CustomVersions;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.ExportTypes;

/// <summary>
/// URL structure.
/// </summary>
public struct FURL
{
    // Protocol, i.e. "unreal" or "http".
    public FString Protocol;
    // Optional hostname, i.e. "204.157.115.40" or "unreal.epicgames.com", blank if local.
    public FString Host;
    // Optional host port.
    public int Port;
    public int Valid;
    // Map name, i.e. "SkyCity", default is "Entry".
    public FString Map;
    // Options.
    public List<FString> Op;
    // Portal to enter through, default is "".
    public FString Portal;

    public FURL(AssetBinaryReader reader)
    {
        Protocol = reader.ReadFString();
        Host = reader.ReadFString();
        Map = reader.ReadFString();
        Portal = reader.ReadFString();
        var len = reader.ReadInt32();
        Op = new List<FString>(len);
        for (int i = 0; i < len; i++)
        {
            Op.Add(reader.ReadFString());
        }
        Port = reader.ReadInt32();
        Valid = reader.ReadInt32();
    }

    public int Write(AssetBinaryWriter writer){

        var offset = writer.BaseStream.Position;
        writer.Write(Protocol);
        writer.Write(Host);
        writer.Write(Map);
        writer.Write(Portal);
        writer.Write(Op.Count);
        for (int i = 0; i < Op.Count; i++)
        {
            writer.Write(Op[i]);
        }
        writer.Write(Port);
        writer.Write(Valid);
        return (int)(writer.BaseStream.Position-offset);
    }
}

public class LevelExport : NormalExport
{
    // Owner of TTransArray<AActor> Actors
    public FPackageIndex Owner;
    public List<FPackageIndex> Actors;
    public FURL URL;
    public FPackageIndex Model;
    public List<FPackageIndex> ModelComponents;
    public FPackageIndex LevelScriptActor;
    public FPackageIndex NavListStart;
    public FPackageIndex NavListEnd;
    //public FPrecomputedVisibilityHandler PrecomputedVisibilityHandler;
    //public FPrecomputedVolumeDistanceField PrecomputedVolumeDistanceField;

    public LevelExport(Export super) : base(super) { }

    public LevelExport(UAsset asset, byte[] extras) : base(asset, extras) { }

    public LevelExport(){ } 

    public override void Read(AssetBinaryReader reader, int nextStarting)
    {
        base.Read(reader, nextStarting);

        if (reader.Asset.GetCustomVersion<FReleaseObjectVersion>() < FReleaseObjectVersion.LevelTransArrayConvertedToTArray)
            Owner = new FPackageIndex(reader);

        int numIndexEntries = reader.ReadInt32();

        Actors = new List<FPackageIndex>(numIndexEntries);
        for (int i = 0; i < numIndexEntries; i++) {
            Actors.Add(new FPackageIndex(reader));
        }
        
        URL = new FURL(reader);

        Model = new FPackageIndex(reader);
        int numModelEntries = reader.ReadInt32();

        ModelComponents = new List<FPackageIndex>(numModelEntries);
        for (int i = 0; i < numModelEntries; i++)
        {
            ModelComponents.Add(new FPackageIndex(reader));
        }

        LevelScriptActor = new FPackageIndex(reader);
        NavListStart = new FPackageIndex(reader);
        NavListEnd = new FPackageIndex(reader);
        
        // TODO: Implement the rest of the properties
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);

        if (writer.Asset.GetCustomVersion<FReleaseObjectVersion>() < FReleaseObjectVersion.LevelTransArrayConvertedToTArray)
            Owner.Write(writer);

        writer.Write(Actors.Count);
        for (int i = 0; i < Actors.Count; i++)
        {
            Actors[i].Write(writer);
        }

        URL.Write(writer);

        Model.Write(writer);
        writer.Write(ModelComponents.Count);
        for (int i = 0; i < ModelComponents.Count; i++)
        {
            ModelComponents[i].Write(writer);
        }

        LevelScriptActor.Write(writer);
        NavListStart.Write(writer);
        NavListEnd.Write(writer);
    }
}

```

`UAssetAPI/ExportTypes/MetaDataExport.cs`:

```cs
using Newtonsoft.Json;
using System.Collections.Generic;
using UAssetAPI.CustomVersions;
using UAssetAPI.JSON;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.ExportTypes
{
    public struct ObjectMetaDataEntry
    {
        public int Import;
        [JsonConverter(typeof(TMapJsonConverter<FName, FString>))]
        public TMap<FName, FString> MetaData;
        
        public ObjectMetaDataEntry(int import, TMap<FName, FString> metaData)
        {
            Import = import;
            MetaData = metaData;
        }
    }

    public class MetaDataExport : NormalExport
    {
        public List<ObjectMetaDataEntry> ObjectMetaData;
        [JsonConverter(typeof(TMapJsonConverter<FName, FString>))]
        public TMap<FName, FString> RootMetaData;

        public MetaDataExport(Export super) : base(super)
        {

        }

        public MetaDataExport(UAsset asset, byte[] extras) : base(asset, extras)
        {

        }

        public MetaDataExport()
        {

        }
        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);

            {
                ObjectMetaData = [];
                var objectMetaDataMapCount = reader.ReadInt32();
                for (var i = 0; i < objectMetaDataMapCount; i++)
                {
                    var import = reader.ReadInt32();
                    var metaDataCount = reader.ReadInt32();
                    var metaData = new TMap<FName, FString>();
                    for (var j = 0; j < metaDataCount; j++)
                    {
                        var key = reader.ReadFName();
                        var value = reader.ReadFString();
                        metaData.Add(key, value);
                    }
                    ObjectMetaData.Add(new ObjectMetaDataEntry(import, metaData));
                }
            }

            if (reader.Asset.GetCustomVersion<FEditorObjectVersion>() >= FEditorObjectVersion.RootMetaDataSupport)
            {
                RootMetaData = [];
                var rootMetaDataMapCount = reader.ReadInt32();
                for (var i = 0; i < rootMetaDataMapCount; i++)
                {
                    var key = reader.ReadFName();
                    var value = reader.ReadFString();
                    RootMetaData.Add(key, value);
                }
            }
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            writer.Write(ObjectMetaData.Count);
            foreach (var entry in ObjectMetaData)
            {
                writer.Write(entry.Import);
                writer.Write(entry.MetaData.Count);
                foreach (var entry2 in entry.MetaData)
                {
                    writer.Write(entry2.Key);
                    writer.Write(entry2.Value);
                }
            }

            if (writer.Asset.GetCustomVersion<FEditorObjectVersion>() >= FEditorObjectVersion.RootMetaDataSupport)
            {
                writer.Write(RootMetaData.Count);
                foreach ((var key, var value) in RootMetaData)
                {
                    writer.Write(key);
                    writer.Write(value);
                }
            }
        }
    }
}

```

`UAssetAPI/ExportTypes/NormalExport.cs`:

```cs
using System;
using System.Collections.Generic;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// Enum flags that indicate that additional data may be serialized prior to actual tagged property serialization
    /// Those extensions are used to store additional function to control how TPS will resolved. e.g. use overridable serialization
    /// </summary>
    public enum EClassSerializationControlExtension
    {
        NoExtension = 0x00,
        ReserveForFutureUse = 0x01, // Can be use to add a next group of extension

        ////////////////////////////////////////////////
        // First extension group
        OverridableSerializationInformation = 0x02,

        //
        // Add more extension for the first group here
        //
    }

    /// <summary>
    /// A regular export representing a UObject, with no special serialization.
    /// </summary>
    public class NormalExport : Export
    {
        public List<PropertyData> Data;
        public Guid? ObjectGuid;
        public EClassSerializationControlExtension SerializationControl;
        public EOverriddenPropertyOperation Operation;
        public bool HasLeadingFourNullBytes = false;

        /// <summary>
        /// Gets or sets the value associated with the specified key. This operation loops linearly, so it may not be suitable for high-performance environments.
        /// </summary>
        /// <param name="key">The key associated with the value to get or set.</param>
        public virtual PropertyData this[FName key]
        {
            get
            {
                for (int i = 0; i < Data.Count; i++)
                {
                    if (Data[i].Name == key) return Data[i];
                }
                return null;
            }
            set
            {
                value.Name = key;

                for (int i = 0; i < Data.Count; i++)
                {
                    if (Data[i].Name == key)
                    {
                        Data[i] = value;
                        return;
                    }
                }

                Data.Add(value);
            }
        }

        /// <summary>
        /// Gets or sets the value associated with the specified key. This operation loops linearly, so it may not be suitable for high-performance environments.
        /// </summary>
        /// <param name="key">The key associated with the value to get or set.</param>
        public virtual PropertyData this[string key]
        {
            get
            {
                return this[FName.FromString(Asset, key)];
            }
            set
            {
                this[FName.FromString(Asset, key)] = value;
            }
        }


        /// <summary>
        /// Gets or sets the value at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to get or set.</param>
        public PropertyData this[int index]
        {
            get
            {
                return Data[index];
            }
            set
            {
                Data[index] = value;
            }
        }

        public NormalExport(Export super)
        {
            Asset = super.Asset;
            Extras = super.Extras;
        }

        public NormalExport(UAsset asset, byte[] extras) : base(asset, extras)
        {

        }

        public NormalExport(List<PropertyData> data, UAsset asset, byte[] extras) : base(asset, extras)
        {
            Data = data;
        }

        public NormalExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting = 0)
        {
            // 5.4-specific problem; unclear why this occurs
            if (reader.Asset.ObjectVersionUE5 > ObjectVersionUE5.DATA_RESOURCES && reader.Asset.ObjectVersionUE5 < ObjectVersionUE5.ASSETREGISTRY_PACKAGEBUILDDEPENDENCIES && !ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject))
            {
                int dummy = reader.ReadInt32();
                if (dummy == 0)
                {
                    HasLeadingFourNullBytes = true;
                }
                else
                {
                    HasLeadingFourNullBytes = false;
                    reader.BaseStream.Seek(-4, System.IO.SeekOrigin.Current);
                }
            }

            Data = new List<PropertyData>();
            PropertyData bit;

            var unversionedHeader = new FUnversionedHeader(reader);
            if (!reader.Asset.HasUnversionedProperties && reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_EXTENSION_AND_OVERRIDABLE_SERIALIZATION)
            {
                SerializationControl = (EClassSerializationControlExtension)reader.ReadByte();

                if (SerializationControl.HasFlag(EClassSerializationControlExtension.OverridableSerializationInformation))
                {
                    Operation = (EOverriddenPropertyOperation)reader.ReadByte();
                }
            }
            FName parentName = GetClassTypeForAncestry(reader.Asset, out FName parentModulePath);
            while ((bit = MainSerializer.Read(reader, null, parentName, parentModulePath, unversionedHeader, true)) != null)
            {
                Data.Add(bit);
            }

            ObjectGuid = null;
            if (!this.ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject) && reader.ReadBooleanInt()) ObjectGuid = new Guid(reader.ReadBytes(16));
        }

        public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
        {
            var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
            ancestryNew.SetAsParent(GetClassTypeForAncestry(asset, out FName modulePath), modulePath);

            if (Data != null)
            {
                for (int i = 0; i < Data.Count; i++) Data[i]?.ResolveAncestries(asset, ancestryNew);
            }
            base.ResolveAncestries(asset, ancestrySoFar);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            // 5.4-specific problem; unclear why this occurs
            if (HasLeadingFourNullBytes && writer.Asset.ObjectVersionUE5 > ObjectVersionUE5.DATA_RESOURCES && writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.ASSETREGISTRY_PACKAGEBUILDDEPENDENCIES && !ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject))
            {
                writer.Write((int)0); // "false" bool?
            }

            FName parentName = GetClassTypeForAncestry(writer.Asset, out FName parentModulePath);

            MainSerializer.GenerateUnversionedHeader(ref Data, parentName, parentModulePath, writer.Asset)?.Write(writer);

            if (!writer.Asset.HasUnversionedProperties && writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_EXTENSION_AND_OVERRIDABLE_SERIALIZATION)
            {
                writer.Write((byte)SerializationControl);

                if (SerializationControl.HasFlag(EClassSerializationControlExtension.OverridableSerializationInformation))
                {
                    writer.Write((byte)Operation);
                }
            }

            for (int j = 0; j < Data.Count; j++)
            {
                PropertyData current = Data[j];
                MainSerializer.Write(current, writer, true);
            }
            if (!writer.Asset.HasUnversionedProperties) writer.Write(new FName(writer.Asset, "None"));

            if (this.ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject)) return;
            if (ObjectGuid == null)
            {
                writer.Write((int)0);
            }
            else
            {
                writer.Write((int)1);
                writer.Write(((Guid)ObjectGuid).ToByteArray());
            }
        }
    }
}

```

`UAssetAPI/ExportTypes/PropertyExport.cs`:

```cs
using System.Linq;
using UAssetAPI.FieldTypes;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// Export data for a <see cref="UProperty"/>.
    /// </summary>
    public class PropertyExport : NormalExport
    {
        public UProperty Property;

        public PropertyExport(Export super) : base(super)
        {

        }

        public PropertyExport(UAsset asset, byte[] extras) : base(asset, extras)
        {

        }

        public PropertyExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);

            FName exportClassType = this.GetExportClassType();
            Property = MainSerializer.ReadUProperty(reader, exportClassType);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            MainSerializer.WriteUProperty(Property, writer);
        }
    }
}

```

`UAssetAPI/ExportTypes/RawExport.cs`:

```cs
using System.IO;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// An export that could not be properly parsed by UAssetAPI, and is instead represented as an array of bytes as a fallback.
    /// </summary>
    public class RawExport : Export
    {
        public byte[] Data;

        public RawExport(Export super)
        {
            Asset = super.Asset;
            Extras = super.Extras;
        }

        public RawExport(byte[] data, UAsset asset, byte[] extras) : base(asset, extras)
        {
            Data = data;
        }

        public RawExport()
        {

        }

        public override void Write(AssetBinaryWriter writer)
        {
            writer.Write(Data);
        }
    }
}

```

`UAssetAPI/ExportTypes/StringTableExport.cs`:

```cs
using Newtonsoft.Json;
using System.Linq;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// A string table. Holds Key->SourceString pairs of text.
    /// </summary>
    public class FStringTable : TMap<FString, FString>
    {
        [JsonProperty]
        public FString TableNamespace;

        public FStringTable(FString tableNamespace) : base()
        {
            TableNamespace = tableNamespace;
        }

        public FStringTable() : base()
        {

        }
    }

    /// <summary>
    /// Export data for a string table. See <see cref="FStringTable"/>.
    /// </summary>
    public class StringTableExport : NormalExport
    {
        [JsonProperty]
        public FStringTable Table;

        public StringTableExport(Export super) : base(super)
        {

        }

        public StringTableExport(FStringTable data, UAsset asset, byte[] extras) : base(asset, extras)
        {
            Table = data;
        }

        public StringTableExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);

            Table = new FStringTable(reader.ReadFString());

            int numEntries = reader.ReadInt32();
            for (int i = 0; i < numEntries; i++)
            {
                Table.Add(reader.ReadFString(), reader.ReadFString());
            }
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            writer.Write(Table.TableNamespace);
            writer.Write(Table.Count);
            for (int i = 0; i < Table.Count; i++)
            {
                writer.Write(Table.Keys.ElementAt(i));
                writer.Write(Table[i]);
            }
        }
    }
}

```

`UAssetAPI/ExportTypes/StructExport.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using UAssetAPI.CustomVersions;
using UAssetAPI.FieldTypes;
using UAssetAPI.Kismet.Bytecode;
using UAssetAPI.UnrealTypes;

#if DEBUGVERBOSE
using System.Diagnostics;
#endif

namespace UAssetAPI.ExportTypes
{
    /// <summary>
    /// Base export for all UObject types that contain fields.
    /// </summary>
    public class StructExport : FieldExport
    {
        /// <summary>
        /// Struct this inherits from, may be null
        /// </summary>
        public FPackageIndex SuperStruct;

        /// <summary>
        /// List of child fields
        /// </summary>
        public FPackageIndex[] Children;

        /// <summary>
        /// Properties serialized with this struct definition
        /// </summary>
        public FProperty[] LoadedProperties;

        /// <summary>
        /// The bytecode instructions contained within this struct.
        /// </summary>
        public KismetExpression[] ScriptBytecode;

        /// <summary>
        /// Bytecode size in total in deserialized memory. Filled out in lieu of <see cref="ScriptBytecode"/> if an error occurs during bytecode parsing.
        /// </summary>
        public int ScriptBytecodeSize;

        /// <summary>
        /// Raw binary bytecode data. Filled out in lieu of <see cref="ScriptBytecode"/> if an error occurs during bytecode parsing.
        /// </summary>
        public byte[] ScriptBytecodeRaw;

        public StructExport(Export super) : base(super)
        {

        }

        public StructExport(UAsset asset, byte[] extras) : base(asset, extras)
        {

        }

        public StructExport()
        {

        }

        public override void Read(AssetBinaryReader reader, int nextStarting)
        {
            base.Read(reader, nextStarting);

            SuperStruct = new FPackageIndex(reader.ReadInt32());

            if (Asset.GetCustomVersion<FFrameworkObjectVersion>() < FFrameworkObjectVersion.RemoveUField_Next)
            {
                var firstChild = new FPackageIndex(reader.ReadInt32());
                Children = firstChild.IsNull() ? Array.Empty<FPackageIndex>() : new[] { firstChild };
            }
            else
            {
                int numIndexEntries = reader.ReadInt32();
                Children = new FPackageIndex[numIndexEntries];
                for (int i = 0; i < numIndexEntries; i++)
                {
                    Children[i] = new FPackageIndex(reader.ReadInt32());
                }
            }

            if (Asset.GetCustomVersion<FCoreObjectVersion>() >= FCoreObjectVersion.FProperties)
            {
                int numProps = reader.ReadInt32();
                LoadedProperties = new FProperty[numProps];
                for (int i = 0; i < numProps; i++)
                {
                    LoadedProperties[i] = MainSerializer.ReadFProperty(reader);
                }
            }
            else
            {
                LoadedProperties = [];
            }

            ScriptBytecodeSize = reader.ReadInt32(); // # of bytes in total in deserialized memory
            int scriptStorageSize = reader.ReadInt32(); // # of bytes in total
            long startedReading = reader.BaseStream.Position;

            bool willParseRaw = true;
#pragma warning disable CS0168 // Variable is declared but never used
            try
            {
                if (!Asset.CustomSerializationFlags.HasFlag(CustomSerializationFlags.SkipParsingBytecode))
                {
                    var tempCode = new List<Kismet.Bytecode.KismetExpression>();
                    while ((reader.BaseStream.Position - startedReading) < scriptStorageSize)
                    {
                        tempCode.Add(ExpressionSerializer.ReadExpression(reader));
                    }
                    ScriptBytecode = tempCode.ToArray();
                    willParseRaw = false;
                }
            }
            catch (Exception ex)
            {
#if DEBUGVERBOSE
                Debug.WriteLine(ex.StackTrace);
#endif
            }
#pragma warning restore CS0168 // Variable is declared but never used

            if (willParseRaw)
            {
                reader.BaseStream.Seek(startedReading, SeekOrigin.Begin);
                ScriptBytecode = null;
                ScriptBytecodeRaw = reader.ReadBytes(scriptStorageSize);
            }
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            writer.Write(SuperStruct.Index);

            if (Asset.GetCustomVersion<FFrameworkObjectVersion>() < FFrameworkObjectVersion.RemoveUField_Next)
            {
                if (Children.Length == 0) 
                {
                    writer.Write(0);
                }
                else
                {
                    writer.Write(Children[0].Index);
                }
            }
            else
            {
                writer.Write(Children.Length);
                for (int i = 0; i < Children.Length; i++)
                {
                    writer.Write(Children[i].Index);
                }
            }

            if (Asset.GetCustomVersion<FCoreObjectVersion>() >= FCoreObjectVersion.FProperties)
            {
                writer.Write(LoadedProperties.Length);
                for (int i = 0; i < LoadedProperties.Length; i++)
                {
                    MainSerializer.WriteFProperty(LoadedProperties[i], writer);
                }
            }

            if (ScriptBytecode == null)
            {
                writer.Write(ScriptBytecodeSize);
                writer.Write(ScriptBytecodeRaw.Length);
                writer.Write(ScriptBytecodeRaw);
            }
            else
            {
                long lengthOffset1 = writer.BaseStream.Position;
                writer.Write((int)0); // total iCode offset; to be filled out after serialization
                long lengthOffset2 = writer.BaseStream.Position;
                writer.Write((int)0); // size on disk; to be filled out after serialization

                int totalICodeOffset = 0;
                long startMetric = writer.BaseStream.Position;
                for (int i = 0; i < ScriptBytecode.Length; i++)
                {
                    totalICodeOffset += ExpressionSerializer.WriteExpression(ScriptBytecode[i], writer);
                }
                long endMetric = writer.BaseStream.Position;

                // Write out total size in bytes
                long totalLength = endMetric - startMetric;
                long here = writer.BaseStream.Position;
                writer.Seek((int)lengthOffset1, SeekOrigin.Begin);
                writer.Write(totalICodeOffset);
                writer.Seek((int)lengthOffset2, SeekOrigin.Begin);
                writer.Write((int)totalLength);
                writer.Seek((int)here, SeekOrigin.Begin);
            }
        }
    }
}

```

`UAssetAPI/ExportTypes/UserDefinedStructExport.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using UAssetAPI.CustomVersions;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.ExportTypes;

public class UserDefinedStructExport : StructExport
{
    public uint StructFlags;
    public List<PropertyData> StructData = [];
    public EClassSerializationControlExtension SerializationControl2;
    public EOverriddenPropertyOperation Operation2;

    public UserDefinedStructExport(Export super) : base(super) { }

    public UserDefinedStructExport(UAsset asset, byte[] extras) : base(asset, extras) { }

    public UserDefinedStructExport() { }

    public override void Read(AssetBinaryReader reader, int nextStarting)
    {
        base.Read(reader, nextStarting);

        if (reader.Asset.Mappings?.Schemas != null && this.ObjectName?.Value?.Value != null)
        {
            UsmapSchema newSchema = Usmap.GetSchemaFromStructExport(this, reader.Asset.Mappings?.AreFNamesCaseInsensitive ?? true);
            reader.Asset.Mappings.Schemas[this.ObjectName.Value.Value] = newSchema;
        }

        if (reader.Asset.GetCustomVersion<FFrameworkObjectVersion>() < FFrameworkObjectVersion.UserDefinedStructsStoreDefaultInstance
            || (Data.FirstOrDefault(x => x.Name.Value.Value == "Status") is BytePropertyData byteprop && byteprop.EnumValue?.Value.Value != "UDSS_UpToDate"))
            return;

        if (this.ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject)) return;

        StructFlags = reader.ReadUInt32();

        PropertyData bit;
        var unversionedHeader = new FUnversionedHeader(reader);
        while ((bit = MainSerializer.Read(reader, null, this.ObjectName, FName.DefineDummy(reader.Asset, reader.Asset.InternalAssetPath), unversionedHeader, true)) != null)
        {
            StructData.Add(bit);
        }
    }

    public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
    {
        var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
        ancestryNew.SetAsParent(this.ObjectName, null);

        if (StructData != null)
        {
            for (int i = 0; i < StructData.Count; i++) StructData[i]?.ResolveAncestries(asset, ancestryNew);
        }
        base.ResolveAncestries(asset, ancestrySoFar);
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);

        if (writer.Asset.GetCustomVersion<FFrameworkObjectVersion>() < FFrameworkObjectVersion.UserDefinedStructsStoreDefaultInstance
            || (Data.FirstOrDefault(x => x.Name.Value.Value == "Status") is BytePropertyData byteprop && byteprop.EnumValue?.Value.Value != "UDSS_UpToDate"))
            return;

        if (this.ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject)) return;

        writer.Write(StructFlags);

        MainSerializer.GenerateUnversionedHeader(ref StructData, this.ObjectName, FName.DefineDummy(writer.Asset, writer.Asset.InternalAssetPath), writer.Asset)?.Write(writer);
        for (int j = 0; j < StructData.Count; j++)
        {
            PropertyData current = StructData[j];
            MainSerializer.Write(current, writer, true);
        }
        if (!writer.Asset.HasUnversionedProperties) writer.Write(new FName(writer.Asset, "None"));
    }
}
```

`UAssetAPI/FieldTypes/EArrayDim.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.FieldTypes
{
    /// <summary>
    /// The type of array that this property represents. This is represented an integer in the engine.
    /// </summary>
    public enum EArrayDim : int
    {
        NotAnArray = 0,
        TArray = 1,
        CArray = 2
    }
}

```

`UAssetAPI/FieldTypes/ELifetimeCondition.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.FieldTypes
{
    /// <summary>Secondary condition to check before considering the replication of a lifetime property.</summary>
    public enum ELifetimeCondition : byte
    {
        /// <summary>This property has no condition, and will send anytime it changes</summary>
        COND_None = 0,
        /// <summary>This property will only attempt to send on the initial bunch</summary>
        COND_InitialOnly = 1,
        /// <summary>This property will only send to the actor's owner</summary>
        COND_OwnerOnly = 2,
        /// <summary>This property send to every connection EXCEPT the owner</summary>
        COND_SkipOwner = 3,
        /// <summary>This property will only send to simulated actors</summary>
        COND_SimulatedOnly = 4,
        /// <summary>This property will only send to autonomous actors</summary>
        COND_AutonomousOnly = 5,
        /// <summary>This property will send to simulated OR bRepPhysics actors</summary>
        COND_SimulatedOrPhysics = 6,
        /// <summary>This property will send on the initial packet, or to the actors owner</summary>
        COND_InitialOrOwner = 7,
        /// <summary>This property has no particular condition, but wants the ability to toggle on/off via SetCustomIsActiveOverride</summary>
        COND_Custom = 8,
        /// <summary>This property will only send to the replay connection, or to the actors owner</summary>
        COND_ReplayOrOwner = 9,
        /// <summary>This property will only send to the replay connection</summary>
        COND_ReplayOnly = 10,
        /// <summary>This property will send to actors only, but not to replay connections</summary>
        COND_SimulatedOnlyNoReplay = 11,
        /// <summary>This property will send to simulated Or bRepPhysics actors, but not to replay connections</summary>
        COND_SimulatedOrPhysicsNoReplay = 12,
        /// <summary>This property will not send to the replay connection</summary>
        COND_SkipReplay = 13,
        /// <summary>This property will never be replicated</summary>
        COND_Never = 15,
        COND_Max = 16
    };
}

```

`UAssetAPI/FieldTypes/FField.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.FieldTypes
{
    /// <summary>
    /// Base class of reflection data objects.
    /// </summary>
    public class FField
    {
        public FName SerializedType;
        public FName Name;
        public EObjectFlags Flags;
        public TMap<FName, FString> MetaDataMap;

        public virtual void Read(AssetBinaryReader reader)
        {
            Name = reader.ReadFName();
            Flags = (EObjectFlags)reader.ReadUInt32();

            if (!reader.Asset.IsFilterEditorOnly && !reader.Asset.PackageFlags.HasFlag(EPackageFlags.PKG_Cooked))
            {
                bool bHasMetaData = reader.ReadBooleanInt();
                if (bHasMetaData)
                {
                    MetaDataMap = new TMap<FName, FString>();
                    int leng = reader.ReadInt32();
                    for (int i = 0; i < leng; i++)
                    {
                        FName key = reader.ReadFName();
                        FString val = reader.ReadFString();
                        MetaDataMap.Add(key, val);
                    }
                }
            }
        }

        public virtual void Write(AssetBinaryWriter writer)
        {
            writer.Write(Name);
            writer.Write((uint)Flags);

            if (!writer.Asset.IsFilterEditorOnly && !writer.Asset.PackageFlags.HasFlag(EPackageFlags.PKG_Cooked))
            {
                writer.Write(MetaDataMap is not null ? 1 : 0); // int32
                if (MetaDataMap is not null && MetaDataMap.Count > 0)
                {
                    writer.Write(MetaDataMap.Count); // int32
                    for (int i = 0; i < MetaDataMap.Count; i++)
                    {
                        var pair = MetaDataMap.GetItem(i);
                        writer.Write(pair.Key);
                        writer.Write(pair.Value);
                    }
                }

            }
        }

        public FField()
        {

        }
    }

    /// <summary>
    /// An UnrealScript variable.
    /// </summary>
    public abstract class FProperty : FField
    {
        public EArrayDim ArrayDim;
        public int ElementSize;
        public EPropertyFlags PropertyFlags;
        public ushort RepIndex;
        public FName RepNotifyFunc;
        public ELifetimeCondition BlueprintReplicationCondition;

        public object RawValue;

        public void SetObject(object value)
        {
            RawValue = value;
        }

        public T GetObject<T>()
        {
            return (T)RawValue;
        }

        [JsonIgnore]
        public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides = new Dictionary<string, EPropertyType>()
        {
            { "MulticastInlineDelegateProperty", EPropertyType.MulticastDelegateProperty },
            { "ClassProperty", EPropertyType.ObjectProperty },
            { "SoftClassProperty", EPropertyType.SoftObjectProperty }
        };

        public EPropertyType GetUsmapPropertyType()
        {
            EPropertyType res = EPropertyType.Unknown;
            if (UsmapPropertyTypeOverrides.TryGetValue(SerializedType.Value.Value, out res)) return res;
            if (Enum.TryParse(SerializedType.Value.Value, out res)) return res;
            return res;
        }

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            ArrayDim = (EArrayDim)reader.ReadInt32();
            ElementSize = reader.ReadInt32();
            PropertyFlags = (EPropertyFlags)reader.ReadUInt64();
            RepIndex = reader.ReadUInt16();
            RepNotifyFunc = reader.ReadFName();
            BlueprintReplicationCondition = (ELifetimeCondition)reader.ReadByte();
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write((int)ArrayDim);
            writer.Write(ElementSize);
            writer.Write((ulong)PropertyFlags);
            writer.Write(RepIndex);
            writer.Write(RepNotifyFunc);
            writer.Write((byte)BlueprintReplicationCondition);
        }

        public FProperty()
        {

        }
    }

    public class FEnumProperty : FProperty
    {
        ///<summary>A pointer to the UEnum represented by this property</summary>
        public FPackageIndex Enum;
        ///<summary>The FNumericProperty which represents the underlying type of the enum</summary>
        public FProperty UnderlyingProp;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);

            Enum = new FPackageIndex(reader.ReadInt32());
            UnderlyingProp = MainSerializer.ReadFProperty(reader);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);

            writer.Write(Enum.Index);
            MainSerializer.WriteFProperty(UnderlyingProp, writer);
        }
    }

    public class FArrayProperty : FProperty
    {
        public FProperty Inner;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            Inner = MainSerializer.ReadFProperty(reader);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            MainSerializer.WriteFProperty(Inner, writer);
        }
    }

    public class FSetProperty : FProperty
    {
        public FProperty ElementProp;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            ElementProp = MainSerializer.ReadFProperty(reader);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            MainSerializer.WriteFProperty(ElementProp, writer);
        }
    }

    public class FObjectProperty : FProperty
    {
        // UClass*
        public FPackageIndex PropertyClass;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            PropertyClass = new FPackageIndex(reader.ReadInt32());
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(PropertyClass.Index);
        }
    }

    public class FSoftObjectProperty : FObjectProperty
    {

    }

    public class FWeakObjectProperty : FObjectProperty
    {

    }

    public class FClassProperty : FObjectProperty
    {
        // UClass*
        public FPackageIndex MetaClass;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            MetaClass = new FPackageIndex(reader.ReadInt32());
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(MetaClass.Index);
        }
    }

    public class FSoftClassProperty : FObjectProperty
    {
        // UClass*
        public FPackageIndex MetaClass;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            MetaClass = new FPackageIndex(reader.ReadInt32());
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(MetaClass.Index);
        }
    }

    public class FDelegateProperty : FProperty
    {
        // UFunction*
        public FPackageIndex SignatureFunction;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            SignatureFunction = new FPackageIndex(reader.ReadInt32());
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(SignatureFunction.Index);
        }
    }

    public class FMulticastDelegateProperty : FDelegateProperty
    {

    }

    public class FMulticastInlineDelegateProperty : FMulticastDelegateProperty
    {

    }

    public class FInterfaceProperty : FProperty
    {
        // UFunction*
        public FPackageIndex InterfaceClass;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            InterfaceClass = new FPackageIndex(reader.ReadInt32());
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(InterfaceClass.Index);
        }
    }

    public class FMapProperty : FProperty
    {
        public FProperty KeyProp;
        public FProperty ValueProp;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            KeyProp = MainSerializer.ReadFProperty(reader);
            ValueProp = MainSerializer.ReadFProperty(reader);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            MainSerializer.WriteFProperty(KeyProp, writer);
            MainSerializer.WriteFProperty(ValueProp, writer);
        }
    }

    public class FBoolProperty : FProperty
    {
        /// <summary>Size of the bitfield/bool property. Equal to ElementSize but used to check if the property has been properly initialized (0-8, where 0 means uninitialized).</summary>
        public byte FieldSize;
        /// <summary>Offset from the memeber variable to the byte of the property (0-7).</summary>
        public byte ByteOffset;
        /// <summary>Mask of the byte with the property value.</summary>
        public byte ByteMask;
        /// <summary>Mask of the field with the property value. Either equal to ByteMask or 255 in case of 'bool' type.</summary>
        public byte FieldMask;

        public bool NativeBool;
        public bool Value;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);

            byte BoolSize = (byte)ElementSize;
            FieldSize = reader.ReadByte();
            ByteOffset = reader.ReadByte();
            ByteMask = reader.ReadByte();
            FieldMask = reader.ReadByte();
            NativeBool = reader.ReadBoolean();
            Value = reader.ReadBoolean();
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(FieldSize);
            writer.Write(ByteOffset);
            writer.Write(ByteMask);
            writer.Write(FieldMask);
            writer.Write(NativeBool);
            writer.Write(Value);
        }
    }

    public class FByteProperty : FProperty
    {
        /// <summary>A pointer to the UEnum represented by this property</summary>
        public FPackageIndex Enum;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            Enum = new FPackageIndex(reader.ReadInt32());
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(Enum.Index);
        }
    }

    public class FStructProperty : FProperty
    {
        // UScriptStruct*
        public FPackageIndex Struct;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            Struct = new FPackageIndex(reader.ReadInt32());
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(Struct.Index);
        }
    }

    public class FNumericProperty : FProperty
    {
        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
        }
    }

    /// <summary>
    /// This is a UAssetAPI-specific property that represents anything that we don't have special serialization for
    /// </summary>
    public class FGenericProperty : FProperty
    {
        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
        }
    }

    public class FOptionalProperty : FProperty
    {
        public FProperty ValueProperty;

        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
            ValueProperty = MainSerializer.ReadFProperty(reader);
        }

        public override void Write(AssetBinaryWriter writer)
        {
            base.Write(writer);
            MainSerializer.WriteFProperty(ValueProperty, writer);
        }
    }
}

```

`UAssetAPI/FieldTypes/UField.cs`:

```cs
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;
using UAssetAPI.CustomVersions;
using UAssetAPI.Unversioned;

namespace UAssetAPI.FieldTypes;

/// <summary>
/// Base class of reflection data objects.
/// </summary>
public class UField
{
    /// <summary>
    /// Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array
    /// </summary>
    [DisplayIndexOrder(0)]
    public FPackageIndex Next;

    public virtual void Read(AssetBinaryReader reader)
    {
        if (reader.Asset.GetCustomVersion<FFrameworkObjectVersion>() < FFrameworkObjectVersion.RemoveUField_Next)
        {
            Next = new FPackageIndex(reader.ReadInt32());
        }
    }

    public virtual void Write(AssetBinaryWriter writer)
    {
        if (writer.Asset.GetCustomVersion<FFrameworkObjectVersion>() < FFrameworkObjectVersion.RemoveUField_Next)
        {
            writer.Write(Next.Index);
        }
    }

    public UField() { }
}

/// <summary>
/// An UnrealScript variable.
/// </summary>
public abstract class UProperty : UField
{
    [DisplayIndexOrder(1)]
    public EArrayDim ArrayDim;
    [DisplayIndexOrder(2)]
    public int ElementSize;
    [DisplayIndexOrder(3)]
    public EPropertyFlags PropertyFlags;
    [DisplayIndexOrder(4)]
    public FName RepNotifyFunc;
    [DisplayIndexOrder(5)]
    public ELifetimeCondition BlueprintReplicationCondition;

    public object RawValue;

    public void SetObject(object value)
    {
        RawValue = value;
    }

    public T GetObject<T>()
    {
        return (T)RawValue;
    }

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        ArrayDim = (EArrayDim)reader.ReadInt32();
        PropertyFlags = (EPropertyFlags)reader.ReadUInt64();
        RepNotifyFunc = reader.ReadFName();

        if (reader.Asset.GetCustomVersion<FReleaseObjectVersion>() >= FReleaseObjectVersion.PropertiesSerializeRepCondition)
        {
            BlueprintReplicationCondition = (ELifetimeCondition)reader.ReadByte();
        }
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write((int)ArrayDim);
        writer.Write((ulong)PropertyFlags);
        writer.Write(RepNotifyFunc);

        if (writer.Asset.GetCustomVersion<FReleaseObjectVersion>() >= FReleaseObjectVersion.PropertiesSerializeRepCondition)
        {
            writer.Write((byte)BlueprintReplicationCondition);
        }
    }

    public UProperty() { }

    public EPropertyType GetUsmapPropertyType()
    {
        return this switch
        {
            UEnumProperty => EPropertyType.EnumProperty,
            UByteProperty => EPropertyType.ByteProperty,
            UBoolProperty => EPropertyType.BoolProperty,
            UInt8Property => EPropertyType.Int8Property,
            UInt16Property => EPropertyType.Int16Property,
            UIntProperty => EPropertyType.IntProperty,
            UInt64Property => EPropertyType.Int64Property,
            UUInt16Property => EPropertyType.UInt16Property,
            UUInt32Property => EPropertyType.UInt32Property,
            UUInt64Property => EPropertyType.UInt64Property,
            UFloatProperty => EPropertyType.FloatProperty,
            UDoubleProperty => EPropertyType.DoubleProperty,

            UAssetClassProperty => EPropertyType.SoftObjectProperty,
            USoftClassProperty => EPropertyType.SoftObjectProperty,
            UClassProperty => EPropertyType.ObjectProperty,
            UAssetObjectProperty => EPropertyType.AssetObjectProperty,
            UWeakObjectProperty => EPropertyType.WeakObjectProperty,
            ULazyObjectProperty => EPropertyType.LazyObjectProperty,
            USoftObjectProperty => EPropertyType.SoftObjectProperty,
            UObjectProperty => EPropertyType.ObjectProperty,

            UNameProperty => EPropertyType.NameProperty,
            UStrProperty => EPropertyType.StrProperty,
            UTextProperty => EPropertyType.TextProperty,

            UInterfaceProperty => EPropertyType.InterfaceProperty,

            UMulticastDelegateProperty => EPropertyType.MulticastDelegateProperty,
            UDelegateProperty => EPropertyType.DelegateProperty,

            UMapProperty => EPropertyType.MapProperty,
            USetProperty => EPropertyType.SetProperty,
            UArrayProperty => EPropertyType.ArrayProperty,
            UStructProperty => EPropertyType.StructProperty,

            _ => EPropertyType.Unknown,
        };
    }
}

public class UEnumProperty : UProperty
{
    ///<summary>A pointer to the UEnum represented by this property</summary>
    [DisplayIndexOrder(6)]
    public FPackageIndex Enum;
    ///<summary>The FNumericProperty which represents the underlying type of the enum</summary>
    [DisplayIndexOrder(7)]
    public FPackageIndex UnderlyingProp;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);

        Enum = new FPackageIndex(reader.ReadInt32());
        UnderlyingProp = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);

        writer.Write(Enum.Index);
        writer.Write(UnderlyingProp.Index);
    }
}

public class UArrayProperty : UProperty
{
    [DisplayIndexOrder(6)]
    public FPackageIndex Inner;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        Inner = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(Inner.Index);
    }
}

public class USetProperty : UProperty
{
    [DisplayIndexOrder(6)]
    public FPackageIndex ElementProp;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        ElementProp = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(ElementProp.Index);
    }
}

public class UObjectProperty : UProperty
{
    // UClass*
    [DisplayIndexOrder(6)]
    public FPackageIndex PropertyClass;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        PropertyClass = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(PropertyClass.Index);
    }
}

public class UWeakObjectProperty : UObjectProperty { }

public class USoftObjectProperty : UObjectProperty { }

public class ULazyObjectProperty : UObjectProperty { }

public class UAssetObjectProperty : UObjectProperty { }

public class UClassProperty : UObjectProperty
{
    // UClass*
    [DisplayIndexOrder(7)]
    public FPackageIndex MetaClass;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        MetaClass = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(MetaClass.Index);
    }
}

public class UAssetClassProperty : UObjectProperty
{
    // UClass*
    [DisplayIndexOrder(7)]
    public FPackageIndex MetaClass;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        MetaClass = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(MetaClass.Index);
    }
}

public class USoftClassProperty : UObjectProperty
{
    // UClass*
    [DisplayIndexOrder(7)]
    public FPackageIndex MetaClass;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        MetaClass = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(MetaClass.Index);
    }
}

public class UDelegateProperty : UProperty
{
    // UFunction*
    [DisplayIndexOrder(6)]
    public FPackageIndex SignatureFunction;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        SignatureFunction = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(SignatureFunction.Index);
    }
}

public class UMulticastDelegateProperty : UDelegateProperty { }

public class UMulticastInlineDelegateProperty : UMulticastDelegateProperty { }

public class UMulticastSparseDelegateProperty : UMulticastDelegateProperty { }

public class UInterfaceProperty : UProperty
{
    // UFunction*
    [DisplayIndexOrder(6)]
    public FPackageIndex InterfaceClass;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        InterfaceClass = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(InterfaceClass.Index);
    }
}

public class UMapProperty : UProperty
{
    [DisplayIndexOrder(6)]
    public FPackageIndex KeyProp;
    [DisplayIndexOrder(7)]
    public FPackageIndex ValueProp;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        KeyProp = new FPackageIndex(reader.ReadInt32());
        ValueProp = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(KeyProp.Index);
        writer.Write(ValueProp.Index);
    }
}

public class UBoolProperty : UProperty
{
    [DisplayIndexOrder(6)]
    public bool NativeBool;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);

        ElementSize = reader.ReadByte();
        NativeBool = reader.ReadBoolean();
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write((byte)ElementSize);
        writer.Write(NativeBool);
    }
}

public class UByteProperty : UProperty
{
    /// <summary>A pointer to the UEnum represented by this property</summary>
    [DisplayIndexOrder(6)]
    public FPackageIndex Enum;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        Enum = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(Enum.Index);
    }
}

public class UStructProperty : UProperty
{
    // UScriptStruct*
    [DisplayIndexOrder(6)]
    public FPackageIndex Struct;

    public override void Read(AssetBinaryReader reader)
    {
        base.Read(reader);
        Struct = new FPackageIndex(reader.ReadInt32());
    }

    public override void Write(AssetBinaryWriter writer)
    {
        base.Write(writer);
        writer.Write(Struct.Index);
    }
}

public class UNameProperty : UProperty { }

public class UStrProperty : UProperty { }

public class UTextProperty : UProperty { }

public class UNumericProperty : UProperty { }

public class UDoubleProperty : UNumericProperty { }

public class UFloatProperty : UNumericProperty { }

public class UIntProperty : UNumericProperty { }

public class UInt8Property : UNumericProperty { }

public class UInt16Property : UNumericProperty { }

public class UInt64Property : UNumericProperty { }

public class UUInt16Property : UNumericProperty { }

public class UUInt32Property : UNumericProperty { }

public class UUInt64Property : UNumericProperty { }

/// <summary>
/// This is a UAssetAPI-specific property that represents anything that we don't have special serialization for
/// </summary>
public class UGenericProperty : UProperty { }

```

`UAssetAPI/Import.cs`:

```cs
using UAssetAPI.UnrealTypes;

namespace UAssetAPI
{
    /// <summary>
    /// UObject resource type for objects that are referenced by this package, but contained within another package.
    /// </summary>
    public class Import
    {
        ///<summary>The name of the UObject represented by this resource.</summary>
        public FName ObjectName;
        ///<summary>Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage</summary>
        public FPackageIndex OuterIndex;
        public FName ClassPackage;
        public FName ClassName;
        /// <summary>
        /// Package Name this import belongs to. Can be none, in that case follow the outer chain
        /// until a set PackageName is found or until OuterIndex is null
        /// </summary>
        public FName PackageName;
        public bool bImportOptional;

        public Import(string classPackage, string className, FPackageIndex outerIndex, string objectName, bool importOptional, UAsset asset)
        {
            ObjectName = new FName(asset, objectName);
            OuterIndex = outerIndex;
            ClassPackage = new FName(asset, classPackage);
            ClassName = new FName(asset, className);
            bImportOptional = importOptional;
        }

        public Import(FName classPackage, FName className, FPackageIndex outerIndex, FName objectName, bool importOptional)
        {
            ObjectName = objectName;
            OuterIndex = outerIndex;
            ClassPackage = classPackage;
            ClassName = className;
            bImportOptional = importOptional;
        }

        public Import(AssetBinaryReader reader)
        {
            ClassPackage = reader.ReadFName();
            ClassName = reader.ReadFName();
            OuterIndex = new FPackageIndex(reader.ReadInt32());
            ObjectName = reader.ReadFName();

            if (reader.Asset.ObjectVersion >= ObjectVersion.VER_UE4_NON_OUTER_PACKAGE_IMPORT
                && !reader.Asset.IsFilterEditorOnly)
                PackageName = reader.ReadFName();

            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.OPTIONAL_RESOURCES) bImportOptional = reader.ReadInt32() == 1;
        }

        public Import()
        {

        }
    }
}

```

`UAssetAPI/JSON/ByteArrayJsonConverter.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;

namespace UAssetAPI.JSON
{
    public class ByteArrayJsonConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(byte[]);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(Convert.ToBase64String((byte[])value));
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            string val = reader.Value as string;

            // backwards compatibility for fun
            if (reader.TokenType == JsonToken.StartObject)
            {
                reader.Read();
                while (reader.TokenType != JsonToken.EndObject)
                {
                    if (reader.TokenType != JsonToken.PropertyName) throw new FormatException("Expected PropertyName, got " + reader.TokenType);
                    string propertyName = reader.Value.ToString();
                    reader.Read();
                    object propertyValue = reader.Value;
                    reader.Read();

                    if (propertyName == "$value")
                    {
                        val = propertyValue as string;
                    }
                }
            }

            if (val == null) return null;
            return Convert.FromBase64String(val);
        }
    }
}

```

`UAssetAPI/JSON/FNameJsonConverter.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.JSON
{
    public class FNameJsonConverter : JsonConverter
    {
        public Dictionary<FName, string> ToBeFilled;
        public int currentI = 0;

        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(FName);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            var realVal = (FName)value;
            writer.WriteValue(realVal.DummyValue == null ? (realVal is null ? "null" : realVal.ToString()) : realVal.DummyValue.ToString());
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null) return null;
            var res = FName.DefineDummy(null, "temp", ++currentI);
            ToBeFilled[res] = Convert.ToString(reader.Value);
            return res;
        }

        public FNameJsonConverter(Dictionary<FName, string> dict) : base()
        {
            ToBeFilled = dict;
        }
    }
}

```

`UAssetAPI/JSON/FPackageIndexJsonConverter.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.JSON
{
    public class FPackageIndexJsonConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(FPackageIndex);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue((value as FPackageIndex).Index);
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            return new FPackageIndex(Convert.ToInt32(reader.Value));
        }
    }
}

```

`UAssetAPI/JSON/FSignedZeroJsonConverter.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Diagnostics;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.JSON
{
    public class FSignedZeroJsonConverter : JsonConverter
    {
        private static readonly decimal negativeZero = decimal.Negate(decimal.Zero);

        private static bool IsNegativeZero(double x)
        {
            return x == 0.0 && double.IsNegativeInfinity(1.0 / x);
        }

        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(decimal) || objectType == typeof(float) || objectType == typeof(double);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            double us = Convert.ToDouble(value);
            if (us == 0)
            {
                writer.WriteValue(IsNegativeZero(us) ? "-0" : "+0");
            }
            else
            {
                writer.WriteValue(us);
            }
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value is null) return 0;

            if (reader.Value is string)
            {
                if (reader.Value == null || reader.Value.Equals("+0")) return Convert.ChangeType(0.0, objectType);
                if (reader.Value.Equals("-0")) return Convert.ChangeType(negativeZero, objectType);
            }

            object res = Convert.ChangeType(reader.Value, objectType);
            if (res is null) return 0;
            return res;
        }
    }
}

```

`UAssetAPI/JSON/FStringJsonConverter.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.JSON
{
    public class FStringJsonConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(FString);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue((value as FString)?.Value);
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null) return null;
            return new FString(Convert.ToString(reader.Value));
        }
    }
}

```

`UAssetAPI/JSON/FStringTableJsonConverter.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections;
using System.Collections.Specialized;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.JSON
{
    public class FStringTableJsonConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(FStringTable);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            var realVal = (FStringTable)value;

            ICollection keys = ((IOrderedDictionary)value).Keys;
            ICollection values = ((IOrderedDictionary)value).Values;
            IEnumerator valueEnumerator = values.GetEnumerator();

            writer.WriteStartObject();
            writer.WritePropertyName("TableNamespace");
            writer.WriteValue(realVal.TableNamespace?.Value);
            writer.WritePropertyName("Value");
            writer.WriteStartArray();
            foreach (object key in keys)
            {
                valueEnumerator.MoveNext();

                writer.WriteStartArray();
                serializer.Serialize(writer, key);
                serializer.Serialize(writer, valueEnumerator.Current);
                writer.WriteEndArray();
            }
            writer.WriteEndArray();
            writer.WriteEndObject();
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            var dictionary = new FStringTable();

            JObject tableJson = JObject.Load(reader);
            dictionary.TableNamespace = new FString(tableJson["TableNamespace"].ToObject<string>());
            JArray tokens = (JArray)tableJson["Value"];

            foreach (var eachToken in tokens)
            {
                FString key = eachToken[0].ToObject<FString>(serializer);
                FString value = eachToken[1].ToObject<FString>(serializer);
                dictionary.Add(key, value);
            }

            return dictionary;
        }
    }
}
```

`UAssetAPI/JSON/GuidJsonConverter.cs`:

```cs
using Newtonsoft.Json;
using System;

namespace UAssetAPI.JSON
{
    public class GuidJsonConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(Guid);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((Guid) value).ConvertToString());
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            return Convert.ToString(reader.Value).ConvertToGUID();
        }
    }
}

```

`UAssetAPI/JSON/TMapJsonConverter.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections;
using System.Collections.Specialized;

/*
    The code in this file is modified from mattmc3's dotmore @ https://github.com/mattmc3/dotmore/tree/b032bbf871d46bffd698c9b7a233c533d9d2f0ebs for usage in UAssetAPI.

    The MIT License (MIT)

    Copyright (c) 2014 mattmc3

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.JSON
{
    public class TMapJsonConverter<TKey, TValue> : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return typeof(IOrderedDictionary).IsAssignableFrom(objectType);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            ICollection keys = ((IOrderedDictionary)value).Keys;
            ICollection values = ((IOrderedDictionary)value).Values;
            IEnumerator valueEnumerator = values.GetEnumerator();

            writer.WriteStartArray();
            foreach (object key in keys)
            {
                valueEnumerator.MoveNext();

                writer.WriteStartArray();
                serializer.Serialize(writer, key);
                serializer.Serialize(writer, valueEnumerator.Current);
                writer.WriteEndArray();
            }
            writer.WriteEndArray();
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            var dictionary = new TMap<TKey, TValue>();
            JToken tokens = JToken.Load(reader);

            foreach (var eachToken in tokens)
            {
                TKey key = eachToken[0].ToObject<TKey>(serializer);
                TValue value = eachToken[1].ToObject<TValue>(serializer);
                dictionary.Add(key, value);
            }
            return dictionary;
        }
    }
}
```

`UAssetAPI/JSON/UAssetContractResolver.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using System;
using System.Collections.Generic;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.JSON
{
    public class UAssetContractResolver : DefaultContractResolver
    {
        public Dictionary<FName, string> ToBeFilled;

        protected override JsonConverter ResolveContractConverter(Type objectType)
        {
            if (typeof(FName).IsAssignableFrom(objectType))
            {
                return new FNameJsonConverter(ToBeFilled);
            }
            return base.ResolveContractConverter(objectType);
        }

        public UAssetContractResolver(Dictionary<FName, string> toBeFilled) : base()
        {
            ToBeFilled = toBeFilled;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/EBlueprintTextLiteralType.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode
{
    /// <summary>
    /// Kinds of text literals
    /// </summary>
    public enum EBlueprintTextLiteralType : byte
	{
		/// <summary>
		/// Text is an empty string. The bytecode contains no strings, and you should use FText::GetEmpty() to initialize the FText instance.
		/// </summary>
		Empty,
		/// <summary>
		/// Text is localized. The bytecode will contain three strings - source, key, and namespace - and should be loaded via FInternationalization
		/// </summary>
		LocalizedText,
		/// <summary>
		/// Text is culture invariant. The bytecode will contain one string, and you should use FText::AsCultureInvariant to initialize the FText instance.
		/// </summary>
		InvariantText,
		/// <summary>
		/// Text is a literal FString. The bytecode will contain one string, and you should use FText::FromString to initialize the FText instance.
		/// </summary>
		LiteralString,
		/// <summary>
		/// Text is from a string table. The bytecode will contain an object pointer (not used) and two strings - the table ID, and key - and should be found via FText::FromStringTable
		/// </summary>
		StringTableEntry
	}
}

```

`UAssetAPI/Kismet/Bytecode/EExprToken.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode
{
    /// <summary>
    /// Evaluatable expression item types.
    /// </summary>
    public enum EExprToken
	{
		/// <summary>A local variable.</summary>
		EX_LocalVariable = 0x00,
		/// <summary>An object variable.</summary>
		EX_InstanceVariable = 0x01,
		/// <summary>Default variable for a class context.</summary>
		EX_DefaultVariable = 0x02,
		/// <summary>Return from function.</summary>
		EX_Return = 0x04,
		/// <summary>Goto a local address in code.</summary>
		EX_Jump = 0x06,
		/// <summary>Goto if not expression.</summary>
		EX_JumpIfNot = 0x07,
		/// <summary>Assertion.</summary>
		EX_Assert = 0x09,
		/// <summary>No operation.</summary>
		EX_Nothing = 0x0B,
		/// <summary>No operation with an int32 argument (useful for debugging script disassembly).</summary>
		EX_NothingInt32 = 0x0C,
		/// <summary>Assign an arbitrary size value to a variable.</summary>
		EX_Let = 0x0F,
		/// <summary>Assign to a single bit, defined by an FProperty.</summary>
		EX_BitFieldConst = 0x11,
		/// <summary>Class default object context.</summary>
		EX_ClassContext = 0x12,
		/// <summary>Metaclass cast.</summary>
		EX_MetaCast = 0x13,
		/// <summary>Let boolean variable.</summary>
		EX_LetBool = 0x14,
		/// <summary>end of default value for optional function parameter</summary>
		EX_EndParmValue = 0x15,
		/// <summary>End of function call parameters.</summary>
		EX_EndFunctionParms = 0x16,
		/// <summary>Self object.</summary>
		EX_Self = 0x17,
		/// <summary>Skippable expression.</summary>
		EX_Skip = 0x18,
		/// <summary>Call a function through an object context.</summary>
		EX_Context = 0x19,
		/// <summary>Call a function through an object context (can fail silently if the context is NULL; only generated for functions that don't have output or return values).</summary>
		EX_Context_FailSilent = 0x1A,
		/// <summary>A function call with parameters.</summary>
		EX_VirtualFunction = 0x1B,
		/// <summary>A prebound function call with parameters.</summary>
		EX_FinalFunction = 0x1C,
		/// <summary>Int constant.</summary>
		EX_IntConst = 0x1D,
		/// <summary>Floating point constant.</summary>
		EX_FloatConst = 0x1E,
		/// <summary>String constant.</summary>
		EX_StringConst = 0x1F,
		/// <summary>An object constant.</summary>
		EX_ObjectConst = 0x20,
		/// <summary>A name constant.</summary>
		EX_NameConst = 0x21,
		/// <summary>A rotation constant.</summary>
		EX_RotationConst = 0x22,
		/// <summary>A vector constant.</summary>
		EX_VectorConst = 0x23,
		/// <summary>A byte constant.</summary>
		EX_ByteConst = 0x24,
		/// <summary>Zero.</summary>
		EX_IntZero = 0x25,
		/// <summary>One.</summary>
		EX_IntOne = 0x26,
		/// <summary>Bool True.</summary>
		EX_True = 0x27,
		/// <summary>Bool False.</summary>
		EX_False = 0x28,
		/// <summary>FText constant</summary>
		EX_TextConst = 0x29,
		/// <summary>NoObject.</summary>
		EX_NoObject = 0x2A,
		/// <summary>A transform constant</summary>
		EX_TransformConst = 0x2B,
		/// <summary>Int constant that requires 1 byte.</summary>
		EX_IntConstByte = 0x2C,
		/// <summary>A null interface (similar to EX_NoObject, but for interfaces)</summary>
		EX_NoInterface = 0x2D,
		/// <summary>Safe dynamic class casting.</summary>
		EX_DynamicCast = 0x2E,
		/// <summary>An arbitrary UStruct constant</summary>
		EX_StructConst = 0x2F,
		/// <summary>End of UStruct constant</summary>
		EX_EndStructConst = 0x30,
		/// <summary>Set the value of arbitrary array</summary>
		EX_SetArray = 0x31,
		EX_EndArray = 0x32,
		/// <summary>FProperty constant.</summary>
		EX_PropertyConst = 0x33,
		/// <summary>Unicode string constant.</summary>
		EX_UnicodeStringConst = 0x34,
		/// <summary>64-bit integer constant.</summary>
		EX_Int64Const = 0x35,
		/// <summary>64-bit unsigned integer constant.</summary>
		EX_UInt64Const = 0x36,
		/// <summary>Double-precision floating point constant.</summary>
		EX_DoubleConst = 0x37,
		/// <summary>A casting operator for primitives which reads the type as the subsequent byte</summary>
		EX_PrimitiveCast = 0x38,
		EX_SetSet = 0x39,
		EX_EndSet = 0x3A,
		EX_SetMap = 0x3B,
		EX_EndMap = 0x3C,
		EX_SetConst = 0x3D,
		EX_EndSetConst = 0x3E,
		EX_MapConst = 0x3F,
		EX_EndMapConst = 0x40,
		/// <summary>A float vector constant.</summary>
		EX_Vector3fConst = 0x41,
		/// <summary>Context expression to address a property within a struct</summary>
		EX_StructMemberContext = 0x42,
		/// <summary>Assignment to a multi-cast delegate</summary>
		EX_LetMulticastDelegate = 0x43,
		/// <summary>Assignment to a delegate</summary>
		EX_LetDelegate = 0x44,
		/// <summary>Special instructions to quickly call a virtual function that we know is going to run only locally</summary>
		EX_LocalVirtualFunction = 0x45,
		/// <summary>Special instructions to quickly call a final function that we know is going to run only locally</summary>
		EX_LocalFinalFunction = 0x46,
		/// <summary>local out (pass by reference) function parameter</summary>
		EX_LocalOutVariable = 0x48,
		EX_DeprecatedOp4A = 0x4A,
		/// <summary>const reference to a delegate or normal function object</summary>
		EX_InstanceDelegate = 0x4B,
		/// <summary>push an address on to the execution flow stack for future execution when a EX_PopExecutionFlow is executed. Execution continues on normally and doesn't change to the pushed address.</summary>
		EX_PushExecutionFlow = 0x4C,
		/// <summary>continue execution at the last address previously pushed onto the execution flow stack.</summary>
		EX_PopExecutionFlow = 0x4D,
		/// <summary>Goto a local address in code, specified by an integer value.</summary>
		EX_ComputedJump = 0x4E,
		/// <summary>continue execution at the last address previously pushed onto the execution flow stack, if the condition is not true.</summary>
		EX_PopExecutionFlowIfNot = 0x4F,
		/// <summary>Breakpoint. Only observed in the editor, otherwise it behaves like EX_Nothing.</summary>
		EX_Breakpoint = 0x50,
		/// <summary>Call a function through a native interface variable</summary>
		EX_InterfaceContext = 0x51,
		/// <summary>Converting an object reference to native interface variable</summary>
		EX_ObjToInterfaceCast = 0x52,
		/// <summary>Last byte in script code</summary>
		EX_EndOfScript = 0x53,
		/// <summary>Converting an interface variable reference to native interface variable</summary>
		EX_CrossInterfaceCast = 0x54,
		/// <summary>Converting an interface variable reference to an object</summary>
		EX_InterfaceToObjCast = 0x55,
		/// <summary>Trace point.  Only observed in the editor, otherwise it behaves like EX_Nothing.</summary>
		EX_WireTracepoint = 0x5A,
		/// <summary>A CodeSizeSkipOffset constant</summary>
		EX_SkipOffsetConst = 0x5B,
		/// <summary>Adds a delegate to a multicast delegate's targets</summary>
		EX_AddMulticastDelegate = 0x5C,
		/// <summary>Clears all delegates in a multicast target</summary>
		EX_ClearMulticastDelegate = 0x5D,
		/// <summary>Trace point.  Only observed in the editor, otherwise it behaves like EX_Nothing.</summary>
		EX_Tracepoint = 0x5E,
		/// <summary>assign to any object ref pointer</summary>
		EX_LetObj = 0x5F,
		/// <summary>assign to a weak object pointer</summary>
		EX_LetWeakObjPtr = 0x60,
		/// <summary>bind object and name to delegate</summary>
		EX_BindDelegate = 0x61,
		/// <summary>Remove a delegate from a multicast delegate's targets</summary>
		EX_RemoveMulticastDelegate = 0x62,
		/// <summary>Call multicast delegate</summary>
		EX_CallMulticastDelegate = 0x63,
		EX_LetValueOnPersistentFrame = 0x64,
		EX_ArrayConst = 0x65,
		EX_EndArrayConst = 0x66,
		EX_SoftObjectConst = 0x67,
		/// <summary>static pure function from on local call space</summary>
		EX_CallMath = 0x68,
		EX_SwitchValue = 0x69,
		/// <summary>Instrumentation event</summary>
		EX_InstrumentationEvent = 0x6A,
		EX_ArrayGetByRef = 0x6B,
		/// <summary>Sparse data variable</summary>
		EX_ClassSparseDataVariable = 0x6C,
		EX_FieldPathConst = 0x6D,
        /// <summary>
        /// AutoRTFM: run following code in a transaction
        /// </summary>
        EX_AutoRtfmTransact = 0x70,
        /// <summary>
        /// AutoRTFM: if in a transaction, abort or break, otherwise no operation
        /// </summary>
        EX_AutoRtfmStopTransact = 0x71,
        /// <summary>
        /// AutoRTFM: evaluate bool condition, abort transaction on false
        /// </summary>
        EX_AutoRtfmAbortIfNot = 0x72,
        EX_Max = 0xFF
	};

	public enum ECastToken {
		ObjectToInterface = 0x46,
		ObjectToBool = 0x47,
		InterfaceToBool = 0x49,
		Max = 0xFF,
	};
}

```

`UAssetAPI/Kismet/Bytecode/EScriptInstrumentationType.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode
{
	public enum EScriptInstrumentationType : byte {
		Class = 0,
		ClassScope,
		Instance,
		Event,
		InlineEvent,
		ResumeEvent,
		PureNodeEntry,
		NodeDebugSite,
		NodeEntry,
		NodeExit,
		PushState,
		RestoreState,
		ResetState,
		SuspendState,
		PopState,
		TunnelEndOfThread,
		Stop
	}
}

```

`UAssetAPI/Kismet/Bytecode/ExpressionSerializer.cs`:

```cs
using System;
using UAssetAPI.Kismet.Bytecode.Expressions;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode
{
    public static class ExpressionSerializer
    {
        public static KismetExpression ReadExpression(AssetBinaryReader reader)
        {
            KismetExpression res = null;
            EExprToken token = (EExprToken)reader.ReadByte();
            switch (token)
            {
                case EExprToken.EX_LocalVariable:
                    res = new EX_LocalVariable();
                    break;
                case EExprToken.EX_InstanceVariable:
                    res = new EX_InstanceVariable();
                    break;
                case EExprToken.EX_DefaultVariable:
                    res = new EX_DefaultVariable();
                    break;
                case EExprToken.EX_Return:
                    res = new EX_Return();
                    break;
                case EExprToken.EX_Jump:
                    res = new EX_Jump();
                    break;
                case EExprToken.EX_JumpIfNot:
                    res = new EX_JumpIfNot();
                    break;
                case EExprToken.EX_Assert:
                    res = new EX_Assert();
                    break;
                case EExprToken.EX_Nothing:
                    res = new EX_Nothing();
                    break;
                case EExprToken.EX_NothingInt32:
                    res = new EX_NothingInt32();
                    break;
                case EExprToken.EX_Let:
                    res = new EX_Let();
                    break;
                case EExprToken.EX_BitFieldConst:
                    res = new EX_BitFieldConst();
                    break;
                case EExprToken.EX_ClassContext:
                    res = new EX_ClassContext();
                    break;
                case EExprToken.EX_MetaCast:
                    res = new EX_MetaCast();
                    break;
                case EExprToken.EX_LetBool:
                    res = new EX_LetBool();
                    break;
                case EExprToken.EX_EndParmValue:
                    res = new EX_EndParmValue();
                    break;
                case EExprToken.EX_EndFunctionParms:
                    res = new EX_EndFunctionParms();
                    break;
                case EExprToken.EX_Self:
                    res = new EX_Self();
                    break;
                case EExprToken.EX_Skip:
                    res = new EX_Skip();
                    break;
                case EExprToken.EX_Context:
                    res = new EX_Context();
                    break;
                case EExprToken.EX_Context_FailSilent:
                    res = new EX_Context_FailSilent();
                    break;
                case EExprToken.EX_VirtualFunction:
                    res = new EX_VirtualFunction();
                    break;
                case EExprToken.EX_FinalFunction:
                    res = new EX_FinalFunction();
                    break;
                case EExprToken.EX_IntConst:
                    res = new EX_IntConst();
                    break;
                case EExprToken.EX_FloatConst:
                    res = new EX_FloatConst();
                    break;
                case EExprToken.EX_DoubleConst:
                    res = new EX_DoubleConst();
                    break;
                case EExprToken.EX_StringConst:
                    res = new EX_StringConst();
                    break;
                case EExprToken.EX_ObjectConst:
                    res = new EX_ObjectConst();
                    break;
                case EExprToken.EX_NameConst:
                    res = new EX_NameConst();
                    break;
                case EExprToken.EX_RotationConst:
                    res = new EX_RotationConst();
                    break;
                case EExprToken.EX_VectorConst:
                    res = new EX_VectorConst();
                    break;
                case EExprToken.EX_ByteConst:
                    res = new EX_ByteConst();
                    break;
                case EExprToken.EX_IntZero:
                    res = new EX_IntZero();
                    break;
                case EExprToken.EX_IntOne:
                    res = new EX_IntOne();
                    break;
                case EExprToken.EX_True:
                    res = new EX_True();
                    break;
                case EExprToken.EX_False:
                    res = new EX_False();
                    break;
                case EExprToken.EX_TextConst:
                    res = new EX_TextConst();
                    break;
                case EExprToken.EX_NoObject:
                    res = new EX_NoObject();
                    break;
                case EExprToken.EX_TransformConst:
                    res = new EX_TransformConst();
                    break;
                case EExprToken.EX_IntConstByte:
                    res = new EX_IntConstByte();
                    break;
                case EExprToken.EX_NoInterface:
                    res = new EX_NoInterface();
                    break;
                case EExprToken.EX_DynamicCast:
                    res = new EX_DynamicCast();
                    break;
                case EExprToken.EX_StructConst:
                    res = new EX_StructConst();
                    break;
                case EExprToken.EX_EndStructConst:
                    res = new EX_EndStructConst();
                    break;
                case EExprToken.EX_SetArray:
                    res = new EX_SetArray();
                    break;
                case EExprToken.EX_EndArray:
                    res = new EX_EndArray();
                    break;
                case EExprToken.EX_PropertyConst:
                    res = new EX_PropertyConst();
                    break;
                case EExprToken.EX_UnicodeStringConst:
                    res = new EX_UnicodeStringConst();
                    break;
                case EExprToken.EX_Int64Const:
                    res = new EX_Int64Const();
                    break;
                case EExprToken.EX_UInt64Const:
                    res = new EX_UInt64Const();
                    break;
                case EExprToken.EX_PrimitiveCast:
                    res = new EX_PrimitiveCast();
                    break;
                case EExprToken.EX_SetSet:
                    res = new EX_SetSet();
                    break;
                case EExprToken.EX_EndSet:
                    res = new EX_EndSet();
                    break;
                case EExprToken.EX_SetMap:
                    res = new EX_SetMap();
                    break;
                case EExprToken.EX_EndMap:
                    res = new EX_EndMap();
                    break;
                case EExprToken.EX_SetConst:
                    res = new EX_SetConst();
                    break;
                case EExprToken.EX_EndSetConst:
                    res = new EX_EndSetConst();
                    break;
                case EExprToken.EX_MapConst:
                    res = new EX_MapConst();
                    break;
                case EExprToken.EX_EndMapConst:
                    res = new EX_EndMapConst();
                    break;
                case EExprToken.EX_Vector3fConst:
                    res = new EX_Vector3fConst();
                    break;
                case EExprToken.EX_StructMemberContext:
                    res = new EX_StructMemberContext();
                    break;
                case EExprToken.EX_LetMulticastDelegate:
                    res = new EX_LetMulticastDelegate();
                    break;
                case EExprToken.EX_LetDelegate:
                    res = new EX_LetDelegate();
                    break;
                case EExprToken.EX_LocalVirtualFunction:
                    res = new EX_LocalVirtualFunction();
                    break;
                case EExprToken.EX_LocalFinalFunction:
                    res = new EX_LocalFinalFunction();
                    break;
                case EExprToken.EX_LocalOutVariable:
                    res = new EX_LocalOutVariable();
                    break;
                case EExprToken.EX_DeprecatedOp4A:
                    res = new EX_DeprecatedOp4A();
                    break;
                case EExprToken.EX_InstanceDelegate:
                    res = new EX_InstanceDelegate();
                    break;
                case EExprToken.EX_PushExecutionFlow:
                    res = new EX_PushExecutionFlow();
                    break;
                case EExprToken.EX_PopExecutionFlow:
                    res = new EX_PopExecutionFlow();
                    break;
                case EExprToken.EX_ComputedJump:
                    res = new EX_ComputedJump();
                    break;
                case EExprToken.EX_PopExecutionFlowIfNot:
                    res = new EX_PopExecutionFlowIfNot();
                    break;
                case EExprToken.EX_Breakpoint:
                    res = new EX_Breakpoint();
                    break;
                case EExprToken.EX_InterfaceContext:
                    res = new EX_InterfaceContext();
                    break;
                case EExprToken.EX_ObjToInterfaceCast:
                    res = new EX_ObjToInterfaceCast();
                    break;
                case EExprToken.EX_EndOfScript:
                    res = new EX_EndOfScript();
                    break;
                case EExprToken.EX_CrossInterfaceCast:
                    res = new EX_CrossInterfaceCast();
                    break;
                case EExprToken.EX_InterfaceToObjCast:
                    res = new EX_InterfaceToObjCast();
                    break;
                case EExprToken.EX_WireTracepoint:
                    res = new EX_WireTracepoint();
                    break;
                case EExprToken.EX_SkipOffsetConst:
                    res = new EX_SkipOffsetConst();
                    break;
                case EExprToken.EX_AddMulticastDelegate:
                    res = new EX_AddMulticastDelegate();
                    break;
                case EExprToken.EX_ClearMulticastDelegate:
                    res = new EX_ClearMulticastDelegate();
                    break;
                case EExprToken.EX_Tracepoint:
                    res = new EX_Tracepoint();
                    break;
                case EExprToken.EX_LetObj:
                    res = new EX_LetObj();
                    break;
                case EExprToken.EX_LetWeakObjPtr:
                    res = new EX_LetWeakObjPtr();
                    break;
                case EExprToken.EX_BindDelegate:
                    res = new EX_BindDelegate();
                    break;
                case EExprToken.EX_RemoveMulticastDelegate:
                    res = new EX_RemoveMulticastDelegate();
                    break;
                case EExprToken.EX_CallMulticastDelegate:
                    res = new EX_CallMulticastDelegate();
                    break;
                case EExprToken.EX_LetValueOnPersistentFrame:
                    res = new EX_LetValueOnPersistentFrame();
                    break;
                case EExprToken.EX_ArrayConst:
                    res = new EX_ArrayConst();
                    break;
                case EExprToken.EX_EndArrayConst:
                    res = new EX_EndArrayConst();
                    break;
                case EExprToken.EX_SoftObjectConst:
                    res = new EX_SoftObjectConst();
                    break;
                case EExprToken.EX_CallMath:
                    res = new EX_CallMath();
                    break;
                case EExprToken.EX_SwitchValue:
                    res = new EX_SwitchValue();
                    break;
                case EExprToken.EX_InstrumentationEvent:
                    res = new EX_InstrumentationEvent();
                    break;
                case EExprToken.EX_ArrayGetByRef:
                    res = new EX_ArrayGetByRef();
                    break;
                case EExprToken.EX_ClassSparseDataVariable:
                    res = new EX_ClassSparseDataVariable();
                    break;
                case EExprToken.EX_FieldPathConst:
                    res = new EX_FieldPathConst();
                    break;
                default:
                    throw new NotImplementedException("Unimplemented token " + token);
            }

            if (res != null)
            {
                res.Read(reader);
            }
            return res;
        }

        public static int WriteExpression(KismetExpression expr, AssetBinaryWriter writer)
        {
            writer.Write((byte)expr.Token);
            return expr.Write(writer) + sizeof(byte);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_AddMulticastDelegate.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_AddMulticastDelegate"/> instruction.
    /// </summary>
    public class EX_AddMulticastDelegate : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_AddMulticastDelegate; } }

        /// <summary>
        /// Delegate property to assign to.
        /// </summary>
        [JsonProperty]
        public KismetExpression Delegate;

        /// <summary>
        /// Delegate to add to the MC delegate for broadcast.
        /// </summary>
        [JsonProperty]
        public KismetExpression DelegateToAdd;

        public EX_AddMulticastDelegate()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Delegate = ExpressionSerializer.ReadExpression(reader);
            DelegateToAdd = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += ExpressionSerializer.WriteExpression(Delegate, writer);
            offset += ExpressionSerializer.WriteExpression(DelegateToAdd, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            Delegate.Visit(asset, ref offset, visitor);
            DelegateToAdd.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ArrayConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ArrayConst"/> instruction.
    /// </summary>
    public class EX_ArrayConst : KismetExpression<KismetExpression[]>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ArrayConst; } }

        /// <summary>
        /// Pointer to this constant's inner property (FProperty*).
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer InnerProperty;

        /// <summary>
        /// Array constant entries.
        /// </summary>
        [JsonProperty]
        public KismetExpression[] Elements;

        public EX_ArrayConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            InnerProperty = reader.XFER_PROP_POINTER();
            int numEntries = reader.ReadInt32(); // Number of elements
            Elements = reader.ReadExpressionArray(EExprToken.EX_EndArrayConst);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_PROP_POINTER(InnerProperty);
            writer.Write(Elements.Length); offset += sizeof(int);
            for (int i = 0; i < Elements.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Elements[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndArrayConst(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 12; // InnerProperty (8) + NumElements (4)
            foreach (var element in Elements)
            {
                element.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndArrayConst
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ArrayGetByRef.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ArrayGetByRef"/> instruction.
    /// </summary>
    public class EX_ArrayGetByRef : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ArrayGetByRef; } }

        /// <summary>
        /// The array variable.
        /// </summary>
        [JsonProperty]
        public KismetExpression ArrayVariable;

        /// <summary>
        /// The index to access in the array.
        /// </summary>
        [JsonProperty]
        public KismetExpression ArrayIndex;

        public EX_ArrayGetByRef()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            ArrayVariable = ExpressionSerializer.ReadExpression(reader);
            ArrayIndex = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += ExpressionSerializer.WriteExpression(ArrayVariable, writer);
            offset += ExpressionSerializer.WriteExpression(ArrayIndex, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            ArrayVariable.Visit(asset, ref offset, visitor);
            ArrayIndex.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Assert.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Assert"/> instruction.
    /// </summary>
    public class EX_Assert : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Assert; } }

        /// <summary>
        /// Line number.
        /// </summary>
        [JsonProperty]
        public ushort LineNumber;

        /// <summary>
        /// Whether or not this assertion is in debug mode.
        /// </summary>
        [JsonProperty]
        public bool DebugMode;

        /// <summary>
        /// Expression to assert.
        /// </summary>
        [JsonProperty]
        public KismetExpression AssertExpression;

        public EX_Assert()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            LineNumber = reader.ReadUInt16();
            DebugMode = reader.ReadBoolean();
            AssertExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            writer.Write(LineNumber); offset += sizeof(ushort);
            writer.Write(DebugMode); offset += sizeof(bool);
            offset += ExpressionSerializer.WriteExpression(AssertExpression, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 3; // LineNumber (2) + DebugMode (1)
            AssertExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_BindDelegate.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_BindDelegate"/> instruction.
    /// </summary>
    public class EX_BindDelegate : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_BindDelegate; } }

        /// <summary>
        /// The name of the function assigned to the delegate.
        /// </summary>
        [JsonProperty]
        public FName FunctionName;

        /// <summary>
        /// Delegate property to assign to.
        /// </summary>
        [JsonProperty]
        public KismetExpression Delegate;

        /// <summary>
        /// Object to bind.
        /// </summary>
        [JsonProperty]
        public KismetExpression ObjectTerm;

        public EX_BindDelegate()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            FunctionName = reader.XFER_FUNC_NAME();
            Delegate = ExpressionSerializer.ReadExpression(reader);
            ObjectTerm = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_FUNC_NAME(FunctionName);
            offset += ExpressionSerializer.WriteExpression(Delegate, writer);
            offset += ExpressionSerializer.WriteExpression(ObjectTerm, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 12; // FunctionName (12)
            Delegate.Visit(asset, ref offset, visitor);
            ObjectTerm.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_BitFieldConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_BitFieldConst"/> instruction.
    /// Assigns to a single bit, defined by an FProperty.
    /// </summary>
    public class EX_BitFieldConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_BitFieldConst; } }

        /// <summary>
        /// A pointer to the bit property.
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer Property;

        /// <summary>
        /// The bit value.
        /// </summary>
        [JsonProperty]
        public byte Value;

        public EX_BitFieldConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Property = reader.XFER_PROP_POINTER();
            Value = reader.ReadByte();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = writer.XFER_PROP_POINTER(Property);
            writer.Write(Value);
            return offset + sizeof(byte);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 9; // Property (8) + Value (1)
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Breakpoint.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Breakpoint"/> instruction.
    /// </summary>
    public class EX_Breakpoint : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Breakpoint; } }

        public EX_Breakpoint()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ByteConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ByteConst"/> instruction.
    /// </summary>
    public class EX_ByteConst : KismetExpression<byte>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ByteConst; } }

        public EX_ByteConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadByte();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(byte);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 1; // Value
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_CallMath.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_CallMath"/> instruction.
    /// </summary>
    public class EX_CallMath : EX_FinalFunction
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_CallMath; } }

        public EX_CallMath() : base()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return base.Write(writer);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_CallMulticastDelegate.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_CallMulticastDelegate"/> instruction.
    /// </summary>
    public class EX_CallMulticastDelegate : EX_FinalFunction
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_CallMulticastDelegate; } }

        /// <summary>
        /// Delegate property.
        /// </summary>
        [JsonProperty]
        public KismetExpression Delegate;

        public EX_CallMulticastDelegate()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            StackNode = reader.XFER_FUNC_POINTER();
            Delegate = ExpressionSerializer.ReadExpression(reader);
            Parameters = reader.ReadExpressionArray(EExprToken.EX_EndFunctionParms);

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_FUNC_POINTER(StackNode);
            offset += ExpressionSerializer.WriteExpression(Delegate, writer);

            for (int i = 0; i < Parameters.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Parameters[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndFunctionParms(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            visitor(this, offset);
            offset++;
            offset += 8; // StackNode (8)
            Delegate.Visit(asset, ref offset, visitor);
            foreach (var param in Parameters)
            {
                param.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndFunctionParms
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_CastBase.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// Base class for several type cast expressions
    /// </summary>
    public abstract class EX_CastBase : KismetExpression
    {
        /// <summary>
        /// The interface class to convert to.
        /// </summary>
        [JsonProperty]
        public FPackageIndex ClassPtr;

        /// <summary>
        /// The target of this expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression Target;

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            ClassPtr = reader.XFER_OBJECT_POINTER();
            Target = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_OBJECT_POINTER(ClassPtr);
            offset += ExpressionSerializer.WriteExpression(Target, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // ClassPtr (8)
            Target.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ClassContext.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ClassContext"/> instruction.
    /// </summary>
    public class EX_ClassContext : EX_Context
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ClassContext; } }

        public EX_ClassContext()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return base.Write(writer);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ClassSparseDataVariable.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ClassSparseDataVariable"/> instruction.
    /// </summary>
    public class EX_ClassSparseDataVariable : EX_VariableBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ClassSparseDataVariable; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ClearMulticastDelegate.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ClearMulticastDelegate"/> instruction.
    /// </summary>
    public class EX_ClearMulticastDelegate : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ClearMulticastDelegate; } }

        /// <summary>
        /// Delegate property to clear.
        /// </summary>
        [JsonProperty]
        public KismetExpression DelegateToClear;

        public EX_ClearMulticastDelegate()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            DelegateToClear = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return ExpressionSerializer.WriteExpression(DelegateToClear, writer);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            DelegateToClear.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ComputedJump.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ComputedJump"/> instruction.
    /// </summary>
    public class EX_ComputedJump : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ComputedJump; } }

        /// <summary>
        /// An integer expression corresponding to the offset to jump to.
        /// </summary>
        [JsonProperty]
        public KismetExpression CodeOffsetExpression;

        public EX_ComputedJump()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            CodeOffsetExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return ExpressionSerializer.WriteExpression(CodeOffsetExpression, writer);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            CodeOffsetExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Context.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Context"/> instruction.
    /// </summary>
    public class EX_Context : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Context; } }

        /// <summary>
        /// Object expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression ObjectExpression;

        /// <summary>
        /// Code offset for NULL expressions.
        /// </summary>
        [JsonProperty]
        public uint Offset;

        /// <summary>
        /// Old property type.
        /// </summary>
        [JsonProperty]
        public byte PropertyType;

        /// <summary>
        /// Property corresponding to the r-value data, in case the l-value needs to be mem-zero'd. FField*
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer RValuePointer;

        /// <summary>
        /// Context expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression ContextExpression;

        public EX_Context()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            ObjectExpression = ExpressionSerializer.ReadExpression(reader);
            Offset = reader.ReadUInt32();
            RValuePointer = reader.XFER_PROP_POINTER();
            if (reader.Asset.ObjectVersion <= ObjectVersion.VER_UE4_SERIALIZE_BLUEPRINT_EVENTGRAPH_FASTCALLS_IN_UFUNCTION)
            {
                PropertyType = reader.ReadByte();
            }
            ContextExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += ExpressionSerializer.WriteExpression(ObjectExpression, writer);
            writer.Write(Offset); offset += sizeof(uint);
            offset += writer.XFER_PROP_POINTER(RValuePointer);
            if (writer.Asset.ObjectVersion <= ObjectVersion.VER_UE4_SERIALIZE_BLUEPRINT_EVENTGRAPH_FASTCALLS_IN_UFUNCTION)
            {
                writer.Write(PropertyType);
                offset += sizeof(byte);
            }
            offset += ExpressionSerializer.WriteExpression(ContextExpression, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            ObjectExpression.Visit(asset, ref offset, visitor);
            offset += 12; // Offset (4) + RValuePointer (8)
            ContextExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Context_FailSilent.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Context_FailSilent"/> instruction.
    /// </summary>
    public class EX_Context_FailSilent : EX_Context
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Context_FailSilent; } }

        public EX_Context_FailSilent()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return base.Write(writer);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_CrossInterfaceCast.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_CrossInterfaceCast"/> instruction.
    /// </summary>
    public class EX_CrossInterfaceCast : EX_CastBase
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_CrossInterfaceCast; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_DefaultVariable.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_DefaultVariable"/> instruction.
    /// </summary>
    public class EX_DefaultVariable : EX_VariableBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_DefaultVariable; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_DeprecatedOp4A.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_DeprecatedOp4A"/> instruction.
    /// </summary>
    public class EX_DeprecatedOp4A : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_DeprecatedOp4A; } }

        public EX_DeprecatedOp4A()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_DoubleConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.JSON;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_DoubleConst"/> instruction.
    /// </summary>
    public class EX_DoubleConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_DoubleConst; } }

        /// <summary>
        /// The value of this double constant expression.
        /// </summary>
        [JsonProperty]
        [JsonConverter(typeof(FSignedZeroJsonConverter))]
        public double Value;

        public EX_DoubleConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadDouble();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(double);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // Value
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_DynamicCast.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_DynamicCast"/> instruction.
    /// </summary>
    public class EX_DynamicCast : EX_CastBase
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_DynamicCast; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndArray.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndArray"/> instruction.
    /// </summary>
    public class EX_EndArray : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndArray; } }

        public EX_EndArray()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndArrayConst.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndArrayConst"/> instruction.
    /// </summary>
    public class EX_EndArrayConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndArrayConst; } }

        public EX_EndArrayConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndFunctionParms.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndFunctionParms"/> instruction.
    /// </summary>
    public class EX_EndFunctionParms : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndFunctionParms; } }

        public EX_EndFunctionParms()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndMap.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndMap"/> instruction.
    /// </summary>
    public class EX_EndMap : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndMap; } }

        public EX_EndMap()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndMapConst.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndMapConst"/> instruction.
    /// </summary>
    public class EX_EndMapConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndMapConst; } }

        public EX_EndMapConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndOfScript.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndOfScript"/> instruction.
    /// </summary>
    public class EX_EndOfScript : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndOfScript; } }

        public EX_EndOfScript()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndParmValue.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndParmValue"/> instruction.
    /// </summary>
    public class EX_EndParmValue : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndParmValue; } }

        public EX_EndParmValue()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndSet.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndSet"/> instruction.
    /// </summary>
    public class EX_EndSet : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndSet; } }

        public EX_EndSet()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndSetConst.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndSetConst"/> instruction.
    /// </summary>
    public class EX_EndSetConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndSetConst; } }

        public EX_EndSetConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_EndStructConst.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_EndStructConst"/> instruction.
    /// </summary>
    public class EX_EndStructConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_EndStructConst; } }

        public EX_EndStructConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_False.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_False"/> instruction.
    /// </summary>
    public class EX_False : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_False; } }

        public EX_False()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_FieldPathConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_FieldPathConst"/> instruction.
    /// </summary>
    public class EX_FieldPathConst : KismetExpression<KismetExpression>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_FieldPathConst; } }

        public EX_FieldPathConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return ExpressionSerializer.WriteExpression(Value, writer);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            Value.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_FinalFunction.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_FinalFunction"/> instruction.
    /// </summary>
    public class EX_FinalFunction : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_FinalFunction; } }

        /// <summary>
        /// Stack node.
        /// </summary>
        [JsonProperty]
        public FPackageIndex StackNode;

        /// <summary>
        /// List of parameters for this function.
        /// </summary>
        [JsonProperty]
        public KismetExpression[] Parameters;

        public EX_FinalFunction()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            StackNode = reader.XFER_FUNC_POINTER();

            Parameters = reader.ReadExpressionArray(EExprToken.EX_EndFunctionParms);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_FUNC_POINTER(StackNode);

            for (int i = 0; i < Parameters.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Parameters[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndFunctionParms(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // StackNode (8)
            foreach (var param in Parameters)
            {
                param.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndFunctionParms
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_FloatConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.JSON;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_FloatConst"/> instruction.
    /// </summary>
    public class EX_FloatConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_FloatConst; } }

        /// <summary>
        /// The value of this float constant expression.
        /// </summary>
        [JsonProperty]
        [JsonConverter(typeof(FSignedZeroJsonConverter))]
        public float Value;

        public EX_FloatConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadSingle();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(float);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 4; // Value
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_InstanceDelegate.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_InstanceDelegate"/> instruction.
    /// </summary>
    public class EX_InstanceDelegate : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_InstanceDelegate; } }

        /// <summary>
        /// The name of the function assigned to the delegate.
        /// </summary>
        [JsonProperty]
        public FName FunctionName;

        public EX_InstanceDelegate()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            FunctionName = reader.XFER_FUNC_NAME();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return writer.XFER_FUNC_NAME(FunctionName);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 12; // FunctionName (FName)
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_InstanceVariable.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_InstanceVariable"/> instruction.
    /// </summary>
    public class EX_InstanceVariable : EX_VariableBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_InstanceVariable; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_InstrumentationEvent.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{

    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_InstrumentationEvent"/> instruction.
    /// </summary>
    public class EX_InstrumentationEvent : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_InstrumentationEvent; } }

        [JsonProperty]
        public EScriptInstrumentationType EventType;
        [JsonProperty]
        public FName EventName;

        public EX_InstrumentationEvent()
        {
            
        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            EventType = (EScriptInstrumentationType)reader.ReadByte();

            if (EventType.Equals(EScriptInstrumentationType.InlineEvent))
            {
                EventName = reader.XFER_FUNC_NAME();
            }
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write((byte)EventType);
            if (EventType.Equals(EScriptInstrumentationType.InlineEvent)) {
                writer.XFER_FUNC_NAME(EventName);
                return 1 + 2 * sizeof(int);
            } else {
                return 1;
            }
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 1; // EventType
            if (EventType.Equals(EScriptInstrumentationType.InlineEvent))
            {
                offset += 12; // EventName (FName)
            }
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Int64Const.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Int64Const"/> instruction.
    /// </summary>
    public class EX_Int64Const : KismetExpression<long>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Int64Const; } }

        public EX_Int64Const()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadInt64();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(long);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // Value
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_IntConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_IntConst"/> instruction.
    /// </summary>
    public class EX_IntConst : KismetExpression<int>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_IntConst; } }

        public EX_IntConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadInt32();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(int);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 4; // Value
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_IntConstByte.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_IntConstByte"/> instruction.
    /// </summary>
    public class EX_IntConstByte : KismetExpression<byte>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_IntConstByte; } }

        public EX_IntConstByte()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadByte();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(byte);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_IntOne.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_IntOne"/> instruction.
    /// </summary>
    public class EX_IntOne : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_IntOne; } }

        public EX_IntOne()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_IntZero.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_IntZero"/> instruction.
    /// </summary>
    public class EX_IntZero : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_IntZero; } }

        public EX_IntZero()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_InterfaceContext.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_InterfaceContext"/> instruction.
    /// </summary>
    public class EX_InterfaceContext : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_InterfaceContext; } }

        /// <summary>
        /// Interface value.
        /// </summary>
        [JsonProperty]
        public KismetExpression InterfaceValue;

        public EX_InterfaceContext()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            InterfaceValue = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return ExpressionSerializer.WriteExpression(InterfaceValue, writer);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            InterfaceValue.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_InterfaceToObjCast.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_InterfaceToObjCast"/> instruction.
    /// </summary>
    public class EX_InterfaceToObjCast : EX_CastBase
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_InterfaceToObjCast; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Jump.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Jump"/> instruction.
    /// </summary>
    public class EX_Jump : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Jump; } }

        /// <summary>
        /// The offset to jump to.
        /// </summary>
        [JsonProperty]
        public uint CodeOffset;

        public EX_Jump()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            CodeOffset = reader.ReadUInt32();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(CodeOffset);
            return sizeof(uint);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 4; // CodeOffset
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_JumpIfNot.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_JumpIfNot"/> instruction.
    /// Conditional equivalent of the <see cref="EExprToken.EX_Jump"/> expression.
    /// </summary>
    public class EX_JumpIfNot : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_JumpIfNot; } }

        /// <summary>
        /// The offset to jump to if the provided expression evaluates to false.
        /// </summary>
        [JsonProperty]
        public uint CodeOffset;

        /// <summary>
        /// Expression to evaluate to determine whether or not a jump should be performed.
        /// </summary>
        [JsonProperty]
        public KismetExpression BooleanExpression;

        public EX_JumpIfNot()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            CodeOffset = reader.ReadUInt32();
            BooleanExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            writer.Write(CodeOffset); offset += sizeof(uint);
            offset += ExpressionSerializer.WriteExpression(BooleanExpression, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 4; // CodeOffset (4)
            BooleanExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Let.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Let"/> instruction.
    /// </summary>
    public class EX_Let : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Let; } }

        /// <summary>
        /// A pointer to the variable.
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer Value;
        [JsonProperty]
        public KismetExpression Variable;
        [JsonProperty]
        public KismetExpression Expression;

        public EX_Let()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            if (reader.Asset.ObjectVersion > ObjectVersion.VER_UE4_SERIALIZE_BLUEPRINT_EVENTGRAPH_FASTCALLS_IN_UFUNCTION)
            {
                Value = reader.XFER_PROP_POINTER();
            }
            Variable = ExpressionSerializer.ReadExpression(reader);
            Expression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            if (writer.Asset.ObjectVersion > ObjectVersion.VER_UE4_SERIALIZE_BLUEPRINT_EVENTGRAPH_FASTCALLS_IN_UFUNCTION)
            {
                offset += writer.XFER_PROP_POINTER(Value);
            }
            offset += ExpressionSerializer.WriteExpression(Variable, writer);
            offset += ExpressionSerializer.WriteExpression(Expression, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // Value (8)
            Variable.Visit(asset, ref offset, visitor);
            Expression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LetBase.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// Base class for several Let (assignment) expressions
    /// </summary>
    public abstract class EX_LetBase : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LetDelegate; } }

        /// <summary>
        /// Variable expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression VariableExpression;

        /// <summary>
        /// Assignment expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression AssignmentExpression;

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            VariableExpression = ExpressionSerializer.ReadExpression(reader);
            AssignmentExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += ExpressionSerializer.WriteExpression(VariableExpression, writer);
            offset += ExpressionSerializer.WriteExpression(AssignmentExpression, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            VariableExpression.Visit(asset, ref offset, visitor);
            AssignmentExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LetBool.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LetBool"/> instruction.
    /// </summary>
    public class EX_LetBool : EX_LetBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LetBool; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LetDelegate.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LetDelegate"/> instruction.
    /// </summary>
    public class EX_LetDelegate : EX_LetBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LetDelegate; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LetMulticastDelegate.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LetMulticastDelegate"/> instruction.
    /// </summary>
    public class EX_LetMulticastDelegate : EX_LetBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LetMulticastDelegate; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LetObj.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LetObj"/> instruction.
    /// </summary>
    public class EX_LetObj : EX_LetBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LetObj; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LetValueOnPersistentFrame.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LetValueOnPersistentFrame"/> instruction.
    /// </summary>
    public class EX_LetValueOnPersistentFrame : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LetValueOnPersistentFrame; } }

        /// <summary>
        /// Destination property pointer.
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer DestinationProperty;

        /// <summary>
        /// Assignment expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression AssignmentExpression;

        public EX_LetValueOnPersistentFrame()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            DestinationProperty = reader.XFER_PROP_POINTER();
            AssignmentExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_PROP_POINTER(DestinationProperty);
            offset += ExpressionSerializer.WriteExpression(AssignmentExpression, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // DestinationProperty (8)
            AssignmentExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LetWeakObjPtr.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LetWeakObjPtr"/> instruction.
    /// </summary>
    public class EX_LetWeakObjPtr : EX_LetBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LetWeakObjPtr; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LocalFinalFunction.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LocalFinalFunction"/> instruction.
    /// </summary>
    public class EX_LocalFinalFunction : EX_FinalFunction
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LocalFinalFunction; } }

        public EX_LocalFinalFunction() : base()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return base.Write(writer);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LocalOutVariable.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LocalOutVariable"/> instruction.
    /// </summary>
    public class EX_LocalOutVariable : EX_VariableBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LocalOutVariable; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LocalVariable.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LocalVariable"/> instruction.
    /// </summary>
    public class EX_LocalVariable : EX_VariableBase
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LocalVariable; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_LocalVirtualFunction.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_LocalVirtualFunction"/> instruction.
    /// </summary>
    public class EX_LocalVirtualFunction : EX_VirtualFunction
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_LocalVirtualFunction; } }

        public EX_LocalVirtualFunction() : base()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            base.Read(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return base.Write(writer);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_MapConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_MapConst"/> instruction.
    /// </summary>
    public class EX_MapConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_MapConst; } }

        /// <summary>
        /// Pointer to this constant's key property (FProperty*).
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer KeyProperty;

        /// <summary>
        /// Pointer to this constant's value property (FProperty*).
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer ValueProperty;

        /// <summary>
        /// Set constant entries.
        /// </summary>
        [JsonProperty]
        public KismetExpression[] Elements;

        public EX_MapConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            KeyProperty = reader.XFER_PROP_POINTER();
            ValueProperty = reader.XFER_PROP_POINTER();
            int numEntries = reader.ReadInt32(); // Number of elements
            Elements = reader.ReadExpressionArray(EExprToken.EX_EndMapConst);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_PROP_POINTER(KeyProperty);
            offset += writer.XFER_PROP_POINTER(ValueProperty);
            writer.Write(Elements.Length / 2); offset += sizeof(int);
            for (int i = 0; i < Elements.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Elements[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndMapConst(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 20; // KeyProperty (8) + ValueProperty (8) + NumElements (4)
            foreach (var element in Elements)
            {
                element.Visit(asset, ref offset, visitor);
            }
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_MetaCast.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_MetaCast"/> instruction.
    /// </summary>
    public class EX_MetaCast : EX_CastBase
	{
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_MetaCast; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_NameConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_NameConst"/> instruction.
    /// </summary>
    public class EX_NameConst : KismetExpression<FName>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_NameConst; } }

        public EX_NameConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.XFERNAME();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return writer.XFERNAME(Value);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 12; // FName (Index + Number + ?)
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_NoInterface.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_NoInterface"/> instruction.
    /// </summary>
    public class EX_NoInterface : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_NoInterface; } }

        public EX_NoInterface()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_NoObject.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_NoObject"/> instruction.
    /// </summary>
    public class EX_NoObject : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_NoObject; } }

        public EX_NoObject()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Nothing.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Nothing"/> instruction.
    /// Represents a no-op.
    /// </summary>
    public class EX_Nothing : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Nothing; } }

        public EX_Nothing()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_NothingInt32.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_NothingInt32"/> instruction.
    /// No operation with an int32 argument (useful for debugging script disassembly).
    /// </summary>
    public class EX_NothingInt32 : KismetExpression<int>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_NothingInt32; } }

        public EX_NothingInt32()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadInt32();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(int);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 4; // Value
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ObjToInterfaceCast.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ObjToInterfaceCast"/> instruction.
    /// A conversion from an object or interface variable to a native interface variable.
    /// </summary>
    public class EX_ObjToInterfaceCast : EX_CastBase
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ObjToInterfaceCast; } }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_ObjectConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_ObjectConst"/> instruction.
    /// </summary>
    public class EX_ObjectConst : KismetExpression<FPackageIndex>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ObjectConst; } }

        public EX_ObjectConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.XFER_OBJECT_POINTER();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return writer.XFER_OBJECT_POINTER(Value);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // Value (FPackageIndex)
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_PopExecutionFlow.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_PopExecutionFlow"/> instruction.
    /// </summary>
    public class EX_PopExecutionFlow : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_PopExecutionFlow; } }

        public EX_PopExecutionFlow()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_PopExecutionFlowIfNot.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_PopExecutionFlowIfNot"/> instruction.
    /// Conditional equivalent of the <see cref="EExprToken.EX_PopExecutionFlow"/> expression.
    /// </summary>
    public class EX_PopExecutionFlowIfNot : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_PopExecutionFlowIfNot; } }

        /// <summary>
        /// Expression to evaluate to determine whether or not a pop should be performed.
        /// </summary>
        [JsonProperty]
        public KismetExpression BooleanExpression;

        public EX_PopExecutionFlowIfNot()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            BooleanExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return ExpressionSerializer.WriteExpression(BooleanExpression, writer);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            BooleanExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_PrimitiveCast.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_PrimitiveCast"/> instruction.
    /// </summary>
    public class EX_PrimitiveCast : KismetExpression
    {
        /// <summary>
        /// The type to cast to.
        /// </summary>
        [JsonProperty]
        public ECastToken ConversionType;

        /// <summary>
        /// The target of this expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression Target;

        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_PrimitiveCast; } }

        public EX_PrimitiveCast()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            ConversionType = (ECastToken)reader.ReadByte();
            Target = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            writer.Write((byte)ConversionType); offset += sizeof(byte);
            offset += ExpressionSerializer.WriteExpression(Target, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 1; // ConversionType (1)
            if (ConversionType == ECastToken.ObjectToInterface)
            {
                offset += 8; // InterfaceClass
            }
            Target.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_PropertyConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_PropertyConst"/> instruction.
    /// </summary>
    public class EX_PropertyConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_PropertyConst; } }

        /// <summary>
        /// A pointer to the property in question.
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer Property;

        public EX_PropertyConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Property = reader.XFER_PROP_POINTER();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return writer.XFER_PROP_POINTER(Property);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // Property (KismetPropertyPointer)
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_PushExecutionFlow.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_PushExecutionFlow"/> instruction.
    /// </summary>
    public class EX_PushExecutionFlow : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_PushExecutionFlow; } }

        /// <summary>
        /// The address to push onto the execution flow stack.
        /// </summary>
        [JsonProperty]
        public uint PushingAddress;

        public EX_PushExecutionFlow()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            PushingAddress = reader.ReadUInt32();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(PushingAddress);
            return sizeof(uint);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 4; // PushingAddress
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_RemoveMulticastDelegate.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_RemoveMulticastDelegate"/> instruction.
    /// </summary>
    public class EX_RemoveMulticastDelegate : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_RemoveMulticastDelegate; } }

        /// <summary>
        /// Delegate property to assign to.
        /// </summary>
        [JsonProperty]
        public KismetExpression Delegate;

        /// <summary>
        /// Delegate to add to the MC delegate for broadcast.
        /// </summary>
        [JsonProperty]
        public KismetExpression DelegateToAdd;

        public EX_RemoveMulticastDelegate()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Delegate = ExpressionSerializer.ReadExpression(reader);
            DelegateToAdd = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += ExpressionSerializer.WriteExpression(Delegate, writer);
            offset += ExpressionSerializer.WriteExpression(DelegateToAdd, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            Delegate.Visit(asset, ref offset, visitor);
            DelegateToAdd.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Return.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Return"/> instruction.
    /// </summary>
    public class EX_Return : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Return; } }

        /// <summary>
        /// The return expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression ReturnExpression;

        public EX_Return()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            ReturnExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return ExpressionSerializer.WriteExpression(ReturnExpression, writer);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            ReturnExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_RotationConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_RotationConst"/> instruction.
    /// </summary>
    public class EX_RotationConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_RotationConst; } }

        [JsonProperty]
        public FRotator Value;

        public EX_RotationConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
            {
                Value = new FRotator(reader.ReadDouble(), reader.ReadDouble(), reader.ReadDouble());
            }
            else
            {
                Value = new FRotator(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
            }
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
            {
                writer.Write(Value.Pitch);
                writer.Write(Value.Yaw);
                writer.Write(Value.Roll);
                return sizeof(double) * 3;
            }
            else
            {
                writer.Write(Value.PitchFloat);
                writer.Write(Value.YawFloat);
                writer.Write(Value.RollFloat);
                return sizeof(float) * 3;
            }
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES ? 24U : 12U;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Self.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Self"/> instruction.
    /// </summary>
    public class EX_Self : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Self; } }

        public EX_Self()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_SetArray.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_SetArray"/> instruction.
    /// </summary>
    public class EX_SetArray : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_SetArray; } }

        /// <summary>
        /// Array property to assign to
        /// </summary>
        [JsonProperty]
        public KismetExpression AssigningProperty;

        /// <summary>
        /// Pointer to the array inner property (FProperty*).
        /// Only used in engine versions prior to <see cref="ObjectVersion.VER_UE4_CHANGE_SETARRAY_BYTECODE"/>.
        /// </summary>
        [JsonProperty]
        public FPackageIndex ArrayInnerProp;

        /// <summary>
        /// Array items.
        /// </summary>
        [JsonProperty]
        public KismetExpression[] Elements;

        public EX_SetArray()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            if (reader.Asset.ObjectVersion >= ObjectVersion.VER_UE4_CHANGE_SETARRAY_BYTECODE)
            {
                AssigningProperty = ExpressionSerializer.ReadExpression(reader);
            }
            else
            {
                ArrayInnerProp = reader.XFERPTR();
            }

            Elements = reader.ReadExpressionArray(EExprToken.EX_EndArray);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            if (writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_CHANGE_SETARRAY_BYTECODE)
            {
                offset += ExpressionSerializer.WriteExpression(AssigningProperty, writer);
            }
            else
            {
                offset += writer.XFERPTR(ArrayInnerProp);
            }

            for (int i = 0; i < Elements.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Elements[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndArray(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            AssigningProperty.Visit(asset, ref offset, visitor);
            foreach (var element in Elements)
            {
                element.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndArray
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_SetConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_SetConst"/> instruction.
    /// </summary>
    public class EX_SetConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_SetConst; } }

        /// <summary>
        /// Pointer to this constant's inner property (FProperty*).
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer InnerProperty;

        /// <summary>
        /// Set constant entries.
        /// </summary>
        [JsonProperty]
        public KismetExpression[] Elements;

        public EX_SetConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            InnerProperty = reader.XFER_PROP_POINTER();
            int numEntries = reader.ReadInt32(); // Number of elements
            Elements = reader.ReadExpressionArray(EExprToken.EX_EndSetConst);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_PROP_POINTER(InnerProperty);
            writer.Write(Elements.Length); offset += sizeof(int);
            for (int i = 0; i < Elements.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Elements[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndSetConst(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 12; // InnerProperty (8) + NumElements (4)
            foreach (var e in Elements)
            {
                e.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndSetConst
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_SetMap.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_SetMap"/> instruction.
    /// </summary>
    public class EX_SetMap : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_SetMap; } }

        /// <summary>
        /// Map property.
        /// </summary>
        [JsonProperty]
        public KismetExpression MapProperty;

        /// <summary>
        /// Set entries.
        /// </summary>
        [JsonProperty]
        public KismetExpression[] Elements;

        public EX_SetMap()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            MapProperty = ExpressionSerializer.ReadExpression(reader);
            int numEntries = reader.ReadInt32(); // Number of elements
            Elements = reader.ReadExpressionArray(EExprToken.EX_EndMap);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += ExpressionSerializer.WriteExpression(MapProperty, writer);
            // count is number if pairs so is half the number of elements
            writer.Write(Elements.Length / 2); offset += sizeof(int);
            for (int i = 0; i < Elements.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Elements[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndMap(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            MapProperty.Visit(asset, ref offset, visitor);
            offset += 4; // NumElements
            foreach (var e in Elements)
            {
                e.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndMap
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_SetSet.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_SetSet"/> instruction.
    /// </summary>
    public class EX_SetSet : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_SetSet; } }

        /// <summary>
        /// Set property.
        /// </summary>
        [JsonProperty]
        public KismetExpression SetProperty;

        /// <summary>
        /// Set entries.
        /// </summary>
        [JsonProperty]
        public KismetExpression[] Elements;

        public EX_SetSet()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            SetProperty = ExpressionSerializer.ReadExpression(reader);
            int numEntries = reader.ReadInt32(); // Number of elements
            Elements = reader.ReadExpressionArray(EExprToken.EX_EndSet);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += ExpressionSerializer.WriteExpression(SetProperty, writer);
            writer.Write(Elements.Length); offset += sizeof(int);
            for (int i = 0; i < Elements.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Elements[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndSet(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            SetProperty.Visit(asset, ref offset, visitor);
            offset += 4; // NumElements
            foreach (var e in Elements)
            {
                e.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndSet
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Skip.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Skip"/> instruction.
    /// </summary>
    public class EX_Skip : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Skip; } }

        /// <summary>
        /// The offset to skip to.
        /// </summary>
        [JsonProperty]
        public uint CodeOffset;

        /// <summary>
        /// An expression to possibly skip.
        /// </summary>
        [JsonProperty]
        public KismetExpression SkipExpression;

        public EX_Skip()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            CodeOffset = reader.ReadUInt32();
            SkipExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            writer.Write(CodeOffset); offset += sizeof(uint);
            offset += ExpressionSerializer.WriteExpression(SkipExpression, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 4; // CodeOffset
            SkipExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_SkipOffsetConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_SkipOffsetConst"/> instruction.
    /// Represents a code offset constant.
    /// </summary>
    public class EX_SkipOffsetConst : KismetExpression<uint>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_SkipOffsetConst; } }

        public EX_SkipOffsetConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadUInt32();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(uint);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 4; // Value
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_SoftObjectConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_SoftObjectConst"/> instruction.
    /// </summary>
    public class EX_SoftObjectConst : KismetExpression<KismetExpression>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_SoftObjectConst; } }

        public EX_SoftObjectConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return ExpressionSerializer.WriteExpression(Value, writer);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            Value.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_StringConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_StringConst"/> instruction.
    /// </summary>
    public class EX_StringConst : KismetExpression<string>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_StringConst; } }

        public EX_StringConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.XFERSTRING();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return writer.XFERSTRING(Value);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += (uint)Value.Length + 1; // String + null terminator
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_StructConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_StructConst"/> instruction.
    /// </summary>
    public class EX_StructConst : KismetExpression<KismetExpression[]>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_StructConst; } }

        /// <summary>
        /// Pointer to the UScriptStruct in question.
        /// </summary>
        [JsonProperty]
        public FPackageIndex Struct;

        /// <summary>
        /// The size of the struct that this constant represents in memory in bytes.
        /// </summary>
        [JsonProperty]
        public int StructSize;

        public EX_StructConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Struct = reader.XFERPTR();
            StructSize = reader.ReadInt32();
            Value = reader.ReadExpressionArray(EExprToken.EX_EndStructConst);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFERPTR(Struct);
            writer.Write(StructSize); offset += sizeof(int);

            for (int i = 0; i < Value.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Value[i], writer);
            }

            // Write end expression
            offset += ExpressionSerializer.WriteExpression(new EX_EndStructConst(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 12; // Struct (8) + StructSize (4)
            foreach (var v in Value)
            {
                v.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndStructConst
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_StructMemberContext.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_StructMemberContext"/> instruction.
    /// </summary>
    public class EX_StructMemberContext : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_StructMemberContext; } }

        /// <summary>
        /// A pointer to the struct member expression (FProperty*).
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer StructMemberExpression;

        /// <summary>
        /// Struct expression.
        /// </summary>
        [JsonProperty]
        public KismetExpression StructExpression;

        public EX_StructMemberContext()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            StructMemberExpression = reader.XFER_PROP_POINTER();
            StructExpression = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_PROP_POINTER(StructMemberExpression);
            offset += ExpressionSerializer.WriteExpression(StructExpression, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // StructMemberExpression (8)
            StructExpression.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_SwitchValue.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// Represents a case in a Kismet bytecode switch statement.
    /// </summary>
    [JsonObject(MemberSerialization.OptIn)]
    public struct FKismetSwitchCase
    {
        /// <summary>
        /// The index value term of this case.
        /// </summary>
        [JsonProperty]
        public KismetExpression CaseIndexValueTerm;

        /// <summary>
        /// Code offset to the next case.
        /// </summary>
        [JsonProperty]
        public uint NextOffset;

        /// <summary>
        /// The main case term.
        /// </summary>
        [JsonProperty]
        public KismetExpression CaseTerm;

        public FKismetSwitchCase(KismetExpression caseIndexValueTerm, uint nextOffset, KismetExpression caseTerm)
        {
            CaseIndexValueTerm = caseIndexValueTerm;
            NextOffset = nextOffset;
            CaseTerm = caseTerm;
        }
    }

    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_SwitchValue"/> instruction.
    /// </summary>
    public class EX_SwitchValue : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_SwitchValue; } }

        /// <summary>
        /// Code offset to jump to when finished.
        /// </summary>
        [JsonProperty]
        public uint EndGotoOffset;

        /// <summary>
        /// The index term of this switch statement.
        /// </summary>
        [JsonProperty]
        public KismetExpression IndexTerm;

        /// <summary>
        /// The default term of this switch statement.
        /// </summary>
        [JsonProperty]
        public KismetExpression DefaultTerm;

        /// <summary>
        /// All the cases in this switch statement.
        /// </summary>
        [JsonProperty]
        public FKismetSwitchCase[] Cases;

        public EX_SwitchValue()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            ushort numCases = reader.ReadUInt16(); // number of cases, without default one
            EndGotoOffset = reader.ReadUInt32();
            IndexTerm = ExpressionSerializer.ReadExpression(reader);

            Cases = new FKismetSwitchCase[numCases];
            for (int i = 0; i < numCases; i++)
            {
                KismetExpression termA = ExpressionSerializer.ReadExpression(reader);
                uint termB = reader.ReadUInt32();
                KismetExpression termC = ExpressionSerializer.ReadExpression(reader);
                Cases[i] = new FKismetSwitchCase(termA, termB, termC);
            }

            DefaultTerm = ExpressionSerializer.ReadExpression(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            writer.Write((ushort)Cases.Length); offset += sizeof(ushort);
            writer.Write(EndGotoOffset); offset += sizeof(uint);
            offset += ExpressionSerializer.WriteExpression(IndexTerm, writer);
            for (int i = 0; i < Cases.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Cases[i].CaseIndexValueTerm, writer);
                writer.Write(Cases[i].NextOffset); offset += sizeof(uint);
                offset += ExpressionSerializer.WriteExpression(Cases[i].CaseTerm, writer);
            }
            offset += ExpressionSerializer.WriteExpression(DefaultTerm, writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 6; // NumCases (2) + EndGotoOffset (4)
            IndexTerm.Visit(asset, ref offset, visitor);
            foreach (var c in Cases)
            {
                c.CaseIndexValueTerm.Visit(asset, ref offset, visitor);
                offset += 4; // NextOffset
                c.CaseTerm.Visit(asset, ref offset, visitor);
            }
            DefaultTerm.Visit(asset, ref offset, visitor);
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_TextConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_TextConst"/> instruction.
    /// </summary>
    public class EX_TextConst : KismetExpression<FScriptText>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_TextConst; } }

        public EX_TextConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = new FScriptText();
            Value.Read(reader);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return Value.Write(writer);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 1; // TextLiteralType
            switch (Value.TextLiteralType)
            {
                case EBlueprintTextLiteralType.Empty:
                    break;
                case EBlueprintTextLiteralType.LocalizedText:
                    Value.LocalizedSource.Visit(asset, ref offset, visitor);
                    Value.LocalizedKey.Visit(asset, ref offset, visitor);
                    Value.LocalizedNamespace.Visit(asset, ref offset, visitor);
                    break;
                case EBlueprintTextLiteralType.InvariantText:
                    Value.InvariantLiteralString.Visit(asset, ref offset, visitor);
                    break;
                case EBlueprintTextLiteralType.LiteralString:
                    Value.LiteralString.Visit(asset, ref offset, visitor);
                    break;
                case EBlueprintTextLiteralType.StringTableEntry:
                    offset += 8; // StringTableAsset
                    Value.StringTableId.Visit(asset, ref offset, visitor);
                    Value.StringTableKey.Visit(asset, ref offset, visitor);
                    break;
            }
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Tracepoint.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Tracepoint"/> instruction.
    /// </summary>
    public class EX_Tracepoint : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Tracepoint; } }

        public EX_Tracepoint()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_TransformConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions;

/// <summary>
/// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_TransformConst"/> instruction.
/// </summary>
public class EX_TransformConst : KismetExpression<FTransform>
{
    /// <summary>
    /// The token of this expression.
    /// </summary>
    public override EExprToken Token { get { return EExprToken.EX_TransformConst; } }

    public EX_TransformConst() { Value = new(); }

    /// <summary>
    /// Reads out the expression from a BinaryReader.
    /// </summary>
    /// <param name="reader">The BinaryReader to read from.</param>
    public override void Read(AssetBinaryReader reader)
    {
        Value = new FTransform(reader);
    }

    /// <summary>
    /// Writes the expression to a BinaryWriter.
    /// </summary>
    /// <param name="writer">The BinaryWriter to write from.</param>
    /// <returns>The iCode offset of the data that was written.</returns>
    public override int Write(AssetBinaryWriter writer)
    {
        return Value.Write(writer);
    }

    public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
    {
        base.Visit(asset, ref offset, visitor);
        offset += asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES ? 80U : 40U;
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_True.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_True"/> instruction.
    /// </summary>
    public class EX_True : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_True; } }

        public EX_True()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_UInt64Const.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_UInt64Const"/> instruction.
    /// </summary>
    public class EX_UInt64Const : KismetExpression<ulong>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_UInt64Const; } }

        public EX_UInt64Const()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.ReadUInt64();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(Value);
            return sizeof(ulong);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // Value
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_UnicodeStringConst.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_UnicodeStringConst"/> instruction.
    /// </summary>
    public class EX_UnicodeStringConst : KismetExpression<string>
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_UnicodeStringConst; } }

        public EX_UnicodeStringConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Value = reader.XFERUNICODESTRING();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return writer.XFERUNICODESTRING(Value);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 2 * ((uint)Value.Length + 1); // Unicode string + null terminator (2 bytes per char)
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_VariableBase.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// Base class for Kismet Variable expressions
    /// </summary>
    public abstract class EX_VariableBase : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_ClassSparseDataVariable; } }

        /// <summary>
        /// A pointer to the variable in question.
        /// </summary>
        [JsonProperty]
        public KismetPropertyPointer Variable;

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            Variable = reader.XFER_PROP_POINTER();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return writer.XFER_PROP_POINTER(Variable);
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 8; // Variable (KismetPropertyPointer)
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_Vector3fConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_Vector3fConst"/> instruction.
    /// A float vector constant (always 3 floats, regardless of LWC).
    /// </summary>
    public class EX_Vector3fConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_Vector3fConst; } }

        [JsonProperty]
        public float X;

        [JsonProperty]
        public float Y;

        [JsonProperty]
        public float Z;

        public EX_Vector3fConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            X = reader.ReadSingle();
            Y = reader.ReadSingle();
            Z = reader.ReadSingle();
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            writer.Write(X);
            writer.Write(Y);
            writer.Write(Z);
            return sizeof(float) * 3;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 12; // 3 floats
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_VectorConst.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_VectorConst"/> instruction.
    /// </summary>
    public class EX_VectorConst : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_VectorConst; } }

        [JsonProperty]
        public FVector Value;

        public EX_VectorConst()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
            {
                Value = new FVector(reader.ReadDouble(), reader.ReadDouble(), reader.ReadDouble());
            }
            else
            {
                Value = new FVector(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
            }
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
            {
                writer.Write(Value.X);
                writer.Write(Value.Y);
                writer.Write(Value.Z);
                return sizeof(double) * 3;
            }
            else
            {
                writer.Write(Value.XFloat);
                writer.Write(Value.YFloat);
                writer.Write(Value.ZFloat);
                return sizeof(float) * 3;
            }
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES ? 24U : 12U;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_VirtualFunction.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_VirtualFunction"/> instruction.
    /// </summary>
    public class EX_VirtualFunction : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_VirtualFunction; } }

        /// <summary>
        /// Virtual function name.
        /// </summary>
        [JsonProperty]
        public FName VirtualFunctionName;

        /// <summary>
        /// List of parameters for this function.
        /// </summary>
        [JsonProperty]
        public KismetExpression[] Parameters;

        public EX_VirtualFunction()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {
            VirtualFunctionName = reader.XFER_FUNC_NAME();

            Parameters = reader.ReadExpressionArray(EExprToken.EX_EndFunctionParms);
        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            offset += writer.XFER_FUNC_NAME(VirtualFunctionName);

            for (int i = 0; i < Parameters.Length; i++)
            {
                offset += ExpressionSerializer.WriteExpression(Parameters[i], writer);
            }
            offset += ExpressionSerializer.WriteExpression(new EX_EndFunctionParms(), writer);
            return offset;
        }

        public override void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            base.Visit(asset, ref offset, visitor);
            offset += 12; // VirtualFunctionName (12)
            foreach (var param in Parameters)
            {
                param.Visit(asset, ref offset, visitor);
            }
            offset += 1; // EX_EndFunctionParms
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/Expressions/EX_WireTracepoint.cs`:

```cs
namespace UAssetAPI.Kismet.Bytecode.Expressions
{
    /// <summary>
    /// A single Kismet bytecode instruction, corresponding to the <see cref="EExprToken.EX_WireTracepoint"/> instruction.
    /// </summary>
    public class EX_WireTracepoint : KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public override EExprToken Token { get { return EExprToken.EX_WireTracepoint; } }

        public EX_WireTracepoint()
        {

        }

        /// <summary>
        /// Reads out the expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public override void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes the expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public override int Write(AssetBinaryWriter writer)
        {
            return 0;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/FScriptText.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode
{
    /// <summary>
    /// Represents an FText as serialized in Kismet bytecode.
    /// </summary>
    [JsonObject(MemberSerialization.OptIn)]
    public class FScriptText
    {
        [JsonProperty]
        public EBlueprintTextLiteralType TextLiteralType;

        /// <summary>
        /// Source of this text if it is localized text. Used when <see cref="TextLiteralType"/> is <see cref="EBlueprintTextLiteralType.InvariantText"/>.
        /// </summary>
        [JsonProperty]
        public KismetExpression LocalizedSource;

        /// <summary>
        /// Key of this text if it is localized text. Used when <see cref="TextLiteralType"/> is <see cref="EBlueprintTextLiteralType.InvariantText"/>.
        /// </summary>
        [JsonProperty]
        public KismetExpression LocalizedKey;

        /// <summary>
        /// Namespace of this text if it is localized text. Used when <see cref="TextLiteralType"/> is <see cref="EBlueprintTextLiteralType.InvariantText"/>.
        /// </summary>
        [JsonProperty]
        public KismetExpression LocalizedNamespace;

        /// <summary>
        /// Value of this text if it is an invariant string literal. Used when <see cref="TextLiteralType"/> is <see cref="EBlueprintTextLiteralType.InvariantText"/>.
        /// </summary>
        [JsonProperty]
        public KismetExpression InvariantLiteralString;

        /// <summary>
        /// Value of this text if it is a string literal. Used when <see cref="TextLiteralType"/> is <see cref="EBlueprintTextLiteralType.LiteralString"/>.
        /// </summary>
        [JsonProperty]
        public KismetExpression LiteralString;

        /// <summary>
        /// Pointer to this text's UStringTable. Not used at runtime, but exists for asset dependency gathering. Used when <see cref="TextLiteralType"/> is <see cref="EBlueprintTextLiteralType.StringTableEntry"/>.
        /// </summary>
        [JsonProperty]
        public FPackageIndex StringTableAsset;

        /// <summary>
        /// Table ID string literal (namespace). Used when <see cref="TextLiteralType"/> is <see cref="EBlueprintTextLiteralType.StringTableEntry"/>.
        /// </summary>
        [JsonProperty]
        public KismetExpression StringTableId;

        /// <summary>
        /// String table key string literal. Used when <see cref="TextLiteralType"/> is <see cref="EBlueprintTextLiteralType.StringTableEntry"/>.
        /// </summary>
        [JsonProperty]
        public KismetExpression StringTableKey;

        /// <summary>
        /// Reads out an FBlueprintText from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public virtual void Read(AssetBinaryReader reader)
        {
            TextLiteralType = (EBlueprintTextLiteralType)reader.ReadByte();
            switch (TextLiteralType)
            {
                case EBlueprintTextLiteralType.Empty:
                    break;
                case EBlueprintTextLiteralType.LocalizedText:
                    LocalizedSource = ExpressionSerializer.ReadExpression(reader);
                    LocalizedKey = ExpressionSerializer.ReadExpression(reader);
                    LocalizedNamespace = ExpressionSerializer.ReadExpression(reader);
                    break;
                case EBlueprintTextLiteralType.InvariantText: // IsCultureInvariant
                    InvariantLiteralString = ExpressionSerializer.ReadExpression(reader);
                    break;
                case EBlueprintTextLiteralType.LiteralString:
                    LiteralString = ExpressionSerializer.ReadExpression(reader);
                    break;
                case EBlueprintTextLiteralType.StringTableEntry:
                    StringTableAsset = reader.XFER_OBJECT_POINTER();
                    StringTableId = ExpressionSerializer.ReadExpression(reader);
                    StringTableKey = ExpressionSerializer.ReadExpression(reader);
                    break;
                default:
                    throw new NotImplementedException("Unimplemented blueprint text literal type " + TextLiteralType);
            }

        }

        /// <summary>
        /// Writes an FBlueprintText to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public virtual int Write(AssetBinaryWriter writer)
        {
            int offset = 0;
            writer.Write((byte)TextLiteralType); offset += sizeof(byte);
            switch (TextLiteralType)
            {
                case EBlueprintTextLiteralType.Empty:
                    break;
                case EBlueprintTextLiteralType.LocalizedText:
                    offset += ExpressionSerializer.WriteExpression(LocalizedSource, writer);
                    offset += ExpressionSerializer.WriteExpression(LocalizedKey, writer);
                    offset += ExpressionSerializer.WriteExpression(LocalizedNamespace, writer);
                    break;
                case EBlueprintTextLiteralType.InvariantText: // IsCultureInvariant
                    offset += ExpressionSerializer.WriteExpression(InvariantLiteralString, writer);
                    break;
                case EBlueprintTextLiteralType.LiteralString:
                    offset += ExpressionSerializer.WriteExpression(LiteralString, writer);
                    break;
                case EBlueprintTextLiteralType.StringTableEntry:
                    offset += writer.XFER_OBJECT_POINTER(StringTableAsset);
                    offset += ExpressionSerializer.WriteExpression(StringTableId, writer);
                    offset += ExpressionSerializer.WriteExpression(StringTableKey, writer);
                    break;
                default:
                    throw new NotImplementedException("Unimplemented blueprint text literal type " + TextLiteralType);
            }
            return offset;
        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/KismetExpression.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Kismet.Bytecode
{
    /// <summary>
    /// A Kismet bytecode instruction.
    /// </summary>
    [JsonObject(MemberSerialization.OptIn)]
    public class KismetExpression
    {
        /// <summary>
        /// The token of this expression.
        /// </summary>
        public virtual EExprToken Token { get { return EExprToken.EX_Nothing; } }

        /// <summary>
        /// The token of this instruction expressed as a string.
        /// </summary>
        public string Inst { get { return Token.ToString().Substring(3, Token.ToString().Length - 3); } }

        /// <summary>
        /// An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.
        /// </summary>
        public object Tag;

        public object RawValue;

        public void SetObject(object value)
        {
            RawValue = value;
        }

        public T GetObject<T>()
        {
            return (T)RawValue;
        }

        public KismetExpression()
        {

        }

        /// <summary>
        /// Reads out an expression from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        public virtual void Read(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Writes an expression to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <returns>The iCode offset of the data that was written.</returns>
        public virtual int Write(AssetBinaryWriter writer)
        {
            return 0;
        }

        /// <summary>
        /// Visits this expression and all child expressions, calling the visitor function for each with the in-memory offset.
        /// Note: The offset is the in-memory offset, not the serialization offset.
        /// </summary>
        /// <param name="asset">The asset containing this expression.</param>
        /// <param name="offset">Reference to the current in-memory offset, which is incremented as expressions are visited.</param>
        /// <param name="visitor">The visitor function to call for each expression with the expression and its offset.</param>
        public virtual void Visit(UAsset asset, ref uint offset, Action<KismetExpression, uint> visitor)
        {
            visitor(this, offset);
            offset++;
        }

        /// <summary>
        /// Gets the in-memory size of this expression and all child expressions.
        /// </summary>
        /// <param name="asset">The asset containing this expression.</param>
        /// <returns>The size in bytes of this expression.</returns>
        public uint GetSize(UAsset asset)
        {
            uint offset = 0;
            Visit(asset, ref offset, (_, __) => { });
            return offset;
        }
    }

    public abstract class KismetExpression<T> : KismetExpression
    {
        /// <summary>
        /// The value of this expression if it is a constant.
        /// </summary>
        [JsonProperty]
        public T Value
        {
            get => GetObject<T>();
            set => SetObject(value);
        }

        public KismetExpression() : base()
        {

        }
    }
}

```

`UAssetAPI/Kismet/Bytecode/KismetPropertyPointer.cs`:

```cs
using Newtonsoft.Json;
using System.ComponentModel;
using UAssetAPI.UnrealTypes;
using UAssetAPI.CustomVersions;

namespace UAssetAPI.Kismet.Bytecode;

/// <summary>
/// Represents a Kismet bytecode pointer to an FProperty or FField.
/// </summary>
[JsonObject(MemberSerialization.OptIn)]
public class KismetPropertyPointer
{
    /// <summary>
    /// The pointer serialized as an FPackageIndex. Used in versions older than <see cref="FReleaseObjectVersion.FFieldPathOwnerSerialization"/>.
    /// </summary>
    [JsonProperty]
    [DefaultValue(null)]
    public FPackageIndex Old;

    /// <summary>
    /// The pointer serialized as an FFieldPath. Used in versions newer than <see cref="FReleaseObjectVersion.FFieldPathOwnerSerialization"/>.
    /// </summary>
    [JsonProperty]
    [DefaultValue(null)]
    public FFieldPath New;

    public bool ShouldSerializeOld()
    {
        return Old != null;
    }

    public bool ShouldSerializeNew()
    {
        return New != null;
    }

    public KismetPropertyPointer(FPackageIndex older)
    {
        Old = older;
    }

    public KismetPropertyPointer(FFieldPath newer)
    {
        New = newer;
    }

    public KismetPropertyPointer()
    {

    }
}

```

`UAssetAPI/Kismet/KismetSerializer.cs`:

```cs
using Newtonsoft.Json.Linq;
using UAssetAPI.FieldTypes;
using UAssetAPI.Kismet.Bytecode.Expressions;
using UAssetAPI.Kismet.Bytecode;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;
using UAssetAPI.CustomVersions;

namespace UAssetAPI.Kismet
{
    public static class KismetSerializer
    {
        public static UAsset asset;
        public struct FSimpleMemberReference
        {
            public string MemberParent;
            public string MemberName;
            public Guid MemberGuid;
        }

        public struct FEdGraphTerminalType
        {
            public string TerminalCategory;
            public string TerminalSubCategory;
            public string TerminalSubCategoryObject;
            public bool bTerminalIsConst;
            public bool bTerminalIsWeakPointer;
            public bool bTerminalIsUObjectWrapper;
        }

        public struct FEdGraphPinType
        {
            public string PinCategory;
            public string PinSubCategory;
            public string PinSubCategoryObject;
            public FSimpleMemberReference PinSubCategoryMemberReference;
            public FEdGraphTerminalType PinValueType;
            public EPinContainerType ContainerType;

            public bool bIsReference;
            public bool bIsConst;
            public bool bIsWeakPointer;
            public bool bIsUObjectWrapper;
        }

        public enum EPinContainerType : byte
        {
            None,
            Array,
            Set,
            Map
        };

        const string PC_Boolean = "Bool";
        const string PC_Byte = "Byte";
        const string PC_Class = "Class";
        const string PC_Int = "Int";
        const string PC_Int64 = "Int64";
        const string PC_Float = "Float";
        const string PC_Double = "Double";
        const string PC_Name = "Name";
        const string PC_Delegate = "Delegate";
        const string PC_MCDelegate = "mcdelegate";
        const string PC_Object = "Object";
        const string PC_Interface = "Interface";
        const string PC_String = "String";
        const string PC_Text = "Text";
        const string PC_Struct = "Struct";
        const string PC_Enum = "Enum";
        const string PC_SoftObject = "Softobject";
        const string PC_SoftClass = "Softclass";
        const string PC_None = "None";

        public static JArray SerializeScript(KismetExpression[] code)
        {
            JArray jscript = new JArray();
            int index = 0;
            foreach (KismetExpression instruction in code)
            {
                jscript.Add(SerializeExpression(instruction, ref index, true));
            }

            return jscript;
        }

        public static string GetName(int index)
        {
            if (index > 0)
            {
                return asset.Exports[index - 1].ObjectName.ToString();
            }
            else if (index < 0)
            {
                return asset.Imports[-index - 1].ObjectName.ToString();
            }
            else
            {
                return "";
            }
        }

        public static int GetClassIndex()
        {
            for (int i = 1; i <= asset.Exports.Count; i++)
            {
                if (asset.Exports[i - 1] is ClassExport)
                {
                    return i;
                }
            }
            return 0;
        }

        public static string GetFullName(int index, bool alt = false)
        {

            if (index > 0 && index < asset.Exports.Count)
            {
                if (asset.Exports[index - 1].OuterIndex.Index != 0)
                {
                    string parent = GetFullName(asset.Exports[index - 1].OuterIndex.Index);
                    return parent + "." + asset.Exports[index - 1].ObjectName.ToString();
                }
                else
                {
                    return asset.Exports[index - 1].ObjectName.ToString();
                }

            }
            else if (index < 0)
            {

                if (asset.Imports[-index - 1].OuterIndex.Index != 0)
                {
                    string parent = GetFullName(asset.Imports[-index - 1].OuterIndex.Index);
                    return parent + "." + asset.Imports[-index - 1].ObjectName.ToString();
                }
                else
                {
                    return asset.Imports[-index - 1].ObjectName.ToString();
                }

            }
            else
            {
                return "";
            }
        }

        public static string GetParentName(int index)
        {
            if (index > 0)
            {
                if (asset.Exports[index - 1].OuterIndex.Index != 0)
                {
                    string parent = GetFullName(asset.Exports[index - 1].OuterIndex.Index);
                    return parent;
                }
                else
                {
                    return "";
                }

            }
            else if (index < 0)
            {

                if (asset.Imports[-index - 1].OuterIndex.Index != 0)
                {
                    string parent = GetFullName(asset.Imports[-index - 1].OuterIndex.Index);
                    return parent;
                }
                else
                {
                    return "";
                }

            }
            else
            {
                return "";
            }
        }

        public static bool FindProperty(int index, FName propname, out FProperty property)
        {
            if (index < 0)
            {

                property = new FObjectProperty();
                return false;

            }
            Export export = asset.Exports[index - 1];
            if (export is StructExport)
            {
                foreach (FProperty prop in (export as StructExport).LoadedProperties)
                {
                    if (prop.Name == propname)
                    {
                        property = prop;
                        return true;
                    }
                }
            }
            property = new FObjectProperty();
            return false;
        }

        public static FEdGraphPinType GetPropertyCategoryInfo(FProperty prop)
        {
            FEdGraphPinType pin = new FEdGraphPinType();
            switch (prop)
            {
                case FInterfaceProperty finterface:
                    {
                        pin.PinCategory = PC_Interface;
                        pin.PinSubCategoryObject = GetFullName(finterface.InterfaceClass.Index);
                        break;
                    };
                case FClassProperty fclassprop:
                    {
                        pin.PinCategory = PC_Class;
                        pin.PinSubCategoryObject = GetFullName(fclassprop.MetaClass.Index);
                        break;
                    };
                case FSoftClassProperty fsoftclassprop:
                    {
                        pin.PinCategory = PC_SoftClass;
                        pin.PinSubCategoryObject = GetFullName(fsoftclassprop.MetaClass.Index);
                        break;
                    };
                case FSoftObjectProperty fsoftobjprop:
                    {
                        pin.PinCategory = PC_SoftObject;
                        pin.PinSubCategoryObject = GetFullName(fsoftobjprop.PropertyClass.Index);
                        break;
                    };
                case FObjectProperty fobjprop:
                    {
                        pin.PinCategory = PC_Object;
                        pin.PinSubCategoryObject = GetFullName(fobjprop.PropertyClass.Index);
                        if (fobjprop.PropertyFlags.HasFlag(EPropertyFlags.CPF_AutoWeak))
                        {
                            pin.bIsWeakPointer = true;
                        }
                        break;
                    };
                case FStructProperty fstruct:
                    {
                        pin.PinCategory = PC_Struct;
                        pin.PinSubCategoryObject = GetFullName(fstruct.Struct.Index);
                        break;
                    };
                case FByteProperty fbyte:
                    {
                        pin.PinCategory = PC_Byte;
                        pin.PinSubCategoryObject = GetFullName(fbyte.Enum.Index);
                        break;
                    };
                case FEnumProperty fenum:
                    {
                        if (!(fenum.UnderlyingProp is FByteProperty))
                        {
                            break;
                        }
                        pin.PinCategory = PC_Byte;
                        pin.PinSubCategoryObject = GetFullName(fenum.Enum.Index);
                        break;
                    }
                case FBoolProperty fbool:
                    {
                        pin.PinCategory = PC_Boolean;
                        break;
                    };
                case FGenericProperty fgeneric:
                    {

                        switch (fgeneric.SerializedType.ToString())
                        {
                            case "FloatProperty":
                                {
                                    pin.PinCategory = PC_Float;
                                    break;
                                }
                            case "DoubleProperty":
                                {
                                    pin.PinCategory = PC_Double;
                                    break;
                                }
                            case "Int64Property":
                                {
                                    pin.PinCategory = PC_Int64;
                                    break;
                                }
                            case "IntProperty":
                                {
                                    pin.PinCategory = PC_Int;
                                    break;
                                }
                            case "NameProperty":
                                {
                                    pin.PinCategory = PC_Name;
                                    break;
                                }
                            case "StrProperty":
                                {
                                    pin.PinCategory = PC_String;
                                    break;
                                }
                            case "TextProperty":
                                {
                                    pin.PinCategory = PC_Text;
                                    break;
                                }
                            default: break;
                        };
                        break;
                    }

                default: break;
            }

            return pin;

        }

        public static FSimpleMemberReference FillSimpleMemberReference(int index)
        {
            FSimpleMemberReference member = new FSimpleMemberReference();
            if (index > 0)
            {
                member.MemberName = asset.Exports[index - 1].ObjectName.ToString();
                member.MemberParent = GetName(asset.Exports[index - 1].OuterIndex.Index);
                member.MemberGuid = asset.Exports[index - 1].PackageGuid;
            }
            else if (index < 0)
            {
                member.MemberName = asset.Imports[-index - 1].ObjectName.ToString();
                member.MemberParent = asset.Imports[-index - 1].ClassPackage.ToString();
                member.MemberGuid = new Guid("00000000000000000000000000000000");
            }

            return member;

        }

        public static JObject SerializeGraphPinType(FEdGraphPinType pin)
        {

            JObject jpin = new JObject();
            jpin.Add("PinCategory", pin.PinCategory);
            jpin.Add("PinSubCategory", pin.PinCategory);
            if (pin.PinSubCategoryObject == "" || pin.PinSubCategoryObject == null)
            {

            }
            else { jpin.Add("PinSubCategoryObject", pin.PinSubCategoryObject); }

            if (pin.PinSubCategoryMemberReference.MemberName != null)
            {
                FSimpleMemberReference member = pin.PinSubCategoryMemberReference;
                if (member.MemberGuid.Equals(new Guid("00000000000000000000000000000000")))
                {
                }
                else
                {
                    JObject jmember = new JObject();
                    if (member.MemberParent != "" || member.MemberParent != null)
                    {
                        jmember.Add("MemberParent", member.MemberParent);
                    }
                    jmember.Add("MemberName", member.MemberName);
                    jmember.Add("MemberGuid", member.MemberGuid);
                    jpin.Add("PinSubCategoryMemberReference", jmember);
                }
            }

            if (pin.ContainerType == EPinContainerType.Map)
            {
                FEdGraphTerminalType valuetype = pin.PinValueType;
                JObject jvaluetype = new JObject();

                jvaluetype.Add("TerminalCategory", valuetype.TerminalCategory);
                if (valuetype.TerminalSubCategory == null || valuetype.TerminalSubCategory == "")
                {
                    jvaluetype.Add("TerminalSubCategory", "None");
                }
                else
                {
                    jvaluetype.Add("TerminalSubCategory", valuetype.TerminalSubCategory);
                }
                if (valuetype.TerminalSubCategoryObject != "" && valuetype.TerminalSubCategoryObject != null)
                {
                    jvaluetype.Add("TerminalSubCategoryObject", valuetype.TerminalSubCategoryObject);
                }
                jvaluetype.Add("TerminalIsConst", valuetype.bTerminalIsConst);
                jvaluetype.Add("TerminalIsWeakPointer", valuetype.bTerminalIsWeakPointer);
                jpin.Add("PinValueType", jvaluetype);

            }

            if (pin.ContainerType != EPinContainerType.None)
            {
                jpin.Add("ContainerType", (int)pin.ContainerType);
            }

            if (pin.bIsReference)
            {
                jpin.Add("IsReference", pin.bIsReference);
            }
            if (pin.bIsConst)
            {
                jpin.Add("IsConst", pin.bIsConst);
            }
            if (pin.bIsWeakPointer)
            {
                jpin.Add("IsWeakPointer", pin.bIsWeakPointer);
            }
            return jpin;

        }
        public static FEdGraphPinType ConvertPropertyToPinType(FProperty property)
        {
            FEdGraphPinType pin = new FEdGraphPinType();
            FProperty prop = property;

            if (property is FMapProperty)
            {
                prop = (property as FMapProperty).KeyProp;
                pin.ContainerType = EPinContainerType.Map;
                pin.bIsWeakPointer = false;
                FEdGraphPinType temppin = GetPropertyCategoryInfo((property as FMapProperty).ValueProp);
                pin.PinValueType.TerminalCategory = temppin.PinCategory;
                pin.PinValueType.TerminalSubCategory = temppin.PinSubCategory;
                pin.PinValueType.TerminalSubCategoryObject = temppin.PinSubCategoryObject;

                pin.PinValueType.bTerminalIsConst = temppin.bIsConst;
                pin.PinValueType.bTerminalIsWeakPointer = temppin.bIsWeakPointer;

            }
            else if (property is FSetProperty)
            {
                prop = (property as FSetProperty).ElementProp;
                pin.ContainerType = EPinContainerType.Set;
            }
            else if (property is FArrayProperty)
            {
                prop = (property as FArrayProperty).Inner;
                pin.ContainerType = EPinContainerType.Array;
            }
            pin.bIsReference = property.PropertyFlags.HasFlag(EPropertyFlags.CPF_OutParm) && property.PropertyFlags.HasFlag(EPropertyFlags.CPF_ReferenceParm);
            pin.bIsConst = property.PropertyFlags.HasFlag(EPropertyFlags.CPF_ConstParm);


            if (prop is FMulticastDelegateProperty)
            {
                pin.PinCategory = PC_MCDelegate;
                pin.PinSubCategoryMemberReference = FillSimpleMemberReference((prop as FMulticastDelegateProperty).SignatureFunction.Index);

            }
            else if (prop is FDelegateProperty)
            {
                pin.PinCategory = PC_Delegate;
                pin.PinSubCategoryMemberReference = FillSimpleMemberReference((prop as FDelegateProperty).SignatureFunction.Index);
            }
            else
            {
                FEdGraphPinType temppin = GetPropertyCategoryInfo(prop);
                pin.PinCategory = temppin.PinCategory;
                pin.PinSubCategory = temppin.PinSubCategory;
                pin.PinSubCategoryObject = temppin.PinSubCategoryObject;
                pin.bIsWeakPointer = temppin.bIsWeakPointer;

            }
            return pin;
        }

        public static JProperty[] SerializePropertyPointer(KismetPropertyPointer pointer, string[] names)
        {

            JProperty[] jproparray = new JProperty[names.Length];

            FProperty property;
            if (asset.GetCustomVersion<FReleaseObjectVersion>() >= FReleaseObjectVersion.FFieldPathOwnerSerialization)
            {
                if (pointer != null && pointer.New.ResolvedOwner.Index != 0)
                {

                    if (FindProperty(pointer.New.ResolvedOwner.Index, pointer.New.Path[0], out property))
                    {
                        FEdGraphPinType PropertyType = ConvertPropertyToPinType(property);
                        jproparray[0] = new JProperty(names[0], SerializeGraphPinType(PropertyType));
                    }
                    else
                    {
                        jproparray[0] = new JProperty(names[0], "##NOT SERIALIZED##");
                    }
                    if (names.Length > 1)
                    {
                        jproparray[1] = new JProperty(names[1], pointer.New.Path[0].ToString());
                    }

                    return jproparray;

                }
            }
            if (pointer != null && pointer.Old != null && pointer.Old.Index != 0)
            {
                if (names.Length > 1)
                {
                    string[] split = GetFullName(pointer.Old.Index).Split('.');
                    jproparray[0] = new JProperty(names[0], split[0]);
                    string path = "";
                    for (int i = 1; i < split.Length; i++)
                    {
                        path += split[i] + ".";
                    }
                    if (path.EndsWith("."))
                    {
                        path = path.Substring(0, path.Length - 1);
                    }
                    jproparray[1] = new JProperty(names[1], path);
                }
                else
                {
                    jproparray[0] = new JProperty(names[0], GetFullName(pointer.Old.Index));
                }
            }
            else
            {
                jproparray[0] = new JProperty(names[0], "#Pointer Error#");
                if (names.Length > 1)
                {
                    jproparray[1] = new JProperty(names[1], "^^^^^");
                }
            }
            return jproparray;

        }

        private static bool FindProperty(int index, FPackageIndex old, out FProperty property)
        {
            throw new NotImplementedException();
        }

        public static JObject SerializeExpression(KismetExpression expression, ref int index, bool addindex = false)
        {

            int savedindex = index;
            JObject jexp = new JObject();
            index++;
            switch (expression)
            {
                case EX_PrimitiveCast exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index++;
                        switch (exp.ConversionType)
                        {

                            case ECastToken.InterfaceToBool:
                                {
                                    jexp.Add("CastType", "InterfaceToBool");
                                    break;
                                }
                            case ECastToken.ObjectToBool:
                                {
                                    jexp.Add("CastType", "ObjectToBool");
                                    break;
                                }
                            case ECastToken.ObjectToInterface:
                                {
                                    jexp.Add("CastType", "ObjectToInterface");
                                    index += 8;
                                    jexp.Add("InterfaceClass", "##NOT SERIALIZED##");
                                    break;
                                }
                            default: break;
                        }
                        jexp.Add("Expression", SerializeExpression(exp.Target, ref index));
                        break;
                    }
                case EX_SetSet exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("LeftSideExpression", SerializeExpression(exp.SetProperty, ref index));
                        JArray jparams = new JArray();

                        index += 4;
                        foreach (KismetExpression param in exp.Elements)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Values", jparams);
                        break;
                    }
                case EX_SetConst exp:
                    {
                        index += 8;
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add(SerializePropertyPointer(exp.InnerProperty, new[] { "InnerProperty" }));

                        index += 4;
                        JArray jparams = new JArray();
                        foreach (KismetExpression param in exp.Elements)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Values", jparams);
                        break;
                    }
                case EX_SetMap exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("LeftSideExpression", SerializeExpression(exp.MapProperty, ref index));

                        index += 4;
                        JArray jparams = new JArray();
                        for (var j = 1; j <= exp.Elements.Length / 2; j++)
                        {
                            JObject jobject = new JObject();
                            jobject.Add("Key", SerializeExpression(exp.Elements[2 * (j - 1)], ref index));
                            jobject.Add("Value", SerializeExpression(exp.Elements[2 * (j - 1) + 1], ref index));
                            jparams.Add(jobject);
                        }
                        index++;
                        jexp.Add("Values", jparams);
                        break;
                    }
                case EX_MapConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.KeyProperty, new[] { "KeyProperty" }));
                        jexp.Add(SerializePropertyPointer(exp.ValueProperty, new[] { "ValueProperty" }));

                        index += 4;
                        JArray jparams = new JArray();
                        for (var j = 1; j <= exp.Elements.Length / 2; j++)
                        {
                            JObject jobject = new JObject();
                            jobject.Add("Key", SerializeExpression(exp.Elements[2 * (j - 1)], ref index));
                            jobject.Add("Value", SerializeExpression(exp.Elements[2 * (j - 1) + 1], ref index));
                            jparams.Add(jobject);
                        }
                        index++;
                        jexp.Add("Values", jparams);
                        break;
                    }
                case EX_ObjToInterfaceCast exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("InterfaceClass", GetFullName(exp.ClassPtr.Index));
                        jexp.Add("Expression", SerializeExpression(exp.Target, ref index));
                        break;
                    }
                case EX_CrossInterfaceCast exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("InterfaceClass", GetFullName(exp.ClassPtr.Index));
                        jexp.Add("Expression", SerializeExpression(exp.Target, ref index));
                        break;
                    }
                case EX_InterfaceToObjCast exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("ObjectClass", GetFullName(exp.ClassPtr.Index));
                        jexp.Add("Expression", SerializeExpression(exp.Target, ref index));
                        break;
                    }
                case EX_Let exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Variable", SerializeExpression(exp.Variable, ref index));
                        jexp.Add("Expression", SerializeExpression(exp.Expression, ref index));
                        break;
                    }
                case EX_LetObj exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Variable", SerializeExpression(exp.VariableExpression, ref index));
                        jexp.Add("Expression", SerializeExpression(exp.AssignmentExpression, ref index));
                        break;
                    }
                case EX_LetWeakObjPtr exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Variable", SerializeExpression(exp.VariableExpression, ref index));
                        jexp.Add("Expression", SerializeExpression(exp.AssignmentExpression, ref index));
                        break;
                    }
                case EX_LetBool exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Variable", SerializeExpression(exp.VariableExpression, ref index));
                        jexp.Add("Expression", SerializeExpression(exp.AssignmentExpression, ref index));
                        break;
                    }
                case EX_LetValueOnPersistentFrame exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.DestinationProperty, new[] { "Property Outer", "Property Name" }));
                        jexp.Add("Expression", SerializeExpression(exp.AssignmentExpression, ref index));
                        break;
                    }
                case EX_StructMemberContext exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.StructMemberExpression, new[] { "Property Outer", "Property Name" }));
                        jexp.Add("StructExpression", SerializeExpression(exp.StructExpression, ref index));
                        break;
                    }
                case EX_LetDelegate exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Variable", SerializeExpression(exp.VariableExpression, ref index));
                        jexp.Add("Expression", SerializeExpression(exp.AssignmentExpression, ref index));
                        break;
                    }
                case EX_LocalVirtualFunction exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 12;
                        jexp.Add("FunctionName", exp.VirtualFunctionName.ToString());
                        JArray jparams = new JArray();
                        foreach (KismetExpression param in exp.Parameters)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Parameters", jparams);
                        break;
                    }
                case EX_LocalFinalFunction exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Function", GetName(exp.StackNode.Index));
                        index += 8;
                        JArray jparams = new JArray();
                        foreach (KismetExpression param in exp.Parameters)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Parameters", jparams);
                        break;
                    }
                case EX_LetMulticastDelegate exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Variable", SerializeExpression(exp.VariableExpression, ref index));
                        jexp.Add("Expression", SerializeExpression(exp.AssignmentExpression, ref index));
                        break;
                    }
                case EX_ComputedJump exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("OffsetExpression", SerializeExpression(exp.CodeOffsetExpression, ref index));
                        break;
                    }
                case EX_Jump exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 4;
                        jexp.Add("Offset", exp.CodeOffset);
                        break;
                    }
                case EX_LocalVariable exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.Variable, new[] { "Variable Outer", "Variable Name" }));
                        break;
                    }
                case EX_DefaultVariable exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.Variable, new[] { "Variable Outer", "Variable Name" }));
                        break;
                    }
                case EX_InstanceVariable exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.Variable, new[] { "Variable Outer", "Variable Name" }));
                        break;
                    }
                case EX_LocalOutVariable exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.Variable, new[] { "Variable Outer", "Variable Name" }));
                        break;
                    }
                case EX_InterfaceContext exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Expression", SerializeExpression(exp.InterfaceValue, ref index));
                        break;
                    }
                case EX_DeprecatedOp4A exp1:
                case EX_Nothing exp2:
                case EX_EndOfScript exp3:
                case EX_IntZero exp4:
                case EX_IntOne exp5:
                case EX_True exp6:
                case EX_False exp7:
                case EX_NoObject exp8:
                case EX_NoInterface exp9:
                case EX_Self exp10:
                    {
                        jexp.Add("Inst", expression.Inst);
                        break;
                    }
                case EX_Return exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Expression", SerializeExpression(exp.ReturnExpression, ref index));
                        break;
                    }
                case EX_CallMath exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Function", GetName(exp.StackNode.Index));
                        jexp.Add("ContextClass", GetParentName(exp.StackNode.Index));
                        JArray jparams = new JArray();
                        foreach (KismetExpression param in exp.Parameters)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Parameters", jparams);
                        break;
                    }
                case EX_CallMulticastDelegate exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        JObject jsign = new JObject();
                        bool bIsSelfContext = GetClassIndex() == exp.StackNode.Index;
                        jsign.Add("IsSelfContext", bIsSelfContext);
                        jsign.Add("MemberParent", GetFullName(exp.StackNode.Index));
                        jsign.Add("MemberName", GetName(exp.StackNode.Index));
                        jexp.Add("DelegateSignatureFunction", jsign);
                        jexp.Add("Delegate", SerializeExpression(exp.Delegate, ref index));

                        JArray jparams = new JArray();
                        foreach (KismetExpression param in exp.Parameters)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Parameters", jparams);
                        break;
                    }
                case EX_FinalFunction exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Function", GetName(exp.StackNode.Index));
                        JArray jparams = new JArray();
                        foreach (KismetExpression param in exp.Parameters)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Parameters", jparams);
                        break;
                    }
                case EX_VirtualFunction exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 12;
                        jexp.Add("Function", exp.VirtualFunctionName.ToString());
                        JArray jparams = new JArray();

                        foreach (KismetExpression param in exp.Parameters)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Parameters", jparams);
                        break;
                    }
                //case EX_ClassContext:
                //case EX_Context_FailSilent: {
                case EX_Context exp:
                    {

                        if (exp is EX_Context_FailSilent)
                        {
                            exp = exp as EX_Context_FailSilent;
                        }
                        else if (exp is EX_ClassContext)
                        {
                            exp = exp as EX_ClassContext;
                        }
                        else
                        {
                        }
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Context", SerializeExpression(exp.ObjectExpression, ref index));
                        index += 4;
                        jexp.Add("SkipOffsetForNull", exp.Offset);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.RValuePointer, new[] { "RValuePropertyOuter", "RValuePropertyName" }));
                        jexp.Add("Expression", SerializeExpression(exp.ContextExpression, ref index));
                        break;
                    }
                case EX_IntConst exp:
                    {
                        index += 4;
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_SkipOffsetConst exp:
                    {
                        index += 4;
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_FloatConst exp:
                    {
                        index += 4;
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_DoubleConst exp:
                    {
                        index += 8;
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_StringConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += exp.Value.Length + 1;
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_UnicodeStringConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 2 * (exp.Value.Length + 1);
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_TextConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index++;
                        switch (exp.Value.TextLiteralType)
                        {
                            case EBlueprintTextLiteralType.Empty:
                                {
                                    jexp.Add("TextLiteralType", "Empty");
                                    break;
                                }
                            case EBlueprintTextLiteralType.LocalizedText:
                                {
                                    jexp.Add("TextLiteralType", "LocalizedText");
                                    jexp.Add("SourceString", ReadString(exp.Value.LocalizedSource, ref index));
                                    jexp.Add("LocalizationKey", ReadString(exp.Value.LocalizedKey, ref index));
                                    jexp.Add("LocalizationNamespace", ReadString(exp.Value.LocalizedNamespace, ref index));
                                    break;
                                }
                            case EBlueprintTextLiteralType.InvariantText:
                                {
                                    jexp.Add("TextLiteralType", "InvariantText");
                                    jexp.Add("SourceString", ReadString(exp.Value.InvariantLiteralString, ref index));

                                    break;
                                }
                            case EBlueprintTextLiteralType.LiteralString:
                                {
                                    jexp.Add("TextLiteralType", "LiteralString");
                                    jexp.Add("SourceString", ReadString(exp.Value.LiteralString, ref index));
                                    break;
                                }
                            case EBlueprintTextLiteralType.StringTableEntry:
                                {
                                    jexp.Add("TextLiteralType", "StringTableEntry");
                                    index += 8;
                                    jexp.Add("TableId", ReadString(exp.Value.StringTableId, ref index));
                                    jexp.Add("TableKey", ReadString(exp.Value.StringTableKey, ref index));
                                    break;
                                }
                            default:
                                break;
                        }
                        break;
                    }
                case EX_ObjectConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Object", GetFullName(exp.Value.Index));
                        break;
                    }
                case EX_SoftObjectConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Value", SerializeExpression(exp.Value, ref index));
                        break;
                    }
                case EX_NameConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 12;
                        jexp.Add("Value", exp.Value.ToString());
                        break;
                    }
                case EX_RotationConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += ((asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES) ? sizeof(double) : sizeof(float)) * 3;
                        jexp.Add("Pitch", exp.Value.Pitch);
                        jexp.Add("Yaw", exp.Value.Yaw);
                        jexp.Add("Roll", exp.Value.Roll);
                        break;
                    }
                case EX_VectorConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += ((asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES) ? sizeof(double) : sizeof(float)) * 3;
                        jexp.Add("X", exp.Value.X);
                        jexp.Add("Y", exp.Value.Y);
                        jexp.Add("Z", exp.Value.Z);
                        break;
                    }
                case EX_TransformConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += ((asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES) ? sizeof(double) : sizeof(float)) * 10;
                        JObject jrot = new JObject();
                        JObject jtrans = new JObject();
                        JObject jscale = new JObject();

                        jrot.Add("X", exp.Value.Rotation.X);
                        jrot.Add("Y", exp.Value.Rotation.Y);
                        jrot.Add("Z", exp.Value.Rotation.Z);
                        jrot.Add("W", exp.Value.Rotation.W);

                        jtrans.Add("X", exp.Value.Translation.X);
                        jtrans.Add("Y", exp.Value.Translation.Y);
                        jtrans.Add("Z", exp.Value.Translation.Z);

                        jscale.Add("X", exp.Value.Scale3D.X);
                        jscale.Add("Y", exp.Value.Scale3D.Y);
                        jscale.Add("Z", exp.Value.Scale3D.Z);

                        jexp.Add("Rotation", jrot);
                        jexp.Add("Translation", jtrans);
                        jexp.Add("Scale", jscale);
                        break;
                    }
                case EX_StructConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Struct", GetFullName(exp.Struct.Index));

                        index += 4;
                        JObject jstruct = new JObject();
                        int tempindex = 0;
                        foreach (KismetExpression param in exp.Value)
                        {
                            JArray jstructpart = new JArray();
                            jstructpart.Add(SerializeExpression(param, ref index));
                            jstruct.Add("Missing property name" + tempindex, jstructpart);
                            tempindex++;
                        }
                        index++;
                        jexp.Add("Properties", jstruct);
                        break;
                    }
                case EX_SetArray exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("LeftSideExpression", SerializeExpression(exp.AssigningProperty, ref index));
                        JArray jparams = new JArray();
                        foreach (KismetExpression param in exp.Elements)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Values", jparams);
                        break;
                    }
                case EX_ArrayConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add(SerializePropertyPointer(exp.InnerProperty, new[] { "Variable Outer" }));

                        index += 4;
                        JArray jparams = new JArray();
                        foreach (KismetExpression param in exp.Elements)
                        {
                            jparams.Add(SerializeExpression(param, ref index));
                        }
                        index++;
                        jexp.Add("Values", jparams);
                        break;
                    }
                case EX_ByteConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index++;
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_IntConstByte exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index++;
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_Int64Const exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_UInt64Const exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Value", exp.Value);
                        break;
                    }
                case EX_FieldPathConst exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Expression", SerializeExpression(exp.Value, ref index));
                        break;
                    }
                case EX_MetaCast exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Class", GetFullName(exp.ClassPtr.Index));
                        jexp.Add("Expression", SerializeExpression(exp.Target, ref index));
                        break;
                    }
                case EX_DynamicCast exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 8;
                        jexp.Add("Class", GetFullName(exp.ClassPtr.Index));
                        jexp.Add("Expression", SerializeExpression(exp.Target, ref index));
                        break;
                    }
                case EX_JumpIfNot exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 4;
                        jexp.Add("Offset", exp.CodeOffset);
                        jexp.Add("Condition", SerializeExpression(exp.BooleanExpression, ref index));
                        break;
                    }
                case EX_Assert exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 3;
                        jexp.Add("LineNumber", exp.LineNumber);
                        jexp.Add("Debug", exp.DebugMode);
                        jexp.Add("Expression", SerializeExpression(exp.AssertExpression, ref index));
                        break;
                    }
                case EX_InstanceDelegate exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 12;
                        jexp.Add("FunctionName", exp.FunctionName.ToString());
                        break;
                    }
                case EX_AddMulticastDelegate exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("MulticastDelegate", SerializeExpression(exp.Delegate, ref index));
                        jexp.Add("Delegate", SerializeExpression(exp.DelegateToAdd, ref index));
                        break;
                    }
                case EX_RemoveMulticastDelegate exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("MulticastDelegate", SerializeExpression(exp.Delegate, ref index));
                        jexp.Add("Delegate", SerializeExpression(exp.DelegateToAdd, ref index));
                        break;
                    }
                case EX_ClearMulticastDelegate exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("MulticastDelegate", SerializeExpression(exp.DelegateToClear, ref index));
                        break;
                    }
                case EX_BindDelegate exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 12;
                        jexp.Add("FunctionName", exp.FunctionName.ToString());
                        jexp.Add("Delegate", SerializeExpression(exp.Delegate, ref index));
                        jexp.Add("Object", SerializeExpression(exp.ObjectTerm, ref index));
                        break;
                    }
                case EX_PushExecutionFlow exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 4;
                        jexp.Add("Offset", exp.PushingAddress);
                        break;
                    }
                case EX_PopExecutionFlow exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        break;
                    }
                case EX_PopExecutionFlowIfNot exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("Condition", SerializeExpression(exp.BooleanExpression, ref index));
                        break;
                    }
                case EX_Breakpoint exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        break;
                    }
                case EX_WireTracepoint exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        break;
                    }
                case EX_InstrumentationEvent exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index++;
                        switch (exp.EventType)
                        {
                            case EScriptInstrumentationType.Class:
                                jexp.Add("EventType", "Class");
                                break;
                            case EScriptInstrumentationType.ClassScope:
                                jexp.Add("EventType", "ClassScope");
                                break;
                            case EScriptInstrumentationType.Instance:
                                jexp.Add("EventType", "Instance");
                                break;
                            case EScriptInstrumentationType.Event:
                                jexp.Add("EventType", "Event");
                                break;
                            case EScriptInstrumentationType.InlineEvent:
                                {
                                    index += 12;
                                    jexp.Add("EventType", "InlineEvent");
                                    jexp.Add("EventName", exp.EventName.ToString());
                                    break;
                                }
                            case EScriptInstrumentationType.ResumeEvent:
                                jexp.Add("EventType", "ResumeEvent");
                                break;
                            case EScriptInstrumentationType.PureNodeEntry:
                                jexp.Add("EventType", "PureNodeEntry");
                                break;
                            case EScriptInstrumentationType.NodeDebugSite:
                                jexp.Add("EventType", "NodeDebugSite");
                                break;
                            case EScriptInstrumentationType.NodeEntry:
                                jexp.Add("EventType", "NodeEntry");
                                break;
                            case EScriptInstrumentationType.NodeExit:
                                jexp.Add("EventType", "NodeExit");
                                break;
                            case EScriptInstrumentationType.PushState:
                                jexp.Add("EventType", "PushState");
                                break;
                            case EScriptInstrumentationType.RestoreState:
                                jexp.Add("EventType", "RestoreState");
                                break;
                            case EScriptInstrumentationType.ResetState:
                                jexp.Add("EventType", "ResetState");
                                break;
                            case EScriptInstrumentationType.SuspendState:
                                jexp.Add("EventType", "SuspendState");
                                break;
                            case EScriptInstrumentationType.PopState:
                                jexp.Add("EventType", "PopState");
                                break;
                            case EScriptInstrumentationType.TunnelEndOfThread:
                                jexp.Add("EventType", "TunnelEndOfThread");
                                break;
                            case EScriptInstrumentationType.Stop:
                                jexp.Add("EventType", "Stop");
                                break;
                            default:
                                break;
                        }
                        break;
                    }
                case EX_Tracepoint exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        break;
                    }
                case EX_SwitchValue exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        index += 6;

                        jexp.Add("Expression", SerializeExpression(exp.IndexTerm, ref index));
                        jexp.Add("OffsetToSwitchEnd", exp.EndGotoOffset);
                        JArray jcases = new JArray();

                        for (var j = 0; j < exp.Cases.Length; j++)
                        {
                            JObject jcase = new JObject();
                            jcase.Add("CaseValue", SerializeExpression(exp.Cases[j].CaseIndexValueTerm, ref index));
                            index += 4;
                            jcase.Add("OffsetToNextCase", exp.Cases[j].NextOffset);
                            jcase.Add("CaseResult", SerializeExpression(exp.Cases[j].CaseTerm, ref index));
                            jcases.Add(jcase);
                        }

                        jexp.Add("Cases", jcases);
                        jexp.Add("DefaultResult", SerializeExpression(exp.DefaultTerm, ref index));

                        break;
                    }
                case EX_ArrayGetByRef exp:
                    {
                        jexp.Add("Inst", exp.Inst);
                        jexp.Add("ArrayExpression", SerializeExpression(exp.ArrayVariable, ref index));
                        jexp.Add("IndexExpression", SerializeExpression(exp.ArrayIndex, ref index));
                        break;
                    }
                default:
                    {
                        // This should never occur.
                        //checkf(0, TEXT("Unknown bytecode 0x%02X"), (uint8)Opcode);
                        break;
                    }
            }
            if (addindex) { jexp.Add("StatementIndex", savedindex); }
            return jexp;
        }

        public static string ReadString(KismetExpression expr, ref int index)
        {

            string result = "";
            index++;
            switch (expr)
            {
                case EX_StringConst exp:
                    {
                        result = exp.Value;
                        index += result.Length + 1;
                        break;
                    }
                case EX_UnicodeStringConst exp:
                    {
                        result = exp.Value;
                        index += 2 * (result.Length + 1);
                        break;
                    }
                default:
                    break;
            }
            return result;
        }
    }
}

```

`UAssetAPI/MainSerializer.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text.RegularExpressions;
using UAssetAPI.ExportTypes;
using UAssetAPI.FieldTypes;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

#if DEBUGVERBOSE
using System.Diagnostics;
#endif

namespace UAssetAPI
{
    /// <summary>
    /// An entry in the property type registry. Contains the class Type used for standard and struct property serialization.
    /// </summary>
    internal class RegistryEntry
    {
        internal Type PropertyType;
        internal bool HasCustomStructSerialization;
        internal Func<FName, PropertyData> Creator;

        public RegistryEntry()
        {

        }
    }

    /// <summary>
    /// The main serializer for most property types in UAssetAPI.
    /// </summary>
    public static class MainSerializer
    {
#if DEBUGVERBOSE
        private static PropertyData lastType;
#endif
        public static string[] AdditionalPropertyRegistry = ["ClassProperty", "SoftClassProperty", "AssetClassProperty"];

        private static IDictionary<string, RegistryEntry> _propertyTypeRegistry;

        /// <summary>
        /// The property type registry. Maps serialized property names to their types.
        /// </summary>
        internal static IDictionary<string, RegistryEntry> PropertyTypeRegistry
        {
            get => _propertyTypeRegistry;
            set => _propertyTypeRegistry = value; // I hope you know what you're doing!
        }

        static MainSerializer()
        {
            InitializePropertyTypeRegistry();
        }

        private static IEnumerable<Assembly> GetDependentAssemblies(Assembly analyzedAssembly)
        {
            return AppDomain.CurrentDomain.GetAssemblies().Where(a => GetNamesOfAssembliesReferencedBy(a).Contains(analyzedAssembly.FullName));
        }

        public static IEnumerable<string> GetNamesOfAssembliesReferencedBy(Assembly assembly)
        {
            return assembly.GetReferencedAssemblies().Select(assemblyName => assemblyName.FullName);
        }

        private static Type registryParentDataType = typeof(PropertyData);

        /// <summary>
        /// Initializes the property type registry.
        /// </summary>
        private static void InitializePropertyTypeRegistry()
        {
            if (_propertyTypeRegistry != null) return;
            _propertyTypeRegistry = new Dictionary<string, RegistryEntry>();

            Assembly[] allDependentAssemblies = GetDependentAssemblies(registryParentDataType.Assembly).ToArray();
            Assembly[] allAssemblies = new Assembly[allDependentAssemblies.Length + 1];
            allAssemblies[0] = registryParentDataType.Assembly;
            Array.Copy(allDependentAssemblies, 0, allAssemblies, 1, allDependentAssemblies.Length);

            for (int i = 0; i < allAssemblies.Length; i++)
            {
                Type[] allPropertyDataTypes = allAssemblies[i].GetTypes().Where(t => t.IsSubclassOf(registryParentDataType)).ToArray();
                for (int j = 0; j < allPropertyDataTypes.Length; j++)
                {
                    Type currentPropertyDataType = allPropertyDataTypes[j];
                    if (currentPropertyDataType == null || currentPropertyDataType.ContainsGenericParameters) continue;

                    var testInstance = Activator.CreateInstance(currentPropertyDataType);

                    FString returnedPropType = currentPropertyDataType.GetProperty("PropertyType")?.GetValue(testInstance, null) as FString;
                    if (returnedPropType == null) continue;
                    bool? returnedHasCustomStructSerialization = currentPropertyDataType.GetProperty("HasCustomStructSerialization")?.GetValue(testInstance, null) as bool?;
                    if (returnedHasCustomStructSerialization == null) continue;
                    bool? returnedShouldBeRegistered = currentPropertyDataType.GetProperty("ShouldBeRegistered")?.GetValue(testInstance, null) as bool?;
                    if (returnedShouldBeRegistered == null) continue;

                    if ((bool)returnedShouldBeRegistered)
                    {
                        RegistryEntry res = new RegistryEntry();
                        res.PropertyType = currentPropertyDataType;
                        res.HasCustomStructSerialization = (bool)returnedHasCustomStructSerialization;

                        var nameParam = Expression.Parameter(typeof(FName));
                        res.Creator = Expression.Lambda<Func<FName, PropertyData>>(
                           Expression.New(currentPropertyDataType.GetConstructor(new[] { typeof(FName), }), new[] { nameParam, }),
                           nameParam
                        ).Compile();

                        _propertyTypeRegistry[returnedPropType.Value] = res;
                    }
                }
            }

            // Fetch the current git commit while we're here
            UAPUtils.CurrentCommit = string.Empty;
            using (Stream stream = registryParentDataType.Assembly.GetManifestResourceStream("UAssetAPI.git_commit.txt"))
            {
                if (stream != null)
                {
                    using (StreamReader reader = new StreamReader(stream))
                    {
                        if (reader != null) UAPUtils.CurrentCommit = reader.ReadToEnd().Trim();
                    }
                }
            }
        }

        /// <summary>
        /// Generates an unversioned header based on a list of properties, and sorts the list in the correct order to be serialized.
        /// </summary>
        /// <param name="data">The list of properties to sort and generate an unversioned header from.</param>
        /// <param name="parentName">The name of the parent of all the properties.</param>
        /// <param name="parentModulePath">The path to the module that the parent class/struct of this property is contained within.</param>
        /// <param name="asset">The UAsset which the properties are contained within.</param>
        public static FUnversionedHeader GenerateUnversionedHeader(ref List<PropertyData> data, FName parentName, FName parentModulePath, UAsset asset)
        {
            var sortedProps = new List<PropertyData>();
            if (!asset.HasUnversionedProperties) return null; // no point in wasting time generating it
            if (asset.Mappings == null) return null;

            int firstNumAll = int.MaxValue;
            int lastNumAll = int.MinValue;
            HashSet<int> propertiesToTouch = new HashSet<int>();
            Dictionary<int, PropertyData> propMap = new Dictionary<int, PropertyData>();
            HashSet<int> zeroProps = new HashSet<int>();
            foreach (PropertyData entry in data)
            {
                if (!asset.Mappings.TryGetProperty<UsmapProperty>(entry.Name, entry.Ancestry, entry.ArrayIndex, asset, out _, out int idx)) throw new FormatException("No valid property \"" + entry.Name.ToString() + "\" in class " + entry.Ancestry.Parent.ToString());
                propMap[idx] = entry;
                if (entry.CanBeZero(asset) && entry.IsZero) zeroProps.Add(idx);

                if (idx < firstNumAll) firstNumAll = idx;
                if (idx > lastNumAll) lastNumAll = idx;
                propertiesToTouch.Add(idx);
            }

            int lastNumBefore = -1;
            List<FFragment> allFrags = new List<FFragment>();
            if (propertiesToTouch.Count > 0)
            {
                while (true)
                {
                    HashSet<int> fragmentHasAnyZeros = new HashSet<int>(); // add 0 if any zeros from 0 to (FFragment.ValueMax-1), 1 if any zeros from FFragment.ValueMax to (FFragment.ValueMax*2-1), etc.

                    int firstNum = lastNumBefore + 1;
                    while (!propertiesToTouch.Contains(firstNum) && firstNum <= lastNumAll) firstNum++;
                    if (firstNum > lastNumAll) break;

#if DEBUGVERBOSE
                    if (allFrags.Count > 0) Debug.WriteLine("W: " + allFrags[allFrags.Count - 1]);
#endif

                    int lastNum = firstNum;
                    while (propertiesToTouch.Contains(lastNum))
                    {
                        if (zeroProps.Contains(lastNum))
                        {
                            int valueNum = lastNum - firstNum + 1;
                            fragmentHasAnyZeros.Add(valueNum / FFragment.ValueMax);
                        }
                        sortedProps.Add(propMap[lastNum]);

                        lastNum++;
                    }
                    lastNum--;

                    var newFrag = FFragment.GetFromBounds(lastNumBefore, firstNum, lastNum, fragmentHasAnyZeros.Contains(0), false);

                    // add extra 127s if we went over the max for either skip or value
                    while (newFrag.SkipNum > FFragment.SkipMax)
                    {
                        allFrags.Add(new FFragment(FFragment.SkipMax, 0, false, false));
                        newFrag.SkipNum -= FFragment.SkipMax;
                    }
                    int fragIdx = 0;
                    while (newFrag.ValueNum > FFragment.ValueMax)
                    {
                        allFrags.Add(new FFragment(newFrag.SkipNum, FFragment.ValueMax, false, fragmentHasAnyZeros.Contains(fragIdx), firstNum + FFragment.ValueMax * fragIdx));
                        newFrag.ValueNum -= FFragment.ValueMax;
                        newFrag.FirstNum += FFragment.ValueMax;
                        newFrag.SkipNum = 0;
                        newFrag.bHasAnyZeroes = fragmentHasAnyZeros.Contains(++fragIdx);
                    }

                    allFrags.Add(newFrag);
                    lastNumBefore = lastNum;
                }
                allFrags[allFrags.Count - 1].bIsLast = true;
#if DEBUGVERBOSE
                Debug.WriteLine("W: " + allFrags[allFrags.Count - 1]);
#endif
            }
            else
            {
                // add "blank" fragment
                // i'm pretty sure that any SkipNum should work here as long as ValueNum = 0, but this is what the engine does
                string highestSchema = parentName?.ToString();

                // i doubt that this is true, empirically tested; need more data
                int numSkip = 0;
                if (asset.ObjectVersion >= ObjectVersion.VER_UE4_CORRECT_LICENSEE_FLAG)
                {
                    numSkip = Math.Min(asset.Mappings.GetAllProperties(highestSchema, parentModulePath?.ToString(), asset).Count, FFragment.SkipMax);
                }
                else
                {
                    numSkip = asset.Mappings.Schemas[highestSchema].Properties.Count == 0 ? 0 : Math.Min(asset.Mappings.GetAllProperties(highestSchema, parentModulePath?.ToString(), asset).Count, FFragment.SkipMax);
                }
                allFrags.Add(new FFragment(numSkip, 0, true, false));
            }

            // generate zero mask
            bool bHasNonZeroValues = false;
            List<bool> zeroMaskList = new List<bool>();
            foreach (var frag in allFrags)
            {
                if (frag.bHasAnyZeroes)
                {
                    for (int i = 0; i < frag.ValueNum; i++)
                    {
                        bool isZero = zeroProps.Contains(frag.FirstNum + i);
                        if (!isZero) bHasNonZeroValues = true;
                        zeroMaskList.Add(isZero);
                    }
                }
            }
            BitArray zeroMask = new BitArray(zeroMaskList.ToArray());

            var res = new FUnversionedHeader();
            res.Fragments = new LinkedList<FFragment>();
            foreach (var frag in allFrags) res.Fragments.AddLast(frag);
            res.ZeroMask = zeroMask;
            res.bHasNonZeroValues = bHasNonZeroValues;
            if (res.Fragments.Count > 0)
            {
                res.CurrentFragment = res.Fragments.First;
                res.UnversionedPropertyIndex = res.CurrentFragment.Value.FirstNum;
            }

            data.Clear();
            data.AddRange(sortedProps);
            return res;
        }

        /// <summary>
        /// Initializes the correct PropertyData class based off of serialized name, type, etc.
        /// </summary>
        /// <param name="type">The serialized type of this property.</param>
        /// <param name="name">The serialized name of this property.</param>
        /// <param name="ancestry">The ancestry of the parent of this property.</param>
        /// <param name="parentName">The name of the parent class/struct of this property.</param>
        /// <param name="parentModulePath">The path to the module that the parent class/struct of this property is contained within.</param>
        /// <param name="asset">The UAsset which this property is contained within.</param>
        /// <param name="reader">The BinaryReader to read from. If left unspecified, you must call the <see cref="PropertyData.Read(AssetBinaryReader, bool, long, long, PropertySerializationContext)"/> method manually.</param>
        /// <param name="leng">The length of this property on disk in bytes.</param>
        /// <param name="propertyTagFlags">Property tag flags, if available.</param>
        /// <param name="ArrayIndex">The duplication index of this property.</param>
        /// <param name="includeHeader">Does this property serialize its header in the current context?</param>
        /// <param name="isZero">Is the body of this property empty?</param>
        /// <param name="propertyTypeName">The complete property type name, if available.</param>
        /// <returns>A new PropertyData instance based off of the passed parameters.</returns>
        public static PropertyData TypeToClass(FName type, FName name, AncestryInfo ancestry, FName parentName, FName parentModulePath, UAsset asset, AssetBinaryReader reader = null, int leng = 0, EPropertyTagFlags propertyTagFlags = EPropertyTagFlags.None, int ArrayIndex = 0, bool includeHeader = true, bool isZero = false, FPropertyTypeName propertyTypeName = null)
        {
            long startingOffset = 0;
            if (reader != null) startingOffset = reader.BaseStream.Position;

            if (type.Value.Value == "None") return null;

            PropertyData data = null;
            if (PropertyTypeRegistry.ContainsKey(type.Value.Value))
            {
                data = PropertyTypeRegistry[type.Value.Value].Creator.Invoke(name);
            }
            else
            {
#if DEBUGVERBOSE
                Debug.WriteLine("-----------");
                Debug.WriteLine("Parsing unknown type " + type.ToString());
                Debug.WriteLine("Length: " + leng);
                if (reader != null) Debug.WriteLine("Pos: " + reader.BaseStream.Position);
                Debug.WriteLine("Last type: " + lastType.PropertyType?.ToString());
                if (lastType is ArrayPropertyData) Debug.WriteLine("Last array's type was " + ((ArrayPropertyData)lastType).ArrayType?.ToString());
                if (lastType is StructPropertyData) Debug.WriteLine("Last struct's type was " + ((StructPropertyData)lastType).StructType?.ToString());
                if (lastType is MapPropertyData lastTypeMap)
                {
                    if (lastTypeMap.Value.Count == 0)
                    {
                        Debug.WriteLine("Last map's key type was " + lastTypeMap.KeyType?.ToString());
                        Debug.WriteLine("Last map's value type was " + lastTypeMap.ValueType?.ToString());
                    }
                    else
                    {
                        Debug.WriteLine("Last map's key type was " + lastTypeMap.Value.Keys.ElementAt(0).PropertyType?.ToString());
                        Debug.WriteLine("Last map's value type was " + lastTypeMap.Value[0].PropertyType?.ToString());
                    }
                }
                Debug.WriteLine("-----------");
#endif
                if (leng > 0)
                {
                    data = new UnknownPropertyData(name);
                    ((UnknownPropertyData)data).SetSerializingPropertyType(type.Value);
                }
                else
                {
                    if (reader == null) throw new FormatException("Unknown property type: " + type.ToString() + " (on " + name.ToString() + ")");
                    throw new FormatException("Unknown property type: " + type.ToString() + " (on " + name.ToString() + " at " + reader.BaseStream.Position + ")");
                }
            }

#if DEBUGVERBOSE
            lastType = data;
#endif

            data.IsZero = isZero;
            data.PropertyTagFlags = propertyTagFlags;
            data.Ancestry.Initialize(ancestry, parentName, parentModulePath);
            data.ArrayIndex = ArrayIndex;
            data.PropertyTypeName = propertyTypeName;
            if (reader != null && !isZero)
            {
                long posBefore = reader.BaseStream.Position;
                try
                {
                    data.Read(reader, includeHeader, leng);
                }
                catch (Exception)
                {
                    // if asset is unversioned, bubble the error up to make the whole export fail
                    // because unversioned headers aren't properly reconstructed currently
                    if (data is StructPropertyData && !reader.Asset.HasUnversionedProperties)
                    {
                        reader.BaseStream.Position = posBefore;
                        data = new RawStructPropertyData(name);
                        data.Ancestry.Initialize(ancestry, parentName, parentModulePath);
                        data.ArrayIndex = ArrayIndex;
                        data.PropertyTypeName = propertyTypeName;
                        data.Read(reader, includeHeader, leng);
                    }
                    else
                    {
                        throw;
                    }
                }
                if (data.Offset == 0) data.Offset = startingOffset; // fallback
            }
            else if (reader != null && isZero)
            {
                data.InitializeZero(reader);
            }

            return data;
        }

        /// <summary>
        /// Reads a property into memory.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from. The underlying stream should be at the position of the property to be read.</param>
        /// <param name="ancestry">The ancestry of the parent of this property.</param>
        /// <param name="parentName">The name of the parent class/struct of this property.</param>
        /// <param name="parentModulePath">The path to the module that the parent class/struct of this property is contained within.</param>
        /// <param name="header">The unversioned header to be used when reading this property. Leave null if none exists.</param>
        /// <param name="includeHeader">Does this property serialize its header in the current context?</param>
        /// <returns>The property read from disk.</returns>
        public static PropertyData Read(AssetBinaryReader reader, AncestryInfo ancestry, FName parentName, FName parentModulePath, FUnversionedHeader header, bool includeHeader)
        {
            long startingOffset = reader.BaseStream.Position;
            FName name = null;
            FName type = null;
            int leng = 0;
            EPropertyTagFlags propertyTagFlags = EPropertyTagFlags.None;
            FPropertyTypeName typeName = null;
            int ArrayIndex = 0;
            string structType = null;
            bool isZero = false;

            if (reader.Asset.HasUnversionedProperties)
            {
                if (reader.Asset.Mappings == null)
                {
                    throw new InvalidMappingsException();
                }

                UsmapSchema relevantSchema = reader.Asset.Mappings.GetSchemaFromName(parentName?.ToString(), reader.Asset, parentModulePath?.ToString());
                while (header.UnversionedPropertyIndex > header.CurrentFragment.Value.LastNum)
                {
                    if (header.CurrentFragment.Value.bIsLast) return null;
                    header.CurrentFragment = header.CurrentFragment.Next;
                    header.UnversionedPropertyIndex = header.CurrentFragment.Value.FirstNum;
                }

                int practicingUnversionedPropertyIndex = header.UnversionedPropertyIndex;
                while (practicingUnversionedPropertyIndex >= relevantSchema.PropCount) // if needed, go to parent struct
                {
                    practicingUnversionedPropertyIndex -= relevantSchema.PropCount;

                    if (relevantSchema.SuperType != null && relevantSchema.SuperTypeModulePath != null && reader.Asset.Mappings.Schemas.ContainsKey(relevantSchema.SuperTypeModulePath + "." + relevantSchema.SuperType))
                    {
                        relevantSchema = reader.Asset.Mappings.Schemas[relevantSchema.SuperTypeModulePath + "." + relevantSchema.SuperType];
                    }
                    else if (relevantSchema.SuperType != null && reader.Asset.Mappings.Schemas.ContainsKey(relevantSchema.SuperType) && relevantSchema.Name != relevantSchema.SuperType) // name is insufficient if name of super is same as name of child
                    {
                        relevantSchema = reader.Asset.Mappings.Schemas[relevantSchema.SuperType];
                    }
                    else
                    {
                        relevantSchema = null;
                    }

                    if (relevantSchema == null) throw new FormatException("Failed to find a valid property for schema index " + header.UnversionedPropertyIndex + " in the class " + parentName.ToString());
                }
                UsmapProperty relevantProperty = relevantSchema.Properties[practicingUnversionedPropertyIndex];
                header.UnversionedPropertyIndex += 1;

                name = FName.DefineDummy(reader.Asset, relevantProperty.Name);
                type = FName.DefineDummy(reader.Asset, relevantProperty.PropertyData.Type.ToString());
                leng = 1; // not serialized
                ArrayIndex = relevantProperty.ArrayIndex;
                if (relevantProperty.PropertyData is UsmapStructData usmapStruc) structType = usmapStruc.StructType;

                // check if property is zero
                if (header.CurrentFragment.Value.bHasAnyZeroes)
                {
                    isZero = header.ZeroMaskIndex >= header.ZeroMask.Count ? false : header.ZeroMask.Get(header.ZeroMaskIndex);
                    header.ZeroMaskIndex++;
                }
            }
            else if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                name = reader.ReadFName();
                if (name.Value.Value == "None") return null;

                typeName = new FPropertyTypeName(reader);
                type = typeName.GetName();
                leng = reader.ReadInt32();
                propertyTagFlags = (EPropertyTagFlags)reader.ReadByte();

                if (propertyTagFlags.HasFlag(EPropertyTagFlags.HasArrayIndex))
                {
                    ArrayIndex = reader.ReadInt32();
                }
            }
            else
            {
                name = reader.ReadFName();
                if (name.Value.Value == "None") return null;

                type = reader.ReadFName();

                leng = reader.ReadInt32();
                ArrayIndex = reader.ReadInt32();
            }

            PropertyData result = TypeToClass(type, name, ancestry, parentName, parentModulePath, reader.Asset, reader, leng, propertyTagFlags, ArrayIndex, includeHeader, isZero, typeName);
            if (structType != null && result is StructPropertyData strucProp) strucProp.StructType = FName.DefineDummy(reader.Asset, structType);
            result.Offset = startingOffset;
            //Debug.WriteLine(type);
            return result;
        }

        internal static readonly Regex allNonLetters = new Regex("[^a-zA-Z]", RegexOptions.Compiled);

        /// <summary>
        /// Reads an FProperty into memory. Primarily used as a part of <see cref="StructExport"/> serialization.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from. The underlying stream should be at the position of the FProperty to be read.</param>
        /// <returns>The FProperty read from disk.</returns>
        public static FProperty ReadFProperty(AssetBinaryReader reader)
        {
            FName serializedType = reader.ReadFName();
            Type requestedType = Type.GetType("UAssetAPI.FieldTypes.F" + allNonLetters.Replace(serializedType.Value.Value, string.Empty));
            if (requestedType == null) requestedType = typeof(FGenericProperty);
            var res = (FProperty)Activator.CreateInstance(requestedType);
            res.SerializedType = serializedType;
            res.Read(reader);
            return res;
        }

        /// <summary>
        /// Serializes an FProperty from memory.
        /// </summary>
        /// <param name="prop">The FProperty to serialize.</param>
        /// <param name="writer">The BinaryWriter to serialize the FProperty to.</param>
        public static void WriteFProperty(FProperty prop, AssetBinaryWriter writer)
        {
            writer.Write(prop.SerializedType);
            prop.Write(writer);
        }

        /// <summary>
        /// Reads a UProperty into memory. Primarily used as a part of <see cref="PropertyExport"/> serialization.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from. The underlying stream should be at the position of the UProperty to be read.</param>
        /// <param name="serializedType">The type of UProperty to be read.</param>
        /// <returns>The FProperty read from disk.</returns>
        public static UProperty ReadUProperty(AssetBinaryReader reader, FName serializedType)
        {
            return ReadUProperty(reader, Type.GetType("UAssetAPI.FieldTypes.U" + allNonLetters.Replace(serializedType.Value.Value, string.Empty)));
        }

        /// <summary>
        /// Reads a UProperty into memory. Primarily used as a part of <see cref="PropertyExport"/> serialization.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from. The underlying stream should be at the position of the UProperty to be read.</param>
        /// <param name="requestedType">The type of UProperty to be read.</param>
        /// <returns>The FProperty read from disk.</returns>
        public static UProperty ReadUProperty(AssetBinaryReader reader, Type requestedType)
        {
            if (requestedType == null) requestedType = typeof(UGenericProperty);
            var res = (UProperty)Activator.CreateInstance(requestedType);
            res.Read(reader);
            return res;
        }

        /// <summary>
        /// Reads a UProperty into memory. Primarily used as a part of <see cref="PropertyExport"/> serialization.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from. The underlying stream should be at the position of the UProperty to be read.</param>
        /// <returns>The FProperty read from disk.</returns>
        public static T ReadUProperty<T>(AssetBinaryReader reader) where T : UProperty
        {
            var res = (UProperty)Activator.CreateInstance(typeof(T));
            res.Read(reader);
            return (T)res;
        }

        /// <summary>
        /// Serializes a UProperty from memory.
        /// </summary>
        /// <param name="prop">The UProperty to serialize.</param>
        /// <param name="writer">The BinaryWriter to serialize the UProperty to.</param>
        public static void WriteUProperty(UProperty prop, AssetBinaryWriter writer)
        {
            prop.Write(writer);
        }

        /// <summary>
        /// Serializes a property from memory.
        /// </summary>
        /// <param name="property">The property to serialize.</param>
        /// <param name="writer">The BinaryWriter to serialize the property to.</param>
        /// <param name="includeHeader">Does this property serialize its header in the current context?</param>
        /// <returns>The serial offset where the length of the property is stored.</returns>
        public static int Write(PropertyData property, AssetBinaryWriter writer, bool includeHeader)
        {
            if (property == null) return -1;

            property.Offset = writer.BaseStream.Position;

            if (writer.Asset.HasUnversionedProperties)
            {
                if (!property.IsZero || !property.CanBeZero(writer.Asset)) property.Write(writer, includeHeader);
                return -1; // length is not serialized
            }
            else if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                writer.Write(property.Name);
                if (property is UnknownPropertyData unknownProp)
                {
                    writer.Write(new FName(writer.Asset, unknownProp.SerializingPropertyType));
                    writer.Write((int)0);
                }
                else
                {
                    property.PropertyTypeName.Write(writer);
                }

                // update flags appropriately
                if (property is BoolPropertyData bProp)
                {
                    if (bProp.Value) property.PropertyTagFlags |= EPropertyTagFlags.BoolTrue;
                    else property.PropertyTagFlags &= ~EPropertyTagFlags.BoolTrue;
                }

                if (property.ArrayIndex != 0) property.PropertyTagFlags |= EPropertyTagFlags.HasArrayIndex;
                else property.PropertyTagFlags &= ~EPropertyTagFlags.HasArrayIndex;

                if (property.PropertyGuid != null) property.PropertyTagFlags |= EPropertyTagFlags.HasPropertyGuid;
                else property.PropertyTagFlags &= ~EPropertyTagFlags.HasPropertyGuid;

                int oldLoc = (int)writer.BaseStream.Position;
                writer.Write((int)0); // initial length
                writer.Write((byte)property.PropertyTagFlags);
                if (property.ArrayIndex != 0) writer.Write(property.ArrayIndex);
                int realLength = property.Write(writer, includeHeader);
                int newLoc = (int)writer.BaseStream.Position;

                writer.Seek(oldLoc, SeekOrigin.Begin);
                writer.Write(realLength);
                writer.Seek(newLoc, SeekOrigin.Begin);
                return oldLoc;
            }
            else
            {
                writer.Write(property.Name);
                if (property is UnknownPropertyData unknownProp)
                {
                    writer.Write(new FName(writer.Asset, unknownProp.SerializingPropertyType));
                }
                else if (property is RawStructPropertyData)
                {
                    writer.Write(new FName(writer.Asset, FString.FromString("StructProperty")));
                }
                else
                {
                    writer.Write(new FName(writer.Asset, property.PropertyType));
                }
                int oldLoc = (int)writer.BaseStream.Position;
                writer.Write((int)0); // initial length
                writer.Write(property.ArrayIndex);
                int realLength = property.Write(writer, includeHeader);
                int newLoc = (int)writer.BaseStream.Position;

                writer.Seek(oldLoc, SeekOrigin.Begin);
                writer.Write(realLength);
                writer.Seek(newLoc, SeekOrigin.Begin);
                return oldLoc;
            }

        }
    }
}

```

`UAssetAPI/Pak/Interop.cs`:

```cs
/*
    This code was written by @trumank as part of the repak crate: https://github.com/trumank/repak

    MIT License

    Copyright 2024 Truman Kilen, spuds

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

namespace UAssetAPI;

using System;
using System.Runtime.InteropServices;

public static class RePakInterop
{
    public const string NativeLib = "repak_bind";

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_setup_allocator();
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_teardown_allocator();

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_builder_new();

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern void pak_builder_drop(IntPtr builder);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern void pak_reader_drop(IntPtr reader);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern void pak_writer_drop(IntPtr writer);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern void pak_buffer_drop(IntPtr buffer, ulong length);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern void pak_cstring_drop(IntPtr cstrign);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_builder_key(IntPtr builder, byte[] key);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_builder_compression(IntPtr builder, byte[] compressions, int length);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_builder_reader(IntPtr builder, StreamCallbacks ctx);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_builder_writer(IntPtr builder, StreamCallbacks ctx, PakVersion version, string mount_point, ulong path_hash_seed = 0);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern PakVersion pak_reader_version(IntPtr reader);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_reader_mount_point(IntPtr reader);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern int pak_reader_get(IntPtr reader, string path, StreamCallbacks ctx, out IntPtr buffer, out ulong length);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_reader_files(IntPtr reader, out ulong length);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr pak_drop_files(IntPtr buffer, ulong length);

    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern int pak_writer_write_file(IntPtr writer, string path, byte[] data, int data_len);
    [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl)]
    public static extern int pak_writer_write_index(IntPtr writer);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate long ReadCallback(IntPtr context, IntPtr buffer, ulong bufferLen);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate int WriteCallback(IntPtr context, IntPtr buffer, int bufferLen);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate ulong SeekCallback(IntPtr context, long offset, int origin);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate int FlushCallback(IntPtr context);

    [StructLayout(LayoutKind.Sequential)]
    public struct StreamCallbacks
    {
        public IntPtr Context;
        public ReadCallback ReadCb;
        public WriteCallback WriteCb;
        public SeekCallback SeekCb;
        public FlushCallback FlushCb;
    }
}

```

`UAssetAPI/Pak/RePak.cs`:

```cs
/*
    This code has been slightly adapted from code written by @trumank as part of the repak crate: https://github.com/trumank/repak

    MIT License

    Copyright 2024 Truman Kilen, spuds

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

namespace UAssetAPI;

using Microsoft.Win32.SafeHandles;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Runtime.InteropServices;
using UAssetAPI.PropertyTypes.Objects;

public enum PakVersion : byte
{
    V0 = 0,
    V1 = 1,
    V2 = 2,
    V3 = 3,
    V4 = 4,
    V5 = 5,
    V6 = 6,
    V7 = 7,
    V8A = 8,
    V8B = 9,
    V9 = 10,
    V10 = 11,
    V11 = 12
}

public enum PakCompression : byte
{
    Zlib,
    Gzip,
    Oodle,
    Zstd
}

public class PakBuilder : SafeHandleZeroOrMinusOneIsInvalid
{
    public PakBuilder() : base(true)
    {
        try
        {
            SetHandle(RePakInterop.pak_builder_new());
        }
        catch (Exception ex)
        {
            if (ex is DllNotFoundException || ex is BadImageFormatException)
            {
                // extract dll if needed
                string outPath = Path.Combine(Directory.GetCurrentDirectory(), RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? "repak_bind.so" : "repak_bind.dll");
                using (var resource = typeof(PropertyData).Assembly.GetManifestResourceStream(RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? "UAssetAPI.repak_bind.so.gz" : "UAssetAPI.repak_bind.dll.gz"))
                {
                    if (resource != null)
                    {
                        using (var file = new FileStream(outPath, FileMode.Create, FileAccess.Write))
                        {
                            using (var gzipStream = new GZipStream(resource, CompressionMode.Decompress))
                            {
                                gzipStream.CopyTo(file);
                            }
                        }
                    }
                }

                NativeLibrary.Load(outPath);

                SetHandle(RePakInterop.pak_builder_new());
            }
            else
            {
                throw;
            }
        }
    }
    protected override bool ReleaseHandle()
    {
        RePakInterop.pak_builder_drop(handle);
        return true;
    }

    public PakBuilder Key(byte[] key)
    {
        if (key.Length != 32) throw new Exception("Invalid AES key length");
        SetHandle(RePakInterop.pak_builder_key(handle, key));
        return this;
    }

    public PakBuilder Compression(PakCompression[] compressions)
    {
        SetHandle(RePakInterop.pak_builder_compression(handle, compressions.Select(c => Convert.ToByte(c)).ToArray(), compressions.Length));
        return this;
    }

    public PakWriter Writer(Stream stream, PakVersion version = PakVersion.V11, string mountPoint = "../../../", ulong pathHashSeed = 0)
    {
        if (handle == IntPtr.Zero) throw new Exception("PakBuilder handle invalid");

        var streamCtx = StreamCallbacks.Create(stream);

        IntPtr writerHandle = RePakInterop.pak_builder_writer(handle, streamCtx, version, mountPoint, pathHashSeed);

        // pak_builder_reader consumes the builder
        SetHandleAsInvalid();
        SetHandle(IntPtr.Zero);

        return new PakWriter(writerHandle, streamCtx.Context);
    }

    public PakReader Reader(Stream stream)
    {
        if (handle == IntPtr.Zero) throw new Exception("PakBuilder handle invalid");

        var streamCtx = StreamCallbacks.Create(stream);

        IntPtr readerHandle = RePakInterop.pak_builder_reader(handle, streamCtx);
        StreamCallbacks.Free(streamCtx.Context);

        // pak_builder_reader consumes the builder
        SetHandleAsInvalid();
        SetHandle(IntPtr.Zero);

        if (readerHandle == IntPtr.Zero) throw new Exception("Failed to create PakReader");
        return new PakReader(readerHandle, stream);
    }
}

public class PakWriter : SafeHandleZeroOrMinusOneIsInvalid
{
    private IntPtr _streamCtx;

    public PakWriter(IntPtr handle, IntPtr streamCtx) : base(true)
    {
        SetHandle(handle);
        _streamCtx = streamCtx;
    }
    protected override bool ReleaseHandle()
    {
        RePakInterop.pak_writer_drop(handle);
        StreamCallbacks.Free(_streamCtx);
        return true;
    }

    public void WriteFile(string path, byte[] data)
    {
        if (handle == IntPtr.Zero) throw new Exception("PakWriter handle invalid");
        int result = RePakInterop.pak_writer_write_file(handle, path, data, data.Length);
        if (result != 0) throw new Exception("Failed to write file");
    }

    public void WriteIndex()
    {
        int result = RePakInterop.pak_writer_write_index(handle);

        // write_index drops the writer
        SetHandleAsInvalid();
        SetHandle(IntPtr.Zero);
        StreamCallbacks.Free(_streamCtx);

        if (result != 0) throw new Exception("Failed to write index");
    }
}

public class PakReader : SafeHandleZeroOrMinusOneIsInvalid
{
    public PakReader(IntPtr handle, Stream stream) : base(true)
    {
        SetHandle(handle);
    }

    protected override bool ReleaseHandle()
    {
        RePakInterop.pak_reader_drop(handle);
        return true;
    }

    public string GetMountPoint()
    {
        if (handle == IntPtr.Zero) throw new Exception("PakReader handle invalid");

        var cstring = RePakInterop.pak_reader_mount_point(handle);
        var mountPoint = Marshal.PtrToStringAnsi(cstring);

        RePakInterop.pak_cstring_drop(cstring);

        return mountPoint;
    }

    public PakVersion GetVersion()
    {
        if (handle == IntPtr.Zero) throw new Exception("PakReader handle invalid");

        return RePakInterop.pak_reader_version(handle);
    }

    public byte[] Get(Stream stream, string path)
    {
        if (handle == IntPtr.Zero) throw new Exception("PakReader handle invalid");

        var streamCtx = StreamCallbacks.Create(stream);

        IntPtr bufferPtr;
        ulong length;
        int result = RePakInterop.pak_reader_get(handle, path, streamCtx, out bufferPtr, out length);

        StreamCallbacks.Free(streamCtx.Context);

        if (result != 0) return null;

        byte[] buffer = new byte[length];
        Marshal.Copy(bufferPtr, buffer, 0, (int)length);

        RePakInterop.pak_buffer_drop(bufferPtr, length);

        return buffer;
    }

    public string[] Files()
    {
        if (handle == IntPtr.Zero) throw new Exception("PakReader handle invalid");

        ulong length;
        IntPtr filesPtr = RePakInterop.pak_reader_files(handle, out length);
        var files = new List<string>();
        for (ulong i = 0; i < length; i++)
        {
            IntPtr currentPtr = Marshal.ReadIntPtr(filesPtr, (int)i * IntPtr.Size);
            files.Add(Marshal.PtrToStringAnsi(currentPtr));
        }
        RePakInterop.pak_drop_files(filesPtr, length);
        return files.ToArray();
    }
}


public static class StreamCallbacks
{
    public static RePakInterop.StreamCallbacks Create(Stream stream)
    {
        return new RePakInterop.StreamCallbacks
        {
            Context = GCHandle.ToIntPtr(GCHandle.Alloc(stream)),
            ReadCb = StreamCallbacks.ReadCallback,
            WriteCb = StreamCallbacks.WriteCallback,
            SeekCb = StreamCallbacks.SeekCallback,
            FlushCb = StreamCallbacks.FlushCallback
        };
    }
    public static void Free(IntPtr streamCtx)
    {
        GCHandle.FromIntPtr(streamCtx).Free();
    }

    public static long ReadCallback(IntPtr context, IntPtr buffer, ulong bufferLen)
    {
        var stream = (Stream)GCHandle.FromIntPtr(context).Target;
        try
        {
            byte[] bufferManaged = new byte[bufferLen];
            int bytesRead = stream.Read(bufferManaged, 0, (int)bufferLen);
            Marshal.Copy(bufferManaged, 0, buffer, bytesRead);
            return bytesRead;
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error during read {e}");
            return -1;
        }
    }

    public static int WriteCallback(IntPtr context, IntPtr buffer, int bufferLen)
    {
        var stream = (Stream)GCHandle.FromIntPtr(context).Target;
        var bufferManaged = new byte[bufferLen];
        Marshal.Copy(buffer, bufferManaged, 0, bufferLen);

        try
        {
            stream.Write(bufferManaged, 0, bufferLen);
            return bufferLen;
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error during write {e}");
            return -1;
        }
    }

    public static ulong SeekCallback(IntPtr context, long offset, int origin)
    {
        var stream = (Stream)GCHandle.FromIntPtr(context).Target;
        try
        {
            long newPosition = stream.Seek(offset, (SeekOrigin)origin);
            return (ulong)newPosition;
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error during seek {e}");
            return ulong.MaxValue;
        }
    }

    public static int FlushCallback(IntPtr context)
    {
        var stream = (Stream)GCHandle.FromIntPtr(context).Target;
        try
        {
            stream.Flush();
            return 0;
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error during flush {e}");
            return 1;
        }
    }
}
```

`UAssetAPI/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#if DEBUGTRACING
using PostSharp.Patterns.Diagnostics;
using PostSharp.Extensibility;
#endif

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("178417ec-1177-413e-be85-c83aecd64279")]

#if DEBUGTRACING
[assembly: UAssetAPI.Trace.LoggingAspect]
[assembly: UAssetAPI.Trace.LoggingAspect(AttributeTargetTypes="UAssetAPI.Trace.*", AttributeExclude = true)]
#endif
```

`UAssetAPI/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UAssetAPI.ExportTypes;

namespace UAssetAPI.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("UAssetAPI.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] AC7Key {
            get {
                object obj = ResourceManager.GetObject("AC7Key", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

```

`UAssetAPI/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="AC7Key" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\AC7Key.bin;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>
```

`UAssetAPI/PropertyTypes/Objects/ArrayPropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.IO;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes an array.
/// </summary>
public class ArrayPropertyData : PropertyData<PropertyData[]>
{
    [JsonProperty]
    public FName ArrayType;
    [JsonProperty]
    public StructPropertyData DummyStruct;

    internal bool ShouldSerializeStructsDifferently = true;

    public bool ShouldSerializeDummyStruct()
    {
        return Value.Length == 0;
    }

    public ArrayPropertyData(FName name) : base(name)
    {
        Value = [];
    }

    public ArrayPropertyData()
    {
        Value = [];
    }

    private static readonly FString CurrentPropertyType = new FString("ArrayProperty");
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader && !reader.Asset.HasUnversionedProperties)
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                if (PropertyTypeName is null) throw new FormatException("PropertyTypeName is required to read ArrayProperty with complete type names.");
                ArrayType = PropertyTypeName.GetParameter(0).GetName();
            }
            else
            {
                ArrayType = reader.ReadFName();
            }
                
            this.ReadEndPropertyTag(reader);
        }

        FName arrayStructType = null;
        if (reader.Asset.Mappings != null && ArrayType == null && reader.Asset.Mappings.TryGetPropertyData(Name, Ancestry, reader.Asset, out UsmapArrayData strucDat1))
        {
            ArrayType = FName.DefineDummy(reader.Asset, strucDat1.InnerType.Type.ToString());
            if (strucDat1.InnerType is UsmapStructData strucDat2) arrayStructType = FName.DefineDummy(reader.Asset, strucDat2.StructType);
        }

        if (reader.Asset.HasUnversionedProperties && ArrayType == null)
        {
            throw new InvalidOperationException("Unable to determine array type for array " + Name.Value.Value + " in class " + Ancestry.Parent.Value.Value);
        }

        int numEntries = reader.ReadInt32();
        if (ArrayType.Value.Value == "StructProperty" && ShouldSerializeStructsDifferently && !reader.Asset.HasUnversionedProperties)
        {
            var results = new PropertyData[numEntries];

            FName name = this.Name;
            long structLength = 1;
            FName fullType = FName.DefineDummy(reader.Asset, "Generic");
            Guid structGUID = new Guid();

            bool isSpecialCase = false;
            if (reader.Asset is UAsset asset)
            {
                isSpecialCase = reader.Asset.ObjectVersion == ObjectVersion.VER_UE4_INNER_ARRAY_TAG_INFO && asset.WillSerializeNameHashes == true;
            }

            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                fullType = PropertyTypeName.GetParameter(0).GetParameter(0).GetName();
            }
            else if (reader.Asset.ObjectVersion >= ObjectVersion.VER_UE4_INNER_ARRAY_TAG_INFO && !isSpecialCase)
            {
                name = reader.ReadFName();
                if (name.Value.Value.Equals("None"))
                {
                    Value = results;
                    return;
                }

                FName thisArrayType = reader.ReadFName();
                if (thisArrayType.Value.Value.Equals("None"))
                {
                    Value = results;
                    return;
                }

                if (thisArrayType.Value.Value != ArrayType.Value.Value) throw new FormatException("Invalid array type: " + thisArrayType.ToString() + " vs " + ArrayType.ToString());

                structLength = reader.ReadInt64(); // length value
                fullType = reader.ReadFName();
                structGUID = new Guid(reader.ReadBytes(16));
                reader.ReadPropertyGuid();
            }
            else
            {
                // override using mappings or ArrayStructTypeOverride if applicable
                if (arrayStructType != null)
                {
                    fullType = arrayStructType;
                }
                else if (reader.Asset.ArrayStructTypeOverride.ContainsKey(this.Name.Value.Value))
                {
                    fullType = FName.DefineDummy(reader.Asset, reader.Asset.ArrayStructTypeOverride[this.Name.Value.Value]);
                }
            }

            if (numEntries == 0)
            {
                DummyStruct = new StructPropertyData(name, fullType)
                {
                    StructGUID = structGUID
                };
            }
            else
            {
                var propTypeName = PropertyTypeName?.GetParameter(0);
                for (int i = 0; i < numEntries; i++)
                {
                    var data = new StructPropertyData(name, fullType);
                    data.Offset = reader.BaseStream.Position;
                    data.Ancestry.Initialize(Ancestry, Name);
                    data.PropertyTypeName = propTypeName;
                    data.Read(reader, false, structLength, 0, PropertySerializationContext.Array);
                    data.StructGUID = structGUID;
                    results[i] = data;
                }
                DummyStruct = (StructPropertyData)results[0];
            }
            Value = results;
        }
        else
        {
            if (numEntries == 0)
            {
                Value = [];
                return;
            }

            int averageSizeEstimate = (int)((leng1 - 4) / numEntries);
            if (averageSizeEstimate <= 0) averageSizeEstimate = 1; // missing possible edge case where leng1 = 4 and numEntries = 2, may result is wrong size

            var propTypeName = PropertyTypeName?.GetParameter(0);
            var results = new PropertyData[numEntries];
            for (int i = 0; i < numEntries; i++)
            {
                results[i] = MainSerializer.TypeToClass(ArrayType, FName.DefineDummy(reader.Asset, i.ToString(), int.MinValue), Ancestry, Name, null, reader.Asset, propertyTypeName: propTypeName);
                results[i].Offset = reader.BaseStream.Position;
                if (results[i] is StructPropertyData data) data.StructType = arrayStructType == null ? FName.DefineDummy(reader.Asset, "Generic") : arrayStructType;
                results[i].Read(reader, false, averageSizeEstimate, 0, PropertySerializationContext.Array);
            }

            Value = results;
        }
    }

    public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
    {
        var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
        ancestryNew.SetAsParent(Name);

        if (Value != null)
        {
            for (int i = 0; i < Value.Length; i++) Value[i].ResolveAncestries(asset, ancestryNew);
        }
        base.ResolveAncestries(asset, ancestrySoFar);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (Value == null) Value = [];

        // let's get our ArrayType if we don't already know it
        // if Value has entries, take it from there
        if (Value.Length > 0)
        {
            ArrayType = writer.Asset.HasUnversionedProperties ? FName.DefineDummy(writer.Asset, Value[0].PropertyType) : new FName(writer.Asset, Value[0].PropertyType);
        }

        // otherwise, let's check mappings
        FName arrayStructType = null;
        if (writer.Asset.Mappings != null && ArrayType == null && writer.Asset.Mappings.TryGetPropertyData(Name, Ancestry, writer.Asset, out UsmapArrayData strucDat1))
        {
            ArrayType = FName.DefineDummy(writer.Asset, strucDat1.InnerType.Type.ToString());
            if (strucDat1.InnerType is UsmapStructData strucDat2) arrayStructType = FName.DefineDummy(writer.Asset, strucDat2.StructType);
        }

        // at this point, if we couldn't get our ArrayType and we're using unversioned properties, we can't continue; otherwise, not needed
        if (writer.Asset.HasUnversionedProperties && ArrayType == null)
        {
            throw new InvalidOperationException("Unable to determine array type for array " + Name.Value.Value + " in class " + Ancestry.Parent.Value.Value);
        }

        // begin actual serialization
        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                writer.Write(ArrayType);
            }
            this.WriteEndPropertyTag(writer);
        }

        int here = (int)writer.BaseStream.Position;
        writer.Write(Value.Length);
        if (ArrayType?.Value?.Value == "StructProperty" && ShouldSerializeStructsDifferently && !writer.Asset.HasUnversionedProperties)
        {
            if (Value.Length == 0 && DummyStruct == null)
            {
                // let's try and reconstruct DummyStruct, if we can
                if (arrayStructType == null && writer.Asset.ArrayStructTypeOverride.ContainsKey(this.Name.Value.Value))
                {
                    arrayStructType = FName.DefineDummy(writer.Asset, writer.Asset.ArrayStructTypeOverride[this.Name.Value.Value]);
                }

                if (arrayStructType == null)
                {
                    throw new InvalidOperationException("Unable to reconstruct DummyStruct within empty StructProperty array " + Name.Value.Value + " in class " + Ancestry.Parent.Value.Value);
                }

                DummyStruct = new StructPropertyData(this.Name, arrayStructType)
                {
                    StructGUID = Guid.Empty // not sure what else to use here...
                };
            }
            if (Value.Length > 0) DummyStruct = (StructPropertyData)Value[0];

            FName fullType = DummyStruct.StructType;

            int lengthLoc = -1;

            bool isSpecialCase = false;
            if (writer.Asset is UAsset)
            {
                isSpecialCase = writer.Asset.ObjectVersion == ObjectVersion.VER_UE4_INNER_ARRAY_TAG_INFO && ((UAsset)writer.Asset).WillSerializeNameHashes == true;
            }

            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME && writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_INNER_ARRAY_TAG_INFO && !isSpecialCase)
            {
                writer.Write(DummyStruct.Name);
                writer.Write(new FName(writer.Asset, "StructProperty"));
                lengthLoc = (int)writer.BaseStream.Position;
                writer.Write((long)0);
                writer.Write(fullType);
                if (writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG) writer.Write(DummyStruct.StructGUID.ToByteArray());
                if (writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_PROPERTY_GUID_IN_PROPERTY_TAG) writer.Write((byte)0);
            }

            for (int i = 0; i < Value.Length; i++)
            {
                ((StructPropertyData)Value[i]).StructType = fullType;
                Value[i].Offset = writer.BaseStream.Position;
                Value[i].Write(writer, false);
            }

            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME && writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_INNER_ARRAY_TAG_INFO && !isSpecialCase)
            {
                int fullLen = (int)writer.BaseStream.Position - lengthLoc;
                int newLoc = (int)writer.BaseStream.Position;
                writer.Seek(lengthLoc, SeekOrigin.Begin);
                writer.Write(fullLen - 32 - (includeHeader ? 1 : 0));
                writer.Seek(newLoc, SeekOrigin.Begin);
            }
        }
        else
        {
            for (int i = 0; i < Value.Length; i++)
            {
                Value[i].Offset = writer.BaseStream.Position;
                Value[i].Write(writer, false, PropertySerializationContext.Array);
            }
        }

        return (int)writer.BaseStream.Position - here;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        if (d[4] != null) ArrayType = FName.FromString(asset, d[4]);
    }

    protected override void HandleCloned(PropertyData res)
    {
        ArrayPropertyData cloningProperty = (ArrayPropertyData)res;
        cloningProperty.ArrayType = (FName)this.ArrayType?.Clone();
        cloningProperty.DummyStruct = (StructPropertyData)this.DummyStruct?.Clone();
    }
}
```

`UAssetAPI/PropertyTypes/Objects/BoolPropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a boolean (<see cref="bool"/>).
/// </summary>
public class BoolPropertyData : PropertyData<bool>
{
    public BoolPropertyData(FName name) : base(name) { }

    public BoolPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("BoolProperty");
    public override FString PropertyType => CurrentPropertyType;
    public override object DefaultValue => false;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (reader.Asset.HasUnversionedProperties || reader.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
        {
            Value = reader.ReadBoolean();
        }
        else
        {
            if (serializationContext is PropertySerializationContext.Map or PropertySerializationContext.Array)
                Value = reader.ReadBoolean();
            else
                Value = this.PropertyTagFlags.HasFlag(EPropertyTagFlags.BoolTrue);
        }
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (writer.Asset.HasUnversionedProperties || writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
        {
            writer.Write(Value);
        }
        else if (serializationContext is PropertySerializationContext.Map or PropertySerializationContext.Array)
        {
            writer.Write(Value);
        }

        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }
        return 0;
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = d[0].Equals("1") || d[0].ToLowerInvariant().Equals("true");
    }
}
```

`UAssetAPI/PropertyTypes/Objects/BytePropertyData.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.PropertyTypes.Objects;

public enum BytePropertyType
{
    Byte,
    FName,
}

/// <summary>
/// Describes a byte or an enumeration value.
/// </summary>
public class BytePropertyData : PropertyData
{
    [JsonProperty]
    [JsonConverter(typeof(StringEnumConverter))]
    public BytePropertyType ByteType;

    [JsonProperty]
    public FName EnumType;
    [JsonProperty]
    public byte Value;
    [JsonProperty]
    public FName EnumValue;

    public bool ShouldSerializeValue()
    {
        return ByteType == BytePropertyType.Byte;
    }

    public bool ShouldSerializeEnumValue()
    {
        return ByteType == BytePropertyType.FName;
    }

    public BytePropertyData(FName name) : base(name) { }

    public BytePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ByteProperty");
    public override FString PropertyType { get { return CurrentPropertyType; } }

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        ReadCustom(reader, includeHeader, leng1, leng2, true);
    }

    private void ReadCustom(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, bool canRepeat)
    {
        if (includeHeader && !reader.Asset.HasUnversionedProperties)
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                if (PropertyTypeName is null) throw new FormatException("PropertyTypeName is required to read ByteProperty with complete type names.");
                EnumType = PropertyTypeName.GetParameter(0).GetName();
            }
            else
            {
                EnumType = reader.ReadFName();
            }
            
            this.ReadEndPropertyTag(reader);
        }

        bool useFailsafe = true;
        if (reader.Asset.Mappings != null && reader.Asset.Mappings.TryGetPropertyData(Name, Ancestry, reader.Asset, out UsmapPropertyData propDat))
        {
            useFailsafe = false;
            ByteType = propDat is UsmapEnumData ? BytePropertyType.FName : BytePropertyType.Byte; // TODO: not always accurate?
        }

        // override with length if it makes sense to do so
        if (!reader.Asset.HasUnversionedProperties)
        {
            switch (leng1)
            {
                case 1:
                    ByteType = BytePropertyType.Byte;
                    useFailsafe = false;
                    break;
                case 8:
                    ByteType = BytePropertyType.FName;
                    useFailsafe = false;
                    break;
            }
        }
        
        if (useFailsafe)
        {
            switch (leng1)
            {
                case 0: // Should be only seen in maps; fallback "make our best guess and pray we're right" behavior
                    int nameMapPointer = reader.ReadInt32();
                    int nameMapIndex = reader.ReadInt32();
                    reader.BaseStream.Position -= sizeof(int) * 2;

                    // In the case of it being serialized as just a byte, it will probably try to parse part of the next property and produce something too big for the name map
                    if (nameMapPointer >= 0 && nameMapPointer < reader.Asset.GetNameMapIndexList().Count && nameMapIndex == 0 && !reader.Asset.GetNameReference(nameMapPointer).ToString().Contains("/"))
                    {
                        ByteType = BytePropertyType.FName;
                        break;
                    }
                    else
                    {
                        ByteType = BytePropertyType.Byte;
                        break;
                    }
                default:
                    if (canRepeat)
                    {
                        ReadCustom(reader, false, leng2, 0, false);
                        return;
                    }
                    throw new FormatException("Invalid length " + leng1 + " for ByteProperty");
            }
        }

        if (ByteType == BytePropertyType.Byte)
        {
            Value = reader.ReadByte();
        }
        else if (ByteType == BytePropertyType.FName)
        {
            EnumValue = reader.ReadFName();
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                writer.Write(EnumType);
            }
            this.WriteEndPropertyTag(writer);
        }

        switch (ByteType)
        {
            case BytePropertyType.Byte:
                writer.Write((byte)Value);
                return 1;
            case BytePropertyType.FName:
                writer.Write(EnumValue);
                return 8;
            default:
                throw new FormatException("Invalid BytePropertyType " + ByteType);
        }
    }

    public FName GetEnumBase()
    {
        return EnumType;
    }

    public FName GetEnumFull()
    {
        return EnumValue;
    }

    public override string ToString()
    {
        if (ByteType == BytePropertyType.Byte) return Convert.ToString(Value);
        //return GetEnumFull().Value;
        return Value.ToString();
    }

    public override void FromString(string[] d, UAsset asset)
    {
        EnumType = FName.FromString(asset, d[0]);
        if (byte.TryParse(d[1], out byte res))
        {
            ByteType = BytePropertyType.Byte;
            Value = res;
        }
        else
        {
            ByteType = BytePropertyType.FName;
            EnumValue = FName.FromString(asset, d[1]);
        }
    }
}
```

`UAssetAPI/PropertyTypes/Objects/DelegatePropertyData.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a function bound to an Object.
/// </summary>
[JsonObject(MemberSerialization.OptIn)]
public class FDelegate
{
    /// <summary>
    /// References the main actor export
    /// </summary>
    [JsonProperty]
    public FPackageIndex Object;
    /// <summary>
    /// The name of the delegate
    /// </summary>
    [JsonProperty]
    public FName Delegate;

    public FDelegate(FPackageIndex _object, FName @delegate)
    {
        Object = _object;
        Delegate = @delegate;
    }

    public FDelegate() { }

    public FDelegate(AssetBinaryReader reader)
    {
        Object = new FPackageIndex(reader);
        Delegate = reader.ReadFName();
    }

    public int Write(AssetBinaryWriter writer)
    {
        writer.XFERPTR(Object);
        int size = sizeof(int);
        writer.Write(Delegate);
        size += 8;
        return size;
    }
}

/// <summary>
/// Describes a function bound to an Object.
/// </summary>
public class DelegatePropertyData : PropertyData<FDelegate>
{
    public DelegatePropertyData(FName name) : base(name) { }

    public DelegatePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("DelegateProperty");
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FDelegate(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        Value ??= new FDelegate(FPackageIndex.FromRawIndex(0), null);
        return Value.Write(writer);
    }

    public override string ToString()
    {
        return null;
    }

    public override void FromString(string[] d, UAsset asset)
    {

    }

    protected override void HandleCloned(PropertyData res)
    {
        DelegatePropertyData cloningProperty = (DelegatePropertyData)res;

        cloningProperty.Value = new FDelegate(this.Value.Object, this.Value.Delegate);
    }
}
```

`UAssetAPI/PropertyTypes/Objects/DoublePropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.JSON;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes an IEEE 64-bit floating point variable (<see cref="double"/>).
/// </summary>
public class DoublePropertyData : PropertyData
{
    /// <summary>
    /// The double that this property represents.
    /// </summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Value
    {
        get => GetObject<double>();
        set => SetObject(value);
    }

    public DoublePropertyData(FName name) : base(name) { }

    public DoublePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("DoubleProperty");
    public override FString PropertyType => CurrentPropertyType;
    public override object DefaultValue => (double)0;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadDouble();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(double);
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (double.TryParse(d[0], out double res)) Value = res;
    }
}

```

`UAssetAPI/PropertyTypes/Objects/EnumPropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes an enumeration value.
/// </summary>
public class EnumPropertyData : PropertyData<FName>
{
    [JsonProperty]
    public FName EnumType;
    /// <summary>
    /// Only used with unversioned properties.
    /// </summary>
    [JsonProperty]
    public FName InnerType;

    public EnumPropertyData(FName name) : base(name) { }

    public EnumPropertyData() { }

    private static readonly List<string> ValidEnumInnerTypeList = ["ByteProperty", "UInt16Property", "UInt32Property", "Int8Property", "Int16Property", "IntProperty", "Int64Property"];

    private static readonly FString CurrentPropertyType = new FString("EnumProperty");
    public override FString PropertyType { get { return CurrentPropertyType; } }

    public static readonly string InvalidEnumIndexFallbackPrefix = "UASSETAPI_INVALID_ENUM_IDX_";

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (reader.Asset.Mappings != null && reader.Asset.Mappings.TryGetPropertyData(Name, Ancestry, reader.Asset, out UsmapEnumData enumDat1))
        {
            EnumType = reader.Asset.HasUnversionedProperties ? FName.DefineDummy(reader.Asset, enumDat1.Name) : new FName(reader.Asset, enumDat1.Name);
            InnerType = reader.Asset.HasUnversionedProperties ? FName.DefineDummy(reader.Asset, enumDat1.InnerType.Type.ToString()) : new FName(reader.Asset, enumDat1.Name);
        }

        if (reader.Asset.HasUnversionedProperties && serializationContext == PropertySerializationContext.Normal)
        {
            Value = null;
            if (InnerType?.Value.Value == "ByteProperty" || InnerType?.Value.Value == "UInt16Property" || InnerType?.Value.Value == "UInt32Property")
            {
                long enumIndice = 0;

                switch (InnerType?.Value.Value)
                {
                    case "ByteProperty":
                        enumIndice = reader.ReadByte();
                        if (enumIndice == byte.MaxValue) return;
                        break;
                    case "UInt16Property":
                        enumIndice = reader.ReadUInt16();
                        if (enumIndice == ushort.MaxValue) return;
                        break;
                    case "UInt32Property":
                        enumIndice = reader.ReadUInt32();
                        if (enumIndice == uint.MaxValue) return;
                        break;
                }

                var listOfValues = reader.Asset.Mappings.EnumMap[EnumType.Value.Value].Values;
                if (enumIndice < listOfValues.Count)
                {
                    Value = FName.DefineDummy(reader.Asset, listOfValues[enumIndice]);
                }
                else
                {
                    // fallback
                    Value = FName.DefineDummy(reader.Asset, InvalidEnumIndexFallbackPrefix + enumIndice.ToString());
                }
                return;
            }

            if (InnerType?.Value.Value == "Int8Property" || InnerType?.Value.Value == "Int16Property" || 
                InnerType?.Value.Value == "IntProperty" || InnerType?.Value.Value == "Int64Property")
            {
                long enumIndice = 0;

                switch (InnerType?.Value.Value)
                {
                    case "Int8Property":
                        enumIndice = reader.ReadSByte();
                        break;
                    case "Int16Property":
                        enumIndice = reader.ReadInt16();
                        break;
                    case "IntProperty":
                        enumIndice = reader.ReadInt32();
                        break;
                    case "Int64Property":
                        enumIndice = reader.ReadInt64();
                        break;
                }

                var listOfValues = reader.Asset.Mappings.EnumMap[EnumType.Value.Value].Values;
                if (enumIndice < listOfValues.Count)
                {
                    Value = FName.DefineDummy(reader.Asset, listOfValues[enumIndice]);
                }
                else
                {
                    // fallback
                    Value = FName.DefineDummy(reader.Asset, InvalidEnumIndexFallbackPrefix + enumIndice.ToString());
                }
                return;
            }
        }

        if (includeHeader && !reader.Asset.HasUnversionedProperties)
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                if (PropertyTypeName is null) throw new FormatException("PropertyTypeName is required to read EnumProperty with complete type names.");
                EnumType = PropertyTypeName.GetParameter(0).GetName();
            }
            else
            {
                EnumType = reader.ReadFName();
            }
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadFName();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (writer.Asset.Mappings != null && writer.Asset.Mappings.TryGetPropertyData(Name, Ancestry, writer.Asset, out UsmapEnumData enumDat1))
        {
            EnumType = writer.Asset.HasUnversionedProperties ? FName.DefineDummy(writer.Asset, enumDat1.Name) : new FName(writer.Asset, enumDat1.Name);
            InnerType = writer.Asset.HasUnversionedProperties ? FName.DefineDummy(writer.Asset, enumDat1.InnerType.Type.ToString()) : new FName(writer.Asset, enumDat1.Name);
        }

        if (writer.Asset.HasUnversionedProperties && serializationContext == PropertySerializationContext.Normal)
        {
            if (ValidEnumInnerTypeList.Contains(InnerType?.Value?.Value))
            {
                long enumIndice = 0;
                var listOfEnums = writer.Asset.Mappings.EnumMap[EnumType.Value.Value].Values;
                var validIndices = listOfEnums.Where(pair => pair.Value == Value.Value.Value).Select(pair => pair.Key);
                if (Value == null)
                {
                    enumIndice = -1;
                }
                else if (validIndices.Count() == 0)
                {
                    bool success = false;
                    if (Value.Value.Value.StartsWith(InvalidEnumIndexFallbackPrefix))
                    {
                        success = long.TryParse(Value.Value.Value.Substring(InvalidEnumIndexFallbackPrefix.Length), out enumIndice);
                    }

                    if (!success)
                    {
                        throw new FormatException("Could not serialize EnumProperty value " + Value.Value.Value + " as " + InnerType?.Value?.Value);
                    }
                }
                else
                {
                    enumIndice = validIndices.FirstOrDefault();
                }

                switch (InnerType?.Value?.Value)
                {
                    case "ByteProperty":
                        writer.Write((byte)enumIndice);
                        return sizeof(byte);
                    case "UInt16Property":
                        writer.Write((ushort)enumIndice);
                        return sizeof(ushort);
                    case "UInt32Property":
                        writer.Write((uint)enumIndice);
                        return sizeof(uint);
                    case "Int8Property":
                        writer.Write((sbyte)enumIndice);
                        return sizeof(sbyte);
                    case "Int16Property":
                        writer.Write((short)enumIndice);
                        return sizeof(short);
                    case "IntProperty":
                        writer.Write((int)enumIndice);
                        return sizeof(int);
                    case "Int64Property":
                        writer.Write((long)enumIndice);
                        return sizeof(long);
                }
            }
        }

        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                writer.Write(EnumType);
            }
            
            this.WriteEndPropertyTag(writer);
        }
        writer.Write(Value);
        return sizeof(int) * 2;
    }

    internal override void InitializeZero(AssetBinaryReader reader)
    {
        if (reader.Asset.Mappings.TryGetPropertyData(Name, Ancestry, reader.Asset, out UsmapEnumData enumDat1))
        {
            EnumType = FName.DefineDummy(reader.Asset, enumDat1.Name);
            InnerType = FName.DefineDummy(reader.Asset, enumDat1.InnerType.Type.ToString());
        }

        // fill in data for enumIndice = 0 to provide clarity for end-user
        if (ValidEnumInnerTypeList.Contains(InnerType?.Value?.Value))
        {
            long enumIndice = 0;
            var listOfValues = reader.Asset.Mappings.EnumMap[EnumType.Value.Value].Values;
            if (enumIndice == byte.MaxValue)
            {
                Value = null;
            }
            else if (enumIndice < listOfValues.Count)
            {
                Value = FName.DefineDummy(reader.Asset, listOfValues[enumIndice]);
            }
            else
            {
                // fallback
                Value = FName.DefineDummy(reader.Asset, InvalidEnumIndexFallbackPrefix + enumIndice.ToString());
            }
        }
    }

    public override string ToString()
    {
        return Value.ToString();
    }

    // note: Value must be overridden manually after this is called in cases where serializationContext != PropertySerializationContext.Normal, to ensure not dummy
    public override void FromString(string[] d, UAsset asset)
    {
        if (d[0] != "null" && d[0] != null)
        {
            EnumType = asset.HasUnversionedProperties ? FName.DefineDummy(asset, d[0]) : FName.FromString(asset, d[0]);
        }
        else
        {
            EnumType = null;
        }

        if (d[1] != "null" && d[1] != null)
        {
            Value = (asset.HasUnversionedProperties && (ValidEnumInnerTypeList.Contains(InnerType?.Value?.Value))) ? FName.DefineDummy(asset, d[1]) : FName.FromString(asset, d[1]);
        }
        else
        {
            Value = null;
        }
    }

    protected override void HandleCloned(PropertyData res)
    {
        EnumPropertyData cloningProperty = (EnumPropertyData)res;
        cloningProperty.EnumType = (FName)this.EnumType?.Clone();
        cloningProperty.InnerType = (FName)this.InnerType?.Clone();
    }
}
```

`UAssetAPI/PropertyTypes/Objects/FieldPathPropertyData.cs`:

```cs
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a reference variable to another object which may be null, and may become valid or invalid at any point. Near synonym for <see cref="SoftObjectPropertyData"/>.
/// </summary>
public class FieldPathPropertyData : BasePropertyData<FFieldPath>
{
    public FieldPathPropertyData(FName name) : base(name) { }

    public FieldPathPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("FieldPathProperty");
    public override FString PropertyType => CurrentPropertyType;
    public override bool HasCustomStructSerialization => false;
    public override object DefaultValue => new FFieldPath();

    public override string ToString()
    {
        // Expected format is: FullPackageName.Subobject[:Subobject:...]:FieldName
        return "";
    }

    public override void FromString(string[] d, UAsset asset)
    {
        // Expected format is: FullPackageName.Subobject[:Subobject:...]:FieldName
        Value = new FFieldPath();
    }
}
```

`UAssetAPI/PropertyTypes/Objects/FloatPropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.JSON;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes an IEEE 32-bit floating point variable (<see cref="float"/>).
/// </summary>
public class FloatPropertyData : PropertyData
{
    /// <summary>
    /// The float that this property represents.
    /// </summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public float Value
    {
        get => GetObject<float>();
        set => SetObject(value);
    }

    public FloatPropertyData(FName name) : base(name) { }

    public FloatPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("FloatProperty");
    public override FString PropertyType { get { return CurrentPropertyType; } }
    public override object DefaultValue { get { return (float)0; } }


    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadSingle();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(float);
    }

    public override string ToString()
    {
        return Convert.ToString(Value); // maybe: , System.Globalization.CultureInfo.InvariantCulture
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (float.TryParse(d[0], out float res)) Value = res;
    }
}

```

`UAssetAPI/PropertyTypes/Objects/Int16PropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a 16-bit signed integer variable (<see cref="short"/>).
/// </summary>
public class Int16PropertyData : PropertyData<short>
{
    public Int16PropertyData(FName name) : base(name) { }

    public Int16PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Int16Property");
    public override FString PropertyType => CurrentPropertyType;
    public override object DefaultValue => (short)0;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = (reader.Asset.HasUnversionedProperties && serializationContext != PropertySerializationContext.Normal) ? (short)reader.ReadInt64() : reader.ReadInt16();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        if (writer.Asset.HasUnversionedProperties && serializationContext != PropertySerializationContext.Normal)
        {
            writer.Write((long)Value);
            return sizeof(long);
        }

        writer.Write(Value);
        return sizeof(short);
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (short.TryParse(d[0], out short res)) Value = res;
    }
}
```

`UAssetAPI/PropertyTypes/Objects/Int64PropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a 64-bit signed integer variable (<see cref="long"/>).
/// </summary>
public class Int64PropertyData : PropertyData<long>
{
    public Int64PropertyData(FName name) : base(name) { }

    public Int64PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Int64Property");
    public override FString PropertyType { get { return CurrentPropertyType; } }
    public override object DefaultValue { get { return (long)0; } }

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadInt64();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(long);
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (long.TryParse(d[0], out long res)) Value = res;
    }
}
```

`UAssetAPI/PropertyTypes/Objects/Int8PropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes an 8-bit signed integer variable (<see cref="sbyte"/>).
/// </summary>
public class Int8PropertyData : PropertyData<sbyte>
{
    public Int8PropertyData(FName name) : base(name) { }

    public Int8PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Int8Property");
    public override FString PropertyType => CurrentPropertyType;
    public override object DefaultValue => (sbyte)0;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadSByte();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(sbyte);
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (sbyte.TryParse(d[0], out sbyte res)) Value = res;
    }
}
```

`UAssetAPI/PropertyTypes/Objects/IntPropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a 32-bit signed integer variable (<see cref="int"/>).
/// </summary>
public class IntPropertyData : PropertyData<int>
{
    public IntPropertyData(FName name) : base(name) { }

    public IntPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("IntProperty");
    public override FString PropertyType => CurrentPropertyType;
    public override object DefaultValue => (int)0;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadInt32();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(int);
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (int.TryParse(d[0], out int res)) Value = res;
    }
}

```

`UAssetAPI/PropertyTypes/Objects/InterfacePropertyData.cs`:

```cs
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a reference variable to another object (import/export) which may be null (<see cref="FPackageIndex"/>).
/// </summary>
public class InterfacePropertyData : ObjectPropertyData
{
    public InterfacePropertyData(FName name) : base(name) { }

    public InterfacePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("InterfaceProperty");
    public override FString PropertyType => CurrentPropertyType;
}

```

`UAssetAPI/PropertyTypes/Objects/MapPropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Linq;
using UAssetAPI.JSON;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a map.
/// </summary>
public class MapPropertyData : PropertyData
{
    /// <summary>
    /// The map that this property represents.
    /// </summary>
    [JsonProperty]
    [JsonConverter(typeof(TMapJsonConverter<PropertyData, PropertyData>))]
    public TMap<PropertyData, PropertyData> Value;

    /// <summary>
    /// Used when the length of the map is zero.
    /// </summary>]
    [JsonProperty]
    public FName KeyType;

    /// <summary>
    /// Used when the length of the map is zero.
    /// </summary>
    [JsonProperty]
    public FName ValueType;

    public bool ShouldSerializeKeyType() => Value.Count == 0;

    public bool ShouldSerializeValueType() => Value.Count == 0;

    [JsonProperty]
    public PropertyData[] KeysToRemove = null;

    public MapPropertyData(FName name) : base(name)
    {
        Value = new TMap<PropertyData, PropertyData>();
    }

    public MapPropertyData()
    {
        Value = new TMap<PropertyData, PropertyData>();
    }

    private static readonly FString CurrentPropertyType = new FString("MapProperty");
    public override FString PropertyType { get { return CurrentPropertyType; } }

    private PropertyData MapTypeToClass(FName type, FName name, AssetBinaryReader reader, int leng, bool includeHeader, bool isKey)
    {
        switch (type.Value.Value)
        {
            case "StructProperty":
                FName strucType = null;
                FPropertyTypeName propertyTypeNameLocal = PropertyTypeName?.GetParameter(isKey ? 0 : 1);
                if (!reader.Asset.HasUnversionedProperties && reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
                {
                    strucType = propertyTypeNameLocal?.GetParameter(0).GetName();
                }
                else if (reader.Asset.Mappings != null && reader.Asset.Mappings.TryGetPropertyData(Name, Ancestry, reader.Asset, out UsmapMapData mapDat))
                {
                    if (isKey && mapDat.InnerType is UsmapStructData strucDat1)
                    {
                        strucType = FName.DefineDummy(reader.Asset, strucDat1.StructType);
                    }
                    else if (mapDat.ValueType is UsmapStructData strucDat2)
                    {
                        strucType = FName.DefineDummy(reader.Asset, strucDat2.StructType);
                    }
                }
                else if (reader.Asset.MapStructTypeOverride.ContainsKey(name.Value.Value))
                {
                    if (isKey)
                    {
                        strucType = FName.DefineDummy(reader.Asset, reader.Asset.MapStructTypeOverride[name.Value.Value].Item1);
                    }
                    else
                    {
                        strucType = FName.DefineDummy(reader.Asset, reader.Asset.MapStructTypeOverride[name.Value.Value].Item2);
                        if (name.Value.Value == "TrackSignatureToTrackIdentifier" && reader.Asset.GetEngineVersion() <= EngineVersion.VER_UE4_18)
                            strucType = FName.DefineDummy(reader.Asset, "Generic");
                    }
                }

                if (strucType?.Value == null) strucType = FName.DefineDummy(reader.Asset, "Generic");

                StructPropertyData data = new StructPropertyData(name, strucType);
                data.Ancestry.Initialize(Ancestry, Name);
                data.Offset = reader.BaseStream.Position;
                data.PropertyTypeName = propertyTypeNameLocal;
                data.Read(reader, false, 1, 0, PropertySerializationContext.Map);
                return data;
            default:
                var res = MainSerializer.TypeToClass(type, name, Ancestry, Name, null, reader.Asset, null, leng, propertyTypeName: PropertyTypeName?.GetParameter(0));
                res.Ancestry.Initialize(Ancestry, Name);
                res.Read(reader, includeHeader, leng, 0, PropertySerializationContext.Map);
                return res;
        }
    }

    private TMap<PropertyData, PropertyData> ReadRawMap(AssetBinaryReader reader, FName type1, FName type2, int numEntries)
    {
        var resultingDict = new TMap<PropertyData, PropertyData>();

        PropertyData data1 = null;
        PropertyData data2 = null;
        for (int i = 0; i < numEntries; i++)
        {
            data1 = MapTypeToClass(type1, Name, reader, 0, false, true);
            data2 = MapTypeToClass(type2, Name, reader, 0, false, false);

            resultingDict.Add(data1, data2);
        }

        return resultingDict;
    }

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        FName type1 = null, type2 = null;
        if (includeHeader && !reader.Asset.HasUnversionedProperties)
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                if (PropertyTypeName is null) throw new FormatException("PropertyTypeName is required to read MapProperty with complete type names.");
                type1 = PropertyTypeName.GetParameter(0).GetName();
                type2 = PropertyTypeName.GetParameter(1).GetName();
            }
            else
            {
                type1 = reader.ReadFName();
                type2 = reader.ReadFName();
            }

            this.ReadEndPropertyTag(reader);
        }

        if (reader.Asset.Mappings != null && type1 == null && type2 == null && reader.Asset.Mappings.TryGetPropertyData(Name, Ancestry, reader.Asset, out UsmapMapData strucDat1))
        {
            type1 = FName.DefineDummy(reader.Asset, strucDat1.InnerType.Type.ToString());
            type2 = FName.DefineDummy(reader.Asset, strucDat1.ValueType.Type.ToString());
        }

        int numKeysToRemove = reader.ReadInt32();
        KeysToRemove = new PropertyData[numKeysToRemove];
        for (int i = 0; i < numKeysToRemove; i++)
        {
            KeysToRemove[i] = MapTypeToClass(type1, Name, reader, 0, false, true);
        }

        int numEntries = reader.ReadInt32();
        if (numEntries == 0)
        {
            KeyType = type1;
            ValueType = type2;
        }

        Value = ReadRawMap(reader, type1, type2, numEntries);
    }

    public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
    {
        var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
        ancestryNew.SetAsParent(Name);

        if (Value != null)
        {
            foreach (var entry in Value)
            {
                entry.Key.ResolveAncestries(asset, ancestryNew);
                entry.Value.ResolveAncestries(asset, ancestryNew);
            }
        }
        base.ResolveAncestries(asset, ancestrySoFar);
    }

    private void WriteRawMap(AssetBinaryWriter writer, TMap<PropertyData, PropertyData> map)
    {
        if (map == null) return;
        foreach (var entry in map)
        {
            entry.Key.Offset = writer.BaseStream.Position;
            entry.Key.Write(writer, false, PropertySerializationContext.Map);
            entry.Value.Offset = writer.BaseStream.Position;
            entry.Value.Write(writer, false, PropertySerializationContext.Map);
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                if (Value.Count > 0)
                {
                    writer.Write(new FName(writer.Asset, Value.Keys.ElementAt(0).PropertyType));
                    writer.Write(new FName(writer.Asset, Value[0].PropertyType));
                }
                else
                {
                    writer.Write(KeyType);
                    writer.Write(ValueType);
                }
            }
            this.WriteEndPropertyTag(writer);
        }

        int here = (int)writer.BaseStream.Position;
        writer.Write(KeysToRemove?.Length ?? 0);
        if (KeysToRemove != null)
        {
            for (int i = 0; i < KeysToRemove.Length; i++)
            {
                var entry = KeysToRemove[i];
                entry.Offset = writer.BaseStream.Position;
                entry.Write(writer, false, PropertySerializationContext.Array);
            }
        }

        writer.Write(Value?.Count ?? 0);
        WriteRawMap(writer, Value);
        return (int)writer.BaseStream.Position - here;
    }

    protected override void HandleCloned(PropertyData res)
    {
        MapPropertyData cloningProperty = (MapPropertyData)res;

        if (this.Value != null)
        {
            var newDict = new TMap<PropertyData, PropertyData>();
            foreach (var entry in this.Value)
            {
                newDict[(PropertyData)entry.Key.Clone()] = (PropertyData)entry.Value.Clone();
            }
            cloningProperty.Value = newDict;
        }
        else
        {
            cloningProperty.Value = null;
        }

        cloningProperty.KeysToRemove = (PropertyData[])this.KeysToRemove?.Clone();
        cloningProperty.KeyType = (FName)this.KeyType?.Clone();
        cloningProperty.ValueType = (FName)this.ValueType?.Clone();
    }
}
```

`UAssetAPI/PropertyTypes/Objects/MulticastDelegatePropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a list of functions bound to an Object.
/// </summary>
public class MulticastDelegatePropertyData : PropertyData<FDelegate[]>
{
    public MulticastDelegatePropertyData(FName name) : base(name) { }

    public MulticastDelegatePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MulticastDelegateProperty");
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadArray(() => new FDelegate(reader));
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        Value ??= [];
        writer.Write(Value.Length);
        var size = 4;
        for (int i = 0; i < Value.Length; i++)
        {
            size += Value[i].Write(writer);
        }
        return size;
    }

    public override string ToString()
    {
        string oup = "(";
        for (int i = 0; i < Value.Length; i++)
        {
            oup += "(" + Convert.ToString(Value[i].Object.Index) + ", " + Value[i].Delegate.Value.Value + "), ";
        }
        return oup.Substring(0, oup.Length - 2) + ")";
    }

    public override void FromString(string[] d, UAsset asset)
    {

    }

    protected override void HandleCloned(PropertyData res)
    {
        MulticastDelegatePropertyData cloningProperty = (MulticastDelegatePropertyData)res;

        if (Value != null)
        {
            FDelegate[] newData = new FDelegate[Value.Length];
            for (int i = 0; i < Value.Length; i++)
            {
                newData[i] = new FDelegate(Value[i].Object, (FName)Value[i].Delegate.Clone());
            }

            cloningProperty.Value = newData;
        }
        else
        {
            cloningProperty.Value = null;
        }
    }
}


/// <summary>
/// Describes a list of functions bound to an Object.
/// </summary>
public class MulticastSparseDelegatePropertyData : MulticastDelegatePropertyData
{
    public MulticastSparseDelegatePropertyData(FName name) : base(name) { }

    public MulticastSparseDelegatePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MulticastSparseDelegateProperty");
    public override FString PropertyType => CurrentPropertyType;
}


/// <summary>
/// Describes a list of functions bound to an Object.
/// </summary>
public class MulticastInlineDelegatePropertyData : MulticastDelegatePropertyData
{
    public MulticastInlineDelegatePropertyData(FName name) : base(name) { }

    public MulticastInlineDelegatePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MulticastInlineDelegateProperty");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Objects/NamePropertyData.cs`:

```cs
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes an <see cref="FName"/>.
/// </summary>
public class NamePropertyData : PropertyData<FName>
{
    public NamePropertyData(FName name) : base(name) { }

    public NamePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("NameProperty");
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadFName();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(int) * 2;
    }

    public override bool CanBeZero(UAsset asset)
    {
        return Value?.Value?.Value == null; // if the index is 0, we need to serialize it anyways
    }

    public override string ToString()
    {
        return Value == null ? "null" : Value.ToString();
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = FName.FromString(asset, d[0]);
    }
}
```

`UAssetAPI/PropertyTypes/Objects/ObjectPropertyData.cs`:

```cs
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a reference variable to another object (import/export) which may be null (<see cref="FPackageIndex"/>).
/// </summary>
public class ObjectPropertyData : PropertyData<FPackageIndex>
{
    public ObjectPropertyData(FName name) : base(name) { }

    public ObjectPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ObjectProperty");
    public override FString PropertyType => CurrentPropertyType;
    public override object DefaultValue => FPackageIndex.FromRawIndex(0);

    /// <summary>
    /// Returns true if this ObjectProperty represents an import.
    /// </summary>
    /// <returns>Is this ObjectProperty an import?</returns>
    public bool IsImport() => Value.IsImport();

    /// <summary>
    /// Returns true if this ObjectProperty represents an export.
    /// </summary>
    /// <returns>Is this ObjectProperty an export?</returns>
    public bool IsExport() => Value.IsExport();

    /// <summary>
    /// Return true if this ObjectProperty represents null (i.e. neither an import nor an export)
    /// </summary>
    /// <returns>Does this ObjectProperty represent null?</returns>
    public bool IsNull() => Value.IsNull();

    /// <summary>
    /// Check that this ObjectProperty is an import index and return the corresponding import.
    /// </summary>
    /// <returns>The import that this ObjectProperty represents in the import map.</returns>
    /// <exception cref="System.InvalidOperationException">Thrown when this is not an index into the import map.</exception>
    public Import ToImport(UAsset asset) => Value.ToImport(asset);

    /// <summary>
    /// Check that this ObjectProperty is an export index and return the corresponding export.
    /// </summary>
    /// <returns>The export that this ObjectProperty represents in the the export map.</returns>
    /// <exception cref="System.InvalidOperationException">Thrown when this is not an index into the export map.</exception>
    public Export ToExport(UAsset asset) => Value.ToExport(asset);

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FPackageIndex(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.Index);
        return sizeof(int);
    }

    public override string ToString()
    {
        return Value.ToString();
    }

    public override void FromString(string[] d, UAsset asset)
    {
        if (int.TryParse(d[0], out int res))
        {
            Value = new FPackageIndex(res);
            return;
        }
    }
}
```

`UAssetAPI/PropertyTypes/Objects/PropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects
{
    public enum PropertySerializationContext
    {
        Normal,
        Array,
        Map,
        StructFallback // a StructPropertyData with custom struct serialization falling back to standard serialization before/after reading custom data
    }

    [Flags]
    public enum EPropertyTagFlags
    {
        None						= 0x00,
        HasArrayIndex				= 0x01,
        HasPropertyGuid				= 0x02,
        HasPropertyExtensions		= 0x04,
        HasBinaryOrNativeSerialize	= 0x08,
        BoolTrue					= 0x10,
        SkippedSerialize            = 0x20,
    }

    [Flags]
    public enum EPropertyTagExtension : byte
    {
        NoExtension = 0x00,
        ReserveForFutureUse = 0x01,
        OverridableInformation = 0x02,
    }

    public enum EOverriddenPropertyOperation
    {
        /// <summary>
        /// no overridden operation was recorded on this property
        /// </summary>
        None =	0,
        /// <summary>
        /// some sub property has recorded overridden operation
        /// </summary>
        Modified,
        /// <summary>
        /// everything has been overridden from this property down to every sub property/sub object
        /// </summary>
        Replace,
        /// <summary>
        /// this element was added in the container
        /// </summary>
        Add,
        /// <summary>
        /// this element was removed from the container
        /// </summary>
        Remove
    };

    public class AncestryInfo : ICloneable
    {
        public List<FName> Ancestors = new List<FName>(5);
        public FName Parent
        {
            get
            {
                if (Ancestors.Count == 0) return null;
                return Ancestors[Ancestors.Count - 1];
            }
            set
            {
                Ancestors[Ancestors.Count - 1] = value;
            }
        }

        public object Clone() // shallow
        {
            var res = new AncestryInfo();
            res.Ancestors.AddRange(Ancestors);
            return res;
        }

        public AncestryInfo CloneWithoutParent()
        {
            AncestryInfo res = (AncestryInfo)this.Clone();
            res.Ancestors.RemoveAt(res.Ancestors.Count - 1);
            return res;
        }

        public void Initialize(AncestryInfo ancestors, FName dad, FName modulePath = null)
        {
            Ancestors.Clear();
            if (ancestors != null) Ancestors.AddRange(ancestors.Ancestors);
            SetAsParent(dad, modulePath);
        }

        public void SetAsParent(FName dad, FName modulePath = null)
        {
            if (dad != null) Ancestors.Add(string.IsNullOrEmpty(modulePath?.Value?.Value) ? dad : FName.DefineDummy(null, modulePath.ToString() + "." + dad.ToString()));
        }
    }

    /// <summary>
    /// Generic Unreal property class.
    /// </summary>
    [JsonObject(MemberSerialization.OptIn)]
    public abstract class PropertyData : ICloneable
    {
        /// <summary>
        /// The name of this property.
        /// </summary>
        [JsonProperty]
        public FName Name = null;

        /// <summary>
        /// The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.
        /// </summary>
        [JsonIgnore]
        public AncestryInfo Ancestry = new AncestryInfo();

        /// <summary>
        /// The array index of this property. Used to distinguish properties with the same name in the same struct.
        /// </summary>
        [JsonProperty]
        public int ArrayIndex = 0;

        /// <summary>
        /// An optional property GUID. Nearly always null.
        /// </summary>
        public Guid? PropertyGuid = null;

        /// <summary>
        /// Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes. <para/>
        /// This field will always be treated as if it is false if <see cref="CanBeZero(UAsset)"/> does not return true.
        /// </summary>
        [JsonProperty]
        public bool IsZero;

        [JsonProperty]
        public EPropertyTagFlags PropertyTagFlags;

        [JsonProperty]
        public FPropertyTypeName PropertyTypeName = null;

        /// <summary>
        /// Optional extensions to serialize with this property.
        /// </summary>
        [JsonProperty]
        public EPropertyTagExtension PropertyTagExtensions; // always serialize just cuz we cant guarantee access to Asset here to check for versions between PROPERTY_TAG_EXTENSION_AND_OVERRIDABLE_SERIALIZATION and PROPERTY_TAG_COMPLETE_TYPE_NAME

        [JsonProperty]
        public EOverriddenPropertyOperation OverrideOperation;
        [JsonProperty]
        public bool bExperimentalOverridableLogic;
        public bool ShouldSerializeOverrideOperation()
        {
            return PropertyTagExtensions.HasFlag(EPropertyTagExtension.OverridableInformation);
        }
        public bool ShouldSerializebExperimentalOverridableLogic()
        {
            return PropertyTagExtensions.HasFlag(EPropertyTagExtension.OverridableInformation);
        }


        /// <summary>
        /// The offset of this property on disk. This is for the user only, and has no bearing in the API itself.
        /// </summary>
        public long Offset = -1;

        /// <summary>
        /// An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.
        /// </summary>
        public object Tag;

        protected object _rawValue;
        public virtual object RawValue
        {
            get
            {
                if (_rawValue == null && DefaultValue != null) _rawValue = DefaultValue;
                return _rawValue;
            }
            set
            {
                _rawValue = value;
            }
        }

        public void SetObject(object value)
        {
            RawValue = value;
        }

        public T GetObject<T>()
        {
            if (RawValue is null) return default;
            return (T)RawValue;
        }

        public PropertyData(FName name)
        {
            Name = name;
        }

        public PropertyData()
        {

        }

        private static FString FallbackPropertyType = new FString(string.Empty);
        /// <summary>
        /// Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.
        /// </summary>
        public virtual bool ShouldBeRegistered { get { return true; } }
        /// <summary>
        /// Determines whether or not this particular property has custom serialization within a StructProperty.
        /// </summary>
        public virtual bool HasCustomStructSerialization { get { return false; } }
        /// <summary>
        /// The type of this property as an FString.
        /// </summary>
        public virtual FString PropertyType { get { return FallbackPropertyType; } }
        /// <summary>
        /// The default value of this property, used as a fallback when no value is defined. Null by default.
        /// </summary>
        public virtual object DefaultValue { get { return null; } }

        /// <summary>
        /// Reads out a property from a BinaryReader.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        /// <param name="includeHeader">Whether or not to also read the "header" of the property, which is data considered by the Unreal Engine to be data that is part of the PropertyData base class rather than any particular child class.</param>
        /// <param name="leng1">An estimate for the length of the data being read out.</param>
        /// <param name="leng2">A second estimate for the length of the data being read out.</param>
        /// <param name="serializationContext">The context in which this property is being read.</param>
        public virtual void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
        {

        }

        /// <summary>
        /// Resolves the ancestry of all child properties of this property.
        /// </summary>
        public virtual void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
        {
            Ancestry = ancestrySoFar;
        }

        /// <summary>
        /// Complete reading the property tag of this property.
        /// </summary>
        protected virtual void ReadEndPropertyTag(AssetBinaryReader reader)
        {
            if (reader.Asset.HasUnversionedProperties) return;

            if (reader.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                PropertyGuid = reader.ReadPropertyGuid();
            }
            else if (PropertyTagFlags.HasFlag(EPropertyTagFlags.HasPropertyGuid))
            {
                PropertyGuid = new Guid(reader.ReadBytes(16));
            }

            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_EXTENSION_AND_OVERRIDABLE_SERIALIZATION)
            {
                if (reader.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME || PropertyTagFlags.HasFlag(EPropertyTagFlags.HasPropertyExtensions))
                {
                    PropertyTagExtensions = (EPropertyTagExtension)reader.ReadByte();

                    if (PropertyTagExtensions.HasFlag(EPropertyTagExtension.OverridableInformation))
                    {
                        OverrideOperation = (EOverriddenPropertyOperation)reader.ReadByte();
                        bExperimentalOverridableLogic = reader.ReadBooleanInt();
                    }
                }
            }
        }

        /// <summary>
        /// Writes a property to a BinaryWriter.
        /// </summary>
        /// <param name="writer">The BinaryWriter to write from.</param>
        /// <param name="includeHeader">Whether or not to also write the "header" of the property, which is data considered by the Unreal Engine to be data that is part of the PropertyData base class rather than any particular child class.</param>
        /// <param name="serializationContext">The context in which this property is being written.</param>
        /// <returns>The length in bytes of the data that was written.</returns>
        public virtual int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
        {
            return 0;
        }

        /// <summary>
        /// Initialize this property when serialized as zero.
        /// </summary>
        /// <param name="reader">The BinaryReader to read from.</param>
        internal virtual void InitializeZero(AssetBinaryReader reader)
        {

        }

        /// <summary>
        /// Complete writing the property tag of this property.
        /// </summary>
        protected virtual void WriteEndPropertyTag(AssetBinaryWriter writer)
        {
            if (writer.Asset.HasUnversionedProperties) return;

            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
                writer.WritePropertyGuid(PropertyGuid);
            if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_EXTENSION_AND_OVERRIDABLE_SERIALIZATION)
            {
                if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME || PropertyTagFlags.HasFlag(EPropertyTagFlags.HasPropertyExtensions))
                {
                    writer.Write((byte)PropertyTagExtensions);

                    if (PropertyTagExtensions.HasFlag(EPropertyTagExtension.OverridableInformation))
                    {
                        writer.Write((byte)OverrideOperation);
                        writer.Write(bExperimentalOverridableLogic ? 1 : 0);
                    }
                }
            }
        }

        /// <summary>
        /// Does the body of this property entirely consist of null bytes? If so, the body can be skipped during serialization in unversioned properties.
        /// </summary>
        /// <param name="asset">The asset to test serialization within.</param>
        /// <returns>Whether or not the property can be serialized as zero.</returns>
        public virtual bool CanBeZero(UAsset asset)
        {
            MemoryStream testStrm = new MemoryStream(32); this.Write(new AssetBinaryWriter(testStrm, asset), false); byte[] testByteArray = testStrm.ToArray();
            foreach (byte entry in testByteArray)
            {
                if (entry != 0) return false;
            }
            return true;
        }

        /// <summary>
        /// Sets certain fields of the property based off of an array of strings.
        /// </summary>
        /// <param name="d">An array of strings to derive certain fields from.</param>
        /// <param name="asset">The asset that the property belongs to.</param>
        public virtual void FromString(string[] d, UAsset asset)
        {

        }

        /// <summary>
        /// Performs a deep clone of the current PropertyData instance.
        /// </summary>
        /// <returns>A deep copy of the current property.</returns>
        public object Clone()
        {
            var res = (PropertyData)MemberwiseClone();
            res.Name = (FName)this.Name.Clone();
            if (res.RawValue is ICloneable cloneableValue) res.RawValue = cloneableValue.Clone();

            HandleCloned(res);
            return res;
        }

        protected virtual void HandleCloned(PropertyData res)
        {
            // Child classes can implement this for custom cloning behavior
        }
    }

    public abstract class PropertyData<T> : PropertyData
    {
        /// <summary>
        /// The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.
        /// </summary>
        [JsonProperty]
        public T Value
        {
            get => GetObject<T>();
            set => SetObject(value);
        }

        public PropertyData(FName name) : base(name) { }

        public PropertyData() : base() { }
    }

    public interface IStruct<T>
    {
        abstract static T Read(AssetBinaryReader reader);
        abstract static T FromString(string[] d, UAsset asset);

        int Write(AssetBinaryWriter writer);
    }

    public abstract class BasePropertyData<T> : PropertyData<T> where T : IStruct<T>, new()
    {
        public BasePropertyData(FName name) : base(name) { }

        public BasePropertyData() : base() { }

        public override bool HasCustomStructSerialization => true;

        public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
        {
            if (includeHeader)
            {
                this.ReadEndPropertyTag(reader);
            }

            Value = T.Read(reader);
        }

        public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
        {

            if (includeHeader)
            {
                this.WriteEndPropertyTag(writer);
            }

            Value ??= new T();
            return Value.Write(writer);
        }

        public override string ToString()
        {
            return Value.ToString();
        }

        public override void FromString(string[] d, UAsset asset)
        {
            Value = T.FromString(d, asset);
        }
    }
}

```

`UAssetAPI/PropertyTypes/Objects/SetPropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a set.
/// </summary>
public class SetPropertyData : ArrayPropertyData
{
    public PropertyData[] ElementsToRemove = null;

    public SetPropertyData(FName name) : base(name)
    {
        Value = [];
        ElementsToRemove = [];
    }

    public SetPropertyData()
    {
        Value = [];
        ElementsToRemove = [];
    }

    private static readonly FString CurrentPropertyType = new FString("SetProperty");
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        ShouldSerializeStructsDifferently = false;

        if (includeHeader && !reader.Asset.HasUnversionedProperties)
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                if (PropertyTypeName is null) throw new FormatException("PropertyTypeName is required to read SetProperty with complete type names.");
                ArrayType = PropertyTypeName.GetParameter(0).GetName();
            }
            else
            {
                ArrayType = reader.ReadFName();
            }
            this.ReadEndPropertyTag(reader);
        }

        if (reader.Asset.Mappings != null && ArrayType == null && reader.Asset.Mappings.TryGetPropertyData(Name, Ancestry, reader.Asset, out UsmapArrayData strucDat1))
        {
            ArrayType = FName.DefineDummy(reader.Asset, strucDat1.InnerType.Type.ToString());
        }

        if (reader.Asset.HasUnversionedProperties && ArrayType == null)
        {
            throw new InvalidOperationException("Unable to determine array type for array " + Name.Value.Value + " in class " + Ancestry.Parent.Value.Value);
        }

        var removedItemsDummy = new ArrayPropertyData(FName.DefineDummy(reader.Asset, "ElementsToRemove"));
        removedItemsDummy.Ancestry.Initialize(Ancestry, Name);
        removedItemsDummy.ShouldSerializeStructsDifferently = false;
        removedItemsDummy.ArrayType = ArrayType;
        removedItemsDummy.PropertyTypeName = PropertyTypeName;
        removedItemsDummy.Read(reader, false, leng1, leng2);
        ElementsToRemove = removedItemsDummy.Value;

        base.Read(reader, false, leng1-4, leng2);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        ShouldSerializeStructsDifferently = false;

        if (Value.Length > 0) ArrayType = writer.Asset.HasUnversionedProperties ? FName.DefineDummy(writer.Asset, Value[0].PropertyType) : new FName(writer.Asset, Value[0].PropertyType);

        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                writer.Write(ArrayType);
            }
            this.WriteEndPropertyTag(writer);
        }

        var removedItemsDummy = new ArrayPropertyData(FName.DefineDummy(writer.Asset, "ElementsToRemove"));
        removedItemsDummy.ShouldSerializeStructsDifferently = false;
        removedItemsDummy.ArrayType = ArrayType;
        removedItemsDummy.Value = ElementsToRemove;

        int leng1 = removedItemsDummy.Write(writer, false);
        return leng1 + base.Write(writer, false);
    }

    protected override void HandleCloned(PropertyData res)
    {
        base.HandleCloned(res);
        SetPropertyData cloningProperty = (SetPropertyData)res;

        if (this.ElementsToRemove != null)
        {
            PropertyData[] newData = new PropertyData[this.ElementsToRemove.Length];
            for (int i = 0; i < this.Value.Length; i++)
            {
                newData[i] = (PropertyData)this.Value[i].Clone();
            }
            cloningProperty.ElementsToRemove = newData;
        }
        else
        {
            cloningProperty.ElementsToRemove = null;
        }
    }
}

```

`UAssetAPI/PropertyTypes/Objects/SoftObjectPropertyData.cs`:

```cs
using System;
using UAssetAPI.CustomVersions;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a reference variable to another object which may be null, and may become valid or invalid at any point. Near synonym for <see cref="SoftObjectPropertyData"/>.
/// </summary>
public class AssetObjectPropertyData : PropertyData<FString>
{
    public uint ID = 0;

    public AssetObjectPropertyData(FName name) : base(name) { }

    public AssetObjectPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("AssetObjectProperty");
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadFString();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return writer.Write(Value);
    }

    public override string ToString()
    {
        return "(" + Value + ", " + ID + ")";
    }

    public override void FromString(string[] d, UAsset asset)
    {
        //asset.AddNameReference(FString.FromString(d[0]));
        Value = FString.FromString(d[0]);
    }
}

public struct FTopLevelAssetPath
{
    /// <summary>
    /// Name of the package containing the asset e.g. /Path/To/Package
    /// If less than 5.1, this is null
    /// </summary>
    public FName PackageName;
    /// <summary>
    /// Name of the asset within the package e.g. 'AssetName'.
    /// If less than 5.1, this contains the full path instead
    /// </summary>
    public FName AssetName;

    public FTopLevelAssetPath(FName packageName, FName assetName)
    {
        PackageName = packageName;
        AssetName = assetName;
    }
}

/// <summary>
/// A reference variable to another object which may be null, and may become valid or invalid at any point.
/// </summary>
public struct FSoftObjectPath : IEquatable<FSoftObjectPath>, IStruct<FSoftObjectPath>
{
    /// <summary>
    /// Asset path, patch to a top level object in a package. This is /package/path.assetname/
    /// </summary>
    public FTopLevelAssetPath AssetPath;
    /// <summary>
    /// Optional FString for subobject within an asset. This is the sub path after the :
    /// </summary>
    public FString SubPathString;

    public FSoftObjectPath(FName packageName, FName assetName, FString subPathString)
    {
        AssetPath = new FTopLevelAssetPath(packageName, assetName);
        SubPathString = subPathString;
    }

    public FSoftObjectPath(FTopLevelAssetPath assetPath, FString subPathString)
    {
        AssetPath = assetPath;
        SubPathString = subPathString;
    }

    public FSoftObjectPath(AssetBinaryReader reader, bool allowIndex = true)
    {
        if (allowIndex && reader.Asset.SoftObjectPathList != null && reader.Asset.SoftObjectPathList.Count > 0)
        {
            // serialize as idx
            int idx = reader.ReadInt32();

            FSoftObjectPath target = reader.Asset.SoftObjectPathList[idx];
            this.AssetPath = target.AssetPath;
            this.SubPathString = target.SubPathString;
        }
        else
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.FSOFTOBJECTPATH_REMOVE_ASSET_PATH_FNAMES)
            {
                AssetPath = new FTopLevelAssetPath(reader.ReadFName(), reader.ReadFName());
            }
            else if (reader.Asset.ObjectVersion >= ObjectVersion.VER_UE4_ADDED_SOFT_OBJECT_PATH)
            {
                AssetPath = new FTopLevelAssetPath(null, reader.ReadFName());
            }
            else
            {
                AssetPath = new FTopLevelAssetPath(null, null);
            } 
            SubPathString = reader.Asset.GetCustomVersion<FFortniteMainBranchObjectVersion>() < FFortniteMainBranchObjectVersion.SoftObjectPathUtf8SubPaths
                ? reader.ReadFString()
                : reader.ReadUtf8String();
        }
    }

    public static FSoftObjectPath Read(AssetBinaryReader reader) => new FSoftObjectPath(reader);

    public int Write(AssetBinaryWriter writer, bool allowIndex = true)
    {
        if (allowIndex && writer.Asset.SoftObjectPathList != null && writer.Asset.SoftObjectPathList.Count > 0)
        {
            // serialize as idx
            int idx = -1;
            for (int i = 0; i < writer.Asset.SoftObjectPathList.Count; i++)
            {
                FSoftObjectPath testingEntry = writer.Asset.SoftObjectPathList[i];
                if (testingEntry == this)
                {
                    idx = i;
                    break;
                }
            }
            if (idx < 0) throw new FormatException("Failed to find AssetPath in SoftObjectPathList");

            writer.Write(idx);
            return sizeof(int);
        }

        if (writer.Asset.ObjectVersion < ObjectVersion.VER_UE4_ADDED_SOFT_OBJECT_PATH)
            return writer.Write(SubPathString);

        var offset = writer.BaseStream.Position;
        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.FSOFTOBJECTPATH_REMOVE_ASSET_PATH_FNAMES) writer.Write(AssetPath.PackageName);
        writer.Write(AssetPath.AssetName);

        if (writer.Asset.GetCustomVersion<FFortniteMainBranchObjectVersion>() < FFortniteMainBranchObjectVersion.SoftObjectPathUtf8SubPaths)
            writer.Write(SubPathString);
        else
            writer.WriteUtf8String(SubPathString);

        return (int)(writer.BaseStream.Position - offset);
    }

    public int Write(AssetBinaryWriter writer) => Write(writer, true);

    public static bool operator ==(FSoftObjectPath lhs, FSoftObjectPath rhs)
    {
        return lhs.Equals(rhs);
    }

    public static bool operator !=(FSoftObjectPath lhs, FSoftObjectPath rhs)
    {
        return !lhs.Equals(rhs);
    }

    public bool Equals(FSoftObjectPath other)
    {
        return AssetPath.PackageName == other.AssetPath.PackageName &&
               AssetPath.AssetName == other.AssetPath.AssetName &&
               SubPathString == other.SubPathString;
    }

    public override bool Equals(object obj)
    {
        return obj is FSoftObjectPath other && Equals(other);
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(AssetPath.PackageName, AssetPath.AssetName, SubPathString);
    }

    public override string ToString()
    {
        return $"({AssetPath.PackageName}, {AssetPath.AssetName}, {SubPathString})";
    }

    public static FSoftObjectPath FromString(string[] d, UAsset asset)
    {
        FName one = FName.FromString(asset, d[0]);
        FName two = FName.FromString(asset, d[1]);
        FString three = string.IsNullOrEmpty(d[2]) ? null : FString.FromString(d[2]);

        return new FSoftObjectPath(one, two, three);
    }
}

/// <summary>
/// Describes a reference variable to another object which may be null, and may become valid or invalid at any point. Near synonym for <see cref="AssetObjectPropertyData"/>.
/// </summary>
public class SoftObjectPropertyData : BasePropertyData<FSoftObjectPath>
{
    public SoftObjectPropertyData(FName name) : base(name) { }

    public SoftObjectPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SoftObjectProperty");

    public override bool HasCustomStructSerialization => false;
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Objects/StrPropertyData.cs`:

```cs
using System.Text;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes an <see cref="FString"/>.
/// </summary>
public class StrPropertyData : PropertyData<FString>
{
    public StrPropertyData(FName name) : base(name) { }

    public StrPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("StrProperty");
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadFString();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        int here = (int)writer.BaseStream.Position;
        writer.Write(Value);
        return (int)writer.BaseStream.Position - here;
    }

    public override string ToString()
    {
        return Value.ToString();
    }

    public override void FromString(string[] d, UAsset asset)
    {
        var encoding = Encoding.UTF8;
        if (d.Length >= 5) encoding = (d[4].Equals(Encoding.Unicode.HeaderName) ? Encoding.Unicode : Encoding.UTF8);
        Value = FString.FromString(d[0], encoding);
    }
}
```

`UAssetAPI/PropertyTypes/Objects/TextHistoryType.cs`:

```cs
namespace UAssetAPI.PropertyTypes.Objects;

public enum TextHistoryType
{
    None = -1,
    Base = 0,
    NamedFormat,
    OrderedFormat,
    ArgumentFormat,
    AsNumber,
    AsPercent,
    AsCurrency,
    AsDate,
    AsTime,
    AsDateTime,
    Transform,
    StringTableEntry,
    TextGenerator,

    RawText // Uncertain, Back 4 Blood specific serialization
}
```

`UAssetAPI/PropertyTypes/Objects/TextPropertyData.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using UAssetAPI.CustomVersions;
using UAssetAPI.UnrealTypes;
using UAssetAPI.UnrealTypes.EngineEnums;

namespace UAssetAPI.PropertyTypes.Objects;

[Flags]
public enum ETextFlag
{
    Transient = 1 << 0,
    CultureInvariant = 1 << 1,
    ConvertedProperty = 1 << 2,
    Immutable = 1 << 3,
    InitializedFromString = 1 << 4
}

public enum ETransformType : byte
{
    ToLower = 0,
    ToUpper,
}

public class FNumberFormattingOptions
{
    public bool AlwaysSign;
    public bool UseGrouping;
    public ERoundingMode RoundingMode;
    public int MinimumIntegralDigits;
    public int MaximumIntegralDigits;
    public int MinimumFractionalDigits;
    public int MaximumFractionalDigits;

    public FNumberFormattingOptions()
    {
        AlwaysSign = false;
        UseGrouping = true;
        RoundingMode = ERoundingMode.HalfToEven;
        MinimumIntegralDigits = 1;
        MaximumIntegralDigits = 316;
        MinimumFractionalDigits = 0;
        MaximumFractionalDigits = 3;
    }

    public FNumberFormattingOptions(AssetBinaryReader reader)
    {
        if (reader.Asset.GetCustomVersion<FEditorObjectVersion>() >= FEditorObjectVersion.AddedAlwaysSignNumberFormattingOption)
            AlwaysSign = reader.ReadBooleanInt();
        UseGrouping = reader.ReadBooleanInt();
        RoundingMode = (ERoundingMode)reader.ReadByte();
        MinimumIntegralDigits = reader.ReadInt32();
        MaximumIntegralDigits = reader.ReadInt32();
        MinimumFractionalDigits = reader.ReadInt32();
        MaximumFractionalDigits = reader.ReadInt32();
    }

    public void Write(AssetBinaryWriter writer)
    {
        if (writer.Asset.GetCustomVersion<FEditorObjectVersion>() >= FEditorObjectVersion.AddedAlwaysSignNumberFormattingOption)
            writer.Write(AlwaysSign ? 1 : 0);
        writer.Write(UseGrouping ? 1 : 0);
        writer.Write((byte)RoundingMode);
        writer.Write(MinimumIntegralDigits);
        writer.Write(MaximumIntegralDigits);
        writer.Write(MinimumFractionalDigits);
        writer.Write(MaximumFractionalDigits);
    }
}


public class FFormatArgumentValue
{
    public EFormatArgumentType Type;
    public object Value;

    public FFormatArgumentValue() { }

    public FFormatArgumentValue(EFormatArgumentType type, object value)
    {
        Type = type;
        Value = value;
    }

    public FFormatArgumentValue(AssetBinaryReader reader, bool isArgumentData = false)
    {
        Type = (EFormatArgumentType)reader.ReadByte();
        switch (Type)
        {
            case EFormatArgumentType.Int:
                Value = isArgumentData && reader.Asset.GetCustomVersion<FUE5ReleaseStreamObjectVersion>() < FUE5ReleaseStreamObjectVersion.TextFormatArgumentData64bitSupport ? reader.ReadInt32() : reader.ReadInt64();
                break;
            case EFormatArgumentType.UInt:
                Value = reader.ReadUInt64();
                break;
            case EFormatArgumentType.Double:
                Value = reader.ReadDouble();
                break;
            case EFormatArgumentType.Float:
                Value = reader.ReadSingle();
                break;
            case EFormatArgumentType.Text:
                var val = new TextPropertyData(FName.DefineDummy(reader.Asset, "Value"));
                val.Read(reader, false, 1, 0, PropertySerializationContext.Normal);
                Value = val;
                break;
            default:
                throw new NotImplementedException("EFormatArgumentType type " + Type.ToString() + " is not implemented for reading");
        }
    }

    public int Write(AssetBinaryWriter writer, bool isArgumentData = false)
    {
        int sz = 0;
        writer.Write((byte)Type); sz += sizeof(byte);
        switch (Type)
        {
            case EFormatArgumentType.Int:
                if (isArgumentData && writer.Asset.GetCustomVersion<FUE5ReleaseStreamObjectVersion>() < FUE5ReleaseStreamObjectVersion.TextFormatArgumentData64bitSupport)
                {
                    writer.Write((int)(long)Value);
                    sz += sizeof(int);
                }
                else
                {
                    writer.Write((long)Value);
                    sz += sizeof(long);
                }
                break;
            case EFormatArgumentType.UInt:
                writer.Write((ulong)Value);
                sz += sizeof(ulong);
                break;
            case EFormatArgumentType.Double:
                writer.Write((double)Value);
                sz += sizeof(double);
                break;
            case EFormatArgumentType.Float:
                writer.Write((float)Value);
                sz += sizeof(float);
                break;
            case EFormatArgumentType.Text:
                int here = (int)writer.BaseStream.Position;
                var val = (TextPropertyData)Value;
                val.Write(writer, false);
                sz += (int)writer.BaseStream.Position - here;
                break;
            default:
                throw new NotImplementedException("EFormatArgumentType type " + Type.ToString() + " is not implemented for writing");
        }

        return sz;
    }
}

public class FFormatArgumentData
{
    public FString ArgumentName;
    public FFormatArgumentValue ArgumentValue;

    public FFormatArgumentData() { }

    public FFormatArgumentData(FString name, FFormatArgumentValue value)
    {
        ArgumentName = name;
        ArgumentValue = value;
    }

    public FFormatArgumentData(AssetBinaryReader reader)
    {
        Read(reader);
    }

    public void Read(AssetBinaryReader reader)
    {
        ArgumentName = reader.ReadFString();
        ArgumentValue = new FFormatArgumentValue(reader, true);
    }

    public int Write(AssetBinaryWriter writer)
    {
        int sz = writer.Write(ArgumentName);
        sz += ArgumentValue.Write(writer, true);
        return sz;
    }
}

/// <summary>
/// Describes an FText.
/// </summary>
public class TextPropertyData : PropertyData<FString>
{
    /// <summary>Flags with various information on what sort of FText this is</summary>
    [JsonProperty]
    public ETextFlag Flags = 0;
    /// <summary>The HistoryType of this FText.</summary>
    [JsonProperty]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextHistoryType HistoryType = TextHistoryType.Base;
    /// <summary>The string table ID being referenced, if applicable</summary>
    [JsonProperty]
    public FName TableId = null;
    /// <summary>A namespace to use when parsing texts that use LOCTEXT</summary>
    [JsonProperty]
    public FString Namespace = null;
    /// <summary>The source string for this FText. In the Unreal Engine, this is also known as SourceString.</summary>
    [JsonProperty]
    public FString CultureInvariantString = null;

    // OrderedFormat
    [JsonProperty]
    public TextPropertyData SourceFmt;
    [JsonProperty]
    public FFormatArgumentValue[] Arguments;
    //ArgumentFormat
    [JsonProperty]
    public FFormatArgumentData[] ArgumentsData;
    //Transform
    [JsonProperty]
    public ETransformType TransformType;
    //AsNumber
    [JsonProperty]
    FFormatArgumentValue SourceValue;
    [JsonProperty]
    FNumberFormattingOptions FormatOptions;
    [JsonProperty]
    FString TargetCulture;

    public bool ShouldSerializeTableId()
    {
        return HistoryType == TextHistoryType.StringTableEntry;
    }

    public TextPropertyData(FName name) : base(name) { }

    public TextPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("TextProperty");
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        if (reader.Asset.ObjectVersion < ObjectVersion.VER_UE4_FTEXT_HISTORY)
        {
            CultureInvariantString = reader.ReadFString();
            if (reader.Asset.ObjectVersion >= ObjectVersion.VER_UE4_ADDED_NAMESPACE_AND_KEY_DATA_TO_FTEXT)
            {
                Namespace = reader.ReadFString();
                Value = reader.ReadFString();
            }
            else
            {
                Namespace = null;
                Value = reader.ReadFString();
            }
        }

        Flags = (ETextFlag)reader.ReadUInt32();

        if (reader.Asset.ObjectVersion >= ObjectVersion.VER_UE4_FTEXT_HISTORY)
        {
            HistoryType = (TextHistoryType)reader.ReadSByte();

            switch (HistoryType)
            {
                case TextHistoryType.None:
                    Value = null;
                    if (reader.Asset.GetCustomVersion<FEditorObjectVersion>() >= FEditorObjectVersion.CultureInvariantTextSerializationKeyStability)
                    {
                        bool bHasCultureInvariantString = reader.ReadInt32() == 1;
                        if (bHasCultureInvariantString)
                        {
                            CultureInvariantString = reader.ReadFString();
                        }
                    }
                    break;
                case TextHistoryType.Base:
                    Namespace = reader.ReadFString();
                    Value = reader.ReadFString(); // Key
                    CultureInvariantString = reader.ReadFString(); // SourceString
                    break;
                case TextHistoryType.StringTableEntry:
                    TableId = reader.ReadFName();
                    Value = reader.ReadFString();
                    break;
                case TextHistoryType.RawText:
                    Value = reader.ReadFString();
                    break;
                case TextHistoryType.OrderedFormat:
                    SourceFmt = new TextPropertyData(FName.DefineDummy(reader.Asset, "SourceFmt"));
                    SourceFmt.Read(reader, false, 1, 0, serializationContext);
                    int ArgumentsSize = reader.ReadInt32();
                    Arguments = new FFormatArgumentValue[ArgumentsSize];
                    for (int i = 0; i < ArgumentsSize; i++)
                    {
                        Arguments[i] = new FFormatArgumentValue(reader);
                    }
                    break;
                case TextHistoryType.ArgumentFormat:
                    SourceFmt = new TextPropertyData(FName.DefineDummy(reader.Asset, "SourceFmt"));
                    SourceFmt.Read(reader, false, 1, 0, serializationContext);
                    ArgumentsSize = reader.ReadInt32();
                    ArgumentsData = new FFormatArgumentData[ArgumentsSize];
                    for (int i = 0; i < ArgumentsSize; i++)
                    {
                        ArgumentsData[i] = new FFormatArgumentData(reader);
                    }
                    break;
                case TextHistoryType.Transform:
                    SourceFmt = new TextPropertyData(FName.DefineDummy(reader.Asset, "SourceFmt"));
                    SourceFmt.Read(reader, false, 1, 0, serializationContext);
                    TransformType = (ETransformType)reader.ReadByte();
                    break;
                case TextHistoryType.AsNumber:
                    SourceValue = new FFormatArgumentValue(reader);
                    if (reader.ReadBooleanInt())
                    {
                        FormatOptions = new FNumberFormattingOptions(reader);
                    }
                    TargetCulture = reader.ReadFString();
                    break;
                default:
                    throw new NotImplementedException("Unimplemented reader for " + HistoryType.ToString() + " @ " + reader.BaseStream.Position);
            }
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        var here = writer.BaseStream.Position;

        if (writer.Asset.ObjectVersion < ObjectVersion.VER_UE4_FTEXT_HISTORY)
        {
            writer.Write(CultureInvariantString);
            if (writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_ADDED_NAMESPACE_AND_KEY_DATA_TO_FTEXT)
            {
                writer.Write(Namespace);
                writer.Write(Value);
            }
            else
            {
                writer.Write(Value);
            }
        }

        writer.Write((uint)Flags);

        if (writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_FTEXT_HISTORY)
        {
            writer.Write((sbyte)HistoryType);

            switch (HistoryType)
            {
                case TextHistoryType.None:
                    if (writer.Asset.GetCustomVersion<FEditorObjectVersion>() >= FEditorObjectVersion.CultureInvariantTextSerializationKeyStability)
                    {
                        if (CultureInvariantString == null || string.IsNullOrEmpty(CultureInvariantString.Value))
                        {
                            writer.Write(0);
                        }
                        else
                        {
                            writer.Write(1);
                            writer.Write(CultureInvariantString);
                        }
                    }
                    break;
                case TextHistoryType.Base:
                    writer.Write(Namespace);
                    writer.Write(Value);
                    writer.Write(CultureInvariantString);
                    break;
                case TextHistoryType.StringTableEntry:
                    writer.Write(TableId);
                    writer.Write(Value);
                    break;
                case TextHistoryType.RawText:
                    writer.Write(Value);
                    break;
                case TextHistoryType.OrderedFormat:
                    SourceFmt.Write(writer, false, serializationContext);
                    writer.Write(Arguments.Length);
                    for (int i = 0; i < Arguments.Length; i++)
                    {
                        Arguments[i].Write(writer);
                    }
                    break;
                case TextHistoryType.ArgumentFormat:
                    SourceFmt.Write(writer, false, serializationContext);
                    writer.Write(ArgumentsData.Length);
                    for (int i = 0; i < ArgumentsData.Length; i++)
                    {
                        ArgumentsData[i].Write(writer);
                    }
                    break;
                case TextHistoryType.Transform:
                    SourceFmt.Write(writer, false, serializationContext);
                    writer.Write((byte)TransformType);
                    break;
                case TextHistoryType.AsNumber:
                    SourceValue.Write(writer);
                    if (FormatOptions != null)
                    {
                        writer.Write(1);
                        FormatOptions.Write(writer);
                    }
                    else
                    {
                        writer.Write(0);
                    }
                    writer.Write(TargetCulture);
                    break;
                default:
                    throw new NotImplementedException("Unimplemented writer for " + HistoryType.ToString());
            }
        }

        return (int)(writer.BaseStream.Position - here);
    }

    public override string ToString()
    {
        if (Value == null) return "null";

        switch (HistoryType)
        {
            case TextHistoryType.None:
                return "None, " + CultureInvariantString;
            case TextHistoryType.Base:
                return "Base, " + Namespace + ", " + Value + ", " + CultureInvariantString;
            case TextHistoryType.StringTableEntry:
                return "StringTableEntry, " + TableId + ", " + Value;
            default:
                throw new NotImplementedException("Unimplemented display for " + HistoryType.ToString());
        }
    }

    public override void FromString(string[] d, UAsset asset)
    {
        throw new NotImplementedException("TextPropertyData.FromString is currently unimplemented");
    }

    protected override void HandleCloned(PropertyData res)
    {
        TextPropertyData cloningProperty = (TextPropertyData)res;

        cloningProperty.TableId = (FName)TableId?.Clone();
        cloningProperty.Namespace = (FString)Namespace?.Clone();
        cloningProperty.CultureInvariantString = (FString)CultureInvariantString?.Clone();
    }
}
```

`UAssetAPI/PropertyTypes/Objects/UInt16PropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a 16-bit unsigned integer variable (<see cref="ushort"/>).
/// </summary>
public class UInt16PropertyData : PropertyData<ushort>
{
    public UInt16PropertyData(FName name) : base(name) { }

    public UInt16PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("UInt16Property");
    public override FString PropertyType => CurrentPropertyType;
    public override object DefaultValue => (ushort)0;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = (reader.Asset.HasUnversionedProperties && serializationContext != PropertySerializationContext.Normal) ? (ushort)reader.ReadInt64() : reader.ReadUInt16();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        if (writer.Asset.HasUnversionedProperties && serializationContext != PropertySerializationContext.Normal)
        {
            writer.Write((long)Value);
            return sizeof(long);
        }
        writer.Write(Value);
        return sizeof(ushort);
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (ushort.TryParse(d[0], out ushort res)) Value = res;
    }
}
```

`UAssetAPI/PropertyTypes/Objects/UInt32PropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a 32-bit unsigned integer variable (<see cref="uint"/>).
/// </summary>
public class UInt32PropertyData : PropertyData<uint>
{
    public UInt32PropertyData(FName name) : base(name) { }

    public UInt32PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("UInt32Property");
    public override FString PropertyType => CurrentPropertyType;
    public override object DefaultValue => (uint)0;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadUInt32();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(uint);
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (uint.TryParse(d[0], out uint res)) Value = res;
    }
}
```

`UAssetAPI/PropertyTypes/Objects/UInt64PropertyData.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a 64-bit unsigned integer variable (<see cref="ulong"/>).
/// </summary>
public class UInt64PropertyData : PropertyData<ulong>
{
    public UInt64PropertyData(FName name) : base(name) { }

    public UInt64PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("UInt64Property");
    public override FString PropertyType { get { return CurrentPropertyType; } }
    public override object DefaultValue { get { return (ulong)0; } }

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadUInt64();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(ulong);
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = 0;
        if (ulong.TryParse(d[0], out ulong res)) Value = res;
    }
}
```

`UAssetAPI/PropertyTypes/Objects/UnknownPropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects;

/// <summary>
/// Describes a property which UAssetAPI has no specific serialization for, and is instead represented as an array of bytes as a fallback.
/// </summary>
public class UnknownPropertyData : PropertyData<byte[]>
{
    [JsonProperty]
    public FString SerializingPropertyType = CurrentPropertyType;

    public UnknownPropertyData(FName name) : base(name) { }

    public UnknownPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("UnknownProperty");
    public override FString PropertyType { get { return CurrentPropertyType; } }

    public void SetSerializingPropertyType(FString newType)
    {
        SerializingPropertyType = newType;
    }

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadBytes((int)leng1);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return Value.Length;
    }

    public override string ToString()
    {
        return Convert.ToString(Value);
    }

    protected override void HandleCloned(PropertyData res)
    {
        UnknownPropertyData cloningProperty = (UnknownPropertyData)res;

        cloningProperty.SerializingPropertyType = (FString)SerializingPropertyType?.Clone();
    }
}

```

`UAssetAPI/PropertyTypes/Objects/WeakObjectPropertyData.cs`:

```cs
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Objects
{
    public class WeakObjectPropertyData : ObjectPropertyData
    {
        public WeakObjectPropertyData(FName name) : base(name)
        {

        }

        public WeakObjectPropertyData()
        {

        }

        private static readonly FString CurrentPropertyType = new FString("WeakObjectProperty");
        public override FString PropertyType { get { return CurrentPropertyType; } }
        public override object DefaultValue { get { return FPackageIndex.FromRawIndex(0); } }
    }
}
```

`UAssetAPI/PropertyTypes/Structs/ClothLODDataPropertyData.cs`:

```cs
using UAssetAPI.UnrealTypes;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A structure for holding mesh-to-mesh triangle influences to skin one mesh to another (similar to a wrap deformer)
/// </summary>
public class FMeshToMeshVertData
{
    /// <summary>
    /// Barycentric coords and distance along normal for the position of the final vert
    /// </summary>
    public Vector4fPropertyData PositionBaryCoordsAndDist;

    /// <summary>
    /// Barycentric coords and distance along normal for the location of the unit normal endpoint.
    /// Actual normal = ResolvedNormalPosition - ResolvedPosition
    /// </summary>
    public Vector4fPropertyData NormalBaryCoordsAndDist;

    /// <summary>
    /// Barycentric coords and distance along normal for the location of the unit Tangent endpoint.
    /// Actual normal = ResolvedNormalPosition - ResolvedPosition
    /// </summary>
    public Vector4fPropertyData TangentBaryCoordsAndDist;

    /// <summary>
    /// Contains the 3 indices for verts in the source mesh forming a triangle, the last element
    /// is a flag to decide how the skinning works, 0xffff uses no simulation, and just normal
    /// skinning, anything else uses the source mesh and the above skin data to get the final position
    /// </summary>
    public ushort[] SourceMeshVertIndices;

    /// <summary>
    /// For weighted averaging of multiple triangle influences
    /// </summary>
    public float Weight = 0.0f;

    /// <summary>
    /// Dummy for alignment
    /// </summary>
    public uint Padding;

    public void Read(AssetBinaryReader reader)
    {
        PositionBaryCoordsAndDist = new Vector4fPropertyData(FName.DefineDummy(reader.Asset, "PositionBaryCoordsAndDist"));
        PositionBaryCoordsAndDist.Offset = reader.BaseStream.Position;
        PositionBaryCoordsAndDist.Read(reader, false, 0);

        NormalBaryCoordsAndDist = new Vector4fPropertyData(FName.DefineDummy(reader.Asset, "NormalBaryCoordsAndDist"));
        NormalBaryCoordsAndDist.Offset = reader.BaseStream.Position;
        NormalBaryCoordsAndDist.Read(reader, false, 0);

        TangentBaryCoordsAndDist = new Vector4fPropertyData(FName.DefineDummy(reader.Asset, "TangentBaryCoordsAndDist"));
        TangentBaryCoordsAndDist.Offset = reader.BaseStream.Position;
        TangentBaryCoordsAndDist.Read(reader, false, 0);

        SourceMeshVertIndices = new ushort[4];
        for (int i = 0; i < 4; i++)
        {
            SourceMeshVertIndices[i] = reader.ReadUInt16();
        }

        Weight = reader.ReadSingle();

        Padding = reader.ReadUInt32();
    }

    public int Write(AssetBinaryWriter writer)
    {
        int res = 0;
        res += PositionBaryCoordsAndDist.Write(writer, false);
        res += NormalBaryCoordsAndDist.Write(writer, false);
        res += TangentBaryCoordsAndDist.Write(writer, false);

        for (int i = 0; i < 4; i++)
        {
            writer.Write(SourceMeshVertIndices.Length > i ? SourceMeshVertIndices[i] : (ushort)0); res += sizeof(ushort);
        }

        writer.Write(Weight); res += sizeof(float);
        writer.Write(Padding); res += sizeof(uint);

        return res;
    }

    public FMeshToMeshVertData(AssetBinaryReader reader)
    {
        Read(reader);
    }

    public FMeshToMeshVertData(Vector4fPropertyData positionBaryCoordsAndDist, Vector4fPropertyData normalBaryCoordsAndDist, Vector4fPropertyData tangentBaryCoordsAndDist, ushort[] sourceMeshVertIndices, float weight, uint padding)
    {
        PositionBaryCoordsAndDist = positionBaryCoordsAndDist;
        NormalBaryCoordsAndDist = normalBaryCoordsAndDist;
        TangentBaryCoordsAndDist = tangentBaryCoordsAndDist;
        SourceMeshVertIndices = sourceMeshVertIndices;
        Weight = weight;
        Padding = padding;
    }

    public FMeshToMeshVertData() { }
}

/// <summary>
/// Common Cloth LOD representation for all clothing assets.
/// </summary>
public class ClothLODDataPropertyData : StructPropertyData
{
    /// <summary>
    /// Skinning data for transitioning from a higher detail LOD to this one
    /// </summary>
    public FMeshToMeshVertData[] TransitionUpSkinData;

    /// <summary>
    /// Skinning data for transitioning from a lower detail LOD to this one
    /// </summary>
    public FMeshToMeshVertData[] TransitionDownSkinData;

    public ClothLODDataPropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public ClothLODDataPropertyData(FName name) : base(name) { }
    public ClothLODDataPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ClothLODData");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        StructType = FName.DefineDummy(reader.Asset, PropertyType);
        base.Read(reader, includeHeader, 1, leng2, PropertySerializationContext.StructFallback);

        int sizeUpData = reader.ReadInt32();
        TransitionUpSkinData = new FMeshToMeshVertData[sizeUpData];
        for (int i = 0; i < sizeUpData; i++)
        {
            TransitionUpSkinData[i] = new FMeshToMeshVertData(reader);
        }

        int sizeDownData = reader.ReadInt32();
        TransitionDownSkinData = new FMeshToMeshVertData[sizeDownData];
        for (int i = 0; i < sizeDownData; i++)
        {
            TransitionDownSkinData[i] = new FMeshToMeshVertData(reader);
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        StructType = FName.DefineDummy(writer.Asset, PropertyType);
        int res = base.Write(writer, includeHeader, PropertySerializationContext.StructFallback);

        if (TransitionUpSkinData == null) TransitionUpSkinData = [];
        writer.Write(TransitionUpSkinData.Length); res += sizeof(int);
        for (int i = 0; i < TransitionUpSkinData.Length; i++)
        {
            res += TransitionUpSkinData[i].Write(writer);
        }

        if (TransitionDownSkinData == null) TransitionDownSkinData = [];
        writer.Write(TransitionDownSkinData.Length); res += sizeof(int);
        for (int i = 0; i < TransitionDownSkinData.Length; i++)
        {
            res += TransitionDownSkinData[i].Write(writer);
        }

        return res;
    }

    public override string ToString()
    {
        return base.ToString();
    }

    public override void FromString(string[] d, UAsset asset)
    {
        base.FromString(d, asset);
    }
}

public class ClothLODDataCommonPropertyData : ClothLODDataPropertyData
{
    public ClothLODDataCommonPropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public ClothLODDataCommonPropertyData(FName name) : base(name) { }
    public ClothLODDataCommonPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ClothLODDataCommon");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/ClothTetherDataPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Long range attachment tether pathfinding based on Dijkstra's algorithm.
/// </summary>
public class ClothTetherDataPropertyData : StructPropertyData
{
    public (int, int, float)[][] Tethers;

    public ClothTetherDataPropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public ClothTetherDataPropertyData(FName name) : base(name) { }
    public ClothTetherDataPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ClothTetherData");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
    

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        StructType = FName.DefineDummy(reader.Asset, CurrentPropertyType);
        base.Read(reader, false, 1, 0, PropertySerializationContext.StructFallback);

        int numElements = reader.ReadInt32();
        Tethers = new (int, int, float)[numElements][];
        for (int i = 0; i < numElements; i++)
        {
            int numInnerElements = reader.ReadInt32();
            Tethers[i] = new (int, int, float)[numInnerElements];
            for (int j = 0; j < numInnerElements; j++)
            {
                Tethers[i][j] = (reader.ReadInt32(), reader.ReadInt32(), reader.ReadSingle());
            }
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        StructType = FName.DefineDummy(writer.Asset, CurrentPropertyType);
        int totalSize = base.Write(writer, includeHeader, PropertySerializationContext.StructFallback);

        if (Tethers == null) Tethers = [];
        writer.Write(Tethers.Length);
        totalSize += sizeof(int);
        for (int i = 0; i < Tethers.Length; i++)
        {
            writer.Write(Tethers[i].Length);
            totalSize += sizeof(int);
            for (int j = 0; j < Tethers[i].Length; j++)
            {
                writer.Write(Tethers[i][j].Item1);
                writer.Write(Tethers[i][j].Item2);
                writer.Write(Tethers[i][j].Item3);
                totalSize += sizeof(int) * 2 + sizeof(float);
            }
        }

        return totalSize;
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Core/ColorPropertyData.cs`:

```cs
using System.Drawing;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Describes a color with 8 bits of precision per channel.
/// </summary>
public class ColorPropertyData : PropertyData<Color> // R, G, B, A
{
    public ColorPropertyData(FName name) : base(name) { }

    public ColorPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Color");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = Color.FromArgb(reader.ReadInt32());
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.ToArgb());
        return sizeof(int);
    }

    public override string ToString()
    {
        return Value.ToString();
    }

    public override void FromString(string[] d, UAsset asset)
    {
        if (!int.TryParse(d[0], out int colorR)) return;
        if (!int.TryParse(d[1], out int colorG)) return;
        if (!int.TryParse(d[2], out int colorB)) return;
        if (!int.TryParse(d[3], out int colorA)) return;
        Value = Color.FromArgb(colorA, colorR, colorG, colorB);
    }

    protected override void HandleCloned(PropertyData res)
    {
        ColorPropertyData cloningProperty = (ColorPropertyData)res;
        cloningProperty.Value = Color.FromArgb(this.Value.ToArgb());
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Core/DateTimePropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Implements a date and time.
///
/// Values of this type represent dates and times between Midnight 00:00:00, January 1, 0001 and
/// Midnight 23:59:59.9999999, December 31, 9999 in the Gregorian calendar. Internally, the time
/// values are stored in ticks of 0.1 microseconds (= 100 nanoseconds) since January 1, 0001.
///
/// The companion class <see cref="TimespanPropertyData"/> (<see cref="TimeSpan"/>) is provided for
/// enabling date and time based arithmetic, such as calculating the difference between two dates
/// or adding a certain amount of time to a given date.
/// </summary>
public class DateTimePropertyData : PropertyData<DateTime>
{
    public DateTimePropertyData(FName name) : base(name) { }

    public DateTimePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("DateTime");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new DateTime(reader.ReadInt64()); // number of ticks since January 1, 0001
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.Ticks);
        return sizeof(long);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = DateTime.Parse(d[0]);
    }

    public override string ToString()
    {
        return Value.ToString();
    }

    protected override void HandleCloned(PropertyData res)
    {
        DateTimePropertyData cloningProperty = (DateTimePropertyData)res;
        cloningProperty.Value = new DateTime(this.Value.Ticks);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Core/GuidPropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Describes a 128-bit <see cref="Guid"/>.
/// </summary>
public class GuidPropertyData : PropertyData<Guid>
{
    public GuidPropertyData(FName name) : base(name) { }

    public GuidPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Guid");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new Guid(reader.ReadBytes(16));
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.ToByteArray());
        return 16;
    }

    public override string ToString()
    {
        return Value.ConvertToString();
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = d[0].ConvertToGUID();
    }

    protected override void HandleCloned(PropertyData res)
    {
        GuidPropertyData cloningProperty = (GuidPropertyData)res;

        cloningProperty.Value = new Guid(Value.ToByteArray());
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Core/TimespanPropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Implements a time span.
/// A time span is the difference between two dates and times. For example, the time span between
/// 12:00:00 January 1, 2000 and 18:00:00 January 2, 2000 is 30.0 hours. Time spans are measured in
/// positive or negative ticks depending on whether the difference is measured forward or backward.
/// Each tick has a resolution of 0.1 microseconds (= 100 nanoseconds).
/// 
/// In conjunction with the companion class <see cref="DateTimePropertyData"/> (<see cref="DateTime"/>),
/// time spans can be used to perform date and time based arithmetic, such as calculating the
/// difference between two dates or adding a certain amount of time to a given date.
/// </summary>
public class TimespanPropertyData : PropertyData<TimeSpan>
{
    public TimespanPropertyData(FName name) : base(name) { }

    public TimespanPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Timespan");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new TimeSpan(reader.ReadInt64()); // number of ticks
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.Ticks);
        return sizeof(long);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = TimeSpan.Parse(d[0]);
    }

    public override string ToString()
    {
        return Value.ToString();
    }

    protected override void HandleCloned(PropertyData res)
    {
        TimespanPropertyData cloningProperty = (TimespanPropertyData)res;
        cloningProperty.Value = new TimeSpan(this.Value.Ticks);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/FontCharacterPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class FontCharacterPropertyData : PropertyData<FFontCharacter>
{
    public FontCharacterPropertyData(FName name) : base(name) { }

    public FontCharacterPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("FontCharacter");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FFontCharacter(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader) {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer);
    }
}

```

`UAssetAPI/PropertyTypes/Structs/Engine/KeyHandleMapPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class KeyHandleMapPropertyData : PropertyData
{
    public KeyHandleMapPropertyData(FName name) : base(name) { }

    public KeyHandleMapPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("KeyHandleMap");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        // map is only saved to the transaction buffer, otherwise completely empty
        return;
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            this.WriteEndPropertyTag(writer);
        }

        // map is only saved to the transaction buffer, otherwise completely empty
        return 0;
    }

    public override void FromString(string[] d, UAsset asset)
    {

    }
}

```

`UAssetAPI/PropertyTypes/Structs/Engine/MaterialInputProperties.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;
using UAssetAPI.CustomVersions;

namespace UAssetAPI.PropertyTypes.Structs;

public abstract class MaterialInputPropertyData<T> : PropertyData<T>
{
    public FPackageIndex Expression;
    public int OutputIndex;
    public FName InputName;
    public FString InputNameOld;
    public int Mask;
    public int MaskR;
    public int MaskG;
    public int MaskB;
    public int MaskA;
    public FName ExpressionName;

    public MaterialInputPropertyData() { }

    public MaterialInputPropertyData(FName name) : base(name) { }

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        //if (reader.Asset.GetCustomVersion<FCoreObjectVersion>() < FCoreObjectVersion.MaterialInputNativeSerialize)
        //{
        //    StructType = FName.DefineDummy(reader.Asset, PropertyType);
        //    base.Read(reader, false, 1, 0, PropertySerializationContext.StructFallback);
        //    return;
        //}

        if ((reader.Asset.GetEngineVersion() <= EngineVersion.VER_UE5_1 && !reader.Asset.IsFilterEditorOnly) || reader.Asset.GetEngineVersion() >= EngineVersion.VER_UE5_1)
            Expression = reader.XFERPTR();
        OutputIndex = reader.ReadInt32();
        InputName = reader.Asset.GetCustomVersion<FFrameworkObjectVersion>() >= FFrameworkObjectVersion.PinsStoreFName ? reader.ReadFName() : null;
        InputNameOld = reader.Asset.GetCustomVersion<FFrameworkObjectVersion>() >= FFrameworkObjectVersion.PinsStoreFName ? null : reader.ReadFString();
        Mask = reader.ReadInt32();
        MaskR = reader.ReadInt32();
        MaskG = reader.ReadInt32();
        MaskB = reader.ReadInt32();
        MaskA = reader.ReadInt32();
        ExpressionName = reader.Asset.GetEngineVersion() <= EngineVersion.VER_UE5_1 && reader.Asset.IsFilterEditorOnly ? reader.ReadFName() : null;
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return WriteExpressionInput(writer, false);
    }

    protected int WriteExpressionInput(AssetBinaryWriter writer, bool includeHeader)
    {
        int totalSize = 0;
        if (writer.Asset.GetCustomVersion<FCoreObjectVersion>() >= FCoreObjectVersion.MaterialInputNativeSerialize)
        {
            if ((writer.Asset.GetEngineVersion() <= EngineVersion.VER_UE5_1 && !writer.Asset.IsFilterEditorOnly) || writer.Asset.GetEngineVersion() >= EngineVersion.VER_UE5_1)
            {
                writer.XFERPTR(Expression);
                totalSize += sizeof(int);
            }

            writer.Write(OutputIndex); totalSize += sizeof(int);
            if (writer.Asset.GetCustomVersion<FFrameworkObjectVersion>() >= FFrameworkObjectVersion.PinsStoreFName)
            {
                writer.Write(InputName); totalSize += sizeof(int) * 2;
            }
            else
            {
                totalSize += writer.Write(InputNameOld);
            }
            writer.Write(Mask);
            writer.Write(MaskR);
            writer.Write(MaskG);
            writer.Write(MaskB);
            writer.Write(MaskA);
            totalSize += sizeof(int) * 5;
            if (writer.Asset.GetEngineVersion() <= EngineVersion.VER_UE5_1 && writer.Asset.IsFilterEditorOnly)
            {
                writer.Write(ExpressionName);
                totalSize += sizeof(int) * 2;
            }
            
        }
        return totalSize;
    }

    protected override void HandleCloned(PropertyData res)
    {
        MaterialInputPropertyData<T> cloningProperty = (MaterialInputPropertyData<T>)res;
        cloningProperty.InputName = (FName)this.InputName?.Clone();
        cloningProperty.InputNameOld = (FString)this.InputNameOld?.Clone();
        cloningProperty.ExpressionName = (FName)this.ExpressionName?.Clone();
    }
}

public class ExpressionInputPropertyData : MaterialInputPropertyData<int>
{
    public ExpressionInputPropertyData(FName name) : base(name) { }

    public ExpressionInputPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ExpressionInput");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}

public class MaterialAttributesInputPropertyData : MaterialInputPropertyData<int>
{
    public MaterialAttributesInputPropertyData(FName name) : base(name) { }

    public MaterialAttributesInputPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MaterialAttributesInput");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}

public class ColorMaterialInputPropertyData : MaterialInputPropertyData<ColorPropertyData>
{
    public ColorMaterialInputPropertyData(FName name) : base(name) { }

    public ColorMaterialInputPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ColorMaterialInput");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        base.Read(reader, includeHeader, leng1, leng2, serializationContext);

        reader.ReadInt32(); // bUseConstantValue; always false
        Value = new ColorPropertyData(Name);
        Value.Ancestry.Initialize(Ancestry, Name);
        Value.Read(reader, false, 0);
    }

    public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
    {
        var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
        ancestryNew.SetAsParent(Name);

        Value.ResolveAncestries(asset, ancestryNew);
        base.ResolveAncestries(asset, ancestrySoFar);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        int expLength = base.Write(writer, includeHeader, serializationContext);
        writer.Write(0);
        return expLength + Value.Write(writer, false) + sizeof(int);
    }
}

public class ScalarMaterialInputPropertyData : MaterialInputPropertyData<float>
{
    public ScalarMaterialInputPropertyData(FName name) : base(name) { }

    public ScalarMaterialInputPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ScalarMaterialInput");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        base.Read(reader, includeHeader, leng1, leng2, serializationContext);

        reader.ReadInt32(); // bUseConstantValue; always false
        Value = reader.ReadSingle();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        int expLength = WriteExpressionInput(writer, false);
        writer.Write(0);
        writer.Write(Value);
        return expLength + sizeof(float) + sizeof(int);
    }
}

public class VectorMaterialInputPropertyData : MaterialInputPropertyData<VectorPropertyData>
{
    public VectorMaterialInputPropertyData(FName name) : base(name) { }

    public VectorMaterialInputPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("VectorMaterialInput");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        base.Read(reader, includeHeader, leng1, leng2, serializationContext);

        reader.ReadInt32(); // bUseConstantValue; always false
        Value = new VectorPropertyData(Name);
        Value.Ancestry.Initialize(Ancestry, Name);
        Value.Read(reader, false, 0);
    }

    public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
    {
        var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
        ancestryNew.SetAsParent(Name);

        Value.ResolveAncestries(asset, ancestryNew);
        base.ResolveAncestries(asset, ancestrySoFar);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        int expLength = WriteExpressionInput(writer, false);
        writer.Write(0);
        return expLength + Value.Write(writer, false) + sizeof(int);
    }
}

public class Vector2MaterialInputPropertyData : MaterialInputPropertyData<Vector2DPropertyData>
{
    public Vector2MaterialInputPropertyData(FName name) : base(name) { }

    public Vector2MaterialInputPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector2MaterialInput");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        base.Read(reader, includeHeader, leng1, leng2, serializationContext);

        reader.ReadInt32(); // bUseConstantValue; always false
        Value = new Vector2DPropertyData(Name);
        Value.Ancestry.Initialize(Ancestry, Name);
        Value.Read(reader, false, 0);
    }

    public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
    {
        var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
        ancestryNew.SetAsParent(Name);

        Value.ResolveAncestries(asset, ancestryNew);
        base.ResolveAncestries(asset, ancestrySoFar);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        int expLength = WriteExpressionInput(writer, false);
        writer.Write(0);
        return expLength + Value.Write(writer, false) + sizeof(int);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/MaterialOverrideNanitePropertyData.cs`:

```cs
using UAssetAPI.CustomVersions;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MaterialOverrideNanitePropertyData : StructPropertyData
{
    public FSoftObjectPath OverrideMaterialRef;
    public bool bEnableOverride;
    public FPackageIndex OverrideMaterial;
    public bool bSerializeAsCookedData;

    public MaterialOverrideNanitePropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public MaterialOverrideNanitePropertyData(FName name) : base(name) { }
    public MaterialOverrideNanitePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MaterialOverrideNanite");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        if (reader.Asset.GetCustomVersion<FFortniteReleaseBranchCustomObjectVersion>() < FFortniteReleaseBranchCustomObjectVersion.NaniteMaterialOverrideUsesEditorOnly)
        {
            OverrideMaterialRef = new FSoftObjectPath(reader);
            bEnableOverride = reader.ReadBooleanInt();
            OverrideMaterial = FPackageIndex.FromRawIndex(reader.ReadInt32());
            return;
        }

        bSerializeAsCookedData = reader.ReadBooleanInt();
        if (bSerializeAsCookedData) OverrideMaterial = FPackageIndex.FromRawIndex(reader.ReadInt32());

        StructType = FName.DefineDummy(reader.Asset, CurrentPropertyType);
        base.Read(reader, includeHeader, 1, 0, PropertySerializationContext.StructFallback);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            this.WriteEndPropertyTag(writer);
        }

        int here = (int)writer.BaseStream.Position;

        if (writer.Asset.GetCustomVersion<FFortniteReleaseBranchCustomObjectVersion>() < FFortniteReleaseBranchCustomObjectVersion.NaniteMaterialOverrideUsesEditorOnly)
        {
            OverrideMaterialRef.Write(writer);
            writer.Write(bEnableOverride ? 1 : 0);
            writer.Write(OverrideMaterial?.Index ?? 0);
        }

        writer.Write(bSerializeAsCookedData ? 1 : 0);
        if (bSerializeAsCookedData) writer.Write(OverrideMaterial?.Index ?? 0);

        StructType = FName.DefineDummy(writer.Asset, CurrentPropertyType);
        base.Write(writer, includeHeader, PropertySerializationContext.StructFallback);

        return (int)writer.BaseStream.Position - here;
    }

    public override void FromString(string[] d, UAsset asset)
    {

    }
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/NavAgentSelectorPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public struct FNavAgentSelector : IStruct<FNavAgentSelector>
{
    public uint PackedBits;

    public FNavAgentSelector(uint packedBits)
    {
        PackedBits = packedBits;
    }

    public FNavAgentSelector(AssetBinaryReader reader)
    {
        PackedBits = reader.ReadUInt32();
    }

    public static FNavAgentSelector Read(AssetBinaryReader reader) => new FNavAgentSelector(reader);

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(PackedBits);
        return sizeof(uint);
    }

    public override string ToString()
    {
        return PackedBits.ToString();
    }

    public static FNavAgentSelector FromString(string[] d, UAsset asset)
    {
        uint.TryParse(d[0], out uint res);
        return new FNavAgentSelector(res);
    }
}

public class NavAgentSelectorPropertyData : BasePropertyData<FNavAgentSelector>
{
    public NavAgentSelectorPropertyData(FName name) : base(name) { }

    public NavAgentSelectorPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("NavAgentSelector");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/PerPlatformProperties.cs`:

```cs
using System;
using System.Collections.Generic;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public abstract class TPerPlatformPropertyData<T> : PropertyData<T[]>
{
    public TPerPlatformPropertyData(FName name) : base(name)
    {
        Value = [];
    }

    public TPerPlatformPropertyData()
    {
        Value = [];
    }
}

/// <summary>
/// <see cref="BoolPropertyData"/> (<see cref="bool"/>) property with per-platform overrides.
/// </summary>
public class PerPlatformBoolPropertyData : TPerPlatformPropertyData<bool>
{
    public PerPlatformBoolPropertyData(FName name) : base(name) { }

    public PerPlatformBoolPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("PerPlatformBool");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        int numEntries = reader.ReadInt32();
        Value = new bool[numEntries];
        for (int i = 0; i < numEntries; i++)
        {
            Value[i] = reader.ReadInt32() == 1;
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.Length);
        for (int i = 0; i < Value.Length; i++)
        {
            writer.Write(Value[i] ? 1 : 0);
        }
        return sizeof(int) + sizeof(int) * Value.Length;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        var valueList = new List<bool>();
        if (bool.TryParse(d[0], out bool res1)) valueList.Add(res1);
        if (bool.TryParse(d[1], out bool res2)) valueList.Add(res2);
        if (bool.TryParse(d[2], out bool res3)) valueList.Add(res3);
        if (bool.TryParse(d[3], out bool res4)) valueList.Add(res4);
        Value = valueList.ToArray();
    }

    public override string ToString()
    {
        string oup = "(";
        for (int i = 0; i < Value.Length; i++)
        {
            oup += Convert.ToString(Value[i]) + ", ";
        }
        return oup.Remove(oup.Length - 2) + ")";
    }
}

/// <summary>
/// <see cref="FloatPropertyData"/> (<see cref="float"/>) property with per-platform overrides.
/// </summary>
public class PerPlatformFloatPropertyData : TPerPlatformPropertyData<float>
{
    public PerPlatformFloatPropertyData(FName name) : base(name) { }

    public PerPlatformFloatPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("PerPlatformFloat");
    public override bool HasCustomStructSerialization { get { return true; } }
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        int numEntries = reader.ReadInt32();
        Value = new float[numEntries];
        for (int i = 0; i < numEntries; i++)
        {
            Value[i] = reader.ReadSingle();
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.Length);
        for (int i = 0; i < Value.Length; i++)
        {
            writer.Write(Value[i]);
        }
        return sizeof(int) + sizeof(float) * Value.Length;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        var valueList = new List<float>();
        if (float.TryParse(d[0], out float res1)) valueList.Add(res1);
        if (float.TryParse(d[1], out float res2)) valueList.Add(res2);
        if (float.TryParse(d[2], out float res3)) valueList.Add(res3);
        if (float.TryParse(d[3], out float res4)) valueList.Add(res4);
        Value = valueList.ToArray();
    }

    public override string ToString()
    {
        string oup = "(";
        for (int i = 0; i < Value.Length; i++)
        {
            oup += Convert.ToString(Value[i]) + ", ";
        }
        return oup.Remove(oup.Length - 2) + ")";
    }
}

/// <summary>
/// <see cref="IntPropertyData"/> (<see cref="int"/>) property with per-platform overrides.
/// </summary>
public class PerPlatformIntPropertyData : TPerPlatformPropertyData<int>
{
    public PerPlatformIntPropertyData(FName name) : base(name) { }

    public PerPlatformIntPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("PerPlatformInt");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        int numEntries = reader.ReadInt32();
        Value = new int[numEntries];
        for (int i = 0; i < numEntries; i++)
        {
            Value[i] = reader.ReadInt32();
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.Length);
        for (int i = 0; i < Value.Length; i++)
        {
            writer.Write(Value[i]);
        }
        return sizeof(int) + sizeof(int) * Value.Length;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        var valueList = new List<int>();
        if (int.TryParse(d[0], out int res1)) valueList.Add(res1);
        if (int.TryParse(d[1], out int res2)) valueList.Add(res2);
        if (int.TryParse(d[2], out int res3)) valueList.Add(res3);
        if (int.TryParse(d[3], out int res4)) valueList.Add(res4);
        Value = valueList.ToArray();
    }

    public override string ToString()
    {
        string oup = "(";
        for (int i = 0; i < Value.Length; i++)
        {
            oup += Convert.ToString(Value[i]) + ", ";
        }
        return oup.Remove(oup.Length - 2) + ")";
    }
}

/// <summary>
/// <see cref="PerPlatformFrameRatePropertyData"/> (<see cref="FFrameRate"/>) property with per-platform overrides.
/// </summary>
public class PerPlatformFrameRatePropertyData : TPerPlatformPropertyData<FFrameRate>
{
    public PerPlatformFrameRatePropertyData(FName name) : base(name) { }

    public PerPlatformFrameRatePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("PerPlatformFrameRate");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        int numEntries = reader.ReadInt32();
        Value = new FFrameRate[numEntries];
        for (int i = 0; i < numEntries; i++)
        {
            Value[i] = new FFrameRate(reader.ReadInt32(), reader.ReadInt32());
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.Length);
        for (int i = 0; i < Value.Length; i++)
        {
            writer.Write(Value[i].Numerator);
            writer.Write(Value[i].Denominator);
        }
        return sizeof(int) + sizeof(int) * 2 * Value.Length;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        var valueList = new List<FFrameRate>();
        if (FFrameRate.TryParse(d[0], out FFrameRate res1)) valueList.Add(res1);
        if (FFrameRate.TryParse(d[1], out FFrameRate res2)) valueList.Add(res2);
        if (FFrameRate.TryParse(d[2], out FFrameRate res3)) valueList.Add(res3);
        if (FFrameRate.TryParse(d[3], out FFrameRate res4)) valueList.Add(res4);
        Value = valueList.ToArray();
    }

    public override string ToString()
    {
        string oup = "(";
        for (int i = 0; i < Value.Length; i++)
        {
            oup += Convert.ToString(Value[i]) + ", ";
        }
        return oup.Remove(oup.Length - 2) + ")";
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/PerQualityProperties.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public abstract class TPerQualityLevelPropertyData<T> : PropertyData<TPerQualityLevel<T>>
{
    public TPerQualityLevelPropertyData(FName name) : base(name) { }

    public TPerQualityLevelPropertyData() { }
}

public class PerQualityLevelFloatPropertyData : TPerQualityLevelPropertyData<float>
{
    public PerQualityLevelFloatPropertyData(FName name) : base(name) { }

    public PerQualityLevelFloatPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("PerQualityLevelFloat");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new(reader, reader.ReadSingle);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer, writer.Write);
    }
}

public class PerQualityLevelIntPropertyData : TPerQualityLevelPropertyData<int>
{
    public PerQualityLevelIntPropertyData(FName name) : base(name) { }

    public PerQualityLevelIntPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("PerQualityLevelInt");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new(reader, reader.ReadInt32);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer, writer.Write);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/RichCurveKeyPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class RichCurveKeyPropertyData : BasePropertyData<FRichCurveKey>
{
    public RichCurveKeyPropertyData(FName name) : base(name) { }

    public RichCurveKeyPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("RichCurveKey");
    public override FString PropertyType => CurrentPropertyType;
}

```

`UAssetAPI/PropertyTypes/Structs/Engine/SkeletalMeshSamplingLODBuiltDataPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class SkeletalMeshSamplingLODBuiltDataPropertyData : PropertyData<SkeletalMeshAreaWeightedTriangleSamplerPropertyData>
{
    public SkeletalMeshSamplingLODBuiltDataPropertyData(FName name) : base(name) { }

    public SkeletalMeshSamplingLODBuiltDataPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SkeletalMeshSamplingLODBuiltData");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new SkeletalMeshAreaWeightedTriangleSamplerPropertyData(FName.DefineDummy(reader.Asset, "AreaWeightedTriangleSampler"));
        Value.Ancestry.Initialize(Ancestry, Name);
        Value.Read(reader, false, 0);
    }

    public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
    {
        var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
        ancestryNew.SetAsParent(Name);

        if (Value == null) Value = new SkeletalMeshAreaWeightedTriangleSamplerPropertyData();
        Value.ResolveAncestries(asset, ancestryNew);
        base.ResolveAncestries(asset, ancestrySoFar);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        if (Value == null) Value = new SkeletalMeshAreaWeightedTriangleSamplerPropertyData();
        return Value.Write(writer, false);
    }

    public override string ToString()
    {
        return Value.ToString();
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/SkeletalMeshSamplingRegionBuiltDataPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.StructTypes;

public class SkeletalMeshSamplingRegionBuiltDataPropertyData : BasePropertyData<FSkeletalMeshSamplingRegionBuiltData>
{
    public SkeletalMeshSamplingRegionBuiltDataPropertyData(FName name) : base(name) { }

    public SkeletalMeshSamplingRegionBuiltDataPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SkeletalMeshSamplingRegionBuiltData");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/SmartNamePropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;
using UAssetAPI.CustomVersions;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Special FName struct used within animations.
/// </summary>
public class SmartNamePropertyData : PropertyData
{
    /// <summary>
    /// The display name of this FSmartName.
    /// </summary>
    public FName DisplayName;

    /// <summary>
    /// SmartName::UID_Type - for faster access
    /// </summary>
    public ushort SmartNameID;

    /// <summary>
    /// Uncertain
    /// </summary>
    public Guid TempGUID;

    public SmartNamePropertyData(FName name) : base(name) { }

    public SmartNamePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SmartName");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        DisplayName = reader.ReadFName();
        if (reader.Asset.GetCustomVersion<FAnimPhysObjectVersion>() < FAnimPhysObjectVersion.RemoveUIDFromSmartNameSerialize)
        {
            SmartNameID = reader.ReadUInt16();
        }
        if (reader.Asset.GetCustomVersion<FAnimPhysObjectVersion>() < FAnimPhysObjectVersion.SmartNameRefactorForDeterministicCooking && !reader.Asset.IsFilterEditorOnly)
        {
            TempGUID = new Guid(reader.ReadBytes(16));
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        long here = writer.BaseStream.Position;

        writer.Write(DisplayName);
        if (writer.Asset.GetCustomVersion<FAnimPhysObjectVersion>() < FAnimPhysObjectVersion.RemoveUIDFromSmartNameSerialize)
        {
            writer.Write(SmartNameID);
        }
        if (writer.Asset.GetCustomVersion<FAnimPhysObjectVersion>() < FAnimPhysObjectVersion.SmartNameRefactorForDeterministicCooking && !writer.Asset.IsFilterEditorOnly)
        {
            writer.Write(TempGUID.ToByteArray());
        }

        return (int)(writer.BaseStream.Position - here);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        DisplayName = FName.FromString(asset, d[0]);
        if (ushort.TryParse(d[1], out ushort rawSmartNameID)) SmartNameID = rawSmartNameID;
        TempGUID = d[2].ConvertToGUID();
    }

    public override string ToString()
    {
        return "(" + ")";
    }
}

```

`UAssetAPI/PropertyTypes/Structs/Engine/StringCurveKeyPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public struct FStringCurveKey : IStruct<FStringCurveKey>
{
    public float Time;
    public FString Value;

    public FStringCurveKey(float time, FString value)
    {
        Time = time;
        Value = value;
    }

    public FStringCurveKey(AssetBinaryReader reader)
    {
        Time = reader.ReadSingle();
        Value = reader.ReadFString();
    }

    public static FStringCurveKey Read(AssetBinaryReader reader) => new FStringCurveKey(reader);

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        writer.Write(Time);
        writer.Write(Value);

        return (int)(writer.BaseStream.Position - offset);
    }

    public override string ToString() => $"({Time}, {Value})";

    public static FStringCurveKey FromString(string[] d, UAsset asset)
    {
        float.TryParse(d[0], out float Time);
        FString Value = FString.FromString(d[1]);
        return new FStringCurveKey(Time, Value);
    }
}

public class StringCurveKeyPropertyData : BasePropertyData<FStringCurveKey>
{
    public StringCurveKeyPropertyData(FName name) : base(name) { }
    public StringCurveKeyPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("StringCurveKey");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Engine/ViewTargetBlendParamsPropertyData.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Options that define how to blend when changing view targets in <see cref="ViewTargetBlendParamsPropertyData"/>.
/// </summary>
public enum ViewTargetBlendFunction
{
    /** Camera does a simple linear interpolation. */
    VTBlend_Linear,
    /** Camera has a slight ease in and ease out, but amount of ease cannot be tweaked. */
    VTBlend_Cubic,
    /** Camera immediately accelerates, but smoothly decelerates into the target.  Ease amount controlled by BlendExp. */
    VTBlend_EaseIn,
    /** Camera smoothly accelerates, but does not decelerate into the target.  Ease amount controlled by BlendExp. */
    VTBlend_EaseOut,
    /** Camera smoothly accelerates and decelerates.  Ease amount controlled by BlendExp. */
    VTBlend_EaseInOut,
    VTBlend_MAX,
}

/// <summary>
/// A set of parameters to describe how to transition between view targets.
/// Referred to as FViewTargetTransitionParams in the Unreal Engine.
/// </summary>
public class ViewTargetBlendParamsPropertyData : PropertyData
{
    [JsonProperty]
    public float BlendTime;
    [JsonProperty]
    [JsonConverter(typeof(StringEnumConverter))]
    public ViewTargetBlendFunction BlendFunction;
    [JsonProperty]
    public float BlendExp;
    [JsonProperty]
    public bool bLockOutgoing;

    public ViewTargetBlendParamsPropertyData(FName name) : base(name) { }

    public ViewTargetBlendParamsPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("ViewTargetBlendParams");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        BlendTime = reader.ReadSingle();
        BlendFunction = (ViewTargetBlendFunction)reader.ReadByte();
        BlendExp = reader.ReadSingle();
        bLockOutgoing = reader.ReadInt32() != 0;
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(BlendTime);
        writer.Write((byte)BlendFunction);
        writer.Write(BlendExp);
        writer.Write(bLockOutgoing ? 1 : 0);
        return sizeof(float) * 2 + sizeof(byte) + sizeof(int);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        if (float.TryParse(d[0], out float res1)) BlendTime = res1;
        if (Enum.TryParse(d[1], out ViewTargetBlendFunction res2)) BlendFunction = res2;
        if (float.TryParse(d[2], out float res3)) BlendExp = res3;
        if (bool.TryParse(d[3], out bool res4)) bLockOutgoing = res4;
    }

    public override string ToString()
    {
        string oup = "(";
        oup += BlendTime + ", ";
        oup += BlendFunction + ", ";
        oup += BlendExp + ", ";
        oup += bLockOutgoing + ", ";
        return oup.Remove(oup.Length - 2) + ")";
    }
}

```

`UAssetAPI/PropertyTypes/Structs/Engine/WeightedRandomSamplerPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class WeightedRandomSamplerPropertyData : BasePropertyData<FWeightedRandomSampler>
{
    public WeightedRandomSamplerPropertyData(FName name) : base(name) { }

    public WeightedRandomSamplerPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("WeightedRandomSampler");
    public override FString PropertyType => CurrentPropertyType;
}

public class SkeletalMeshAreaWeightedTriangleSamplerPropertyData : WeightedRandomSamplerPropertyData
{
    public SkeletalMeshAreaWeightedTriangleSamplerPropertyData(FName name) : base(name) { }

    public SkeletalMeshAreaWeightedTriangleSamplerPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SkeletalMeshAreaWeightedTriangleSampler");
    public override FString PropertyType => CurrentPropertyType;
}

```

`UAssetAPI/PropertyTypes/Structs/GameplayTagContainerPropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class GameplayTagContainerPropertyData : PropertyData<FName[]>
{
    public GameplayTagContainerPropertyData(FName name) : base(name)
    {
        Value = [];
    }

    public GameplayTagContainerPropertyData()
    {
        Value = [];
    }

    private static readonly FString CurrentPropertyType = new FString("GameplayTagContainer");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        int numEntries = reader.ReadInt32();
        Value = new FName[numEntries];
        for (int i = 0; i < numEntries; i++)
        {
            Value[i] = reader.ReadFName();
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        if (Value == null) Value = [];
        writer.Write(Value.Length);
        int totalSize = sizeof(int);
        for (int i = 0; i < Value.Length; i++)
        {
            writer.Write(Value[i]);
            totalSize += sizeof(int) * 2;
        }
        return totalSize;
    }

    public override string ToString()
    {
        string oup = "(";
        for (int i = 0; i < Value.Length; i++)
        {
            oup += Convert.ToString(Value[i]) + ", ";
        }
        return oup.Remove(oup.Length - 2) + ")";
    }

    protected override void HandleCloned(PropertyData res)
    {
        GameplayTagContainerPropertyData cloningProperty = (GameplayTagContainerPropertyData)res;

        if (this.Value != null)
        {
            FName[] newData = new FName[this.Value.Length];
            for (int i = 0; i < this.Value.Length; i++)
            {
                newData[i] = (FName)this.Value[i].Clone();
            }
            cloningProperty.Value = newData;
        }
        else
        {
            cloningProperty.Value = null;
        }
    }
}
```

`UAssetAPI/PropertyTypes/Structs/LevelSequenceObjectReferenceMapPropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class FLevelSequenceLegacyObjectReference
{
    public Guid ObjectId;
    public FString ObjectPath;

    public FLevelSequenceLegacyObjectReference(Guid objectId, FString objectPath)
    {
        ObjectId = objectId;
        ObjectPath = objectPath;
    }
    
    public FLevelSequenceLegacyObjectReference(AssetBinaryReader reader)
    {
        ObjectId = new Guid(reader.ReadBytes(16));
        ObjectPath = reader.ReadFString();
    }

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(ObjectId.ToByteArray());
        var size = 16;
        size += writer.Write(ObjectPath);
        return size;
    }
}

public class LevelSequenceObjectReferenceMapPropertyData : PropertyData<TMap<Guid, FLevelSequenceLegacyObjectReference>>
{
    public LevelSequenceObjectReferenceMapPropertyData(FName name) : base(name) { }

    public LevelSequenceObjectReferenceMapPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("LevelSequenceObjectReferenceMap");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
    

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        var num = reader.ReadInt32();
        Value = new TMap<Guid, FLevelSequenceLegacyObjectReference>();
        for (int i = 0; i < num; i++)
        {
            Value[new Guid(reader.ReadBytes(16))] = new FLevelSequenceLegacyObjectReference(reader);
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        var offset = writer.BaseStream.Position;

        if (Value == null) Value = [];
        writer.Write(Value.Count);

        foreach (var pair in Value)
        {
            writer.Write(pair.Key.ToByteArray());
            pair.Value.Write(writer);
        }

        return (int)(writer.BaseStream.Position - offset);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Math/BoxPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public abstract class TBoxPropertyData<T> : PropertyData<TBox<T>>
{
    public TBoxPropertyData(FName name) : base(name) { }

    public TBoxPropertyData() { }
}

public class BoxPropertyData : TBoxPropertyData<FVector>
{
    public BoxPropertyData(FName name) : base(name) { }

    public BoxPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Box");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new(reader, () => new FVector(reader));
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer, entry => entry.Write(writer));
    }
}

public class Box2fPropertyData : TBoxPropertyData<FVector2f>
{
    public Box2fPropertyData(FName name) : base(name) { }

    public Box2fPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Box2f");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new(reader, () => new FVector2f(reader));
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer, entry => entry.Write(writer));
    }
}

public class Box2DPropertyData : TBoxPropertyData<FVector2D>
{
    public Box2DPropertyData(FName name) : base(name) { }

    public Box2DPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Box2D");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new TBox<FVector2D>(reader, () => new FVector2D(reader));
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer, entry => entry.Write(writer));
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Math/IntPointPropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class IntPointPropertyData : PropertyData<int[]> // X, Y
{
    public IntPointPropertyData(FName name) : base(name) { }

    public IntPointPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("IntPoint");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new int[2];
        for (int i = 0; i < 2; i++)
        {
            Value[i] = reader.ReadInt32();
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        if (Value == null) Value = new int[2];
        for (int i = 0; i < 2; i++)
        {
            writer.Write(Value[i]);
        }
        return sizeof(int) * 2;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        Value = new int[2];
        if (int.TryParse(d[0], out int res1)) Value[0] = res1;
        if (int.TryParse(d[1], out int res2)) Value[1] = res2;
    }

    public override string ToString()
    {
        string oup = "(";
        for (int i = 0; i < Value.Length; i++)
        {
            oup += Convert.ToString(Value[i]) + ", ";
        }
        return oup.Remove(oup.Length - 2) + ")";
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Math/IntVector2PropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class IntVector2PropertyData : BasePropertyData<FIntVector2>
{
    public IntVector2PropertyData(FName name) : base(name) { }

    public IntVector2PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("IntVector2");
    public override FString PropertyType => CurrentPropertyType;
}

```

`UAssetAPI/PropertyTypes/Structs/Math/IntVectorPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class IntVectorPropertyData : BasePropertyData<FIntVector>
{
    public IntVectorPropertyData(FName name) : base(name) { }

    public IntVectorPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("IntVector");
    public override FString PropertyType => CurrentPropertyType;
}


```

`UAssetAPI/PropertyTypes/Structs/Math/LinearColorPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class LinearColorPropertyData : BasePropertyData<FLinearColor> // R, G, B, A
{
    public LinearColorPropertyData(FName name) : base(name) { }

    public LinearColorPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("LinearColor");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/MatrixPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MatrixPropertyData : BasePropertyData<FMatrix>
{
    public MatrixPropertyData(FName name) : base(name) { }

    public MatrixPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Matrix");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/PlanePropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A plane in 3-D space stores the coeffecients as Xx+Yy+Zz=W.
/// </summary>
public class PlanePropertyData : BasePropertyData<FPlane>
{
    public PlanePropertyData(FName name) : base(name) { }

    public PlanePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Plane");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/QuatPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Floating point quaternion that can represent a rotation about an axis in 3-D space.
/// The X, Y, Z, W components also double as the Axis/Angle format.
/// </summary>
public class QuatPropertyData : BasePropertyData<FQuat>
{
    public QuatPropertyData(FName name) : base(name) { }

    public QuatPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Quat");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/RotatorPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Implements a container for rotation information.
/// All rotation values are stored in degrees.
/// </summary>
public class RotatorPropertyData : BasePropertyData<FRotator>
{        
    public RotatorPropertyData(FName name) : base(name) { }

    public RotatorPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Rotator");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/TwoVectorsPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class TwoVectorsPropertyData : BasePropertyData<FTwoVectors>
{
    public TwoVectorsPropertyData(FName name) : base(name) { }

    public TwoVectorsPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("TwoVectors");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/Vector2DPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A vector in 2-D space composed of components (X, Y) with floating/double point precision.
/// </summary>
public class Vector2DPropertyData : BasePropertyData<FVector2D>
{
    public Vector2DPropertyData(FName name) : base(name) { }

    public Vector2DPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector2D");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/Vector2fPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A vector in 2-D space composed of components (X, Y) with floating/double point precision.
/// </summary>
public class Vector2fPropertyData : BasePropertyData<FVector2f>
{
    public Vector2fPropertyData(FName name) : base(name) { }

    public Vector2fPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector2f");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/Vector3fPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A vector in 3-D space composed of components (X, Y, Z) with floating point precision.
/// </summary>
public class Vector3fPropertyData : BasePropertyData<FVector3f>
{
    public Vector3fPropertyData(FName name) : base(name) { }

    public Vector3fPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector3f");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/Vector4PropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A vector in 4-D space composed of components (X, Y, Z, W) with floating/double point precision.
/// </summary>
public class Vector4PropertyData : BasePropertyData<FVector4>
{
    public Vector4PropertyData(FName name) : base(name) { }

    public Vector4PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector4");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/Vector4fPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A vector in 4-D space composed of components (X, Y, Z, W) with floating point precision.
/// </summary>
public class Vector4fPropertyData : BasePropertyData<FVector4f>
{
    public Vector4fPropertyData(FName name) : base(name) { }

    public Vector4fPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector4f");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/VectorNetQuantizePropertyData.cs`:

```cs
using System;
using System.Collections.Generic;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class VectorNetQuantizePropertyData : StructPropertyData
{
    public VectorNetQuantizePropertyData(FName name, FName forcedType) : base(name, forcedType)
    {
        Value.Add(new VectorPropertyData(name)); //backup for isZero
    }

    public VectorNetQuantizePropertyData(FName name) : base(name)
    {
        Value.Add(new VectorPropertyData(name));
    }

    public VectorNetQuantizePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector_NetQuantize");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        Value = [];
        //either this or 5.0+ or unversioned
        if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            var data = new VectorPropertyData(Name);
            data.Read(reader, includeHeader, leng1, leng2, serializationContext);
            Value.Add(data);
        }
        else
        {
            StructType = FName.DefineDummy(reader.Asset, PropertyType);
            base.Read(reader, includeHeader, 1, leng2, PropertySerializationContext.StructFallback);
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            if (Value == null)
            {
                Value = new List<PropertyData>();
                Value.Add(new VectorPropertyData(Name));
            }

            if (Value.Count == 1 && Value[0] is VectorPropertyData vector)
            {
                return Value[0].Write(writer, includeHeader, serializationContext);
            }
            throw new FormatException($"{PropertyType} must have a VectorPropertyData child");
        }
        else
        {
            StructType = FName.DefineDummy(writer.Asset, PropertyType);
            return base.Write(writer, includeHeader, PropertySerializationContext.StructFallback);
        }
    }
}

public class VectorNetQuantizeNormalPropertyData : VectorNetQuantizePropertyData
{
    public VectorNetQuantizeNormalPropertyData(FName name) : base(name) { }

    public VectorNetQuantizeNormalPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector_NetQuantizeNormal");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}

public class VectorNetQuantize10PropertyData : VectorNetQuantizePropertyData
{
    public VectorNetQuantize10PropertyData(FName name) : base(name) { }

    public VectorNetQuantize10PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector_NetQuantize10");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}

public class VectorNetQuantize100PropertyData : VectorNetQuantizePropertyData
{
    public VectorNetQuantize100PropertyData(FName name) : base(name) { }

    public VectorNetQuantize100PropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector_NetQuantize100");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Math/VectorPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A vector in 3-D space composed of components (X, Y, Z) with floating/double point precision.
/// </summary>
public class VectorPropertyData : BasePropertyData<FVector>
{
    public VectorPropertyData(FName name) : base(name) { }

    public VectorPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("Vector");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/FrameNumberPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class FrameNumberPropertyData : BasePropertyData<FFrameNumber>
{
    public FrameNumberPropertyData(FName name) : base(name) { }

    public FrameNumberPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("FrameNumber");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieScene.cs`:

```cs
using System;
using UAssetAPI.CustomVersions;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public enum ESectionEvaluationFlags : byte {
    None = 0,
    PreRoll = 1,
    PostRoll = 2,
    ForceKeepState = 4,
    ForceRestoreState = 8,
};

/// <summary>
/// Keyable struct that represents a particular entity within an evaluation template (either a section/template or a track)
/// </summary>
public struct FMovieSceneEvaluationKey
{
    /// <summary> ID of the sequence that the entity is contained within </summary>
    public uint SequenceID;
    /// <summary> ID of the track this key relates to </summary>
    public uint TrackIdentifier;
    /// <summary> Index of the section template within the track this key relates to (or -1 where this key relates to a track) </summary>
    public uint SectionIndex;

    public FMovieSceneEvaluationKey(uint _SequenceID, uint _TrackIdentifier, uint _SectionIndex)
    {
        SequenceID = _SequenceID;
        TrackIdentifier = _TrackIdentifier;
        SectionIndex = _SectionIndex;
    }

    public FMovieSceneEvaluationKey(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            SequenceID = reader.ReadUInt32();
            TrackIdentifier = reader.ReadUInt32();
            SectionIndex = reader.ReadUInt32();
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(SequenceID);
        writer.Write(TrackIdentifier);
        writer.Write(SectionIndex);
        return sizeof(uint) * 3;
    }
}

/// <summary>
/// Data that represents a single sub-section
/// </summary>
public struct FMovieSceneSubSectionData
{
    /// <summary> The sub section itself  </summary>
    public FPackageIndex Section;
    /// <summary> The object binding that the sub section belongs to (usually zero) </summary>
    public Guid ObjectBindingId;
    /// <summary> Evaluation flags for the section </summary>
    public ESectionEvaluationFlags Flags;

    public FMovieSceneSubSectionData(FPackageIndex section, Guid objectBindingId, ESectionEvaluationFlags flags)
    {
        Section = section;
        ObjectBindingId = objectBindingId;
        Flags = flags;
    }

    public FMovieSceneSubSectionData(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            Section = new FPackageIndex(reader);
            ObjectBindingId = new Guid(reader.ReadBytes(16));
            Flags = (ESectionEvaluationFlags)reader.ReadByte();
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        Section.Write(writer);
        writer.Write(ObjectBindingId.ToByteArray());
        writer.Write((byte)Flags);
        return sizeof(int) + 16 + sizeof(byte);
    }
}

public struct FEntityAndMetaDataIndex
{
    public int EntityIndex;
    public int MetaDataIndex;

    public FEntityAndMetaDataIndex(int entityIndex, int metaDataIndex)
    {
        EntityIndex = entityIndex;
        MetaDataIndex = metaDataIndex;
    }

    public FEntityAndMetaDataIndex(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            EntityIndex = reader.ReadInt32();
            MetaDataIndex = reader.ReadInt32();
        }
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(EntityIndex);
        writer.Write(MetaDataIndex);
    }
}

public struct FMovieSceneSubSequenceTreeEntry
{
    public uint SequenceID;
    public ESectionEvaluationFlags Flags;
    public StructPropertyData RootToSequenceWarpCounter = null;

    public FMovieSceneSubSequenceTreeEntry(uint sequenceID, byte flags, StructPropertyData _struct = null)
    {
        SequenceID = sequenceID;
        Flags = (ESectionEvaluationFlags)flags;
        RootToSequenceWarpCounter = _struct;
    }

    public FMovieSceneSubSequenceTreeEntry(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            SequenceID = reader.ReadUInt32();
            Flags = (ESectionEvaluationFlags)reader.ReadByte();
            if (reader.Asset.GetCustomVersion<FReleaseObjectVersion>() >= FReleaseObjectVersion.AddedSubSequenceEntryWarpCounter ||
                reader.Asset.GetCustomVersion<FFortniteMainBranchObjectVersion>() >= FFortniteMainBranchObjectVersion.AddedSubSequenceEntryWarpCounter)
            {
                var data = new StructPropertyData(FName.DefineDummy(reader.Asset, "RootToSequenceWarpCounter"), FName.DefineDummy(reader.Asset, "MovieSceneWarpCounter"));
                data.Read(reader, false, 1, 0, PropertySerializationContext.StructFallback);
                RootToSequenceWarpCounter = data;
            }
        }
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(SequenceID);
        writer.Write((byte)Flags);
        if (writer.Asset.GetCustomVersion<FReleaseObjectVersion>() >= FReleaseObjectVersion.AddedSubSequenceEntryWarpCounter ||
            writer.Asset.GetCustomVersion<FFortniteMainBranchObjectVersion>() >= FFortniteMainBranchObjectVersion.AddedSubSequenceEntryWarpCounter)
        {
            RootToSequenceWarpCounter?.Write(writer, false, PropertySerializationContext.StructFallback);
        }
    }
}

public struct FMovieSceneSubSectionFieldData(AssetBinaryReader reader)
{
    public TMovieSceneEvaluationTree<FMovieSceneSubSectionData> Field = new(reader, () => new FMovieSceneSubSectionData(reader));

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        Field.Write(writer, entry => entry.Write(writer));

        return (int)(writer.BaseStream.Position - offset);
    }
}

public struct FMovieSceneEvaluationFieldEntityTree(AssetBinaryReader reader)
{
    public TMovieSceneEvaluationTree<FEntityAndMetaDataIndex> SerializedData = new(reader, () => new FEntityAndMetaDataIndex(reader));

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        SerializedData.Write(writer, entry => entry.Write(writer));

        return (int)(writer.BaseStream.Position - offset);
    }
}

public struct FMovieSceneSubSequenceTree(AssetBinaryReader reader)
{
    public TMovieSceneEvaluationTree<FMovieSceneSubSequenceTreeEntry> Data = new(reader, () => new FMovieSceneSubSequenceTreeEntry(reader));

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        Data.Write(writer, entry => entry.Write(writer));

        return (int)(writer.BaseStream.Position - offset);
    }
}

public struct FSectionEvaluationDataTree
{
    public TMovieSceneEvaluationTree<StructPropertyData> Tree;

    public FSectionEvaluationDataTree(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            Tree = new(reader, () => ReadTree(reader));

            static StructPropertyData ReadTree(AssetBinaryReader reader)
            {
                var data = new StructPropertyData(FName.DefineDummy(reader.Asset, "Tree"), FName.DefineDummy(reader.Asset, "SectionEvaluationDataTree"));
                data.Read(reader, false, 1, 0, PropertySerializationContext.StructFallback);
                return data;
            }
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        static void WriteTree(AssetBinaryWriter writer, StructPropertyData data)
        {
            if (data != null)
            {
                data.StructType = FName.DefineDummy(writer.Asset, "SectionEvaluationDataTree");
                data.Write(writer, false, PropertySerializationContext.StructFallback);
            }
        }

        var offset = writer.BaseStream.Position;
        Tree.Write(writer, entry => WriteTree(writer, entry));
        return (int)(writer.BaseStream.Position - offset);
    }
}

public struct FMovieSceneTrackFieldData(AssetBinaryReader reader)
{
    public TMovieSceneEvaluationTree<uint> Field = new (reader, reader.ReadUInt32);

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        Field.Write(writer, writer.Write);

        return (int)(writer.BaseStream.Position - offset);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneChannel.cs`:

```cs
using System;
using UAssetAPI.CustomVersions;
using UAssetAPI.UnrealTypes.EngineEnums;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class FMovieSceneChannel<T>
{
    public ERichCurveExtrapolation PreInfinityExtrap;
    public ERichCurveExtrapolation PostInfinityExtrap;
    public int TimesStructLength;
    public FFrameNumber[] Times;
    public int ValuesStructLength;
    public FMovieSceneValue<T>[] Values;
    public T DefaultValue;
    public bool bHasDefaultValue;
    public FFrameRate TickResolution;
    public bool bShowCurve;

    public FMovieSceneChannel()
    {
        PreInfinityExtrap = ERichCurveExtrapolation.RCCE_Constant;
        PostInfinityExtrap = ERichCurveExtrapolation.RCCE_Constant;
        Times = [];
        Values = [];
        DefaultValue = default;
        bHasDefaultValue = false;
        TickResolution = new FFrameRate(60000, 1);
        bShowCurve = false;
    }

    public FMovieSceneChannel(AssetBinaryReader reader, Func<T> valueReader)
    {
        if (reader != null && valueReader != null)
        {
            PreInfinityExtrap = (ERichCurveExtrapolation)reader.ReadByte();
            PostInfinityExtrap = (ERichCurveExtrapolation)reader.ReadByte();

            TimesStructLength = reader.ReadInt32();
            Times = reader.ReadArray(() => new FFrameNumber(reader));

            ValuesStructLength = reader.ReadInt32();
            Values = reader.ReadArray(() => new FMovieSceneValue<T>(reader, valueReader()));

            DefaultValue = valueReader();
            bHasDefaultValue = reader.ReadBooleanInt();
            TickResolution = new FFrameRate(reader);
            bShowCurve = reader.Asset.GetCustomVersion<FFortniteMainBranchObjectVersion>() > FFortniteMainBranchObjectVersion.SerializeFloatChannelShowCurve && reader.ReadBooleanInt();
        }
    }

    public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
    {
        writer.Write((byte)PreInfinityExtrap);
        writer.Write((byte)PostInfinityExtrap);

        writer.Write(TimesStructLength);
        writer.Write(Times.Length);
        for (int i = 0; i < Times.Length; i++)
        {
            Times[i].Write(writer);
        }

        writer.Write(ValuesStructLength);
        writer.Write(Values.Length);
        for (int i = 0; i < Values.Length; i++)
        {
            Values[i].Write(writer, valueWriter);
        }

        valueWriter(DefaultValue);
        writer.Write(bHasDefaultValue ? 1 : 0);
        TickResolution.Write(writer);
        if (writer.Asset.GetCustomVersion<FFortniteMainBranchObjectVersion>() > FFortniteMainBranchObjectVersion.SerializeFloatChannelShowCurve)
            writer.Write(bShowCurve ? 1 : 0);
    }
}

public class FMovieSceneFloatChannel(AssetBinaryReader reader) : FMovieSceneChannel<float>(reader, reader == null ? null : reader.ReadSingle) { }

public class FMovieSceneDoubleChannel(AssetBinaryReader reader) : FMovieSceneChannel<double>(reader, reader == null ? null : reader.ReadDouble) { }
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneDoubleChannelPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneDoubleChannelPropertyData : PropertyData<FMovieSceneDoubleChannel>
{
    public MovieSceneDoubleChannelPropertyData(FName name) : base(name) { }

    public MovieSceneDoubleChannelPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneDoubleChannel");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneDoubleChannel(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }
        
        var offset = writer.BaseStream.Position;

        Value.Write(writer, writer.Write);

        return (int)(writer.BaseStream.Position - offset);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneEvalTemplatePtrPropertyData.cs`:

```cs
using System;
using System.Linq;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneTemplatePropertyData : StructPropertyData 
{
    public MovieSceneTemplatePropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public MovieSceneTemplatePropertyData(FName name) : base(name) { }
    public MovieSceneTemplatePropertyData() { }

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        StrPropertyData type = new StrPropertyData(FName.DefineDummy(reader.Asset, "TypeName"));
        type.Ancestry.Initialize(Ancestry, Name);
        type.Read(reader, includeHeader, leng1);
        
        if (type.Value != null)
        {
            StructType = FName.DefineDummy(reader.Asset, type.Value.ToString().Split(".")[1]);
            base.Read(reader, false, 1, 0, PropertySerializationContext.StructFallback);
        }

        Value.Insert(0, type);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        var offset = writer.BaseStream.Position;

        if (Value != null)
        {
            var type = (StrPropertyData)Value.Find(x => x.Name.ToString() == "TypeName");
            if (type is null) throw new FormatException($"TypeName property not found in {PropertyType}");
            writer.Write(type.Value);
            if (type.Value != null)
            {
                var dat = Value.Except([type]).ToList();
                MainSerializer.GenerateUnversionedHeader(ref dat, Name, null, writer.Asset)?.Write(writer);

                foreach (var t in dat)
                {
                    MainSerializer.Write(t, writer, true);
                }
                if (!writer.Asset.HasUnversionedProperties) writer.Write(new FName(writer.Asset, "None"));
            }
        }

        return (int)(writer.BaseStream.Position - offset);
    }
}

public class MovieSceneEvalTemplatePtrPropertyData : MovieSceneTemplatePropertyData
{
    public MovieSceneEvalTemplatePtrPropertyData(FName name, FName forcedType) : base(name, forcedType) {}
    public MovieSceneEvalTemplatePtrPropertyData(FName name) : base(name) { }
    public MovieSceneEvalTemplatePtrPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneEvalTemplatePtr");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}

public class MovieSceneTrackImplementationPtrPropertyData : MovieSceneTemplatePropertyData
{
    public MovieSceneTrackImplementationPtrPropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public MovieSceneTrackImplementationPtrPropertyData(FName name) : base(name) { }
    public MovieSceneTrackImplementationPtrPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneTrackImplementationPtr");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneEvaluationFieldEntityTreePropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneSubSectionFieldDataPropertyData : PropertyData<FMovieSceneSubSectionFieldData>
{
    public MovieSceneSubSectionFieldDataPropertyData(FName name) : base(name) { }

    public MovieSceneSubSectionFieldDataPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneSubSectionFieldData");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneSubSectionFieldData(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer);
    }
}

public class MovieSceneEvaluationFieldEntityTreePropertyData : PropertyData<FMovieSceneEvaluationFieldEntityTree>
{
    public MovieSceneEvaluationFieldEntityTreePropertyData(FName name) : base(name) { }

    public MovieSceneEvaluationFieldEntityTreePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneEvaluationFieldEntityTree");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneEvaluationFieldEntityTree(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer);
    }
}

public class MovieSceneSubSequenceTreePropertyData : PropertyData<FMovieSceneSubSequenceTree>
{
    public MovieSceneSubSequenceTreePropertyData(FName name) : base(name) { }

    public MovieSceneSubSequenceTreePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneSubSequenceTree");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneSubSequenceTree(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader) {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer);
    }
}

public class MovieSceneSequenceInstanceDataPtrPropertyData : PropertyData<FPackageIndex>
{
    public MovieSceneSequenceInstanceDataPtrPropertyData(FName name) : base(name) { }

    public MovieSceneSequenceInstanceDataPtrPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneSequenceInstanceDataPtr");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }
        Value = new FPackageIndex(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value.Index);
        return sizeof(int);
    }
}

public class SectionEvaluationDataTreePropertyData : PropertyData<FSectionEvaluationDataTree>
{
    public SectionEvaluationDataTreePropertyData(FName name) : base(name) { }

    public SectionEvaluationDataTreePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SectionEvaluationDataTree");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FSectionEvaluationDataTree(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer);
    }
}

public class MovieSceneTrackFieldDataPropertyData : PropertyData<FMovieSceneTrackFieldData>
{
    public MovieSceneTrackFieldDataPropertyData(FName name) : base(name) { }

    public MovieSceneTrackFieldDataPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneTrackFieldData");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneTrackFieldData(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader) {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneEvaluationTree.cs`:

```cs
using System;

namespace UAssetAPI.PropertyTypes.Structs;

public struct FEntry
{
    /// <summary>
    /// The index into Items of the first item
    /// </summary>
    public int StartIndex;
    /// <summary>
    /// The number of currently valid items
    /// </summary>
    public int Size;
    /// <summary>
    /// The total capacity of allowed items before reallocating
    /// </summary>
    public int Capacity;

    public FEntry(int startIndex, int size, int capacity)
    {
        StartIndex = startIndex;
        Size = size;
        Capacity = capacity;
    }

    public FEntry(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            StartIndex = reader.ReadInt32();
            Size = reader.ReadInt32();
            Capacity = reader.ReadInt32();
        }
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(StartIndex);
        writer.Write(Size);
        writer.Write(Capacity);
    }
}

public struct TEvaluationTreeEntryContainer<T>
{
    /// <summary>
    /// List of allocated entries for each allocated entry. Should only ever grow, never shrink. Shrinking would cause previously established handles to become invalid. */
    /// </summary>
    public FEntry[] Entries;
    /// <summary>
    /// Linear array of allocated entry contents. Once allocated, indices are never invalidated until Compact is called. Entries needing more capacity are re-allocated on the end of the array.
    /// </summary>
    public T[] Items;

    public TEvaluationTreeEntryContainer(FEntry[] entries, T[] items)
    {
        Entries = entries;
        Items = items;
    }

    public TEvaluationTreeEntryContainer(AssetBinaryReader reader, Func<T> valueReader)
    {
        if (reader != null)
        {
            var entriesamount = reader.ReadInt32();
            Entries = new FEntry[entriesamount];
            for (int i = 0; i < entriesamount; i++)
            {
                Entries[i] = new FEntry(reader);
            }

            int itemsamount = reader.ReadInt32();
            Items = new T[itemsamount];
            for (int i = 0; i < itemsamount; i++)
            {
                Items[i] = valueReader();
            }
        }
    }

    public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
    {
        writer.Write(Entries.Length);
        for (int i = 0; i < Entries.Length; i++)
        {
            Entries[i].Write(writer);
        }

        writer.Write(Items.Length);
        for (int i = 0; i < Items.Length; i++)
        {
            valueWriter(Items[i]);
        }
    }
}

public class FMovieSceneEvaluationTree(AssetBinaryReader reader)
{
    /// <summary> 
    /// This tree's root node
    /// </summary>
    public FMovieSceneEvaluationTreeNode RootNode = new FMovieSceneEvaluationTreeNode(reader);
    /// <summary>
    /// Segmented array of all child nodes within this tree (in no particular order)
    /// </summary>
    public TEvaluationTreeEntryContainer<FMovieSceneEvaluationTreeNode> ChildNodes = new(reader, () => new FMovieSceneEvaluationTreeNode(reader));

    public void Write(AssetBinaryWriter writer)
    {
        RootNode.Write(writer);
        ChildNodes.Write(writer, node => node.Write(writer));
    }
}

public class TMovieSceneEvaluationTree<T> : FMovieSceneEvaluationTree
{
    /// <summary>
    /// Tree data container that corresponds to FMovieSceneEvaluationTreeNode::DataID
    /// </summary>
    public TEvaluationTreeEntryContainer<T> Data;

    public TMovieSceneEvaluationTree(AssetBinaryReader reader, Func<T> valueReader) : base(reader)
    {
        if (reader != null) Data = new(reader, valueReader);
    }

    public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
    {
        base.Write(writer);
        Data.Write(writer, valueWriter);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneEvaluationTreeNode.cs`:

```cs
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A structure that uniquely identifies an entry within a TEvaluationTreeEntryContaine
/// </summary>
public struct FEvaluationTreeEntryHandle
{
    /// <summary>
    /// Specifies an index into TEvaluationTreeEntryContainer::Entries
    /// </summary>
    public int EntryIndex;

    public FEvaluationTreeEntryHandle(int _EntryIndex)
    {
        EntryIndex = _EntryIndex;
    }

    public FEvaluationTreeEntryHandle(AssetBinaryReader reader)
    {
        EntryIndex = reader.ReadInt32();
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(EntryIndex);
    }
}

/// <summary>
/// A handle to a node in an FMovieSceneEvaluationTree, defined in terms of an entry handle (corrsponding to FMovieSceneEvaluationTree::ChildNodes), and its child index
/// </summary>
public struct FMovieSceneEvaluationTreeNodeHandle
{
    /// <summary>
    /// Entry handle for the parent's children in FMovieSceneEvaluationTree::ChildNodes
    /// </summary>
    public FEvaluationTreeEntryHandle ChildrenHandle;
    /// <summary>
    /// The index of this child within its parent's children
    /// </summary>
    public int Index;

    public FMovieSceneEvaluationTreeNodeHandle(int _ChildrenHandle, int _Index)
    {
        ChildrenHandle.EntryIndex = _ChildrenHandle;
        Index = _Index;
    }

    public FMovieSceneEvaluationTreeNodeHandle(AssetBinaryReader reader)
    {
        ChildrenHandle = new FEvaluationTreeEntryHandle(reader.ReadInt32());
        Index = reader.ReadInt32();
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(ChildrenHandle.EntryIndex);
        writer.Write(Index);
    }
}

public class FMovieSceneEvaluationTreeNode
{
    /// <summary>
    /// The time-range that this node represents
    /// </summary>
    public TRange<FFrameNumber> Range;
    public FMovieSceneEvaluationTreeNodeHandle Parent;
    /// <summary>
    /// Identifier for the child node entries associated with this node (FMovieSceneEvaluationTree::ChildNodes)
    /// </summary>
    public FEvaluationTreeEntryHandle ChildrenID;
    /// <summary>
    /// Identifier for externally stored data entries associated with this node
    /// </summary>
    public FEvaluationTreeEntryHandle DataID;

    public FMovieSceneEvaluationTreeNode(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            Range = new(reader, () => new FFrameNumber(reader));
            Parent = new FMovieSceneEvaluationTreeNodeHandle(reader.ReadInt32(), reader.ReadInt32());
            ChildrenID = new FEvaluationTreeEntryHandle(reader.ReadInt32());
            DataID = new FEvaluationTreeEntryHandle(reader.ReadInt32());
        }
    }

    public void Write(AssetBinaryWriter writer)
    {
        Range.Write(writer, frame => frame.Write(writer));
        writer.Write(Parent.ChildrenHandle.EntryIndex);
        writer.Write(Parent.Index);
        writer.Write(ChildrenID.EntryIndex);
        writer.Write(DataID.EntryIndex);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneEventParametersPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public struct FMovieSceneEventParameters
{
    /** Soft object path to the type of this parameter payload */
    public FSoftObjectPath StructType;

    /** Serialized bytes that represent the payload. Serialized internally with FEventParameterArchive */
    public byte[] StructBytes;

    public FMovieSceneEventParameters(FSoftObjectPath structType, byte[] structBytes)
    {
        StructType = structType;
        StructBytes = structBytes;
    }

    public FMovieSceneEventParameters(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            StructType = new FSoftObjectPath(reader);
            var length = reader.ReadInt32();
            StructBytes = reader.ReadBytes(length);
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        var size = StructType.Write(writer);
        writer.Write(StructBytes.Length);
        size += sizeof(int);
        writer.Write(StructBytes);
        size += StructBytes.Length;
        return size;
    }
}

public class MovieSceneEventParametersPropertyData : PropertyData<FMovieSceneEventParameters>
{
    public MovieSceneEventParametersPropertyData(FName name) : base(name) { }

    public MovieSceneEventParametersPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneEventParameters");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneEventParameters(reader); 
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer);
    }
}

```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneFloatChannelPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneFloatChannelPropertyData : PropertyData<FMovieSceneFloatChannel>
{
    public MovieSceneFloatChannelPropertyData(FName name) : base(name) { }

    public MovieSceneFloatChannelPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneFloatChannel");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneFloatChannel(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        var offset = writer.BaseStream.Position;

        Value.Write(writer, writer.Write);

        return (int)(writer.BaseStream.Position - offset);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneFloatValuePropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneFloatValuePropertyData : PropertyData<FMovieSceneFloatValue>
{
    public MovieSceneFloatValuePropertyData(FName name) : base(name) { }

    public MovieSceneFloatValuePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneFloatValue");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneFloatValue(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        var offset = writer.BaseStream.Position;

        Value.Write(writer, writer.Write);

        return (int)(writer.BaseStream.Position - offset);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneFrameRangePropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneFrameRangePropertyData : PropertyData<TRange<FFrameNumber>>
{
    public MovieSceneFrameRangePropertyData(FName name) : base(name) { }

    public MovieSceneFrameRangePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneFrameRange");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new(reader, () => new FFrameNumber(reader));
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        var offset = writer.BaseStream.Position;

        Value.Write(writer, frame => frame.Write(writer));

        return (int)(writer.BaseStream.Position - offset);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneGenerationLedgerPropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneGenerationLedgerPropertyData : PropertyData
{
    /** Map of track identifiers to number of references within th template (generally 1, maybe >1 for shared tracks) */
    TMap<StructPropertyData, int> TrackReferenceCounts;

    /** Map of track signature to array of track identifiers that it created */
    TMap<Guid, StructPropertyData> TrackSignatureToTrackIdentifier;

    public MovieSceneGenerationLedgerPropertyData(FName name) : base(name) { }
    public MovieSceneGenerationLedgerPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneGenerationLedger");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        var NumReferenceCounts = reader.ReadInt32();
        TrackReferenceCounts = new TMap<StructPropertyData, int>();

        for (int i = 0; i < NumReferenceCounts; i++)
        {
            var identifier = new StructPropertyData(FName.DefineDummy(reader.Asset, "MovieSceneTrackIdentifier"), FName.DefineDummy(reader.Asset, "Generic"));
            identifier.Ancestry.Initialize(Ancestry, Name);
            identifier.Read(reader, false, 1, 0, PropertySerializationContext.StructFallback);
            TrackReferenceCounts.Add(identifier, reader.ReadInt32());
        }
        var SignatureToTrackIDs = reader.ReadInt32();
        TrackSignatureToTrackIdentifier = new TMap<Guid, StructPropertyData>();
        for (int i = 0; i < SignatureToTrackIDs; i++)
        {
            var guid = new Guid(reader.ReadBytes(16));
            var counts = reader.ReadInt32();
            if (counts != 1) throw new FormatException("Invalid TrackSignatureToTrackIdentifier count");
            var identifier = new StructPropertyData(FName.DefineDummy(reader.Asset, "MovieSceneTrackIdentifier"), FName.DefineDummy(reader.Asset, "Generic"));
            identifier.Ancestry.Initialize(Ancestry, Name);
            identifier.Read(reader, false, 1, 0, PropertySerializationContext.StructFallback);
            TrackSignatureToTrackIdentifier.Add(guid, identifier);
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        var offset = writer.BaseStream.Position;

        writer.Write(TrackReferenceCounts.Count);
        foreach (var kvp in TrackReferenceCounts)
        {
            kvp.Key.Write(writer, false, PropertySerializationContext.StructFallback);
            writer.Write(kvp.Value);
        }

        writer.Write(TrackSignatureToTrackIdentifier.Count);
        foreach (var kvp in TrackSignatureToTrackIdentifier)
        {
            writer.Write(kvp.Key.ToByteArray());
            writer.Write(1);
            kvp.Value.Write(writer, false, PropertySerializationContext.StructFallback);
        }

        return (int)(writer.BaseStream.Position - offset);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneSegment.cs`:

```cs
using UAssetAPI.CustomVersions;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// Information about a single segment of an evaluation track
/// </summary>
public class FMovieSceneSegment
{
    /// <summary> The segment's range </summary>
    public TRange<float> RangeOld;
    public TRange<FFrameNumber> Range;
    public int ID;
    /// <summary> Whether this segment has been generated yet or not </summary>
    public bool bAllowEmpty;
    /// <summary> Array of implementations that reside at the segment's range </summary>
    public StructPropertyData[] Impls;

    public FMovieSceneSegment()
    {

    }

    public FMovieSceneSegment(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            if (reader.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.FloatToIntConversion)
            {
                RangeOld = new TRange<float>(reader, reader.ReadSingle);
            }
            else
            {
                Range = new(reader, () => new FFrameNumber(reader));
            }

            if (reader.Asset.GetCustomVersion<FSequencerObjectVersion>() > FSequencerObjectVersion.EvaluationTree)
            {
                ID = reader.ReadInt32();
                bAllowEmpty = reader.ReadBooleanInt();
            }

            int length = reader.ReadInt32();
            Impls = new StructPropertyData[length];
            for (int i = 0; i < length; i++)
            {
                var data = new StructPropertyData(FName.DefineDummy(reader.Asset, "Impls"), FName.DefineDummy(reader.Asset, "SectionEvaluationData"));
                data.Read(reader, false, 1, 0, PropertySerializationContext.StructFallback);
                Impls[i] = data;
            }
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;
        if (writer.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.FloatToIntConversion)
        {
            RangeOld.Write(writer, writer.Write);
        }
        else
        {
            Range.Write(writer, frame => frame.Write(writer));
        }

        if (writer.Asset.GetCustomVersion<FSequencerObjectVersion>() > FSequencerObjectVersion.EvaluationTree)
        {
            writer.Write(ID);
            writer.Write(bAllowEmpty ? 1 : 0);
        }

        writer.Write(Impls.Length);
        for (int i = 0; i < Impls.Length; i++)
        {
            Impls[i]?.Write(writer, false, PropertySerializationContext.StructFallback);
        }

        return (int)(writer.BaseStream.Position - offset);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneSegmentPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneSegmentPropertyData : PropertyData<FMovieSceneSegment>
{
    public MovieSceneSegmentPropertyData(FName name) : base(name) { }
    
    public MovieSceneSegmentPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneSegment");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneSegment(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        return Value.Write(writer);
    }
}

public class MovieSceneSegmentIdentifierPropertyData : PropertyData<int>
{
    public MovieSceneSegmentIdentifierPropertyData(FName name) : base(name) { }

    public MovieSceneSegmentIdentifierPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneSegmentIdentifier");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadInt32();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(int);
    }
}

```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneTrackIdentifierPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class MovieSceneTrackIdentifierPropertyData : PropertyData<uint>
{
    public MovieSceneTrackIdentifierPropertyData(FName name) : base(name) { }

    public MovieSceneTrackIdentifierPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneTrackIdentifier");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadUInt32();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(uint);
    }
}

public class MovieSceneSequenceIDPropertyData : PropertyData<uint>
{
    public MovieSceneSequenceIDPropertyData(FName name) : base(name) { }

    public MovieSceneSequenceIDPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneSequenceID");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadUInt32();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return sizeof(uint);
    }
}

public class MovieSceneEvaluationKeyPropertyData : PropertyData<FMovieSceneEvaluationKey>
{
    public MovieSceneEvaluationKeyPropertyData(FName name) : base(name) { }

    public MovieSceneEvaluationKeyPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("MovieSceneEvaluationKey");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FMovieSceneEvaluationKey(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }
        
        return Value.Write(writer);
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Movies/MovieSceneValue.cs`:

```cs
using System;
using UAssetAPI.UnrealTypes.EngineEnums;
using UAssetAPI.CustomVersions;

namespace UAssetAPI.PropertyTypes.Structs;

public class FMovieSceneTangentData
{
    public float ArriveTangent;
    public float LeaveTangent;
    public float ArriveTangentWeight;
    public float LeaveTangentWeight;
    public ERichCurveTangentWeightMode TangentWeightMode;
    public byte[] padding;

    public FMovieSceneTangentData()
    {

    }

    public FMovieSceneTangentData(AssetBinaryReader reader)
    {
        if (reader != null)
        {
            ArriveTangent = reader.ReadSingle();
            LeaveTangent = reader.ReadSingle();
            if (reader.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannelCompletely)
            {
                TangentWeightMode = (ERichCurveTangentWeightMode)reader.ReadByte();
                ArriveTangentWeight = reader.ReadSingle();
                LeaveTangentWeight = reader.ReadSingle();
                padding = [];
            }
            else
            {
                ArriveTangentWeight = reader.ReadSingle();
                LeaveTangentWeight = reader.ReadSingle();
                TangentWeightMode = (ERichCurveTangentWeightMode)reader.ReadByte();
                padding = reader.ReadBytes(3);
            }
        }
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(ArriveTangent);
        writer.Write(LeaveTangent);
        if (writer.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannelCompletely)
        {
            writer.Write((byte)TangentWeightMode);
            writer.Write(ArriveTangentWeight);
            writer.Write(LeaveTangentWeight);
        }
        else
        {
            writer.Write(ArriveTangentWeight);
            writer.Write(LeaveTangentWeight);
            writer.Write((byte)TangentWeightMode);
        }
        writer.Write(padding);
    }
}

public class FMovieSceneValue<T>
{
    public T Value;
    public FMovieSceneTangentData Tangent;
    public ERichCurveInterpMode InterpMode;
    public ERichCurveTangentMode TangentMode;
    public byte[] padding;

    public FMovieSceneValue(AssetBinaryReader reader, T value)
    {
        Value = value;
        if (reader != null)
        {
            if (reader.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannelCompletely)
            {
                InterpMode = (ERichCurveInterpMode)reader.ReadByte();
                TangentMode = (ERichCurveTangentMode)reader.ReadByte();
                Tangent = new FMovieSceneTangentData(reader);
                padding = [];
            }
            else
            {
                Tangent = new FMovieSceneTangentData(reader);
                InterpMode = (ERichCurveInterpMode)reader.ReadByte();
                TangentMode = (ERichCurveTangentMode)reader.ReadByte();
                padding = reader.ReadBytes(2);
            }
        }
    }

    public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
    {
        valueWriter(Value);
        if (writer.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannelCompletely)
        {
            writer.Write((byte)InterpMode);
            writer.Write((byte)TangentMode);
            Tangent.Write(writer);
        }
        else
        {
            Tangent.Write(writer);
            writer.Write((byte)InterpMode);
            writer.Write((byte)TangentMode);
        }
        writer.Write(padding);
    }
}

public class FMovieSceneFloatValue(AssetBinaryReader reader) : FMovieSceneValue<float>(reader, reader?.ReadSingle() ?? 0) { }

public class FMovieSceneDoubleValue(AssetBinaryReader reader) : FMovieSceneValue<double>(reader, reader?.ReadDouble() ?? 0) { }
```

`UAssetAPI/PropertyTypes/Structs/Movies/NameCurveKeyPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public struct FNameCurveKey : IStruct<FNameCurveKey>
{
    public float Time;
    public FName Value;

    public FNameCurveKey(float time, FName value)
    {
        Time = time;
        Value = value;
    }

    public FNameCurveKey(AssetBinaryReader reader)
    {
        Time = reader.ReadSingle();
        Value = reader.ReadFName();
    }

    public static FNameCurveKey Read(AssetBinaryReader reader) => new FNameCurveKey(reader);

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        writer.Write(Time);
        writer.Write(Value);

        return (int)(writer.BaseStream.Position - offset);
    }

    public override string ToString() => $"({Time}, {Value})";

    public static FNameCurveKey FromString(string[] d, UAsset asset)
    {
        float.TryParse(d[0], out float time);
        FName value = FName.FromString(asset, d[1]);
        return new FNameCurveKey(time, value);
    }
}

public class NameCurveKeyPropertyData : BasePropertyData<FNameCurveKey>
{
    public NameCurveKeyPropertyData(FName name) : base(name) { }
    public NameCurveKeyPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("NameCurveKey");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Niagara/NiagaraDataInterfaceGPUParamInfoPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class NiagaraDataInterfaceGPUParamInfoPropertyData : BasePropertyData<FNiagaraDataInterfaceGPUParamInfo>
{
    public NiagaraDataInterfaceGPUParamInfoPropertyData(FName name) : base(name) { }

    public NiagaraDataInterfaceGPUParamInfoPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("NiagaraDataInterfaceGPUParamInfo");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Niagara/NiagaraVariablePropertyData.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class NiagaraDataChannelVariablePropertyData : NiagaraVariableBasePropertyData
{
    public NiagaraDataChannelVariablePropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public NiagaraDataChannelVariablePropertyData(FName name) : base(name) { }
    public NiagaraDataChannelVariablePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("NiagaraDataChannelVariable");
    public override FString PropertyType => CurrentPropertyType;
}

public class NiagaraVariableBasePropertyData : StructPropertyData
{
    public FName VariableName;
    public StructPropertyData TypeDef;

    public NiagaraVariableBasePropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public NiagaraVariableBasePropertyData(FName name) : base(name) { }
    public NiagaraVariableBasePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("NiagaraVariableBase");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (reader.Asset.GetEngineVersion() <= EngineVersion.VER_UE4_25)
        {
            StructType = FName.DefineDummy(reader.Asset, PropertyType);
            base.Read(reader, includeHeader, 1, 0, PropertySerializationContext.StructFallback);
            return;
        }

        VariableName = reader.ReadFName();
        TypeDef = new StructPropertyData(FName.DefineDummy(reader.Asset, "TypeDef"), FName.DefineDummy(reader.Asset, "NiagaraTypeDefinition"));
        TypeDef.Read(reader, false, 1, 0, serializationContext);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (writer.Asset.GetEngineVersion() <= EngineVersion.VER_UE4_25)
        {
            StructType = FName.DefineDummy(writer.Asset, PropertyType);
            return base.Write(writer, includeHeader, PropertySerializationContext.StructFallback);
        }

        var offset = writer.BaseStream.Position;
        writer.Write(VariableName);
        if (TypeDef == null) TypeDef = new StructPropertyData(FName.DefineDummy(writer.Asset, "TypeDef"), FName.DefineDummy(writer.Asset, "NiagaraTypeDefinition"));
        TypeDef.Write(writer, false);
        return (int)(writer.BaseStream.Position - offset);
    }

    public override void FromString(string[] d, UAsset asset)
    {
        VariableName = FName.FromString(asset, d[0]);
    }
}

public class NiagaraVariablePropertyData : NiagaraVariableBasePropertyData
{
    public byte[] VarData;

    public NiagaraVariablePropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public NiagaraVariablePropertyData(FName name) : base(name) { }
    public NiagaraVariablePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("NiagaraVariable");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        base.Read(reader, includeHeader, leng1, leng2, serializationContext);

        if (reader.Asset.GetEngineVersion() >= EngineVersion.VER_UE4_26)
        {
            int varDataSize = reader.ReadInt32();
            VarData = reader.ReadBytes(varDataSize);
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        int sz = base.Write(writer, includeHeader, serializationContext);
        if (writer.Asset.GetEngineVersion() <= EngineVersion.VER_UE4_25)
            return sz;

        if (VarData == null) VarData = Array.Empty<byte>();
        writer.Write(VarData.Length); sz += sizeof(int);
        writer.Write(VarData); sz += VarData.Length;
        return sz;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        base.FromString(d, asset);
        VarData = d[2].ConvertStringToByteArray();
    }
}

public class NiagaraVariableWithOffsetPropertyData : NiagaraVariableBasePropertyData
{
    public int VariableOffset;

    public NiagaraVariableWithOffsetPropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public NiagaraVariableWithOffsetPropertyData(FName name) : base(name) { }
    public NiagaraVariableWithOffsetPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("NiagaraVariableWithOffset");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        base.Read(reader, includeHeader, leng1, leng2, serializationContext);

        if (reader.Asset.GetEngineVersion() >= EngineVersion.VER_UE4_26)
            VariableOffset = reader.ReadInt32();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        int sz = base.Write(writer, includeHeader);
        if (writer.Asset.GetEngineVersion() <= EngineVersion.VER_UE4_25)
            return sz;

        writer.Write(VariableOffset);
        sz += sizeof(int);
        return sz;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        base.FromString(d, asset);
        VariableOffset = 0;
        if (int.TryParse(d[2], out int res)) VariableOffset = res;
    }
}
```

`UAssetAPI/PropertyTypes/Structs/Ranges/FloatRangePropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class FloatRangePropertyData : PropertyData
{
    public float LowerBound;
    public float UpperBound;

    public FloatRangePropertyData(FName name) : base(name) { }

    public FloatRangePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("FloatRange");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        LowerBound = reader.ReadSingle();
        UpperBound = reader.ReadSingle();
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(LowerBound);
        writer.Write(UpperBound);
        return sizeof(float) * 2;
    }

    public override void FromString(string[] d, UAsset asset)
    {
        if (float.TryParse(d[0], out float res1)) LowerBound = res1;
        if (float.TryParse(d[1], out float res2)) UpperBound = res2;
    }

    public override string ToString()
    {
        return "(" + LowerBound + ", " + UpperBound + ")";
    }
}
```

`UAssetAPI/PropertyTypes/Structs/RawStructPropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class RawStructPropertyData : PropertyData<byte[]>
{
    [JsonProperty]
    public FName StructType = null;
    [JsonProperty]
    public bool SerializeNone = true;
    [JsonProperty]
    public Guid StructGUID = Guid.Empty; // usually set to 0

    public RawStructPropertyData(FName name) : base(name) { }

    public RawStructPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("RawStructProperty");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader && !reader.Asset.HasUnversionedProperties)
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                if (PropertyTypeName is null) throw new FormatException("PropertyTypeName is required to read MapProperty with complete type names.");
                StructType = PropertyTypeName.GetParameter(0).GetName();
                //StructGUID
            }
            else
            {
                StructType = reader.ReadFName();
                if (reader.Asset.ObjectVersion >= ObjectVersion.VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG) StructGUID = new Guid(reader.ReadBytes(16));
            }
            this.ReadEndPropertyTag(reader);
        }

        Value = reader.ReadBytes((int)leng1);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                writer.Write(StructType);
                if (writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG) writer.Write(StructGUID.ToByteArray());
            }
            this.WriteEndPropertyTag(writer);
        }

        writer.Write(Value);
        return Value.Length;
    }
}

```

`UAssetAPI/PropertyTypes/Structs/Slate/DeprecateSlateVector2DPropertyData.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class DeprecateSlateVector2DPropertyData : BasePropertyData<FVector2f>
{
    public DeprecateSlateVector2DPropertyData(FName name) : base(name) { }

    public DeprecateSlateVector2DPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("DeprecateSlateVector2D");
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/Slate/FontDataPropertyData.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

public class FontDataPropertyData : PropertyData<FFontData>
{
    public FontDataPropertyData(FName name) : base(name) { }

    public FontDataPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("FontData");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FFontData(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        if (Value == null) Value = new FFontData();
        return Value.Write(writer);
    }
}

```

`UAssetAPI/PropertyTypes/Structs/SoftObjectPathPropertyData.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.PropertyTypes.Structs;

/// <summary>
/// A struct that contains a string reference to an object, either a top level asset or a subobject.
/// This can be used to make soft references to assets that are loaded on demand.
/// This is stored internally as an FName pointing to the top level asset (/package/path.assetname) and an option a string subobject path.
/// </summary>
public class SoftObjectPathPropertyData : PropertyData<FSoftObjectPath>
{
    /// <summary>Used in older versions of the Unreal Engine.</summary>
    [JsonProperty]
    public FString Path;

    public SoftObjectPathPropertyData(FName name) : base(name) { }

    public SoftObjectPathPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SoftObjectPath");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        if (reader.Asset.ObjectVersion < ObjectVersion.VER_UE4_ADDED_SOFT_OBJECT_PATH)
        {
            Path = reader.ReadFString();
        }
        else
        {
            Value = new FSoftObjectPath(reader);
        }
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        int here = (int)writer.BaseStream.Position;

        if (writer.Asset.ObjectVersion < ObjectVersion.VER_UE4_ADDED_SOFT_OBJECT_PATH)
        {
            writer.Write(Path);
        }
        else
        {
            Value.Write(writer);
        }

        return (int)writer.BaseStream.Position - here;
    }

    public override string ToString()
    {
        return "(" + Value.AssetPath.PackageName.ToString() + ", " + Value.AssetPath.AssetName.ToString() + ", " + Value.SubPathString.ToString() + ")";
    }

    public override void FromString(string[] d, UAsset asset)
    {
        if (asset.ObjectVersion < ObjectVersion.VER_UE4_ADDED_SOFT_OBJECT_PATH)
        {
            Path = FString.FromString(d[0]);
        }
        else
        {
            FName one = FName.FromString(asset, d[0]);
            FName two = FName.FromString(asset, d[1]);
            FString three = string.IsNullOrEmpty(d[2]) ? null : FString.FromString(d[2]);

            Value = new FSoftObjectPath(one, two, three);
        }
    }
}


/// <summary>
/// A struct that contains a string reference to a class. Can be used to make soft references to classes.
/// </summary>
public class SoftClassPathPropertyData : SoftObjectPathPropertyData
{
    public SoftClassPathPropertyData(FName name) : base(name) { }

    public SoftClassPathPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SoftClassPath");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}


public class SoftAssetPathPropertyData : SoftObjectPathPropertyData
{
    public SoftAssetPathPropertyData(FName name) : base(name) { }

    public SoftAssetPathPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("SoftAssetPath");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}

/// <summary>
/// A struct that contains a string reference to a class. Can be used to make soft references to classes.
/// </summary>
public class StringAssetReferencePropertyData : SoftObjectPathPropertyData
{
    public StringAssetReferencePropertyData(FName name) : base(name) { }

    public StringAssetReferencePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("StringAssetReference");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}

public class StringClassReferencePropertyData : SoftObjectPathPropertyData
{
    public StringClassReferencePropertyData(FName name) : base(name) { }

    public StringClassReferencePropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("StringClassReference");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;
}
```

`UAssetAPI/PropertyTypes/Structs/StructPropertyData.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using UAssetAPI.CustomVersions;
using UAssetAPI.ExportTypes;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI.PropertyTypes.Structs;

public class StructPropertyData : PropertyData<List<PropertyData>>
{
    [JsonProperty]
    public FName StructType = null;
    [JsonProperty]
    public bool SerializeNone = true;
    [JsonProperty]
    public Guid StructGUID = Guid.Empty; // usually set to 0
    [JsonProperty]
    public EClassSerializationControlExtension SerializationControl;
    [JsonProperty]
    public EOverriddenPropertyOperation Operation;

    /// <summary>
    /// Gets or sets the value associated with the specified key. This operation loops linearly, so it may not be suitable for high-performance environments.
    /// </summary>
    /// <param name="key">The key associated with the value to get or set.</param>
    public virtual PropertyData this[FName key]
    {
        get
        {
            if (Value == null) return null;

            for (int i = 0; i < Value.Count; i++)
            {
                if (Value[i].Name == key) return Value[i];
            }
            return null;
        }
        set
        {
            if (Value == null) Value = [];
            value.Name = key;

            for (int i = 0; i < Value.Count; i++)
            {
                if (Value[i].Name == key)
                {
                    Value[i] = value;
                    return;
                }
            }

            Value.Add(value);
        }
    }

    /// <summary>
    /// Gets or sets the value associated with the specified key. This operation loops linearly, so it may not be suitable for high-performance environments.
    /// </summary>
    /// <param name="key">The key associated with the value to get or set.</param>
    public virtual PropertyData this[string key]
    {
        get
        {
            return this[FName.FromString(Name?.Asset, key)];
        }
        set
        {
            this[FName.FromString(Name?.Asset, key)] = value;
        }
    }

    public StructPropertyData(FName name) : base(name)
    {
        Value = [];
    }

    public StructPropertyData(FName name, FName forcedType) : base(name)
    {
        StructType = forcedType;
        Value = [];
    }

    public StructPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("StructProperty");
    public override FString PropertyType => CurrentPropertyType;

    private void ReadOnce(AssetBinaryReader reader, Type T, long offset, long leng1)
    {
        if (Activator.CreateInstance(T, Name) is not PropertyData data) return;
        data.Offset = offset;
        data.Ancestry.Initialize(Ancestry, Name);
        // i think it's unnecessary
        data.PropertyTypeName = PropertyTypeName?.GetParameter(0);
        data.Read(reader, false, leng1);
        Value = new List<PropertyData> { data };
    }

    private void ReadNTPL(AssetBinaryReader reader, bool resetValue = true)
    {
        List<PropertyData> resultingList = resetValue ? new List<PropertyData>() : Value;
        PropertyData data = null;

        var unversionedHeader = new FUnversionedHeader(reader);
        while ((data = MainSerializer.Read(reader, Ancestry, StructType, FName.DefineDummy(reader.Asset, reader.Asset.InternalAssetPath + ((Ancestry?.Ancestors?.Count ?? 0) == 0 ? string.Empty : ("." + Ancestry.Parent))), unversionedHeader, true)) != null)
        {
            resultingList.Add(data);
        }

        Value = resultingList;
    }

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader && !reader.Asset.HasUnversionedProperties) // originally !isForced
        {
            if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                if (PropertyTypeName is null) throw new FormatException("PropertyTypeName is required to read StructProperty with complete type names.");
                StructType = PropertyTypeName.GetParameter(0).GetName();
            }
            else
            {
                StructType = reader.ReadFName();
                if (reader.Asset.ObjectVersion >= ObjectVersion.VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG) StructGUID = new Guid(reader.ReadBytes(16));
            }

            this.ReadEndPropertyTag(reader);
        }

        if (reader.Asset.Mappings != null && (StructType == null || StructType.Value.Value == "Generic") && reader.Asset.Mappings.TryGetPropertyData(Name, Ancestry, reader.Asset, out UsmapStructData strucDat1))
        {
            StructType = FName.DefineDummy(reader.Asset, strucDat1.StructType);
        }

        if (reader.Asset.HasUnversionedProperties && StructType?.Value?.Value == null)
        {
            throw new InvalidOperationException("Unable to determine struct type for struct " + Name.Value.Value + " in class " + Ancestry.Parent.Value.Value);
        }

        RegistryEntry targetEntry = null;
        string structTypeVal = StructType?.Value?.Value;
        if (structTypeVal != null) MainSerializer.PropertyTypeRegistry.TryGetValue(structTypeVal, out targetEntry);
        bool hasCustomStructSerialization = targetEntry != null && targetEntry.HasCustomStructSerialization && serializationContext != PropertySerializationContext.StructFallback;

        if (structTypeVal == "FloatRange")
        {
            // FloatRange is a special case; it can either be manually serialized as two floats (TRange<float>) or as a regular struct (FFloatRange), but the first is overridden to use the same name as the second
            // The best solution is to just check and see if the next bit is an FName or not

            int nextFourBytes = reader.ReadInt32();
            reader.BaseStream.Position -= sizeof(int);
            hasCustomStructSerialization = !(reader.Asset.HasUnversionedProperties || (nextFourBytes >= 0 && nextFourBytes < reader.Asset.GetNameMapIndexList().Count && reader.Asset.GetNameReference(nextFourBytes).Value.EndsWith("Bound")));
        }
        if (structTypeVal == "RichCurveKey" && reader.Asset.ObjectVersion < ObjectVersion.VER_UE4_SERIALIZE_RICH_CURVE_KEY) hasCustomStructSerialization = false;
        if (structTypeVal == "MovieSceneTrackIdentifier" && reader.Asset.GetCustomVersion<FEditorObjectVersion>() < FEditorObjectVersion.MovieSceneMetaDataSerialization) hasCustomStructSerialization = false;
        if (structTypeVal == "MovieSceneFloatChannel" && reader.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannelCompletely) hasCustomStructSerialization = false;
        if (structTypeVal == "MovieSceneFloatValue" && reader.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannel) hasCustomStructSerialization = false;
        if (structTypeVal == "MovieSceneTangentData" && reader.Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannel) hasCustomStructSerialization = false;
        if (structTypeVal == "FontData" && reader.Asset.GetCustomVersion<FEditorObjectVersion>() < FEditorObjectVersion.AddedFontFaceAssets) hasCustomStructSerialization = false;

        if (leng1 == 0)
        {
            SerializeNone = false;
            Value = [];
            return;
        }

        if (targetEntry != null && hasCustomStructSerialization)
        {
            ReadOnce(reader, targetEntry.PropertyType, reader.BaseStream.Position, leng1);
        }
        else
        {
            ReadNTPL(reader);
        }
    }

    public override void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
    {
        var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
        ancestryNew.SetAsParent(StructType, FName.DefineDummy(asset, asset.InternalAssetPath + (ancestrySoFar.Ancestors.Count == 0 ? string.Empty : ("." + ancestrySoFar.Parent))));

        if (Value != null)
        {
            foreach (var entry in Value) entry?.ResolveAncestries(asset, ancestryNew);
        }
        base.ResolveAncestries(asset, ancestrySoFar);
    }

    private int WriteOnce(AssetBinaryWriter writer)
    {
        if (Value.Count > 1) throw new InvalidOperationException("Structs with type " + StructType.Value.Value + " cannot have more than one entry");

        if (Value.Count == 0)
        {
            // populate fallback zero entry 
            if (Value == null) Value = new List<PropertyData>();
            Value.Clear();
            Value.Add(MainSerializer.TypeToClass(StructType, Name, Ancestry, Name, null, writer.Asset, null, 0, EPropertyTagFlags.None, 0, false));
        }
        Value[0].Offset = writer.BaseStream.Position;
        return Value[0].Write(writer, false);
    }

    private int WriteNTPL(AssetBinaryWriter writer)
    {
        int here = (int)writer.BaseStream.Position;

        List<PropertyData> allDat = Value;
        MainSerializer.GenerateUnversionedHeader(ref allDat, StructType, FName.DefineDummy(writer.Asset, writer.Asset.InternalAssetPath + ((Ancestry?.Ancestors?.Count ?? 0) == 0 ? string.Empty : ("." + Ancestry.Parent))), writer.Asset)?.Write(writer);
        foreach (var t in allDat)
        {
            MainSerializer.Write(t, writer, true);
        }
        if (!writer.Asset.HasUnversionedProperties) writer.Write(new FName(writer.Asset, "None"));
        return (int)writer.BaseStream.Position - here;
    }

    internal bool DetermineIfSerializeWithCustomStructSerialization(UAsset Asset, PropertySerializationContext serializationContext, out RegistryEntry targetEntry)
    {
        targetEntry = null;
        string structTypeVal = StructType?.Value?.Value;
        if (structTypeVal != null) MainSerializer.PropertyTypeRegistry.TryGetValue(structTypeVal, out targetEntry);
        bool hasCustomStructSerialization = targetEntry != null && targetEntry.HasCustomStructSerialization && serializationContext != PropertySerializationContext.StructFallback;

        if (structTypeVal == "FloatRange") hasCustomStructSerialization = Value.Count == 1 && Value[0] is FloatRangePropertyData;
        if (structTypeVal == "RichCurveKey" && Asset.ObjectVersion < ObjectVersion.VER_UE4_SERIALIZE_RICH_CURVE_KEY) hasCustomStructSerialization = false;
        if (structTypeVal == "MovieSceneTrackIdentifier" && Asset.GetCustomVersion<FEditorObjectVersion>() < FEditorObjectVersion.MovieSceneMetaDataSerialization) hasCustomStructSerialization = false;
        if (structTypeVal == "MovieSceneFloatChannel" && Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannelCompletely) hasCustomStructSerialization = false;
        if (structTypeVal == "MovieSceneFloatValue" && Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannel) hasCustomStructSerialization = false;
        if (structTypeVal == "MovieSceneTangentData" && Asset.GetCustomVersion<FSequencerObjectVersion>() < FSequencerObjectVersion.SerializeFloatChannel) hasCustomStructSerialization = false;
        if (structTypeVal == "FontData" && Asset.GetCustomVersion<FEditorObjectVersion>() < FEditorObjectVersion.AddedFontFaceAssets) hasCustomStructSerialization = false;
        return hasCustomStructSerialization;
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        // if available and needed, fetch StructType from mappings
        if (writer.Asset.Mappings != null && (StructType == null || StructType.Value.Value == "Generic") && writer.Asset.Mappings.TryGetPropertyData(Name, Ancestry, writer.Asset, out UsmapStructData strucDat1))
        {
            StructType = FName.DefineDummy(writer.Asset, strucDat1.StructType);
        }

        if (includeHeader && !writer.Asset.HasUnversionedProperties)
        {
            if (writer.Asset.ObjectVersionUE5 < ObjectVersionUE5.PROPERTY_TAG_COMPLETE_TYPE_NAME)
            {
                writer.Write(StructType);
                if (writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG) writer.Write(StructGUID.ToByteArray());
            }

            this.WriteEndPropertyTag(writer);
        }

        if (Value == null) Value = [];

        bool hasCustomStructSerialization = DetermineIfSerializeWithCustomStructSerialization(writer.Asset, serializationContext, out RegistryEntry targetEntry);
        if (targetEntry != null && hasCustomStructSerialization) return WriteOnce(writer);
        if (Value.Count == 0 && !SerializeNone) return 0;
        return WriteNTPL(writer);
    }

    // removed; we'll actually just use default PropertyData alg

    /*public override bool CanBeZero(UAsset asset)
    {
        if (StructType?.Value?.Value == "Guid")
        {
            return base.CanBeZero(asset);
        }
        return !DetermineIfSerializeWithCustomStructSerialization(asset, out _, out __) && base.CanBeZero(asset);
    }*/

    public override void FromString(string[] d, UAsset asset)
    {
        if (d[4] != null && d[4] != "Generic") StructType = asset.HasUnversionedProperties ? FName.DefineDummy(asset, d[4]) : FName.FromString(asset, d[4]);
        if (StructType == null) StructType = FName.DefineDummy(asset, "Generic");
    }

    protected override void HandleCloned(PropertyData res)
    {
        StructPropertyData cloningProperty = (StructPropertyData)res;
        cloningProperty.StructType = (FName)this.StructType?.Clone();
        cloningProperty.StructGUID = new Guid(this.StructGUID.ToByteArray());

        if (this.Value != null)
        {
            List<PropertyData> newData = new List<PropertyData>(this.Value.Count);
            for (int i = 0; i < this.Value.Count; i++)
            {
                newData.Add((PropertyData)this.Value[i].Clone());
            }
            cloningProperty.Value = newData;
        }
        else
        {
            cloningProperty.Value = null;
        }
    }
}
```

`UAssetAPI/UAPUtils.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using UAssetAPI.ExportTypes;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI
{
    public static class UAPUtils
    {
        public static string CurrentCommit = string.Empty;

        public static string SerializeJson(object obj, bool isFormatted)
        {
            return JsonConvert.SerializeObject(obj, isFormatted ? Formatting.Indented : Formatting.None, UAsset.jsonSettings);
        }

        public static List<T> FindAllInstances<T>(object parent) where T : class
        {
            HashSet<object> yaExplorado = new HashSet<object>();
            List<T> res = new List<T>();

            FindAllInstances(parent, yaExplorado, res);

            return res;
        }

        private static void FindAllInstances<T>(object value, HashSet<object> yaExplorado, List<T> res) where T : class
        {
            if (value == null) return;
            if (yaExplorado.Contains(value)) return;

            yaExplorado.Add(value);

            if (value is IEnumerable enumerable)
            {
                foreach (object item in enumerable)
                {
                    FindAllInstances<T>(item, yaExplorado, res);
                }
            }
            else
            {
                if (value is T match) res.Add(match);

                PropertyInfo[] properties = value.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty);
                foreach (PropertyInfo property in properties)
                {
                    if (property.GetIndexParameters().Length > 0) continue;
                    if (value is PropertyData && (property.Name == "PropertyType" || property.Name == "HasCustomStructSerialization")) continue;
                    FindAllInstances<T>(property.GetValue(value, null), yaExplorado, res);
                }

                FieldInfo[] fields = value.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                foreach (FieldInfo field in fields)
                {
                    FindAllInstances<T>(field.GetValue(value), yaExplorado, res);
                }
            }
        }

        public static T Clamp<T>(T val, T min, T max) where T : IComparable<T>
        {
            if (val.CompareTo(min) < 0) return min;
            else if (val.CompareTo(max) > 0) return max;
            else return val;
        }

        public static FieldInfo[] GetOrderedFields<T>()
        {
            return GetOrderedFields(typeof(T));
        }

        public static FieldInfo[] GetOrderedFields(Type t)
        {
            return t.GetFields().Where(fld => fld.IsDefined(typeof(DisplayIndexOrderAttribute), true)).OrderBy(fld => ((DisplayIndexOrderAttribute[])fld.GetCustomAttributes(typeof(DisplayIndexOrderAttribute), true))[0].DisplayingIndex).ToArray();
        }

        public static MemberInfo[] GetOrderedMembers<T>()
        {
            return GetOrderedMembers(typeof(T));
        }

        public static MemberInfo[] GetOrderedMembers(Type t)
        {
            return t.GetMembers().Where(fld => fld.IsDefined(typeof(DisplayIndexOrderAttribute), true)).OrderBy(fld => ((DisplayIndexOrderAttribute[])fld.GetCustomAttributes(typeof(DisplayIndexOrderAttribute), true))[0].DisplayingIndex).Where(x => x.MemberType == MemberTypes.Field || x.MemberType == MemberTypes.Property).ToArray();
        }

        // https://stackoverflow.com/a/33446914
        public static object GetValue(this MemberInfo memberInfo, object forObject)
        {
            switch (memberInfo.MemberType)
            {
                case MemberTypes.Field:
                    return ((FieldInfo)memberInfo).GetValue(forObject);
                case MemberTypes.Property:
                    return ((PropertyInfo)memberInfo).GetValue(forObject);
                default:
                    throw new NotImplementedException();
            }
        }

        public static void SetValue(this MemberInfo memberInfo, object forObject, object forVal)
        {
            switch (memberInfo.MemberType)
            {
                case MemberTypes.Field:
                    ((FieldInfo)memberInfo).SetValue(forObject, forVal);
                    break;
                case MemberTypes.Property:
                    ((PropertyInfo)memberInfo).SetValue(forObject, forVal);
                    break;
                default:
                    throw new NotImplementedException();
            }
        }


        public static FString GetImportNameReferenceWithoutZero(int j, UAsset asset)
        {
            FString refer = new FPackageIndex(j).ToImport(asset).ObjectName.Value;
            if (!asset.ContainsNameReference(refer)) return refer;
            return asset.GetNameReferenceWithoutZero(asset.SearchNameReference(refer));
        }

        public static uint[] InterpretAsGuidAndConvertToUnsignedInts(this string value)
        {
            Guid res = value.Trim().ConvertToGUID();
            return res.ToUnsignedInts();
        }

        // adapted from UAssetGUI - see NOTICE.md
        public static byte[] ConvertStringToByteArray(this string val)
        {
            if (string.IsNullOrWhiteSpace(val)) return Array.Empty<byte>();
            string[] rawStringArr = val.Split(' ');
            byte[] byteArr = new byte[rawStringArr.Length];
            for (int i = 0; i < rawStringArr.Length; i++) byteArr[i] = Convert.ToByte(rawStringArr[i], 16);
            return byteArr;
        }

        public static uint[] ToUnsignedInts(this Guid value)
        {
            byte[] vals = value.ToByteArray();
            uint[] res = new uint[4];
            res[0] = BitConverter.ToUInt32(vals, 0);
            res[1] = BitConverter.ToUInt32(vals, sizeof(uint));
            res[2] = BitConverter.ToUInt32(vals, sizeof(uint) * 2);
            res[3] = BitConverter.ToUInt32(vals, sizeof(uint) * 3);
            return res;
        }

        public static Guid GUID(uint value1, uint value2, uint value3, uint value4)
        {
            byte[] bytes = new byte[16];
            BitConverter.GetBytes(value1).CopyTo(bytes, 0);
            BitConverter.GetBytes(value2).CopyTo(bytes, sizeof(uint));
            BitConverter.GetBytes(value3).CopyTo(bytes, sizeof(uint) * 2);
            BitConverter.GetBytes(value4).CopyTo(bytes, sizeof(uint) * 3);
            return new Guid(bytes);
        }

        public static Guid ConvertToGUID(this string GuidString)
        {
            if (GuidString == null ||
            (GuidString[0] != '{') ||
            (GuidString[9] != '-') ||
            (GuidString[14] != '-') ||
            (GuidString[19] != '-') ||
            (GuidString[24] != '-') ||
            (GuidString[37] != '}'))
            {
                if (Guid.TryParse(GuidString, out Guid res1)) return res1;
                return Guid.Empty;
            }

            string byteText = GuidString.Substring(29, 8) + GuidString.Substring(20, 4) + GuidString.Substring(25, 4) + GuidString.Substring(10, 4) + GuidString.Substring(15, 4) + GuidString.Substring(1, 8);
            byte[] byteArr = ConvertHexStringToByteArray(byteText);
            Array.Reverse(byteArr);
            return new Guid(byteArr);
        }

        public static string ConvertToString(this Guid val)
        {
            byte[] byteArr = val.ToByteArray();
            Array.Reverse(byteArr);
            string bytes = BitConverter.ToString(byteArr).Replace("-", "");
            return ("{" + bytes.Substring(24, 8) + "-" + bytes.Substring(16, 4) + "-" + bytes.Substring(20, 4) + "-" + bytes.Substring(8, 4) + "-" + bytes.Substring(12, 4) + bytes.Substring(0, 8) + "}").ToUpperInvariant();
        }

        public static byte[] ConvertHexStringToByteArray(string hexString)
        {
            hexString = hexString.Replace(" ", string.Empty).Replace("-", string.Empty);

            byte[] data = new byte[hexString.Length / 2];
            for (int index = 0; index < data.Length; index++)
            {
                string byteValue = hexString.Substring(index * 2, 2);
                data[index] = byte.Parse(byteValue, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
            }

            return data;
        }

        public static long AlignPadding(long pos, int align)
        {
            long remainder = pos % align;
            return pos + (remainder == 0 ? remainder : (align - remainder));
        }

        public static int AlignPadding(int pos, int align)
        {
            return (int)AlignPadding((long)pos, align);
        }

        public static int DivideAndRoundUp(int a, int b)
        {
            return (a + b - 1) / b;
        }

        public static string FixDirectorySeparatorsForDisk(this string path)
        {
            return path.Replace('/', Path.DirectorySeparatorChar).Replace('\\', Path.DirectorySeparatorChar);
        }

        public static List<T> SortByDependencies<T>(this IEnumerable<T> allExports, IDictionary<T, IList<T>> dependencies)
        {
            var sortedSoFar = new List<T>();
            var visited = new HashSet<T>();

            foreach (var item in allExports) SortByDependenciesVisit(item, visited, sortedSoFar, dependencies);

            return sortedSoFar;
        }

        private static void SortByDependenciesVisit<T>(T item, HashSet<T> visited, List<T> sortedSoFar, IDictionary<T, IList<T>> dependencies)
        {
            if (!visited.Contains(item))
            {
                visited.Add(item);
                if (dependencies.ContainsKey(item))
                {
                    foreach (var dependency in dependencies[item]) SortByDependenciesVisit(dependency, visited, sortedSoFar, dependencies);
                }
                sortedSoFar.Add(item);
            }
            else
            {
                if (!sortedSoFar.Contains(item)) throw new FormatException("Cyclic dependency exists in preload dependency graph");
            }
        }
    }
}

```

`UAssetAPI/UAsset.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UAssetAPI.CustomVersions;
using UAssetAPI.ExportTypes;
using UAssetAPI.FieldTypes;
using UAssetAPI.JSON;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;
using UAssetAPI.Unversioned;

#if DEBUGTRACING
using PostSharp.Aspects;
using PostSharp.Serialization;
#endif

namespace UAssetAPI
{
    public interface INameMap
    {
        IReadOnlyList<FString> GetNameMapIndexList();
        void ClearNameIndexList();
        void SetNameReference(int index, FString value);
        FString GetNameReference(int index);
        bool ContainsNameReference(FString search);
        int SearchNameReference(FString search);
        int AddNameReference(FString name, bool forceAddDuplicates = false, bool skipFixes = false);
        bool CanCreateDummies();
    }

    [Flags]
    public enum CustomSerializationFlags : int
    {
        /// <summary>
        /// No flags.
        /// </summary>
        None = 0,

        /// <summary>
        /// Serialize all dummy FNames to the name map.
        /// </summary>
        NoDummies = 1,

        /// <summary>
        /// Skip Kismet bytecode serialization.
        /// </summary>
        SkipParsingBytecode = 2,

        /// <summary>
        /// Skip loading other assets referenced in preload dependencies. You may wish to set this flag when possible in multi-threading applications, since preload dependency loading could lead to file handle race conditions.
        /// </summary>
        SkipPreloadDependencyLoading = 4,

        /// <summary>
        /// Skip parsing exports at read time. Entries in the export map will be read as raw exports. You can manually parse exports with the <see cref="UAsset.ParseExport(AssetBinaryReader, int, bool)"/> method.
        /// </summary>
        SkipParsingExports = 8,

        /// <summary>
        /// Skip loading exports at read time altogether. Entries in the export map will be read as raw exports of zero length, so they cannot be manually parsed later. If this flag is set, SkipParsingExports will also effectively be automatically set regardless of whether or not it was already set manually.
        /// </summary>
        SkipLoadingExports = 16,
    }


    public class NameMapOutOfRangeException : FormatException
    {
        public FString RequiredName;

        public NameMapOutOfRangeException(FString requiredName) : base("Requested name \"" + requiredName + "\" not found in name map")
        {
            RequiredName = requiredName;
        }
    }

    public class InvalidMappingsException : InvalidOperationException
    {
        public InvalidMappingsException(string message = "Unversioned properties cannot be serialized without valid mappings") : base(message)
        {

        }
    }

    public class UnknownEngineVersionException : InvalidOperationException
    {
        public UnknownEngineVersionException(string message) : base(message)
        {

        }
    }

    /// <summary>
    /// Holds basic Unreal version numbers.
    /// </summary>
    public struct FEngineVersion
    {
        /// <summary>Major version number.</summary>
        public ushort Major;
        /// <summary>Minor version number.</summary>
        public ushort Minor;
        /// <summary>Patch version number.</summary>
        public ushort Patch;
        /// <summary>Changelist number. This is used by the engine to arbitrate when Major/Minor/Patch version numbers match.</summary>
        public uint Changelist;
        /// <summary>Branch name.</summary>
        public FString Branch;

        public void Write(UnrealBinaryWriter writer)
        {
            writer.Write(Major);
            writer.Write(Minor);
            writer.Write(Patch);
            writer.Write(Changelist);
            writer.Write(Branch);
        }

        public FEngineVersion(UnrealBinaryReader reader)
        {
            Major = reader.ReadUInt16();
            Minor = reader.ReadUInt16();
            Patch = reader.ReadUInt16();
            Changelist = reader.ReadUInt32();
            Branch = reader.ReadFString();
        }

        public FEngineVersion(ushort major, ushort minor, ushort patch, uint changelist, FString branch)
        {
            Major = major;
            Minor = minor;
            Patch = patch;
            Changelist = changelist;
            Branch = branch;
        }
    }

    /// <summary>
    /// Revision data for an Unreal package file.
    /// </summary>
    public class FGenerationInfo
    {
        /// <summary>Number of exports in the export map for this generation.</summary>
        public int ExportCount;
        /// <summary>Number of names in the name map for this generation.</summary>
        public int NameCount;

        public FGenerationInfo(int exportCount, int nameCount)
        {
            ExportCount = exportCount;
            NameCount = nameCount;
        }
    }

    /// <summary>
    /// Represents an Unreal Engine asset.
    /// </summary>
    public class UAsset : INameMap
    {
        /// <summary>
        /// Agent string to provide context in serialized JSON.
        /// </summary>
        [JsonProperty(Order = -99)]
        public string Info = "Serialized with UAssetAPI";

        /// <summary>
        /// The path of the file on disk that this asset represents. This does not need to be specified for regular parsing.
        /// </summary>
        [JsonIgnore]
        public string FilePath;

        /// <summary>
        /// The corresponding mapping data for the game that this asset is from. Optional unless unversioned properties are present.
        /// </summary>
        [JsonIgnore]
        public Usmap Mappings;

        /// <summary>
        /// List of custom serialization flags, used to override certain optional behavior in how UAssetAPI serializes assets.
        /// </summary>
        public CustomSerializationFlags CustomSerializationFlags;

        /// <summary>
        /// Should the asset be split into separate .uasset, .uexp, and .ubulk files, as opposed to one single .uasset file?
        /// </summary>
        public bool UseSeparateBulkDataFiles = false;

        /// <summary>
        /// Should this asset not serialize its engine and custom versions?
        /// </summary>
        public bool IsUnversioned;

        /// <summary>
        /// The licensee file version. Used by some games to add their own Engine-level versioning.
        /// </summary>
        public int FileVersionLicenseeUE;

        /// <summary>
        /// The object version of UE4 that will be used to parse this asset.
        /// </summary>
        public ObjectVersion ObjectVersion = ObjectVersion.UNKNOWN;

        /// <summary>
        /// The object version of UE5 that will be used to parse this asset. Set to <see cref="ObjectVersionUE5.UNKNOWN"/> for UE4 games.
        /// </summary>
        public ObjectVersionUE5 ObjectVersionUE5 = ObjectVersionUE5.UNKNOWN;

        /// <summary>
        /// All the custom versions stored in the archive.
        /// </summary>
        public List<CustomVersion> CustomVersionContainer = null;

        private EPackageFlags _packageFlags;
        /// <summary>
        /// The flags for this package.
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public EPackageFlags PackageFlags
        {
            get
            {
                return _packageFlags;
            }
            set
            {
                _packageFlags = value;
                _hasUnversionedPropertiesCacheDirty = true;
            }
        }

        private bool _hasUnversionedPropertiesCacheDirty = true;
        private bool _hasUnversionedPropertiesCache; // HasFlag is a little bit expensive so we cache the bool value for good measure
        /// <summary>
        /// Whether or not this asset uses unversioned properties.
        /// </summary>
        public bool HasUnversionedProperties
        {
            get
            {
                if (_hasUnversionedPropertiesCacheDirty)
                {
                    _hasUnversionedPropertiesCache = PackageFlags.HasFlag(EPackageFlags.PKG_UnversionedProperties);
                    _hasUnversionedPropertiesCacheDirty = false;
                }
                return _hasUnversionedPropertiesCache;
            }
        }

        /// <summary>
        /// Whether or not this asset has PKG_FilterEditorOnly flag.
        /// </summary>
        public bool IsFilterEditorOnly => PackageFlags.HasFlag(EPackageFlags.PKG_FilterEditorOnly);

        [JsonIgnore]
        internal volatile bool isSerializationTime = false;

        /// <summary>
        /// Internal list of name map entries. Do not directly add values to here under any circumstances; use <see cref="AddNameReference"/> instead
        /// </summary>
        [JsonProperty("NameMap", Order = -2)]
        internal List<FString> nameMapIndexList;

        /// <summary>
        /// Internal lookup for name map entries. Do not directly add values to here under any circumstances; use <see cref="AddNameReference"/> instead
        /// </summary>
        internal Dictionary<string, int> nameMapLookup = new Dictionary<string, int>();

        /// <summary>
        /// List of SoftObjectPath contained in this package.
        /// </summary>
        public List<FSoftObjectPath> SoftObjectPathList;

        /// <summary>
        /// Map of the gatherable text data.
        /// </summary>
        public List<FGatherableTextData> GatherableTextData;

        /// <summary>
        /// Map of object exports. UAssetAPI used to call these "categories."
        /// </summary>
        public List<Export> Exports;

        // TODO: sort in lexical order
        /// <summary>
        /// List of Searchable Names, by object containing them. Sorted to keep order consistent.
        /// </summary>
        public SortedDictionary<FPackageIndex, List<FName>> SearchableNames;

        /// <summary>
        /// Map of object full names to the thumbnails
        /// </summary>
        public Dictionary<string, FObjectThumbnail> Thumbnails;

        /// <summary>
        /// Tile information used by WorldComposition.
        /// Defines properties necessary for tile positioning in the world.
        /// </summary>
        public FWorldTileInfo WorldTileInfo;

        /// <summary>
        /// The number of null bytes appended to the end of the package header (.uasset file).
        /// This should typically be zero, but may be greater when reading assets generated by external tools.
        /// </summary>
        public int AppendedNullBytes;

        /// <summary>
        /// In MapProperties that have StructProperties as their keys or values, there is no universal, context-free way to determine the type of the struct.
        /// <para />
        /// To that end, this dictionary maps MapProperty names to the type of the structs within them (tuple of key struct type and value struct type) if they are not None-terminated property lists.
        /// </summary>
        [JsonIgnore]
        public Dictionary<string, Tuple<FString, FString>> MapStructTypeOverride = new Dictionary<string, Tuple<FString, FString>>()
        {
            { "ColorDatabase", new Tuple<FString, FString>(null, new FString("LinearColor")) },
            { "PlayerCharacterIDs", new Tuple<FString, FString>(new FString("Guid"), null) },
            { "m_PerConditionValueToNodeMap", new Tuple<FString, FString>(new FString("Guid"), null) },
            { "BindingIdToReferences", new Tuple<FString, FString>(new FString("Guid"), null) },
            { "UserParameterRedirects", new Tuple<FString, FString>(new FString("NiagaraVariable"), new FString("NiagaraVariable"))},
            { "Tracks", new Tuple<FString, FString>(new FString("MovieSceneTrackIdentifier"), null)},
            { "TrackReferenceCounts", new Tuple<FString, FString>(new FString("MovieSceneTrackIdentifier"), null)},
            { "SubSequences", new Tuple<FString, FString>(new FString("MovieSceneSequenceID"), null)},
            { "Hierarchy", new Tuple<FString, FString>(new FString("MovieSceneSequenceID"), null)},
            { "TrackSignatureToTrackIdentifier", new Tuple<FString, FString>(new FString("Guid"), new FString("MovieSceneTrackIdentifier"))},
            { "SoftwareCursors", new Tuple<FString, FString>(new FString("Guid"), new FString("SoftClassPath"))},
            { "ItemsToRefund", new Tuple<FString, FString>(new FString("Guid"), null) },
            { "PlayerCharacterIDMap", new Tuple<FString, FString>(new FString("Guid"), null) },
            { "RainChanceMinMaxPerWeatherState", new Tuple<FString, FString>(null, new FString("FloatRange")) },
            { "Assets", new Tuple<FString, FString>(new FString("Guid"), null) },
            { "PlanetOffsets", new Tuple<FString, FString>(null, new FString("Vector")) }
        };

        /// <summary>
        /// IN ENGINE VERSIONS BEFORE <see cref="ObjectVersion.VER_UE4_INNER_ARRAY_TAG_INFO"/>:
        /// <para />
        /// In ArrayProperties that have StructProperties as their keys or values, there is no universal, context-free way to determine the type of the struct. To that end, this dictionary maps ArrayProperty names to the type of the structs within them.
        /// </summary>
        [JsonIgnore]
        public Dictionary<string, FString> ArrayStructTypeOverride = new Dictionary<string, FString>()
        {
            { "Keys", new FString("RichCurveKey") }
        };

        internal void FixNameMapLookupIfNeeded()
        {
            if (nameMapIndexList.Count > 0 && nameMapLookup.Count == 0)
            {
                for (int i = 0; i < nameMapIndexList.Count; i++)
                {
                    nameMapLookup[nameMapIndexList[i].Value] = i;
                }
            }
        }

        /// <summary>
        /// Returns the name map as a read-only list of FStrings.
        /// </summary>
        /// <returns>The name map as a read-only list of FStrings.</returns>
        public IReadOnlyList<FString> GetNameMapIndexList()
        {
            FixNameMapLookupIfNeeded();
            return nameMapIndexList.AsReadOnly();
        }

        /// <summary>
        /// Clears the name map. This method should be used with extreme caution, as it may break unparsed references to the name map.
        /// </summary>
        public void ClearNameIndexList()
        {
            nameMapIndexList = new List<FString>();
            nameMapLookup = new Dictionary<string, int>();
        }

        /// <summary>
        /// Replaces a value in the name map at a particular index.
        /// </summary>
        /// <param name="index">The index to overwrite in the name map.</param>
        /// <param name="value">The value that will be replaced in the name map.</param>
        public void SetNameReference(int index, FString value)
        {
            FixNameMapLookupIfNeeded();
            nameMapIndexList[index] = value;
            nameMapLookup[value.Value] = index;
        }

        /// <summary>
        /// Gets a value in the name map at a particular index.
        /// </summary>
        /// <param name="index">The index to return the value at.</param>
        /// <returns>The value at the index provided.</returns>
        public FString GetNameReference(int index)
        {
            FixNameMapLookupIfNeeded();
            if (index < 0) return new FString(Convert.ToString(-index));
            if (index >= nameMapIndexList.Count) return new FString(Convert.ToString(index));
            return nameMapIndexList[index];
        }

        /// <summary>
        /// Gets a value in the name map at a particular index, but with the index zero being treated as if it is not valid.
        /// </summary>
        /// <param name="index">The index to return the value at.</param>
        /// <returns>The value at the index provided.</returns>
        public FString GetNameReferenceWithoutZero(int index)
        {
            FixNameMapLookupIfNeeded();
            if (index <= 0) return new FString(Convert.ToString(-index));
            if (index >= nameMapIndexList.Count) return new FString(Convert.ToString(index));
            return nameMapIndexList[index];
        }

        /// <summary>
        /// Checks whether or not the value exists in the name map.
        /// </summary>
        /// <param name="search">The value to search the name map for.</param>
        /// <returns>true if the value appears in the name map, otherwise false.</returns>
        public bool ContainsNameReference(FString search)
        {
            FixNameMapLookupIfNeeded();
            return nameMapLookup.ContainsKey(search.Value);
        }

        /// <summary>
        /// Searches the name map for a particular value.
        /// </summary>
        /// <param name="search">The value to search the name map for.</param>
        /// <returns>The index at which the value appears in the name map.</returns>
        /// <exception cref="UAssetAPI.NameMapOutOfRangeException">Thrown when the value provided does not appear in the name map.</exception>
        public int SearchNameReference(FString search)
        {
            //FixNameMapLookupIfNeeded();
            if (ContainsNameReference(search)) return nameMapLookup[search.Value];
            throw new NameMapOutOfRangeException(search);
        }

        /// <summary>
        /// Adds a new value to the name map.
        /// </summary>
        /// <param name="name">The value to add to the name map.</param>
        /// <param name="forceAddDuplicates">Whether or not to add a new entry if the value provided already exists in the name map.</param>
        /// <param name="skipFixes">Whether or not to skip other additional fixes made upon adding new entries to the name map. In nearly all cases, this should be false.</param>
        /// <returns>The index of the new value in the name map. If the value already existed in the name map beforehand, that index will be returned instead.</returns>
        /// <exception cref="ArgumentException">Thrown when forceAddDuplicates is false and the value provided is null or empty.</exception>
        public int AddNameReference(FString name, bool forceAddDuplicates = false, bool skipFixes = false)
        {
            FixNameMapLookupIfNeeded();

            if (!forceAddDuplicates)
            {
                if (name?.Value == null) throw new ArgumentException("Cannot add a null FString to the name map");
                if (name.Value == string.Empty) throw new ArgumentException("Cannot add an empty FString to the name map");
                if (ContainsNameReference(name)) return SearchNameReference(name);
            }

            if (isSerializationTime) throw new InvalidOperationException("Attempt to add name \"" + name + "\" to name map during serialization time");
            nameMapIndexList.Add(name);
            nameMapLookup[name.Value] = nameMapIndexList.Count - 1;
            if (!skipFixes) NamesReferencedFromExportDataCount = nameMapIndexList.Count; // needed for conversion to zen to include new names added by modders
            return nameMapIndexList.Count - 1;
        }

        /// <summary>
        /// Whether or not we can create dummies in this name map. If false, attempting to define a dummy will append to the name map instead.
        /// </summary>
        /// <returns>A boolean.</returns>
        public virtual bool CanCreateDummies()
        {
            if (isSerializationTime) return true;
            return (CustomSerializationFlags & CustomSerializationFlags.NoDummies) == 0;
        }

        /// <summary>
        /// Creates a MemoryStream from an asset path.
        /// </summary>
        /// <param name="p">The path to the input file.</param>
        /// <param name="loadUEXP">Whether to load the UEXP file. False only reads the UASSET.</param>
        /// <returns>A new MemoryStream that stores the binary data of the input file.</returns>
        public MemoryStream PathToStream(string p, bool loadUEXP = true)
        {
            using (FileStream origStream = File.Open(p, FileMode.Open, FileAccess.Read))
            {
                MemoryStream completeStream = new MemoryStream();
                origStream.CopyTo(completeStream);

                if (loadUEXP)
                {
                    UseSeparateBulkDataFiles = false;
                    try
                    {
                        var targetFile = Path.ChangeExtension(p, "uexp");
                        if (File.Exists(targetFile))
                        {
                            using (FileStream newStream = File.Open(targetFile, FileMode.Open))
                            {
                                completeStream.Seek(0, SeekOrigin.End);
                                newStream.CopyTo(completeStream);
                                UseSeparateBulkDataFiles = true;
                            }
                        }
                    }
                    catch (FileNotFoundException) { }
                }


                completeStream.Seek(0, SeekOrigin.Begin);
                return completeStream;
            }
        }

        /// <summary>
        /// Creates a BinaryReader from an asset path.
        /// </summary>
        /// <param name="p">The path to the input file.</param>
        /// <param name="loadUEXP">Whether to load the .uexp file. False only reads the .uasset file.</param>
        /// <returns>A new BinaryReader that stores the binary data of the input file.</returns>
        public AssetBinaryReader PathToReader(string p, bool loadUEXP = true)
        {
            return new AssetBinaryReader(PathToStream(p, loadUEXP), loadUEXP, this);
        }

        /// <summary>
        /// Gets or sets the export associated with the specified key. This operation loops linearly, so it may not be suitable for high-performance environments.
        /// </summary>
        /// <param name="key">The key associated with the export to get or set.</param>
        public virtual Export this[FName key]
        {
            get
            {
                for (int i = 0; i < Exports.Count; i++)
                {
                    if (Exports[i].ObjectName == key) return Exports[i];
                }
                return null;
            }
            set
            {
                value.ObjectName = key;
                for (int i = 0; i < Exports.Count; i++)
                {
                    if (Exports[i].ObjectName == key)
                    {
                        Exports[i] = value;
                        return;
                    }
                }

                Exports.Add(value);
            }
        }

        /// <summary>
        /// Gets or sets the export associated with the specified key. This operation loops linearly, so it may not be suitable for high-performance environments.
        /// </summary>
        /// <param name="key">The key associated with the export to get or set.</param>
        public virtual Export this[string key]
        {
            get
            {
                return this[FName.FromString(this, key)];
            }
            set
            {
                this[FName.FromString(this, key)] = value;
            }
        }

        /// <summary>
        /// Searches for and returns this asset's ClassExport, if one exists.
        /// </summary>
        /// <returns>The asset's ClassExport if one exists, otherwise null.</returns>
        public ClassExport GetClassExport()
        {
            foreach (Export cat in Exports)
            {
                if (cat is ClassExport bgcCat) return bgcCat;
            }
            return null;
        }

        /// <summary>
        /// Resolves the ancestry of all properties present in this asset.
        /// </summary>
        public virtual void ResolveAncestries()
        {
            if (WorldTileInfo != null) WorldTileInfo.ResolveAncestries(this, new AncestryInfo());
            if (Exports != null)
            {
                for (int i = 0; i < Exports.Count; i++) Exports[i]?.ResolveAncestries(this, new AncestryInfo());
            }
        }

        /// <summary>
        /// Attempt to find another asset on disk given an asset path (i.e. one starting with /Game/).
        /// </summary>
        /// <param name="path">The asset path.</param>
        /// <returns>The path to the file on disk, or null if none could be found.</returns>
        public virtual string FindAssetOnDiskFromPath(string path)
        {
            if (!path.StartsWith("/") || path.StartsWith("/Script")) return null;
            path = path.Substring(6) + ".uasset";

            string mappedPathOnDisk = string.Empty;
            bool foundMappedPath = false;

            var contentPart = Path.DirectorySeparatorChar + "Content";
            if (!string.IsNullOrEmpty(FilePath))
            {
                var fixedFilePath = FilePath.FixDirectorySeparatorsForDisk();
                var contentIndex = fixedFilePath.LastIndexOf(contentPart);

                // let's see if the current path has Content in it, then we can re-orient ourselves
                if (!foundMappedPath && contentIndex > 0)
                {
                    var contentDir = fixedFilePath.Substring(0, contentIndex + contentPart.Length);
                    mappedPathOnDisk = Path.Combine(contentDir, path.FixDirectorySeparatorsForDisk());
                    foundMappedPath = File.Exists(mappedPathOnDisk); // not worrying too much about race condition, we'll put a try catch later
                }

                if (!foundMappedPath)
                {
                    // let's see if it exists in the same directory
                    var rawFileName = Path.GetFileName(path);
                    mappedPathOnDisk = Path.Combine(Directory.GetParent(FilePath).FullName, Path.GetFileName(path));
                    foundMappedPath = File.Exists(mappedPathOnDisk);
                }
            }

            return foundMappedPath ? mappedPathOnDisk : null;
        }

        /// <summary>
        /// Sets the version of the Unreal Engine to use in serialization.
        /// </summary>
        /// <param name="newVersion">The new version of the Unreal Engine to use in serialization.</param>
        /// <exception cref="InvalidOperationException">Thrown when an invalid EngineVersion is specified.</exception>
        public void SetEngineVersion(EngineVersion newVersion)
        {
            if (newVersion == EngineVersion.UNKNOWN) return;
            if (!Enum.TryParse(Enum.GetName(typeof(EngineVersion), newVersion), out UE4VersionToObjectVersion bridgeVer)) throw new InvalidOperationException("Invalid engine version specified");
            ObjectVersion = (ObjectVersion)(int)bridgeVer;

            if (Enum.TryParse(Enum.GetName(typeof(EngineVersion), newVersion), out UE5VersionToObjectVersion bridgeVer2)) ObjectVersionUE5 = (ObjectVersionUE5)(int)bridgeVer2;

            CustomVersionContainer = GetDefaultCustomVersionContainer(newVersion);
        }

        public static EngineVersion GetEngineVersion(ObjectVersion objectVersion, ObjectVersionUE5 objectVersionUE5, List<CustomVersion> customVersionContainer)
        {
            // analyze all possible versions based off of the object version alone
            List<EngineVersion> allPossibleVersions = new List<EngineVersion>();
            int targetVer = (int)objectVersionUE5;
            while (allPossibleVersions.Count == 0 && targetVer >= (int)ObjectVersionUE5.INITIAL_VERSION)
            {
                allPossibleVersions = Enum.GetNames(typeof(UE5VersionToObjectVersion)).Where(n => ((int)Enum.Parse(typeof(UE5VersionToObjectVersion), n)).Equals(targetVer)).Select(str => (EngineVersion)Enum.Parse(typeof(EngineVersion), str)).ToList();
                targetVer -= 1;
            }
            targetVer = (int)objectVersion;
            while (allPossibleVersions.Count == 0 && targetVer > (int)ObjectVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE)
            {
                allPossibleVersions = Enum.GetNames(typeof(UE4VersionToObjectVersion)).Where(n => ((int)Enum.Parse(typeof(UE4VersionToObjectVersion), n)).Equals(targetVer)).Select(str => (EngineVersion)Enum.Parse(typeof(EngineVersion), str)).ToList();
                targetVer -= 1;
            }

            if (allPossibleVersions.Count == 0) return EngineVersion.UNKNOWN;
            if (allPossibleVersions.Count == 1 || customVersionContainer == null) return allPossibleVersions[0];

            // multiple possible versions; use custom versions to eliminate some
            EngineVersion minIntroduced = EngineVersion.VER_UE4_OLDEST_LOADABLE_PACKAGE;
            EngineVersion maxIntroduced = EngineVersion.VER_UE4_AUTOMATIC_VERSION_PLUS_ONE;
            foreach (CustomVersion entry in customVersionContainer)
            {
                if (entry.FriendlyName is null) continue;
                Type customVersionType = Type.GetType("UAssetAPI.CustomVersions." + MainSerializer.allNonLetters.Replace(entry.FriendlyName, string.Empty));
                if (customVersionType == null) continue;
                EngineVersion minIntroducedThis = GetIntroducedFromCustomVersionValue(customVersionType, entry.Version); // inclusive
                EngineVersion maxIntroducedThis = GetIntroducedFromCustomVersionValue(customVersionType, entry.Version + 1); // exclusive

                if (minIntroducedThis != EngineVersion.UNKNOWN && minIntroducedThis > minIntroduced) minIntroduced = minIntroducedThis;
                if (maxIntroducedThis != EngineVersion.UNKNOWN && maxIntroducedThis < maxIntroduced) maxIntroduced = maxIntroducedThis;
            }

            List<EngineVersion> finalPossibleVersions = new List<EngineVersion>();
            foreach (EngineVersion entry in allPossibleVersions)
            {
                if (entry >= minIntroduced && entry < maxIntroduced) finalPossibleVersions.Add(entry);
            }
            finalPossibleVersions.Sort();

            if (finalPossibleVersions.Count == 0) return allPossibleVersions[0]; // there must be a special set of custom versions; we'll just ignore our intuitions and go with the object version alone
            if (finalPossibleVersions.Count >= 1) return finalPossibleVersions[0];
            return EngineVersion.UNKNOWN;
        }

        private EngineVersion _cachedEngineVersion = EngineVersion.UNKNOWN;
        private bool _cachedEngineVersionDirty = true; // used only at serialization time to determine if we need to re-evaluate this

        /// <summary>
        /// Estimates the retail version of the Unreal Engine based on the object and custom versions.
        /// </summary>
        /// <returns>The estimated retail version of the Unreal Engine.</returns>
        public EngineVersion GetEngineVersion()
        {
            if (isSerializationTime)
            {
                if (_cachedEngineVersionDirty)
                {
                    _cachedEngineVersionDirty = false;
                    _cachedEngineVersion = UAsset.GetEngineVersion(ObjectVersion, ObjectVersionUE5, CustomVersionContainer);
                }
                return _cachedEngineVersion;
            }

            _cachedEngineVersionDirty = true;
            return UAsset.GetEngineVersion(ObjectVersion, ObjectVersionUE5, CustomVersionContainer);
        }

        private static EngineVersion GetIntroducedFromCustomVersionValue(Type customVersionType, int val)
        {
            var nm = Enum.GetName(customVersionType, val);
            if (nm == null) return EngineVersion.UNKNOWN;
            var attributes = customVersionType.GetMember(nm)?[0]?.GetCustomAttributes(typeof(IntroducedAttribute), false);
            if (attributes == null || attributes.Length <= 0) return EngineVersion.UNKNOWN;
            return ((IntroducedAttribute)attributes[0]).IntroducedVersion;
        }

        /// <summary>
        /// Fetches the version of a custom version in this asset.
        /// </summary>
        /// <param name="key">The GUID of the custom version to retrieve.</param>
        /// <returns>The version of the retrieved custom version.</returns>
        public int GetCustomVersion(Guid key)
        {
            for (int i = 0; i < CustomVersionContainer.Count; i++)
            {
                CustomVersion custVer = CustomVersionContainer[i];
                if (custVer.Key == key)
                {
                    return custVer.Version;
                }
            }

            return -1; // https://github.com/EpicGames/UnrealEngine/blob/99b6e203a15d04fc7bbbf554c421a985c1ccb8f1/Engine/Source/Runtime/Core/Private/Serialization/Archive.cpp#L578
        }

        /// <summary>
        /// Fetches the version of a custom version in this asset.
        /// </summary>
        /// <param name="friendlyName">The friendly name of the custom version to retrieve.</param>
        /// <returns>The version of the retrieved custom version.</returns>
        public int GetCustomVersion(string friendlyName)
        {
            for (int i = 0; i < CustomVersionContainer.Count; i++)
            {
                CustomVersion custVer = CustomVersionContainer[i];
                if (custVer.FriendlyName == friendlyName)
                {
                    return custVer.Version;
                }
            }

            return -1;
        }

        /// <summary>
        /// Fetches a custom version's enum value based off of its type.
        /// </summary>
        /// <typeparam name="T">The enum type of the custom version to retrieve.</typeparam>
        /// <returns>The enum value of the requested custom version.</returns>
        /// <exception cref="ArgumentException">Thrown when T is not an enumerated type.</exception>
        public T GetCustomVersion<T>()
        {
            Type customVersionEnumType = typeof(T);
            if (!customVersionEnumType.IsEnum) throw new ArgumentException("T must be an enumerated type");

            for (int i = 0; i < CustomVersionContainer.Count; i++)
            {
                CustomVersion custVer = CustomVersionContainer[i];
                if (custVer.FriendlyName == customVersionEnumType.Name)
                {
                    return (T)(object)custVer.Version;
                }
            }

            return (T)(object)-1;
        }

        private static ConcurrentDictionary<string, EngineVersion> cachedCustomVersionReflectionData = new ConcurrentDictionary<string, EngineVersion>();
        public static int GuessCustomVersionFromTypeAndEngineVersion(EngineVersion chosenVersion, Type typ)
        {
            string typeString = typ.ToString();
            string[] allValsRaw = Enum.GetNames(typ);

            // remove VersionPlusOne and LatestVersion entries, which are redundant
            // we absolutely need to remove LatestVersion because it's a duplicate of another entry, so the order of the two is not guaranteed; LatestVersion might come first
            string[] allVals = new string[allValsRaw.Length - 2];
            int j = 0;
            for (int i = 0; i < allValsRaw.Length; i++)
            {
                if (allValsRaw[i] != "VersionPlusOne" && allValsRaw[i] != "LatestVersion")
                {
                    allVals[j++] = allValsRaw[i];
                }
            }

            for (int i = allVals.Length - 1; i >= 0; i--)
            {
                string val = allVals[i];
                string cacheKey = typeString + val;

                var attributeIntroducedVersion = EngineVersion.UNKNOWN;
                if (cachedCustomVersionReflectionData.ContainsKey(cacheKey))
                {
                    attributeIntroducedVersion = cachedCustomVersionReflectionData[cacheKey];
                }
                else
                {
                    var attributes = typ.GetMember(val)?[0]?.GetCustomAttributes(typeof(IntroducedAttribute), false);
                    attributeIntroducedVersion = (attributes == null || attributes.Length <= 0) ? EngineVersion.UNKNOWN : ((IntroducedAttribute)attributes[0]).IntroducedVersion;
                    cachedCustomVersionReflectionData[cacheKey] = attributeIntroducedVersion;
                }

                if (attributeIntroducedVersion != EngineVersion.UNKNOWN && chosenVersion >= attributeIntroducedVersion) return i;
            }
            return -1;
        }

        /// <summary>
        /// Fetches a list of all default custom versions for a specific Unreal version.
        /// </summary>
        /// <param name="chosenVersion">The version of the engine to check against.</param>
        /// <returns>A list of all the default custom version values for the given engine version.</returns>
        public static List<CustomVersion> GetDefaultCustomVersionContainer(EngineVersion chosenVersion)
        {
            List<CustomVersion> res = new List<CustomVersion>();
            foreach (KeyValuePair<Guid, string> entry in CustomVersion.GuidToCustomVersionStringMap)
            {
                Type customVersionType = Type.GetType("UAssetAPI.CustomVersions." + entry.Value);
                if (customVersionType == null) continue;
                int guessedCustomVersion = GuessCustomVersionFromTypeAndEngineVersion(chosenVersion, customVersionType);
                if (guessedCustomVersion < 0) continue;
                res.Add(new CustomVersion(entry.Key, guessedCustomVersion));
            }
            return res;
        }

        private string _internalAssetPath = null;
        internal string InternalAssetPath
        {
            get
            {
                if (_internalAssetPath != null) return _internalAssetPath;
                if (this is UAsset uas)
                {
                    string folderName = uas.FolderName?.Value;
                    if (folderName != null && folderName != "None") return folderName;
                }
                return null;
            }
            set
            {
                _internalAssetPath = value;
            }
        }


        /// <summary>
        /// Read an export from disk.
        /// </summary>
        /// <param name="reader">The binary reader.</param>
        /// <param name="i">The index of the export in the export map to read.</param>
        /// <param name="read">Whether or not to serialize the body of the export. If false, simply converts to the respective sub-type.</param>
        public void ParseExport(AssetBinaryReader reader, int i, bool read = true)
        {
            reader.BaseStream.Seek(Exports[i].SerialOffset, SeekOrigin.Begin);
            ConvertExportToChildExportAndRead(reader, i, read);
        }

        public void ConvertExportToChildExportAndRead(AssetBinaryReader reader, int i, bool read = true)
        {
#pragma warning disable CS0168 // Variable is declared but never used
            try
            {
                long nextStarting = -1;
                if ((Exports.Count - 1) > i)
                {
                    nextStarting = Exports[i + 1].SerialOffset;
                }
                else
                {
                    var uas = (UAsset)reader.Asset;
                    nextStarting = uas.BulkDataStartOffset;
                    if (uas.SeaOfThievesGarbageData != null) nextStarting -= uas.SeaOfThievesGarbageData.Length;
                }

                FName exportClassTypeName = Exports[i].GetExportClassType();
                string exportClassType = exportClassTypeName.Value.Value;
                switch (exportClassType)
                {
                    case "Level":
                        Exports[i] = Exports[i].ConvertToChildExport<LevelExport>();
                        break;
                    case "Enum":
                    case "UserDefinedEnum":
                        Exports[i] = Exports[i].ConvertToChildExport<EnumExport>();
                        break;
                    case "Function":
                        Exports[i] = Exports[i].ConvertToChildExport<FunctionExport>();
                        break;
                    case "UserDefinedStruct":
                        Exports[i] = Exports[i].ConvertToChildExport<UserDefinedStructExport>();
                        break;
                    case "MetaData":
                        Exports[i] = Exports[i].ConvertToChildExport<MetaDataExport>();
                        break;
                    default:
                        if (exportClassType.EndsWith("DataTable"))
                        {
                            Exports[i] = Exports[i].ConvertToChildExport<DataTableExport>();
                        }
                        else if (exportClassType.EndsWith("StringTable"))
                        {
                            Exports[i] = Exports[i].ConvertToChildExport<StringTableExport>();
                        }
                        else if (exportClassType.EndsWith("BlueprintGeneratedClass"))
                        {
                            Exports[i] = Exports[i].ConvertToChildExport<ClassExport>();
                        }
                        else if (exportClassType == "ScriptStruct")
                        {
                            Exports[i] = Exports[i].ConvertToChildExport<StructExport>();
                        }
                        else if (MainSerializer.PropertyTypeRegistry.ContainsKey(exportClassType) || MainSerializer.AdditionalPropertyRegistry.Contains(exportClassType))
                        {
                            Exports[i] = Exports[i].ConvertToChildExport<PropertyExport>();
                        }
                        else
                        {
                            Exports[i] = Exports[i].ConvertToChildExport<NormalExport>();
                        }
                        break;
                }

                if (read) Exports[i].Read(reader, (int)nextStarting);

                // if we got a StructExport, let's modify mappings/MapStructTypeOverride if we can
                if (read && Exports[i] is StructExport fetchedStructExp && Exports[i] is not FunctionExport)
                {
                    // check to see if we can add some new map type overrides
                    if (fetchedStructExp.LoadedProperties != null)
                    {
                        foreach (FProperty entry in fetchedStructExp.LoadedProperties)
                        {
                            if (entry is FMapProperty fMapEntry)
                            {
                                FString keyOverride = null;
                                FString valueOverride = null;
                                if (fMapEntry.KeyProp is FStructProperty keyPropStruc && keyPropStruc.Struct.IsImport()) keyOverride = keyPropStruc.Struct.ToImport(this).ObjectName.Value;
                                if (fMapEntry.ValueProp is FStructProperty valuePropStruc && valuePropStruc.Struct.IsImport()) valueOverride = valuePropStruc.Struct.ToImport(this).ObjectName.Value;

                                MapStructTypeOverride[fMapEntry.Name.Value.Value] = new Tuple<FString, FString>(keyOverride, valueOverride);
                            }
                        }
                    }

                    // add schema if possible (!!!)
                    if (Mappings?.Schemas != null && fetchedStructExp.ObjectName?.ToString() != null)
                    {
                        string outer = null;
                        if (fetchedStructExp.OuterIndex.IsImport()) outer = fetchedStructExp.OuterIndex.ToImport(this).ObjectName.ToString();
                        if (fetchedStructExp.OuterIndex.IsExport()) outer = fetchedStructExp.OuterIndex.ToExport(this).ObjectName.ToString();

                        UsmapSchema newSchema = Usmap.GetSchemaFromStructExport(fetchedStructExp, Mappings?.AreFNamesCaseInsensitive ?? true);
                        if (newSchema != null)
                        {
                            newSchema.ModulePath = InternalAssetPath;
                            Mappings.Schemas[fetchedStructExp.ObjectName.ToString()] = newSchema;
                            if (!string.IsNullOrEmpty(newSchema.ModulePath)) Mappings.Schemas[newSchema.ModulePath + "." + (string.IsNullOrEmpty(outer) ? string.Empty : (outer + ".")) + fetchedStructExp.ObjectName.ToString()] = newSchema;
                        }
                    }
                }

                // if we got an enum, let's add to mappings enum map if we can
                if (read && Exports[i] is EnumExport fetchedEnumExp)
                {
                    string enumName = fetchedEnumExp.ObjectName?.ToString();
                    if (Mappings?.EnumMap != null && enumName != null)
                    {
                        var newEnum = new UsmapEnum(enumName, new ConcurrentDictionary<long, string>());
                        foreach (Tuple<FName, long> entry in fetchedEnumExp.Enum.Names)
                        {
                            newEnum.Values[entry.Item2] = entry.Item1.ToString();
                        }
                        Mappings.EnumMap[enumName] = newEnum;
                    }
                }

                if (read)
                {
                    long extrasLen = nextStarting - reader.BaseStream.Position;
                    if (extrasLen < 0)
                    {
                        throw new FormatException("Invalid padding at end of export " + (i + 1) + ": " + extrasLen + " bytes");
                    }
                    else
                    {
                        Exports[i].Extras = reader.ReadBytes((int)extrasLen);
                    }

                    Exports[i].alreadySerialized = true;
                }
            }
            catch (Exception ex)
            {
#if DEBUGVERBOSE
                Console.WriteLine("\nFailed to parse export " + (i + 1) + ": " + ex.ToString());
#endif
                if (read) reader.BaseStream.Seek(Exports[i].SerialOffset, SeekOrigin.Begin);
                Exports[i] = Exports[i].ConvertToChildExport<RawExport>();
                if (read) ((RawExport)Exports[i]).Data = reader.ReadBytes((int)Exports[i].SerialSize);
            }
#pragma warning restore CS0168 // Variable is declared but never used
        }


        internal static JsonSerializerSettings jsonSettings = new JsonSerializerSettings
        {
            TypeNameHandling = TypeNameHandling.Objects,
            NullValueHandling = NullValueHandling.Include,
            FloatParseHandling = FloatParseHandling.Double,
            ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
            MetadataPropertyHandling = MetadataPropertyHandling.ReadAhead,
            ContractResolver = new UAssetContractResolver(null),
            Converters = new List<JsonConverter>()
            {
                new FSignedZeroJsonConverter(),
                new FNameJsonConverter(null),
                new FStringTableJsonConverter(),
                new FStringJsonConverter(),
                new FPackageIndexJsonConverter(),
                new StringEnumConverter(),
                new GuidJsonConverter(),
                new ByteArrayJsonConverter()
            }
        };

        /// <summary>
        /// Checks whether or not this asset maintains binary equality when serialized.
        /// </summary>
        /// <returns>Whether or not the asset maintained binary equality.</returns>
        public bool VerifyBinaryEquality()
        {
            MemoryStream f = this.PathToStream(FilePath);
            f.Seek(0, SeekOrigin.Begin);
            MemoryStream newDataStream = WriteData();
            f.Seek(0, SeekOrigin.Begin);

            if (f.Length != newDataStream.Length) return false;

            const int CHUNK_SIZE = 1024;
            byte[] buffer = new byte[CHUNK_SIZE];
            byte[] buffer2 = new byte[CHUNK_SIZE];
            int lastRead1;
            while ((lastRead1 = f.Read(buffer, 0, buffer.Length)) > 0)
            {
                int lastRead2 = newDataStream.Read(buffer2, 0, buffer2.Length);
                if (lastRead1 != lastRead2) return false;
                if (!buffer.SequenceEqual(buffer2)) return false;
            }

            return true;
        }


        /// <summary>
        /// Finds the class path and export name of the SuperStruct of this asset, if it exists.
        /// </summary>
        /// <param name="parentClassPath">The class path of the SuperStruct of this asset, if it exists.</param>
        /// <param name="parentClassExportName">The export name of the SuperStruct of this asset, if it exists.</param>
        public virtual void GetParentClass(out FName parentClassPath, out FName parentClassExportName)
        {
            parentClassPath = null;
            parentClassExportName = null;

            var bgcCat = GetClassExport();
            if (bgcCat == null) return;
            if (bgcCat.SuperStruct == null) return;

            Import parentClassLink = bgcCat.SuperStruct.ToImport(this);
            if (parentClassLink == null) return;
            if (parentClassLink.OuterIndex.Index >= 0) return;

            parentClassExportName = parentClassLink.ObjectName;
            parentClassPath = parentClassLink.OuterIndex.ToImport(this).ObjectName;
        }

        internal bool hasFoundParentClassExportName = false;
        internal FName parentClassExportNameCache = null;
        internal FName parentClassExportName2Cache = null;
        internal virtual FName GetParentClassExportName(out FName modulePath)
        {
            if (!hasFoundParentClassExportName)
            {
                hasFoundParentClassExportName = true;
                GetParentClass(out parentClassExportName2Cache, out parentClassExportNameCache);
            }

            modulePath = parentClassExportName2Cache;
            return parentClassExportNameCache;
        }

        /// <summary>
        /// Adds a new import to the import map. This is equivalent to adding directly to the <see cref="Imports"/> list.
        /// </summary>
        /// <param name="li">The new import to add to the import map.</param>
        /// <returns>The FPackageIndex corresponding to the newly-added import.</returns>
        public FPackageIndex AddImport(Import li)
        {
            Imports.Add(li);
            return FPackageIndex.FromImport(Imports.Count - 1);
        }

        /// <summary>
        /// Searches for an import in the import map based off of certain parameters.
        /// </summary>
        /// <param name="classPackage">The ClassPackage that the requested import will have.</param>
        /// <param name="className">The ClassName that the requested import will have.</param>
        /// <param name="outerIndex">The CuterIndex that the requested import will have.</param>
        /// <param name="objectName">The ObjectName that the requested import will have.</param>
        /// <returns>The index of the requested import in the name map, or zero if one could not be found.</returns>
        public int SearchForImport(FName classPackage, FName className, FPackageIndex outerIndex, FName objectName)
        {
            int currentPos = 0;
            for (int i = 0; i < Imports.Count; i++)
            {
                currentPos--;
                if (classPackage == Imports[i].ClassPackage
                    && className == Imports[i].ClassName
                    && outerIndex == Imports[i].OuterIndex
                    && objectName == Imports[i].ObjectName)
                {
                    return currentPos;
                }

            }

            return 0;
        }

        /// <summary>
        /// Searches for an import in the import map based off of certain parameters.
        /// </summary>
        /// <param name="classPackage">The ClassPackage that the requested import will have.</param>
        /// <param name="className">The ClassName that the requested import will have.</param>
        /// <param name="objectName">The ObjectName that the requested import will have.</param>
        /// <returns>The index of the requested import in the name map, or zero if one could not be found.</returns>
        public int SearchForImport(FName classPackage, FName className, FName objectName)
        {
            int currentPos = 0;
            for (int i = 0; i < Imports.Count; i++)
            {
                currentPos--;
                if (classPackage == Imports[i].ClassPackage
                    && className == Imports[i].ClassName
                    && objectName == Imports[i].ObjectName)
                {
                    return currentPos;
                }

            }

            return 0;
        }

        /// <summary>
        /// Searches for an import in the import map based off of certain parameters.
        /// </summary>
        /// <param name="objectName">The ObjectName that the requested import will have.</param>
        /// <returns>The index of the requested import in the name map, or zero if one could not be found.</returns>
        public int SearchForImport(FName objectName)
        {
            int currentPos = 0;
            for (int i = 0; i < Imports.Count; i++)
            {
                currentPos--;
                if (objectName == Imports[i].ObjectName) return currentPos;
            }

            return 0;
        }

        public ISet<FName> OtherAssetsFailedToAccess = new HashSet<FName>();

        public virtual bool PullSchemasFromAnotherAsset(FName path)
        {
            if (CustomSerializationFlags.HasFlag(CustomSerializationFlags.SkipPreloadDependencyLoading)) return false;

            if (Mappings?.Schemas == null) return false;
            if (path?.Value?.Value == null) return false;
            if (!path.Value.Value.StartsWith("/") || path.Value.Value.StartsWith("/Script")) return false;
            var assetPath = path.ToString();
            string pathOnDisk = FindAssetOnDiskFromPath(assetPath);
            if (pathOnDisk == null)
            {
                OtherAssetsFailedToAccess.Add(path);
                return false;
            }

            // basic circular referencing guard
            if (Mappings.PathsAlreadyProcessedForSchemas.ContainsKey(assetPath))
            {
                return false;
            }

            bool success = false;
            try
            {
                Mappings.PathsAlreadyProcessedForSchemas[assetPath] = 1;

                // initial read to just fetch the FolderName
                UAsset otherAsset = new UAsset(this.ObjectVersion, this.ObjectVersionUE5, this.CustomVersionContainer.Select(item => (CustomVersion)item.Clone()).ToList(), this.Mappings);
                AssetBinaryReader otherReader = otherAsset.PathToReader(pathOnDisk);
                otherAsset.CustomSerializationFlags = CustomSerializationFlags.SkipLoadingExports | CustomSerializationFlags.SkipPreloadDependencyLoading;
                otherAsset.FilePath = pathOnDisk;
                otherAsset.Read(otherReader);

                // second read to get schemas
                otherAsset.InternalAssetPath = (otherAsset.FolderName != null && otherAsset.FolderName.ToString() != "None") ? otherAsset.FolderName.ToString() : assetPath;
                otherAsset.CustomSerializationFlags = CustomSerializationFlags.None;
                otherReader.BaseStream.Seek(0, SeekOrigin.Begin);
                otherAsset.Read(otherReader);

                // loading the asset will automatically add any new schemas to the mappings in-situ

                // add to failed map
                if (otherAsset.OtherAssetsFailedToAccess != null && OtherAssetsFailedToAccess != null)
                {
                    foreach (var entry in otherAsset.OtherAssetsFailedToAccess)
                    {
                        OtherAssetsFailedToAccess.Add(entry);
                    }
                }
            }
            catch
            {
                // if we fail to parse the other asset, that's perfectly fine; just move on
                success = false;
            }

            return success;
        }

        /// <summary>
        /// The package file version number when this package was saved.
        /// </summary>
        /// <remarks>
        ///     The lower 16 bits stores the UE3 engine version, while the upper 16 bits stores the UE4/licensee version. For newer packages this is -7.
        ///     <list type="table">
        ///         <listheader>
        ///             <version>Version</version>
        ///             <description>Description</description>
        ///         </listheader>
        ///         <item>
        ///             <version>-2</version>
        ///             <description>indicates presence of enum-based custom versions</description>
        ///         </item>
        ///         <item>
        ///             <version>-3</version>
        ///             <description>indicates guid-based custom versions</description>
        ///         </item>
        ///         <item>
        ///             <version>-4</version>
        ///             <description>indicates removal of the UE3 version. Packages saved with this ID cannot be loaded in older engine versions</description>
        ///         </item>
        ///         <item>
        ///             <version>-5</version>
        ///             <description>indicates the replacement of writing out the "UE3 version" so older versions of engine can gracefully fail to open newer packages</description>
        ///         </item>
        ///         <item>
        ///             <version>-6</version>
        ///             <description>indicates optimizations to how custom versions are being serialized</description>
        ///         </item>
        ///         <item>
        ///             <version>-7</version>
        ///             <description>indicates the texture allocation info has been removed from the summary</description>
        ///         </item>
        ///         <item>
        ///             <version>-8</version>
        ///             <description>indicates that the UE5 version has been added to the summary</description>
        ///         </item>
        ///         <item>
        ///             <version>-9</version>
        ///             <description>indicates a contractual change in when early exits are required based on FileVersionTooNew. At or after this LegacyFileVersion, we support changing the PackageFileSummary serialization format for all bytes serialized after FileVersionLicensee, and that format change can be conditional on any of the versions parsed before that point. All packageloaders that understand the -9 legacyfileformat are required to early exit without further serialization at that point if FileVersionTooNew is true.</description>
        ///         </item>
        ///     </list>
        /// </remarks>
        public int LegacyFileVersion;

        internal ECustomVersionSerializationFormat CustomVersionSerializationFormat
        {
            get
            {
                if (LegacyFileVersion > -3) return ECustomVersionSerializationFormat.Enums;
                if (LegacyFileVersion > -6) return ECustomVersionSerializationFormat.Guids;
                return ECustomVersionSerializationFormat.Optimized;
            }
        }

        /// <summary>
        /// The version to use for serializing data resources.
        /// </summary>

        public EObjectDataResourceVersion DataResourceVersion;

        /// <summary>
        /// List of serialized UObject binary/bulk data resources.
        /// </summary>
        public List<FObjectDataResource> DataResources;

        /// <summary>
        /// Whether or not this asset is loaded with the Event Driven Loader.
        /// </summary>
        public bool UsesEventDrivenLoader;

        /// <summary>
        /// Whether or not this asset serializes hashes in the name map.
        /// If null, this will be automatically determined based on the object version.
        /// </summary>
        public bool? WillSerializeNameHashes = null;

        /// <summary>
        /// Map of object imports. UAssetAPI used to call these "links."
        /// </summary>
        public List<Import> Imports;

        /// <summary>
        /// List of dependency lists for each export.
        /// </summary>
        public List<int[]> DependsMap;

        /// <summary>
        /// List of packages that are soft referenced by this package.
        /// </summary>
        public List<FString> SoftPackageReferenceList;

        /// <summary>
        /// Uncertain
        /// </summary>
        public byte[] AssetRegistryData;

        /// <summary>
        /// Any bulk data that is not stored in the export map.
        /// </summary>
        public byte[] BulkData;

        /// <summary>
        /// Some garbage data that appears to be present in certain games (e.g. Valorant)
        /// </summary>
        public byte[] ValorantGarbageData;

        /// <summary>
        /// Some garbage data that appears to be present in certain games (e.g. Sea of Thieves)
        /// null = not present
        /// empty array = present, but serialize as offset = 0, length = 0
        /// </summary>
        public byte[] SeaOfThievesGarbageData = null;

        /// <summary>
        /// Sea of Thieves garbage data offset
        /// </summary>
        internal int SeaOfThievesGarbageDataOffset = -1;

        /// <summary>
        /// Sea of Thieves garbage data length
        /// </summary>
        internal short SeaOfThievesGarbageDataLength = -1;

        /// <summary>
        /// Data about previous versions of this package.
        /// </summary>
        public List<FGenerationInfo> Generations;

        /// <summary>
        /// Current ID for this package. Effectively unused.
        /// </summary>
        public Guid PackageGuid;

        /// <summary>
        /// Current persistent ID for this package.
        /// </summary>
        public Guid PersistentGuid;

        /// <summary>
        /// Engine version this package was saved with. This may differ from CompatibleWithEngineVersion for assets saved with a hotfix release.
        /// </summary>
        public FEngineVersion RecordedEngineVersion;

        /// <summary>
        /// Engine version this package is compatible with. Assets saved by Hotfix releases and engine versions that maintain binary compatibility will have
        /// a CompatibleWithEngineVersion.Patch that matches the original release (as opposed to SavedByEngineVersion which will have a patch version of the new release).
        /// </summary>
        public FEngineVersion RecordedCompatibleWithEngineVersion;

        /// <summary>
        /// Streaming install ChunkIDs
        /// </summary>
        public int[] ChunkIDs;

        /// <summary>
        /// Value that is used by the Unreal Engine to determine if the package was saved by Epic, a licensee, modder, etc.
        /// </summary>
        public uint PackageSource;

        /// <summary>
        /// In UE4: "FolderName": The Generic Browser folder name that this package lives in. Usually "None" in cooked assets.
        /// In UE5: "PackageName": The package name the file was last saved with.
        /// </summary>
        public FString FolderName;

        /// <summary>
        /// A map of name map entries to hashes to use when serializing instead of the default engine hash algorithm. Useful when external programs improperly specify name map hashes and binary equality must be maintained.
        /// </summary>
        [JsonIgnore]
        public Dictionary<FString, uint> OverrideNameMapHashes;

        /// <summary>This is called "TotalHeaderSize" in UE4 where header refers to the whole summary, whereas in UAssetAPI "header" refers to just the data before the start of the name map</summary>
        internal int SectionSixOffset = 0;

        /// <summary>Number of names used in this package</summary>
        internal int NameCount = 0;

        /// <summary>Location into the file on disk for the name data</summary>
        internal int NameOffset;

        /// <summary>Localization ID of this package</summary>
        public FString LocalizationId;

        /// <summary>Number of names used in this package</summary>
        [JsonProperty]
        internal int SoftObjectPathsCount = 0;

        /// <summary>Location into the file on disk for the name data</summary>
        [JsonProperty]
        internal int SoftObjectPathsOffset = 0;

        /// <summary>Number of gatherable text data items in this package</summary>
        internal int GatherableTextDataCount;

        /// <summary>Location into the file on disk for the gatherable text data items</summary>
        internal int GatherableTextDataOffset;

        /// <summary>Location into the file on disk for the MetaData data</summary>
        internal int MetaDataOffset;

        /// <summary>Number of exports contained in this package</summary>
        internal int ExportCount = 0;

        /// <summary>Location into the file on disk for the "Export Details" data</summary>
        internal int ExportOffset = 0;

        /// <summary>Number of imports contained in this package</summary>
        internal int ImportCount = 0;

        /// <summary>Location into the file on disk for the ImportMap data</summary>
        internal int ImportOffset = 0;

        /// <summary>Number of cells contained in this package</summary>
        internal int CellExportCount;

        /// <summary>Location into the file on disk for the CellExportMap data</summary>
        internal int CellExportOffset;

        /// <summary>Number of cell imports contained in this package</summary>
        internal int CellImportCount;

        /// <summary>Location into the file on disk for the CellImportMap data</summary>
        internal int CellImportOffset;

        /// <summary>Location into the file on disk for the DependsMap data</summary>
        internal int DependsOffset = 0;

        /// <summary>Number of soft package references contained in this package</summary>
        internal int SoftPackageReferencesCount = 0;

        /// <summary>Location into the file on disk for the soft package reference list</summary>
        internal int SoftPackageReferencesOffset = 0;

        /// <summary>Location into the file on disk for the SearchableNamesMap data</summary>
        [JsonProperty]
        internal int SearchableNamesOffset;

        /// <summary>Thumbnail table offset</summary>
        [JsonProperty]
        internal int ThumbnailTableOffset;

        /// <summary>Hash of the Package's bytes when it was saved to disk.</summary>
        [JsonProperty]
        internal byte[] SavedHash;

        /// <summary>Should be zero</summary>
        [JsonProperty]
        internal uint CompressionFlags;

        /// <summary>List of additional packages that are needed to be cooked for this package. No longer used</summary>
        [JsonProperty]
        internal List<FString> AdditionalPackagesToCook;

        /// <summary>Location into the file on disk for the asset registry tag data</summary>
        internal int AssetRegistryDataOffset;

        /// <summary>Offset to the location in the file where the bulkdata starts</summary>
        internal long BulkDataStartOffset;

        /// <summary>Offset to the location in the file where the FWorldTileInfo data start</summary>
        internal int WorldTileInfoDataOffset;

        /// <summary>Number of preload dependencies contained in this package</summary>
        internal int PreloadDependencyCount;

        /// <summary>Location into the file on disk for the preload dependency data</summary>
        internal int PreloadDependencyOffset;

        [JsonProperty]
        internal int NamesReferencedFromExportDataCount;
        [JsonProperty]
        internal long PayloadTocOffset;
        [JsonProperty]
        internal int DataResourceOffset;

        [JsonProperty]
        internal bool doWeHaveAssetRegistryData = true;
        [JsonProperty]
        internal bool doWeHaveWorldTileInfo = true;

        [JsonIgnore]
        internal bool haveWeLoadedDependencies = false;
        private Dictionary<int, IList<int>> LoadDependencies()
        {
            haveWeLoadedDependencies = true;
            if (Exports == null) return null;

            Dictionary<int, IList<int>> depsMap = new Dictionary<int, IList<int>>();
            for (int i = 0; i < Exports.Count; i++)
            {
                Export newExport = Exports[i];
                List<FPackageIndex> deps = new List<FPackageIndex>();
                deps.AddRange(newExport.SerializationBeforeSerializationDependencies);
                deps.AddRange(newExport.SerializationBeforeCreateDependencies);
                //deps.Add(newExport.ClassIndex);
                //deps.Add(newExport.SuperIndex);

                depsMap[i + 1] = new List<int>();
                foreach (FPackageIndex dep in deps)
                {
                    if (dep.IsImport())
                    {
                        Import imp = dep.ToImport(this);
                        if (imp?.OuterIndex?.IsImport() ?? false)
                        {
                            Import outerIndex1 = imp?.OuterIndex?.ToImport(this);
                            FName sourcePath = outerIndex1?.ObjectName;
                            if (sourcePath?.ToString()?.StartsWith('/') ?? false)
                            {
                                this.PullSchemasFromAnotherAsset(sourcePath);
                            }
                            else if (outerIndex1?.OuterIndex?.IsImport() ?? false)
                            {
                                Import outerIndex2 = outerIndex1.OuterIndex.ToImport(this);
                                if (outerIndex2?.ObjectName?.ToString()?.StartsWith('/') ?? false)
                                {
                                    this.PullSchemasFromAnotherAsset(outerIndex2.ObjectName);
                                }
                            }
                        }
                    }

                    if (dep.IsExport())
                    {
                        depsMap[i + 1].Add(dep.Index);
                    }
                }
            }
            return depsMap;
        }

        /// <summary>
        /// Copies a portion of a stream to another stream.
        /// </summary>
        /// <param name="input">The input stream.</param>
        /// <param name="output">The output stream.</param>
        /// <param name="start">The offset in the input stream to start copying from.</param>
        /// <param name="leng">The length in bytes of the data to be copied.</param>
        internal static void CopySplitUp(Stream input, Stream output, int start, int leng)
        {
            input.Seek(start, SeekOrigin.Begin);
            output.Seek(0, SeekOrigin.Begin);

            byte[] buffer = new byte[32768];
            int read;
            while (leng > 0 && (read = input.Read(buffer, 0, Math.Min(buffer.Length, leng))) > 0)
            {
                output.Write(buffer, 0, read);
                leng -= read;
            }
        }

        /// <summary>
        /// Magic number for the .uasset format
        /// </summary>
        public static readonly uint UASSET_MAGIC = 0x9E2A83C1;

        /// <summary>
        /// Magic number for Ace Combat 7 encrypted .uasset format
        /// </summary>
        public static readonly uint ACE7_MAGIC = 0x37454341;

        /// <summary>
        /// Reads the initial portion of the asset (everything before the name map).
        /// </summary>
        /// <param name="reader"></param>
        /// <exception cref="UnknownEngineVersionException">Thrown when this is an unversioned asset and <see cref="ObjectVersion"/> is unspecified.</exception>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        private void ReadHeader(AssetBinaryReader reader)
        {
            reader.BaseStream.Seek(0, SeekOrigin.Begin);
            uint fileSignature = reader.ReadUInt32();
            if (fileSignature != UASSET_MAGIC) throw new FormatException("File signature mismatch");

            LegacyFileVersion = reader.ReadInt32();
            if (LegacyFileVersion != -4)
            {
                reader.ReadInt32(); // LegacyUE3Version for backwards-compatibility with UE3 games: always 864 in versioned assets, always 0 in unversioned assets
            }

            ObjectVersion fileVersionUE4 = (ObjectVersion)reader.ReadInt32();
            if (fileVersionUE4 > ObjectVersion.UNKNOWN)
            {
                IsUnversioned = false;
                ObjectVersion = fileVersionUE4;
            }
            else
            {
                IsUnversioned = true;
                if (Mappings != null && Mappings.FileVersionUE4 > 0) ObjectVersion = Mappings.FileVersionUE4;
                if (ObjectVersion == ObjectVersion.UNKNOWN) throw new UnknownEngineVersionException("Cannot begin serialization of an unversioned asset before an object version is manually specified");
            }

            if (LegacyFileVersion <= -8)
            {
                ObjectVersionUE5 fileVersionUE5 = (ObjectVersionUE5)reader.ReadInt32();
                if (fileVersionUE5 > ObjectVersionUE5.UNKNOWN) ObjectVersionUE5 = fileVersionUE5;
            }
            if (ObjectVersionUE5 == ObjectVersionUE5.UNKNOWN && Mappings != null && Mappings.FileVersionUE5 > 0) ObjectVersionUE5 = Mappings.FileVersionUE5;

            // if wasn't unversioned, we'll ignore the current custom version container and just read it from disk
            if (!IsUnversioned)
            {
                CustomVersionContainer = null;
            }

            FileVersionLicenseeUE = reader.ReadInt32();

            if (ObjectVersionUE5 >= ObjectVersionUE5.PACKAGE_SAVED_HASH)
            {
                SavedHash = reader.ReadBytes(20);
                SectionSixOffset = reader.ReadInt32();
            }

            // Custom versions container
            if (LegacyFileVersion <= -2)
            {
                CustomVersionContainer = reader.ReadCustomVersionContainer(CustomVersionSerializationFormat, CustomVersionContainer, Mappings);
            }

            if (ObjectVersionUE5 < ObjectVersionUE5.PACKAGE_SAVED_HASH)
            { 
                SectionSixOffset = reader.ReadInt32(); // 24
            }

            FolderName = reader.ReadFString();
            PackageFlags = (EPackageFlags)reader.ReadUInt32();
            NameCount = reader.ReadInt32();
            NameOffset = reader.ReadInt32();

            if (ObjectVersionUE5 >= ObjectVersionUE5.ADD_SOFTOBJECTPATH_LIST)
            {
                SoftObjectPathsCount = reader.ReadInt32();
                SoftObjectPathsOffset = reader.ReadInt32();
            }

            if (!IsFilterEditorOnly && ObjectVersion >= ObjectVersion.VER_UE4_ADDED_PACKAGE_SUMMARY_LOCALIZATION_ID)
            {
                LocalizationId = reader.ReadFString();
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_SERIALIZE_TEXT_IN_PACKAGES)
            {
                GatherableTextDataCount = reader.ReadInt32();
                GatherableTextDataOffset = reader.ReadInt32();
            }

            ExportCount = reader.ReadInt32();
            ExportOffset = reader.ReadInt32(); // 61
            ImportCount = reader.ReadInt32(); // 65
            ImportOffset = reader.ReadInt32(); // 69 (haha funny)

            if (ObjectVersionUE5 >= ObjectVersionUE5.VERSE_CELLS)
            {
                CellExportCount = reader.ReadInt32();
                CellExportOffset = reader.ReadInt32();
                CellImportCount = reader.ReadInt32();
                CellImportOffset = reader.ReadInt32();
            }

            if (ObjectVersionUE5 >= ObjectVersionUE5.METADATA_SERIALIZATION_OFFSET)
            {
                MetaDataOffset = reader.ReadInt32();
            }

            DependsOffset = reader.ReadInt32(); // 73
            if (ObjectVersion >= ObjectVersion.VER_UE4_ADD_STRING_ASSET_REFERENCES_MAP)
            {
                SoftPackageReferencesCount = reader.ReadInt32(); // 77
                SoftPackageReferencesOffset = reader.ReadInt32(); // 81
            }
            if (ObjectVersion >= ObjectVersion.VER_UE4_ADDED_SEARCHABLE_NAMES)
            {
                SearchableNamesOffset = reader.ReadInt32();
            }
            ThumbnailTableOffset = reader.ReadInt32();

            // valorant garbage data is here

            if (ObjectVersionUE5 < ObjectVersionUE5.PACKAGE_SAVED_HASH)
            {
                PackageGuid = new Guid(reader.ReadBytes(16));
            }

            if (!IsFilterEditorOnly)
            {
                PersistentGuid = ObjectVersion >= ObjectVersion.VER_UE4_ADDED_PACKAGE_OWNER 
                    ? new Guid(reader.ReadBytes(16))
                    : PackageGuid;

                if (ObjectVersion >= ObjectVersion.VER_UE4_ADDED_PACKAGE_OWNER &&
                    ObjectVersion < ObjectVersion.VER_UE4_NON_OUTER_PACKAGE_IMPORT)
                    reader.ReadBytes(16);
            }

            Generations = new List<FGenerationInfo>();
            int generationCount = reader.ReadInt32();
            if (generationCount < 0 || generationCount > 1e5) // failsafe for some specific games
            {
                reader.BaseStream.Position -= sizeof(int) + 16;
                ValorantGarbageData = reader.ReadBytes(8); // garbage data
                PackageGuid = new Guid(reader.ReadBytes(16));
                generationCount = reader.ReadInt32();
            }
            for (int i = 0; i < generationCount; i++)
            {
                int genNumExports = reader.ReadInt32();
                int genNumNames = reader.ReadInt32();
                Generations.Add(new FGenerationInfo(genNumExports, genNumNames));
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_ENGINE_VERSION_OBJECT)
            {
                RecordedEngineVersion = new FEngineVersion(reader);
            }
            else
            {
                RecordedEngineVersion = new FEngineVersion(4, 0, 0, reader.ReadUInt32(), FString.FromString(""));
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_PACKAGE_SUMMARY_HAS_COMPATIBLE_ENGINE_VERSION)
            {
                RecordedCompatibleWithEngineVersion = new FEngineVersion(reader);
            }
            else
            {
                RecordedCompatibleWithEngineVersion = RecordedEngineVersion;
            }

            CompressionFlags = reader.ReadUInt32();
            int numCompressedChunks = reader.ReadInt32();
            if (numCompressedChunks > 0) throw new FormatException("Asset has package-level compression and is likely too old to be parsed");

            PackageSource = reader.ReadUInt32();

            AdditionalPackagesToCook = new List<FString>();
            int numAdditionalPackagesToCook = reader.ReadInt32();
            for (int i = 0; i < numAdditionalPackagesToCook; i++)
            {
                AdditionalPackagesToCook.Add(reader.ReadFString());
            }

            if (LegacyFileVersion > -7)
            {
                int numTextureAllocations = reader.ReadInt32(); // unused
                if (numTextureAllocations > 0) throw new FormatException("Asset has texture allocation info and is likely too old to be parsed");
            }

            AssetRegistryDataOffset = reader.ReadInt32();
            BulkDataStartOffset = reader.ReadInt64();
            if (BulkDataStartOffset < -1e14 || BulkDataStartOffset > 1e14)
            {
                // probably Sea of Thieves, etc.
                reader.BaseStream.Position -= sizeof(long);
                SeaOfThievesGarbageDataOffset = reader.ReadInt32();
                SeaOfThievesGarbageDataLength = reader.ReadInt16();
                BulkDataStartOffset = reader.ReadInt64();
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO)
            {
                WorldTileInfoDataOffset = reader.ReadInt32();
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_CHANGED_CHUNKID_TO_BE_AN_ARRAY_OF_CHUNKIDS)
            {
                int numChunkIDs = reader.ReadInt32();
                ChunkIDs = new int[numChunkIDs];
                for (int i = 0; i < numChunkIDs; i++)
                {
                    ChunkIDs[i] = reader.ReadInt32();
                }
            }
            else if (ObjectVersion >= ObjectVersion.VER_UE4_ADDED_CHUNKID_TO_ASSETDATA_AND_UPACKAGE)
            {
                ChunkIDs = new int[1];
                ChunkIDs[0] = reader.ReadInt32();
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS)
            {
                PreloadDependencyCount = reader.ReadInt32();
                PreloadDependencyOffset = reader.ReadInt32();
            }

            // ue5 stuff
            NamesReferencedFromExportDataCount = ObjectVersionUE5 >= ObjectVersionUE5.NAMES_REFERENCED_FROM_EXPORT_DATA ? reader.ReadInt32() : NameCount;
            PayloadTocOffset = ObjectVersionUE5 >= ObjectVersionUE5.PAYLOAD_TOC ? reader.ReadInt64() : -1;
            DataResourceOffset = ObjectVersionUE5 >= ObjectVersionUE5.DATA_RESOURCES ? reader.ReadInt32() : -1;
        }

        /// <summary>
        /// Reads an asset into memory.
        /// </summary>
        /// <param name="reader">The input reader.</param>
        /// <param name="manualSkips">An array of export indices to skip parsing. For most applications, this should be left blank.</param>
        /// <param name="forceReads">An array of export indices that must be read, overriding entries in the manualSkips parameter. For most applications, this should be left blank.</param>
        /// <exception cref="UnknownEngineVersionException">Thrown when this is an unversioned asset and <see cref="ObjectVersion"/> is unspecified.</exception>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        public virtual void Read(AssetBinaryReader reader, int[] manualSkips = null, int[] forceReads = null)
        {
            reader.Asset = this;
            hasFoundParentClassExportName = false;

            // Header
            ReadHeader(reader);

            // Name map
            reader.BaseStream.Seek(NameOffset, SeekOrigin.Begin);

            OverrideNameMapHashes = new Dictionary<FString, uint>();
            ClearNameIndexList();
            for (int i = 0; i < NameCount; i++)
            {
                FString nameInMap = reader.ReadNameMapString(out uint hashes);
                if (hashes == 0)
                {
                    OverrideNameMapHashes[nameInMap] = 0;
                }
                else if (hashes >> 16 == 0 && nameInMap.Value == nameInMap.Value.ToLowerInvariant()) // WITH_CASE_PRESERVING_NAME = 0; if pre-4.23, do not serialize CasePreservingHash 
                {
                    nameInMap.IsCasePreserving = false;
                }
                AddNameReference(nameInMap, true, true);
            }

            SoftObjectPathList = null;
            if (SoftObjectPathsOffset > 0)
            {
                reader.BaseStream.Seek(SoftObjectPathsOffset, SeekOrigin.Begin);
                SoftObjectPathList = new List<FSoftObjectPath>();
                for (int i = 0; i < SoftObjectPathsCount; i++)
                {
                    SoftObjectPathList.Add(new FSoftObjectPath(reader, false));
                }
            }

            // Gatherable text
            if (GatherableTextDataOffset > 0 && GatherableTextDataCount > 0)
            {
                reader.BaseStream.Seek(GatherableTextDataOffset, SeekOrigin.Begin);

                GatherableTextData = new List<FGatherableTextData>();
                for (var i = 0; i < GatherableTextDataCount; i++)
                {
                    var namespaceName = reader.ReadFString();

                    var sourceString = reader.ReadFString();
                    var sourceStringMetaData = reader.ReadLocMetadataObject();
                    var sourceData = new FTextSourceData {SourceString = sourceString, SourceStringMetaData = sourceStringMetaData};

                    var contexts = new List<FTextSourceSiteContext>();
                    var contextsCount = reader.ReadInt32();
                    for (var j = 0; j < contextsCount; j++)
                    {
                        var keyName = reader.ReadFString();
                        var siteDescription = reader.ReadFString();
                        var isEditorOnly = reader.ReadInt32() > 0;
                        var isOptional = reader.ReadInt32() > 0;
                        var infoMetaData = reader.ReadLocMetadataObject();
                        var keyMetaData = reader.ReadLocMetadataObject();
                        var context = new FTextSourceSiteContext
                        {
                            KeyName = keyName,
                            SiteDescription = siteDescription,
                            IsEditorOnly = isEditorOnly,
                            IsOptional = isOptional,
                            InfoMetaData = infoMetaData,
                            KeyMetaData = keyMetaData
                        };
                        contexts.Add(context);
                    }

                    var textData = new FGatherableTextData { NamespaceName = namespaceName, SourceData = sourceData, SourceSiteContexts = contexts};
                    GatherableTextData.Add(textData);
                }
            }

            // Imports
            Imports = new List<Import>();
            if (ImportOffset > 0)
            {
                reader.BaseStream.Seek(ImportOffset, SeekOrigin.Begin);
                for (int i = 0; i < ImportCount; i++)
                {
                    Imports.Add(new Import(reader));
                }
            }

            // Export details
            Exports = new List<Export>();
            List<int> exportLoadOrder = new List<int>();
            if (ExportOffset > 0)
            {
                reader.BaseStream.Seek(ExportOffset, SeekOrigin.Begin);
                for (int i = 0; i < ExportCount; i++)
                {
                    var newExport = new Export(this, Array.Empty<byte>());
                    newExport.ReadExportMapEntry(reader);
                    Exports.Add(newExport);

                    /*string ect = newExport.GetExportClassType().Value.Value;
                    if (ect.EndsWith("BlueprintGeneratedClass"))
                    {
                        exportLoadOrder.Add(i);
                    }*/
                }
            }

            // DependsMap
            DependsMap = null;
            if (DependsOffset > 0 || (ObjectVersion > ObjectVersion.VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS && ObjectVersion < ObjectVersion.VER_UE4_64BIT_EXPORTMAP_SERIALSIZES)) // 4.14-4.15 the depends offset wasnt updated so always serialized as 0
            {
                DependsMap = new List<int[]>();
                if (DependsOffset > 0) reader.BaseStream.Seek(DependsOffset, SeekOrigin.Begin);
                for (int i = 0; i < ExportCount; i++)
                {
                    int size = reader.ReadInt32();
                    int[] data = new int[size];
                    for (int j = 0; j < size; j++)
                    {
                        data[j] = reader.ReadInt32();
                    }
                    DependsMap.Add(data);
                }
            }

            // SoftPackageReferenceList
            SoftPackageReferenceList = null;
            if (SoftPackageReferencesOffset > 0)
            {
                reader.BaseStream.Seek(SoftPackageReferencesOffset, SeekOrigin.Begin);
                SoftPackageReferenceList = new List<FString>();
                for (int i = 0; i < SoftPackageReferencesCount; i++)
                {
                    SoftPackageReferenceList.Add(ObjectVersion >= ObjectVersion.VER_UE4_ADDED_SOFT_OBJECT_PATH
                        ? FString.FromString(reader.ReadFName().ToString())
                        : reader.ReadFString());
                }
            }

            // AssetRegistryData
            AssetRegistryData = [];
            if (AssetRegistryDataOffset > 0)
            {
                reader.BaseStream.Seek(AssetRegistryDataOffset, SeekOrigin.Begin);
                /*
                int numAssets = reader.ReadInt32();
                for (int i = 0; i < numAssets; i++)
                {
                    throw new NotImplementedException("Asset registry data is not yet supported. Please let me know if you see this error message");
                }
                */

                // For now: read binary data until next offset
                int nextOffset = this.WorldTileInfoDataOffset;
                if (this.PreloadDependencyOffset >= 0 && nextOffset <= 0) nextOffset = this.PreloadDependencyOffset;
                if (SectionSixOffset > 0 && Exports.Count > 0 && nextOffset <= 0) nextOffset = (int)Exports[0].SerialOffset;
                if (nextOffset <= 0) nextOffset = (int)this.BulkDataStartOffset;
                AssetRegistryData = reader.ReadBytes(nextOffset - AssetRegistryDataOffset);
            }
            else
            {
                doWeHaveAssetRegistryData = false;
            }

            // SeaOfThievesGarbageData
            if (SeaOfThievesGarbageDataOffset > 0 && SeaOfThievesGarbageDataLength > 0)
            {
                long before = reader.BaseStream.Position;
                reader.BaseStream.Seek(SeaOfThievesGarbageDataOffset, SeekOrigin.Begin);
                SeaOfThievesGarbageData = reader.ReadBytes(SeaOfThievesGarbageDataLength);
                reader.BaseStream.Seek(before, SeekOrigin.Begin);
            }
            else if (SeaOfThievesGarbageDataOffset == 0 || SeaOfThievesGarbageDataLength == 0)
            {
                SeaOfThievesGarbageData = Array.Empty<byte>();
            }
            else
            {
                SeaOfThievesGarbageData = null;
            }

            BulkData = [];
            if (BulkDataStartOffset > 0 && reader.LoadUexp)
            {
                long before = reader.BaseStream.Position;
                reader.BaseStream.Seek(BulkDataStartOffset, SeekOrigin.Begin);
                BulkData = reader.ReadBytes((int)(reader.BaseStream.Length - BulkDataStartOffset));
                reader.BaseStream.Seek(before, SeekOrigin.Begin);
            }

            // WorldTileInfoDataOffset
            WorldTileInfo = null;
            if (WorldTileInfoDataOffset > 0)
            {
                reader.BaseStream.Seek(WorldTileInfoDataOffset, SeekOrigin.Begin);
                WorldTileInfo = new FWorldTileInfo();
                WorldTileInfo.Read(reader, this);
            }
            else
            {
                doWeHaveWorldTileInfo = false;
            }

            // PreloadDependencies
            if (PreloadDependencyOffset > 0) reader.BaseStream.Seek(PreloadDependencyOffset, SeekOrigin.Begin); // needed so that we're at a sensible offset for AppendedNullBytes if no preload deps
            for (int i = 0; i < Exports.Count; i++)
            {
                if (PreloadDependencyOffset <= 0) continue;
                if (Exports[i].FirstExportDependencyOffset < 0) continue; // not <= 0
                this.UsesEventDrivenLoader = true;

                reader.BaseStream.Seek(PreloadDependencyOffset, SeekOrigin.Begin);
                reader.BaseStream.Seek(Exports[i].FirstExportDependencyOffset * sizeof(int), SeekOrigin.Current);

                Exports[i].SerializationBeforeSerializationDependencies = new List<FPackageIndex>(Exports[i].SerializationBeforeSerializationDependenciesSize);
                for (int j = 0; j < Exports[i].SerializationBeforeSerializationDependenciesSize; j++) Exports[i].SerializationBeforeSerializationDependencies.Add(FPackageIndex.FromRawIndex(reader.ReadInt32()));

                Exports[i].CreateBeforeSerializationDependencies = new List<FPackageIndex>(Exports[i].CreateBeforeSerializationDependenciesSize);
                for (int j = 0; j < Exports[i].CreateBeforeSerializationDependenciesSize; j++) Exports[i].CreateBeforeSerializationDependencies.Add(FPackageIndex.FromRawIndex(reader.ReadInt32()));

                Exports[i].SerializationBeforeCreateDependencies = new List<FPackageIndex>(Exports[i].SerializationBeforeCreateDependenciesSize);
                for (int j = 0; j < Exports[i].SerializationBeforeCreateDependenciesSize; j++) Exports[i].SerializationBeforeCreateDependencies.Add(FPackageIndex.FromRawIndex(reader.ReadInt32()));

                Exports[i].CreateBeforeCreateDependencies = new List<FPackageIndex>(Exports[i].CreateBeforeCreateDependenciesSize);
                for (int j = 0; j < Exports[i].CreateBeforeCreateDependenciesSize; j++) Exports[i].CreateBeforeCreateDependencies.Add(FPackageIndex.FromRawIndex(reader.ReadInt32()));
            }

            // DataResources (5.3+)
            DataResources = null;
            if (DataResourceOffset > 0)
            {
                DataResources = new List<FObjectDataResource>();
                reader.BaseStream.Seek(DataResourceOffset, SeekOrigin.Begin);
                DataResourceVersion = (EObjectDataResourceVersion)reader.ReadUInt32();

                int count = reader.ReadInt32();
                for (int i = 0; i < count; i++)
                {
                    EObjectDataResourceFlags Flags = (EObjectDataResourceFlags)reader.ReadUInt32();

                    byte CookedIndex = 0;
                    if (DataResourceVersion >= EObjectDataResourceVersion.AddedCookedIndex)
                    {
                        CookedIndex = reader.ReadByte();
                    }

                    long SerialOffset = reader.ReadInt64();
                    long DuplicateSerialOffset = reader.ReadInt64();
                    long SerialSize = reader.ReadInt64();
                    long RawSize = reader.ReadInt64();
                    FPackageIndex OuterIndex = FPackageIndex.FromRawIndex(reader.ReadInt32());
                    uint LegacyBulkDataFlags = reader.ReadUInt32();

                    DataResources.Add(new FObjectDataResource(Flags, SerialOffset, DuplicateSerialOffset, SerialSize, RawSize, OuterIndex, LegacyBulkDataFlags, CookedIndex));
                }
            }

            // possible for some null bytes to exist at end of .uasset file as part of Archengius + trumank zen to legacy conversion project
            // as with other changes made by external tools that are accepted by the engine, we would like to maintain these bytes
            if (Exports.Count > 0)
            {
                long offsetDiff = Exports[0].SerialOffset - reader.BaseStream.Position;
                byte[] paddingBytes = reader.ReadBytes((int)offsetDiff);
                foreach (byte byt in paddingBytes)
                {
                    // if non-null then we expect that some serialization problem has occurred
                    if (byt != 0) throw new FormatException("Encountered additional non-null data at end of legacy header data");
                }
                AppendedNullBytes = paddingBytes.Length; // int rather than byte[] so easy to understand in JSON
            }

            if (reader.LoadUexp)
            {
                bool skipLoadingExports = CustomSerializationFlags.HasFlag(CustomSerializationFlags.SkipLoadingExports);
                bool skipParsingExports = skipLoadingExports || CustomSerializationFlags.HasFlag(CustomSerializationFlags.SkipParsingExports);

                // load dependencies, if needed and available
                Dictionary<int, IList<int>> depsMap = LoadDependencies();
                exportLoadOrder.AddRange(Enumerable.Range(1, Exports.Count).SortByDependencies(depsMap));

                // Export data
                if (SectionSixOffset > 0 && Exports.Count > 0)
                {
                    foreach (int exportIdx in exportLoadOrder)
                    {
                        int i = exportIdx - 1;

                        if (!skipLoadingExports) reader.BaseStream.Seek(Exports[i].SerialOffset, SeekOrigin.Begin);
                        if (skipParsingExports || skipLoadingExports || (manualSkips != null && manualSkips.Contains(i) && (forceReads == null || !forceReads.Contains(i))))
                        {
                            Exports[i] = Exports[i].ConvertToChildExport<RawExport>();
                            ((RawExport)Exports[i]).Data = skipLoadingExports ? Array.Empty<byte>() : reader.ReadBytes((int)Exports[i].SerialSize);
                            continue;
                        }

                        ConvertExportToChildExportAndRead(reader, i);
                    }

                    // catch any stragglers
                    for (int i = 0; i < Exports.Count; i++)
                    {
                        if (Exports[i].alreadySerialized) continue;

                        if (!skipLoadingExports) reader.BaseStream.Seek(Exports[i].SerialOffset, SeekOrigin.Begin);
                        if (skipParsingExports || skipLoadingExports || (manualSkips != null && manualSkips.Contains(i) && (forceReads == null || !forceReads.Contains(i))))
                        {
                            Exports[i] = Exports[i].ConvertToChildExport<RawExport>();
                            ((RawExport)Exports[i]).Data = skipLoadingExports ? Array.Empty<byte>() : reader.ReadBytes((int)Exports[i].SerialSize);
                            continue;
                        }

                        ConvertExportToChildExportAndRead(reader, i);
                    }
                }
            }
            else
            {
                // skip loading dependencies & parsing export data if we don't load uexp/exports
                // convert all exports as appropriate, but do no further reading
                for (int i = 0; i < Exports.Count; i++)
                {
                    if (manualSkips != null && manualSkips.Contains(i) && (forceReads == null || !forceReads.Contains(i)))
                    {
                        Exports[i] = Exports[i].ConvertToChildExport<RawExport>();
                        continue;
                    }

                    ConvertExportToChildExportAndRead(reader, i, false);
                }
            }

            // Searchable names
            if (SearchableNamesOffset > 0)
            {
                SearchableNames = new SortedDictionary<FPackageIndex, List<FName>>();
                reader.BaseStream.Seek(SearchableNamesOffset, SeekOrigin.Begin);
                var searchableNamesCount = reader.ReadInt32();
                
                for (int i = 0; i < searchableNamesCount; i++)
                {
                    var collectionIndex = reader.ReadInt32();
                    var collectionCount = reader.ReadInt32();
                    var searchableCollection = new List<FName>();
                    for (int j = 0; j < collectionCount; j++)
                    {
                        var searchableName = reader.ReadFName();
                        searchableCollection.Add(searchableName);
                    }

                    SearchableNames.Add(FPackageIndex.FromRawIndex(collectionIndex), searchableCollection);
                }
            }

            // Thumbnails
            if (ThumbnailTableOffset > 0)
            {
                reader.BaseStream.Seek(ThumbnailTableOffset, SeekOrigin.Begin);
                var thumbnailCount = reader.ReadInt32();
                var thumbnailOffsets = new Dictionary<string, int>();
                for (int i = 0; i < thumbnailCount; i++)
                {
                    var objectShortClassName = reader.ReadFString();
                    var objectPathWithoutPackageName = reader.ReadFString();
                    // TODO: handle UPackage thumbnails differently from usual assets

                    // TODO: FPackageName::FilenameToLongPackageName(InPackageFileName)
                    var objectName = $"{objectShortClassName} {objectPathWithoutPackageName}";

                    var fileOffset = reader.ReadInt32();

                    thumbnailOffsets[objectName] = fileOffset;
                }

                Thumbnails = new Dictionary<string, FObjectThumbnail>();
                foreach (var kv in thumbnailOffsets)
                {
                    reader.BaseStream.Seek(kv.Value, SeekOrigin.Begin);
                    Thumbnails[kv.Key] = reader.ReadObjectThumbnail();
                }
            }
        }

        /// <summary>
        /// Serializes the initial portion of the asset from memory.
        /// </summary>
        /// <returns>A byte array which represents the serialized binary data of the initial portion of the asset.</returns>
        private byte[] MakeHeader()
        {
            var stre = new MemoryStream(this.NameOffset);
            AssetBinaryWriter writer = new AssetBinaryWriter(stre, this);

            writer.Write(UAsset.UASSET_MAGIC);
            writer.Write(LegacyFileVersion);
            if (LegacyFileVersion != 4)
            {
                writer.Write(IsUnversioned ? 0 : 864);
            }

            if (IsUnversioned)
            {
                writer.Write(0);
            }
            else
            {
                writer.Write((int)ObjectVersion);
            }

            if (LegacyFileVersion <= -8)
            {
                if (IsUnversioned)
                {
                    writer.Write(0);
                }
                else
                {
                    writer.Write((int)ObjectVersionUE5);
                }
            }

            writer.Write(FileVersionLicenseeUE);

            if (ObjectVersionUE5 >= ObjectVersionUE5.PACKAGE_SAVED_HASH)
            {
                writer.Write(SavedHash);
                writer.Write(SectionSixOffset);
            }

            if (LegacyFileVersion <= -2)
            {
                if (IsUnversioned)
                {
                    writer.Write(0);
                }
                else
                {
                    writer.WriteCustomVersionContainer(CustomVersionSerializationFormat, CustomVersionContainer);
                }
            }

            if (ObjectVersionUE5 < ObjectVersionUE5.PACKAGE_SAVED_HASH)
            {
                writer.Write(SectionSixOffset);
            }

            writer.Write(FolderName);
            writer.Write((uint)PackageFlags);
            writer.Write(NameCount);
            writer.Write(NameOffset);
            if (ObjectVersionUE5 >= ObjectVersionUE5.ADD_SOFTOBJECTPATH_LIST)
            {
                writer.Write(SoftObjectPathsCount);
                writer.Write(SoftObjectPathsOffset);
            }
            if (!IsFilterEditorOnly && ObjectVersion >= ObjectVersion.VER_UE4_ADDED_PACKAGE_SUMMARY_LOCALIZATION_ID)
            {
                writer.Write(LocalizationId);
            }
            if (ObjectVersion >= ObjectVersion.VER_UE4_SERIALIZE_TEXT_IN_PACKAGES)
            {
                writer.Write(GatherableTextDataCount);
                writer.Write(GatherableTextDataOffset);
            }
            writer.Write(ExportCount);
            writer.Write(ExportOffset); // 61
            writer.Write(ImportCount); // 65
            writer.Write(ImportOffset); // 69 (haha funny)

            if (ObjectVersionUE5 >= ObjectVersionUE5.VERSE_CELLS)
            {
                writer.Write(CellExportCount);
                writer.Write(CellExportOffset);
                writer.Write(CellImportCount);
                writer.Write(CellImportOffset);
            }

            if (ObjectVersionUE5 >= ObjectVersionUE5.METADATA_SERIALIZATION_OFFSET)
            {
                writer.Write(MetaDataOffset);
            }

            writer.Write(DependsOffset); // 73
            if (ObjectVersion >= ObjectVersion.VER_UE4_ADD_STRING_ASSET_REFERENCES_MAP)
            {
                writer.Write(SoftPackageReferencesCount); // 77
                writer.Write(SoftPackageReferencesOffset); // 81
            }
            if (ObjectVersion >= ObjectVersion.VER_UE4_ADDED_SEARCHABLE_NAMES)
            {
                writer.Write(SearchableNamesOffset);
            }
            writer.Write(ThumbnailTableOffset);

            if (ValorantGarbageData != null && ValorantGarbageData.Length > 0) writer.Write(ValorantGarbageData);

            if (ObjectVersionUE5 < ObjectVersionUE5.PACKAGE_SAVED_HASH)
            {
                writer.Write(PackageGuid.ToByteArray());
            }

            if (!IsFilterEditorOnly)
            {
                if (ObjectVersion >= ObjectVersion.VER_UE4_ADDED_PACKAGE_OWNER)
                    writer.Write(PersistentGuid.ToByteArray());

                // The owner persistent guid was added in VER_UE4_ADDED_PACKAGE_OWNER but removed in the next version VER_UE4_NON_OUTER_PACKAGE_IMPORT
                if (ObjectVersion >= ObjectVersion.VER_UE4_ADDED_PACKAGE_OWNER &&
                    ObjectVersion < ObjectVersion.VER_UE4_NON_OUTER_PACKAGE_IMPORT)
                {
                    writer.Write(new byte[16]);
                }
            }
            writer.Write(Generations.Count);
            for (int i = 0; i < Generations.Count; i++)
            {
                Generations[i].ExportCount = ExportCount;
                Generations[i].NameCount = NameCount;
                writer.Write(Generations[i].ExportCount);
                writer.Write(Generations[i].NameCount);
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_ENGINE_VERSION_OBJECT)
            {
                RecordedEngineVersion.Write(writer);
            }
            else
            {
                writer.Write(RecordedEngineVersion.Changelist);
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_PACKAGE_SUMMARY_HAS_COMPATIBLE_ENGINE_VERSION)
            {
                RecordedCompatibleWithEngineVersion.Write(writer);
            }

            writer.Write(CompressionFlags);
            writer.Write((int)0); // numCompressedChunks
            writer.Write(PackageSource);
            writer.Write(AdditionalPackagesToCook.Count);
            for (int i = 0; i < AdditionalPackagesToCook.Count; i++)
            {
                writer.Write(AdditionalPackagesToCook[i]);
            }

            if (LegacyFileVersion > -7)
            {
                writer.Write((int)0); // numTextureAllocations
            }

            writer.Write(AssetRegistryDataOffset);
            if (SeaOfThievesGarbageData != null)
            {
                if (SeaOfThievesGarbageData.Length == 0)
                {
                    writer.Write((int)0);
                    writer.Write((short)0);
                }
                else
                {
                    writer.Write((int)(BulkDataStartOffset - SeaOfThievesGarbageData.Length));
                    writer.Write((short)SeaOfThievesGarbageData.Length);
                }
            }
            writer.Write(BulkDataStartOffset);

            if (ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO)
            {
                writer.Write(WorldTileInfoDataOffset);
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_CHANGED_CHUNKID_TO_BE_AN_ARRAY_OF_CHUNKIDS)
            {
                writer.Write(ChunkIDs.Length);
                for (int i = 0; i < ChunkIDs.Length; i++)
                {
                    writer.Write(ChunkIDs[i]);
                }
            }
            else if (ObjectVersion >= ObjectVersion.VER_UE4_ADDED_CHUNKID_TO_ASSETDATA_AND_UPACKAGE)
            {
                writer.Write(ChunkIDs[0]);
            }

            if (ObjectVersion >= ObjectVersion.VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS)
            {
                writer.Write(PreloadDependencyCount);
                writer.Write(PreloadDependencyOffset);
            }

            // ue5 stuff
            if (ObjectVersionUE5 >= ObjectVersionUE5.NAMES_REFERENCED_FROM_EXPORT_DATA)
            {
                writer.Write(NamesReferencedFromExportDataCount);
            }

            if (ObjectVersionUE5 >= ObjectVersionUE5.PAYLOAD_TOC)
            {
                writer.Write(PayloadTocOffset);
            }

            if (ObjectVersionUE5 >= ObjectVersionUE5.DATA_RESOURCES)
            {
                writer.Write(DataResourceOffset);
            }

            return stre.ToArray();
        }

        /// <summary>
        /// Serializes an asset from memory.
        /// </summary>
        /// <returns>A new MemoryStream containing the full binary data of the serialized asset.</returns>
        public virtual MemoryStream WriteData()
        {
            isSerializationTime = true;

            // resolve ancestries
            ResolveAncestries();

            // load deps if needed (i.e. asset was loaded from json)
            if (!haveWeLoadedDependencies) LoadDependencies();

            var stre = new MemoryStream();
            try
            {
                AssetBinaryWriter writer = new AssetBinaryWriter(stre, this);

                // Header
                writer.Seek(0, SeekOrigin.Begin);
                writer.Write(MakeHeader());

                // Name map
                this.NameOffset = (int)writer.BaseStream.Position;
                this.NameCount = this.nameMapIndexList.Count;
                for (int i = 0; i < this.nameMapIndexList.Count; i++)
                {
                    // this is not really the right custom version, i don't think the change was documented but it was in 4.23
                    bool disableCasePreservingHash = !nameMapIndexList[i].IsCasePreserving && this.GetCustomVersion<FReleaseObjectVersion>() < FReleaseObjectVersion.PropertiesSerializeRepCondition;
                    writer.Write(disableCasePreservingHash ? CRCGenerator.ToLower(nameMapIndexList[i], false) : nameMapIndexList[i]);

                    if (WillSerializeNameHashes == true || (WillSerializeNameHashes == null && ObjectVersion >= ObjectVersion.VER_UE4_NAME_HASHES_SERIALIZED))
                    {
                        if (OverrideNameMapHashes != null && OverrideNameMapHashes.ContainsKey(nameMapIndexList[i]))
                        {
                            writer.Write(OverrideNameMapHashes[nameMapIndexList[i]]);
                        }
                        else
                        {
                            writer.Write(CRCGenerator.GenerateHash(nameMapIndexList[i], disableCasePreservingHash, writer.Asset.GetEngineVersion() == EngineVersion.VER_UE4_20));
                        }
                    }
                }

                // soft object paths
                if (SoftObjectPathList != null)
                {
                    this.SoftObjectPathsOffset = (int)writer.BaseStream.Position;
                    this.SoftObjectPathsCount = SoftObjectPathList.Count;

                    for (int i = 0; i < SoftObjectPathList.Count; i++)
                    {
                        SoftObjectPathList[i].Write(writer, false);
                    }
                }
                else
                {
                    this.SoftObjectPathsOffset = 0;
                }

                // Gatherable text
                if (!IsFilterEditorOnly && GatherableTextData != null)
                {
                    GatherableTextDataOffset = (int)writer.BaseStream.Position;
                    GatherableTextDataCount = GatherableTextData.Count;

                    foreach (var gatherableTextData in GatherableTextData)
                    {
                        writer.Write(gatherableTextData.NamespaceName);

                        writer.Write(gatherableTextData.SourceData.SourceString);
                        writer.Write(gatherableTextData.SourceData.SourceStringMetaData);

                        writer.Write(gatherableTextData.SourceSiteContexts.Count);
                        foreach (var context in gatherableTextData.SourceSiteContexts)
                        {
                            writer.Write(context.KeyName);
                            writer.Write(context.SiteDescription);
                            writer.Write(context.IsEditorOnly ? 1 : 0);
                            writer.Write(context.IsOptional ? 1 : 0);
                            writer.Write(context.InfoMetaData);
                            writer.Write(context.KeyMetaData);
                        }
                    }
                }

                // Imports
                if (this.Imports.Count > 0)
                {
                    this.ImportOffset = (int)writer.BaseStream.Position;
                    this.ImportCount = this.Imports.Count;
                    for (int i = 0; i < this.Imports.Count; i++)
                    {
                        writer.Write(this.Imports[i].ClassPackage);
                        writer.Write(this.Imports[i].ClassName);
                        writer.Write(this.Imports[i].OuterIndex.Index);
                        writer.Write(this.Imports[i].ObjectName);
                        if (writer.Asset.ObjectVersion >= ObjectVersion.VER_UE4_NON_OUTER_PACKAGE_IMPORT
                            && !writer.Asset.IsFilterEditorOnly)
                            writer.Write(this.Imports[i].PackageName);
                        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.OPTIONAL_RESOURCES) writer.Write(this.Imports[i].bImportOptional ? 1 : 0);
                    }
                }
                else
                {
                    this.ImportOffset = 0;
                }

                // Export details
                if (this.Exports.Count > 0)
                {
                    this.ExportOffset = (int)writer.BaseStream.Position;
                    this.ExportCount = this.Exports.Count;
                    for (int i = 0; i < this.Exports.Count; i++)
                    {
                        Export us = this.Exports[i];
                        us.WriteExportMapEntry(writer);
                    }
                }
                else
                {
                    this.ExportOffset = 0;
                }

                // DependsMap
                if (DependsMap != null)
                {
                    this.DependsOffset = (ObjectVersion > ObjectVersion.VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS && ObjectVersion < ObjectVersion.VER_UE4_64BIT_EXPORTMAP_SERIALSIZES) ? 0 : (int)writer.BaseStream.Position;
                    for (int i = 0; i < this.Exports.Count; i++)
                    {
                        if (i >= this.DependsMap.Count) this.DependsMap.Add(new int[0]);

                        int[] currentData = this.DependsMap[i];
                        writer.Write(currentData.Length);
                        for (int j = 0; j < currentData.Length; j++)
                        {
                            writer.Write(currentData[j]);
                        }
                    }
                }
                else
                {
                    this.DependsOffset = 0;
                    writer.Write((int)0);
                }

                // SoftPackageReferenceList
                if (SoftPackageReferenceList != null)
                {
                    this.SoftPackageReferencesOffset = (int)writer.BaseStream.Position;
                    this.SoftPackageReferencesCount = this.SoftPackageReferenceList.Count;
                    for (int i = 0; i < this.SoftPackageReferenceList.Count; i++)
                    {
                        if (ObjectVersion >= ObjectVersion.VER_UE4_ADDED_SOFT_OBJECT_PATH)
                            writer.Write(FName.FromString(this, SoftPackageReferenceList[i].Value));
                        else
                            writer.Write(this.SoftPackageReferenceList[i]);
                    }
                }
                else
                {
                    this.SoftPackageReferencesOffset = 0;
                }

                if (!IsFilterEditorOnly && SearchableNames != null)
                {
                    SearchableNamesOffset = (int)writer.BaseStream.Position;

                    writer.Write(SearchableNames.Count);

                    for (int i = 0; i < SearchableNames.Count; i++)
                    {
                        var searchableNamesCollectionPair = SearchableNames.ElementAt(i);
                        var searchableNamesCollectionIndex = searchableNamesCollectionPair.Key;
                        var searchableNamesCollectionContent = searchableNamesCollectionPair.Value;

                        writer.Write(searchableNamesCollectionIndex.Index);
                        writer.Write(searchableNamesCollectionContent.Count);

                        for (int j = 0; j < searchableNamesCollectionContent.Count; j++)
                        {
                            writer.Write(searchableNamesCollectionContent[j]);
                        }
                    }
                }
                else
                {
                    SearchableNamesOffset = 0;
                }

                if (!IsFilterEditorOnly && Thumbnails != null)
                {
                    var thumbnailOffsets = new List<(string ObjectFullName, int FileOffset)>();
                    foreach (var kv in Thumbnails)
                    {
                        var offset = (int)writer.BaseStream.Position;
                        writer.Write(kv.Value);
                        thumbnailOffsets.Add((kv.Key, offset));
                    }

                    ThumbnailTableOffset = (int)writer.BaseStream.Position;

                    writer.Write(Thumbnails.Count);
                    foreach (var thumbnail in thumbnailOffsets)
                    {
                        var firstSpaceIdx = thumbnail.ObjectFullName.IndexOf(' ');
                        if (firstSpaceIdx == -1 || firstSpaceIdx == 0)
                            throw new Exception($"Invalid thumbnail object name: \"{thumbnail.ObjectFullName}\"");

                        var objectClassName = new FString(thumbnail.ObjectFullName.Substring(0, firstSpaceIdx));
                        var objectPath = thumbnail.ObjectFullName.Substring(firstSpaceIdx + 1);

                        var objectPathWithoutPackageName = new FString(objectPath.Substring(objectPath.IndexOf('.') + 1));

                        writer.Write(objectClassName);
                        writer.Write(objectPathWithoutPackageName);
                        writer.Write(thumbnail.FileOffset);
                    }
                }
                else
                {
                    ThumbnailTableOffset = 0;
                }

                // AssetRegistryData
                if (this.doWeHaveAssetRegistryData)
                {
                    this.AssetRegistryDataOffset = (int)writer.BaseStream.Position;

                    /*writer.Write(this.AssetRegistryData.Count);
                    for (int i = 0; i < this.AssetRegistryData.Count; i++)
                    {
                        throw new NotImplementedException("Asset registry data is not yet supported. Please let me know if you see this error message");
                    }*/

                    writer.Write(AssetRegistryData);
                }
                else
                {
                    this.AssetRegistryDataOffset = 0;
                }

                // WorldTileInfo
                if (this.doWeHaveWorldTileInfo)
                {
                    this.WorldTileInfoDataOffset = (int)writer.BaseStream.Position;
                    WorldTileInfo.Write(writer, this);
                }
                else
                {
                    this.WorldTileInfoDataOffset = 0;
                }

                // PreloadDependencies
                this.PreloadDependencyOffset = (int)writer.BaseStream.Position;
                if (this.UseSeparateBulkDataFiles) this.UsesEventDrivenLoader = true;
                if (this.UsesEventDrivenLoader)
                {
                    this.PreloadDependencyCount = 0;
                    for (int i = 0; i < this.Exports.Count; i++)
                    {
                        Exports[i].FirstExportDependencyOffset = this.PreloadDependencyCount;

                        Exports[i].SerializationBeforeSerializationDependenciesSize = Exports[i].SerializationBeforeSerializationDependencies.Count;
                        for (int j = 0; j < Exports[i].SerializationBeforeSerializationDependenciesSize; j++) writer.Write(Exports[i].SerializationBeforeSerializationDependencies[j].Index);

                        Exports[i].CreateBeforeSerializationDependenciesSize = Exports[i].CreateBeforeSerializationDependencies.Count;
                        for (int j = 0; j < Exports[i].CreateBeforeSerializationDependenciesSize; j++) writer.Write(Exports[i].CreateBeforeSerializationDependencies[j].Index);

                        Exports[i].SerializationBeforeCreateDependenciesSize = Exports[i].SerializationBeforeCreateDependencies.Count;
                        for (int j = 0; j < Exports[i].SerializationBeforeCreateDependenciesSize; j++) writer.Write(Exports[i].SerializationBeforeCreateDependencies[j].Index);

                        Exports[i].CreateBeforeCreateDependenciesSize = Exports[i].CreateBeforeCreateDependencies.Count;
                        for (int j = 0; j < Exports[i].CreateBeforeCreateDependenciesSize; j++) writer.Write(Exports[i].CreateBeforeCreateDependencies[j].Index);

                        this.PreloadDependencyCount +=
                            Exports[i].SerializationBeforeSerializationDependencies.Count +
                            Exports[i].CreateBeforeSerializationDependencies.Count +
                            Exports[i].SerializationBeforeCreateDependencies.Count +
                            Exports[i].CreateBeforeCreateDependencies.Count;

                        if (Exports[i].FirstExportDependencyOffset == this.PreloadDependencyCount) Exports[i].FirstExportDependencyOffset = -1;
                    }
                }
                else
                {
                    this.PreloadDependencyCount = -1;
                    for (int i = 0; i < this.Exports.Count; i++) Exports[i].FirstExportDependencyOffset = -1;
                }

                // DataResources (5.3+)
                if (DataResources != null)
                {
                    this.DataResourceOffset = (int)writer.BaseStream.Position;
                    writer.Write((uint)DataResourceVersion);
                    writer.Write(DataResources.Count);

                    for (int i = 0; i < DataResources.Count; i++)
                    {
                        FObjectDataResource dataResource = DataResources[i];
                        writer.Write((uint)dataResource.Flags);

                        if (DataResourceVersion >= EObjectDataResourceVersion.AddedCookedIndex)
                        {
                            writer.Write(dataResource.CookedIndex);
                        }

                        writer.Write(dataResource.SerialOffset);
                        writer.Write(dataResource.DuplicateSerialOffset);
                        writer.Write(dataResource.SerialSize);
                        writer.Write(dataResource.RawSize);
                        writer.Write(dataResource.OuterIndex?.Index ?? 0);
                        writer.Write(dataResource.LegacyBulkDataFlags);
                    }
                }

                if (AppendedNullBytes > 0)
                {
                    // new arrays guaranteed to be zero'd
                    writer.Write(new byte[AppendedNullBytes]);
                }

                // Export data
                int oldOffset = this.SectionSixOffset;
                this.SectionSixOffset = (int)writer.BaseStream.Position;
                long[] categoryStarts = new long[this.Exports.Count];
                if (this.Exports.Count > 0)
                {
                    for (int i = 0; i < this.Exports.Count; i++)
                    {
                        categoryStarts[i] = writer.BaseStream.Position;
                        Export us = this.Exports[i];
                        us.Write(writer);
                        writer.Write(us.Extras);
                    }
                }

                // SeaOfThievesGarbageData
                if (SeaOfThievesGarbageData != null && SeaOfThievesGarbageData.Length > 0) writer.Write(SeaOfThievesGarbageData);

                this.BulkDataStartOffset = (int)writer.BaseStream.Position;
                writer.Write(BulkData);

                // Rewrite Section 3
                if (this.Exports.Count > 0)
                {
                    writer.Seek(this.ExportOffset, SeekOrigin.Begin);
                    for (int i = 0; i < this.Exports.Count; i++)
                    {
                        Export us = this.Exports[i];

                        long nextStarting = -1;
                        if ((Exports.Count - 1) > i)
                        {
                            nextStarting = categoryStarts[i + 1];
                        }
                        else
                        {
                            nextStarting = this.BulkDataStartOffset;
                            if (this.SeaOfThievesGarbageData != null) nextStarting -= this.SeaOfThievesGarbageData.Length;
                        }

                        us.SerialOffset = categoryStarts[i];
                        us.SerialSize = nextStarting - categoryStarts[i];

                        us.WriteExportMapEntry(writer);
                    }
                }

                // Rewrite header
                writer.Seek(0, SeekOrigin.Begin);
                writer.Write(MakeHeader());

                writer.Seek(0, SeekOrigin.Begin);
            }
            finally
            {
                isSerializationTime = false;
                GetEngineVersion(); // update dirty state
            }
            return stre;
        }

        /// <summary>
        /// Serializes and writes an asset to two split streams (.uasset and .uexp) from memory.
        /// </summary>
        /// <param name="uassetStream">A stream containing the contents of the .uasset file.</param>
        /// <param name="uexpStream">A stream containing the contents of the .uexp file, if needed, otherwise null.</param>
        /// <exception cref="UnknownEngineVersionException">Thrown when <see cref="ObjectVersion"/> is unspecified.</exception>
        public virtual void Write(out MemoryStream uassetStream, out MemoryStream uexpStream)
        {
            if (ObjectVersion == ObjectVersion.UNKNOWN) throw new UnknownEngineVersionException("Cannot begin serialization before an object version is specified");

            MemoryStream newData = WriteData();

            if (this.UseSeparateBulkDataFiles && this.Exports.Count > 0)
            {
                long breakingOffPoint = this.Exports[0].SerialOffset;
                uassetStream = new MemoryStream((int)breakingOffPoint);
                uexpStream = new MemoryStream((int)(newData.Length - breakingOffPoint));
                CopySplitUp(newData, uassetStream, 0, (int)breakingOffPoint);
                CopySplitUp(newData, uexpStream, (int)breakingOffPoint, (int)(newData.Length - breakingOffPoint));
            }
            else
            {
                uassetStream = newData;
                uexpStream = null;
                // uexpStream is left empty
            }
        }

        /// <summary>
        /// Serializes and writes an asset to disk from memory.
        /// </summary>
        /// <param name="outputPath">The path on disk to write the asset to.</param>
        /// <exception cref="UnknownEngineVersionException">Thrown when <see cref="ObjectVersion"/> is unspecified.</exception>
        public virtual void Write(string outputPath)
        {
            if (ObjectVersion == ObjectVersion.UNKNOWN) throw new UnknownEngineVersionException("Cannot begin serialization before an object version is specified");

            MemoryStream newData = WriteData();

            if (this.UseSeparateBulkDataFiles && this.Exports.Count > 0)
            {
                long breakingOffPoint = this.Exports[0].SerialOffset;
                using (FileStream f = File.Open(outputPath, FileMode.Create, FileAccess.Write))
                {
                    CopySplitUp(newData, f, 0, (int)breakingOffPoint);
                }

                using (FileStream f = File.Open(Path.ChangeExtension(outputPath, "uexp"), FileMode.Create, FileAccess.Write))
                {
                    CopySplitUp(newData, f, (int)breakingOffPoint, (int)(newData.Length - breakingOffPoint));
                }
            }
            else
            {
                using (FileStream f = File.Open(outputPath, FileMode.Create, FileAccess.Write))
                {
                    newData.CopyTo(f);
                }
            }
        }

        /// <summary>
        /// Serializes this asset as JSON.
        /// </summary>
        /// <param name="isFormatted">Whether or not the returned JSON string should be indented.</param>
        /// <returns>A serialized JSON string that represents the asset.</returns>
        public string SerializeJson(bool isFormatted = false)
        {
            return SerializeJson(isFormatted ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Serializes this asset as JSON.
        /// </summary>
        /// <param name="jsonFormatting">The formatting to use for the returned JSON string.</param>
        /// <returns>A serialized JSON string that represents the asset.</returns>
        public string SerializeJson(Formatting jsonFormatting)
        {
            Info = "Serialized with UAssetAPI " + typeof(PropertyData).Assembly.GetName().Version + (string.IsNullOrEmpty(UAPUtils.CurrentCommit) ? "" : (" (" + UAPUtils.CurrentCommit + ")"));
            return JsonConvert.SerializeObject(this, jsonFormatting, jsonSettings);
        }

        /// <summary>
        /// Serializes an object as JSON.
        /// </summary>
        /// <param name="value">The object to serialize as JSON.</param>
        /// <param name="isFormatted">Whether or not the returned JSON string should be indented.</param>
        /// <returns>A serialized JSON string that represents the object.</returns>
        public string SerializeJsonObject(object value, bool isFormatted = false)
        {
            return SerializeJsonObject(value, isFormatted ? Formatting.Indented : Formatting.None);
        }

        /// <summary>
        /// Serializes an object as JSON.
        /// </summary>
        /// <param name="value">The object to serialize as JSON.</param>
        /// <param name="jsonFormatting">The formatting to use for the returned JSON string.</param>
        /// <returns>A serialized JSON string that represents the object.</returns>
        public string SerializeJsonObject(object value, Formatting jsonFormatting)
        {
            return JsonConvert.SerializeObject(value, jsonFormatting, jsonSettings);
        }

        /// <summary>
        /// Deserializes an object from JSON.
        /// </summary>
        /// <param name="json">A serialized JSON string to parse.</param>
        public T DeserializeJsonObject<T>(string json)
        {
            Dictionary<FName, string> toBeFilled = new Dictionary<FName, string>();
            T res = JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings
            {
                TypeNameHandling = TypeNameHandling.Objects,
                NullValueHandling = NullValueHandling.Include,
                FloatParseHandling = FloatParseHandling.Double,
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                MetadataPropertyHandling = MetadataPropertyHandling.ReadAhead,
                ContractResolver = new UAssetContractResolver(toBeFilled),
                Converters = new List<JsonConverter>()
                {
                    new FSignedZeroJsonConverter(),
                    new FNameJsonConverter(null),
                    new FStringTableJsonConverter(),
                    new FStringJsonConverter(),
                    new FPackageIndexJsonConverter(),
                    new StringEnumConverter(),
                    new GuidJsonConverter(),
                    new ByteArrayJsonConverter()
                }
            });

            foreach (KeyValuePair<FName, string> entry in toBeFilled)
            {
                entry.Key.Asset = this;
                if (FName.IsFromStringValid(this, entry.Value))
                {
                    var dummy = FName.FromString(this, entry.Value);
                    entry.Key.Value = dummy.Value;
                    entry.Key.Number = dummy.Number;
                }
                else
                {
                    entry.Key.DummyValue = FString.FromString(entry.Value);
                    entry.Key.Number = 0;
                }
            }
            toBeFilled.Clear();

            return res;
        }

        /// <summary>
        /// Reads an asset from serialized JSON and initializes a new instance of the <see cref="UAsset"/> class to store its data in memory.
        /// </summary>
        /// <param name="json">A serialized JSON string to parse.</param>
        public static UAsset DeserializeJson(string json)
        {
            Dictionary<FName, string> toBeFilled = new Dictionary<FName, string>();
            UAsset res = JsonConvert.DeserializeObject<UAsset>(json, new JsonSerializerSettings
            {
                TypeNameHandling = TypeNameHandling.Objects,
                NullValueHandling = NullValueHandling.Include,
                FloatParseHandling = FloatParseHandling.Double,
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                MetadataPropertyHandling = MetadataPropertyHandling.ReadAhead,
                ContractResolver = new UAssetContractResolver(toBeFilled),
                Converters = new List<JsonConverter>()
                {
                    new FSignedZeroJsonConverter(),
                    new FNameJsonConverter(null),
                    new FStringTableJsonConverter(),
                    new FStringJsonConverter(),
                    new FPackageIndexJsonConverter(),
                    new StringEnumConverter(),
                    new GuidJsonConverter(),
                    new ByteArrayJsonConverter()
                }
            });

            foreach (KeyValuePair<FName, string> entry in toBeFilled)
            {
                entry.Key.Asset = res;
                if (FName.IsFromStringValid(res, entry.Value))
                {
                    var dummy = FName.FromString(res, entry.Value);
                    entry.Key.Value = dummy.Value;
                    entry.Key.Number = dummy.Number;
                }
                else
                {
                    entry.Key.DummyValue = FString.FromString(entry.Value);
                    entry.Key.Number = 0;
                }
            }
            toBeFilled.Clear();

            foreach (Export ex in res.Exports) ex.Asset = res;

            res.ResolveAncestries();
            return res;
        }

        /// <summary>
        /// Reads an asset from serialized JSON and initializes a new instance of the <see cref="UAsset"/> class to store its data in memory.
        /// </summary>
        /// <param name="stream">A stream containing serialized JSON string to parse.</param>
        public static UAsset DeserializeJson(Stream stream)
        {
            Dictionary<FName, string> toBeFilled = new Dictionary<FName, string>();
            var serializer = JsonSerializer.Create(new JsonSerializerSettings
            {
                TypeNameHandling = TypeNameHandling.Objects,
                NullValueHandling = NullValueHandling.Include,
                FloatParseHandling = FloatParseHandling.Double,
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                MetadataPropertyHandling = MetadataPropertyHandling.ReadAhead,
                ContractResolver = new UAssetContractResolver(toBeFilled),
                Converters = new List<JsonConverter>()
                {
                    new FSignedZeroJsonConverter(),
                    new FNameJsonConverter(null),
                    new FStringTableJsonConverter(),
                    new FStringJsonConverter(),
                    new FPackageIndexJsonConverter(),
                    new StringEnumConverter(),
                    new GuidJsonConverter(),
                    new ByteArrayJsonConverter()
                }
            });

            UAsset res;

            using (var sr = new StreamReader(stream))
            {
                using (var jsonTextReader = new JsonTextReader(sr))
                {
                    res = serializer.Deserialize<UAsset>(jsonTextReader);
                }
            }

            foreach (KeyValuePair<FName, string> entry in toBeFilled)
            {
                entry.Key.Asset = res;
                if (FName.IsFromStringValid(res, entry.Value))
                {
                    var dummy = FName.FromString(res, entry.Value);
                    entry.Key.Value = dummy.Value;
                    entry.Key.Number = dummy.Number;
                }
                else
                {
                    entry.Key.DummyValue = FString.FromString(entry.Value);
                    entry.Key.Number = 0;
                }
            }
            toBeFilled.Clear();

            foreach (Export ex in res.Exports) ex.Asset = res;
            return res;
        }

        /// <summary>
        /// Reads an asset from disk and initializes a new instance of the <see cref="UAsset"/> class to store its data in memory.
        /// </summary>
        /// <param name="path">The path of the asset file on disk that this instance will read from.</param>
        /// <param name="engineVersion">The version of the Unreal Engine that will be used to parse this asset. If the asset is versioned, this can be left unspecified.</param>
        /// <param name="mappings">A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.</param>
        /// <param name="customSerializationFlags">A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.</param>
        /// <exception cref="UnknownEngineVersionException">Thrown when this is an unversioned asset and <see cref="ObjectVersion"/> is unspecified.</exception>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        public UAsset(string path, EngineVersion engineVersion = EngineVersion.UNKNOWN, Usmap mappings = null, CustomSerializationFlags customSerializationFlags = CustomSerializationFlags.None)
        {
            this.FilePath = path;
            this.Mappings = mappings;
            this.CustomSerializationFlags = customSerializationFlags;
            SetEngineVersion(engineVersion);

            Read(PathToReader(path));
        }
        
        /// <summary>
        /// Reads an asset from disk and initializes a new instance of the <see cref="UAsset"/> class to store its data in memory.
        /// </summary>
        /// <param name="path">The path of the asset file on disk that this instance will read from.</param>
        /// <param name="loadUexp">Whether to load the .uexp file. False only reads the .uasset file.</param>
        /// <param name="engineVersion">The version of the Unreal Engine that will be used to parse this asset. If the asset is versioned, this can be left unspecified.</param>
        /// <param name="mappings">A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.</param>
        /// <param name="customSerializationFlags">A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.</param>
        /// <exception cref="UnknownEngineVersionException">Thrown when this is an unversioned asset and <see cref="ObjectVersion"/> is unspecified.</exception>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        public UAsset(string path, bool loadUexp, EngineVersion engineVersion = EngineVersion.UNKNOWN, Usmap mappings = null, CustomSerializationFlags customSerializationFlags = CustomSerializationFlags.None)
        {
            this.FilePath = path;
            this.Mappings = mappings;
            this.CustomSerializationFlags = customSerializationFlags;
            SetEngineVersion(engineVersion);

            Read(PathToReader(path, loadUexp));
        }

        /// <summary>
        /// Reads an asset from a BinaryReader and initializes a new instance of the <see cref="UAsset"/> class to store its data in memory.
        /// </summary>
        /// <param name="reader">The asset's BinaryReader that this instance will read from. If a .uexp file exists, the .uexp file's data should be appended to the end of the .uasset file's data.</param>
        /// <param name="engineVersion">The version of the Unreal Engine that will be used to parse this asset. If the asset is versioned, this can be left unspecified.</param>
        /// <param name="mappings">A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.</param>
        /// <param name="useSeparateBulkDataFiles">Does this asset uses separate bulk data files (.uexp, .ubulk)?</param>
        /// <param name="customSerializationFlags">A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.</param>
        /// <exception cref="UnknownEngineVersionException">Thrown when this is an unversioned asset and <see cref="ObjectVersion"/> is unspecified.</exception>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        public UAsset(AssetBinaryReader reader, EngineVersion engineVersion = EngineVersion.UNKNOWN, Usmap mappings = null, bool useSeparateBulkDataFiles = false, CustomSerializationFlags customSerializationFlags = CustomSerializationFlags.None)
        {
            this.Mappings = mappings;
            this.CustomSerializationFlags = customSerializationFlags;
            UseSeparateBulkDataFiles = useSeparateBulkDataFiles;
            SetEngineVersion(engineVersion);
            Read(reader);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="UAsset"/> class. This instance will store no asset data and does not represent any asset in particular until the <see cref="Read"/> method is manually called.
        /// </summary>
        /// <param name="engineVersion">The version of the Unreal Engine that will be used to parse this asset. If the asset is versioned, this can be left unspecified.</param>
        /// <param name="mappings">A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.</param>
        /// <param name="customSerializationFlags">A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.</param>
        public UAsset(EngineVersion engineVersion = EngineVersion.UNKNOWN, Usmap mappings = null, CustomSerializationFlags customSerializationFlags = CustomSerializationFlags.None)
        {
            this.Mappings = mappings;
            this.CustomSerializationFlags = customSerializationFlags;
            SetEngineVersion(engineVersion);
        }

        /// <summary>
        /// Reads an asset from disk and initializes a new instance of the <see cref="UAsset"/> class to store its data in memory.
        /// </summary>
        /// <param name="path">The path of the asset file on disk that this instance will read from.</param>
        /// <param name="objectVersion">The UE4 object version of the Unreal Engine that will be used to parse this asset.</param>
        /// <param name="objectVersionUE5">The UE5 object version of the Unreal Engine that will be used to parse this asset.</param>
        /// <param name="customVersionContainer">A list of custom versions to parse this asset with.</param>
        /// <param name="mappings">A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.</param>
        /// <param name="customSerializationFlags">A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.</param>
        /// <exception cref="UnknownEngineVersionException">Thrown when this is an unversioned asset and <see cref="ObjectVersion"/> is unspecified.</exception>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        public UAsset(string path, ObjectVersion objectVersion, ObjectVersionUE5 objectVersionUE5, List<CustomVersion> customVersionContainer, Usmap mappings = null, CustomSerializationFlags customSerializationFlags = CustomSerializationFlags.None)
        {
            this.FilePath = path;
            this.Mappings = mappings;
            this.CustomSerializationFlags = customSerializationFlags;
            ObjectVersion = objectVersion;
            ObjectVersionUE5 = objectVersionUE5;
            if (customVersionContainer != null) CustomVersionContainer = customVersionContainer;

            Read(PathToReader(path));
        }

        /// <summary>
        /// Reads an asset from a BinaryReader and initializes a new instance of the <see cref="UAsset"/> class to store its data in memory.
        /// </summary>
        /// <param name="reader">The asset's BinaryReader that this instance will read from.</param>
        /// <param name="objectVersion">The UE4 object version of the Unreal Engine that will be used to parse this asset.</param>
        /// <param name="objectVersionUE5">The UE5 object version of the Unreal Engine that will be used to parse this asset.</param>
        /// <param name="customVersionContainer">A list of custom versions to parse this asset with.</param>
        /// <param name="mappings">A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.</param>
        /// <param name="useSeparateBulkDataFiles">Does this asset uses separate bulk data files (.uexp, .ubulk)?</param>
        /// <param name="customSerializationFlags">A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.</param>
        /// <exception cref="UnknownEngineVersionException">Thrown when this is an unversioned asset and <see cref="ObjectVersion"/> is unspecified.</exception>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        public UAsset(AssetBinaryReader reader, ObjectVersion objectVersion, ObjectVersionUE5 objectVersionUE5, List<CustomVersion> customVersionContainer, Usmap mappings = null, bool useSeparateBulkDataFiles = false, CustomSerializationFlags customSerializationFlags = CustomSerializationFlags.None)
        {
            this.Mappings = mappings;
            this.CustomSerializationFlags = customSerializationFlags;
            UseSeparateBulkDataFiles = useSeparateBulkDataFiles;
            ObjectVersion = objectVersion;
            ObjectVersionUE5 = objectVersionUE5;
            if (customVersionContainer != null) CustomVersionContainer = customVersionContainer;

            Read(reader);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="UAsset"/> class. This instance will store no asset data and does not represent any asset in particular until the <see cref="Read"/> method is manually called.
        /// </summary>
        /// <param name="objectVersion">The UE4 object version of the Unreal Engine that will be used to parse this asset.</param>
        /// <param name="objectVersionUE5">The UE5 object version of the Unreal Engine that will be used to parse this asset.</param>
        /// <param name="customVersionContainer">A list of custom versions to parse this asset with.</param>
        /// <param name="mappings">A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.</param>
        /// <param name="customSerializationFlags">A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.</param>
        public UAsset(ObjectVersion objectVersion, ObjectVersionUE5 objectVersionUE5, List<CustomVersion> customVersionContainer, Usmap mappings = null, CustomSerializationFlags customSerializationFlags = CustomSerializationFlags.None)
        {
            this.Mappings = mappings;
            this.CustomSerializationFlags = customSerializationFlags;
            ObjectVersion = objectVersion;
            ObjectVersionUE5 = objectVersionUE5;
            if (customVersionContainer != null) CustomVersionContainer = customVersionContainer;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="UAsset"/> class. This instance will store no asset data and does not represent any asset in particular until the <see cref="Read"/> method is manually called.
        /// </summary>
        public UAsset()
        {

        }
    }
}

#if DEBUGTRACING
namespace UAssetAPI.Trace {
    public class TraceStream : Stream
    {
        Stream BaseStream;
        public byte[] Data;
        public LoggingAspect.LogContext Context;
        public string PathOnDisk;

        public TraceStream(Stream BaseStream, string pathOnDisk = null)
        {
            var start = BaseStream.Position;
            using (MemoryStream ms = new MemoryStream())
            {
                BaseStream.CopyTo(ms);
                this.Data = ms.ToArray();
            }
            BaseStream.Position = start;
            this.BaseStream = BaseStream;
            this.PathOnDisk = pathOnDisk;
        }

        public override bool CanRead { get => BaseStream.CanRead; }
        public override bool CanSeek => throw new NotImplementedException();
        public override bool CanWrite => throw new NotImplementedException();
        public override long Length { get => BaseStream.Length; }
        public override long Position { get => BaseStream.Position; set => throw new NotImplementedException(); }

        public override void Flush()
        {
            BaseStream.Flush();
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            Context.OnRead(count);
            return BaseStream.Read(buffer, offset, count);
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            var pos = BaseStream.Seek(offset, origin);
            Context.OnSeek(pos);
            return pos;
        }

        public override void SetLength(long value)
        {
            BaseStream.SetLength(value);
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            BaseStream.Write(buffer, offset, count);
        }
    }

    [PSerializable]
    public class LoggingAspect : OnMethodBoundaryAspect
    {
        public class ActionRead : IAction {
            public long Size;
        }
        public class ActionSeek : IAction {
            public long Position;
        }
        public class ActionSpan : IAction {
            public Span Span;
        }

        public interface IAction {}

        public class Span
        {
            [JsonIgnore]
            public Span Parent;
            [JsonProperty("name")]
            public string Name;
            [JsonProperty("actions")]
            public IList<IAction> Actions;
        }

        public class Trace
        {
            [JsonProperty("data")]
            public byte[] Data;
            [JsonProperty("root")]
            public Span Root;
        }

        public class VersionConverter : JsonConverter<IAction>
        {
            public override void WriteJson(JsonWriter writer, IAction value, JsonSerializer serializer)
            {
                switch (value)
                {
                    case ActionSeek s:
                        writer.WriteStartObject();
                        writer.WritePropertyName("Seek");
                        writer.WriteValue(s.Position);
                        writer.WriteEndObject();
                        break;
                    case ActionRead s:
                        writer.WriteStartObject();
                        writer.WritePropertyName("Read");
                        writer.WriteValue(s.Size);
                        writer.WriteEndObject();
                        break;
                    case ActionSpan s:
                        writer.WriteStartObject();
                        writer.WritePropertyName("Span");
                        serializer.Serialize(writer, s.Span);
                        writer.WriteEndObject();
                        break;
                    default:
                        throw new NotImplementedException();
                };
            }

            public override IAction ReadJson(JsonReader reader, Type objectType, IAction existingValue, bool hasExistingValue, JsonSerializer serializer)
            {
                throw new NotImplementedException();
            }
        }

        public class LogContext
        {
            public uint SpanId = 0;
            public Span Root;
            public Span Current;
            TraceStream UnderlyingStream;

            public LogContext(TraceStream stream) {
                UnderlyingStream = stream;
                stream.Context = this;
                Root = Current = new Span() {
                    Parent = null,
                    Name = "root",
                    Actions = new List<IAction>(),
                };
            }

            /// <summary>
            /// Stop logging.
            /// </summary>
            /// <returns>Path to the saved .json file.</returns>
            public string Stop()
            {
                string outputPath = "trace.json";
                if (!string.IsNullOrEmpty(UnderlyingStream.PathOnDisk))
                {
                    outputPath = Path.Combine(Path.GetDirectoryName(UnderlyingStream.PathOnDisk), Path.GetFileNameWithoutExtension(UnderlyingStream.PathOnDisk) + "-trace.json");
                }

                using (StreamWriter writer = File.CreateText(outputPath)) {
                    var trace = new Trace {
                        Data = UnderlyingStream.Data,
                        Root = Root,
                    };
                    writer.Write(JsonConvert.SerializeObject(trace, Formatting.None, new VersionConverter()));
                }

                return outputPath;
            }

            public void OnEntry(MethodExecutionArgs args) {
                var newSpan = new Span() {
                    Parent = Current,
                    Name = $"{args.Method.ReflectedType.FullName}.{args.Method.Name}",
                    Actions = new List<IAction>(),
                };
                Current.Actions.Add(new ActionSpan() { Span = newSpan });
                Current = newSpan;
            }
            public void OnExit(MethodExecutionArgs args) {
                Current = Current.Parent;
            }
            public void OnRead(long size) {
                Current.Actions.Add(new ActionRead() {
                    Size = size,
                });
            }
            public void OnSeek(long position) {
                Current.Actions.Add(new ActionSeek() {
                    Position = position,
                });
            }
        }

        static LogContext Context = null;

        public override void OnEntry(MethodExecutionArgs args) {
            if (Context != null) Context.OnEntry(args);
        }
        public override void OnSuccess(MethodExecutionArgs args) {}
        public override void OnExit(MethodExecutionArgs args) {
            if (Context != null) Context.OnExit(args);
        }
        public override void OnException(MethodExecutionArgs args) {}

        public static void Start(TraceStream stream) {
            LoggingAspect.Context = new LogContext(stream);
        }

        /// <summary>
        /// Stop logging.
        /// </summary>
        /// <returns>Path to the saved .json file.</returns>
        public static string Stop()
        {
            string res = LoggingAspect.Context.Stop();
            LoggingAspect.Context = null;
            return res;
        }
    }
}
#endif

```

`UAssetAPI/UAssetAPI.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <ProjectGuid>{178417EC-1177-413E-BE85-C83AECD64279}</ProjectGuid>
    <TargetFramework>net8.0</TargetFramework>
    <AssemblyTitle>UAssetAPI</AssemblyTitle>
    <Product>UAssetAPI</Product>
    <Copyright>Copyright © Atenfyr 2024</Copyright>
    <OutputPath>bin\$(Configuration)\</OutputPath>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Configurations>Debug;Release;DebugVerbose;DebugTracing</Configurations>
    <Platforms>AnyCPU;x86</Platforms>
    <FileVersion>1.0.2.0</FileVersion>
    <AssemblyVersion>1.0.2.0</AssemblyVersion>
    <Version>1.0.2</Version>
    <IncludeSourceRevisionInInformationalVersion>false</IncludeSourceRevisionInInformationalVersion>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugType>full</DebugType>
    <DocumentationFile>bin\$(Configuration)\UAssetAPI.xml</DocumentationFile>
    <NoWarn>1591</NoWarn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'">
    <DebugType>full</DebugType>
    <DocumentationFile>bin\$(Configuration)\UAssetAPI.xml</DocumentationFile>
    <NoWarn>1591</NoWarn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|AnyCPU'">
    <DebugType>full</DebugType>
    <DocumentationFile>bin\$(Configuration)\UAssetAPI.xml</DocumentationFile>
    <NoWarn>1591</NoWarn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugVerbose|x86'">
    <DebugType>full</DebugType>
    <DocumentationFile>bin\$(Configuration)\UAssetAPI.xml</DocumentationFile>
    <NoWarn>1591</NoWarn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugTracing|AnyCPU'">
    <DebugType>full</DebugType>
    <DocumentationFile>bin\$(Configuration)\UAssetAPI.xml</DocumentationFile>
    <NoWarn>1591</NoWarn>
    <DefineConstants>ADDTRACING</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugTracing|x86'">
    <DebugType>full</DebugType>
    <DocumentationFile>bin\$(Configuration)\UAssetAPI.xml</DocumentationFile>
    <NoWarn>1591</NoWarn>
    <DefineConstants>ADDTRACING</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x86'">
    <DebugType>pdbonly</DebugType>
  </PropertyGroup>
  <Choose>
    <When Condition="$(DefineConstants.Contains('ADDTRACING'))">
        <ItemGroup>
          <PackageReference Include="PostSharp.Patterns.Diagnostics" Version="2024.1.3" />
        </ItemGroup>
    </When>
  </Choose>
  <Target Name="BeforeBuildMigrated" BeforeTargets="PreBuildEvent">
    <Exec ContinueOnError="true" ConsoleToMsBuild="true" Command="git rev-parse --short HEAD">
      <Output TaskParameter="ConsoleOutput" PropertyName="GitCommit" />
    </Exec>
    <WriteLinesToFile File="$(ProjectDir)git_commit.txt" Overwrite="true" Lines="$(GitCommit)" />
  </Target>
  <Target Name="AfterBuildMigrated" AfterTargets="Build">
    <Delete Files="$(ProjectDir)git_commit.txt" />
  </Target>
  <ItemGroup>
    <None Remove="repak_bind.dll.gz" />
    <None Remove="repak_bind.so.gz" />
  </ItemGroup>
  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="ZstdSharp.Port" Version="0.8.1" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="git_commit.txt">
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
    <EmbeddedResource Include="repak_bind.dll.gz">
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
    <EmbeddedResource Include="repak_bind.so.gz">
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\AC7Key.bin" />
  </ItemGroup>
</Project>

```

`UAssetAPI/UnrealTypes/EngineVersion.cs`:

```cs
namespace UAssetAPI.UnrealTypes
{
    /// <summary>
    /// An enum used to represent all retail versions of the Unreal Engine. Each version entry represents a particular <see cref="ObjectVersion"/>, a particular <see cref="ObjectVersionUE5"/>, and the default set of all applicable <see cref="CustomVersion"/> enum values.
    /// </summary>
    public enum EngineVersion
    {
        UNKNOWN,
        VER_UE4_OLDEST_LOADABLE_PACKAGE,

        /// <summary>4.0</summary>
        VER_UE4_0,
        /// <summary>4.1</summary>
        VER_UE4_1,
        /// <summary>4.2</summary>
        VER_UE4_2,
        /// <summary>4.3</summary>
        VER_UE4_3,
        /// <summary>4.4</summary>
        VER_UE4_4,
        /// <summary>4.5</summary>
        VER_UE4_5,
        /// <summary>4.6</summary>
        VER_UE4_6,
        /// <summary>4.7</summary>
        VER_UE4_7,
        /// <summary>4.8</summary>
        VER_UE4_8,
        /// <summary>4.9</summary>
        VER_UE4_9,
        /// <summary>4.10</summary>
        VER_UE4_10,
        /// <summary>4.11</summary>
        VER_UE4_11,
        /// <summary>4.12</summary>
        VER_UE4_12,
        /// <summary>4.13</summary>
        VER_UE4_13,
        /// <summary>4.14</summary>
        VER_UE4_14,
        /// <summary>4.15</summary>
        VER_UE4_15,
        /// <summary>4.16</summary>
        VER_UE4_16,
        /// <summary>4.17</summary>
        VER_UE4_17,
        /// <summary>4.18</summary>
        VER_UE4_18,
        /// <summary>4.19</summary>
        VER_UE4_19,
        /// <summary>4.20</summary>
        VER_UE4_20,
        /// <summary>4.21</summary>
        VER_UE4_21,
        /// <summary>4.22</summary>
        VER_UE4_22,
        /// <summary>4.23</summary>
        VER_UE4_23,
        /// <summary>4.24</summary>
        VER_UE4_24,
        /// <summary>4.25</summary>
        VER_UE4_25,
        /// <summary>4.26</summary>
        VER_UE4_26,
        /// <summary>4.27</summary>
        VER_UE4_27,

        /// <summary>5.0EA</summary>
        VER_UE5_0EA,
        /// <summary>5.0</summary>
        VER_UE5_0,
        /// <summary>5.1</summary>
        VER_UE5_1,
        /// <summary>5.2</summary>
        VER_UE5_2,
        /// <summary>5.3</summary>
        VER_UE5_3,
        /// <summary>5.4</summary>
        VER_UE5_4,
        /// <summary>5.5</summary>
        VER_UE5_5,
        /// <summary>5.6</summary>
        VER_UE5_6,
        /// <summary>5.7</summary>
        VER_UE5_7,

        VER_UE4_AUTOMATIC_VERSION_PLUS_ONE,
        /// <summary>The newest specified version of the Unreal Engine.</summary>
        VER_UE4_AUTOMATIC_VERSION = VER_UE4_AUTOMATIC_VERSION_PLUS_ONE - 1,
    };
}

```

`UAssetAPI/UnrealTypes/FFieldPath.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

[JsonObject(MemberSerialization.OptIn)]
public class FFieldPath : IStruct<FFieldPath>
{
    /// <summary>
    /// Path to the FField object from the innermost FField to the outermost UObject (UPackage)
    /// </summary>
    [JsonProperty]
    public FName[] Path;

    /// <summary>
    /// The cached owner of this field.
    /// </summary>
    [JsonProperty]
    public FPackageIndex ResolvedOwner;

    public FFieldPath(FName[] path, FPackageIndex resolvedOwner, int numExports = -1)
    {
        Path = path;
        ResolvedOwner = resolvedOwner;

        // sanity check: throw if makes no sense
        if (numExports > 0 && ResolvedOwner.Index > numExports) throw new FormatException("Received nonsensical FFieldPath ResolvedOwner: " + ResolvedOwner.Index);
    }

    public FFieldPath()
    {
        Path = [];
        ResolvedOwner = FPackageIndex.FromRawIndex(0);
    }

    public FFieldPath(AssetBinaryReader reader)
    {
        Path = reader.ReadArray(reader.ReadFName);
        ResolvedOwner = new FPackageIndex(reader.ReadInt32());
    }

    public static FFieldPath Read(AssetBinaryReader reader) => new FFieldPath(reader);

    public int Write(AssetBinaryWriter writer)
    {
        if (Path == null && ResolvedOwner == null)
        {
            return 0;
        }
        writer.Write(Path.Length);
        foreach (FName name in Path)
        {
            writer.Write(name);
        }

        writer.Write(ResolvedOwner.Index);
        return sizeof(int) * (2 + Path.Length * 2);
    }

    public static FFieldPath FromString(string[] d, UAsset asset)
    {
        throw new NotImplementedException();
    }
}

```

`UAssetAPI/UnrealTypes/FGatherableTextData.cs`:

```cs
using System.Collections.Generic;
using Newtonsoft.Json;

namespace UAssetAPI.UnrealTypes
{
    /// <summary>
    /// Gatherable text data item
    /// </summary>
    public struct FGatherableTextData
    {
        [JsonProperty] public FString NamespaceName { get; set; }
        [JsonProperty] public FTextSourceData SourceData { get; set; }
        [JsonProperty] public List<FTextSourceSiteContext> SourceSiteContexts { get; set; }
    }
}
```

`UAssetAPI/UnrealTypes/FLocMetadataObject.cs`:

```cs
using System.Collections.Generic;
using Newtonsoft.Json;

namespace UAssetAPI.UnrealTypes
{
    public class FLocMetadataObject
    {
        public class FLocMetadataValue
        {
            // TODO:
        }

        [JsonProperty] public List<FLocMetadataValue> Values { get; set; } = new List<FLocMetadataValue>();
    }
}
```

`UAssetAPI/UnrealTypes/FName.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.JSON;

namespace UAssetAPI.UnrealTypes
{
    public enum EMappedNameType
    {
        Package,
        Container,
        Global
    }

    /// <summary>
    /// Unreal name - consists of an FString (which is serialized as an index in the name map) and an instance number
    /// </summary>
    [JsonConverter(typeof(FNameJsonConverter))]
    public class FName : ICloneable
    {
        public FString Value
        {
            get
            {
                // TODO: if type = Global, retrieve value from global name map (= script objects from usmap apparently?)
                if (DummyValue != null) return DummyValue;
                if (Asset == null) throw new InvalidOperationException("Attempt to get Value with no Asset defined");
                if (Index < 0) return null;
                return Asset.GetNameReference(Index);
            }
            set
            {
                DummyValue = null;
                if (Asset == null) throw new InvalidOperationException("Attempt to set Value with no Asset defined");
                Index = value?.Value == null ? -1 : Asset.AddNameReference(value);
            }
        }

        public bool IsDummy
        {
            get
            {
                return DummyValue != null;
            }
        }

        /// <summary>Instance number.</summary>
        public int Number;

        internal const int IndexBits = 30;
        internal const uint IndexMask = (1u << IndexBits) - 1u;
        internal const uint TypeMask = ~IndexMask;
        internal const int TypeShift = IndexBits;

        /// <summary>
        /// The type of this FName; i.e. whether it points to a package-level name table, container-level name table, or global name table. This value is always <see cref="EMappedNameType.Package"/> for non-Zen assets.
        /// </summary>
        public EMappedNameType Type = EMappedNameType.Package;

        /// <summary>
        /// Does this FName point into the global name table? This value is always false for non-Zen assets.
        /// </summary>
        public bool IsGlobal => Type != EMappedNameType.Package;

        /// <summary>
        /// The asset that this FName is bound to.
        /// </summary>
        public INameMap Asset;

        private int _index;
        /// <summary>
        /// Index into the name map of <see cref="Asset"/> that this FName points to.
        /// </summary>
        public sealed class DummyFNameSerializationException : InvalidOperationException
        {
            public readonly FString Dummy;
            public readonly INameMap NameMap;

            public DummyFNameSerializationException(FString dummy, INameMap map)
                : base($"Attempt to serialize dummy FName '{dummy?.Value ?? "<null>"}' - this name was never added to the NameMap.")
            {
                Dummy   = dummy;
                NameMap = map;
            }
        }

        internal int Index
        {
            get
            {
                if (IsDummy)
                    throw new DummyFNameSerializationException(DummyValue, Asset);
                return _index;
            }
            set
            {
                _index = value;
                DummyValue = null;
            }
        }

        /// <summary>
        /// Dummy value. If defined, this FName does not actually point to a value in any name map, but will still act as if it does.
        /// </summary>
        internal FString DummyValue = null;

        /// <summary>
        /// Converts this FName instance into a human-readable string. This is the inverse of <see cref="FromString(INameMap, string)"/>.
        /// </summary>
        /// <returns>The human-readable string that represents this FName.</returns>
        public override string ToString()
        {
            if (Value == null) return FString.NullCase;
            if (Number > 0) return Value.ToString() + "_" + (Number - 1);
            return Value.ToString();
        }

        internal static void FromStringFragments(INameMap asset, string val, out string str, out int num)
        {
            str = val; num = 0;

            if (val[val.Length - 1] >= '0' && val[val.Length - 1] <= '9')
            {
                int i = val.Length - 1;
                while (i > 1 && (val[i] >= '0' && val[i] <= '9'))
                {
                    i--;
                }

                if (val[i] == '_')
                {
                    string startSegment = val.Substring(0, i);
                    string endSegment = val.Substring(i + 1, val.Length - i - 1);
                    if (endSegment.Length == 1 || endSegment[0] != '0')
                    {
                        if (int.TryParse(endSegment, out int endSegmentVal))
                        {
                            str = startSegment;
                            num = endSegmentVal + 1;
                            return;
                        }
                    }
                }
            }
        }

        public static bool IsFromStringValid(INameMap asset, string val)
        {
            if (val == null || val == FString.NullCase) return true;
            if (val.Length == 0) return true;

            FromStringFragments(asset, val, out string value, out _);
            return asset.ContainsNameReference(FString.FromString(value));
        }

        /// <summary>
        /// Converts a human-readable string into an FName instance. This is the inverse of <see cref="ToString"/>.
        /// </summary>
        /// <param name="asset">The asset that the new FName will be bound to.</param>
        /// <param name="val">The human-readable string to convert into an FName instance.</param>
        /// <returns>An FName instance that this string represents.</returns>
        public static FName FromString(INameMap asset, string val)
        {
            if (val == null || val == FString.NullCase) return null;
            if (val.Length == 0) return new FName(asset, val, 0);

            FromStringFragments(asset, val, out string value, out int number);
            return new FName(asset, value, number);
        }

        /// <summary>
        /// Creates a new FName with the same string value and number as the current instance but is bound to a different asset.
        /// </summary>
        /// <param name="newAsset">The asset to bound the new FName to.</param>
        /// <returns>An equivalent FName bound to a different asset.</returns>
        public FName Transfer(INameMap newAsset)
        {
            return new FName(newAsset, Value, Number);
        }

        /// <summary>
        /// Creates a new dummy FName.
        /// This can be used for cases where a valid FName must be produced without referencing a specific asset's name map.
        /// <para />
        /// USE WITH CAUTION! UAssetAPI must never attempt to serialize a dummy FName to disk.
        /// </summary>
        /// <param name="asset">The asset that this FName is bound to.</param>
        /// <param name="val">The FString that the FName's value will be, verbatim.</param>
        /// <param name="number">The instance number of the new FName.</param>
        /// <returns>A dummy FName instance that represents the string.</returns>
        public static FName DefineDummy(INameMap asset, FString val, int number = 0)
        {
            if (asset != null && !asset.CanCreateDummies())
            {
                return new FName(asset, val, number);
            }

            var res = new FName();
            res.Asset = asset;
            res.DummyValue = val;
            res.Number = number;
            return res;
        }

        /// <summary>
        /// Creates a new dummy FName.
        /// This can be used for cases where a valid FName must be produced without referencing a specific asset's name map.
        /// <para />
        /// USE WITH CAUTION! UAssetAPI must never attempt to serialize a dummy FName to disk.
        /// </summary>
        /// <param name="asset">The asset that this FName is bound to.</param>
        /// <param name="val">The string literal that the FName's value will be, verbatim.</param>
        /// <param name="number">The instance number of the new FName.</param>
        /// <returns>A dummy FName instance that represents the string.</returns>
        public static FName DefineDummy(INameMap asset, string val, int number = 0)
        {
            if (asset != null && !asset.CanCreateDummies())
            {
                return new FName(asset, val, number);
            }

            var res = new FName();
            res.Asset = asset;
            res.DummyValue = FString.FromString(val);
            res.Number = number;
            return res;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is FName name)) return false;
            if (this is null || obj is null) return this is null && obj is null;
            if (this.Asset != name.Asset) return this.Value.ToString().Equals(name.Value.ToString()); // if assets aren't the same, compare string values
            return (this.Value == name.Value || this.Value.Value == name.Value.Value) && this.Number == name.Number;
        }

        public static bool operator ==(FName one, FName two)
        {
            if (one is null || two is null) return one is null && two is null;
            return one.Equals(two);
        }

        public static bool operator !=(FName one, FName two)
        {
            if (one is null || two is null) return !(one is null && two is null);
            return !one.Equals(two);
        }

        public override int GetHashCode()
        {
            return Value == null ? 0 : (Value.GetHashCode() ^ Number.GetHashCode());
        }

        public object Clone()
        {
            if (this.IsDummy) return DefineDummy(Asset, (FString)Value.Clone(), Number);
            return new FName(Asset, (FString)Value.Clone(), Number);
        }

        /// <summary>
        /// Creates a new FName instance.
        /// </summary>
        /// <param name="asset">The asset that this FName is bound to.</param>
        /// <param name="value">The string literal that the new FName's value will be, verbatim.</param>
        /// <param name="number">The instance number of the new FName.</param>
        public FName(INameMap asset, string value, int number = 0)
        {
            Asset = asset;
            if (value == null)
            {
                Value = new FString(null);
            }
            else
            {
                Value = new FString(value);
            }
            Number = number;
        }

        /// <summary>
        /// Creates a new FName instance.
        /// </summary>
        /// <param name="asset">The asset that this FName is bound to.</param>
        /// <param name="value">The FString that the FName's value will be, verbatim.</param>
        /// <param name="number">The instance number of the new FName.</param>
        public FName(INameMap asset, FString value, int number = 0)
        {
            Asset = asset;
            Value = value;
            Number = number;
        }

        /// <summary>
        /// Creates a new FName instance.
        /// </summary>
        /// <param name="asset">The asset that this FName is bound to.</param>
        /// <param name="index">The index that this FName's value will be.</param>
        /// <param name="number">The instance number of the new FName.</param>
        public FName(INameMap asset, int index, int number = 0)
        {
            Asset = asset;
            Index = index;
            Number = number;
        }

        /// <summary>
        /// Creates a new blank FName instance.
        /// </summary>
        /// <param name="asset">The asset that this FName is bound to.</param>
        public FName(INameMap asset)
        {
            Asset = asset;
            Value = new FString(string.Empty);
            Number = 0;
        }

        /// <summary>
        /// Creates a new blank FName instance, with no asset bound to it. An asset must be bound to this FName before setting its value.
        /// </summary>
        public FName()
        {
            Number = 0;
        }
    }
}


```

`UAssetAPI/UnrealTypes/FObjectDataResource.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UAssetAPI.UnrealTypes
{
    public enum EObjectDataResourceVersion : uint
    {
        Invalid,
		Initial,
        AddedCookedIndex,
        LatestPlusOne,
		Latest = LatestPlusOne - 1
	}

    [Flags]
    public enum EObjectDataResourceFlags
    {
        None					= 0,
	    Inline					= (1 << 0),
	    Streaming				= (1 << 1),
	    Optional				= (1 << 2),
	    Duplicate				= (1 << 3),
	    MemoryMapped			= (1 << 4),
	    DerivedDataReference	= (1 << 5),
    }

    /// <summary>
    /// UObject binary/bulk data resource type.
    /// </summary>
    public struct FObjectDataResource
    {
        public EObjectDataResourceFlags Flags;
        public byte CookedIndex;
        public long SerialOffset;
        public long DuplicateSerialOffset;
        public long SerialSize;
        public long RawSize;
        public FPackageIndex OuterIndex;
        public uint LegacyBulkDataFlags;

        public FObjectDataResource(EObjectDataResourceFlags Flags, long SerialOffset, long DuplicateSerialOffset, long SerialSize, long RawSize, FPackageIndex OuterIndex, uint LegacyBulkDataFlags, byte CookedIndex = 0)
        {
            this.Flags = Flags;
            this.CookedIndex = CookedIndex;
            this.SerialOffset = SerialOffset;
            this.DuplicateSerialOffset = DuplicateSerialOffset;
            this.SerialSize = SerialSize;
            this.RawSize = RawSize;
            this.OuterIndex = OuterIndex;
            this.LegacyBulkDataFlags = LegacyBulkDataFlags;
        }
    }
}

```

`UAssetAPI/UnrealTypes/FObjectThumbnail.cs`:

```cs
using System;
using Newtonsoft.Json;

namespace UAssetAPI.UnrealTypes
{
    // TODO: JSON serializer 

    /// <summary>
    /// Unreal Object Thumbnail - Thumbnail image data for an object.
    /// </summary>
    public class FObjectThumbnail
    {
        /// <summary>Thumbnail width</summary>
        public int Width;

        /// <summary>Thumbnail height</summary>
        public int Height;

        /// <summary>Compressed image data bytes</summary>
        public byte[] CompressedImageData = Array.Empty<byte>(); // TODO: FThumbnailCompressionInterface
        // TODO: Compress on demand?

        /// <summary>Image data bytes</summary>
        [JsonIgnore]
        public byte[] ImageData; // TODO: Uncompress on demand

        public FObjectThumbnail()
        {
        }
    }
}
```

`UAssetAPI/UnrealTypes/FPackageIndex.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.ExportTypes;
using UAssetAPI.JSON;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Wrapper for index into an ImportMap or ExportMap.
/// 
/// Values greater than zero indicate that this is an index into the ExportMap.
/// The actual array index will be (FPackageIndex - 1).
/// 
/// Values less than zero indicate that this is an index into the ImportMap.
/// The actual array index will be (-FPackageIndex - 1)
/// </summary>
[JsonConverter(typeof(FPackageIndexJsonConverter))]
public class FPackageIndex
{
    /// <summary>
    /// Values greater than zero indicate that this is an index into the ExportMap.
    /// The actual array index will be (FPackageIndex - 1).
    /// 
    /// Values less than zero indicate that this is an index into the ImportMap.
    /// The actual array index will be (-FPackageIndex - 1)
    /// </summary>
    public int Index;

    /// <summary>
    /// Returns an FPackageIndex based off of the index provided. Equivalent to <see cref="FPackageIndex(int)"/>.
    /// </summary>
    /// <param name="index">The index to create a new FPackageIndex with.</param>
    /// <returns>A new FPackageIndex with the index provided.</returns>
    public static FPackageIndex FromRawIndex(int index) => new FPackageIndex(index);

    /// <summary>
    /// Returns true if this is an index into the import map.
    /// </summary>
    /// <returns>true if this is an index into the import map, false otherwise</returns>
    public bool IsImport() => Index < 0;

    /// <summary>
    /// Returns true if this is an index into the export map.
    /// </summary>
    /// <returns>true if this is an index into the export map, false otherwise</returns>
    public bool IsExport() => Index > 0;

    /// <summary>
    /// Return true if this represents null (i.e. neither an import nor an export)
    /// </summary>
    /// <returns>true if this index represents null, false otherwise</returns>
    public bool IsNull() => this == null || Index == 0;

    /// <summary>
    /// Creates a FPackageIndex from an index in the import map.
    /// </summary>
    /// <param name="importIndex">An import index to create an FPackageIndex from.</param>
    /// <returns>An FPackageIndex created from the import index.</returns>
    /// <exception cref="System.InvalidOperationException">Thrown when the provided import index is less than zero.</exception>
    public static FPackageIndex FromImport(int importIndex)
    {
        if (importIndex < 0) throw new InvalidOperationException("importIndex must be greater than or equal to zero");
        return new FPackageIndex(-importIndex - 1);
    }

    /// <summary>
    /// Creates a FPackageIndex from an index in the export map.
    /// </summary>
    /// <param name="exportIndex">An export index to create an FPackageIndex from.</param>
    /// <returns>An FPackageIndex created from the export index.</returns>
    /// <exception cref="System.InvalidOperationException">Thrown when the provided export index is less than zero.</exception>
    public static FPackageIndex FromExport(int exportIndex)
    {
        if (exportIndex < 0) throw new InvalidOperationException("exportIndex must be greater than or equal to zero");
        return new FPackageIndex(exportIndex + 1);
    }

    /// <summary>
    /// Check that this is an import index and return the corresponding import.
    /// </summary>
    /// <param name="asset">The asset that this index is used in.</param>
    /// <returns>The import that this index represents in the import map.</returns>
    /// <exception cref="System.InvalidOperationException">Thrown when this is not an index into the import map.</exception>
    public Import ToImport(UAsset asset)
    {
        if (!IsImport()) throw new InvalidOperationException("Index = " + Index + "; cannot call ToImport()");

        int newIndex = -Index - 1;

        if (asset is UAsset uas)
        {
            if (newIndex < 0 || newIndex >= uas.Imports.Count) return null;
            return uas.Imports[newIndex];
        }
        return null;
    }

    /// <summary>
    /// Check that this is an export index and return the corresponding export.
    /// </summary>
    /// <param name="asset">The asset that this index is used in.</param>
    /// <returns>The export that this index represents in the the export map.</returns>
    /// <exception cref="System.InvalidOperationException">Thrown when this is not an index into the export map.</exception>
    public Export ToExport(UAsset asset)
    {
        if (!IsExport() || Index > asset.Exports.Count) throw new InvalidOperationException("Index = " + Index + "; cannot call ToExport()");
        return asset.Exports[Index - 1];
    }

    public T ToExport<T>(UAsset asset) where T : Export
    {
        if (!IsExport() || Index > asset.Exports.Count) throw new InvalidOperationException("Index = " + Index + "; cannot call ToExport()");
        return (T)asset.Exports[Index-1];
    }

    public override bool Equals(object obj)
    {
        if (!(obj is FPackageIndex comparingPackageIndex)) return false;
        return comparingPackageIndex.Index == this.Index;
    }

    public static bool operator <(FPackageIndex first, FPackageIndex second)
    {
        return first.Index < second.Index;
    }

    public static bool operator >(FPackageIndex first, FPackageIndex second)
    {
        return first.Index > second.Index;
    }

    public static bool operator <=(FPackageIndex first, FPackageIndex second)
    {
        return first.Index <= second.Index;
    }

    public static bool operator >=(FPackageIndex first, FPackageIndex second)
    {
        return first.Index >= second.Index;
    }

    public override int GetHashCode()
    {
        return Index.GetHashCode();
    }

    public override string ToString()
    {
        return Index.ToString();
    }

    public FPackageIndex(int index = 0)
    {
        Index = index;
    }

    public FPackageIndex(AssetBinaryReader reader)
    {
        Index = reader.ReadInt32();
    }

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(Index);
        return sizeof(int);
    }
}

```

`UAssetAPI/UnrealTypes/FPropertyTypeName.cs`:

```cs
using Newtonsoft.Json;
using System.Collections.Generic;

namespace UAssetAPI.UnrealTypes;

public struct FPropertyTypeNameNode(AssetBinaryReader Ar)
{
    public FName Name = Ar.ReadFName();
    public int InnerCount = Ar.ReadInt32();
}

public class FPropertyTypeNameConverter : JsonConverter<FPropertyTypeName>
{
    public override void WriteJson(JsonWriter writer, FPropertyTypeName value, JsonSerializer serializer)
    {
        if (value is null || !value.ShouldSerializeNodes)
            writer.WriteNull();
        else
        {
            serializer.Serialize(writer, value.Nodes);
        }
    }
    public override FPropertyTypeName ReadJson(JsonReader reader, System.Type objectType, FPropertyTypeName existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
        if (reader.TokenType == JsonToken.Null)
            return null;
        var nodes = serializer.Deserialize<List<FPropertyTypeNameNode>>(reader);
        return new FPropertyTypeName(nodes, true);
    }
}


[JsonConverter(typeof(FPropertyTypeNameConverter))]
public class FPropertyTypeName
{
    public List<FPropertyTypeNameNode> Nodes;
    public bool ShouldSerializeNodes = true;

    public FPropertyTypeName(List<FPropertyTypeNameNode> list, bool shouldSerialize = false)
    {
        Nodes = list;
        ShouldSerializeNodes = shouldSerialize;
    }

    public FPropertyTypeName(AssetBinaryReader reader)
    {
        Nodes = [];
        int totalNodes = 1;
        for (int i = 0; i < totalNodes; ++i)
        {
            var node = new FPropertyTypeNameNode(reader);
            Nodes.Add(node);
            totalNodes += node.InnerCount;
        }
    }

    public void Write(AssetBinaryWriter writer)
    {
        foreach (var node in Nodes)
        {
            writer.Write(node.Name);
            writer.Write(node.InnerCount);
        }
    }

    public FName GetName() => Nodes is { Count: > 0 } ? Nodes[0].Name : FName.DefineDummy(null, "None");

    public FPropertyTypeName GetParameter(int paramIndex)
    {
        if (Nodes is not { Count: > 0 } || paramIndex < 0 || paramIndex >= Nodes[0].InnerCount) return new FPropertyTypeName([]);

        var param = 1;
        for (int skip = paramIndex; skip > 0; --skip, ++param)
        {
            skip += Nodes[param].InnerCount;
        }

        return new(Nodes[param..]);
    }
}
```

`UAssetAPI/UnrealTypes/FString.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Text;
using UAssetAPI.JSON;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Unreal string - consists of a string and an encoding
/// </summary>
[JsonConverter(typeof(FStringJsonConverter))]
public class FString : ICloneable
{
    public string Value;
    public Encoding Encoding;
    public static readonly string NullCase = "null";

    /// <summary>
    /// Is this FString case preserving?
    /// </summary>
    public bool IsCasePreserving = true;

    public override string ToString()
    {
        if (this == null || Value == null) return NullCase;
        return Value;
    }

    public override bool Equals(object obj)
    {
        if (obj is FString fStr)
        {
            if (fStr == null) return false;
            return this.Value == fStr.Value && this.Encoding == fStr.Encoding;
        }
        else if (obj is string str)
        {
            return this.Value == str;
        }

        return false;
    }

    public static explicit operator FString(string b) => new FString(b, null);

    public static bool operator ==(FString one, FString two)
    {
        if (one is null || two is null) return one is null && two is null;
        return one.Equals(two);
    }

    public static bool operator !=(FString one, FString two)
    {
        if (one is null || two is null) return !(one is null && two is null);
        return !one.Equals(two);
    }

    public override int GetHashCode()
    {
        return Value.GetHashCode();
    }

    public object Clone()
    {
        return new FString(Value, Encoding);
    }

    public static FString FromString(string value, Encoding encoding = null)
    {
        if (value == NullCase || value == null) return null;
        return new FString(value, encoding);
    }

    public FString(string value, Encoding encoding = null)
    {
        if (encoding == null && value != null) encoding = Encoding.UTF8.GetByteCount(value) == value.Length ? Encoding.UTF8 : Encoding.Unicode;

        Value = value;
        Encoding = encoding;
    }

    public FString()
    {

    }
}

```

`UAssetAPI/UnrealTypes/FTextSourceData.cs`:

```cs
using Newtonsoft.Json;

namespace UAssetAPI.UnrealTypes
{
    public struct FTextSourceData
    {
        [JsonProperty] public FString SourceString { get; set; }
        [JsonProperty] public FLocMetadataObject SourceStringMetaData { get; set; }
    }
}
```

`UAssetAPI/UnrealTypes/FTextSourceSiteContext.cs`:

```cs
using Newtonsoft.Json;

namespace UAssetAPI.UnrealTypes
{
    public struct FTextSourceSiteContext
    {
        [JsonProperty] public FString KeyName { get; set; }
        [JsonProperty] public FString SiteDescription { get; set; }
        [JsonProperty] public bool IsEditorOnly { get; set; }
        [JsonProperty] public bool IsOptional { get; set; }
        [JsonProperty] public FLocMetadataObject InfoMetaData { get; set; }
        [JsonProperty] public FLocMetadataObject KeyMetaData { get; set; }
    }
}
```

`UAssetAPI/UnrealTypes/FUniversalObjectLocatorFragment.cs`:

```cs
using System;
using System.Collections.Generic;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.PropertyTypes.Structs;

namespace UAssetAPI.UnrealTypes;

public class UniversalObjectLocatorFragmentPropertyData : StructPropertyData
{
    private static Dictionary<string, string> FragmentTypeRegistry = new()
    {
        { "actor", "DirectPathObjectLocator" },
        { "animinst", "AnimInstanceLocatorFragment" },
        { "subobj", "SubObjectLocator" },
        { "ls_lazy_obj_ptr", "LegacyLazyObjectPtrFragment" },
    };

    public FName FragmentTypeID;

    public UniversalObjectLocatorFragmentPropertyData(FName name, FName forcedType) : base(name, forcedType) { }
    public UniversalObjectLocatorFragmentPropertyData(FName name) : base(name) { }
    public UniversalObjectLocatorFragmentPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("UniversalObjectLocatorFragment");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        FragmentTypeID = reader.ReadFName();
        if (FragmentTypeID.Value.Value == "None") return;

        if (FragmentTypeRegistry.TryGetValue(FragmentTypeID.Value.Value, out var structType))
        {
            StructType = FName.DefineDummy(reader.Asset, structType);
        }
        else
        {
            throw new FormatException($"Unknown FragmentTypeID : {FragmentTypeID}");
        }

        base.Read(reader, includeHeader, 1, leng2, PropertySerializationContext.StructFallback);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        writer.Write(FragmentTypeID);
        int res = 8;
        if (FragmentTypeID.Value.Value == "None") return res;
        res += base.Write(writer, includeHeader, PropertySerializationContext.StructFallback);
        return res;
    }
}
```

`UAssetAPI/UnrealTypes/FWorldTileInfo.cs`:

```cs
using System.IO;
using UAssetAPI.PropertyTypes.Structs;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;
using UAssetAPI.PropertyTypes.Objects;
using System.Xml.Linq;
using UAssetAPI.CustomVersions;

namespace UAssetAPI.UnrealTypes
{
    /// <summary>
    /// World layer information for tile tagging
    /// </summary>
    public class FWorldTileLayer
    {
        /// <summary>Human readable name for this layer</summary>
        public FString Name;

        /// <summary>Reserved for additional options</summary>
        public int Reserved0;
        /// <summary>Reserved for additional options</summary>
        public IntPointPropertyData Reserved1;

        /// <summary>Distance starting from where tiles belonging to this layer will be streamed in</summary>
        public int StreamingDistance;
        public bool DistanceStreamingEnabled;

        public void Read(AssetBinaryReader reader, UAsset asset)
        {
            Name = reader.ReadFString();
            Reserved0 = reader.ReadInt32();
            Reserved1 = new IntPointPropertyData(FName.DefineDummy(asset, "Reserved1"));
            Reserved1.Ancestry.Initialize(null, reader.Asset.GetParentClassExportName(out FName pcen2), pcen2);
            Reserved1.Read(reader, false, 0, 0);

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO_UPDATED)
            {
                StreamingDistance = reader.ReadInt32();
            }

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LAYER_ENABLE_DISTANCE_STREAMING)
            {
                DistanceStreamingEnabled = reader.ReadInt32() == 1;
            }
        }

        public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
        {
            var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
            ancestryNew.SetAsParent(FName.DefineDummy(asset, "WorldTileLayer"));

            Reserved1.ResolveAncestries(asset, ancestryNew);
        }

        public void Write(AssetBinaryWriter writer, UAsset asset)
        {
            writer.Write(this.Name);
            writer.Write(Reserved0);
            Reserved1.Write(writer, false);

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO_UPDATED)
            {
                writer.Write(StreamingDistance);
            }

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LAYER_ENABLE_DISTANCE_STREAMING)
            {
                writer.Write(DistanceStreamingEnabled ? 1 : 0);
            }
        }

        public FWorldTileLayer(FString name, int reserved0, IntPointPropertyData reserved1, int streamingDistance, bool distanceStreamingEnabled)
        {
            Name = name;
            Reserved0 = reserved0;
            Reserved1 = reserved1;
            StreamingDistance = streamingDistance;
            DistanceStreamingEnabled = distanceStreamingEnabled;
        }

        public FWorldTileLayer()
        {

        }
    }

    /// <summary>
    /// Describes LOD entry in a world tile
    /// </summary>
    public class FWorldTileLODInfo
    {
        /// <summary>Relative to LOD0 streaming distance, absolute distance = LOD0 + StreamingDistanceDelta</summary>
        public int RelativeStreamingDistance;

        /// <summary>Reserved for additional options</summary>
        public float Reserved0;
        /// <summary>Reserved for additional options</summary>
        public float Reserved1;
        /// <summary>Reserved for additional options</summary>
        public int Reserved2;
        /// <summary>Reserved for additional options</summary>
        public int Reserved3;

        public FWorldTileLODInfo(int relativeStreamingDistance, float reserved0, float reserved1, int reserved2, int reserved3)
        {
            RelativeStreamingDistance = relativeStreamingDistance;
            Reserved0 = reserved0;
            Reserved1 = reserved1;
            Reserved2 = reserved2;
            Reserved3 = reserved3;
        }

        public void Read(AssetBinaryReader reader, UAsset asset)
        {
            RelativeStreamingDistance = reader.ReadInt32();
            Reserved0 = reader.ReadSingle();
            Reserved1 = reader.ReadSingle();
            Reserved2 = reader.ReadInt32();
            Reserved3 = reader.ReadInt32();
        }

        public void Write(AssetBinaryWriter writer, UAsset asset)
        {
            writer.Write(RelativeStreamingDistance);
            writer.Write(Reserved0);
            writer.Write(Reserved1);
            writer.Write(Reserved2);
            writer.Write(Reserved3);
        }

        public FWorldTileLODInfo()
        {

        }
    }

    /// <summary>
    /// Tile information used by WorldComposition.
    /// Defines properties necessary for tile positioning in the world. Stored with package summary
    /// </summary>
    public class FWorldTileInfo
    {
        /// <summary>Tile position in the world relative to parent</summary>
        public int[] Position; // FIntVector
        /// <summary>Absolute tile position in the world. Calculated in runtime</summary>
        public int[] AbsolutePosition; // FIntVector
        /// <summary>Tile bounding box</summary>
        public BoxPropertyData Bounds;
        /// <summary>Tile assigned layer</summary>
        public FWorldTileLayer Layer;
        /// <summary>Whether to hide sub-level tile in tile view</summary>
        public bool bHideInTileView;
        /// <summary>Parent tile package name</summary>
        public FString ParentTilePackageName;
        /// <summary>LOD information</summary>
        public FWorldTileLODInfo[] LODList;
        /// <summary>Sorting order</summary>
        public int ZOrder;

        public void Read(AssetBinaryReader reader, UAsset asset)
        {
            Position = new int[3];
            AbsolutePosition = new int[3];

            if (asset.GetCustomVersion<FFortniteMainBranchObjectVersion>() < FFortniteMainBranchObjectVersion.WorldCompositionTile3DOffset)
            {
                Position[0] = reader.ReadInt32();
                Position[1] = reader.ReadInt32();
                Position[2] = 0;
            }
            else
            {
                Position[0] = reader.ReadInt32();
                Position[1] = reader.ReadInt32();
                Position[2] = reader.ReadInt32();
            }
            Bounds = new BoxPropertyData(FName.DefineDummy(asset, "Bounds"));
            Bounds.Ancestry.Initialize(null, reader.Asset.GetParentClassExportName(out FName pcen2), pcen2);
            Bounds.Read(reader, false, 0, 0);
            Layer = new FWorldTileLayer();
            Layer.Read(reader, asset);

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO_UPDATED)
            {
                bHideInTileView = reader.ReadInt32() == 1;
                ParentTilePackageName = reader.ReadFString();
            }

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO_LOD_LIST)
            {
                int numEntries = reader.ReadInt32();
                LODList = new FWorldTileLODInfo[numEntries];
                for (int i = 0; i < numEntries; i++)
                {
                    LODList[i] = new FWorldTileLODInfo();
                    LODList[i].Read(reader, asset);
                }
            }

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO_ZORDER)
            {
                ZOrder = reader.ReadInt32();
            }

#pragma warning disable CS0162 // Unreachable code detected
            if (false) // Ar.GetPortFlags() & PPF_DuplicateForPIE
            {
                AbsolutePosition[0] = reader.ReadInt32();
                AbsolutePosition[1] = reader.ReadInt32();
                AbsolutePosition[2] = reader.ReadInt32();
            }
#pragma warning restore CS0162 // Unreachable code detected
        }

        public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
        {
            var ancestryNew = (AncestryInfo)ancestrySoFar.Clone();
            ancestryNew.SetAsParent(FName.DefineDummy(asset, "WorldTileInfo"));

            Bounds.ResolveAncestries(asset, ancestryNew);
            Layer.ResolveAncestries(asset, ancestryNew);
        }

        public void Write(AssetBinaryWriter writer, UAsset asset)
        {
            if (asset.GetCustomVersion<FFortniteMainBranchObjectVersion>() < FFortniteMainBranchObjectVersion.WorldCompositionTile3DOffset)
            {
                writer.Write(Position[0]);
                writer.Write(Position[1]);
            }
            else
            {
                writer.Write(Position[0]);
                writer.Write(Position[1]);
                writer.Write(Position[2]);
            }
            Bounds.Write(writer, false);
            Layer.Write(writer, asset);

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO_UPDATED)
            {
                writer.Write(bHideInTileView ? 1 : 0);
                writer.Write(ParentTilePackageName);
            }

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO_LOD_LIST)
            {
                writer.Write(LODList.Length);
                for (int i = 0; i < LODList.Length; i++)
                {
                    LODList[i].Write(writer, asset);
                }
            }

            if (asset.ObjectVersion >= ObjectVersion.VER_UE4_WORLD_LEVEL_INFO_ZORDER)
            {
                writer.Write(ZOrder);
            }

#pragma warning disable CS0162 // Unreachable code detected
            if (false) // Ar.GetPortFlags() & PPF_DuplicateForPIE
            {
                writer.Write(AbsolutePosition[0]);
                writer.Write(AbsolutePosition[1]);
                writer.Write(AbsolutePosition[2]);
            }
#pragma warning restore CS0162 // Unreachable code detected
        }

        public FWorldTileInfo(int[] position, int[] absolutePosition, BoxPropertyData bounds, FWorldTileLayer layer, bool bHideInTileView, FString parentTilePackageName, FWorldTileLODInfo[] lODList, int zOrder)
        {
            Position = position;
            AbsolutePosition = absolutePosition;
            Bounds = bounds;
            Layer = layer;
            this.bHideInTileView = bHideInTileView;
            ParentTilePackageName = parentTilePackageName;
            LODList = lODList;
            ZOrder = zOrder;
        }

        public FWorldTileInfo()
        {

        }
    }
}

```

`UAssetAPI/UnrealTypes/Flags.cs`:

```cs
using System;
using UAssetAPI.ExportTypes;

namespace UAssetAPI.UnrealTypes
{
    /// <summary>
    /// Flags describing an object instance
    /// </summary>
    [Flags]
    public enum EObjectFlags
    {
        RF_NoFlags = 0x00000000,
        RF_Public = 0x00000001,
        RF_Standalone = 0x00000002,
        RF_MarkAsNative = 0x00000004,
        RF_Transactional = 0x00000008,
        RF_ClassDefaultObject = 0x00000010,
        RF_ArchetypeObject = 0x00000020,
        RF_Transient = 0x00000040,
        RF_MarkAsRootSet = 0x00000080,
        RF_TagGarbageTemp = 0x00000100,
        RF_NeedInitialization = 0x00000200,
        RF_NeedLoad = 0x00000400,
        RF_KeepForCooker = 0x00000800,
        RF_NeedPostLoad = 0x00001000,
        RF_NeedPostLoadSubobjects = 0x00002000,
        RF_NewerVersionExists = 0x00004000,
        RF_BeginDestroyed = 0x00008000,
        RF_FinishDestroyed = 0x00010000,
        RF_BeingRegenerated = 0x00020000,
        RF_DefaultSubObject = 0x00040000,
        RF_WasLoaded = 0x00080000,
        RF_TextExportTransient = 0x00100000,
        RF_LoadCompleted = 0x00200000,
        RF_InheritableComponentTemplate = 0x00400000,
        RF_DuplicateTransient = 0x00800000,
        RF_StrongRefOnFrame = 0x01000000,
        RF_NonPIEDuplicateTransient = 0x02000000,
        RF_Dynamic = 0x04000000,
        RF_WillBeLoaded = 0x08000000,
        RF_HasExternalPackage = 0x10000000
    }

    /// <summary>
    /// Package flags, passed into UPackage::SetPackageFlags and related functions in the Unreal Engine
    /// </summary>
    [Flags]
    public enum EPackageFlags : uint
    {
	    ///<summary>No flags</summary>
	    PKG_None = 0x00000000,
	    ///<summary>Newly created package, not saved yet. In editor only.</summary>
	    PKG_NewlyCreated = 0x00000001,
	    ///<summary>Purely optional for clients.</summary>
	    PKG_ClientOptional = 0x00000002,
	    ///<summary>Only needed on the server side.</summary>
	    PKG_ServerSideOnly = 0x00000004,
	    ///<summary>This package is from "compiled in" classes.</summary>
	    PKG_CompiledIn = 0x00000010,
	    ///<summary>This package was loaded just for the purposes of diffing</summary>
	    PKG_ForDiffing = 0x00000020,
	    ///<summary>This is editor-only package (for example: editor module script package)</summary>
	    PKG_EditorOnly = 0x00000040,
	    ///<summary>Developer module</summary>
	    PKG_Developer = 0x00000080,
	    ///<summary>Loaded only in uncooked builds (i.e. runtime in editor)</summary>
	    PKG_UncookedOnly = 0x00000100,
	    ///<summary>Package is cooked</summary>
	    PKG_Cooked = 0x00000200,
	    ///<summary>Package doesn't contain any asset object (although asset tags can be present)</summary>
	    PKG_ContainsNoAsset = 0x00000400,
	    ///<summary>Uses unversioned property serialization instead of versioned tagged property serialization</summary>
	    PKG_UnversionedProperties = 0x00002000,
	    ///<summary>Contains map data (UObjects only referenced by a single ULevel) but is stored in a different package</summary>
	    PKG_ContainsMapData = 0x00004000,
	    ///<summary>package is currently being compiled</summary>
	    PKG_Compiling = 0x00010000,
	    ///<summary>Set if the package contains a ULevel/ UWorld object</summary>
	    PKG_ContainsMap = 0x00020000,
	    ///<summary>???</summary>
	    PKG_RequiresLocalizationGather = 0x00040000,
	    ///<summary>Set if the package was created for the purpose of PIE</summary>
	    PKG_PlayInEditor = 0x00100000,
	    ///<summary>Package is allowed to contain UClass objects</summary>
	    PKG_ContainsScript = 0x00200000,
	    ///<summary>Editor should not export asset in this package</summary>
	    PKG_DisallowExport = 0x00400000,
	    ///<summary>This package should resolve dynamic imports from its export at runtime.</summary>
	    PKG_DynamicImports = 0x10000000,
	    ///<summary>This package contains elements that are runtime generated, and may not follow standard loading order rules</summary>
	    PKG_RuntimeGenerated = 0x20000000,
	    ///<summary>This package is reloading in the cooker, try to avoid getting data we will never need. We won't save this package.</summary>
	    PKG_ReloadingForCooker = 0x40000000,
	    ///<summary>Package has editor-only data filtered out</summary>
	    PKG_FilterEditorOnly = 0x80000000,
    }

    /// <summary>
    /// Flags associated with each property in a class, overriding the property's default behavior.
    /// </summary>
    [Flags]
    public enum EPropertyFlags : ulong
    {
        CPF_None = 0,

        ///<summary>Property is user-settable in the editor.</summary>
        CPF_Edit = 0x0000000000000001,
        ///<summary>This is a constant function parameter</summary>
        CPF_ConstParm = 0x0000000000000002,
        ///<summary>This property can be read by blueprint code</summary>
        CPF_BlueprintVisible = 0x0000000000000004,
        ///<summary>Object can be exported with actor.</summary>
        CPF_ExportObject = 0x0000000000000008,
        ///<summary>This property cannot be modified by blueprint code</summary>
        CPF_BlueprintReadOnly = 0x0000000000000010,
        ///<summary>Property is relevant to network replication.</summary>
        CPF_Net = 0x0000000000000020,
        ///<summary>Indicates that elements of an array can be modified, but its size cannot be changed.</summary>
        CPF_EditFixedSize = 0x0000000000000040,
        ///<summary>Function/When call parameter.</summary>
        CPF_Parm = 0x0000000000000080,
        ///<summary>Value is copied out after function call.</summary>
        CPF_OutParm = 0x0000000000000100,
        ///<summary>memset is fine for construction</summary>
        CPF_ZeroConstructor = 0x0000000000000200,
        ///<summary>Return value.</summary>
        CPF_ReturnParm = 0x0000000000000400,
        ///<summary>Disable editing of this property on an archetype/sub-blueprint</summary>
        CPF_DisableEditOnTemplate = 0x0000000000000800,
        ///<summary>Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.</summary>
        CPF_Transient = 0x0000000000002000,
        ///<summary>Property should be loaded/saved as permanent profile.</summary>
        CPF_Config = 0x0000000000004000,
        ///<summary>Disable editing on an instance of this class</summary>
        CPF_DisableEditOnInstance = 0x0000000000010000,
        ///<summary>Property is uneditable in the editor.</summary>
        CPF_EditConst = 0x0000000000020000,
        ///<summary>Load config from base class, not subclass.</summary>
        CPF_GlobalConfig = 0x0000000000040000,
        ///<summary>Property is a component references.</summary>
        CPF_InstancedReference = 0x0000000000080000,
        ///<summary>Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)</summary>
        CPF_DuplicateTransient = 0x0000000000200000,
        ///<summary>Property should be serialized for save games, this is only checked for game-specific archives with ArIsSaveGame</summary>
        CPF_SaveGame = 0x0000000001000000,
        ///<summary>Hide clear (and browse) button.</summary>
        CPF_NoClear = 0x0000000002000000,
        ///<summary>Value is passed by reference; CPF_OutParam and CPF_Param should also be set.</summary>
        CPF_ReferenceParm = 0x0000000008000000,
        ///<summary>MC Delegates only.  Property should be exposed for assigning in blueprint code</summary>
        CPF_BlueprintAssignable = 0x0000000010000000,
        ///<summary>Property is deprecated.  Read it from an archive, but don't save it.</summary>
        CPF_Deprecated = 0x0000000020000000,
        ///<summary>If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue</summary>
        CPF_IsPlainOldData = 0x0000000040000000,
        ///<summary>Not replicated. For non replicated properties in replicated structs </summary>
        CPF_RepSkip = 0x0000000080000000,
        ///<summary>Notify actors when a property is replicated</summary>
        CPF_RepNotify = 0x0000000100000000,
        ///<summary>interpolatable property for use with matinee</summary>
        CPF_Interp = 0x0000000200000000,
        ///<summary>Property isn't transacted</summary>
        CPF_NonTransactional = 0x0000000400000000,
        ///<summary>Property should only be loaded in the editor</summary>
        CPF_EditorOnly = 0x0000000800000000,
        ///<summary>No destructor</summary>
        CPF_NoDestructor = 0x0000001000000000,
        ///<summary>Only used for weak pointers, means the export type is autoweak</summary>
        CPF_AutoWeak = 0x0000004000000000,
        ///<summary>Property contains component references.</summary>
        CPF_ContainsInstancedReference = 0x0000008000000000,
        ///<summary>asset instances will add properties with this flag to the asset registry automatically</summary>
        CPF_AssetRegistrySearchable = 0x0000010000000000,
        ///<summary>The property is visible by default in the editor details view</summary>
        CPF_SimpleDisplay = 0x0000020000000000,
        ///<summary>The property is advanced and not visible by default in the editor details view</summary>
        CPF_AdvancedDisplay = 0x0000040000000000,
        ///<summary>property is protected from the perspective of script</summary>
        CPF_Protected = 0x0000080000000000,
        ///<summary>MC Delegates only.  Property should be exposed for calling in blueprint code</summary>
        CPF_BlueprintCallable = 0x0000100000000000,
        ///<summary>MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.</summary>
        CPF_BlueprintAuthorityOnly = 0x0000200000000000,
        ///<summary>Property shouldn't be exported to text format (e.g. copy/paste)</summary>
        CPF_TextExportTransient = 0x0000400000000000,
        ///<summary>Property should only be copied in PIE</summary>
        CPF_NonPIEDuplicateTransient = 0x0000800000000000,
        ///<summary>Property is exposed on spawn</summary>
        CPF_ExposeOnSpawn = 0x0001000000000000,
        ///<summary>A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)</summary>
        CPF_PersistentInstance = 0x0002000000000000,
        ///<summary>Property was parsed as a wrapper class like TSubclassOf T, FScriptInterface etc., rather than a USomething*</summary>
        CPF_UObjectWrapper = 0x0004000000000000,
        ///<summary>This property can generate a meaningful hash value.</summary>
        CPF_HasGetValueTypeHash = 0x0008000000000000,
        ///<summary>Public native access specifier</summary>
        CPF_NativeAccessSpecifierPublic = 0x0010000000000000,
        ///<summary>Protected native access specifier</summary>
        CPF_NativeAccessSpecifierProtected = 0x0020000000000000,
        ///<summary>Private native access specifier</summary>
        CPF_NativeAccessSpecifierPrivate = 0x0040000000000000,
        ///<summary>Property shouldn't be serialized, can still be exported to text</summary>
        CPF_SkipSerialization = 0x0080000000000000,
    }

    /// <summary>
    /// Flags describing a class.
    /// </summary>
    [Flags]
    public enum EClassFlags : uint
    {
        /// <summary>No Flags</summary>
        CLASS_None = 0x00000000,
        /// <summary>Class is abstract and can't be instantiated directly.</summary>
        CLASS_Abstract = 0x00000001,
        /// <summary>Save object configuration only to Default INIs, never to local INIs. Must be combined with CLASS_Config</summary>
        CLASS_DefaultConfig = 0x00000002,
        /// <summary>Load object configuration at construction time.</summary>
        CLASS_Config = 0x00000004,
        /// <summary>This object type can't be saved; null it out at save time.</summary>
        CLASS_Transient = 0x00000008,
        /// <summary>Successfully parsed.</summary>
        CLASS_Parsed = 0x00000010,
        /// <summary>???</summary>
        CLASS_MatchedSerializers = 0x00000020,
        /// <summary>Indicates that the config settings for this class will be saved to Project/User*.ini (similar to CLASS_GlobalUserConfig)</summary>
        CLASS_ProjectUserConfig = 0x00000040,
        /// <summary>Class is a native class - native interfaces will have CLASS_Native set, but not RF_MarkAsNative</summary>
        CLASS_Native = 0x00000080,
        /// <summary>Don't export to C++ header.</summary>
        CLASS_NoExport = 0x00000100,
        /// <summary>Do not allow users to create in the editor.</summary>
        CLASS_NotPlaceable = 0x00000200,
        /// <summary>Handle object configuration on a per-object basis, rather than per-class.</summary>
        CLASS_PerObjectConfig = 0x00000400,
        /// <summary>Whether SetUpRuntimeReplicationData still needs to be called for this class</summary>
        CLASS_ReplicationDataIsSetUp = 0x00000800u,
        /// <summary>Class can be constructed from editinline New button.</summary>
        CLASS_EditInlineNew = 0x00001000,
        /// <summary>Display properties in the editor without using categories.</summary>
        CLASS_CollapseCategories = 0x00002000,
        /// <summary>Class is an interface</summary>
        CLASS_Interface = 0x00004000,
        /// <summary>Do not export a constructor for this class, assuming it is in the cpptext</summary>
        CLASS_CustomConstructor = 0x00008000,
        /// <summary>All properties and functions in this class are const and should be exported as const</summary>
        CLASS_Const = 0x00010000,
        /// <summary>Class flag indicating the class is having its layout changed, and therefore is not ready for a CDO to be created</summary>
        CLASS_LayoutChanging = 0x00020000,
        /// <summary>Indicates that the class was created from blueprint source material</summary>
        CLASS_CompiledFromBlueprint = 0x00040000,
        /// <summary>Indicates that only the bare minimum bits of this class should be DLL exported/imported</summary>
        CLASS_MinimalAPI = 0x00080000,
        /// <summary>Indicates this class must be DLL exported/imported (along with all of it's members)</summary>
        CLASS_RequiredAPI = 0x00100000,
        /// <summary>Indicates that references to this class default to instanced. Used to be subclasses of UComponent, but now can be any UObject</summary>
        CLASS_DefaultToInstanced = 0x00200000,
        /// <summary>Indicates that the parent token stream has been merged with ours.</summary>
        CLASS_TokenStreamAssembled = 0x00400000,
        /// <summary>Class has component properties.</summary>
        CLASS_HasInstancedReference = 0x00800000,
        /// <summary>Don't show this class in the editor class browser or edit inline new menus.</summary>
        CLASS_Hidden = 0x01000000,
        /// <summary>Don't save objects of this class when serializing</summary>
        CLASS_Deprecated = 0x02000000,
        /// <summary>Class not shown in editor drop down for class selection</summary>
        CLASS_HideDropDown = 0x04000000,
        /// <summary>Class settings are saved to AppData/..../Blah.ini (as opposed to CLASS_DefaultConfig)</summary>
        CLASS_GlobalUserConfig = 0x08000000,
        /// <summary>Class was declared directly in C++ and has no boilerplate generated by UnrealHeaderTool</summary>
        CLASS_Intrinsic = 0x10000000,
        /// <summary>Class has already been constructed (maybe in a previous DLL version before hot-reload).</summary>
        CLASS_Constructed = 0x20000000,
        /// <summary>Indicates that object configuration will not check against ini base/defaults when serialized</summary>
        CLASS_ConfigDoNotCheckDefaults = 0x40000000,
        /// <summary>Class has been consigned to oblivion as part of a blueprint recompile, and a newer version currently exists.</summary>
        CLASS_NewerVersionExists = 0x80000000,
    };

    /// <summary>
    /// Flags describing a function.
    /// </summary>
    [Flags]
    public enum EFunctionFlags : uint {
        FUNC_None = 0x00000000,
        FUNC_Final = 0x00000001,
        FUNC_RequiredAPI = 0x00000002,
        FUNC_BlueprintAuthorityOnly = 0x00000004,
        FUNC_BlueprintCosmetic = 0x00000008,
        FUNC_Net = 0x00000040,
        FUNC_NetReliable = 0x00000080,
        FUNC_NetRequest = 0x00000100,
        FUNC_Exec = 0x00000200,
        FUNC_Native = 0x00000400,
        FUNC_Event = 0x00000800,
        FUNC_NetResponse = 0x00001000,
        FUNC_Static = 0x00002000,
        FUNC_NetMulticast = 0x00004000,
        FUNC_UbergraphFunction = 0x00008000,
        FUNC_MulticastDelegate = 0x00010000,
        FUNC_Public = 0x00020000,
        FUNC_Private = 0x00040000,
        FUNC_Protected = 0x00080000,
        FUNC_Delegate = 0x00100000,
        FUNC_NetServer = 0x00200000,
        FUNC_HasOutParms = 0x00400000,
        FUNC_HasDefaults = 0x00800000,
        FUNC_NetClient = 0x01000000,
        FUNC_DLLImport = 0x02000000,
        FUNC_BlueprintCallable = 0x04000000,
        FUNC_BlueprintEvent = 0x08000000,
        FUNC_BlueprintPure = 0x10000000,
        FUNC_EditorOnly = 0x20000000,
        FUNC_Const = 0x40000000,
        FUNC_NetValidate = 0x80000000,
        FUNC_AllFlags = 0xFFFFFFFF,
    };
}

```

`UAssetAPI/UnrealTypes/ObjectVersion.cs`:

```cs
namespace UAssetAPI.UnrealTypes
{
    /// <summary>
    /// An enum used to represent the global object version of UE4.
    /// </summary>
    public enum ObjectVersion
    {
        UNKNOWN = 0,
        VER_UE4_OLDEST_LOADABLE_PACKAGE = 214,

        /// <summary>Removed restriction on blueprint-exposed variables from being read-only</summary>
        VER_UE4_BLUEPRINT_VARS_NOT_READ_ONLY,
        /// <summary>Added manually serialized element to UStaticMesh (precalculated nav collision)</summary>
        VER_UE4_STATIC_MESH_STORE_NAV_COLLISION,
        /// <summary>Changed property name for atmospheric fog</summary>
        VER_UE4_ATMOSPHERIC_FOG_DECAY_NAME_CHANGE,
        /// <summary>Change many properties/functions from Translation to Location</summary>
        VER_UE4_SCENECOMP_TRANSLATION_TO_LOCATION,
        /// <summary>Material attributes reordering</summary>
        VER_UE4_MATERIAL_ATTRIBUTES_REORDERING,
        /// <summary>Collision Profile setting has been added, and all components that exists has to be properly upgraded</summary>
        VER_UE4_COLLISION_PROFILE_SETTING,
        /// <summary>Making the blueprint's skeleton class transient</summary>
        VER_UE4_BLUEPRINT_SKEL_TEMPORARY_TRANSIENT,
        /// <summary>Making the blueprint's skeleton class serialized again</summary>
        VER_UE4_BLUEPRINT_SKEL_SERIALIZED_AGAIN,
        /// <summary>Blueprint now controls replication settings again</summary>
        VER_UE4_BLUEPRINT_SETS_REPLICATION,
        /// <summary>Added level info used by World browser</summary>
        VER_UE4_WORLD_LEVEL_INFO,
        /// <summary>Changed capsule height to capsule half-height (afterwards)</summary>
        VER_UE4_AFTER_CAPSULE_HALF_HEIGHT_CHANGE,
        /// <summary>Added Namepace, GUID (Key) and Flags to FText</summary>
        VER_UE4_ADDED_NAMESPACE_AND_KEY_DATA_TO_FTEXT,
        /// <summary>Attenuation shapes</summary>
        VER_UE4_ATTENUATION_SHAPES,
        /// <summary>Use IES texture multiplier even when IES brightness is not being used</summary>
        VER_UE4_LIGHTCOMPONENT_USE_IES_TEXTURE_MULTIPLIER_ON_NON_IES_BRIGHTNESS,
        /// <summary>Removed InputComponent as a blueprint addable component</summary>
        VER_UE4_REMOVE_INPUT_COMPONENTS_FROM_BLUEPRINTS,
        /// <summary>Use an FMemberReference struct in UK2Node_Variable</summary>
        VER_UE4_VARK2NODE_USE_MEMBERREFSTRUCT,
        /// <summary>Refactored material expression inputs for UMaterialExpressionSceneColor and UMaterialExpressionSceneDepth</summary>
        VER_UE4_REFACTOR_MATERIAL_EXPRESSION_SCENECOLOR_AND_SCENEDEPTH_INPUTS,
        /// <summary>Spline meshes changed from Z forwards to configurable</summary>
        VER_UE4_SPLINE_MESH_ORIENTATION,
        /// <summary>Added ReverbEffect asset type</summary>
        VER_UE4_REVERB_EFFECT_ASSET_TYPE,
        /// <summary>changed max texcoords from 4 to 8</summary>
        VER_UE4_MAX_TEXCOORD_INCREASED,
        /// <summary>static meshes changed to support SpeedTrees</summary>
        VER_UE4_SPEEDTREE_STATICMESH,
        /// <summary>Landscape component reference between landscape component and collision component</summary>
        VER_UE4_LANDSCAPE_COMPONENT_LAZY_REFERENCES,
        /// <summary>Refactored UK2Node_CallFunction to use FMemberReference</summary>
        VER_UE4_SWITCH_CALL_NODE_TO_USE_MEMBER_REFERENCE,
        /// <summary>Added fixup step to remove skeleton class references from blueprint objects</summary>
        VER_UE4_ADDED_SKELETON_ARCHIVER_REMOVAL,
        /// <summary>See above, take 2.</summary>
        VER_UE4_ADDED_SKELETON_ARCHIVER_REMOVAL_SECOND_TIME,
        /// <summary>Making the skeleton class on blueprints transient</summary>
        VER_UE4_BLUEPRINT_SKEL_CLASS_TRANSIENT_AGAIN,
        /// <summary>UClass knows if it's been cooked</summary>
        VER_UE4_ADD_COOKED_TO_UCLASS,
        /// <summary>Deprecated static mesh thumbnail properties were removed</summary>
        VER_UE4_DEPRECATED_STATIC_MESH_THUMBNAIL_PROPERTIES_REMOVED,
        /// <summary>Added collections in material shader map ids</summary>
        VER_UE4_COLLECTIONS_IN_SHADERMAPID,
        /// <summary>Renamed some Movement Component properties, added PawnMovementComponent</summary>
        VER_UE4_REFACTOR_MOVEMENT_COMPONENT_HIERARCHY,
        /// <summary>Swap UMaterialExpressionTerrainLayerSwitch::LayerUsed/LayerNotUsed the correct way round</summary>
        VER_UE4_FIX_TERRAIN_LAYER_SWITCH_ORDER,
        /// <summary>Remove URB_ConstraintSetup</summary>
        VER_UE4_ALL_PROPS_TO_CONSTRAINTINSTANCE,
        /// <summary>Low quality directional lightmaps</summary>
        VER_UE4_LOW_QUALITY_DIRECTIONAL_LIGHTMAPS,
        /// <summary>Added NoiseEmitterComponent and removed related Pawn properties.</summary>
        VER_UE4_ADDED_NOISE_EMITTER_COMPONENT,
        /// <summary>Add text component vertical alignment</summary>
        VER_UE4_ADD_TEXT_COMPONENT_VERTICAL_ALIGNMENT,
        /// <summary>Added AssetImportData for FBX asset types, deprecating SourceFilePath and SourceFileTimestamp</summary>
        VER_UE4_ADDED_FBX_ASSET_IMPORT_DATA,
        /// <summary>Remove LevelBodySetup from ULevel</summary>
        VER_UE4_REMOVE_LEVELBODYSETUP,
        /// <summary>Refactor character crouching</summary>
        VER_UE4_REFACTOR_CHARACTER_CROUCH,
        /// <summary>Trimmed down material shader debug information.</summary>
        VER_UE4_SMALLER_DEBUG_MATERIALSHADER_UNIFORM_EXPRESSIONS,
        /// <summary>APEX Clothing</summary>
        VER_UE4_APEX_CLOTH,
        /// <summary>
        /// Change Collision Channel to save only modified ones than all of them.
        /// Note!!! Once we pass this CL, we can rename FCollisionResponseContainer enum values.
        /// We should rename to match ECollisionChannel
        /// </summary>
        VER_UE4_SAVE_COLLISIONRESPONSE_PER_CHANNEL,
        /// <summary>Added Landscape Spline editor meshes</summary>
        VER_UE4_ADDED_LANDSCAPE_SPLINE_EDITOR_MESH,
        /// <summary>Fixup input expressions for reading from refraction material attributes.</summary>
        VER_UE4_CHANGED_MATERIAL_REFACTION_TYPE,
        /// <summary>Refactor projectile movement, along with some other movement component work.</summary>
        VER_UE4_REFACTOR_PROJECTILE_MOVEMENT,
        /// <summary>Remove PhysicalMaterialProperty and replace with user defined enum</summary>
        VER_UE4_REMOVE_PHYSICALMATERIALPROPERTY,
        /// <summary>Removed all compile outputs from FMaterial</summary>
        VER_UE4_PURGED_FMATERIAL_COMPILE_OUTPUTS,
        /// <summary>Ability to save cooked PhysX meshes to Landscape</summary>
        VER_UE4_ADD_COOKED_TO_LANDSCAPE,
        /// <summary>Change how input component consumption works</summary>
        VER_UE4_CONSUME_INPUT_PER_BIND,
        /// <summary>Added new Graph based SoundClass Editor</summary>
        VER_UE4_SOUND_CLASS_GRAPH_EDITOR,
        /// <summary>Fixed terrain layer node guids which was causing artifacts</summary>
        VER_UE4_FIXUP_TERRAIN_LAYER_NODES,
        /// <summary>Added clamp min/max swap check to catch older materials</summary>
        VER_UE4_RETROFIT_CLAMP_EXPRESSIONS_SWAP,
        /// <summary>Remove static/movable/stationary light classes</summary>
        VER_UE4_REMOVE_LIGHT_MOBILITY_CLASSES,
        /// <summary>Refactor the way physics blending works to allow partial blending</summary>
        VER_UE4_REFACTOR_PHYSICS_BLENDING,
        /// <summary>WorldLevelInfo: Added reference to parent level and streaming distance</summary>
        VER_UE4_WORLD_LEVEL_INFO_UPDATED,
        /// <summary>Fixed cooking of skeletal/static meshes due to bad serialization logic</summary>
        VER_UE4_STATIC_SKELETAL_MESH_SERIALIZATION_FIX,
        /// <summary>Removal of InterpActor and PhysicsActor</summary>
        VER_UE4_REMOVE_STATICMESH_MOBILITY_CLASSES,
        /// <summary>Refactor physics transforms</summary>
        VER_UE4_REFACTOR_PHYSICS_TRANSFORMS,
        /// <summary>Remove zero triangle sections from static meshes and compact material indices.</summary>
        VER_UE4_REMOVE_ZERO_TRIANGLE_SECTIONS,
        /// <summary>Add param for deceleration in character movement instead of using acceleration.</summary>
        VER_UE4_CHARACTER_MOVEMENT_DECELERATION,
        /// <summary>Made ACameraActor use a UCameraComponent for parameter storage, etc...</summary>
        VER_UE4_CAMERA_ACTOR_USING_CAMERA_COMPONENT,
        /// <summary>Deprecated some pitch/roll properties in CharacterMovementComponent</summary>
        VER_UE4_CHARACTER_MOVEMENT_DEPRECATE_PITCH_ROLL,
        /// <summary>Rebuild texture streaming data on load for uncooked builds</summary>
        VER_UE4_REBUILD_TEXTURE_STREAMING_DATA_ON_LOAD,
        /// <summary>Add support for 32 bit index buffers for static meshes.</summary>
        VER_UE4_SUPPORT_32BIT_STATIC_MESH_INDICES,
        /// <summary>Added streaming install ChunkID to AssetData and UPackage</summary>
        VER_UE4_ADDED_CHUNKID_TO_ASSETDATA_AND_UPACKAGE,
        /// <summary>Add flag to control whether Character blueprints receive default movement bindings.</summary>
        VER_UE4_CHARACTER_DEFAULT_MOVEMENT_BINDINGS,
        /// <summary>APEX Clothing LOD Info</summary>
        VER_UE4_APEX_CLOTH_LOD,
        /// <summary>Added atmospheric fog texture data to be general</summary>
        VER_UE4_ATMOSPHERIC_FOG_CACHE_DATA,
        /// <summary>Arrays serialize their inner's tags</summary>
        VAR_UE4_ARRAY_PROPERTY_INNER_TAGS,
        /// <summary>Skeletal mesh index data is kept in memory in game to support mesh merging.</summary>
        VER_UE4_KEEP_SKEL_MESH_INDEX_DATA,
        /// <summary>Added compatibility for the body instance collision change</summary>
        VER_UE4_BODYSETUP_COLLISION_CONVERSION,
        /// <summary>Reflection capture cooking</summary>
        VER_UE4_REFLECTION_CAPTURE_COOKING,
        /// <summary>Removal of DynamicTriggerVolume, DynamicBlockingVolume, DynamicPhysicsVolume</summary>
        VER_UE4_REMOVE_DYNAMIC_VOLUME_CLASSES,
        /// <summary>Store an additional flag in the BodySetup to indicate whether there is any cooked data to load</summary>
        VER_UE4_STORE_HASCOOKEDDATA_FOR_BODYSETUP,
        /// <summary>Changed name of RefractionBias to RefractionDepthBias.</summary>
        VER_UE4_REFRACTION_BIAS_TO_REFRACTION_DEPTH_BIAS,
        /// <summary>Removal of SkeletalPhysicsActor</summary>
        VER_UE4_REMOVE_SKELETALPHYSICSACTOR,
        /// <summary>PlayerController rotation input refactor</summary>
        VER_UE4_PC_ROTATION_INPUT_REFACTOR,
        /// <summary>Landscape Platform Data cooking</summary>
        VER_UE4_LANDSCAPE_PLATFORMDATA_COOKING,
        /// <summary>Added call for linking classes in CreateExport to ensure memory is initialized properly</summary>
        VER_UE4_CREATEEXPORTS_CLASS_LINKING_FOR_BLUEPRINTS,
        /// <summary>Remove native component nodes from the blueprint SimpleConstructionScript</summary>
        VER_UE4_REMOVE_NATIVE_COMPONENTS_FROM_BLUEPRINT_SCS,
        /// <summary>Removal of Single Node Instance</summary>
        VER_UE4_REMOVE_SINGLENODEINSTANCE,
        /// <summary>Character movement braking changes</summary>
        VER_UE4_CHARACTER_BRAKING_REFACTOR,
        /// <summary>Supported low quality lightmaps in volume samples</summary>
        VER_UE4_VOLUME_SAMPLE_LOW_QUALITY_SUPPORT,
        /// <summary>Split bEnableTouchEvents out from bEnableClickEvents</summary>
        VER_UE4_SPLIT_TOUCH_AND_CLICK_ENABLES,
        /// <summary>Health/Death refactor</summary>
        VER_UE4_HEALTH_DEATH_REFACTOR,
        /// <summary>Moving USoundNodeEnveloper from UDistributionFloatConstantCurve to FRichCurve</summary>
        VER_UE4_SOUND_NODE_ENVELOPER_CURVE_CHANGE,
        /// <summary>Moved SourceRadius to UPointLightComponent</summary>
        VER_UE4_POINT_LIGHT_SOURCE_RADIUS,
        /// <summary>Scene capture actors based on camera actors.</summary>
        VER_UE4_SCENE_CAPTURE_CAMERA_CHANGE,
        /// <summary>Moving SkeletalMesh shadow casting flag from LoD details to material</summary>
        VER_UE4_MOVE_SKELETALMESH_SHADOWCASTING,
        /// <summary>Changing bytecode operators for creating arrays</summary>
        VER_UE4_CHANGE_SETARRAY_BYTECODE,
        /// <summary>Material Instances overriding base material properties.</summary>
        VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES,
        /// <summary>Combined top/bottom lightmap textures</summary>
        VER_UE4_COMBINED_LIGHTMAP_TEXTURES,
        /// <summary>Forced material lightmass guids to be regenerated</summary>
        VER_UE4_BUMPED_MATERIAL_EXPORT_GUIDS,
        /// <summary>Allow overriding of parent class input bindings</summary>
        VER_UE4_BLUEPRINT_INPUT_BINDING_OVERRIDES,
        /// <summary>Fix up convex invalid transform</summary>
        VER_UE4_FIXUP_BODYSETUP_INVALID_CONVEX_TRANSFORM,
        /// <summary>Fix up scale of physics stiffness and damping value</summary>
        VER_UE4_FIXUP_STIFFNESS_AND_DAMPING_SCALE,
        /// <summary>Convert USkeleton and FBoneContrainer to using FReferenceSkeleton.</summary>
        VER_UE4_REFERENCE_SKELETON_REFACTOR,
        /// <summary>Adding references to variable, function, and macro nodes to be able to update to renamed values</summary>
        VER_UE4_K2NODE_REFERENCEGUIDS,
        /// <summary>Fix up the 0th bone's parent bone index.</summary>
        VER_UE4_FIXUP_ROOTBONE_PARENT,
        //Allow setting of TextRenderComponents size in world space.
        VER_UE4_TEXT_RENDER_COMPONENTS_WORLD_SPACE_SIZING,
        /// <summary>Material Instances overriding base material properties #2.</summary>
        VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES_PHASE_2,
        /// <summary>CLASS_Placeable becomes CLASS_NotPlaceable</summary>
        VER_UE4_CLASS_NOTPLACEABLE_ADDED,
        /// <summary>Added LOD info list to a world tile description</summary>
        VER_UE4_WORLD_LEVEL_INFO_LOD_LIST,
        /// <summary>CharacterMovement variable naming refactor</summary>
        VER_UE4_CHARACTER_MOVEMENT_VARIABLE_RENAMING_1,
        /// <summary>FName properties containing sound names converted to FSlateSound properties</summary>
        VER_UE4_FSLATESOUND_CONVERSION,
        /// <summary>Added ZOrder to a world tile description</summary>
        VER_UE4_WORLD_LEVEL_INFO_ZORDER,
        /// <summary>Added flagging of localization gather requirement to packages</summary>
        VER_UE4_PACKAGE_REQUIRES_LOCALIZATION_GATHER_FLAGGING,
        /// <summary>Preventing Blueprint Actor variables from having default values</summary>
        VER_UE4_BP_ACTOR_VARIABLE_DEFAULT_PREVENTING,
        /// <summary>Preventing Blueprint Actor variables from having default values</summary>
        VER_UE4_TEST_ANIMCOMP_CHANGE,
        /// <summary>Class as primary asset, name convention changed</summary>
        VER_UE4_EDITORONLY_BLUEPRINTS,
        /// <summary>Custom serialization for FEdGraphPinType</summary>
        VER_UE4_EDGRAPHPINTYPE_SERIALIZATION,
        /// <summary>Stop generating 'mirrored' cooked mesh for Brush and Model components</summary>
        VER_UE4_NO_MIRROR_BRUSH_MODEL_COLLISION,
        /// <summary>Changed ChunkID to be an array of IDs.</summary>
        VER_UE4_CHANGED_CHUNKID_TO_BE_AN_ARRAY_OF_CHUNKIDS,
        /// <summary>Worlds have been renamed from "TheWorld" to be named after the package containing them</summary>
        VER_UE4_WORLD_NAMED_AFTER_PACKAGE,
        /// <summary>Added sky light component</summary>
        VER_UE4_SKY_LIGHT_COMPONENT,
        /// <summary>Added Enable distance streaming flag to FWorldTileLayer</summary>
        VER_UE4_WORLD_LAYER_ENABLE_DISTANCE_STREAMING,
        /// <summary>Remove visibility/zone information from UModel</summary>
        VER_UE4_REMOVE_ZONES_FROM_MODEL,
        /// <summary>Fix base pose serialization </summary>
        VER_UE4_FIX_ANIMATIONBASEPOSE_SERIALIZATION,
        /// <summary>Support for up to 8 skinning influences per vertex on skeletal meshes (on non-gpu vertices)</summary>
        VER_UE4_SUPPORT_8_BONE_INFLUENCES_SKELETAL_MESHES,
        /// <summary>Add explicit bOverrideGravity to world settings</summary>
        VER_UE4_ADD_OVERRIDE_GRAVITY_FLAG,
        /// <summary>Support for up to 8 skinning influences per vertex on skeletal meshes (on gpu vertices)</summary>
        VER_UE4_SUPPORT_GPUSKINNING_8_BONE_INFLUENCES,
        /// <summary>Supporting nonuniform scale animation</summary>
        VER_UE4_ANIM_SUPPORT_NONUNIFORM_SCALE_ANIMATION,
        /// <summary>Engine version is stored as a FEngineVersion object rather than changelist number</summary>
        VER_UE4_ENGINE_VERSION_OBJECT,
        /// <summary>World assets now have RF_Public</summary>
        VER_UE4_PUBLIC_WORLDS,
        /// <summary>Skeleton Guid</summary>
        VER_UE4_SKELETON_GUID_SERIALIZATION,
        /// <summary>Character movement WalkableFloor refactor</summary>
        VER_UE4_CHARACTER_MOVEMENT_WALKABLE_FLOOR_REFACTOR,
        /// <summary>Lights default to inverse squared</summary>
        VER_UE4_INVERSE_SQUARED_LIGHTS_DEFAULT,
        /// <summary>Disabled SCRIPT_LIMIT_BYTECODE_TO_64KB</summary>
        VER_UE4_DISABLED_SCRIPT_LIMIT_BYTECODE,
        /// <summary>Made remote role private, exposed bReplicates</summary>
        VER_UE4_PRIVATE_REMOTE_ROLE,
        /// <summary>Fix up old foliage components to have static mobility (superseded by VER_UE4_FOLIAGE_MOVABLE_MOBILITY)</summary>
        VER_UE4_FOLIAGE_STATIC_MOBILITY,
        /// <summary>Change BuildScale from a float to a vector</summary>
        VER_UE4_BUILD_SCALE_VECTOR,
        /// <summary>After implementing foliage collision, need to disable collision on old foliage instances</summary>
        VER_UE4_FOLIAGE_COLLISION,
        /// <summary>Added sky bent normal to indirect lighting cache</summary>
        VER_UE4_SKY_BENT_NORMAL,
        /// <summary>Added cooking for landscape collision data</summary>
        VER_UE4_LANDSCAPE_COLLISION_DATA_COOKING,
        /// <summary>
        /// Convert CPU tangent Z delta to vector from PackedNormal since we don't get any benefit other than memory
        /// we still convert all to FVector in CPU time whenever any calculation
        /// </summary>
        VER_UE4_MORPHTARGET_CPU_TANGENTZDELTA_FORMATCHANGE,
        /// <summary>Soft constraint limits will implicitly use the mass of the bodies</summary>
        VER_UE4_SOFT_CONSTRAINTS_USE_MASS,
        /// <summary>Reflection capture data saved in packages</summary>
        VER_UE4_REFLECTION_DATA_IN_PACKAGES,
        /// <summary>Fix up old foliage components to have movable mobility (superseded by VER_UE4_FOLIAGE_STATIC_LIGHTING_SUPPORT)</summary>
        VER_UE4_FOLIAGE_MOVABLE_MOBILITY,
        /// <summary>Undo BreakMaterialAttributes changes as it broke old content</summary>
        VER_UE4_UNDO_BREAK_MATERIALATTRIBUTES_CHANGE,
        /// <summary>Now Default custom profile name isn't NONE anymore due to copy/paste not working properly with it</summary>
        VER_UE4_ADD_CUSTOMPROFILENAME_CHANGE,
        /// <summary>Permanently flip and scale material expression coordinates</summary>
        VER_UE4_FLIP_MATERIAL_COORDS,
        /// <summary>PinSubCategoryMemberReference added to FEdGraphPinType</summary>
        VER_UE4_MEMBERREFERENCE_IN_PINTYPE,
        /// <summary>Vehicles use Nm for Torque instead of cm and RPM instead of rad/s</summary>
        VER_UE4_VEHICLES_UNIT_CHANGE,
        /// <summary>
        /// removes NANs from all animations when loaded
        /// now importing should detect NaNs, so we should not have NaNs in source data
        /// </summary>
        VER_UE4_ANIMATION_REMOVE_NANS,
        /// <summary>Change skeleton preview attached assets property type</summary>
        VER_UE4_SKELETON_ASSET_PROPERTY_TYPE_CHANGE,
        /// <summary>
        /// Fix some blueprint variables that have the CPF_DisableEditOnTemplate flag set
        /// when they shouldn't
        /// </summary>
        VER_UE4_FIX_BLUEPRINT_VARIABLE_FLAGS,
        /// <summary>Vehicles use Nm for Torque instead of cm and RPM instead of rad/s part two (missed conversion for some variables</summary>
        VER_UE4_VEHICLES_UNIT_CHANGE2,
        /// <summary>Changed order of interface class serialization</summary>
        VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING,
        /// <summary>Change from LOD distances to display factors</summary>
        VER_UE4_STATIC_MESH_SCREEN_SIZE_LODS,
        /// <summary>Requires test of material coords to ensure they're saved correctly</summary>
        VER_UE4_FIX_MATERIAL_COORDS,
        /// <summary>Changed SpeedTree wind presets to v7</summary>
        VER_UE4_SPEEDTREE_WIND_V7,
        /// <summary>NeedsLoadForEditorGame added</summary>
        VER_UE4_LOAD_FOR_EDITOR_GAME,
        /// <summary>Manual serialization of FRichCurveKey to save space</summary>
        VER_UE4_SERIALIZE_RICH_CURVE_KEY,
        /// <summary>Change the outer of ULandscapeMaterialInstanceConstants and Landscape-related textures to the level in which they reside</summary>
        VER_UE4_MOVE_LANDSCAPE_MICS_AND_TEXTURES_WITHIN_LEVEL,
        /// <summary>FTexts have creation history data, removed Key, Namespaces, and SourceString</summary>
        VER_UE4_FTEXT_HISTORY,
        /// <summary>Shift comments to the left to contain expressions properly</summary>
        VER_UE4_FIX_MATERIAL_COMMENTS,
        /// <summary>Bone names stored as FName means that we can't guarantee the correct case on export, now we store a separate string for export purposes only</summary>
        VER_UE4_STORE_BONE_EXPORT_NAMES,
        /// <summary>changed mesh emitter initial orientation to distribution</summary>
        VER_UE4_MESH_EMITTER_INITIAL_ORIENTATION_DISTRIBUTION,
        /// <summary>Foliage on blueprints causes crashes</summary>
        VER_UE4_DISALLOW_FOLIAGE_ON_BLUEPRINTS,
        /// <summary>change motors to use revolutions per second instead of rads/second</summary>
        VER_UE4_FIXUP_MOTOR_UNITS,
        /// <summary>deprecated MovementComponent functions including "ModifiedMaxSpeed" et al</summary>
        VER_UE4_DEPRECATED_MOVEMENTCOMPONENT_MODIFIED_SPEEDS,
        /// <summary>rename CanBeCharacterBase</summary>
        VER_UE4_RENAME_CANBECHARACTERBASE,
        /// <summary>Change GameplayTagContainers to have FGameplayTags instead of FNames; Required to fix-up native serialization</summary>
        VER_UE4_GAMEPLAY_TAG_CONTAINER_TAG_TYPE_CHANGE,
        /// <summary>Change from UInstancedFoliageSettings to UFoliageType, and change the api from being keyed on UStaticMesh* to UFoliageType*</summary>
        VER_UE4_FOLIAGE_SETTINGS_TYPE,
        /// <summary>Lights serialize static shadow depth maps</summary>
        VER_UE4_STATIC_SHADOW_DEPTH_MAPS,
        /// <summary>Add RF_Transactional to data assets, fixing undo problems when editing them</summary>
        VER_UE4_ADD_TRANSACTIONAL_TO_DATA_ASSETS,
        /// <summary>Change LB_AlphaBlend to LB_WeightBlend in ELandscapeLayerBlendType</summary>
        VER_UE4_ADD_LB_WEIGHTBLEND,
        /// <summary>Add root component to an foliage actor, all foliage cluster components will be attached to a root</summary>
        VER_UE4_ADD_ROOTCOMPONENT_TO_FOLIAGEACTOR,
        /// <summary>FMaterialInstanceBasePropertyOverrides didn't use proper UObject serialize</summary>
        VER_UE4_FIX_MATERIAL_PROPERTY_OVERRIDE_SERIALIZE,
        /// <summary>Addition of linear color sampler. color sample type is changed to linear sampler if source texture !sRGB</summary>
        VER_UE4_ADD_LINEAR_COLOR_SAMPLER,
        /// <summary>Added StringAssetReferencesMap to support renames of FStringAssetReference properties.</summary>
        VER_UE4_ADD_STRING_ASSET_REFERENCES_MAP,
        /// <summary>Apply scale from SCS RootComponent details in the Blueprint Editor to new actor instances at construction time</summary>
        VER_UE4_BLUEPRINT_USE_SCS_ROOTCOMPONENT_SCALE,
        /// <summary>Changed level streaming to have a linear color since the visualization doesn't gamma correct.</summary>
        VER_UE4_LEVEL_STREAMING_DRAW_COLOR_TYPE_CHANGE,
        /// <summary>Cleared end triggers from non-state anim notifies</summary>
        VER_UE4_CLEAR_NOTIFY_TRIGGERS,
        /// <summary>Convert old curve names stored in anim assets into skeleton smartnames</summary>
        VER_UE4_SKELETON_ADD_SMARTNAMES,
        /// <summary>Added the currency code field to FTextHistory_AsCurrency</summary>
        VER_UE4_ADDED_CURRENCY_CODE_TO_FTEXT,
        /// <summary>Added support for C++11 enum classes</summary>
        VER_UE4_ENUM_CLASS_SUPPORT,
        /// <summary>Fixup widget animation class</summary>
        VER_UE4_FIXUP_WIDGET_ANIMATION_CLASS,
        /// <summary>USoundWave objects now contain details about compression scheme used.</summary>
        VER_UE4_SOUND_COMPRESSION_TYPE_ADDED,
        /// <summary>Bodies will automatically weld when attached</summary>
        VER_UE4_AUTO_WELDING,
        /// <summary>Rename UCharacterMovementComponent::bCrouchMovesCharacterDown</summary>
        VER_UE4_RENAME_CROUCHMOVESCHARACTERDOWN,
        /// <summary>Lightmap parameters in FMeshBuildSettings</summary>
        VER_UE4_LIGHTMAP_MESH_BUILD_SETTINGS,
        /// <summary>Rename SM3 to ES3_1 and updates featurelevel material node selector</summary>
        VER_UE4_RENAME_SM3_TO_ES3_1,
        /// <summary>Deprecated separate style assets for use in UMG</summary>
        VER_UE4_DEPRECATE_UMG_STYLE_ASSETS,
        /// <summary>Duplicating Blueprints will regenerate NodeGuids after this version</summary>
        VER_UE4_POST_DUPLICATE_NODE_GUID,
        /// <summary>
        /// Rename USpringArmComponent::bUseControllerViewRotation to bUsePawnViewRotation,
        /// Rename UCameraComponent::bUseControllerViewRotation to bUsePawnViewRotation (and change the default value)
        /// </summary>
        VER_UE4_RENAME_CAMERA_COMPONENT_VIEW_ROTATION,
        /// <summary>Changed FName to be case preserving</summary>
        VER_UE4_CASE_PRESERVING_FNAME,
        /// <summary>
        /// Rename USpringArmComponent::bUsePawnViewRotation to bUsePawnControlRotation,
        /// Rename UCameraComponent::bUsePawnViewRotation to bUsePawnControlRotation
        /// </summary>
        VER_UE4_RENAME_CAMERA_COMPONENT_CONTROL_ROTATION,
        /// <summary>Fix bad refraction material attribute masks</summary>
        VER_UE4_FIX_REFRACTION_INPUT_MASKING,
        /// <summary>A global spawn rate for emitters.</summary>
        VER_UE4_GLOBAL_EMITTER_SPAWN_RATE_SCALE,
        /// <summary>Cleanup destructible mesh settings</summary>
        VER_UE4_CLEAN_DESTRUCTIBLE_SETTINGS,
        /// <summary>CharacterMovementComponent refactor of AdjustUpperHemisphereImpact and deprecation of some associated vars.</summary>
        VER_UE4_CHARACTER_MOVEMENT_UPPER_IMPACT_BEHAVIOR,
        /// <summary>Changed Blueprint math equality functions for vectors and rotators to operate as a "nearly" equals rather than "exact"</summary>
        VER_UE4_BP_MATH_VECTOR_EQUALITY_USES_EPSILON,
        /// <summary>Static lighting support was re-added to foliage, and mobility was returned to static</summary>
        VER_UE4_FOLIAGE_STATIC_LIGHTING_SUPPORT,
        /// <summary>Added composite fonts to Slate font info</summary>
        VER_UE4_SLATE_COMPOSITE_FONTS,
        /// <summary>Remove UDEPRECATED_SaveGameSummary, required for UWorld::Serialize</summary>
        VER_UE4_REMOVE_SAVEGAMESUMMARY,

        /// <summary>Remove bodyseutp serialization from skeletal mesh component</summary>
        VER_UE4_REMOVE_SKELETALMESH_COMPONENT_BODYSETUP_SERIALIZATION,
        /// <summary>Made Slate font data use bulk data to store the embedded font data</summary>
        VER_UE4_SLATE_BULK_FONT_DATA,
        /// <summary>Add new friction behavior in ProjectileMovementComponent.</summary>
        VER_UE4_ADD_PROJECTILE_FRICTION_BEHAVIOR,
        /// <summary>Add axis settings enum to MovementComponent.</summary>
        VER_UE4_MOVEMENTCOMPONENT_AXIS_SETTINGS,
        /// <summary>Switch to new interactive comments, requires boundry conversion to preserve previous states</summary>
        VER_UE4_GRAPH_INTERACTIVE_COMMENTBUBBLES,
        /// <summary>Landscape serializes physical materials for collision objects </summary>
        VER_UE4_LANDSCAPE_SERIALIZE_PHYSICS_MATERIALS,
        /// <summary>Rename Visiblity on widgets to Visibility</summary>
        VER_UE4_RENAME_WIDGET_VISIBILITY,
        /// <summary>add track curves for animation</summary>
        VER_UE4_ANIMATION_ADD_TRACKCURVES,
        /// <summary>Removed BranchingPoints from AnimMontages and converted them to regular AnimNotifies.</summary>
        VER_UE4_MONTAGE_BRANCHING_POINT_REMOVAL,
        /// <summary>Enforce const-correctness in Blueprint implementations of native C++ const class methods</summary>
        VER_UE4_BLUEPRINT_ENFORCE_CONST_IN_FUNCTION_OVERRIDES,
        /// <summary>Added pivot to widget components, need to load old versions as a 0,0 pivot, new default is 0.5,0.5</summary>
        VER_UE4_ADD_PIVOT_TO_WIDGET_COMPONENT,
        /// <summary>Added finer control over when AI Pawns are automatically possessed. Also renamed Pawn.AutoPossess to Pawn.AutoPossessPlayer indicate this was a setting for players and not AI.</summary>
        VER_UE4_PAWN_AUTO_POSSESS_AI,
        /// <summary>Added serialization of timezone to FTextHistory for AsDate operations.</summary>
        VER_UE4_FTEXT_HISTORY_DATE_TIMEZONE,
        /// <summary>Sort ActiveBoneIndices on lods so that we can avoid doing it at run time</summary>
        VER_UE4_SORT_ACTIVE_BONE_INDICES,
        /// <summary>Added per-frame material uniform expressions</summary>
        VER_UE4_PERFRAME_MATERIAL_UNIFORM_EXPRESSIONS,
        /// <summary>Make MikkTSpace the default tangent space calculation method for static meshes.</summary>
        VER_UE4_MIKKTSPACE_IS_DEFAULT,
        /// <summary>Only applies to cooked files, grass cooking support.</summary>
        VER_UE4_LANDSCAPE_GRASS_COOKING,
        /// <summary>Fixed code for using the bOrientMeshEmitters property.</summary>
        VER_UE4_FIX_SKEL_VERT_ORIENT_MESH_PARTICLES,
        /// <summary>Do not change landscape section offset on load under world composition</summary>
        VER_UE4_LANDSCAPE_STATIC_SECTION_OFFSET,
        /// <summary>New options for navigation data runtime generation (static, modifiers only, dynamic)</summary>
        VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION,
        /// <summary>Tidied up material's handling of masked blend mode.</summary>
        VER_UE4_MATERIAL_MASKED_BLENDMODE_TIDY,
        /// <summary>Original version of VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7; renumbered to prevent blocking promotion in main.</summary>
        VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7_DEPRECATED,
        /// <summary>Original version of VER_UE4_AFTER_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7; renumbered to prevent blocking promotion in main.</summary>
        VER_UE4_AFTER_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7_DEPRECATED,
        /// <summary>After merging VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION into 4.7 branch</summary>
        VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7,
        /// <summary>After merging VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION into 4.7 branch</summary>
        VER_UE4_AFTER_MERGING_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7,
        /// <summary>Landscape grass weightmap data is now generated in the editor and serialized.</summary>
        VER_UE4_SERIALIZE_LANDSCAPE_GRASS_DATA,
        /// <summary>New property to optionally prevent gpu emitters clearing existing particles on Init().</summary>
        VER_UE4_OPTIONALLY_CLEAR_GPU_EMITTERS_ON_INIT,
        /// <summary>Also store the Material guid with the landscape grass data</summary>
        VER_UE4_SERIALIZE_LANDSCAPE_GRASS_DATA_MATERIAL_GUID,
        /// <summary>Make sure that all template components from blueprint generated classes are flagged as public</summary>
        VER_UE4_BLUEPRINT_GENERATED_CLASS_COMPONENT_TEMPLATES_PUBLIC,
        /// <summary>Split out creation method on ActorComponents to distinguish between native, instance, and simple or user construction script</summary>
        VER_UE4_ACTOR_COMPONENT_CREATION_METHOD,
        /// <summary>K2Node_Event now uses FMemberReference for handling references</summary>
        VER_UE4_K2NODE_EVENT_MEMBER_REFERENCE,
        /// <summary>FPropertyTag stores GUID of struct</summary>
        VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG,
        /// <summary>Remove unused UPolys from UModel cooked content</summary>
        VER_UE4_REMOVE_UNUSED_UPOLYS_FROM_UMODEL,
        /// <summary>This doesn't do anything except trigger a rebuild on HISMC cluster trees, in this case to get a good "occlusion query" level</summary>
        VER_UE4_REBUILD_HIERARCHICAL_INSTANCE_TREES,
        /// <summary>Package summary includes an CompatibleWithEngineVersion field, separately to the version it's saved with</summary>
        VER_UE4_PACKAGE_SUMMARY_HAS_COMPATIBLE_ENGINE_VERSION,
        /// <summary>Track UCS modified properties on Actor Components</summary>
        VER_UE4_TRACK_UCS_MODIFIED_PROPERTIES,
        /// <summary>Allowed landscape spline meshes to be stored into landscape streaming levels rather than the spline's level</summary>
        VER_UE4_LANDSCAPE_SPLINE_CROSS_LEVEL_MESHES,
        /// <summary>Deprecate the variables used for sizing in the designer on UUserWidget</summary>
        VER_UE4_DEPRECATE_USER_WIDGET_DESIGN_SIZE,
        /// <summary>Make the editor views array dynamically sized</summary>
        VER_UE4_ADD_EDITOR_VIEWS,
        /// <summary>Updated foliage to work with either FoliageType assets or blueprint classes</summary>
        VER_UE4_FOLIAGE_WITH_ASSET_OR_CLASS,
        /// <summary>Allows PhysicsSerializer to serialize shapes and actors for faster load times</summary>
        VER_UE4_BODYINSTANCE_BINARY_SERIALIZATION,
        /// <summary>Added fastcall data serialization directly in UFunction</summary>
        VER_UE4_SERIALIZE_BLUEPRINT_EVENTGRAPH_FASTCALLS_IN_UFUNCTION,
        /// <summary>Changes to USplineComponent and FInterpCurve</summary>
        VER_UE4_INTERPCURVE_SUPPORTS_LOOPING,
        /// <summary>Material Instances overriding base material LOD transitions</summary>
        VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES_DITHERED_LOD_TRANSITION,
        /// <summary>Serialize ES2 textures separately rather than overwriting the properties used on other platforms</summary>
        VER_UE4_SERIALIZE_LANDSCAPE_ES2_TEXTURES,
        /// <summary>Constraint motor velocity is broken into per-component</summary>
        VER_UE4_CONSTRAINT_INSTANCE_MOTOR_FLAGS,
        /// <summary>Serialize bIsConst in FEdGraphPinType</summary>
        VER_UE4_SERIALIZE_PINTYPE_CONST,
        /// <summary>Change UMaterialFunction::LibraryCategories to LibraryCategoriesText (old assets were saved before auto-conversion of FArrayProperty was possible)</summary>
        VER_UE4_LIBRARY_CATEGORIES_AS_FTEXT,
        /// <summary>Check for duplicate exports while saving packages.</summary>
        VER_UE4_SKIP_DUPLICATE_EXPORTS_ON_SAVE_PACKAGE,
        /// <summary>Pre-gathering of gatherable, localizable text in packages to optimize text gathering operation times</summary>
        VER_UE4_SERIALIZE_TEXT_IN_PACKAGES,
        /// <summary>Added pivot to widget components, need to load old versions as a 0,0 pivot, new default is 0.5,0.5</summary>
        VER_UE4_ADD_BLEND_MODE_TO_WIDGET_COMPONENT,
        /// <summary>Added lightmass primitive setting</summary>
        VER_UE4_NEW_LIGHTMASS_PRIMITIVE_SETTING,
        /// <summary>Deprecate NoZSpring property on spring nodes to be replaced with TranslateZ property</summary>
        VER_UE4_REPLACE_SPRING_NOZ_PROPERTY,
        /// <summary>Keep enums tight and serialize their values as pairs of FName and value. Don't insert dummy values.</summary>
        VER_UE4_TIGHTLY_PACKED_ENUMS,
        /// <summary>Changed Asset import data to serialize file meta data as JSON</summary>
        VER_UE4_ASSET_IMPORT_DATA_AS_JSON,
        /// <summary>Legacy gamma support for textures.</summary>
        VER_UE4_TEXTURE_LEGACY_GAMMA,
        /// <summary>Added WithSerializer for basic native structures like FVector, FColor etc to improve serialization performance</summary>
        VER_UE4_ADDED_NATIVE_SERIALIZATION_FOR_IMMUTABLE_STRUCTURES,
        /// <summary>Deprecated attributes that override the style on UMG widgets</summary>
        VER_UE4_DEPRECATE_UMG_STYLE_OVERRIDES,
        /// <summary>Shadowmap penumbra size stored</summary>
        VER_UE4_STATIC_SHADOWMAP_PENUMBRA_SIZE,
        /// <summary>Fix BC on Niagara effects from the data object and dev UI changes.</summary>
        VER_UE4_NIAGARA_DATA_OBJECT_DEV_UI_FIX,
        /// <summary>Fixed the default orientation of widget component so it faces down +x</summary>
        VER_UE4_FIXED_DEFAULT_ORIENTATION_OF_WIDGET_COMPONENT,
        /// <summary>Removed bUsedWithUI flag from UMaterial and replaced it with a new material domain for UI</summary>
        VER_UE4_REMOVED_MATERIAL_USED_WITH_UI_FLAG,
        /// <summary>Added braking friction separate from turning friction.</summary>
        VER_UE4_CHARACTER_MOVEMENT_ADD_BRAKING_FRICTION,
        /// <summary>Removed TTransArrays from UModel</summary>
        VER_UE4_BSP_UNDO_FIX,
        /// <summary>Added default value to dynamic parameter.</summary>
        VER_UE4_DYNAMIC_PARAMETER_DEFAULT_VALUE,
        /// <summary>Added ExtendedBounds to StaticMesh</summary>
        VER_UE4_STATIC_MESH_EXTENDED_BOUNDS,
        /// <summary>Added non-linear blending to anim transitions, deprecating old types</summary>
        VER_UE4_ADDED_NON_LINEAR_TRANSITION_BLENDS,
        /// <summary>AO Material Mask texture</summary>
        VER_UE4_AO_MATERIAL_MASK,
        /// <summary>Replaced navigation agents selection with single structure</summary>
        VER_UE4_NAVIGATION_AGENT_SELECTOR,
        /// <summary>Mesh particle collisions consider particle size.</summary>
        VER_UE4_MESH_PARTICLE_COLLISIONS_CONSIDER_PARTICLE_SIZE,
        /// <summary>Adjacency buffer building no longer automatically handled based on triangle count, user-controlled</summary>
        VER_UE4_BUILD_MESH_ADJ_BUFFER_FLAG_EXPOSED,
        /// <summary>Change the default max angular velocity</summary>
        VER_UE4_MAX_ANGULAR_VELOCITY_DEFAULT,
        /// <summary>Build Adjacency index buffer for clothing tessellation</summary>
        VER_UE4_APEX_CLOTH_TESSELLATION,
        /// <summary>Added DecalSize member, solved backward compatibility</summary>
        VER_UE4_DECAL_SIZE,
        /// <summary>Keep only package names in StringAssetReferencesMap</summary>
        VER_UE4_KEEP_ONLY_PACKAGE_NAMES_IN_STRING_ASSET_REFERENCES_MAP,
        /// <summary>Support sound cue not saving out editor only data</summary>
        VER_UE4_COOKED_ASSETS_IN_EDITOR_SUPPORT,
        /// <summary>Updated dialogue wave localization gathering logic.</summary>
        VER_UE4_DIALOGUE_WAVE_NAMESPACE_AND_CONTEXT_CHANGES,
        /// <summary>Renamed MakeRot MakeRotator and rearranged parameters.</summary>
        VER_UE4_MAKE_ROT_RENAME_AND_REORDER,
        /// <summary>K2Node_Variable will properly have the VariableReference Guid set if available</summary>
        VER_UE4_K2NODE_VAR_REFERENCEGUIDS,
        /// <summary>Added support for sound concurrency settings structure and overrides</summary>
        VER_UE4_SOUND_CONCURRENCY_PACKAGE,
        /// <summary>Changing the default value for focusable user widgets to false</summary>
        VER_UE4_USERWIDGET_DEFAULT_FOCUSABLE_FALSE,
        /// <summary>Custom event nodes implicitly set 'const' on array and non-array pass-by-reference input params</summary>
        VER_UE4_BLUEPRINT_CUSTOM_EVENT_CONST_INPUT,
        /// <summary>Renamed HighFrequencyGain to LowPassFilterFrequency</summary>
        VER_UE4_USE_LOW_PASS_FILTER_FREQ,
        /// <summary>UAnimBlueprintGeneratedClass can be replaced by a dynamic class. Use TSubclassOf UAnimInstance instead.</summary>
        VER_UE4_NO_ANIM_BP_CLASS_IN_GAMEPLAY_CODE,
        /// <summary>The SCS keeps a list of all nodes in its hierarchy rather than recursively building it each time it is requested</summary>
        VER_UE4_SCS_STORES_ALLNODES_ARRAY,
        /// <summary>Moved StartRange and EndRange in UFbxAnimSequenceImportData to use FInt32Interval</summary>
        VER_UE4_FBX_IMPORT_DATA_RANGE_ENCAPSULATION,
        /// <summary>Adding a new root scene component to camera component</summary>
        VER_UE4_CAMERA_COMPONENT_ATTACH_TO_ROOT,
        /// <summary>Updating custom material expression nodes for instanced stereo implementation</summary>
        VER_UE4_INSTANCED_STEREO_UNIFORM_UPDATE,
        /// <summary>Texture streaming min and max distance to handle HLOD</summary>
        VER_UE4_STREAMABLE_TEXTURE_MIN_MAX_DISTANCE,
        /// <summary>Fixing up invalid struct-to-struct pin connections by injecting available conversion nodes</summary>
        VER_UE4_INJECT_BLUEPRINT_STRUCT_PIN_CONVERSION_NODES,
        /// <summary>Saving tag data for Array Property's inner property</summary>
        VER_UE4_INNER_ARRAY_TAG_INFO,
        /// <summary>Fixed duplicating slot node names in skeleton due to skeleton preload on compile</summary>
        VER_UE4_FIX_SLOT_NAME_DUPLICATION,
        /// <summary>Texture streaming using AABBs instead of Spheres</summary>
        VER_UE4_STREAMABLE_TEXTURE_AABB,
        /// <summary>FPropertyTag stores GUID of property</summary>
        VER_UE4_PROPERTY_GUID_IN_PROPERTY_TAG,
        /// <summary>Name table hashes are calculated and saved out rather than at load time</summary>
        VER_UE4_NAME_HASHES_SERIALIZED,
        /// <summary>Updating custom material expression nodes for instanced stereo implementation refactor</summary>
        VER_UE4_INSTANCED_STEREO_UNIFORM_REFACTOR,
        /// <summary>Added compression to the shader resource for memory savings</summary>
        VER_UE4_COMPRESSED_SHADER_RESOURCES,
        /// <summary>Cooked files contain the dependency graph for the event driven loader (the serialization is largely independent of the use of the new loader)</summary>
        VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS,
        /// <summary>Cooked files contain the TemplateIndex used by the event driven loader (the serialization is largely independent of the use of the new loader, i.e. this will be null if cooking for the old loader)</summary>
        VER_UE4_TemplateIndex_IN_COOKED_EXPORTS,
        /// <summary>FPropertyTag includes contained type(s) for Set and Map properties</summary>
        VER_UE4_PROPERTY_TAG_SET_MAP_SUPPORT,
        /// <summary>Added SearchableNames to the package summary and asset registry</summary>
        VER_UE4_ADDED_SEARCHABLE_NAMES,
        /// <summary>Increased size of SerialSize and SerialOffset in export map entries to 64 bit, allow support for bigger files</summary>
        VER_UE4_64BIT_EXPORTMAP_SERIALSIZES,
        /// <summary>Sky light stores IrradianceMap for mobile renderer.</summary>
        VER_UE4_SKYLIGHT_MOBILE_IRRADIANCE_MAP,
        /// <summary>Added flag to control sweep behavior while walking in UCharacterMovementComponent.</summary>
        VER_UE4_ADDED_SWEEP_WHILE_WALKING_FLAG,
        /// <summary>StringAssetReference changed to SoftObjectPath and swapped to serialize as a name+string instead of a string</summary>
        VER_UE4_ADDED_SOFT_OBJECT_PATH,
        /// <summary>Changed the source orientation of point lights to match spot lights (z axis)</summary>
        VER_UE4_POINTLIGHT_SOURCE_ORIENTATION,
        /// <summary>LocalizationId has been added to the package summary (editor-only)</summary>
        VER_UE4_ADDED_PACKAGE_SUMMARY_LOCALIZATION_ID,
        /// <summary>Fixed case insensitive hashes of wide strings containing character values from 128-255</summary>
        VER_UE4_FIX_WIDE_STRING_CRC,
        /// <summary>Added package owner to allow private references</summary>
        VER_UE4_ADDED_PACKAGE_OWNER,
        /// <summary>Changed the data layout for skin weight profile data</summary>
        VER_UE4_SKINWEIGHT_PROFILE_DATA_LAYOUT_CHANGES,
        /// <summary>Added import that can have package different than their outer</summary>
        VER_UE4_NON_OUTER_PACKAGE_IMPORT,
        /// <summary>Added DependencyFlags to AssetRegistry</summary>
        VER_UE4_ASSETREGISTRY_DEPENDENCYFLAGS,
        /// <summary>Fixed corrupt licensee flag in 4.26 assets</summary>
        VER_UE4_CORRECT_LICENSEE_FLAG,

        VER_UE4_AUTOMATIC_VERSION_PLUS_ONE,
        /// <summary>The newest specified version of the Unreal Engine.</summary>
        VER_UE4_AUTOMATIC_VERSION = VER_UE4_AUTOMATIC_VERSION_PLUS_ONE - 1,
    };

    /// <summary>
    /// An enum used to represent the global object version of UE5.
    /// </summary>
    public enum ObjectVersionUE5
    {
        UNKNOWN = 0,

        // The original UE5 version, at the time this was added the UE4 version was 522, so UE5 will start from 1000 to show a clear difference
        INITIAL_VERSION = 1000,

        // Support stripping names that are not referenced from export data
        NAMES_REFERENCED_FROM_EXPORT_DATA,

        // Added a payload table of contents to the package summary 
        PAYLOAD_TOC,

        // Added data to identify references from and to optional package
        OPTIONAL_RESOURCES,

        // Large world coordinates converts a number of core types to double components by default.
        LARGE_WORLD_COORDINATES,

        // Remove package GUID from FObjectExport
        REMOVE_OBJECT_EXPORT_PACKAGE_GUID,

        // Add IsInherited to the FObjectExport entry
        TRACK_OBJECT_EXPORT_IS_INHERITED,

        // Replace FName asset path in FSoftObjectPath with (package name, asset name) pair FTopLevelAssetPath
        FSOFTOBJECTPATH_REMOVE_ASSET_PATH_FNAMES,

        // Add a soft object path list to the package summary for fast remap
        ADD_SOFTOBJECTPATH_LIST,

        // Added bulk/data resource table
        DATA_RESOURCES,

        // Added script property serialization offset to export table entries for saved, versioned packages
        SCRIPT_SERIALIZATION_OFFSET,

        // Adding property tag extension,
        // Support for overridable serialization on UObject,
        // Support for overridable logic in containers
        PROPERTY_TAG_EXTENSION_AND_OVERRIDABLE_SERIALIZATION,

        // Added property tag complete type name and serialization type
        PROPERTY_TAG_COMPLETE_TYPE_NAME,

        // Changed UE::AssetRegistry::WritePackageData to include PackageBuildDependencies
        ASSETREGISTRY_PACKAGEBUILDDEPENDENCIES,
        
        // Added meta data serialization offset to for saved, versioned packages
        METADATA_SERIALIZATION_OFFSET,

        // Added VCells to the object graph
        VERSE_CELLS,

        // Changed PackageFileSummary to write FIoHash PackageSavedHash instead of FGuid Guid
        PACKAGE_SAVED_HASH,

        // OS shadow serialization of subobjects
        OS_SUB_OBJECT_SHADOW_SERIALIZATION,

        // -----<new versions can be added before this line>-------------------------------------------------
        // - this needs to be the last line (see note below)
        AUTOMATIC_VERSION_PLUS_ONE,
        AUTOMATIC_VERSION = AUTOMATIC_VERSION_PLUS_ONE - 1
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FIntVector.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Structure for integer vectors in 3-d space.
/// </summary>
public struct FIntVector : ICloneable, IStruct<FIntVector>
{
    public int X;
    public int Y;
    public int Z;

    public FIntVector(int x, int y, int z)
    {
        X = x;
        Y = y;
        Z = z;
    }

    public FIntVector(AssetBinaryReader reader)
    {
        X = reader.ReadInt32();
        Y = reader.ReadInt32();
        Z = reader.ReadInt32();
    }

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(X);
        writer.Write(Y);
        writer.Write(Z);
        return sizeof(int) * 3;
    }

    public static FIntVector Read(AssetBinaryReader reader) => new FIntVector(reader);

    public object Clone() => new FIntVector(X, Y, Z);

    public static FIntVector FromString(string[] d, UAsset asset)
    {
        int.TryParse(d[0], out int X);
        int.TryParse(d[1], out int Y);
        int.TryParse(d[2], out int Z);
        return new FIntVector(X, Y, Z);
    }

    public override string ToString() => "(" + X + ", " + Y + ", " + Z + ")";
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FIntVector2.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Structure for integer vectors in 2-d space.
/// </summary>
public struct FIntVector2 : ICloneable, IStruct<FIntVector2>
{
    public int X;
    public int Y;

    public FIntVector2(int x, int y)
    {
        X = x;
        Y = y;
    }

    public FIntVector2(AssetBinaryReader reader)
    {
        X = reader.ReadInt32();
        Y = reader.ReadInt32();
    }

    public static FIntVector2 Read(AssetBinaryReader reader) => new FIntVector2(reader);

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(X);
        writer.Write(Y);
        return sizeof(int) * 2;
    }

    public object Clone() => new FIntVector2(X, Y);

    public override string ToString() => "(" + X + ", " + Y + ")";

    public static FIntVector2 FromString(string[] d, UAsset asset)
    {
        int.TryParse(d[0], out int X);
        int.TryParse(d[1], out int Y);
        return new FIntVector2(X, Y);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FLinearColor.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Drawing;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

public static class LinearHelpers
{
    public static Color Convert(FLinearColor color)
    {
        float FloatR = UAPUtils.Clamp(color.R, 0.0f, 1.0f);
        float FloatG = UAPUtils.Clamp(color.G, 0.0f, 1.0f);
        float FloatB = UAPUtils.Clamp(color.B, 0.0f, 1.0f);
        float FloatA = UAPUtils.Clamp(color.A, 0.0f, 1.0f);

        FloatR = (float)(FloatR <= 0.0031308f ? FloatR * 12.92f : Math.Pow(FloatR, 1.0f / 2.4f) * 1.055f - 0.055f);
        FloatG = (float)(FloatG <= 0.0031308f ? FloatG * 12.92f : Math.Pow(FloatG, 1.0f / 2.4f) * 1.055f - 0.055f);
        FloatB = (float)(FloatB <= 0.0031308f ? FloatB * 12.92f : Math.Pow(FloatB, 1.0f / 2.4f) * 1.055f - 0.055f);

        return Color.FromArgb((byte)Math.Floor(FloatA * 255.999f), (byte)Math.Floor(FloatR * 255.999f), (byte)Math.Floor(FloatG * 255.999f), (byte)Math.Floor(FloatB * 255.999f));
    }
}

/// <summary>
/// A linear, 32-bit/component floating point RGBA color.
/// </summary>
public struct FLinearColor : ICloneable, IStruct<FLinearColor>
{
    [JsonProperty]
    public float R;
    [JsonProperty]
    public float G;
    [JsonProperty]
    public float B;
    [JsonProperty]
    public float A;

    public FLinearColor(float R, float G, float B, float A)
    {
        this.R = R;
        this.G = G;
        this.B = B;
        this.A = A;
    }

    public object Clone() => new FLinearColor(this.R, this.G, this.B, this.A);

    public FLinearColor(AssetBinaryReader reader)
    {
        R = reader.ReadSingle();
        G = reader.ReadSingle();
        B = reader.ReadSingle();
        A = reader.ReadSingle();
    }

    public static FLinearColor Read(AssetBinaryReader reader) => new FLinearColor(reader);

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(R);
        writer.Write(G);
        writer.Write(B);
        writer.Write(A);
        return sizeof(float) * 4;
    }

    public override string ToString() => "(" + R + ", " + G + ", " + B + ", " + A + ")";

    public static FLinearColor FromString(string[] d, UAsset asset)
    {
        float.TryParse(d[0], out float R);
        float.TryParse(d[1], out float G);
        float.TryParse(d[2], out float B);
        float.TryParse(d[3], out float A);
        return new FLinearColor(R, G, B, A);
    }
}
```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FMatrix.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// 4x4 matrix of floating point values.
/// </summary>
public struct FMatrix : IStruct<FMatrix>
{
    public FPlane XPlane;
    public FPlane YPlane;
    public FPlane ZPlane;
    public FPlane WPlane;

    public FMatrix(FPlane xPlane, FPlane yPlane, FPlane zPlane, FPlane wPlane)
    {
        XPlane = xPlane;
        YPlane = yPlane;
        ZPlane = zPlane;
        WPlane = wPlane;
    }

    public FMatrix(AssetBinaryReader reader)
    {
        XPlane = new FPlane(reader);
        YPlane = new FPlane(reader);
        ZPlane = new FPlane(reader);
        WPlane = new FPlane(reader);
    }

    public static FMatrix Read(AssetBinaryReader reader) => new FMatrix(reader);

    public int Write(AssetBinaryWriter writer)
    {
        var size = XPlane.Write(writer);
        size += YPlane.Write(writer);
        size += ZPlane.Write(writer);
        size += WPlane.Write(writer);
        return size;
    }

    public static FMatrix FromString(string[] d, UAsset asset)
    {
        throw new System.NotImplementedException();
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FPlane.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.JSON;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Structure for three dimensional planes.
/// Stores the coeffecients as Xx+Yy+Zz=W.
/// This is different from many other Plane classes that use Xx+Yy+Zz+W=0.
/// </summary>
[JsonObject(MemberSerialization.OptIn)]
public struct FPlane : IStruct<FPlane>
{
    private float? _x1;
    private double _x2;
    private float? _y1;
    private double _y2;
    private float? _z1;
    private double _z2;
    private float? _w1;
    private double _w2;

    /// <summary>The plane's X-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double X
    {
        get
        {
            return _x1 == null ? _x2 : (double)_x1;
        }
        set
        {
            _x1 = null;
            _x2 = value;
        }
    }

    [JsonIgnore]
    public float XFloat => _x1 == null ? (float)_x2 : (float)_x1;

    /// <summary>The plane's Y-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Y
    {
        get
        {
            return _y1 == null ? _y2 : (double)_y1;
        }
        set
        {
            _y1 = null;
            _y2 = value;
        }
    }

    [JsonIgnore]
    public float YFloat => _y1 == null ? (float)_y2 : (float)_y1;

    /// <summary>The plane's Z-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Z
    {
        get
        {
            return _z1 == null ? _z2 : (double)_z1;
        }
        set
        {
            _z1 = null;
            _z2 = value;
        }
    }

    [JsonIgnore]
    public float ZFloat => _z1 == null ? (float)_z2 : (float)_z1;

    /// <summary>The plane's W-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double W
    {
        get
        {
            return _w1 == null ? _w2 : (double)_w1;
        }
        set
        {
            _w1 = null;
            _w2 = value;
        }
    }

    [JsonIgnore]
    public float WFloat => _w1 == null ? (float)_w2 : (float)_w1;

    public FPlane(double x, double y, double z, double w)
    {
        _x1 = null; _y1 = null; _z1 = null; _w1 = null;
        _x2 = x;
        _y2 = y;
        _z2 = z;
        _w2 = w;
    }

    public FPlane(float x, float y, float z, float w)
    {
        _x2 = 0; _y2 = 0; _z2 = 0; _w2 = 0;
        _x1 = x;
        _y1 = y;
        _z1 = z;
        _w1 = w;
    }

    public FPlane(AssetBinaryReader reader)
    {
        if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            _x1 = null; _y1 = null; _z1 = null; _w1 = null;
            _x2 = reader.ReadDouble();
            _y2 = reader.ReadDouble();
            _z2 = reader.ReadDouble();
            _w2 = reader.ReadDouble();
        }
        else
        {
            _x2 = 0; _y2 = 0; _z2 = 0; _w2 = 0;
            _x1 = reader.ReadSingle();
            _y1 = reader.ReadSingle();
            _z1 = reader.ReadSingle();
            _w1 = reader.ReadSingle();
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            writer.Write(_x2);
            writer.Write(_y2);
            writer.Write(_z2);
            writer.Write(_w2);
            return sizeof(double) * 4;
        }
        else
        {
            writer.Write(XFloat);
            writer.Write(YFloat);
            writer.Write(ZFloat);
            writer.Write(WFloat);
            return sizeof(float) * 4;
        }
    }

    public static FPlane Read(AssetBinaryReader reader) => new FPlane(reader);

    public override string ToString() => "(" + X + ", " + Y + ", " + Z + ", " + W + ")";
    public static FPlane FromString(string[] d, UAsset asset)
    {
        double.TryParse(d[0], out double X);
        double.TryParse(d[1], out double Y);
        double.TryParse(d[2], out double Z);
        double.TryParse(d[3], out double W);
        return new FPlane(X, Y, Z, W);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FQuat.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.JSON;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Floating point quaternion that can represent a rotation about an axis in 3-D space.
/// The X, Y, Z, W components also double as the Axis/Angle format.
/// </summary>
[JsonObject(MemberSerialization.OptIn)]
public struct FQuat : IStruct<FQuat>
{
    private float? _x1;
    private double _x2;
    private float? _y1;
    private double _y2;
    private float? _z1;
    private double _z2;
    private float? _w1;
    private double _w2;

    /// <summary>The quaternion's X-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double X
    {
        get
        {
            return _x1 == null ? _x2 : (double)_x1;
        }
        set
        {
            _x1 = null;
            _x2 = value;
        }
    }

    [JsonIgnore]
    public float XFloat => _x1 == null ? (float)_x2 : (float)_x1;

    /// <summary>The quaternion's Y-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Y
    {
        get
        {
            return _y1 == null ? _y2 : (double)_y1;
        }
        set
        {
            _y1 = null;
            _y2 = value;
        }
    }

    [JsonIgnore]
    public float YFloat => _y1 == null ? (float)_y2 : (float)_y1;

    /// <summary>The quaternion's Z-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Z
    {
        get
        {
            return _z1 == null ? _z2 : (double)_z1;
        }
        set
        {
            _z1 = null;
            _z2 = value;
        }
    }

    [JsonIgnore]
    public float ZFloat => _z1 == null ? (float)_z2 : (float)_z1;

    /// <summary>The quaternion's W-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double W
    {
        get
        {
            return _w1 == null ? _w2 : (double)_w1;
        }
        set
        {
            _w1 = null;
            _w2 = value;
        }
    }

    [JsonIgnore]
    public float WFloat => _w1 == null ? (float)_w2 : (float)_w1;

    public FQuat(double x, double y, double z, double w)
    {
        _x1 = null; _y1 = null; _z1 = null; _w1 = null;
        _x2 = x;
        _y2 = y;
        _z2 = z;
        _w2 = w;
    }

    public FQuat(float x, float y, float z, float w)
    {
        _x2 = 0; _y2 = 0; _z2 = 0; _w2 = 0;
        _x1 = x;
        _y1 = y;
        _z1 = z;
        _w1 = w;
    }

    public FQuat(AssetBinaryReader reader)
    {
        if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            _x1 = null; _y1 = null; _z1 = null; _w1 = null;
            _x2 = reader.ReadDouble();
            _y2 = reader.ReadDouble();
            _z2 = reader.ReadDouble();
            _w2 = reader.ReadDouble();
        }
        else
        {
            _x2 = 0; _y2 = 0; _z2 = 0; _w2 = 0;
            _x1 = reader.ReadSingle();
            _y1 = reader.ReadSingle();
            _z1 = reader.ReadSingle();
            _w1 = reader.ReadSingle();
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            writer.Write(X);
            writer.Write(Y);
            writer.Write(Z);
            writer.Write(W);
            return sizeof(double) * 4;
        }
        else
        {
            writer.Write(XFloat);
            writer.Write(YFloat);
            writer.Write(ZFloat);
            writer.Write(WFloat);
            return sizeof(float) * 4;
        }
    }

    public static FQuat Read(AssetBinaryReader reader) => new FQuat(reader);

    public override string ToString() => "(" + X + ", " + Y + ", " + Z + ", " + W + ")";

    public static FQuat FromString(string[] d, UAsset asset)
    {
        double.TryParse(d[0], out double X);
        double.TryParse(d[1], out double Y);
        double.TryParse(d[2], out double Z);
        double.TryParse(d[3], out double W);
        return new FQuat(X, Y, Z, W);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FRotator.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.JSON;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Implements a container for rotation information.
/// All rotation values are stored in degrees.
/// </summary>
[JsonObject(MemberSerialization.OptIn)]
public struct FRotator : IStruct<FRotator>
{
    private float? _pitch1;
    private double _pitch2;
    private float? _yaw1;
    private double _yaw2;
    private float? _roll1;
    private double _roll2;

    /// <summary>Rotation around the right axis (around Y axis), Looking up and down (0=Straight Ahead, +Up, -Down)</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Pitch
    {
        get
        {
            return _pitch1 == null ? _pitch2 : (double)_pitch1;
        }
        set
        {
            _pitch1 = null;
            _pitch2 = value;
        }
    }

    [JsonIgnore]
    public float PitchFloat => _pitch1 == null ? (float)_pitch2 : (float)_pitch1;

    /// <summary>Rotation around the up axis (around Z axis), Running in circles 0=East, +North, -South.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Yaw
    {
        get
        {
            return _yaw1 == null ? _yaw2 : (double)_yaw1;
        }
        set
        {
            _yaw1 = null;
            _yaw2 = value;
        }
    }

    [JsonIgnore]
    public float YawFloat => _yaw1 == null ? (float)_yaw2 : (float)_yaw1;

    /// <summary>Rotation around the forward axis (around X axis), Tilting your head, 0=Straight, +Clockwise, -CCW.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Roll
    {
        get
        {
            return _roll1 == null ? _roll2 : (double)_roll1;
        }
        set
        {
            _roll1 = null;
            _roll2 = value;
        }
    }

    [JsonIgnore]
    public float RollFloat => _roll1 == null ? (float)_roll2 : (float)_roll1;

    public FRotator(double pitch, double yaw, double roll)
    {
        _pitch1 = null; _yaw1 = null; _roll1 = null;
        _pitch2 = pitch;
        _yaw2 = yaw;
        _roll2 = roll;
    }

    public FRotator(float pitch, float yaw, float roll)
    {
        _pitch2 = 0; _yaw2 = 0; _roll2 = 0;
        _pitch1 = pitch;
        _yaw1 = yaw;
        _roll1 = roll;
    }

    public FRotator(AssetBinaryReader reader)
    {
        if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            _pitch1 = null; _yaw1 = null; _roll1 = null;
            _pitch2 = reader.ReadDouble();
            _yaw2 = reader.ReadDouble();
            _roll2 = reader.ReadDouble();
        }
        else
        {
            _pitch2 = 0; _yaw2 = 0; _roll2 = 0;
            _pitch1 = reader.ReadSingle();
            _yaw1 = reader.ReadSingle();
            _roll1 = reader.ReadSingle();
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            writer.Write(Pitch);
            writer.Write(Yaw);
            writer.Write(Roll);
            return sizeof(double) * 3;
        }
        else
        {
            writer.Write(PitchFloat);
            writer.Write(YawFloat);
            writer.Write(RollFloat);
            return sizeof(float) * 3;
        }
    }

    public static FRotator Read(AssetBinaryReader reader) => new FRotator(reader);

    public override string ToString() => $"({Roll}, {Pitch}, {Yaw})";

    public static FRotator FromString(string[] d, UAsset asset)
    {
        double.TryParse(d[0], out double Roll);
        double.TryParse(d[1], out double Pitch);
        double.TryParse(d[2], out double Yaw);
        return new FRotator(Pitch, Yaw, Roll);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FTransform.cs`:

```cs
namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Transform composed of Scale, Rotation (as a quaternion), and Translation.
/// Transforms can be used to convert from one space to another, for example by transforming
/// positions and directions from local space to world space.
/// 
/// Transformation of position vectors is applied in the order:  Scale -> Rotate -> Translate.
/// Transformation of direction vectors is applied in the order: Scale -> Rotate.
/// 
/// Order matters when composing transforms: C = A * B will yield a transform C that logically
/// first applies A then B to any subsequent transformation. Note that this is the opposite order of quaternion (FQuat) multiplication.
/// 
/// Example: LocalToWorld = (DeltaRotation * LocalToWorld) will change rotation in local space by DeltaRotation.
/// Example: LocalToWorld = (LocalToWorld * DeltaRotation) will change rotation in world space by DeltaRotation.
/// </summary>
public struct FTransform
{
    /// <summary>
    /// Rotation of this transformation, as a quaternion
    /// </summary>
    public FQuat Rotation;

    /// <summary>
    /// Translation of this transformation, as a vector.
    /// </summary>
    public FVector Translation;

    /// <summary>
    /// 3D scale (always applied in local space) as a vector.
    /// </summary>
    public FVector Scale3D;

    public FTransform(FQuat rotation, FVector translation, FVector scale3D)
    {
        Rotation = rotation;
        Translation = translation;
        Scale3D = scale3D;
    }

    public FTransform(AssetBinaryReader reader)
    {
        Rotation = new FQuat(reader);
        Translation = new FVector(reader);
        Scale3D = new FVector(reader);
    }

    public int Write(AssetBinaryWriter writer)
    {
        int size = 0;
        size += Rotation.Write(writer);
        size += Translation.Write(writer);
        size += Scale3D.Write(writer);
        return size;
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FTwoVectors.cs`:

```cs
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

public struct FTwoVectors : IStruct<FTwoVectors>
{
    public FVector V1;
    public FVector V2;

    public FTwoVectors(FVector v1, FVector v2)
    {
        V1 = v1;
        V2 = v2;
    }

    public FTwoVectors(AssetBinaryReader reader)
    {
        V1 = new FVector(reader);
        V2 = new FVector(reader);
    }

    public int Write(AssetBinaryWriter writer)
    {
        var size = V1.Write(writer);
        size += V2.Write(writer);
        return size;
    }

    public static FTwoVectors Read(AssetBinaryReader reader) => new FTwoVectors(reader);

    public override string ToString()
    {
        return $"({V1}, {V2})";
    }

    public static FTwoVectors FromString(string[] d, UAsset asset)
    {
        throw new System.NotImplementedException();
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FVector.cs`:

```cs
using Newtonsoft.Json;
using System;
using UAssetAPI.JSON;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// A vector in 3-D space composed of components (X, Y, Z) with floating/double point precision.
/// </summary>
public struct FVector : ICloneable, IStruct<FVector>
{
    private float? _x1;
    private double _x2;
    private float? _y1;
    private double _y2;
    private float? _z1;
    private double _z2;

    /// <summary>The vector's X-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double X
    {
        get
        {
            return _x1 == null ? _x2 : (double)_x1;
        }
        set
        {
            _x1 = null;
            _x2 = value;
        }
    }

    [JsonIgnore]
    public float XFloat => _x1 == null ? (float)_x2 : (float)_x1;

    /// <summary>The vector's Y-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Y
    {
        get
        {
            return _y1 == null ? _y2 : (double)_y1;
        }
        set
        {
            _y1 = null;
            _y2 = value;
        }
    }

    [JsonIgnore]
    public float YFloat => _y1 == null ? (float)_y2 : (float)_y1;

    /// <summary>The vector's Z-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Z
    {
        get
        {
            return _z1 == null ? _z2 : (double)_z1;
        }
        set
        {
            _z1 = null;
            _z2 = value;
        }
    }

    [JsonIgnore]
    public float ZFloat => _z1 == null ? (float)_z2 : (float)_z1;

    public FVector(double x, double y, double z)
    {
        _x1 = null; _y1 = null; _z1 = null;
        _x2 = x;
        _y2 = y;
        _z2 = z;
    }

    public FVector(float x, float y, float z)
    {
        _x2 = 0; _y2 = 0; _z2 = 0;
        _x1 = x;
        _y1 = y;
        _z1 = z;
    }

    public FVector(AssetBinaryReader reader)
    {
        if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            _x1 = null; _y1 = null; _z1 = null;
            _x2 = reader.ReadDouble();
            _y2 = reader.ReadDouble();
            _z2 = reader.ReadDouble();
        }
        else
        {
            _x2 = 0; _y2 = 0; _z2 = 0;
            _x1 = reader.ReadSingle();
            _y1 = reader.ReadSingle();
            _z1 = reader.ReadSingle();
        }
    }

    public static FVector Read(AssetBinaryReader reader) => new FVector(reader);

    public int Write(AssetBinaryWriter writer)
    {
        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            writer.Write(X);
            writer.Write(Y);
            writer.Write(Z);
            return sizeof(double) * 3;
        }
        else
        {
            writer.Write(XFloat);
            writer.Write(YFloat);
            writer.Write(ZFloat);
            return sizeof(float) * 3;
        }
    }

    public object Clone()
    {
        if (_x1 != null)
        {
            return new FVector((float)_x1, (float)_y1, (float)_z1);
        }
        else
        {
            return new FVector(_x2, _y2, _z2);
        }
    }

    public static FVector FromString(string[] d, UAsset asset)
    {
        double.TryParse(d[0], out double X);
        double.TryParse(d[1], out double Y);
        double.TryParse(d[2], out double Z);
        return new FVector(X, Y, Z);
    }

    public override string ToString()
    {
        return "(" + X + ", " + Y + ", " + Z + ")";
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FVector2D.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.JSON;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// A vector in 2-D space composed of components (X, Y) with floating/double point precision.
/// </summary>
public struct FVector2D : IStruct<FVector2D>
{
    private float? _x1;
    private double _x2;
    private float? _y1;
    private double _y2;

    /// <summary>The vector's X-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double X
    {
        get
        {
            return _x1 == null ? _x2 : (double)_x1;
        }
        set
        {
            _x1 = null;
            _x2 = value;
        }
    }

    [JsonIgnore]
    public float XFloat => _x1 == null ? (float)_x2 : (float)_x1;

    /// <summary>The vector's Y-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Y
    {
        get
        {
            return _y1 == null ? _y2 : (double)_y1;
        }
        set
        {
            _y1 = null;
            _y2 = value;
        }
    }

    [JsonIgnore]
    public float YFloat => _y1 == null ? (float)_y2 : (float)_y1;

    public FVector2D(double x, double y)
    {
        _x1 = null; _y1 = null;
        _x2 = x;
        _y2 = y;
    }

    public FVector2D(float x, float y, float z)
    {
        _x2 = 0; _y2 = 0;
        _x1 = x;
        _y1 = y;
    }

    public FVector2D(AssetBinaryReader reader)
    {
        if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            _x1 = null; _y1 = null;
            _x2 = reader.ReadDouble();
            _y2 = reader.ReadDouble();
        }
        else
        {
            _x2 = 0; _y2 = 0;
            _x1 = reader.ReadSingle();
            _y1 = reader.ReadSingle();
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            writer.Write(X);
            writer.Write(Y);
            return sizeof(double) * 2;
        }
        else
        {
            writer.Write(XFloat);
            writer.Write(YFloat);
            return sizeof(float) * 2;
        }
    }

    public static FVector2D Read(AssetBinaryReader reader) => new FVector2D(reader);

    public override string ToString() => $"({X}, {Y})";
    public static FVector2D FromString(string[] d, UAsset asset)
    {
        double.TryParse(d[0], out double X);
        double.TryParse(d[1], out double Y);
        return new FVector2D(X, Y);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FVector2f.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// A vector in 2-D space composed of components (X, Y) with floating point precision.
/// </summary>
public struct FVector2f : ICloneable, IStruct<FVector2f>
{
    public float X;
    public float Y;

    public FVector2f(float x, float y)
    {
        X = x;
        Y = y;
    }

    public FVector2f(AssetBinaryReader reader)
    {
        X = reader.ReadSingle();
        Y = reader.ReadSingle();
    }
    public static FVector2f Read(AssetBinaryReader reader) => new FVector2f(reader);

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(X);
        writer.Write(Y);
        return sizeof(float) * 2;
    }

    public object Clone() => new FVector2f(X, Y);

    public override string ToString() => $"({X}, {Y})";
    public static FVector2f FromString(string[] d, UAsset asset)
    {
        float.TryParse(d[0], out float X);
        float.TryParse(d[1], out float Y);
        return new FVector2f(X, Y);
    }
}
```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FVector3f.cs`:

```cs
using Newtonsoft.Json.Linq;
using System;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// A vector in 3-D space composed of components (X, Y, Z) with floating point precision.
/// </summary>
public struct FVector3f : ICloneable, IStruct<FVector3f>
{
    public float X;
    public float Y;
    public float Z;

    public FVector3f(float x, float y, float z)
    {
        X = x;
        Y = y;
        Z = z;
    }

    public FVector3f(AssetBinaryReader reader)
    {
        X = reader.ReadSingle();
        Y = reader.ReadSingle();
        Z = reader.ReadSingle();
    }

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(X);
        writer.Write(Y);
        writer.Write(Z);
        return sizeof(float) * 3;
    }

    public object Clone() => new FVector3f(X, Y, Z);

    public static FVector3f Read(AssetBinaryReader reader) => new FVector3f(reader);

    public override string ToString() => $"({X}, {Y}, {Z})";

    public static FVector3f FromString(string[] d, UAsset asset)
    {
        float.TryParse(d[0], out float X);
        float.TryParse(d[1], out float Y);
        float.TryParse(d[2], out float Z);
        return new FVector3f(X, Y, Z);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FVector4.cs`:

```cs
using Newtonsoft.Json;
using UAssetAPI.JSON;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// A vector in 4-D space composed of components (X, Y, Z, W) with floating/double point precision.
/// </summary>
public struct FVector4: IStruct<FVector4>
{
    private float? _x1;
    private double _x2;
    private float? _y1;
    private double _y2;
    private float? _z1;
    private double _z2;
    private float? _w1;
    private double _w2;

    /// <summary>The vector's X-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double X
    {
        get
        {
            return _x1 == null ? _x2 : (double)_x1;
        }
        set
        {
            _x1 = null;
            _x2 = value;
        }
    }

    [JsonIgnore]
    public float XFloat => _x1 == null ? (float)_x2 : (float)_x1;

    /// <summary>The vector's Y-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Y
    {
        get
        {
            return _y1 == null ? _y2 : (double)_y1;
        }
        set
        {
            _y1 = null;
            _y2 = value;
        }
    }

    [JsonIgnore]
    public float YFloat => _y1 == null ? (float)_y2 : (float)_y1;

    /// <summary>The vector's Z-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double Z
    {
        get
        {
            return _z1 == null ? _z2 : (double)_z1;
        }
        set
        {
            _z1 = null;
            _z2 = value;
        }
    }

    [JsonIgnore]
    public float ZFloat => _z1 == null ? (float)_z2 : (float)_z1;

    /// <summary>The vector's W-component.</summary>
    [JsonProperty]
    [JsonConverter(typeof(FSignedZeroJsonConverter))]
    public double W
    {
        get
        {
            return _w1 == null ? _w2 : (double)_w1;
        }
        set
        {
            _w1 = null;
            _w2 = value;
        }
    }

    [JsonIgnore]
    public float WFloat => _w1 == null ? (float)_w2 : (float)_w1;

    public FVector4(double x, double y, double z, double w)
    {
        _x1 = null; _y1 = null; _z1 = null; _w1 = null;
        _x2 = x;
        _y2 = y;
        _z2 = z;
        _w2 = w;
    }

    public FVector4(float x, float y, float z, float w)
    {
        _x2 = 0; _y2 = 0; _z2 = 0; _w2 = 0;
        _x1 = x;
        _y1 = y;
        _z1 = z;
        _w1 = w;
    }

    public FVector4(AssetBinaryReader reader)
    {
        if (reader.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            _x1 = null; _y1 = null; _z1 = null; _w1 = null;
            _x2 = reader.ReadDouble();
            _y2 = reader.ReadDouble();
            _z2 = reader.ReadDouble();
            _w2 = reader.ReadDouble();
        }
        else
        {
            _x2 = 0; _y2 = 0; _z2 = 0; _w2 = 0;
            _x1 = reader.ReadSingle();
            _y1 = reader.ReadSingle();
            _z1 = reader.ReadSingle();
            _w1 = reader.ReadSingle();
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        if (writer.Asset.ObjectVersionUE5 >= ObjectVersionUE5.LARGE_WORLD_COORDINATES)
        {
            writer.Write(_x2);
            writer.Write(_y2);
            writer.Write(_z2);
            writer.Write(_w2);
            return sizeof(double) * 4;
        }
        else
        {
            writer.Write(XFloat);
            writer.Write(YFloat);
            writer.Write(ZFloat);
            writer.Write(WFloat);
            return sizeof(float) * 4;
        }
    }

    public static FVector4 Read(AssetBinaryReader reader) => new FVector4(reader);

    public override string ToString() => $"({X}, {Y}, {Z}, {W})";

    public static FVector4 FromString(string[] d, UAsset asset)
    {
        double.TryParse(d[0], out double X);
        double.TryParse(d[1], out double Y);
        double.TryParse(d[2], out double Z);
        double.TryParse(d[3], out double W);
        return new FVector4(X, Y, Z, W);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/FVector4f.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// A vector in 4-D space composed of components (X, Y, Z, W) with floating point precision.
/// </summary>
public struct FVector4f : ICloneable, IStruct<FVector4f>
{
    public float X;
    public float Y;
    public float Z;
    public float W;

    public FVector4f(float x, float y, float z, float w)
    {
        X = x;
        Y = y;
        Z = z;
        W = w;
    }

    public FVector4f(AssetBinaryReader reader)
    {
        X = reader.ReadSingle();
        Y = reader.ReadSingle();
        Z = reader.ReadSingle();
        W = reader.ReadSingle();
    }

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(X);
        writer.Write(Y);
        writer.Write(Z);
        writer.Write(W);
        return sizeof(float) * 4;
    }

    public object Clone() => new FVector4f(X, Y, Z, W);

    public static FVector4f Read(AssetBinaryReader reader) => new FVector4f(reader);

    public override string ToString() => $"({X}, {Y}, {Z}, {W})";

    public static FVector4f FromString(string[] d, UAsset asset)
    {
        float.TryParse(d[0], out float X);
        float.TryParse(d[1], out float Y);
        float.TryParse(d[2], out float Z);
        float.TryParse(d[3], out float W);
        return new FVector4f(X, Y, Z, W);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/TBox.cs`:

```cs
using System;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Axis-aligned box collision geometry. Consists of a core AABB with a margin.
/// The margin should be considered physically part of the * box - it pads the faces and rounds the corners.
/// </summary>
/// <typeparam name="T"></typeparam>
public struct TBox<T> : ICloneable
{
    public T Min;
    public T Max;
    public byte IsValid;

    public TBox(T min, T max, byte isValid)
    {
        Min = min;
        Max = max;
        IsValid = isValid;
    }

    public TBox(AssetBinaryReader reader, Func<T> valueReader)
    {
        Min = valueReader();
        Max = valueReader();
        IsValid = reader.ReadByte();
    }

    public int Write(AssetBinaryWriter writer, Action<T> valueWriter)
    {
        var offset = writer.BaseStream.Position;
        valueWriter(Min);
        valueWriter(Max);
        writer.Write(IsValid);
        return (int)(writer.BaseStream.Position - offset);
    }

    public object Clone() => new TBox<T>(Min, Max, IsValid);
}

```

`UAssetAPI/UnrealTypes/Objects/Core/Math/TPerQualityLevel.cs`:

```cs
using System;
using System.Collections.Generic;

namespace UAssetAPI.UnrealTypes;

public struct TPerQualityLevel<T>
{
    public bool bCooked;
    public T Default;
    public Dictionary<int, T> PerQuality;

    public TPerQualityLevel(bool _bCooked, T _default, Dictionary<int, T> perQuality)
    {
        bCooked = _bCooked;
        Default = _default;
        PerQuality = perQuality;
    }

    public TPerQualityLevel(AssetBinaryReader reader, Func<T> valueReader)
    {
        bCooked = reader.ReadBooleanInt();
        Default = valueReader();
        PerQuality = [];
        int numElements = reader.ReadInt32();
        for (int i = 0; i < numElements; i++)
        {
            PerQuality[reader.ReadInt32()] = valueReader();
        }
    }

    public int Write(AssetBinaryWriter writer, Action<T> valueWriter)
    {
        var offset = writer.BaseStream.Position;
        writer.Write(bCooked ? 1 : 0);
        valueWriter(Default);
        writer.Write(PerQuality?.Count ?? 0);
        if (PerQuality != null)
        {
            foreach (var pair in PerQuality)
            {
                writer.Write(pair.Key);
                valueWriter(pair.Value);
            }
        }
        return (int)(writer.BaseStream.Position - offset);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Engine/CoreUObject/CoreUObjectEnums.cs`:

```cs
namespace UAssetAPI.UnrealTypes;

public enum EInterpCurveMode : byte {
	CIM_Linear = 0,
	CIM_CurveAuto = 1,
	CIM_Constant = 2,
	CIM_CurveUser = 3,
	CIM_CurveBreak = 4,
	CIM_CurveAutoClamped = 5,
    CIM_Unknown = 6
};

public enum ERangeBoundTypes : byte {
	Exclusive = 0,
	Inclusive = 1,
	Open = 2,
};

public enum EAxis : byte {
	None = 0,
	X = 1,
	Y = 2,
	Z = 3,
};
```

`UAssetAPI/UnrealTypes/Objects/Engine/CoreUObject/CoreUObjectStructs.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

public struct TRange<T>
{
    public TRangeBound<T> LowerBound;
    public TRangeBound<T> UpperBound;

    public TRange(TRangeBound<T> lowerBound, TRangeBound<T> upperBound)
    {
        LowerBound = lowerBound;
        UpperBound = upperBound;
    }

    public TRange(AssetBinaryReader reader, Func<T> valueReader)
    {
        LowerBound = new TRangeBound<T>(reader, valueReader);
        UpperBound = new TRangeBound<T>(reader, valueReader);
    }

    public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
    {
        LowerBound.Write(writer, valueWriter);
        UpperBound.Write(writer, valueWriter);
    }
}

/// <summary>
/// Template for range bounds.
/// </summary>
public struct TRangeBound<T>
{
    public ERangeBoundTypes Type;
    public T Value;

    public TRangeBound()
    {

    }

    public TRangeBound(ERangeBoundTypes type, T value)
    {
        Type = type;
        Value = value;
    }

    public TRangeBound(AssetBinaryReader reader, Func<T> valueReader)
    {
        Type = reader == null ? ERangeBoundTypes.Exclusive : (ERangeBoundTypes)reader.ReadByte();
        Value = valueReader();
    }

    public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
    {
        writer.Write((byte)Type);
        valueWriter(Value);
    }
}

public struct FFrameNumber : IStruct<FFrameNumber>
{
    public int Value;

    public FFrameNumber() { }

    public FFrameNumber(int value)
    {
        Value = value;
    }

    public FFrameNumber(AssetBinaryReader reader)
    {
        Value = reader?.ReadInt32() ?? 0;
    }

    public static FFrameNumber Read(AssetBinaryReader reader) => new FFrameNumber(reader);

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write(Value);
        return sizeof(int);
    }

    public static FFrameNumber FromString(string[] d, UAsset asset)
    {
        if (int.TryParse(d[0], out int val)) return new FFrameNumber(val);
        return new FFrameNumber();
    }
}

public struct FFrameRate
{
    public int Numerator;
    public int Denominator;

    public FFrameRate() { }

    public FFrameRate(int numerator, int denominator)
    {
        Numerator = numerator;
        Denominator = denominator;
    }

    public FFrameRate(AssetBinaryReader reader)
    {
        Numerator = reader.ReadInt32();
        Denominator = reader.ReadInt32();
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(Numerator);
        writer.Write(Denominator);
    }

    public override string ToString()
    {
        return Numerator.ToString() + "/" + Denominator.ToString();
    }

    public static bool TryParse(string s, out FFrameRate result)
    {
        result = new FFrameRate();
        string[] parts = s.Trim().Split('/');

        if (parts.Length != 2) return false;
        if (!int.TryParse(parts[0], out int numer)) return false;
        if (!int.TryParse(parts[1], out int denom)) return false;

        result = new FFrameRate(numer, denom);
        return true;
    }
}

public struct FFrameTime
{
    public FFrameNumber FrameNumber;
    public float SubFrame;

    public FFrameTime() { }

    public FFrameTime(FFrameNumber frameNumber, float subFrame)
    {
        FrameNumber = frameNumber;
        SubFrame = subFrame;
    }

    public FFrameTime(AssetBinaryReader reader)
    {
        FrameNumber = new FFrameNumber(reader);
        SubFrame = reader.ReadSingle();
    }

    public void Write(AssetBinaryWriter writer)
    {
        FrameNumber.Write(writer);
        writer.Write(SubFrame);
    }
}

public struct FQualifiedFrameTime
{
    public FFrameTime Time;
    public FFrameRate Rate;

    public FQualifiedFrameTime() { }

    public FQualifiedFrameTime(FFrameTime time, FFrameRate rate)
    {
        Time = time;
        Rate = rate;
    }

    public FQualifiedFrameTime(AssetBinaryReader reader)
    {
        Time = new FFrameTime(reader);
        Rate = new FFrameRate(reader);
    }

    public void Write(AssetBinaryWriter writer)
    {
        Time.Write(writer);
        Rate.Write(writer);
    }
}

public struct FTimecode
{
    public int Hours;
    public int Minutes;
    public int Seconds;
    public int Frames;
    public bool bDropFrameFormat;

    public FTimecode() { }

    public FTimecode(int hours, int minutes, int seconds, int frames, bool bDropFrameFormat)
    {
        Hours = hours;
        Minutes = minutes;
        Seconds = seconds;
        Frames = frames;
        this.bDropFrameFormat = bDropFrameFormat;
    }

    public FTimecode(AssetBinaryReader reader)
    {
        Hours = reader.ReadInt32();
        Minutes = reader.ReadInt32();
        Seconds = reader.ReadInt32();
        Frames = reader.ReadInt32();
        bDropFrameFormat = reader.ReadBoolean();
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(Hours);
        writer.Write(Minutes);
        writer.Write(Seconds);
        writer.Write(Frames);
        writer.Write(bDropFrameFormat);
    }
}
```

`UAssetAPI/UnrealTypes/Objects/Engine/EngineEnums.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.IO;
using UAssetAPI.PropertyTypes;

namespace UAssetAPI.UnrealTypes.EngineEnums
{

	// Enum Engine.ETextGender
	public enum ETextGender : byte {
		Masculine = 0,
		Feminine = 1,
		Neuter = 2,
		ETextGender_MAX = 3
	};

	// Enum Engine.EFormatArgumentType
	public enum EFormatArgumentType : byte {
		Int = 0,
		UInt = 1,
		Float = 2,
		Double = 3,
		Text = 4,
		Gender = 5,
		EFormatArgumentType_MAX = 6
	};

	// Enum Engine.EEndPlayReason
	public enum EEndPlayReason : byte {
		Destroyed = 0,
		LevelTransition = 1,
		EndPlayInEditor = 2,
		RemovedFromWorld = 3,
		Quit = 4,
		EEndPlayReason_MAX = 5
	};

	// Enum Engine.ETickingGroup
	public enum ETickingGroup : byte {
		TG_PrePhysics = 0,
		TG_StartPhysics = 1,
		TG_DuringPhysics = 2,
		TG_EndPhysics = 3,
		TG_PostPhysics = 4,
		TG_PostUpdateWork = 5,
		TG_LastDemotable = 6,
		TG_NewlySpawned = 7,
		TG_MAX = 8
	};

	// Enum Engine.EComponentCreationMethod
	public enum EComponentCreationMethod : byte {
		Native = 0,
		SimpleConstructionScript = 1,
		UserConstructionScript = 2,
		Instance = 3,
		EComponentCreationMethod_MAX = 4
	};

	// Enum Engine.ETemperatureSeverityType
	public enum ETemperatureSeverityType : byte {
		Unknown = 0,
		Good = 1,
		Bad = 2,
		Serious = 3,
		Critical = 4,
		NumSeverities = 5,
		ETemperatureSeverityType_MAX = 6
	};

	// Enum Engine.EPlaneConstraintAxisSetting
	public enum EPlaneConstraintAxisSetting : byte {
		Custom = 0,
		X = 1,
		Y = 2,
		Z = 3,
		UseGlobalPhysicsSetting = 4,
		EPlaneConstraintAxisSetting_MAX = 5
	};

	// Enum Engine.EInterpToBehaviourType
	public enum EInterpToBehaviourType : byte {
		OneShot = 0,
		OneShot_Reverse = 1,
		Loop_Reset = 2,
		PingPong = 3,
		EInterpToBehaviourType_MAX = 4
	};

	// Enum Engine.ETeleportType
	public enum ETeleportType : byte {
		None = 0,
		TeleportPhysics = 1,
		ResetPhysics = 2,
		ETeleportType_MAX = 3
	};

	// Enum Engine.EPlatformInterfaceDataType
	public enum EPlatformInterfaceDataType : byte {
		PIDT_None = 0,
		PIDT_Int = 1,
		PIDT_Float = 2,
		PIDT_String = 3,
		PIDT_Object = 4,
		PIDT_Custom = 5,
		PIDT_MAX = 6
	};

	// Enum Engine.EMovementMode
	public enum EMovementMode : byte {
		MOVE_None = 0,
		MOVE_Walking = 1,
		MOVE_NavWalking = 2,
		MOVE_Falling = 3,
		MOVE_Swimming = 4,
		MOVE_Flying = 5,
		MOVE_Custom = 6,
		MOVE_MAX = 7
	};

	// Enum Engine.ENetworkFailure
	public enum ENetworkFailure : byte {
		NetDriverAlreadyExists = 0,
		NetDriverCreateFailure = 1,
		NetDriverListenFailure = 2,
		ConnectionLost = 3,
		ConnectionTimeout = 4,
		FailureReceived = 5,
		OutdatedClient = 6,
		OutdatedServer = 7,
		PendingConnectionFailure = 8,
		NetGuidMismatch = 9,
		NetChecksumMismatch = 10,
		ENetworkFailure_MAX = 11
	};

	// Enum Engine.ETravelFailure
	public enum ETravelFailure : byte {
		NoLevel = 0,
		LoadMapFailure = 1,
		InvalidURL = 2,
		PackageMissing = 3,
		PackageVersion = 4,
		NoDownload = 5,
		TravelFailure = 6,
		CheatCommands = 7,
		PendingNetGameCreateFailure = 8,
		CloudSaveFailure = 9,
		ServerTravelFailure = 10,
		ClientTravelFailure = 11,
		ETravelFailure_MAX = 12
	};

	// Enum Engine.EScreenOrientation
	public enum EScreenOrientation : byte {
		Unknown = 0,
		Portrait = 1,
		PortraitUpsideDown = 2,
		LandscapeLeft = 3,
		LandscapeRight = 4,
		FaceUp = 5,
		FaceDown = 6,
		EScreenOrientation_MAX = 7
	};

	// Enum Engine.EApplicationState
	public enum EApplicationState : byte {
		Unknown = 0,
		Inactive = 1,
		Background = 2,
		Active = 3,
		EApplicationState_MAX = 4
	};

	// Enum Engine.EObjectTypeQuery
	public enum EObjectTypeQuery : byte {
		ObjectTypeQuery1 = 0,
		ObjectTypeQuery2 = 1,
		ObjectTypeQuery3 = 2,
		ObjectTypeQuery4 = 3,
		ObjectTypeQuery5 = 4,
		ObjectTypeQuery6 = 5,
		ObjectTypeQuery7 = 6,
		ObjectTypeQuery8 = 7,
		ObjectTypeQuery9 = 8,
		ObjectTypeQuery10 = 9,
		ObjectTypeQuery11 = 10,
		ObjectTypeQuery12 = 11,
		ObjectTypeQuery13 = 12,
		ObjectTypeQuery14 = 13,
		ObjectTypeQuery15 = 14,
		ObjectTypeQuery16 = 15,
		ObjectTypeQuery17 = 16,
		ObjectTypeQuery18 = 17,
		ObjectTypeQuery19 = 18,
		ObjectTypeQuery20 = 19,
		ObjectTypeQuery21 = 20,
		ObjectTypeQuery22 = 21,
		ObjectTypeQuery23 = 22,
		ObjectTypeQuery24 = 23,
		ObjectTypeQuery25 = 24,
		ObjectTypeQuery26 = 25,
		ObjectTypeQuery27 = 26,
		ObjectTypeQuery28 = 27,
		ObjectTypeQuery29 = 28,
		ObjectTypeQuery30 = 29,
		ObjectTypeQuery31 = 30,
		ObjectTypeQuery32 = 31,
		ObjectTypeQuery_MAX = 32,
		EObjectTypeQuery_MAX = 33
	};

	// Enum Engine.EDrawDebugTrace
	public enum EDrawDebugTrace : byte {
		None = 0,
		ForOneFrame = 1,
		ForDuration = 2,
		Persistent = 3,
		EDrawDebugTrace_MAX = 4
	};

	// Enum Engine.ETraceTypeQuery
	public enum ETraceTypeQuery : byte {
		TraceTypeQuery1 = 0,
		TraceTypeQuery2 = 1,
		TraceTypeQuery3 = 2,
		TraceTypeQuery4 = 3,
		TraceTypeQuery5 = 4,
		TraceTypeQuery6 = 5,
		TraceTypeQuery7 = 6,
		TraceTypeQuery8 = 7,
		TraceTypeQuery9 = 8,
		TraceTypeQuery10 = 9,
		TraceTypeQuery11 = 10,
		TraceTypeQuery12 = 11,
		TraceTypeQuery13 = 12,
		TraceTypeQuery14 = 13,
		TraceTypeQuery15 = 14,
		TraceTypeQuery16 = 15,
		TraceTypeQuery17 = 16,
		TraceTypeQuery18 = 17,
		TraceTypeQuery19 = 18,
		TraceTypeQuery20 = 19,
		TraceTypeQuery21 = 20,
		TraceTypeQuery22 = 21,
		TraceTypeQuery23 = 22,
		TraceTypeQuery24 = 23,
		TraceTypeQuery25 = 24,
		TraceTypeQuery26 = 25,
		TraceTypeQuery27 = 26,
		TraceTypeQuery28 = 27,
		TraceTypeQuery29 = 28,
		TraceTypeQuery30 = 29,
		TraceTypeQuery31 = 30,
		TraceTypeQuery32 = 31,
		TraceTypeQuery_MAX = 32,
		ETraceTypeQuery_MAX = 33
	};

	// Enum Engine.EMoveComponentAction
	public enum EMoveComponentAction : byte {
		Move = 0,
		Stop = 1,
		Return = 2,
		EMoveComponentAction_MAX = 3
	};

	// Enum Engine.EQuitPreference
	public enum EQuitPreference : byte {
		Quit = 0,
		Background = 1,
		EQuitPreference_MAX = 2
	};

	// Enum Engine.ERelativeTransformSpace
	public enum ERelativeTransformSpace : byte {
		RTS_World = 0,
		RTS_Actor = 1,
		RTS_Component = 2,
		RTS_ParentBoneSpace = 3,
		RTS_MAX = 4
	};

	// Enum Engine.EAttachLocation
	public enum EAttachLocation : byte {
		KeepRelativeOffset = 0,
		KeepWorldPosition = 1,
		SnapToTarget = 2,
		SnapToTargetIncludingScale = 3,
		EAttachLocation_MAX = 4
	};

	// Enum Engine.EAttachmentRule
	public enum EAttachmentRule : byte {
		KeepRelative = 0,
		KeepWorld = 1,
		SnapToTarget = 2,
		EAttachmentRule_MAX = 3
	};

	// Enum Engine.EDetachmentRule
	public enum EDetachmentRule : byte {
		KeepRelative = 0,
		KeepWorld = 1,
		EDetachmentRule_MAX = 2
	};

	// Enum Engine.EComponentMobility
	public enum EComponentMobility : byte {
		Static = 0,
		Stationary = 1,
		Movable = 2,
		EComponentMobility_MAX = 3
	};

	// Enum Engine.EDetailMode
	public enum EDetailMode : byte {
		DM_Low = 0,
		DM_Medium = 1,
		DM_High = 2,
		DM_MAX = 3
	};

	// Enum Engine.ENetRole
	public enum ENetRole : byte {
		ROLE_None = 0,
		ROLE_SimulatedProxy = 1,
		ROLE_AutonomousProxy = 2,
		ROLE_Authority = 3,
		ROLE_MAX = 4
	};

	// Enum Engine.ENetDormancy
	public enum ENetDormancy : byte {
		DORM_Never = 0,
		DORM_Awake = 1,
		DORM_DormantAll = 2,
		DORM_DormantPartial = 3,
		DORM_Initial = 4,
		DORM_MAX = 5
	};

	// Enum Engine.EAutoReceiveInput
	public enum EAutoReceiveInput : byte {
		Disabled = 0,
		Player0 = 1,
		Player1 = 2,
		Player2 = 3,
		Player3 = 4,
		Player4 = 5,
		Player5 = 6,
		Player6 = 7,
		Player7 = 8,
		EAutoReceiveInput_MAX = 9
	};

	// Enum Engine.ESpawnActorCollisionHandlingMethod
	public enum ESpawnActorCollisionHandlingMethod : byte {
		Undefined = 0,
		AlwaysSpawn = 1,
		AdjustIfPossibleButAlwaysSpawn = 2,
		AdjustIfPossibleButDontSpawnIfColliding = 3,
		DontSpawnIfColliding = 4,
		ESpawnActorCollisionHandlingMethod_MAX = 5
	};

	// Enum Engine.ERotatorQuantization
	public enum ERotatorQuantization : byte {
		ByteComponents = 0,
		ShortComponents = 1,
		ERotatorQuantization_MAX = 2
	};

	// Enum Engine.EVectorQuantization
	public enum EVectorQuantization : byte {
		RoundWholeNumber = 0,
		RoundOneDecimal = 1,
		RoundTwoDecimals = 2,
		EVectorQuantization_MAX = 3
	};

	// Enum Engine.EActorUpdateOverlapsMethod
	public enum EActorUpdateOverlapsMethod : byte {
		UseConfigDefault = 0,
		AlwaysUpdate = 1,
		OnlyUpdateMovable = 2,
		NeverUpdate = 3,
		EActorUpdateOverlapsMethod_MAX = 4
	};

	// Enum Engine.EAutoPossessAI
	public enum EAutoPossessAI : byte {
		Disabled = 0,
		PlacedInWorld = 1,
		Spawned = 2,
		PlacedInWorldOrSpawned = 3,
		EAutoPossessAI_MAX = 4
	};

	// Enum Engine.EPhysicalSurface
	public enum EPhysicalSurface : byte {
		SurfaceType_Default = 0,
		SurfaceType1 = 1,
		SurfaceType2 = 2,
		SurfaceType3 = 3,
		SurfaceType4 = 4,
		SurfaceType5 = 5,
		SurfaceType6 = 6,
		SurfaceType7 = 7,
		SurfaceType8 = 8,
		SurfaceType9 = 9,
		SurfaceType10 = 10,
		SurfaceType11 = 11,
		SurfaceType12 = 12,
		SurfaceType13 = 13,
		SurfaceType14 = 14,
		SurfaceType15 = 15,
		SurfaceType16 = 16,
		SurfaceType17 = 17,
		SurfaceType18 = 18,
		SurfaceType19 = 19,
		SurfaceType20 = 20,
		SurfaceType21 = 21,
		SurfaceType22 = 22,
		SurfaceType23 = 23,
		SurfaceType24 = 24,
		SurfaceType25 = 25,
		SurfaceType26 = 26,
		SurfaceType27 = 27,
		SurfaceType28 = 28,
		SurfaceType29 = 29,
		SurfaceType30 = 30,
		SurfaceType31 = 31,
		SurfaceType32 = 32,
		SurfaceType33 = 33,
		SurfaceType34 = 34,
		SurfaceType35 = 35,
		SurfaceType36 = 36,
		SurfaceType37 = 37,
		SurfaceType38 = 38,
		SurfaceType39 = 39,
		SurfaceType40 = 40,
		SurfaceType41 = 41,
		SurfaceType42 = 42,
		SurfaceType43 = 43,
		SurfaceType44 = 44,
		SurfaceType45 = 45,
		SurfaceType46 = 46,
		SurfaceType47 = 47,
		SurfaceType48 = 48,
		SurfaceType49 = 49,
		SurfaceType50 = 50,
		SurfaceType51 = 51,
		SurfaceType52 = 52,
		SurfaceType53 = 53,
		SurfaceType54 = 54,
		SurfaceType55 = 55,
		SurfaceType56 = 56,
		SurfaceType57 = 57,
		SurfaceType58 = 58,
		SurfaceType59 = 59,
		SurfaceType60 = 60,
		SurfaceType61 = 61,
		SurfaceType62 = 62,
		SurfaceType_Max = 63,
		EPhysicalSurface_MAX = 64
	};

	// Enum Engine.EMouseLockMode
	public enum EMouseLockMode : byte {
		DoNotLock = 0,
		LockOnCapture = 1,
		LockAlways = 2,
		LockInFullscreen = 3,
		EMouseLockMode_MAX = 4
	};

	// Enum Engine.EWindowTitleBarMode
	public enum EWindowTitleBarMode : byte {
		Overlay = 0,
		VerticalBox = 1,
		EWindowTitleBarMode_MAX = 2
	};

	// Enum Engine.EAlphaBlendOption
	public enum EAlphaBlendOption : byte {
		Linear = 0,
		Cubic = 1,
		HermiteCubic = 2,
		Sinusoidal = 3,
		QuadraticInOut = 4,
		CubicInOut = 5,
		QuarticInOut = 6,
		QuinticInOut = 7,
		CircularIn = 8,
		CircularOut = 9,
		CircularInOut = 10,
		ExpIn = 11,
		ExpOut = 12,
		ExpInOut = 13,
		Custom = 14,
		EAlphaBlendOption_MAX = 15
	};

	// Enum Engine.EAnimGroupRole
	public enum EAnimGroupRole : byte {
		CanBeLeader = 0,
		AlwaysFollower = 1,
		AlwaysLeader = 2,
		TransitionLeader = 3,
		TransitionFollower = 4,
		EAnimGroupRole_MAX = 5
	};

	// Enum Engine.EPreviewAnimationBlueprintApplicationMethod
	public enum EPreviewAnimationBlueprintApplicationMethod : byte {
		LinkedLayers = 0,
		LinkedAnimGraph = 1,
		EPreviewAnimationBlueprintApplicationMethod_MAX = 2
	};

	// Enum Engine.AnimationKeyFormat
	public enum AnimationKeyFormat : byte {
		AKF_ConstantKeyLerp = 0,
		AKF_VariableKeyLerp = 1,
		AKF_PerTrackCompression = 2,
		AKF_MAX = 3
	};

	// Enum Engine.ERawCurveTrackTypes
	public enum ERawCurveTrackTypes : byte {
		RCT_Float = 0,
		RCT_Vector = 1,
		RCT_Transform = 2,
		RCT_MAX = 3
	};

	// Enum Engine.EAnimAssetCurveFlags
	public enum EAnimAssetCurveFlags : byte {
		AACF_NONE = 0,
		AACF_DriveMorphTarget_DEPRECATED = 1,
		AACF_DriveAttribute_DEPRECATED = 2,
		AACF_Editable = 4,
		AACF_DriveMaterial_DEPRECATED = 8,
		AACF_Metadata = 16,
		AACF_DriveTrack = 32,
		AACF_Disabled = 64,
		AACF_MAX = 65
	};

	// Enum Engine.AnimationCompressionFormat
	public enum AnimationCompressionFormat : byte {
		ACF_None = 0,
		ACF_Float96NoW = 1,
		ACF_Fixed48NoW = 2,
		ACF_IntervalFixed32NoW = 3,
		ACF_Fixed32NoW = 4,
		ACF_Float32NoW = 5,
		ACF_Identity = 6,
		ACF_MAX = 7
	};

	// Enum Engine.EAdditiveBasePoseType
	public enum EAdditiveBasePoseType : byte {
		ABPT_None = 0,
		ABPT_RefPose = 1,
		ABPT_AnimScaled = 2,
		ABPT_AnimFrame = 3,
		ABPT_MAX = 4
	};

	// Enum Engine.ERootMotionMode
	public enum ERootMotionMode : byte {
		NoRootMotionExtraction = 0,
		IgnoreRootMotion = 1,
		RootMotionFromEverything = 2,
		RootMotionFromMontagesOnly = 3,
		ERootMotionMode_MAX = 4
	};

	// Enum Engine.ERootMotionRootLock
	public enum ERootMotionRootLock : byte {
		RefPose = 0,
		AnimFirstFrame = 1,
		Zero = 2,
		ERootMotionRootLock_MAX = 3
	};

	// Enum Engine.EMontagePlayReturnType
	public enum EMontagePlayReturnType : byte {
		MontageLength = 0,
		Duration = 1,
		EMontagePlayReturnType_MAX = 2
	};

	// Enum Engine.EDrawDebugItemType
	public enum EDrawDebugItemType : byte {
		DirectionalArrow = 0,
		Sphere = 1,
		Line = 2,
		OnScreenMessage = 3,
		CoordinateSystem = 4,
		EDrawDebugItemType_MAX = 5
	};

	// Enum Engine.EAnimLinkMethod
	public enum EAnimLinkMethod : byte {
		Absolute = 0,
		Relative = 1,
		Proportional = 2,
		EAnimLinkMethod_MAX = 3
	};

	// Enum Engine.EMontageSubStepResult
	public enum EMontageSubStepResult : byte {
		Moved = 0,
		NotMoved = 1,
		InvalidSection = 2,
		InvalidMontage = 3,
		EMontageSubStepResult_MAX = 4
	};

	// Enum Engine.EAnimNotifyEventType
	public enum EAnimNotifyEventType : byte {
		Begin = 0,
		End = 1,
		EAnimNotifyEventType_MAX = 2
	};

	// Enum Engine.EInertializationSpace
	public enum EInertializationSpace : byte {
		Default = 0,
		WorldSpace = 1,
		WorldRotation = 2,
		EInertializationSpace_MAX = 3
	};

	// Enum Engine.EInertializationBoneState
	public enum EInertializationBoneState : byte {
		Invalid = 0,
		Valid = 1,
		Excluded = 2,
		EInertializationBoneState_MAX = 3
	};

	// Enum Engine.EInertializationState
	public enum EInertializationState : byte {
		Inactive = 0,
		Pending = 1,
		Active = 2,
		EInertializationState_MAX = 3
	};

	// Enum Engine.EEvaluatorMode
	public enum EEvaluatorMode : byte {
		EM_Standard = 0,
		EM_Freeze = 1,
		EM_DelayedFreeze = 2,
		EM_MAX = 3
	};

	// Enum Engine.EEvaluatorDataSource
	public enum EEvaluatorDataSource : byte {
		EDS_SourcePose = 0,
		EDS_DestinationPose = 1,
		EDS_MAX = 2
	};

	// Enum Engine.ECopyType
	public enum ECopyType : byte {
		PlainProperty = 0,
		BoolProperty = 1,
		StructProperty = 2,
		ObjectProperty = 3,
		NameProperty = 4,
		ECopyType_MAX = 5
	};

	// Enum Engine.EPostCopyOperation
	public enum EPostCopyOperation : byte {
		None = 0,
		LogicalNegateBool = 1,
		EPostCopyOperation_MAX = 2
	};

	// Enum Engine.EPinHidingMode
	public enum EPinHidingMode : byte {
		NeverAsPin = 0,
		PinHiddenByDefault = 1,
		PinShownByDefault = 2,
		AlwaysAsPin = 3,
		EPinHidingMode_MAX = 4
	};

	// Enum Engine.AnimPhysCollisionType
	public enum AnimPhysCollisionType : byte {
		CoM = 0,
		CustomSphere = 1,
		InnerSphere = 2,
		OuterSphere = 3,
		AnimPhysCollisionType_MAX = 4
	};

	// Enum Engine.AnimPhysTwistAxis
	public enum AnimPhysTwistAxis : byte {
		AxisX = 0,
		AxisY = 1,
		AxisZ = 2,
		AnimPhysTwistAxis_MAX = 3
	};

	// Enum Engine.ETypeAdvanceAnim
	public enum ETypeAdvanceAnim : byte {
		ETAA_Default = 0,
		ETAA_Finished = 1,
		ETAA_Looped = 2,
		ETAA_MAX = 3
	};

	// Enum Engine.ETransitionLogicType
	public enum ETransitionLogicType : byte {
		TLT_StandardBlend = 0,
		TLT_Inertialization = 1,
		TLT_Custom = 2,
		TLT_MAX = 3
	};

	// Enum Engine.ETransitionBlendMode
	public enum ETransitionBlendMode : byte {
		TBM_Linear = 0,
		TBM_Cubic = 1,
		TBM_MAX = 2
	};

	// Enum Engine.EComponentType
	public enum EComponentType : byte {
		None = 0,
		TranslationX = 1,
		TranslationY = 2,
		TranslationZ = 3,
		RotationX = 4,
		RotationY = 5,
		RotationZ = 6,
		Scale = 7,
		ScaleX = 8,
		ScaleY = 9,
		ScaleZ = 10,
		EComponentType_MAX = 11
	};

	// Enum Engine.EAxisOption
	public enum EAxisOption : byte {
		X = 0,
		Y = 1,
		Z = 2,
		X_Neg = 3,
		Y_Neg = 4,
		Z_Neg = 5,
		Custom = 6,
		EAxisOption_MAX = 7
	};

	// Enum Engine.EAnimInterpolationType
	public enum EAnimInterpolationType : byte {
		Linear = 0,
		Step = 1,
		EAnimInterpolationType_MAX = 2
	};

	// Enum Engine.ECurveBlendOption
	public enum ECurveBlendOption : byte {
		Override = 0,
		DoNotOverride = 1,
		NormalizeByWeight = 2,
		BlendByWeight = 3,
		UseBasePose = 4,
		UseMaxValue = 5,
		UseMinValue = 6,
		ECurveBlendOption_MAX = 7
	};

	// Enum Engine.EAdditiveAnimationType
	public enum EAdditiveAnimationType : byte {
		AAT_None = 0,
		AAT_LocalSpaceBase = 1,
		AAT_RotationOffsetMeshSpace = 2,
		AAT_MAX = 3
	};

	// Enum Engine.ENotifyFilterType
	public enum ENotifyFilterType : byte {
		NoFiltering = 0,
		LOD = 1,
		ENotifyFilterType_MAX = 2
	};

	// Enum Engine.EMontageNotifyTickType
	public enum EMontageNotifyTickType : byte {
		Queued = 0,
		BranchingPoint = 1,
		EMontageNotifyTickType_MAX = 2
	};

	// Enum Engine.EBoneRotationSource
	public enum EBoneRotationSource : byte {
		BRS_KeepComponentSpaceRotation = 0,
		BRS_KeepLocalSpaceRotation = 1,
		BRS_CopyFromTarget = 2,
		BRS_MAX = 3
	};

	// Enum Engine.EBoneControlSpace
	public enum EBoneControlSpace : byte {
		BCS_WorldSpace = 0,
		BCS_ComponentSpace = 1,
		BCS_ParentBoneSpace = 2,
		BCS_BoneSpace = 3,
		BCS_MAX = 4
	};

	// Enum Engine.EBoneAxis
	public enum EBoneAxis : byte {
		BA_X = 0,
		BA_Y = 1,
		BA_Z = 2,
		BA_MAX = 3
	};

	// Enum Engine.EPrimaryAssetCookRule
	public enum EPrimaryAssetCookRule : byte {
		Unknown = 0,
		NeverCook = 1,
		DevelopmentCook = 2,
		DevelopmentAlwaysCook = 3,
		AlwaysCook = 4,
		EPrimaryAssetCookRule_MAX = 5
	};

	// Enum Engine.ENaturalSoundFalloffMode
	public enum ENaturalSoundFalloffMode : byte {
		Continues = 0,
		Silent = 1,
		Hold = 2,
		ENaturalSoundFalloffMode_MAX = 3
	};

	// Enum Engine.EAttenuationShape
	public enum EAttenuationShape : byte {
		Sphere = 0,
		Capsule = 1,
		Box = 2,
		Cone = 3,
		EAttenuationShape_MAX = 4
	};

	// Enum Engine.EAttenuationDistanceModel
	public enum EAttenuationDistanceModel : byte {
		Linear = 0,
		Logarithmic = 1,
		Inverse = 2,
		LogReverse = 3,
		NaturalSound = 4,
		Custom = 5,
		EAttenuationDistanceModel_MAX = 6
	};

	// Enum Engine.EAudioFaderCurve
	public enum EAudioFaderCurve : byte {
		Linear = 0,
		Logarithmic = 1,
		SCurve = 2,
		Sin = 3,
		Count = 4,
		EAudioFaderCurve_MAX = 5
	};

	// Enum Engine.EAudioComponentPlayState
	public enum EAudioComponentPlayState : byte {
		Playing = 0,
		Stopped = 1,
		Paused = 2,
		FadingIn = 3,
		FadingOut = 4,
		Count = 5,
		EAudioComponentPlayState_MAX = 6
	};

	// Enum Engine.EAudioOutputTarget
	public enum EAudioOutputTarget : byte {
		Speaker = 0,
		Controller = 1,
		ControllerFallbackToSpeaker = 2,
		EAudioOutputTarget_MAX = 3
	};

	// Enum Engine.EMonoChannelUpmixMethod
	public enum EMonoChannelUpmixMethod : byte {
		Linear = 0,
		EqualPower = 1,
		FullVolume = 2,
		EMonoChannelUpmixMethod_MAX = 3
	};

	// Enum Engine.EPanningMethod
	public enum EPanningMethod : byte {
		Linear = 0,
		EqualPower = 1,
		EPanningMethod_MAX = 2
	};

	// Enum Engine.EVoiceSampleRate
	public enum EVoiceSampleRate : int {
		Low16000Hz = 16000,
		Normal24000Hz = 24000,
		EVoiceSampleRate_MAX = 24001
	};

	// Enum Engine.EBlendableLocation
	public enum EBlendableLocation : byte {
		BL_AfterTonemapping = 0,
		BL_BeforeTonemapping = 1,
		BL_BeforeTranslucency = 2,
		BL_ReplacingTonemapper = 3,
		BL_SSRInput = 4,
		BL_MAX = 5
	};

	// Enum Engine.ENotifyTriggerMode
	public enum ENotifyTriggerMode : byte {
		AllAnimations = 0,
		HighestWeightedAnimation = 1,
		None = 2,
		ENotifyTriggerMode_MAX = 3
	};

	// Enum Engine.EBlendSpaceAxis
	public enum EBlendSpaceAxis : byte {
		BSA_None = 0,
		BSA_X = 1,
		BSA_Y = 2,
		BSA_Max = 3
	};

	// Enum Engine.EBlueprintNativizationFlag
	public enum EBlueprintNativizationFlag : byte {
		Disabled = 0,
		Dependency = 1,
		ExplicitlyEnabled = 2,
		EBlueprintNativizationFlag_MAX = 3
	};

	// Enum Engine.EBlueprintCompileMode
	public enum EBlueprintCompileMode : byte {
		Default = 0,
		Development = 1,
		FinalRelease = 2,
		EBlueprintCompileMode_MAX = 3
	};

	// Enum Engine.EBlueprintType
	public enum EBlueprintType : byte {
		BPTYPE_Normal = 0,
		BPTYPE_Const = 1,
		BPTYPE_MacroLibrary = 2,
		BPTYPE_Interface = 3,
		BPTYPE_LevelScript = 4,
		BPTYPE_FunctionLibrary = 5,
		BPTYPE_MAX = 6
	};

	// Enum Engine.EBlueprintStatus
	public enum EBlueprintStatus : byte {
		BS_Unknown = 0,
		BS_Dirty = 1,
		BS_Error = 2,
		BS_UpToDate = 3,
		BS_BeingCreated = 4,
		BS_UpToDateWithWarnings = 5,
		BS_MAX = 6
	};

	// Enum Engine.EDOFMode
	public enum EDOFMode : byte {
		Default = 0,
		SixDOF = 1,
		YZPlane = 2,
		XZPlane = 3,
		XYPlane = 4,
		CustomPlane = 5,
		None = 6,
		EDOFMode_MAX = 7
	};

	// Enum Engine.EBodyCollisionResponse
	public enum EBodyCollisionResponse : byte {
		BodyCollision_Enabled = 0,
		BodyCollision_Disabled = 1,
		BodyCollision_MAX = 2
	};

	// Enum Engine.EPhysicsType
	public enum EPhysicsType : byte {
		PhysType_Default = 0,
		PhysType_Kinematic = 1,
		PhysType_Simulated = 2,
		PhysType_MAX = 3
	};

	// Enum Engine.ECollisionTraceFlag
	public enum ECollisionTraceFlag : byte {
		CTF_UseDefault = 0,
		CTF_UseSimpleAndComplex = 1,
		CTF_UseSimpleAsComplex = 2,
		CTF_UseComplexAsSimple = 3,
		CTF_MAX = 4
	};

	// Enum Engine.EBrushType
	public enum EBrushType : byte {
		Brush_Default = 0,
		Brush_Add = 1,
		Brush_Subtract = 2,
		Brush_MAX = 3
	};

	// Enum Engine.ECsgOper
	public enum ECsgOper : byte {
		CSG_Active = 0,
		CSG_Add = 1,
		CSG_Subtract = 2,
		CSG_Intersect = 3,
		CSG_Deintersect = 4,
		CSG_None = 5,
		CSG_MAX = 6
	};

	// Enum Engine.EInitialOscillatorOffset
	public enum EInitialOscillatorOffset : byte {
		EOO_OffsetRandom = 0,
		EOO_OffsetZero = 1,
		EOO_MAX = 2
	};

	// Enum Engine.EOscillatorWaveform
	public enum EOscillatorWaveform : byte {
		SineWave = 0,
		PerlinNoise = 1,
		EOscillatorWaveform_MAX = 2
	};

	// Enum Engine.ECameraShakeAttenuation
	public enum ECameraShakeAttenuation : byte {
		Linear = 0,
		Quadratic = 1,
		ECameraShakeAttenuation_MAX = 2
	};

	// Enum Engine.ECameraAlphaBlendMode
	public enum ECameraAlphaBlendMode : byte {
		CABM_Linear = 0,
		CABM_Cubic = 1,
		CABM_MAX = 2
	};

	// Enum Engine.ECameraAnimPlaySpace
	public enum ECameraAnimPlaySpace : byte {
		CameraLocal = 0,
		World = 1,
		UserDefined = 2,
		ECameraAnimPlaySpace_MAX = 3
	};

	// Enum Engine.ECameraProjectionMode
	public enum ECameraProjectionMode : byte {
		Perspective = 0,
		Orthographic = 1,
		ECameraProjectionMode_MAX = 2
	};

	// Enum Engine.ECloudStorageDelegate
	public enum ECloudStorageDelegate : byte {
		CSD_KeyValueReadComplete = 0,
		CSD_KeyValueWriteComplete = 1,
		CSD_ValueChanged = 2,
		CSD_DocumentQueryComplete = 3,
		CSD_DocumentReadComplete = 4,
		CSD_DocumentWriteComplete = 5,
		CSD_DocumentConflictDetected = 6,
		CSD_MAX = 7
	};

	// Enum Engine.EAngularDriveMode
	public enum EAngularDriveMode : byte {
		SLERP = 0,
		TwistAndSwing = 1,
		EAngularDriveMode_MAX = 2
	};

	// Enum Engine.ELinearConstraintMotion
	public enum ELinearConstraintMotion : byte {
		LCM_Free = 0,
		LCM_Limited = 1,
		LCM_Locked = 2,
		LCM_MAX = 3
	};

	// Enum Engine.ECurveTableMode
	public enum ECurveTableMode : byte {
		Empty = 0,
		SimpleCurves = 1,
		RichCurves = 2,
		ECurveTableMode_MAX = 3
	};

	// Enum Engine.EEvaluateCurveTableResult
	public enum EEvaluateCurveTableResult : byte {
		RowFound = 0,
		RowNotFound = 1,
		EEvaluateCurveTableResult_MAX = 2
	};

	// Enum Engine.EGrammaticalNumber
	public enum EGrammaticalNumber : byte {
		Singular = 0,
		Plural = 1,
		EGrammaticalNumber_MAX = 2
	};

	// Enum Engine.EGrammaticalGender
	public enum EGrammaticalGender : byte {
		Neuter = 0,
		Masculine = 1,
		Feminine = 2,
		Mixed = 3,
		EGrammaticalGender_MAX = 4
	};

	// Enum Engine.DistributionParamMode
	public enum DistributionParamMode : byte {
		DPM_Normal = 0,
		DPM_Abs = 1,
		DPM_Direct = 2,
		DPM_MAX = 3
	};

	// Enum Engine.EDistributionVectorMirrorFlags
	public enum EDistributionVectorMirrorFlags : byte {
		EDVMF_Same = 0,
		EDVMF_Different = 1,
		EDVMF_Mirror = 2,
		EDVMF_MAX = 3
	};

	// Enum Engine.EDistributionVectorLockFlags
	public enum EDistributionVectorLockFlags : byte {
		EDVLF_None = 0,
		EDVLF_XY = 1,
		EDVLF_XZ = 2,
		EDVLF_YZ = 3,
		EDVLF_XYZ = 4,
		EDVLF_MAX = 5
	};

	// Enum Engine.ENodeEnabledState
	public enum ENodeEnabledState : byte {
		Enabled = 0,
		Disabled = 1,
		DevelopmentOnly = 2,
		ENodeEnabledState_MAX = 3
	};

	// Enum Engine.ENodeAdvancedPins
	public enum ENodeAdvancedPins : byte {
		NoPins = 0,
		Shown = 1,
		Hidden = 2,
		ENodeAdvancedPins_MAX = 3
	};

	// Enum Engine.ENodeTitleType
	public enum ENodeTitleType : byte {
		FullTitle = 0,
		ListView = 1,
		EditableTitle = 2,
		MenuTitle = 3,
		MAX_TitleTypes = 4,
		ENodeTitleType_MAX = 5
	};

	// Enum Engine.EPinContainerType
	public enum EPinContainerType : byte {
		None = 0,
		Array = 1,
		Set = 2,
		Map = 3,
		EPinContainerType_MAX = 4
	};

	// Enum Engine.EEdGraphPinDirection
	public enum EEdGraphPinDirection : byte {
		EGPD_Input = 0,
		EGPD_Output = 1,
		EGPD_MAX = 2
	};

	// Enum Engine.EBlueprintPinStyleType
	public enum EBlueprintPinStyleType : byte {
		BPST_Original = 0,
		BPST_VariantA = 1,
		BPST_MAX = 2
	};

	// Enum Engine.ECanCreateConnectionResponse
	public enum ECanCreateConnectionResponse : byte {
		CONNECT_RESPONSE_MAKE = 0,
		CONNECT_RESPONSE_DISALLOW = 1,
		CONNECT_RESPONSE_BREAK_OTHERS_A = 2,
		CONNECT_RESPONSE_BREAK_OTHERS_B = 3,
		CONNECT_RESPONSE_BREAK_OTHERS_AB = 4,
		CONNECT_RESPONSE_MAKE_WITH_CONVERSION_NODE = 5,
		CONNECT_RESPONSE_MAX = 6
	};

	// Enum Engine.EGraphType
	public enum EGraphType : byte {
		GT_Function = 0,
		GT_Ubergraph = 1,
		GT_Macro = 2,
		GT_Animation = 3,
		GT_StateMachine = 4,
		GT_MAX = 5
	};

	// Enum Engine.ETransitionType
	public enum ETransitionType : byte {
		None = 0,
		Paused = 1,
		Loading = 2,
		Saving = 3,
		Connecting = 4,
		Precaching = 5,
		WaitingToConnect = 6,
		MAX = 7
	};

	// Enum Engine.EFullyLoadPackageType
	public enum EFullyLoadPackageType : byte {
		FULLYLOAD_Map = 0,
		FULLYLOAD_Game_PreLoadClass = 1,
		FULLYLOAD_Game_PostLoadClass = 2,
		FULLYLOAD_Always = 3,
		FULLYLOAD_Mutator = 4,
		FULLYLOAD_MAX = 5
	};

	// Enum Engine.EViewModeIndex
	public enum EViewModeIndex : byte {
		VMI_BrushWireframe = 0,
		VMI_Wireframe = 1,
		VMI_Unlit = 2,
		VMI_Lit = 3,
		VMI_Lit_DetailLighting = 4,
		VMI_LightingOnly = 5,
		VMI_LightComplexity = 6,
		VMI_ShaderComplexity = 8,
		VMI_LightmapDensity = 9,
		VMI_LitLightmapDensity = 10,
		VMI_ReflectionOverride = 11,
		VMI_VisualizeBuffer = 12,
		VMI_StationaryLightOverlap = 14,
		VMI_CollisionPawn = 15,
		VMI_CollisionVisibility = 16,
		VMI_LODColoration = 18,
		VMI_QuadOverdraw = 19,
		VMI_PrimitiveDistanceAccuracy = 20,
		VMI_MeshUVDensityAccuracy = 21,
		VMI_ShaderComplexityWithQuadOverdraw = 22,
		VMI_HLODColoration = 23,
		VMI_GroupLODColoration = 24,
		VMI_MaterialTextureScaleAccuracy = 25,
		VMI_RequiredTextureResolution = 26,
		VMI_PathTracing = 27,
		VMI_RayTracingDebug = 28,
		VMI_Max = 29,
		VMI_Unknown = 255
	};

	// Enum Engine.EDemoPlayFailure
	public enum EDemoPlayFailure : byte {
		Generic = 0,
		DemoNotFound = 1,
		Corrupt = 2,
		InvalidVersion = 3,
		InitBase = 4,
		GameSpecificHeader = 5,
		ReplayStreamerInternal = 6,
		LoadMap = 7,
		Serialization = 8,
		EDemoPlayFailure_MAX = 9
	};

	// Enum Engine.ETravelType
	public enum ETravelType : byte {
		TRAVEL_Absolute = 0,
		TRAVEL_Partial = 1,
		TRAVEL_Relative = 2,
		TRAVEL_MAX = 3
	};

	// Enum Engine.ENetworkLagState
	public enum ENetworkLagState : byte {
		NotLagging = 0,
		Lagging = 1,
		ENetworkLagState_MAX = 2
	};

	// Enum Engine.EMouseCaptureMode
	public enum EMouseCaptureMode : byte {
		NoCapture = 0,
		CapturePermanently = 1,
		CapturePermanently_IncludingInitialMouseDown = 2,
		CaptureDuringMouseDown = 3,
		CaptureDuringRightMouseDown = 4,
		EMouseCaptureMode_MAX = 5
	};

	// Enum Engine.EInputEvent
	public enum EInputEvent : byte {
		IE_Pressed = 0,
		IE_Released = 1,
		IE_Repeat = 2,
		IE_DoubleClick = 3,
		IE_Axis = 4,
		IE_MAX = 5
	};

	// Enum Engine.ECustomTimeStepSynchronizationState
	public enum ECustomTimeStepSynchronizationState : byte {
		Closed = 0,
		Error = 1,
		Synchronized = 2,
		Synchronizing = 3,
		ECustomTimeStepSynchronizationState_MAX = 4
	};

	// Enum Engine.EMeshBufferAccess
	public enum EMeshBufferAccess : byte {
		Default = 0,
		ForceCPUAndGPU = 1,
		EMeshBufferAccess_MAX = 2
	};

	// Enum Engine.EConstraintFrame
	public enum EConstraintFrame : byte {
		Frame1 = 0,
		Frame2 = 1,
		EConstraintFrame_MAX = 2
	};

	// Enum Engine.EAngularConstraintMotion
	public enum EAngularConstraintMotion : byte {
		ACM_Free = 0,
		ACM_Limited = 1,
		ACM_Locked = 2,
		ACM_MAX = 3
	};

	// Enum Engine.EComponentSocketType
	public enum EComponentSocketType : byte {
		Invalid = 0,
		Bone = 1,
		Socket = 2,
		EComponentSocketType_MAX = 3
	};

	// Enum Engine.EPhysicalMaterialMaskColor
	public enum EPhysicalMaterialMaskColor : byte {
		Red = 0,
		Green = 1,
		Blue = 2,
		Cyan = 3,
		Magenta = 4,
		Yellow = 5,
		White = 6,
		Black = 7,
		MAX = 8
	};

	// Enum Engine.EWalkableSlopeBehavior
	public enum EWalkableSlopeBehavior : byte {
		WalkableSlope_Default = 0,
		WalkableSlope_Increase = 1,
		WalkableSlope_Decrease = 2,
		WalkableSlope_Unwalkable = 3,
		WalkableSlope_Max = 4
	};

	// Enum Engine.EUpdateRateShiftBucket
	public enum EUpdateRateShiftBucket : byte {
		ShiftBucket0 = 0,
		ShiftBucket1 = 1,
		ShiftBucket2 = 2,
		ShiftBucket3 = 3,
		ShiftBucket4 = 4,
		ShiftBucket5 = 5,
		ShiftBucketMax = 6,
		EUpdateRateShiftBucket_MAX = 7
	};

	// Enum Engine.EShadowMapFlags
	public enum EShadowMapFlags : byte {
		SMF_None = 0,
		SMF_Streamed = 1,
		SMF_MAX = 2
	};

	// Enum Engine.ELightMapPaddingType
	public enum ELightMapPaddingType : byte {
		LMPT_NormalPadding = 0,
		LMPT_PrePadding = 1,
		LMPT_NoPadding = 2,
		LMPT_MAX = 3
	};

	// Enum Engine.ECollisionEnabled
	public enum ECollisionEnabled : byte {
		NoCollision = 0,
		QueryOnly = 1,
		PhysicsOnly = 2,
		QueryAndPhysics = 3,
		ECollisionEnabled_MAX = 4
	};

	// Enum Engine.ETimelineSigType
	public enum ETimelineSigType : byte {
		ETS_EventSignature = 0,
		ETS_FloatSignature = 1,
		ETS_VectorSignature = 2,
		ETS_LinearColorSignature = 3,
		ETS_InvalidSignature = 4,
		ETS_MAX = 5
	};

	// Enum Engine.ESleepFamily
	public enum ESleepFamily : byte {
		Normal = 0,
		Sensitive = 1,
		Custom = 2,
		ESleepFamily_MAX = 3
	};

	// Enum Engine.ERadialImpulseFalloff
	public enum ERadialImpulseFalloff : byte {
		RIF_Constant = 0,
		RIF_Linear = 1,
		RIF_MAX = 2
	};

	// Enum Engine.EFilterInterpolationType
	public enum EFilterInterpolationType : byte {
		BSIT_Average = 0,
		BSIT_Linear = 1,
		BSIT_Cubic = 2,
		BSIT_MAX = 3
	};

	// Enum Engine.ECollisionResponse
	public enum ECollisionResponse : byte {
		ECR_Ignore = 0,
		ECR_Overlap = 1,
		ECR_Block = 2,
		ECR_MAX = 3
	};

	// Enum Engine.EOverlapFilterOption
	public enum EOverlapFilterOption : byte {
		OverlapFilter_All = 0,
		OverlapFilter_DynamicOnly = 1,
		OverlapFilter_StaticOnly = 2,
		OverlapFilter_MAX = 3
	};

	// Enum Engine.ECollisionChannel
	public enum ECollisionChannel : byte {
		ECC_WorldStatic = 0,
		ECC_WorldDynamic = 1,
		ECC_Pawn = 2,
		ECC_Visibility = 3,
		ECC_Camera = 4,
		ECC_PhysicsBody = 5,
		ECC_Vehicle = 6,
		ECC_Destructible = 7,
		ECC_EngineTraceChannel1 = 8,
		ECC_EngineTraceChannel2 = 9,
		ECC_EngineTraceChannel3 = 10,
		ECC_EngineTraceChannel4 = 11,
		ECC_EngineTraceChannel5 = 12,
		ECC_EngineTraceChannel6 = 13,
		ECC_GameTraceChannel1 = 14,
		ECC_GameTraceChannel2 = 15,
		ECC_GameTraceChannel3 = 16,
		ECC_GameTraceChannel4 = 17,
		ECC_GameTraceChannel5 = 18,
		ECC_GameTraceChannel6 = 19,
		ECC_GameTraceChannel7 = 20,
		ECC_GameTraceChannel8 = 21,
		ECC_GameTraceChannel9 = 22,
		ECC_GameTraceChannel10 = 23,
		ECC_GameTraceChannel11 = 24,
		ECC_GameTraceChannel12 = 25,
		ECC_GameTraceChannel13 = 26,
		ECC_GameTraceChannel14 = 27,
		ECC_GameTraceChannel15 = 28,
		ECC_GameTraceChannel16 = 29,
		ECC_GameTraceChannel17 = 30,
		ECC_GameTraceChannel18 = 31,
		ECC_OverlapAll_Deprecated = 32,
		ECC_MAX = 33
	};

	// Enum Engine.ENetworkSmoothingMode
	public enum ENetworkSmoothingMode : byte {
		Disabled = 0,
		Linear = 1,
		Exponential = 2,
		Replay = 3,
		ENetworkSmoothingMode_MAX = 4
	};

	// Enum Engine.ELightingBuildQuality
	public enum ELightingBuildQuality : byte {
		Quality_Preview = 0,
		Quality_Medium = 1,
		Quality_High = 2,
		Quality_Production = 3,
		Quality_MAX = 4
	};

	// Enum Engine.EMaterialStencilCompare
	public enum EMaterialStencilCompare : byte {
		MSC_Less = 0,
		MSC_LessEqual = 1,
		MSC_Greater = 2,
		MSC_GreaterEqual = 3,
		MSC_Equal = 4,
		MSC_NotEqual = 5,
		MSC_Never = 6,
		MSC_Always = 7,
		MSC_Count = 8,
		MSC_MAX = 9
	};

	// Enum Engine.EMaterialSamplerType
	public enum EMaterialSamplerType : byte {
		SAMPLERTYPE_Color = 0,
		SAMPLERTYPE_Grayscale = 1,
		SAMPLERTYPE_Alpha = 2,
		SAMPLERTYPE_Normal = 3,
		SAMPLERTYPE_Masks = 4,
		SAMPLERTYPE_DistanceFieldFont = 5,
		SAMPLERTYPE_LinearColor = 6,
		SAMPLERTYPE_LinearGrayscale = 7,
		SAMPLERTYPE_Data = 8,
		SAMPLERTYPE_External = 9,
		SAMPLERTYPE_VirtualColor = 10,
		SAMPLERTYPE_VirtualGrayscale = 11,
		SAMPLERTYPE_VirtualAlpha = 12,
		SAMPLERTYPE_VirtualNormal = 13,
		SAMPLERTYPE_VirtualMasks = 14,
		SAMPLERTYPE_VirtualLinearColor = 15,
		SAMPLERTYPE_VirtualLinearGrayscale = 16,
		SAMPLERTYPE_MAX = 17
	};

	// Enum Engine.EMaterialTessellationMode
	public enum EMaterialTessellationMode : byte {
		MTM_NoTessellation = 0,
		MTM_FlatTessellation = 1,
		MTM_PNTriangles = 2,
		MTM_MAX = 3
	};

	// Enum Engine.EMaterialShadingModel
	public enum EMaterialShadingModel : byte {
		MSM_Unlit = 0,
		MSM_DefaultLit = 1,
		MSM_Subsurface = 2,
		MSM_PreintegratedSkin = 3,
		MSM_ClearCoat = 4,
		MSM_SubsurfaceProfile = 5,
		MSM_TwoSidedFoliage = 6,
		MSM_Hair = 7,
		MSM_Cloth = 8,
		MSM_Eye = 9,
		MSM_SingleLayerWater = 10,
		MSM_ThinTranslucent = 11,
		MSM_NUM = 12,
		MSM_FromMaterialExpression = 13,
		MSM_MAX = 14
	};

	// Enum Engine.EParticleCollisionMode
	public enum EParticleCollisionMode : byte {
		SceneDepth = 0,
		DistanceField = 1,
		EParticleCollisionMode_MAX = 2
	};

	// Enum Engine.ETrailWidthMode
	public enum ETrailWidthMode : byte {
		ETrailWidthMode_FromCentre = 0,
		ETrailWidthMode_FromFirst = 1,
		ETrailWidthMode_FromSecond = 2,
		ETrailWidthMode_MAX = 3
	};

	// Enum Engine.EGBufferFormat
	public enum EGBufferFormat : byte {
		Force8BitsPerChannel = 0,
		Default = 1,
		HighPrecisionNormals = 3,
		Force16BitsPerChannel = 5,
		EGBufferFormat_MAX = 6
	};

	// Enum Engine.ESceneCaptureCompositeMode
	public enum ESceneCaptureCompositeMode : byte {
		SCCM_Overwrite = 0,
		SCCM_Additive = 1,
		SCCM_Composite = 2,
		SCCM_MAX = 3
	};

	// Enum Engine.ESceneCaptureSource
	public enum ESceneCaptureSource : byte {
		SCS_SceneColorHDR = 0,
		SCS_SceneColorHDRNoAlpha = 1,
		SCS_FinalColorLDR = 2,
		SCS_SceneColorSceneDepth = 3,
		SCS_SceneDepth = 4,
		SCS_DeviceDepth = 5,
		SCS_Normal = 6,
		SCS_BaseColor = 7,
		SCS_FinalColorHDR = 8,
		SCS_FinalToneCurveHDR = 9,
		SCS_MAX = 10
	};

	// Enum Engine.ETranslucentSortPolicy
	public enum ETranslucentSortPolicy : byte {
		SortByDistance = 0,
		SortByProjectedZ = 1,
		SortAlongAxis = 2,
		ETranslucentSortPolicy_MAX = 3
	};

	// Enum Engine.ERefractionMode
	public enum ERefractionMode : byte {
		RM_IndexOfRefraction = 0,
		RM_PixelNormalOffset = 1,
		RM_MAX = 2
	};

	// Enum Engine.ETranslucencyLightingMode
	public enum ETranslucencyLightingMode : byte {
		TLM_VolumetricNonDirectional = 0,
		TLM_VolumetricDirectional = 1,
		TLM_VolumetricPerVertexNonDirectional = 2,
		TLM_VolumetricPerVertexDirectional = 3,
		TLM_Surface = 4,
		TLM_SurfacePerPixelLighting = 5,
		TLM_MAX = 6
	};

	// Enum Engine.ESamplerSourceMode
	public enum ESamplerSourceMode : byte {
		SSM_FromTextureAsset = 0,
		SSM_Wrap_WorldGroupSettings = 1,
		SSM_Clamp_WorldGroupSettings = 2,
		SSM_MAX = 3
	};

	// Enum Engine.EBlendMode
	public enum EBlendMode : byte {
		BLEND_Opaque = 0,
		BLEND_Masked = 1,
		BLEND_Translucent = 2,
		BLEND_Additive = 3,
		BLEND_Modulate = 4,
		BLEND_AlphaComposite = 5,
		BLEND_AlphaHoldout = 6,
		BLEND_MAX = 7
	};

	// Enum Engine.EOcclusionCombineMode
	public enum EOcclusionCombineMode : byte {
		OCM_Minimum = 0,
		OCM_Multiply = 1,
		OCM_MAX = 2
	};

	// Enum Engine.ELightmapType
	public enum ELightmapType : byte {
		Default = 0,
		ForceSurface = 1,
		ForceVolumetric = 2,
		ELightmapType_MAX = 3
	};

	// Enum Engine.EIndirectLightingCacheQuality
	public enum EIndirectLightingCacheQuality : byte {
		ILCQ_Off = 0,
		ILCQ_Point = 1,
		ILCQ_Volume = 2,
		ILCQ_MAX = 3
	};

	// Enum Engine.ESceneDepthPriorityGroup
	public enum ESceneDepthPriorityGroup : byte {
		SDPG_World = 0,
		SDPG_Foreground = 1,
		SDPG_MAX = 2
	};

	// Enum Engine.EAspectRatioAxisConstraint
	public enum EAspectRatioAxisConstraint : byte {
		AspectRatio_MaintainYFOV = 0,
		AspectRatio_MaintainXFOV = 1,
		AspectRatio_MajorAxisFOV = 2,
		AspectRatio_MAX = 3
	};

	// Enum Engine.EFontCacheType
	public enum EFontCacheType : byte {
		Offline = 0,
		Runtime = 1,
		EFontCacheType_MAX = 2
	};

	// Enum Engine.EFontImportCharacterSet
	public enum EFontImportCharacterSet : byte {
		FontICS_Default = 0,
		FontICS_Ansi = 1,
		FontICS_Symbol = 2,
		FontICS_MAX = 3
	};

	// Enum Engine.EStandbyType
	public enum EStandbyType : byte {
		STDBY_Rx = 0,
		STDBY_Tx = 1,
		STDBY_BadPing = 2,
		STDBY_MAX = 3
	};

	// Enum Engine.ESuggestProjVelocityTraceOption
	public enum ESuggestProjVelocityTraceOption : byte {
		DoNotTrace = 0,
		TraceFullPath = 1,
		OnlyTraceWhileAscending = 2,
		ESuggestProjVelocityTraceOption_MAX = 3
	};

	// Enum Engine.EWindowMode
	public enum EWindowMode : byte {
		Fullscreen = 0,
		WindowedFullscreen = 1,
		Windowed = 2,
		EWindowMode_MAX = 3
	};

	// Enum Engine.EHitProxyPriority
	public enum EHitProxyPriority : byte {
		HPP_World = 0,
		HPP_Wireframe = 1,
		HPP_Foreground = 2,
		HPP_UI = 3,
		HPP_MAX = 4
	};

	// Enum Engine.EImportanceWeight
	public enum EImportanceWeight : byte {
		Luminance = 0,
		Red = 1,
		Green = 2,
		Blue = 3,
		Alpha = 4,
		EImportanceWeight_MAX = 5
	};

	// Enum Engine.EAdManagerDelegate
	public enum EAdManagerDelegate : byte {
		AMD_ClickedBanner = 0,
		AMD_UserClosedAd = 1,
		AMD_MAX = 2
	};

	// Enum Engine.EControllerAnalogStick
	public enum EControllerAnalogStick : byte {
		CAS_LeftStick = 0,
		CAS_RightStick = 1,
		CAS_MAX = 2
	};

	// Enum Engine.EAnimAlphaInputType
	public enum EAnimAlphaInputType : byte {
		Float = 0,
		Bool = 1,
		Curve = 2,
		EAnimAlphaInputType_MAX = 3
	};

	// Enum Engine.ETrackActiveCondition
	public enum ETrackActiveCondition : byte {
		ETAC_Always = 0,
		ETAC_GoreEnabled = 1,
		ETAC_GoreDisabled = 2,
		ETAC_MAX = 3
	};

	// Enum Engine.EInterpTrackMoveRotMode
	public enum EInterpTrackMoveRotMode : byte {
		IMR_Keyframed = 0,
		IMR_LookAtGroup = 1,
		IMR_Ignore = 2,
		IMR_MAX = 3
	};

	// Enum Engine.EInterpMoveAxis
	public enum EInterpMoveAxis : byte {
		AXIS_TranslationX = 0,
		AXIS_TranslationY = 1,
		AXIS_TranslationZ = 2,
		AXIS_RotationX = 3,
		AXIS_RotationY = 4,
		AXIS_RotationZ = 5,
		AXIS_MAX = 6
	};

	// Enum Engine.ETrackToggleAction
	public enum ETrackToggleAction : byte {
		ETTA_Off = 0,
		ETTA_On = 1,
		ETTA_Toggle = 2,
		ETTA_Trigger = 3,
		ETTA_MAX = 4
	};

	// Enum Engine.EVisibilityTrackCondition
	public enum EVisibilityTrackCondition : byte {
		EVTC_Always = 0,
		EVTC_GoreEnabled = 1,
		EVTC_GoreDisabled = 2,
		EVTC_MAX = 3
	};

	// Enum Engine.EVisibilityTrackAction
	public enum EVisibilityTrackAction : byte {
		EVTA_Hide = 0,
		EVTA_Show = 1,
		EVTA_Toggle = 2,
		EVTA_MAX = 3
	};

	// Enum Engine.ESlateGesture
	public enum ESlateGesture : byte {
		None = 0,
		Scroll = 1,
		Magnify = 2,
		Swipe = 3,
		Rotate = 4,
		LongPress = 5,
		ESlateGesture_MAX = 6
	};

	// Enum Engine.EMatrixColumns
	public enum EMatrixColumns : byte {
		First = 0,
		Second = 1,
		Third = 2,
		Fourth = 3,
		EMatrixColumns_MAX = 4
	};

	// Enum Engine.ELerpInterpolationMode
	public enum ELerpInterpolationMode : byte {
		QuatInterp = 0,
		EulerInterp = 1,
		DualQuatInterp = 2,
		ELerpInterpolationMode_MAX = 3
	};

	// Enum Engine.EEasingFunc
	public enum EEasingFunc : byte {
		Linear = 0,
		Step = 1,
		SinusoidalIn = 2,
		SinusoidalOut = 3,
		SinusoidalInOut = 4,
		EaseIn = 5,
		EaseOut = 6,
		EaseInOut = 7,
		ExpoIn = 8,
		ExpoOut = 9,
		ExpoInOut = 10,
		CircularIn = 11,
		CircularOut = 12,
		CircularInOut = 13,
		EEasingFunc_MAX = 14
	};

	// Enum Engine.ERoundingMode
	public enum ERoundingMode : byte {
		HalfToEven = 0,
		HalfFromZero = 1,
		HalfToZero = 2,
		FromZero = 3,
		ToZero = 4,
		ToNegativeInfinity = 5,
		ToPositiveInfinity = 6,
		ERoundingMode_MAX = 7
	};

	// Enum Engine.EStreamingVolumeUsage
	public enum EStreamingVolumeUsage : byte {
		SVB_Loading = 0,
		SVB_LoadingAndVisibility = 1,
		SVB_VisibilityBlockingOnLoad = 2,
		SVB_BlockingOnLoad = 3,
		SVB_LoadingNotVisible = 4,
		SVB_MAX = 5
	};

	// Enum Engine.EMaterialDecalResponse
	public enum EMaterialDecalResponse : byte {
		MDR_None = 0,
		MDR_ColorNormalRoughness = 1,
		MDR_Color = 2,
		MDR_ColorNormal = 3,
		MDR_ColorRoughness = 4,
		MDR_Normal = 5,
		MDR_NormalRoughness = 6,
		MDR_Roughness = 7,
		MDR_MAX = 8
	};

	// Enum Engine.EDecalBlendMode
	public enum EDecalBlendMode : byte {
		DBM_Translucent = 0,
		DBM_Stain = 1,
		DBM_Normal = 2,
		DBM_Emissive = 3,
		DBM_DBuffer_ColorNormalRoughness = 4,
		DBM_DBuffer_Color = 5,
		DBM_DBuffer_ColorNormal = 6,
		DBM_DBuffer_ColorRoughness = 7,
		DBM_DBuffer_Normal = 8,
		DBM_DBuffer_NormalRoughness = 9,
		DBM_DBuffer_Roughness = 10,
		DBM_DBuffer_Emissive = 11,
		DBM_DBuffer_AlphaComposite = 12,
		DBM_DBuffer_EmissiveAlphaComposite = 13,
		DBM_Volumetric_DistanceFunction = 14,
		DBM_AlphaComposite = 15,
		DBM_AmbientOcclusion = 16,
		DBM_MAX = 17
	};

	// Enum Engine.ETextureColorChannel
	public enum ETextureColorChannel : byte {
		TCC_Red = 0,
		TCC_Green = 1,
		TCC_Blue = 2,
		TCC_Alpha = 3,
		TCC_MAX = 4
	};

	// Enum Engine.EMaterialAttributeBlend
	public enum EMaterialAttributeBlend : byte {
		Blend = 0,
		UseA = 1,
		UseB = 2,
		EMaterialAttributeBlend_MAX = 3
	};

	// Enum Engine.EChannelMaskParameterColor
	public enum EChannelMaskParameterColor : byte {
		Red = 0,
		Green = 1,
		Blue = 2,
		Alpha = 3,
		EChannelMaskParameterColor_MAX = 4
	};

	// Enum Engine.EClampMode
	public enum EClampMode : byte {
		CMODE_Clamp = 0,
		CMODE_ClampMin = 1,
		CMODE_ClampMax = 2,
		CMODE_MAX = 3
	};

	// Enum Engine.ECustomMaterialOutputType
	public enum ECustomMaterialOutputType : byte {
		CMOT_Float1 = 0,
		CMOT_Float2 = 1,
		CMOT_Float3 = 2,
		CMOT_Float4 = 3,
		CMOT_MAX = 4
	};

	// Enum Engine.EDepthOfFieldFunctionValue
	public enum EDepthOfFieldFunctionValue : byte {
		TDOF_NearAndFarMask = 0,
		TDOF_NearMask = 1,
		TDOF_FarMask = 2,
		TDOF_CircleOfConfusionRadius = 3,
		TDOF_MAX = 4
	};

	// Enum Engine.EFunctionInputType
	public enum EFunctionInputType : byte {
		FunctionInput_Scalar = 0,
		FunctionInput_Vector2 = 1,
		FunctionInput_Vector3 = 2,
		FunctionInput_Vector4 = 3,
		FunctionInput_Texture2D = 4,
		FunctionInput_TextureCube = 5,
		FunctionInput_Texture2DArray = 6,
		FunctionInput_VolumeTexture = 7,
		FunctionInput_StaticBool = 8,
		FunctionInput_MaterialAttributes = 9,
		FunctionInput_TextureExternal = 10,
		FunctionInput_MAX = 11
	};

	// Enum Engine.ENoiseFunction
	public enum ENoiseFunction : byte {
		NOISEFUNCTION_SimplexTex = 0,
		NOISEFUNCTION_GradientTex = 1,
		NOISEFUNCTION_GradientTex3D = 2,
		NOISEFUNCTION_GradientALU = 3,
		NOISEFUNCTION_ValueALU = 4,
		NOISEFUNCTION_VoronoiALU = 5,
		NOISEFUNCTION_MAX = 6
	};

	// Enum Engine.ERuntimeVirtualTextureMipValueMode
	public enum ERuntimeVirtualTextureMipValueMode : byte {
		RVTMVM_None = 0,
		RVTMVM_MipLevel = 1,
		RVTMVM_MipBias = 2,
		RVTMVM_MAX = 3
	};

	// Enum Engine.EMaterialSceneAttributeInputMode
	public enum EMaterialSceneAttributeInputMode : byte {
		Coordinates = 0,
		OffsetFraction = 1,
		EMaterialSceneAttributeInputMode_MAX = 2
	};

	// Enum Engine.ESpeedTreeLODType
	public enum ESpeedTreeLODType : byte {
		STLOD_Pop = 0,
		STLOD_Smooth = 1,
		STLOD_MAX = 2
	};

	// Enum Engine.ESpeedTreeWindType
	public enum ESpeedTreeWindType : byte {
		STW_None = 0,
		STW_Fastest = 1,
		STW_Fast = 2,
		STW_Better = 3,
		STW_Best = 4,
		STW_Palm = 5,
		STW_BestPlus = 6,
		STW_MAX = 7
	};

	// Enum Engine.ESpeedTreeGeometryType
	public enum ESpeedTreeGeometryType : byte {
		STG_Branch = 0,
		STG_Frond = 1,
		STG_Leaf = 2,
		STG_FacingLeaf = 3,
		STG_Billboard = 4,
		STG_MAX = 5
	};

	// Enum Engine.EMaterialExposedTextureProperty
	public enum EMaterialExposedTextureProperty : byte {
		TMTM_TextureSize = 0,
		TMTM_TexelSize = 1,
		TMTM_MAX = 2
	};

	// Enum Engine.ETextureMipValueMode
	public enum ETextureMipValueMode : byte {
		TMVM_None = 0,
		TMVM_MipLevel = 1,
		TMVM_MipBias = 2,
		TMVM_Derivative = 3,
		TMVM_MAX = 4
	};

	// Enum Engine.EMaterialVectorCoordTransform
	public enum EMaterialVectorCoordTransform : byte {
		TRANSFORM_Tangent = 0,
		TRANSFORM_Local = 1,
		TRANSFORM_World = 2,
		TRANSFORM_View = 3,
		TRANSFORM_Camera = 4,
		TRANSFORM_ParticleWorld = 5,
		TRANSFORM_MAX = 6
	};

	// Enum Engine.EMaterialVectorCoordTransformSource
	public enum EMaterialVectorCoordTransformSource : byte {
		TRANSFORMSOURCE_Tangent = 0,
		TRANSFORMSOURCE_Local = 1,
		TRANSFORMSOURCE_World = 2,
		TRANSFORMSOURCE_View = 3,
		TRANSFORMSOURCE_Camera = 4,
		TRANSFORMSOURCE_ParticleWorld = 5,
		TRANSFORMSOURCE_MAX = 6
	};

	// Enum Engine.EMaterialPositionTransformSource
	public enum EMaterialPositionTransformSource : byte {
		TRANSFORMPOSSOURCE_Local = 0,
		TRANSFORMPOSSOURCE_World = 1,
		TRANSFORMPOSSOURCE_TranslatedWorld = 2,
		TRANSFORMPOSSOURCE_View = 3,
		TRANSFORMPOSSOURCE_Camera = 4,
		TRANSFORMPOSSOURCE_Particle = 5,
		TRANSFORMPOSSOURCE_MAX = 6
	};

	// Enum Engine.EVectorNoiseFunction
	public enum EVectorNoiseFunction : byte {
		VNF_CellnoiseALU = 0,
		VNF_VectorALU = 1,
		VNF_GradientALU = 2,
		VNF_CurlALU = 3,
		VNF_VoronoiALU = 4,
		VNF_MAX = 5
	};

	// Enum Engine.EMaterialExposedViewProperty
	public enum EMaterialExposedViewProperty : byte {
		MEVP_BufferSize = 0,
		MEVP_FieldOfView = 1,
		MEVP_TanHalfFieldOfView = 2,
		MEVP_ViewSize = 3,
		MEVP_WorldSpaceViewPosition = 4,
		MEVP_WorldSpaceCameraPosition = 5,
		MEVP_ViewportOffset = 6,
		MEVP_TemporalSampleCount = 7,
		MEVP_TemporalSampleIndex = 8,
		MEVP_TemporalSampleOffset = 9,
		MEVP_RuntimeVirtualTextureOutputLevel = 10,
		MEVP_RuntimeVirtualTextureOutputDerivative = 11,
		MEVP_PreExposure = 12,
		MEVP_MAX = 13
	};

	// Enum Engine.EWorldPositionIncludedOffsets
	public enum EWorldPositionIncludedOffsets : byte {
		WPT_Default = 0,
		WPT_ExcludeAllShaderOffsets = 1,
		WPT_CameraRelative = 2,
		WPT_CameraRelativeNoOffsets = 3,
		WPT_MAX = 4
	};

	// Enum Engine.EMaterialFunctionUsage
	public enum EMaterialFunctionUsage : byte {
		Default = 0,
		MaterialLayer = 1,
		MaterialLayerBlend = 2,
		EMaterialFunctionUsage_MAX = 3
	};

	// Enum Engine.EMaterialUsage
	public enum EMaterialUsage : byte {
		MATUSAGE_SkeletalMesh = 0,
		MATUSAGE_ParticleSprites = 1,
		MATUSAGE_BeamTrails = 2,
		MATUSAGE_MeshParticles = 3,
		MATUSAGE_StaticLighting = 4,
		MATUSAGE_MorphTargets = 5,
		MATUSAGE_SplineMesh = 6,
		MATUSAGE_InstancedStaticMeshes = 7,
		MATUSAGE_GeometryCollections = 8,
		MATUSAGE_Clothing = 9,
		MATUSAGE_NiagaraSprites = 10,
		MATUSAGE_NiagaraRibbons = 11,
		MATUSAGE_NiagaraMeshParticles = 12,
		MATUSAGE_GeometryCache = 13,
		MATUSAGE_Water = 14,
		MATUSAGE_HairStrands = 15,
		MATUSAGE_LidarPointCloud = 16,
		MATUSAGE_MAX = 17
	};

	// Enum Engine.EMaterialParameterAssociation
	public enum EMaterialParameterAssociation : byte {
		LayerParameter = 0,
		BlendParameter = 1,
		GlobalParameter = 2,
		EMaterialParameterAssociation_MAX = 3
	};

	// Enum Engine.EMaterialMergeType
	public enum EMaterialMergeType : byte {
		MaterialMergeType_Default = 0,
		MaterialMergeType_Simplygon = 1,
		MaterialMergeType_MAX = 2
	};

	// Enum Engine.ETextureSizingType
	public enum ETextureSizingType : byte {
		TextureSizingType_UseSingleTextureSize = 0,
		TextureSizingType_UseAutomaticBiasedSizes = 1,
		TextureSizingType_UseManualOverrideTextureSize = 2,
		TextureSizingType_UseSimplygonAutomaticSizing = 3,
		TextureSizingType_MAX = 4
	};

	// Enum Engine.ESceneTextureId
	public enum ESceneTextureId : byte {
		PPI_SceneColor = 0,
		PPI_SceneDepth = 1,
		PPI_DiffuseColor = 2,
		PPI_SpecularColor = 3,
		PPI_SubsurfaceColor = 4,
		PPI_BaseColor = 5,
		PPI_Specular = 6,
		PPI_Metallic = 7,
		PPI_WorldNormal = 8,
		PPI_SeparateTranslucency = 9,
		PPI_Opacity = 10,
		PPI_Roughness = 11,
		PPI_MaterialAO = 12,
		PPI_CustomDepth = 13,
		PPI_PostProcessInput0 = 14,
		PPI_PostProcessInput1 = 15,
		PPI_PostProcessInput2 = 16,
		PPI_PostProcessInput3 = 17,
		PPI_PostProcessInput4 = 18,
		PPI_PostProcessInput5 = 19,
		PPI_PostProcessInput6 = 20,
		PPI_DecalMask = 21,
		PPI_ShadingModelColor = 22,
		PPI_ShadingModelID = 23,
		PPI_AmbientOcclusion = 24,
		PPI_CustomStencil = 25,
		PPI_StoredBaseColor = 26,
		PPI_StoredSpecular = 27,
		PPI_Velocity = 28,
		PPI_WorldTangent = 29,
		PPI_Anisotropy = 30,
		PPI_MAX = 31
	};

	// Enum Engine.EMaterialDomain
	public enum EMaterialDomain : byte {
		MD_Surface = 0,
		MD_DeferredDecal = 1,
		MD_LightFunction = 2,
		MD_Volume = 3,
		MD_PostProcess = 4,
		MD_UI = 5,
		MD_RuntimeVirtualTexture = 6,
		MD_MAX = 7
	};

	// Enum Engine.EMeshInstancingReplacementMethod
	public enum EMeshInstancingReplacementMethod : byte {
		RemoveOriginalActors = 0,
		KeepOriginalActorsAsEditorOnly = 1,
		EMeshInstancingReplacementMethod_MAX = 2
	};

	// Enum Engine.EUVOutput
	public enum EUVOutput : byte {
		DoNotOutputChannel = 0,
		OutputChannel = 1,
		EUVOutput_MAX = 2
	};

	// Enum Engine.EMeshMergeType
	public enum EMeshMergeType : byte {
		MeshMergeType_Default = 0,
		MeshMergeType_MergeActor = 1,
		MeshMergeType_MAX = 2
	};

	// Enum Engine.EMeshLODSelectionType
	public enum EMeshLODSelectionType : byte {
		AllLODs = 0,
		SpecificLOD = 1,
		CalculateLOD = 2,
		LowestDetailLOD = 3,
		EMeshLODSelectionType_MAX = 4
	};

	// Enum Engine.EProxyNormalComputationMethod
	public enum EProxyNormalComputationMethod : byte {
		AngleWeighted = 0,
		AreaWeighted = 1,
		EqualWeighted = 2,
		EProxyNormalComputationMethod_MAX = 3
	};

	// Enum Engine.ELandscapeCullingPrecision
	public enum ELandscapeCullingPrecision : byte {
		High = 0,
		Medium = 1,
		Low = 2,
		ELandscapeCullingPrecision_MAX = 3
	};

	// Enum Engine.EStaticMeshReductionTerimationCriterion
	public enum EStaticMeshReductionTerimationCriterion : byte {
		Triangles = 0,
		Vertices = 1,
		Any = 2,
		EStaticMeshReductionTerimationCriterion_MAX = 3
	};

	// Enum Engine.EMeshFeatureImportance
	public enum EMeshFeatureImportance : byte {
		Off = 0,
		Lowest = 1,
		Low = 2,
		Normal = 3,
		High = 4,
		Highest = 5,
		EMeshFeatureImportance_MAX = 6
	};

	// Enum Engine.EVertexPaintAxis
	public enum EVertexPaintAxis : byte {
		X = 0,
		Y = 1,
		Z = 2,
		EVertexPaintAxis_MAX = 3
	};

	// Enum Engine.EMicroTransactionResult
	public enum EMicroTransactionResult : byte {
		MTR_Succeeded = 0,
		MTR_Failed = 1,
		MTR_Canceled = 2,
		MTR_RestoredFromServer = 3,
		MTR_MAX = 4
	};

	// Enum Engine.EMicroTransactionDelegate
	public enum EMicroTransactionDelegate : byte {
		MTD_PurchaseQueryComplete = 0,
		MTD_PurchaseComplete = 1,
		MTD_MAX = 2
	};

	// Enum Engine.FNavigationSystemRunMode
	public enum FNavigationSystemRunMode : byte {
		InvalidMode = 0,
		GameMode = 1,
		EditorMode = 2,
		SimulationMode = 3,
		PIEMode = 4,
		FNavigationSystemRunMode_MAX = 5
	};

	// Enum Engine.ENavigationQueryResult
	public enum ENavigationQueryResult : byte {
		Invalid = 0,
		Error = 1,
		Fail = 2,
		Success = 3,
		ENavigationQueryResult_MAX = 4
	};

	// Enum Engine.ENavPathEvent
	public enum ENavPathEvent : byte {
		Cleared = 0,
		NewPath = 1,
		UpdatedDueToGoalMoved = 2,
		UpdatedDueToNavigationChanged = 3,
		Invalidated = 4,
		RePathFailed = 5,
		MetaPathUpdate = 6,
		Custom = 7,
		ENavPathEvent_MAX = 8
	};

	// Enum Engine.ENavDataGatheringModeConfig
	public enum ENavDataGatheringModeConfig : byte {
		Invalid = 0,
		Instant = 1,
		Lazy = 2,
		ENavDataGatheringModeConfig_MAX = 3
	};

	// Enum Engine.ENavDataGatheringMode
	public enum ENavDataGatheringMode : byte {
		Default = 0,
		Instant = 1,
		Lazy = 2,
		ENavDataGatheringMode_MAX = 3
	};

	// Enum Engine.ENavigationOptionFlag
	public enum ENavigationOptionFlag : byte {
		Default = 0,
		Enable = 1,
		Disable = 2,
		MAX = 3
	};

	// Enum Engine.ENavLinkDirection
	public enum ENavLinkDirection : byte {
		BothWays = 0,
		LeftToRight = 1,
		RightToLeft = 2,
		ENavLinkDirection_MAX = 3
	};

	// Enum Engine.EFastArraySerializerDeltaFlags
	public enum EFastArraySerializerDeltaFlags : byte {
		None = 0,
		HasBeenSerialized = 1,
		HasDeltaBeenRequested = 2,
		IsUsingDeltaSerialization = 4,
		EFastArraySerializerDeltaFlags_MAX = 5
	};

	// Enum Engine.EEmitterRenderMode
	public enum EEmitterRenderMode : byte {
		ERM_Normal = 0,
		ERM_Point = 1,
		ERM_Cross = 2,
		ERM_LightsOnly = 3,
		ERM_None = 4,
		ERM_MAX = 5
	};

	// Enum Engine.EParticleSubUVInterpMethod
	public enum EParticleSubUVInterpMethod : byte {
		PSUVIM_None = 0,
		PSUVIM_Linear = 1,
		PSUVIM_Linear_Blend = 2,
		PSUVIM_Random = 3,
		PSUVIM_Random_Blend = 4,
		PSUVIM_MAX = 5
	};

	// Enum Engine.EParticleBurstMethod
	public enum EParticleBurstMethod : byte {
		EPBM_Instant = 0,
		EPBM_Interpolated = 1,
		EPBM_MAX = 2
	};

	// Enum Engine.EParticleSystemInsignificanceReaction
	public enum EParticleSystemInsignificanceReaction : byte {
		Auto = 0,
		Complete = 1,
		DisableTick = 2,
		DisableTickAndKill = 3,
		Num = 4,
		EParticleSystemInsignificanceReaction_MAX = 5
	};

	// Enum Engine.EParticleSignificanceLevel
	public enum EParticleSignificanceLevel : byte {
		Low = 0,
		Medium = 1,
		High = 2,
		Critical = 3,
		Num = 4,
		EParticleSignificanceLevel_MAX = 5
	};

	// Enum Engine.EParticleDetailMode
	public enum EParticleDetailMode : byte {
		PDM_Low = 0,
		PDM_Medium = 1,
		PDM_High = 2,
		PDM_MAX = 3
	};

	// Enum Engine.EParticleSourceSelectionMethod
	public enum EParticleSourceSelectionMethod : byte {
		EPSSM_Random = 0,
		EPSSM_Sequential = 1,
		EPSSM_MAX = 2
	};

	// Enum Engine.EModuleType
	public enum EModuleType : byte {
		EPMT_General = 0,
		EPMT_TypeData = 1,
		EPMT_Beam = 2,
		EPMT_Trail = 3,
		EPMT_Spawn = 4,
		EPMT_Required = 5,
		EPMT_Event = 6,
		EPMT_Light = 7,
		EPMT_SubUV = 8,
		EPMT_MAX = 9
	};

	// Enum Engine.EAttractorParticleSelectionMethod
	public enum EAttractorParticleSelectionMethod : byte {
		EAPSM_Random = 0,
		EAPSM_Sequential = 1,
		EAPSM_MAX = 2
	};

	// Enum Engine.Beam2SourceTargetTangentMethod
	public enum Beam2SourceTargetTangentMethod : byte {
		PEB2STTM_Direct = 0,
		PEB2STTM_UserSet = 1,
		PEB2STTM_Distribution = 2,
		PEB2STTM_Emitter = 3,
		PEB2STTM_MAX = 4
	};

	// Enum Engine.Beam2SourceTargetMethod
	public enum Beam2SourceTargetMethod : byte {
		PEB2STM_Default = 0,
		PEB2STM_UserSet = 1,
		PEB2STM_Emitter = 2,
		PEB2STM_Particle = 3,
		PEB2STM_Actor = 4,
		PEB2STM_MAX = 5
	};

	// Enum Engine.BeamModifierType
	public enum BeamModifierType : byte {
		PEB2MT_Source = 0,
		PEB2MT_Target = 1,
		PEB2MT_MAX = 2
	};

	// Enum Engine.EParticleCameraOffsetUpdateMethod
	public enum EParticleCameraOffsetUpdateMethod : byte {
		EPCOUM_DirectSet = 0,
		EPCOUM_Additive = 1,
		EPCOUM_Scalar = 2,
		EPCOUM_MAX = 3
	};

	// Enum Engine.EParticleCollisionComplete
	public enum EParticleCollisionComplete : byte {
		EPCC_Kill = 0,
		EPCC_Freeze = 1,
		EPCC_HaltCollisions = 2,
		EPCC_FreezeTranslation = 3,
		EPCC_FreezeRotation = 4,
		EPCC_FreezeMovement = 5,
		EPCC_MAX = 6
	};

	// Enum Engine.EParticleCollisionResponse
	public enum EParticleCollisionResponse : byte {
		Bounce = 0,
		Stop = 1,
		Kill = 2,
		EParticleCollisionResponse_MAX = 3
	};

	// Enum Engine.ELocationBoneSocketSelectionMethod
	public enum ELocationBoneSocketSelectionMethod : byte {
		BONESOCKETSEL_Sequential = 0,
		BONESOCKETSEL_Random = 1,
		BONESOCKETSEL_MAX = 2
	};

	// Enum Engine.ELocationBoneSocketSource
	public enum ELocationBoneSocketSource : byte {
		BONESOCKETSOURCE_Bones = 0,
		BONESOCKETSOURCE_Sockets = 1,
		BONESOCKETSOURCE_MAX = 2
	};

	// Enum Engine.ELocationEmitterSelectionMethod
	public enum ELocationEmitterSelectionMethod : byte {
		ELESM_Random = 0,
		ELESM_Sequential = 1,
		ELESM_MAX = 2
	};

	// Enum Engine.CylinderHeightAxis
	public enum CylinderHeightAxis : byte {
		PMLPC_HEIGHTAXIS_X = 0,
		PMLPC_HEIGHTAXIS_Y = 1,
		PMLPC_HEIGHTAXIS_Z = 2,
		PMLPC_HEIGHTAXIS_MAX = 3
	};

	// Enum Engine.ELocationSkelVertSurfaceSource
	public enum ELocationSkelVertSurfaceSource : byte {
		VERTSURFACESOURCE_Vert = 0,
		VERTSURFACESOURCE_Surface = 1,
		VERTSURFACESOURCE_MAX = 2
	};

	// Enum Engine.EOrbitChainMode
	public enum EOrbitChainMode : byte {
		EOChainMode_Add = 0,
		EOChainMode_Scale = 1,
		EOChainMode_Link = 2,
		EOChainMode_MAX = 3
	};

	// Enum Engine.EParticleAxisLock
	public enum EParticleAxisLock : byte {
		EPAL_NONE = 0,
		EPAL_X = 1,
		EPAL_Y = 2,
		EPAL_Z = 3,
		EPAL_NEGATIVE_X = 4,
		EPAL_NEGATIVE_Y = 5,
		EPAL_NEGATIVE_Z = 6,
		EPAL_ROTATE_X = 7,
		EPAL_ROTATE_Y = 8,
		EPAL_ROTATE_Z = 9,
		EPAL_MAX = 10
	};

	// Enum Engine.EEmitterDynamicParameterValue
	public enum EEmitterDynamicParameterValue : byte {
		EDPV_UserSet = 0,
		EDPV_AutoSet = 1,
		EDPV_VelocityX = 2,
		EDPV_VelocityY = 3,
		EDPV_VelocityZ = 4,
		EDPV_VelocityMag = 5,
		EDPV_MAX = 6
	};

	// Enum Engine.EEmitterNormalsMode
	public enum EEmitterNormalsMode : byte {
		ENM_CameraFacing = 0,
		ENM_Spherical = 1,
		ENM_Cylindrical = 2,
		ENM_MAX = 3
	};

	// Enum Engine.EParticleSortMode
	public enum EParticleSortMode : byte {
		PSORTMODE_None = 0,
		PSORTMODE_ViewProjDepth = 1,
		PSORTMODE_DistanceToView = 2,
		PSORTMODE_Age_OldestFirst = 3,
		PSORTMODE_Age_NewestFirst = 4,
		PSORTMODE_MAX = 5
	};

	// Enum Engine.EParticleUVFlipMode
	public enum EParticleUVFlipMode : byte {
		None = 0,
		FlipUV = 1,
		FlipUOnly = 2,
		FlipVOnly = 3,
		RandomFlipUV = 4,
		RandomFlipUOnly = 5,
		RandomFlipVOnly = 6,
		RandomFlipUVIndependent = 7,
		EParticleUVFlipMode_MAX = 8
	};

	// Enum Engine.ETrail2SourceMethod
	public enum ETrail2SourceMethod : byte {
		PET2SRCM_Default = 0,
		PET2SRCM_Particle = 1,
		PET2SRCM_Actor = 2,
		PET2SRCM_MAX = 3
	};

	// Enum Engine.EBeamTaperMethod
	public enum EBeamTaperMethod : byte {
		PEBTM_None = 0,
		PEBTM_Full = 1,
		PEBTM_Partial = 2,
		PEBTM_MAX = 3
	};

	// Enum Engine.EBeam2Method
	public enum EBeam2Method : byte {
		PEB2M_Distance = 0,
		PEB2M_Target = 1,
		PEB2M_Branch = 2,
		PEB2M_MAX = 3
	};

	// Enum Engine.EMeshCameraFacingOptions
	public enum EMeshCameraFacingOptions : byte {
		XAxisFacing_NoUp = 0,
		XAxisFacing_ZUp = 1,
		XAxisFacing_NegativeZUp = 2,
		XAxisFacing_YUp = 3,
		XAxisFacing_NegativeYUp = 4,
		LockedAxis_ZAxisFacing = 5,
		LockedAxis_NegativeZAxisFacing = 6,
		LockedAxis_YAxisFacing = 7,
		LockedAxis_NegativeYAxisFacing = 8,
		VelocityAligned_ZAxisFacing = 9,
		VelocityAligned_NegativeZAxisFacing = 10,
		VelocityAligned_YAxisFacing = 11,
		VelocityAligned_NegativeYAxisFacing = 12,
		EMeshCameraFacingOptions_MAX = 13
	};

	// Enum Engine.EMeshCameraFacingUpAxis
	public enum EMeshCameraFacingUpAxis : byte {
		CameraFacing_NoneUP = 0,
		CameraFacing_ZUp = 1,
		CameraFacing_NegativeZUp = 2,
		CameraFacing_YUp = 3,
		CameraFacing_NegativeYUp = 4,
		CameraFacing_MAX = 5
	};

	// Enum Engine.EMeshScreenAlignment
	public enum EMeshScreenAlignment : byte {
		PSMA_MeshFaceCameraWithRoll = 0,
		PSMA_MeshFaceCameraWithSpin = 1,
		PSMA_MeshFaceCameraWithLockedAxis = 2,
		PSMA_MAX = 3
	};

	// Enum Engine.ETrailsRenderAxisOption
	public enum ETrailsRenderAxisOption : byte {
		Trails_CameraUp = 0,
		Trails_SourceUp = 1,
		Trails_WorldUp = 2,
		Trails_MAX = 3
	};

	// Enum Engine.EParticleScreenAlignment
	public enum EParticleScreenAlignment : byte {
		PSA_FacingCameraPosition = 0,
		PSA_Square = 1,
		PSA_Rectangle = 2,
		PSA_Velocity = 3,
		PSA_AwayFromCenter = 4,
		PSA_TypeSpecific = 5,
		PSA_FacingCameraDistanceBlend = 6,
		PSA_MAX = 7
	};

	// Enum Engine.EParticleSystemOcclusionBoundsMethod
	public enum EParticleSystemOcclusionBoundsMethod : byte {
		EPSOBM_None = 0,
		EPSOBM_ParticleBounds = 1,
		EPSOBM_CustomBounds = 2,
		EPSOBM_MAX = 3
	};

	// Enum Engine.ParticleSystemLODMethod
	public enum ParticleSystemLODMethod : byte {
		PARTICLESYSTEMLODMETHOD_Automatic = 0,
		PARTICLESYSTEMLODMETHOD_DirectSet = 1,
		PARTICLESYSTEMLODMETHOD_ActivateAutomatic = 2,
		PARTICLESYSTEMLODMETHOD_MAX = 3
	};

	// Enum Engine.EParticleSystemUpdateMode
	public enum EParticleSystemUpdateMode : byte {
		EPSUM_RealTime = 0,
		EPSUM_FixedTime = 1,
		EPSUM_MAX = 2
	};

	// Enum Engine.EParticleEventType
	public enum EParticleEventType : byte {
		EPET_Any = 0,
		EPET_Spawn = 1,
		EPET_Death = 2,
		EPET_Collision = 3,
		EPET_Burst = 4,
		EPET_Blueprint = 5,
		EPET_MAX = 6
	};

	// Enum Engine.ParticleReplayState
	public enum ParticleReplayState : byte {
		PRS_Disabled = 0,
		PRS_Capturing = 1,
		PRS_Replaying = 2,
		PRS_MAX = 3
	};

	// Enum Engine.EParticleSysParamType
	public enum EParticleSysParamType : byte {
		PSPT_None = 0,
		PSPT_Scalar = 1,
		PSPT_ScalarRand = 2,
		PSPT_Vector = 3,
		PSPT_VectorRand = 4,
		PSPT_Color = 5,
		PSPT_Actor = 6,
		PSPT_Material = 7,
		PSPT_VectorUnitRand = 8,
		PSPT_MAX = 9
	};

	// Enum Engine.ESettingsLockedAxis
	public enum ESettingsLockedAxis : byte {
		None = 0,
		X = 1,
		Y = 2,
		Z = 3,
		Invalid = 4,
		ESettingsLockedAxis_MAX = 5
	};

	// Enum Engine.ESettingsDOF
	public enum ESettingsDOF : byte {
		Full3D = 0,
		YZPlane = 1,
		XZPlane = 2,
		XYPlane = 3,
		ESettingsDOF_MAX = 4
	};

	// Enum Engine.EFrictionCombineMode
	public enum EFrictionCombineMode : byte {
		Average = 0,
		Min = 1,
		Multiply = 2,
		Max = 3
	};

	// Enum Engine.EViewTargetBlendFunction
	public enum EViewTargetBlendFunction : byte {
		VTBlend_Linear = 0,
		VTBlend_Cubic = 1,
		VTBlend_EaseIn = 2,
		VTBlend_EaseOut = 3,
		VTBlend_EaseInOut = 4,
		VTBlend_MAX = 5
	};

	// Enum Engine.EDynamicForceFeedbackAction
	public enum EDynamicForceFeedbackAction : byte {
		Start = 0,
		Update = 1,
		Stop = 2,
		EDynamicForceFeedbackAction_MAX = 3
	};

	// Enum Engine.ERendererStencilMask
	public enum ERendererStencilMask : byte {
		ERSM_Default = 0,
		ERSM_256 = 1,
		ERSM_2 = 2,
		ERSM_3 = 3,
		ERSM_5 = 4,
		ERSM_9 = 5,
		ERSM_17 = 6,
		ERSM_33 = 7,
		ERSM_65 = 8,
		ERSM_129 = 9,
		ERSM_MAX = 10
	};

	// Enum Engine.EHasCustomNavigableGeometry
	public enum EHasCustomNavigableGeometry : byte {
		No = 0,
		Yes = 1,
		EvenIfNotCollidable = 2,
		DontExport = 3,
		EHasCustomNavigableGeometry_MAX = 4
	};

	// Enum Engine.ECanBeCharacterBase
	public enum ECanBeCharacterBase : byte {
		ECB_No = 0,
		ECB_Yes = 1,
		ECB_Owner = 2,
		ECB_MAX = 3
	};

	// Enum Engine.ERichCurveExtrapolation
	public enum ERichCurveExtrapolation : byte {
		RCCE_Cycle = 0,
		RCCE_CycleWithOffset = 1,
		RCCE_Oscillate = 2,
		RCCE_Linear = 3,
		RCCE_Constant = 4,
		RCCE_None = 5,
		RCCE_MAX = 6
	};

	// Enum Engine.ERichCurveInterpMode
	public enum ERichCurveInterpMode : byte {
		RCIM_Linear = 0,
		RCIM_Constant = 1,
		RCIM_Cubic = 2,
		RCIM_None = 3,
		RCIM_MAX = 4
	};

	// Enum Engine.EReflectionSourceType
	public enum EReflectionSourceType : byte {
		CapturedScene = 0,
		SpecifiedCubemap = 1,
		EReflectionSourceType_MAX = 2
	};

	// Enum Engine.EDefaultBackBufferPixelFormat
	public enum EDefaultBackBufferPixelFormat : byte {
		DBBPF_B8G8R8A8 = 0,
		DBBPF_A16B16G16R16_DEPRECATED = 1,
		DBBPF_FloatRGB_DEPRECATED = 2,
		DBBPF_FloatRGBA = 3,
		DBBPF_A2B10G10R10 = 4,
		DBBPF_MAX = 5
	};

	// Enum Engine.EAutoExposureMethodUI
	public enum EAutoExposureMethodUI : byte {
		AEM_Histogram = 0,
		AEM_Basic = 1,
		AEM_Manual = 2,
		AEM_MAX = 3
	};

	// Enum Engine.EAlphaChannelMode
	public enum EAlphaChannelMode : byte {
		Disabled = 0,
		LinearColorSpaceOnly = 1,
		AllowThroughTonemapper = 2,
		EAlphaChannelMode_MAX = 3
	};

	// Enum Engine.EEarlyZPass
	public enum EEarlyZPass : byte {
		None = 0,
		OpaqueOnly = 1,
		OpaqueAndMasked = 2,
		Auto = 3,
		EEarlyZPass_MAX = 4
	};

	// Enum Engine.ECustomDepthStencil
	public enum ECustomDepthStencil : byte {
		Disabled = 0,
		Enabled = 1,
		EnabledOnDemand = 2,
		EnabledWithStencil = 3,
		ECustomDepthStencil_MAX = 4
	};

	// Enum Engine.EMobileMSAASampleCount
	public enum EMobileMSAASampleCount : byte {
		One = 1,
		Two = 2,
		Four = 4,
		Eight = 8,
		EMobileMSAASampleCount_MAX = 9
	};

	// Enum Engine.ECompositingSampleCount
	public enum ECompositingSampleCount : byte {
		One = 1,
		Two = 2,
		Four = 4,
		Eight = 8,
		ECompositingSampleCount_MAX = 9
	};

	// Enum Engine.EClearSceneOptions
	public enum EClearSceneOptions : byte {
		NoClear = 0,
		HardwareClear = 1,
		QuadAtMaxZ = 2,
		EClearSceneOptions_MAX = 3
	};

	// Enum Engine.EReporterLineStyle
	public enum EReporterLineStyle : byte {
		Line = 0,
		Dash = 1,
		EReporterLineStyle_MAX = 2
	};

	// Enum Engine.ELegendPosition
	public enum ELegendPosition : byte {
		Outside = 0,
		Inside = 1,
		ELegendPosition_MAX = 2
	};

	// Enum Engine.EGraphDataStyle
	public enum EGraphDataStyle : byte {
		Lines = 0,
		Filled = 1,
		EGraphDataStyle_MAX = 2
	};

	// Enum Engine.EGraphAxisStyle
	public enum EGraphAxisStyle : byte {
		Lines = 0,
		Notches = 1,
		Grid = 2,
		EGraphAxisStyle_MAX = 3
	};

	// Enum Engine.ReverbPreset
	public enum ReverbPreset : byte {
		REVERB_Default = 0,
		REVERB_Bathroom = 1,
		REVERB_StoneRoom = 2,
		REVERB_Auditorium = 3,
		REVERB_ConcertHall = 4,
		REVERB_Cave = 5,
		REVERB_Hallway = 6,
		REVERB_StoneCorridor = 7,
		REVERB_Alley = 8,
		REVERB_Forest = 9,
		REVERB_City = 10,
		REVERB_Mountains = 11,
		REVERB_Quarry = 12,
		REVERB_Plain = 13,
		REVERB_ParkingLot = 14,
		REVERB_SewerPipe = 15,
		REVERB_Underwater = 16,
		REVERB_SmallRoom = 17,
		REVERB_MediumRoom = 18,
		REVERB_LargeRoom = 19,
		REVERB_MediumHall = 20,
		REVERB_LargeHall = 21,
		REVERB_Plate = 22,
		REVERB_MAX = 23
	};

	// Enum Engine.ERichCurveKeyTimeCompressionFormat
	public enum ERichCurveKeyTimeCompressionFormat : byte {
		RCKTCF_uint16 = 0,
		RCKTCF_float32 = 1,
		RCKTCF_MAX = 2
	};

	// Enum Engine.ERichCurveCompressionFormat
	public enum ERichCurveCompressionFormat : byte {
		RCCF_Empty = 0,
		RCCF_Constant = 1,
		RCCF_Linear = 2,
		RCCF_Cubic = 3,
		RCCF_Mixed = 4,
		RCCF_MAX = 5
	};

	// Enum Engine.ERichCurveTangentWeightMode
	public enum ERichCurveTangentWeightMode : byte {
		RCTWM_WeightedNone = 0,
		RCTWM_WeightedArrive = 1,
		RCTWM_WeightedLeave = 2,
		RCTWM_WeightedBoth = 3,
		RCTWM_MAX = 4
	};

	// Enum Engine.ERichCurveTangentMode
	public enum ERichCurveTangentMode : byte {
		RCTM_Auto = 0,
		RCTM_User = 1,
		RCTM_Break = 2,
		RCTM_None = 3,
		RCTM_MAX = 4
	};

	// Enum Engine.EConstraintTransform
	public enum EConstraintTransform : byte {
		Absolute = 0,
		Relative = 1,
		EConstraintTransform_MAX = 2
	};

	// Enum Engine.EControlConstraint
	public enum EControlConstraint : byte {
		Orientation = 0,
		Translation = 1,
		MAX = 2
	};

	// Enum Engine.ERootMotionFinishVelocityMode
	public enum ERootMotionFinishVelocityMode : byte {
		MaintainLastRootMotionVelocity = 0,
		SetVelocity = 1,
		ClampVelocity = 2,
		ERootMotionFinishVelocityMode_MAX = 3
	};

	// Enum Engine.ERootMotionSourceSettingsFlags
	public enum ERootMotionSourceSettingsFlags : byte {
		UseSensitiveLiftoffCheck = 1,
		DisablePartialEndTick = 2,
		IgnoreZAccumulate = 4,
		ERootMotionSourceSettingsFlags_MAX = 5
	};

	// Enum Engine.ERootMotionSourceStatusFlags
	public enum ERootMotionSourceStatusFlags : byte {
		Prepared = 1,
		Finished = 2,
		MarkedForRemoval = 4,
		ERootMotionSourceStatusFlags_MAX = 5
	};

	// Enum Engine.ERootMotionAccumulateMode
	public enum ERootMotionAccumulateMode : byte {
		Override = 0,
		Additive = 1,
		ERootMotionAccumulateMode_MAX = 2
	};

	// Enum Engine.ERuntimeVirtualTextureMainPassType
	public enum ERuntimeVirtualTextureMainPassType : byte {
		Never = 0,
		Exclusive = 1,
		Always = 2,
		ERuntimeVirtualTextureMainPassType_MAX = 3
	};

	// Enum Engine.ERuntimeVirtualTextureMaterialType
	public enum ERuntimeVirtualTextureMaterialType : byte {
		BaseColor = 0,
		BaseColor_Normal_DEPRECATED = 1,
		BaseColor_Normal_Specular = 2,
		BaseColor_Normal_Specular_YCoCg = 3,
		BaseColor_Normal_Specular_Mask_YCoCg = 4,
		WorldHeight = 5,
		Count = 6,
		ERuntimeVirtualTextureMaterialType_MAX = 7
	};

	// Enum Engine.EReflectedAndRefractedRayTracedShadows
	public enum EReflectedAndRefractedRayTracedShadows : byte {
		Disabled = 0,
		Hard_shadows = 1,
		Area_shadows = 2,
		EReflectedAndRefractedRayTracedShadows_MAX = 3
	};

	// Enum Engine.ERayTracingGlobalIlluminationType
	public enum ERayTracingGlobalIlluminationType : byte {
		Disabled = 0,
		BruteForce = 1,
		FinalGather = 2,
		ERayTracingGlobalIlluminationType_MAX = 3
	};

	// Enum Engine.ETranslucencyType
	public enum ETranslucencyType : byte {
		Raster = 0,
		RayTracing = 1,
		ETranslucencyType_MAX = 2
	};

	// Enum Engine.EReflectionsType
	public enum EReflectionsType : byte {
		ScreenSpace = 0,
		RayTracing = 1,
		EReflectionsType_MAX = 2
	};

	// Enum Engine.ELightUnits
	public enum ELightUnits : byte {
		Unitless = 0,
		Candelas = 1,
		Lumens = 2,
		ELightUnits_MAX = 3
	};

	// Enum Engine.EBloomMethod
	public enum EBloomMethod : byte {
		BM_SOG = 0,
		BM_FFT = 1,
		BM_MAX = 2
	};

	// Enum Engine.EAutoExposureMethod
	public enum EAutoExposureMethod : byte {
		AEM_Histogram = 0,
		AEM_Basic = 1,
		AEM_Manual = 2,
		AEM_MAX = 3
	};

	// Enum Engine.EAntiAliasingMethod
	public enum EAntiAliasingMethod : byte {
		AAM_None = 0,
		AAM_FXAA = 1,
		AAM_TemporalAA = 2,
		AAM_MSAA = 3,
		AAM_DLSS = 4,
		AAM_MAX = 5
	};

	// Enum Engine.EDepthOfFieldMethod
	public enum EDepthOfFieldMethod : byte {
		DOFM_BokehDOF = 0,
		DOFM_Gaussian = 1,
		DOFM_CircleDOF = 2,
		DOFM_MAX = 3
	};

	// Enum Engine.ESceneCapturePrimitiveRenderMode
	public enum ESceneCapturePrimitiveRenderMode : byte {
		PRM_LegacySceneCapture = 0,
		PRM_RenderScenePrimitives = 1,
		PRM_UseShowOnlyList = 2,
		PRM_MAX = 3
	};

	// Enum Engine.EMaterialProperty
	public enum EMaterialProperty : byte {
		MP_EmissiveColor = 0,
		MP_Opacity = 1,
		MP_OpacityMask = 2,
		MP_DiffuseColor = 3,
		MP_SpecularColor = 4,
		MP_BaseColor = 5,
		MP_Metallic = 6,
		MP_Specular = 7,
		MP_Roughness = 8,
		MP_Anisotropy = 9,
		MP_Normal = 10,
		MP_Tangent = 11,
		MP_WorldPositionOffset = 12,
		MP_WorldDisplacement = 13,
		MP_TessellationMultiplier = 14,
		MP_SubsurfaceColor = 15,
		MP_CustomData0 = 16,
		MP_CustomData1 = 17,
		MP_AmbientOcclusion = 18,
		MP_Refraction = 19,
		MP_CustomizedUVs0 = 20,
		MP_CustomizedUVs1 = 21,
		MP_CustomizedUVs2 = 22,
		MP_CustomizedUVs3 = 23,
		MP_CustomizedUVs4 = 24,
		MP_CustomizedUVs5 = 25,
		MP_CustomizedUVs6 = 26,
		MP_CustomizedUVs7 = 27,
		MP_PixelDepthOffset = 28,
		MP_ShadingModel = 29,
		MP_MaterialAttributes = 30,
		MP_CustomOutput = 31,
		MP_MAX = 32
	};

	// Enum Engine.ESkinCacheDefaultBehavior
	public enum ESkinCacheDefaultBehavior : byte {
		Exclusive = 0,
		Inclusive = 1,
		ESkinCacheDefaultBehavior_MAX = 2
	};

	// Enum Engine.ESkinCacheUsage
	public enum ESkinCacheUsage : byte {
		Auto = 0,
		Disabled = 255,
		Enabled = 1,
		//ESkinCacheUsage_MAX = 256
	};

	// Enum Engine.EPhysicsTransformUpdateMode
	public enum EPhysicsTransformUpdateMode : byte {
		SimulationUpatesComponentTransform = 0,
		ComponentTransformIsKinematic = 1,
		EPhysicsTransformUpdateMode_MAX = 2
	};

	// Enum Engine.EAnimationMode
	public enum EAnimationMode : byte {
		AnimationBlueprint = 0,
		AnimationSingleNode = 1,
		AnimationCustomMode = 2,
		EAnimationMode_MAX = 3
	};

	// Enum Engine.EKinematicBonesUpdateToPhysics
	public enum EKinematicBonesUpdateToPhysics : byte {
		SkipSimulatingBones = 0,
		SkipAllBones = 1,
		EKinematicBonesUpdateToPhysics_MAX = 2
	};

	// Enum Engine.EClothMassMode
	public enum EClothMassMode : byte {
		UniformMass = 0,
		TotalMass = 1,
		Density = 2,
		MaxClothMassMode = 3,
		EClothMassMode_MAX = 4
	};

	// Enum Engine.EAnimCurveType
	public enum EAnimCurveType : byte {
		AttributeCurve = 0,
		MaterialCurve = 1,
		MorphTargetCurve = 2,
		MaxAnimCurveType = 3,
		EAnimCurveType_MAX = 4
	};

	// Enum Engine.ESkeletalMeshSkinningImportVersions
	public enum ESkeletalMeshSkinningImportVersions : byte {
		Before_Versionning = 0,
		SkeletalMeshBuildRefactor = 1,
		VersionPlusOne = 2,
		LatestVersion = 1,
		ESkeletalMeshSkinningImportVersions_MAX = 3
	};

	// Enum Engine.ESkeletalMeshGeoImportVersions
	public enum ESkeletalMeshGeoImportVersions : byte {
		Before_Versionning = 0,
		SkeletalMeshBuildRefactor = 1,
		VersionPlusOne = 2,
		LatestVersion = 1,
		ESkeletalMeshGeoImportVersions_MAX = 3
	};

	// Enum Engine.EBoneFilterActionOption
	public enum EBoneFilterActionOption : byte {
		Remove = 0,
		Keep = 1,
		Invalid = 2,
		EBoneFilterActionOption_MAX = 3
	};

	// Enum Engine.SkeletalMeshOptimizationImportance
	public enum SkeletalMeshOptimizationImportance : byte {
		SMOI_Off = 0,
		SMOI_Lowest = 1,
		SMOI_Low = 2,
		SMOI_Normal = 3,
		SMOI_High = 4,
		SMOI_Highest = 5,
		SMOI_MAX = 6
	};

	// Enum Engine.SkeletalMeshOptimizationType
	public enum SkeletalMeshOptimizationType : byte {
		SMOT_NumOfTriangles = 0,
		SMOT_MaxDeviation = 1,
		SMOT_TriangleOrDeviation = 2,
		SMOT_MAX = 3
	};

	// Enum Engine.SkeletalMeshTerminationCriterion
	public enum SkeletalMeshTerminationCriterion : byte {
		SMTC_NumOfTriangles = 0,
		SMTC_NumOfVerts = 1,
		SMTC_TriangleOrVert = 2,
		SMTC_AbsNumOfTriangles = 3,
		SMTC_AbsNumOfVerts = 4,
		SMTC_AbsTriangleOrVert = 5,
		SMTC_MAX = 6
	};

	// Enum Engine.EBoneTranslationRetargetingMode
	public enum EBoneTranslationRetargetingMode : byte {
		Animation = 0,
		Skeleton = 1,
		AnimationScaled = 2,
		AnimationRelative = 3,
		OrientAndScale = 4,
		EBoneTranslationRetargetingMode_MAX = 5
	};

	// Enum Engine.EBoneSpaces
	public enum EBoneSpaces : byte {
		WorldSpace = 0,
		ComponentSpace = 1,
		EBoneSpaces_MAX = 2
	};

	// Enum Engine.EVisibilityBasedAnimTickOption
	public enum EVisibilityBasedAnimTickOption : byte {
		AlwaysTickPoseAndRefreshBones = 0,
		AlwaysTickPose = 1,
		OnlyTickMontagesWhenNotRendered = 2,
		OnlyTickPoseWhenRendered = 3,
		EVisibilityBasedAnimTickOption_MAX = 4
	};

	// Enum Engine.EPhysBodyOp
	public enum EPhysBodyOp : byte {
		PBO_None = 0,
		PBO_Term = 1,
		PBO_MAX = 2
	};

	// Enum Engine.EBoneVisibilityStatus
	public enum EBoneVisibilityStatus : byte {
		BVS_HiddenByParent = 0,
		BVS_Visible = 1,
		BVS_ExplicitlyHidden = 2,
		BVS_MAX = 3
	};

	// Enum Engine.ESkyAtmosphereTransformMode
	public enum ESkyAtmosphereTransformMode : byte {
		PlanetTopAtAbsoluteWorldOrigin = 0,
		PlanetTopAtComponentTransform = 1,
		PlanetCenterAtComponentTransform = 2,
		ESkyAtmosphereTransformMode_MAX = 3
	};

	// Enum Engine.ESkyLightSourceType
	public enum ESkyLightSourceType : byte {
		SLS_CapturedScene = 0,
		SLS_SpecifiedCubemap = 1,
		SLS_MAX = 2
	};

	// Enum Engine.EPriorityAttenuationMethod
	public enum EPriorityAttenuationMethod : byte {
		Linear = 0,
		CustomCurve = 1,
		Manual = 2,
		EPriorityAttenuationMethod_MAX = 3
	};

	// Enum Engine.ESubmixSendMethod
	public enum ESubmixSendMethod : byte {
		Linear = 0,
		CustomCurve = 1,
		Manual = 2,
		ESubmixSendMethod_MAX = 3
	};

	// Enum Engine.EReverbSendMethod
	public enum EReverbSendMethod : byte {
		Linear = 0,
		CustomCurve = 1,
		Manual = 2,
		EReverbSendMethod_MAX = 3
	};

	// Enum Engine.EAirAbsorptionMethod
	public enum EAirAbsorptionMethod : byte {
		Linear = 0,
		CustomCurve = 1,
		EAirAbsorptionMethod_MAX = 2
	};

	// Enum Engine.ESoundSpatializationAlgorithm
	public enum ESoundSpatializationAlgorithm : byte {
		SPATIALIZATION_Default = 0,
		SPATIALIZATION_HRTF = 1,
		SPATIALIZATION_MAX = 2
	};

	// Enum Engine.ESoundDistanceCalc
	public enum ESoundDistanceCalc : byte {
		SOUNDDISTANCE_Normal = 0,
		SOUNDDISTANCE_InfiniteXYPlane = 1,
		SOUNDDISTANCE_InfiniteXZPlane = 2,
		SOUNDDISTANCE_InfiniteYZPlane = 3,
		SOUNDDISTANCE_MAX = 4
	};

	// Enum Engine.EVirtualizationMode
	public enum EVirtualizationMode : byte {
		Disabled = 0,
		PlayWhenSilent = 1,
		Restart = 2,
		EVirtualizationMode_MAX = 3
	};

	// Enum Engine.EMaxConcurrentResolutionRule
	public enum EMaxConcurrentResolutionRule : byte {
		PreventNew = 0,
		StopOldest = 1,
		StopFarthestThenPreventNew = 2,
		StopFarthestThenOldest = 3,
		StopLowestPriority = 4,
		StopQuietest = 5,
		StopLowestPriorityThenPreventNew = 6,
		Count = 7,
		EMaxConcurrentResolutionRule_MAX = 8
	};

	// Enum Engine.ESoundGroup
	public enum ESoundGroup : byte {
		SOUNDGROUP_Default = 0,
		SOUNDGROUP_Effects = 1,
		SOUNDGROUP_UI = 2,
		SOUNDGROUP_Music = 3,
		SOUNDGROUP_Voice = 4,
		SOUNDGROUP_GameSoundGroup1 = 5,
		SOUNDGROUP_GameSoundGroup2 = 6,
		SOUNDGROUP_GameSoundGroup3 = 7,
		SOUNDGROUP_GameSoundGroup4 = 8,
		SOUNDGROUP_GameSoundGroup5 = 9,
		SOUNDGROUP_GameSoundGroup6 = 10,
		SOUNDGROUP_GameSoundGroup7 = 11,
		SOUNDGROUP_GameSoundGroup8 = 12,
		SOUNDGROUP_GameSoundGroup9 = 13,
		SOUNDGROUP_GameSoundGroup10 = 14,
		SOUNDGROUP_GameSoundGroup11 = 15,
		SOUNDGROUP_GameSoundGroup12 = 16,
		SOUNDGROUP_GameSoundGroup13 = 17,
		SOUNDGROUP_GameSoundGroup14 = 18,
		SOUNDGROUP_GameSoundGroup15 = 19,
		SOUNDGROUP_GameSoundGroup16 = 20,
		SOUNDGROUP_GameSoundGroup17 = 21,
		SOUNDGROUP_GameSoundGroup18 = 22,
		SOUNDGROUP_GameSoundGroup19 = 23,
		SOUNDGROUP_GameSoundGroup20 = 24,
		SOUNDGROUP_MAX = 25
	};

	// Enum Engine.ModulationParamMode
	public enum ModulationParamMode : byte {
		MPM_Normal = 0,
		MPM_Abs = 1,
		MPM_Direct = 2,
		MPM_MAX = 3
	};

	// Enum Engine.ESourceBusChannels
	public enum ESourceBusChannels : byte {
		Mono = 0,
		Stereo = 1,
		ESourceBusChannels_MAX = 2
	};

	// Enum Engine.ESourceBusSendLevelControlMethod
	public enum ESourceBusSendLevelControlMethod : byte {
		Linear = 0,
		CustomCurve = 1,
		Manual = 2,
		ESourceBusSendLevelControlMethod_MAX = 3
	};

	// Enum Engine.ESendLevelControlMethod
	public enum ESendLevelControlMethod : byte {
		Linear = 0,
		CustomCurve = 1,
		Manual = 2,
		ESendLevelControlMethod_MAX = 3
	};

	// Enum Engine.EAudioRecordingExportType
	public enum EAudioRecordingExportType : byte {
		SoundWave = 0,
		WavFile = 1,
		EAudioRecordingExportType_MAX = 2
	};

	// Enum Engine.ESoundWaveFFTSize
	public enum ESoundWaveFFTSize : byte {
		VerySmall_65 = 0,
		Small_257 = 1,
		Medium_513 = 2,
		Large_1025 = 3,
		VeryLarge_2049 = 4,
		ESoundWaveFFTSize_MAX = 5
	};

	// Enum Engine.EDecompressionType
	public enum EDecompressionType : byte {
		DTYPE_Setup = 0,
		DTYPE_Invalid = 1,
		DTYPE_Preview = 2,
		DTYPE_Native = 3,
		DTYPE_RealTime = 4,
		DTYPE_Procedural = 5,
		DTYPE_Xenon = 6,
		DTYPE_Streaming = 7,
		DTYPE_MAX = 8
	};

	// Enum Engine.ESoundWaveLoadingBehavior
	public enum ESoundWaveLoadingBehavior : byte {
		Inherited = 0,
		RetainOnLoad = 1,
		PrimeOnLoad = 2,
		LoadOnDemand = 3,
		ForceInline = 4,
		Uninitialized = 255,
		//ESoundWaveLoadingBehavior_MAX = 256
	};

	// Enum Engine.ESplineCoordinateSpace
	public enum ESplineCoordinateSpace : byte {
		Local = 0,
		World = 1,
		ESplineCoordinateSpace_MAX = 2
	};

	// Enum Engine.ESplinePointType
	public enum ESplinePointType : byte {
		Linear = 0,
		Curve = 1,
		Constant = 2,
		CurveClamped = 3,
		CurveCustomTangent = 4,
		ESplinePointType_MAX = 5
	};

	// Enum Engine.ESplineMeshAxis
	public enum ESplineMeshAxis : byte {
		X = 0,
		Y = 1,
		Z = 2,
		ESplineMeshAxis_MAX = 3
	};

	// Enum Engine.EOptimizationType
	public enum EOptimizationType : byte {
		OT_NumOfTriangles = 0,
		OT_MaxDeviation = 1,
		OT_MAX = 2
	};

	// Enum Engine.EImportanceLevel
	public enum EImportanceLevel : byte {
		IL_Off = 0,
		IL_Lowest = 1,
		IL_Low = 2,
		IL_Normal = 3,
		IL_High = 4,
		IL_Highest = 5,
		TEMP_BROKEN2 = 6,
		EImportanceLevel_MAX = 7
	};

	// Enum Engine.ENormalMode
	public enum ENormalMode : byte {
		NM_PreserveSmoothingGroups = 0,
		NM_RecalculateNormals = 1,
		NM_RecalculateNormalsSmooth = 2,
		NM_RecalculateNormalsHard = 3,
		TEMP_BROKEN = 4,
		ENormalMode_MAX = 5
	};

	// Enum Engine.EStereoLayerShape
	public enum EStereoLayerShape : byte {
		SLSH_QuadLayer = 0,
		SLSH_CylinderLayer = 1,
		SLSH_CubemapLayer = 2,
		SLSH_EquirectLayer = 3,
		SLSH_MAX = 4
	};

	// Enum Engine.EStereoLayerType
	public enum EStereoLayerType : byte {
		SLT_WorldLocked = 0,
		SLT_TrackerLocked = 1,
		SLT_FaceLocked = 2,
		SLT_MAX = 3
	};

	// Enum Engine.EOpacitySourceMode
	public enum EOpacitySourceMode : byte {
		OSM_Alpha = 0,
		OSM_ColorBrightness = 1,
		OSM_RedChannel = 2,
		OSM_GreenChannel = 3,
		OSM_BlueChannel = 4,
		OSM_MAX = 5
	};

	// Enum Engine.ESubUVBoundingVertexCount
	public enum ESubUVBoundingVertexCount : byte {
		BVC_FourVertices = 0,
		BVC_EightVertices = 1,
		BVC_MAX = 2
	};

	// Enum Engine.EVerticalTextAligment
	public enum EVerticalTextAligment : byte {
		EVRTA_TextTop = 0,
		EVRTA_TextCenter = 1,
		EVRTA_TextBottom = 2,
		EVRTA_QuadTop = 3,
		EVRTA_MAX = 4
	};

	// Enum Engine.EHorizTextAligment
	public enum EHorizTextAligment : byte {
		EHTA_Left = 0,
		EHTA_Center = 1,
		EHTA_Right = 2,
		EHTA_MAX = 3
	};

	// Enum Engine.ETextureLossyCompressionAmount
	public enum ETextureLossyCompressionAmount : byte {
		TLCA_Default = 0,
		TLCA_None = 1,
		TLCA_Lowest = 2,
		TLCA_Low = 3,
		TLCA_Medium = 4,
		TLCA_High = 5,
		TLCA_Highest = 6,
		TLCA_MAX = 7
	};

	// Enum Engine.ETextureCompressionQuality
	public enum ETextureCompressionQuality : byte {
		TCQ_Default = 0,
		TCQ_Lowest = 1,
		TCQ_Low = 2,
		TCQ_Medium = 3,
		TCQ_High = 4,
		TCQ_Highest = 5,
		TCQ_MAX = 6
	};

	// Enum Engine.ETextureSourceFormat
	public enum ETextureSourceFormat : byte {
		TSF_Invalid = 0,
		TSF_G8 = 1,
		TSF_BGRA8 = 2,
		TSF_BGRE8 = 3,
		TSF_RGBA16 = 4,
		TSF_RGBA16F = 5,
		TSF_RGBA8 = 6,
		TSF_RGBE8 = 7,
		TSF_G16 = 8,
		TSF_MAX = 9
	};

	// Enum Engine.ETextureSourceArtType
	public enum ETextureSourceArtType : byte {
		TSAT_Uncompressed = 0,
		TSAT_PNGCompressed = 1,
		TSAT_DDSFile = 2,
		TSAT_MAX = 3
	};

	// Enum Engine.ETextureMipCount
	public enum ETextureMipCount : byte {
		TMC_ResidentMips = 0,
		TMC_AllMips = 1,
		TMC_AllMipsBiased = 2,
		TMC_MAX = 3
	};

	// Enum Engine.ECompositeTextureMode
	public enum ECompositeTextureMode : byte {
		CTM_Disabled = 0,
		CTM_NormalRoughnessToRed = 1,
		CTM_NormalRoughnessToGreen = 2,
		CTM_NormalRoughnessToBlue = 3,
		CTM_NormalRoughnessToAlpha = 4,
		CTM_MAX = 5
	};

	// Enum Engine.TextureAddress
	public enum TextureAddress : byte {
		TA_Wrap = 0,
		TA_Clamp = 1,
		TA_Mirror = 2,
		TA_MAX = 3
	};

	// Enum Engine.TextureFilter
	public enum TextureFilter : byte {
		TF_Nearest = 0,
		TF_Bilinear = 1,
		TF_Trilinear = 2,
		TF_Default = 3,
		TF_MAX = 4
	};

	// Enum Engine.TextureCompressionSettings
	public enum TextureCompressionSettings : byte {
		TC_Default = 0,
		TC_Normalmap = 1,
		TC_Masks = 2,
		TC_Grayscale = 3,
		TC_Displacementmap = 4,
		TC_VectorDisplacementmap = 5,
		TC_HDR = 6,
		TC_EditorIcon = 7,
		TC_Alpha = 8,
		TC_DistanceFieldFont = 9,
		TC_HDR_Compressed = 10,
		TC_BC7 = 11,
		TC_MAX = 12
	};

	// Enum Engine.ETextureMipLoadOptions
	public enum ETextureMipLoadOptions : byte {
		Default = 0,
		AllMips = 1,
		OnlyFirstMip = 2,
		ETextureMipLoadOptions_MAX = 3
	};

	// Enum Engine.ETextureSamplerFilter
	public enum ETextureSamplerFilter : byte {
		Point = 0,
		Bilinear = 1,
		Trilinear = 2,
		AnisotropicPoint = 3,
		AnisotropicLinear = 4,
		ETextureSamplerFilter_MAX = 5
	};

	// Enum Engine.ETexturePowerOfTwoSetting
	public enum ETexturePowerOfTwoSetting : byte {
		None = 0,
		PadToPowerOfTwo = 1,
		PadToSquarePowerOfTwo = 2,
		ETexturePowerOfTwoSetting_MAX = 3
	};

	// Enum Engine.TextureMipGenSettings
	public enum TextureMipGenSettings : byte {
		TMGS_FromTextureGroup = 0,
		TMGS_SimpleAverage = 1,
		TMGS_Sharpen0 = 2,
		TMGS_Sharpen1 = 3,
		TMGS_Sharpen2 = 4,
		TMGS_Sharpen3 = 5,
		TMGS_Sharpen4 = 6,
		TMGS_Sharpen5 = 7,
		TMGS_Sharpen6 = 8,
		TMGS_Sharpen7 = 9,
		TMGS_Sharpen8 = 10,
		TMGS_Sharpen9 = 11,
		TMGS_Sharpen10 = 12,
		TMGS_NoMipmaps = 13,
		TMGS_LeaveExistingMips = 14,
		TMGS_Blur1 = 15,
		TMGS_Blur2 = 16,
		TMGS_Blur3 = 17,
		TMGS_Blur4 = 18,
		TMGS_Blur5 = 19,
		TMGS_Unfiltered = 20,
		TMGS_MAX = 21
	};

	// Enum Engine.TextureGroup
	public enum TextureGroup : byte {
		TEXTUREGROUP_World = 0,
		TEXTUREGROUP_WorldNormalMap = 1,
		TEXTUREGROUP_WorldSpecular = 2,
		TEXTUREGROUP_Character = 3,
		TEXTUREGROUP_CharacterNormalMap = 4,
		TEXTUREGROUP_CharacterSpecular = 5,
		TEXTUREGROUP_Weapon = 6,
		TEXTUREGROUP_WeaponNormalMap = 7,
		TEXTUREGROUP_WeaponSpecular = 8,
		TEXTUREGROUP_Vehicle = 9,
		TEXTUREGROUP_VehicleNormalMap = 10,
		TEXTUREGROUP_VehicleSpecular = 11,
		TEXTUREGROUP_Cinematic = 12,
		TEXTUREGROUP_Effects = 13,
		TEXTUREGROUP_EffectsNotFiltered = 14,
		TEXTUREGROUP_Skybox = 15,
		TEXTUREGROUP_UI = 16,
		TEXTUREGROUP_Lightmap = 17,
		TEXTUREGROUP_RenderTarget = 18,
		TEXTUREGROUP_MobileFlattened = 19,
		TEXTUREGROUP_ProcBuilding_Face = 20,
		TEXTUREGROUP_ProcBuilding_LightMap = 21,
		TEXTUREGROUP_Shadowmap = 22,
		TEXTUREGROUP_ColorLookupTable = 23,
		TEXTUREGROUP_Terrain_Heightmap = 24,
		TEXTUREGROUP_Terrain_Weightmap = 25,
		TEXTUREGROUP_Bokeh = 26,
		TEXTUREGROUP_IESLightProfile = 27,
		TEXTUREGROUP_Pixels2D = 28,
		TEXTUREGROUP_HierarchicalLOD = 29,
		TEXTUREGROUP_Impostor = 30,
		TEXTUREGROUP_ImpostorNormalDepth = 31,
		TEXTUREGROUP_8BitData = 32,
		TEXTUREGROUP_16BitData = 33,
		TEXTUREGROUP_Project01 = 34,
		TEXTUREGROUP_Project02 = 35,
		TEXTUREGROUP_Project03 = 36,
		TEXTUREGROUP_Project04 = 37,
		TEXTUREGROUP_Project05 = 38,
		TEXTUREGROUP_Project06 = 39,
		TEXTUREGROUP_Project07 = 40,
		TEXTUREGROUP_Project08 = 41,
		TEXTUREGROUP_Project09 = 42,
		TEXTUREGROUP_Project10 = 43,
		TEXTUREGROUP_Project11 = 44,
		TEXTUREGROUP_Project12 = 45,
		TEXTUREGROUP_Project13 = 46,
		TEXTUREGROUP_Project14 = 47,
		TEXTUREGROUP_Project15 = 48,
		TEXTUREGROUP_MAX = 49
	};

	// Enum Engine.ETextureRenderTargetFormat
	public enum ETextureRenderTargetFormat : byte {
		RTF_R8 = 0,
		RTF_RG8 = 1,
		RTF_RGBA8 = 2,
		RTF_RGBA8_SRGB = 3,
		RTF_R16f = 4,
		RTF_RG16f = 5,
		RTF_RGBA16f = 6,
		RTF_R32f = 7,
		RTF_RG32f = 8,
		RTF_RGBA32f = 9,
		RTF_RGB10A2 = 10,
		RTF_MAX = 11
	};

	// Enum Engine.ETimecodeProviderSynchronizationState
	public enum ETimecodeProviderSynchronizationState : byte {
		Closed = 0,
		Error = 1,
		Synchronized = 2,
		Synchronizing = 3,
		ETimecodeProviderSynchronizationState_MAX = 4
	};

	// Enum Engine.ETimelineDirection
	public enum ETimelineDirection : byte {
		Forward = 0,
		Backward = 1,
		ETimelineDirection_MAX = 2
	};

	// Enum Engine.ETimelineLengthMode
	public enum ETimelineLengthMode : byte {
		TL_TimelineLength = 0,
		TL_LastKeyFrame = 1,
		TL_MAX = 2
	};

	// Enum Engine.ETimeStretchCurveMapping
	public enum ETimeStretchCurveMapping : byte {
		T_Original = 0,
		T_TargetMin = 1,
		T_TargetMax = 2,
		MAX = 3
	};

	// Enum Engine.ETwitterIntegrationDelegate
	public enum ETwitterIntegrationDelegate : byte {
		TID_AuthorizeComplete = 0,
		TID_TweetUIComplete = 1,
		TID_RequestComplete = 2,
		TID_MAX = 3
	};

	// Enum Engine.ETwitterRequestMethod
	public enum ETwitterRequestMethod : byte {
		TRM_Get = 0,
		TRM_Post = 1,
		TRM_Delete = 2,
		TRM_MAX = 3
	};

	// Enum Engine.EUserDefinedStructureStatus
	public enum EUserDefinedStructureStatus : byte {
		UDSS_UpToDate = 0,
		UDSS_Dirty = 1,
		UDSS_Error = 2,
		UDSS_Duplicate = 3,
		UDSS_MAX = 4
	};

	// Enum Engine.EUIScalingRule
	public enum EUIScalingRule : byte {
		ShortestSide = 0,
		LongestSide = 1,
		Horizontal = 2,
		Vertical = 3,
		Custom = 4,
		EUIScalingRule_MAX = 5
	};

	// Enum Engine.ERenderFocusRule
	public enum ERenderFocusRule : byte {
		Always = 0,
		NonPointer = 1,
		NavigationOnly = 2,
		Never = 3,
		ERenderFocusRule_MAX = 4
	};

	// Enum Engine.EVectorFieldConstructionOp
	public enum EVectorFieldConstructionOp : byte {
		VFCO_Extrude = 0,
		VFCO_Revolve = 1,
		VFCO_MAX = 2
	};

	// Enum Engine.EWindSourceType
	public enum EWindSourceType : byte {
		Directional = 0,
		Point = 1,
		EWindSourceType_MAX = 2
	};

	// Enum Engine.EPSCPoolMethod
	public enum EPSCPoolMethod : byte {
		None = 0,
		AutoRelease = 1,
		ManualRelease = 2,
		ManualRelease_OnComplete = 3,
		FreeInPool = 4,
		EPSCPoolMethod_MAX = 5
	};

	// Enum Engine.EVolumeLightingMethod
	public enum EVolumeLightingMethod : byte {
		VLM_VolumetricLightmap = 0,
		VLM_SparseVolumeLightingSamples = 1,
		VLM_MAX = 2
	};

	// Enum Engine.EVisibilityAggressiveness
	public enum EVisibilityAggressiveness : byte {
		VIS_LeastAggressive = 0,
		VIS_ModeratelyAggressive = 1,
		VIS_MostAggressive = 2,
		VIS_Max = 3
	};



}


```

`UAssetAPI/UnrealTypes/Objects/Engine/FFontCharacter.cs`:

```cs
namespace UAssetAPI.UnrealTypes;

/// <summary>
/// This struct is serialized using native serialization so any changes to it require a package version bump.
/// </summary>
public struct FFontCharacter
{
    public int StartU;
    public int StartV;
    public int USize;
    public int VSize;
    public byte TextureIndex;
    public int VerticalOffset;

    public FFontCharacter(AssetBinaryReader reader)
    {
        StartU = reader.ReadInt32();
        StartV = reader.ReadInt32();
        USize = reader.ReadInt32();
        VSize = reader.ReadInt32();
        TextureIndex = reader.ReadByte();
        VerticalOffset = reader.ReadInt32();
    }

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;
        writer.Write(StartU);
        writer.Write(StartV);
        writer.Write(USize);
        writer.Write(VSize);
        writer.Write(TextureIndex);
        writer.Write(VerticalOffset);
        return (int)(writer.BaseStream.Position - offset);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Engine/FRichCurveKey.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes.EngineEnums;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// One key in a rich, editable float curve
/// </summary>
public struct FRichCurveKey : IStruct<FRichCurveKey>
{
    public ERichCurveInterpMode InterpMode;
    public ERichCurveTangentMode TangentMode;
    public ERichCurveTangentWeightMode TangentWeightMode;
    public float Time;
    public float Value;
    public float ArriveTangent;
    public float ArriveTangentWeight;
    public float LeaveTangent;
    public float LeaveTangentWeight;

    public FRichCurveKey() { }

    public FRichCurveKey(ERichCurveInterpMode interpMode, ERichCurveTangentMode tangentMode, ERichCurveTangentWeightMode tangentWeightMode, float time, float value, float arriveTangent, float arriveTangentWeight, float leaveTangent, float leaveTangentWeight)
    {
        InterpMode = interpMode;
        TangentMode = tangentMode;
        TangentWeightMode = tangentWeightMode;
        Time = time;
        Value = value;
        ArriveTangent = arriveTangent;
        ArriveTangentWeight = arriveTangentWeight;
        LeaveTangent = leaveTangent;
        LeaveTangentWeight = leaveTangentWeight;
    }

    public FRichCurveKey(AssetBinaryReader reader)
    {
        InterpMode = (ERichCurveInterpMode)reader.ReadByte();
        TangentMode = (ERichCurveTangentMode)reader.ReadByte();
        TangentWeightMode = (ERichCurveTangentWeightMode)reader.ReadByte();
        Time = reader.ReadSingle();
        Value = reader.ReadSingle();
        ArriveTangent = reader.ReadSingle();
        ArriveTangentWeight = reader.ReadSingle();
        LeaveTangent = reader.ReadSingle();
        LeaveTangentWeight = reader.ReadSingle();
    }

    public int Write(AssetBinaryWriter writer)
    {
        writer.Write((byte)InterpMode);
        writer.Write((byte)TangentMode);
        writer.Write((byte)TangentWeightMode);
        writer.Write(Time);
        writer.Write(Value);
        writer.Write(ArriveTangent);
        writer.Write(ArriveTangentWeight);
        writer.Write(LeaveTangent);
        writer.Write(LeaveTangentWeight);
        return sizeof(float) * 6 + sizeof(byte) * 3;
    }

    public static FRichCurveKey Read(AssetBinaryReader reader) => new FRichCurveKey(reader); 

    public override string ToString()
    {
        return $"({InterpMode}, {TangentMode}, {TangentWeightMode}, {Time}, {Value}, {ArriveTangent}, {ArriveTangentWeight}, {LeaveTangent}, {LeaveTangentWeight})";
    }

    public static FRichCurveKey FromString(string[] d, UAsset asset)
    {
        Enum.TryParse<ERichCurveInterpMode>(d[0], out var InterpMode);
        Enum.TryParse<ERichCurveTangentMode>(d[1], out var TangentMode);
        Enum.TryParse<ERichCurveTangentWeightMode>(d[2], out var TangentWeightMode);
        float.TryParse(d[3], out float res1);
        float.TryParse(d[4], out float res2);
        float.TryParse(d[5], out float res3);
        float.TryParse(d[6], out float res4);
        float.TryParse(d[7], out float res5);
        float.TryParse(d[8], out float res6);
        return new FRichCurveKey(InterpMode, TangentMode, TangentWeightMode, res1, res2, res3, res4, res5, res6);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Engine/FSkeletalMeshSamplingRegionBuiltData.cs`:

```cs
using System;
using UAssetAPI.CustomVersions;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

/// <summary>
/// Built data for sampling a single region of a skeletal mesh
/// </summary>
public class FSkeletalMeshSamplingRegionBuiltData : IStruct<FSkeletalMeshSamplingRegionBuiltData>
{
    /** Triangles included in this region. */
    public int[] TriangleIndices;

    /** Vertices included in this region. */
    public int[] Vertices;

    /** Bones included in this region. */
    public int[] BoneIndices;

    /** Provides random area weighted sampling of the TriangleIndices array. */
    FSkeletalMeshAreaWeightedTriangleSampler AreaWeightedSampler;

    public FSkeletalMeshSamplingRegionBuiltData()
    {
        TriangleIndices = [];
        Vertices = [];
        BoneIndices = [];
        AreaWeightedSampler = new FSkeletalMeshAreaWeightedTriangleSampler();
    }

    public FSkeletalMeshSamplingRegionBuiltData(AssetBinaryReader reader)
    {
        TriangleIndices = reader.ReadArray(reader.ReadInt32);
        BoneIndices = reader.ReadArray(reader.ReadInt32);

        AreaWeightedSampler = new FSkeletalMeshAreaWeightedTriangleSampler(reader);

        if (reader.Asset.GetCustomVersion<FNiagaraObjectVersion>() >= FNiagaraObjectVersion.SkeletalMeshVertexSampling)
        {
            Vertices = reader.ReadArray(reader.ReadInt32);
        }
    }

    public static FSkeletalMeshSamplingRegionBuiltData Read(AssetBinaryReader reader) => new FSkeletalMeshSamplingRegionBuiltData(reader);

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        if (TriangleIndices == null) TriangleIndices = Array.Empty<int>();
        writer.Write(TriangleIndices.Length);
        foreach (var t in TriangleIndices)
        {
            writer.Write(t);
        }

        if (BoneIndices == null) BoneIndices = Array.Empty<int>();
        writer.Write(BoneIndices.Length);
        foreach (var b in BoneIndices)
        {
            writer.Write(b);
        }

        if (AreaWeightedSampler == null) AreaWeightedSampler = new FSkeletalMeshAreaWeightedTriangleSampler();
        AreaWeightedSampler.Write(writer);

        if (writer.Asset.GetCustomVersion<FNiagaraObjectVersion>() >= FNiagaraObjectVersion.SkeletalMeshVertexSampling)
        {
            if (Vertices == null) Vertices = Array.Empty<int>();
            writer.Write(Vertices.Length);
            foreach (var v in Vertices)
            {
                writer.Write(v);
            }
        }

        return (int)(writer.BaseStream.Position - offset);
    }

    public static FSkeletalMeshSamplingRegionBuiltData FromString(string[] d, UAsset asset)
    {
        throw new NotImplementedException();
    }
}
```

`UAssetAPI/UnrealTypes/Objects/Engine/FWeightedRandomSampler.cs`:

```cs
using System;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

public class FWeightedRandomSampler : ICloneable, IStruct<FWeightedRandomSampler>
{
    public float[] Prob;
    public int[] Alias;
    public float TotalWeight;

    public FWeightedRandomSampler()
    {
        Prob = [];
        Alias = [];
        TotalWeight = 0;
    }

    public FWeightedRandomSampler(float[] prob, int[] alias, float totalWeight)
    {
        Prob = prob;
        Alias = alias;
        TotalWeight = totalWeight;
    }

    public FWeightedRandomSampler(AssetBinaryReader reader)
    {
        Prob = reader.ReadArray(reader.ReadSingle);
        Alias = reader.ReadArray(reader.ReadInt32);
        TotalWeight = reader.ReadSingle();
    }

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        writer.Write(Prob.Length);
        foreach (var p in Prob)
        {
            writer.Write(p);
        }

        writer.Write(Alias.Length);
        foreach (var a in Alias)
        {
            writer.Write(a);
        }

        writer.Write(TotalWeight);

        return (int)(writer.BaseStream.Position - offset);
    }

    public object Clone() => new FWeightedRandomSampler((float[])Prob.Clone(), (int[])Alias.Clone(), TotalWeight);

    public static FWeightedRandomSampler Read(AssetBinaryReader reader) => new FWeightedRandomSampler(reader);

    public override string ToString()
    {
        string oup = "(";

        oup += "(";
        for (int i = 0; i < Prob.Length; i++)
        {
            oup += Convert.ToString(Prob[i]) + ", ";
        }
        oup = oup.Remove(oup.Length - 2) + ")";

        oup += "(";
        for (int i = 0; i < Alias.Length; i++)
        {
            oup += Convert.ToString(Alias[i]) + ", ";
        }
        oup = oup.Remove(oup.Length - 2) + ")";

        oup += ", " + TotalWeight + ")";

        return oup;
    }

    public static FWeightedRandomSampler FromString(string[] d, UAsset asset)
    {
        throw new NotImplementedException();
    }
}

/// <summary>
/// Allows area weighted sampling of triangles on a skeletal mesh.
/// </summary>
public class FSkeletalMeshAreaWeightedTriangleSampler : FWeightedRandomSampler
{
    public FSkeletalMeshAreaWeightedTriangleSampler(AssetBinaryReader reader) : base(reader) { }

    public FSkeletalMeshAreaWeightedTriangleSampler() { }
}
```

`UAssetAPI/UnrealTypes/Objects/Engine/GameFramework/UniqueNetIdReplPropertyData.cs`:

```cs
using System.Text;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

public class FUniqueNetId
{
    public FName Type;
    public FString Contents;

    public FUniqueNetId(FName type, FString contents)
    {
        Type = type;
        Contents = contents;
    }

    public FUniqueNetId(AssetBinaryReader reader)
    {
        if (reader.ReadInt32() <= 0) return;
        if (reader.Asset.GetEngineVersion() >= EngineVersion.VER_UE4_20)
            Type = reader.ReadFName();
        Contents = reader.ReadFString();
    }

    public int Write(AssetBinaryWriter writer)
    {
        if (Type is null && Contents is null)
        {
            writer.Write(0);
            return sizeof(int);
        }

        var size = sizeof(int);
        if (writer.Asset.GetEngineVersion() >= EngineVersion.VER_UE4_20)
        {
            size += sizeof(int) * 2;
        }

        if (Contents != null)
        {
            size += Contents.Encoding is UnicodeEncoding ? (Contents.Value.Length + 1) * 2 : (Contents.Value.Length + 1);
        }

        //not sure about this alignment, maybe need this only in old versions
        writer.Write(size + 3 & ~3);

        if (writer.Asset.GetEngineVersion() >= EngineVersion.VER_UE4_20)
            writer.Write(Type);
        writer.Write(Contents);

        return size+sizeof(int);
    }
}

public class UniqueNetIdReplPropertyData : PropertyData<FUniqueNetId>
{
    public UniqueNetIdReplPropertyData(FName name) : base(name) { } 

    public UniqueNetIdReplPropertyData() { }

    private static readonly FString CurrentPropertyType = new FString("UniqueNetIdRepl");
    public override bool HasCustomStructSerialization => true;
    public override FString PropertyType => CurrentPropertyType;

    public override void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2 = 0, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.ReadEndPropertyTag(reader);
        }

        Value = new FUniqueNetId(reader);
    }

    public override int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext = PropertySerializationContext.Normal)
    {
        if (includeHeader)
        {
            this.WriteEndPropertyTag(writer);
        }

        if (Value is null)
        {
            writer.Write(0);
            return sizeof(int);
        }
      
        return Value.Write(writer);
    }
}

```

`UAssetAPI/UnrealTypes/Objects/Engine/Niagara/FNiagaraDataInterfaceGPUParamInfo.cs`:

```cs
using System;
using UAssetAPI.CustomVersions;
using UAssetAPI.PropertyTypes.Objects;

namespace UAssetAPI.UnrealTypes;

public struct FNiagaraVariableCommonReference(AssetBinaryReader reader)
{
    public FName Name = reader.ReadFName();
    public FPackageIndex Type = new FPackageIndex(reader);

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(Name);
        Type.Write(writer);
    }
}

public class FNiagaraDataInterfaceGeneratedFunction
{
    /** Name of the function as defined by the data interface. */
    public FName DefinitionName;

    /** Name of the instance. Derived from the definition name but made unique for this DI instance and specifier values. */
    public FString InstanceName;

    /** Specifier values for this instance. */
    public (FName, FName)[] Specifiers;

    public FNiagaraVariableCommonReference[] VariadicInputs = [];
    public FNiagaraVariableCommonReference[] VariadicOutputs = [];
    public ushort MiscUsageBitMask;

    public FNiagaraDataInterfaceGeneratedFunction() { }

    public FNiagaraDataInterfaceGeneratedFunction(AssetBinaryReader reader)
    {
        DefinitionName = reader.ReadFName();
        InstanceName = reader.ReadFString();

        Specifiers = reader.ReadArray(() => (reader.ReadFName(), reader.ReadFName()));

        if (reader.Asset.GetCustomVersion<FNiagaraCustomVersion>() >= FNiagaraCustomVersion.AddVariadicParametersToGPUFunctionInfo)
        {
            VariadicInputs = reader.ReadArray(() => new FNiagaraVariableCommonReference(reader));
            VariadicOutputs = reader.ReadArray(() => new FNiagaraVariableCommonReference(reader));
        }

        if (reader.Asset.GetCustomVersion<FNiagaraCustomVersion>() >= FNiagaraCustomVersion.SerializeUsageBitMaskToGPUFunctionInfo)
            MiscUsageBitMask = reader.ReadUInt16();
    }

    public void Write(AssetBinaryWriter writer)
    {
        writer.Write(DefinitionName);
        writer.Write(InstanceName);

        writer.Write(Specifiers.Length);
        foreach (var spec in Specifiers)
        {
            writer.Write(spec.Item1);
            writer.Write(spec.Item2);
        }

        if (writer.Asset.GetCustomVersion<FNiagaraCustomVersion>() >= FNiagaraCustomVersion.AddVariadicParametersToGPUFunctionInfo)
        {
            writer.Write(VariadicInputs.Length);
            foreach (var input in VariadicInputs)
            {
                input.Write(writer);
            }

            writer.Write(VariadicOutputs.Length);
            foreach (var output in VariadicOutputs)
            {
                output.Write(writer);
            }
        }

        if (writer.Asset.GetCustomVersion<FNiagaraCustomVersion>() >= FNiagaraCustomVersion.SerializeUsageBitMaskToGPUFunctionInfo)
            writer.Write(MiscUsageBitMask);
    }
}

public class FNiagaraDataInterfaceGPUParamInfo : IStruct<FNiagaraDataInterfaceGPUParamInfo>
{
    /** Symbol of this DI in the hlsl. Used for binding parameters. */
    public FString DataInterfaceHLSLSymbol;

    /** Name of the class for this data interface. Used for constructing the correct parameters struct. */
    public FString DIClassName;

    /** Information about all the functions generated by the translator for this data interface. */
    public FNiagaraDataInterfaceGeneratedFunction[] GeneratedFunctions = [];

    public FNiagaraDataInterfaceGPUParamInfo() { }

    public FNiagaraDataInterfaceGPUParamInfo(AssetBinaryReader reader)
    {
        DataInterfaceHLSLSymbol = reader.ReadFString();
        DIClassName = reader.ReadFString();

        if (reader.Asset.GetCustomVersion<FNiagaraCustomVersion>() >= FNiagaraCustomVersion.AddGeneratedFunctionsToGPUParamInfo)
        {
            GeneratedFunctions = reader.ReadArray(() => new FNiagaraDataInterfaceGeneratedFunction(reader));
        }
    }

    public static FNiagaraDataInterfaceGPUParamInfo Read(AssetBinaryReader reader) => new FNiagaraDataInterfaceGPUParamInfo(reader);

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;
        writer.Write(DataInterfaceHLSLSymbol);
        writer.Write(DIClassName);
        if (writer.Asset.GetCustomVersion<FNiagaraCustomVersion>() >= FNiagaraCustomVersion.AddGeneratedFunctionsToGPUParamInfo)
        {
            writer.Write(GeneratedFunctions.Length);
            foreach (var func in GeneratedFunctions)
            {
                func.Write(writer);
            }
        }

        return (int)(writer.BaseStream.Position - offset);
    }

    public static FNiagaraDataInterfaceGPUParamInfo FromString(string[] d, UAsset asset)
    {
        throw new NotImplementedException();
    }
}

```

`UAssetAPI/UnrealTypes/Objects/SlateCore/FFontData.cs`:

```cs
namespace UAssetAPI.UnrealTypes;

public enum EFontHinting : byte
{
    /** Use the default hinting specified in the font. */
    Default,
    /** Force the use of an automatic hinting algorithm. */
    Auto,
    /** Force the use of an automatic light hinting algorithm, optimized for non-monochrome displays. */
    AutoLight,
    /** Force the use of an automatic hinting algorithm optimized for monochrome displays. */
    Monochrome,
    /** Do not use hinting. */
    None,
}

public enum EFontLoadingPolicy : byte
{
    /** Lazy load the entire font into memory. This will consume more memory than Streaming, however there will be zero file-IO when rendering glyphs within the font, although the initial load may cause a hitch. */
    LazyLoad,
    /** Stream the font from disk. This will consume less memory than LazyLoad or Inline, however there will be file-IO when rendering glyphs, which may cause hitches under certain circumstances or on certain platforms. */
    Stream,
    /** Embed the font data within the asset. This will consume more memory than Streaming, however it is guaranteed to be hitch free (only valid for font data within a Font Face asset). */
    Inline,
}

public class FFontData
{
    public FPackageIndex LocalFontFaceAsset; // UObject
    public FString FontFilename;
    public EFontHinting Hinting;
    public EFontLoadingPolicy LoadingPolicy;
    public int SubFaceIndex;
    public bool bIsCooked;

    public FFontData()
    {
        bIsCooked = false;
    }

    public FFontData(AssetBinaryReader reader)
    {
        bIsCooked = reader.ReadBooleanInt();
        if (bIsCooked)
        {
            LocalFontFaceAsset = new FPackageIndex(reader);

            if (LocalFontFaceAsset.Index == 0)
            {
                FontFilename = reader.ReadFString();
                Hinting = (EFontHinting)reader.ReadByte();
                LoadingPolicy = (EFontLoadingPolicy)reader.ReadByte();
            }

            if (reader.Asset.GetEngineVersion() >= EngineVersion.VER_UE4_20)
                SubFaceIndex = reader.ReadInt32();
        }
    }

    public int Write(AssetBinaryWriter writer)
    {
        var offset = writer.BaseStream.Position;

        writer.Write(bIsCooked ? 1 : 0);
        if (bIsCooked)
        {
            writer.Write(LocalFontFaceAsset?.Index ?? 0);

            if (LocalFontFaceAsset.Index == 0)
            {
                writer.Write(FontFilename);
                writer.Write((byte)Hinting);
                writer.Write((byte)LoadingPolicy);
            }

            if (writer.Asset.GetEngineVersion() >= EngineVersion.VER_UE4_20)
                writer.Write(SubFaceIndex);
        }

        return (int)(writer.BaseStream.Position - offset);
    }
}

```

`UAssetAPI/UnrealTypes/TMap.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Linq;

/*
    The code in this file is modified from mattmc3's dotmore @ https://github.com/mattmc3/dotmore/tree/b032bbf871d46bffd698c9b7a233c533d9d2f0ebs for usage in UAssetAPI.

    The MIT License (MIT)

    Copyright (c) 2014 mattmc3

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

namespace UAssetAPI.UnrealTypes
{
    internal static class StringExtensions
    {
        /// <summary>
        /// Provides a more natural way to call String.Format() on a string.
        /// </summary>
        /// <param name="s">The string to format.</param>
        /// <param name="args">An object array that contains zero or more objects to format</param>
        public static string FormatWith(this string s, params object[] args)
        {
            if (s == null) return null;
            return string.Format(s, args);
        }

        /// <summary>
        /// Provides a more natural way to call String.Format() on a string.
        /// </summary>
        /// <param name="s">The string to format.</param>
        /// <param name="provider">An object that supplies the culture specific formatting</param>
        /// <param name="args">An object array that contains zero or more objects to format</param>
        public static string FormatWith(this string s, IFormatProvider provider, params object[] args)
        {
            if (s == null) return null;
            return string.Format(provider, s, args);
        }
    }

    public class DictionaryEnumerator<TKey, TValue> : IDictionaryEnumerator, IDisposable
    {
        readonly IEnumerator<KeyValuePair<TKey, TValue>> _impl;
        public void Dispose() { _impl.Dispose(); }
        public DictionaryEnumerator(IDictionary<TKey, TValue> value)
        {
            this._impl = value.GetEnumerator();
        }
        public void Reset() { _impl.Reset(); }
        public bool MoveNext() { return _impl.MoveNext(); }
        public DictionaryEntry Entry
        {
            get
            {
                var pair = _impl.Current;
                return new DictionaryEntry(pair.Key, pair.Value);
            }
        }
        public object Key { get { return _impl.Current.Key; } }
        public object Value { get { return _impl.Current.Value; } }
        public object Current { get { return Entry; } }
    }

    public class Comparer2<T> : Comparer<T>
    {
        private readonly Comparison<T> _compareFunction;

        public Comparer2(Comparison<T> comparison)
        {
            if (comparison == null) throw new ArgumentNullException("comparison");
            _compareFunction = comparison;
        }

        public override int Compare(T arg1, T arg2)
        {
            return _compareFunction(arg1, arg2);
        }
    }
    
    /// <summary>
    /// A concrete implementation of the abstract KeyedCollection class using lambdas for the
    /// implementation.
    /// </summary>
    public class KeyedCollection2<TKey, TItem> : KeyedCollection<TKey, TItem>
    {
        private const string DelegateNullExceptionMessage = "Delegate passed cannot be null";
        private Func<TItem, TKey> _getKeyForItemFunction;

        public KeyedCollection2(Func<TItem, TKey> getKeyForItemFunction) : base()
        {
            if (getKeyForItemFunction == null) throw new ArgumentNullException(DelegateNullExceptionMessage);
            _getKeyForItemFunction = getKeyForItemFunction;
        }

        public KeyedCollection2(Func<TItem, TKey> getKeyForItemDelegate, IEqualityComparer<TKey> comparer) : base(comparer)
        {
            if (getKeyForItemDelegate == null) throw new ArgumentNullException(DelegateNullExceptionMessage);
            _getKeyForItemFunction = getKeyForItemDelegate;
        }

        protected override TKey GetKeyForItem(TItem item)
        {
            return _getKeyForItemFunction(item);
        }

        public void SortByKeys()
        {
            var comparer = Comparer<TKey>.Default;
            SortByKeys(comparer);
        }

        public void SortByKeys(IComparer<TKey> keyComparer)
        {
            var comparer = new Comparer2<TItem>((x, y) => keyComparer.Compare(GetKeyForItem(x), GetKeyForItem(y)));
            Sort(comparer);
        }

        public void SortByKeys(Comparison<TKey> keyComparison)
        {
            var comparer = new Comparer2<TItem>((x, y) => keyComparison(GetKeyForItem(x), GetKeyForItem(y)));
            Sort(comparer);
        }

        public void Sort()
        {
            var comparer = Comparer<TItem>.Default;
            Sort(comparer);
        }

        public void Sort(Comparison<TItem> comparison)
        {
            var newComparer = new Comparer2<TItem>((x, y) => comparison(x, y));
            Sort(newComparer);
        }

        public void Sort(IComparer<TItem> comparer)
        {
            List<TItem> list = base.Items as List<TItem>;
            if (list != null)
            {
                list.Sort(comparer);
            }
        }
    }

    public interface IOrderedDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IOrderedDictionary
    {
        new TValue this[int index] { get; set; }
        new TValue this[TKey key] { get; set; }
        new int Count { get; }
        new ICollection<TKey> Keys { get; }
        new ICollection<TValue> Values { get; }
        new void Add(TKey key, TValue value);
        new void Clear();
        void Insert(int index, TKey key, TValue value);
        int IndexOf(TKey key);
        bool ContainsValue(TValue value);
        bool ContainsValue(TValue value, IEqualityComparer<TValue> comparer);
        new bool ContainsKey(TKey key);
        new IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator();
        new bool Remove(TKey key);
        new void RemoveAt(int index);
        new bool TryGetValue(TKey key, out TValue value);
        TValue GetValue(TKey key);
        void SetValue(TKey key, TValue value);
        KeyValuePair<TKey, TValue> GetItem(int index);
        void SetItem(int index, TValue value);
    }

    /// <summary>
    /// A dictionary object that allows rapid hash lookups using keys, but also
    /// maintains the key insertion order so that values can be retrieved by
    /// key index.
    /// </summary>
    public class TMap<TKey, TValue> : IOrderedDictionary<TKey, TValue>
    {
        #region Fields/Properties

        private KeyedCollection2<TKey, KeyValuePair<TKey, TValue>> _keyedCollection;

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key associated with the value to get or set.</param>
        public TValue this[TKey key]
        {
            get
            {
                return GetValue(key);
            }
            set
            {
                SetValue(key, value);
            }
        }

        /// <summary>
        /// Gets or sets the value at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to get or set.</param>
        public TValue this[int index]
        {
            get
            {
                return GetItem(index).Value;
            }
            set
            {
                SetItem(index, value);
            }
        }

        /// <summary>
        /// Gets the number of items in the dictionary
        /// </summary>
        public int Count
        {
            get { return _keyedCollection.Count; }
        }

        /// <summary>
        /// Gets all the keys in the ordered dictionary in their proper order.
        /// </summary>
        public ICollection<TKey> Keys
        {
            get
            {
                return _keyedCollection.Select(x => x.Key).ToList();
            }
        }

        /// <summary>
        /// Gets all the values in the ordered dictionary in their proper order.
        /// </summary>
        public ICollection<TValue> Values
        {
            get
            {
                return _keyedCollection.Select(x => x.Value).ToList();
            }
        }

        /// <summary>
        /// Gets the key comparer for this dictionary
        /// </summary>
        public IEqualityComparer<TKey> Comparer
        {
            get;
            private set;
        }

        #endregion
        
        #region Constructors

        public TMap()
        {
            Initialize();
        }

        public TMap(IEqualityComparer<TKey> comparer)
        {
            Initialize(comparer);
        }

        public TMap(IOrderedDictionary<TKey, TValue> dictionary)
        {
            Initialize();
            foreach (KeyValuePair<TKey, TValue> pair in dictionary)
            {
                _keyedCollection.Add(pair);
            }
        }

        public TMap(IOrderedDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey> comparer)
        {
            Initialize(comparer);
            foreach (KeyValuePair<TKey, TValue> pair in dictionary)
            {
                _keyedCollection.Add(pair);
            }
        }

        public TMap(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            Initialize();
            foreach (KeyValuePair<TKey, TValue> pair in items)
            {
                _keyedCollection.Add(pair);
            }
        }

        public TMap(IEnumerable<KeyValuePair<TKey, TValue>> items, IEqualityComparer<TKey> comparer)
        {
            Initialize(comparer);
            foreach (KeyValuePair<TKey, TValue> pair in items)
            {
                _keyedCollection.Add(pair);
            }
        }

        #endregion

        #region Methods

        private void Initialize(IEqualityComparer<TKey> comparer = null)
        {
            this.Comparer = comparer;
            if (comparer != null)
            {
                _keyedCollection = new KeyedCollection2<TKey, KeyValuePair<TKey, TValue>>(x => x.Key, comparer);
            }
            else
            {
                _keyedCollection = new KeyedCollection2<TKey, KeyValuePair<TKey, TValue>>(x => x.Key);
            }
        }

        /// <summary>
        /// Adds the specified key and value to the dictionary.
        /// </summary>
        /// <param name="key">The key of the element to add.</param>
        /// <param name="value">The value of the element to add.  The value can be null for reference types.</param>
        public void Add(TKey key, TValue value)
        {
            _keyedCollection.Add(new KeyValuePair<TKey, TValue>(key, value));
        }

        /// <summary>
        /// Removes all keys and values from this object.
        /// </summary>
        public void Clear()
        {
            _keyedCollection.Clear();
        }

        /// <summary>
        /// Inserts a new key-value pair at the index specified.
        /// </summary>
        /// <param name="index">The insertion index.  This value must be between 0 and the count of items in this object.</param>
        /// <param name="key">A unique key for the element to add</param>
        /// <param name="value">The value of the element to add.  Can be null for reference types.</param>
        public void Insert(int index, TKey key, TValue value)
        {
            _keyedCollection.Insert(index, new KeyValuePair<TKey, TValue>(key, value));
        }

        /// <summary>
        /// Gets the index of the key specified.
        /// </summary>
        /// <param name="key">The key whose index will be located</param>
        /// <returns>Returns the index of the key specified if found.  Returns -1 if the key could not be located.</returns>
        public int IndexOf(TKey key)
        {
            if (_keyedCollection.Contains(key))
            {
                return _keyedCollection.IndexOf(_keyedCollection[key]);
            }
            else
            {
                return -1;
            }
        }

        /// <summary>
        /// Determines whether this object contains the specified value.
        /// </summary>
        /// <param name="value">The value to locate in this object.</param>
        /// <returns>True if the value is found.  False otherwise.</returns>
        public bool ContainsValue(TValue value)
        {
            return this.Values.Contains(value);
        }

        /// <summary>
        /// Determines whether this object contains the specified value.
        /// </summary>
        /// <param name="value">The value to locate in this object.</param>
        /// <param name="comparer">The equality comparer used to locate the specified value in this object.</param>
        /// <returns>True if the value is found.  False otherwise.</returns>
        public bool ContainsValue(TValue value, IEqualityComparer<TValue> comparer)
        {
            return this.Values.Contains(value, comparer);
        }

        /// <summary>
        /// Determines whether this object contains the specified key.
        /// </summary>
        /// <param name="key">The key to locate in this object.</param>
        /// <returns>True if the key is found.  False otherwise.</returns>
        public bool ContainsKey(TKey key)
        {
            return _keyedCollection.Contains(key);
        }

        /// <summary>
        /// Returns the KeyValuePair at the index specified.
        /// </summary>
        /// <param name="index">The index of the KeyValuePair desired</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown when the index specified does not refer to a KeyValuePair in this object
        /// </exception>
        public KeyValuePair<TKey, TValue> GetItem(int index)
        {
            if (index < 0 || index >= _keyedCollection.Count)
            {
                throw new ArgumentException("The index was outside the bounds of the dictionary: {0}".FormatWith(index));
            }
            return _keyedCollection[index];
        }

        /// <summary>
        /// Sets the value at the index specified.
        /// </summary>
        /// <param name="index">The index of the value desired</param>
        /// <param name="value">The value to set</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown when the index specified does not refer to a KeyValuePair in this object
        /// </exception>
        public void SetItem(int index, TValue value)
        {
            if (index < 0 || index >= _keyedCollection.Count)
            {
                throw new ArgumentException("The index is outside the bounds of the dictionary: {0}".FormatWith(index));
            }
            var kvp = new KeyValuePair<TKey, TValue>(_keyedCollection[index].Key, value);
            _keyedCollection[index] = kvp;
        }

        /// <summary>
        /// Returns an enumerator that iterates through all the KeyValuePairs in this object.
        /// </summary>
        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            return _keyedCollection.GetEnumerator();
        }

        /// <summary>
        /// Removes the key-value pair for the specified key.
        /// </summary>
        /// <param name="key">The key to remove from the dictionary.</param>
        /// <returns>True if the item specified existed and the removal was successful.  False otherwise.</returns>
        public bool Remove(TKey key)
        {
            return _keyedCollection.Remove(key);
        }

        /// <summary>
        /// Removes the key-value pair at the specified index.
        /// </summary>
        /// <param name="index">The index of the key-value pair to remove from the dictionary.</param>
        public void RemoveAt(int index)
        {
            if (index < 0 || index >= _keyedCollection.Count)
            {
                throw new ArgumentException("The index was outside the bounds of the dictionary: {0}".FormatWith(index));
            }
            _keyedCollection.RemoveAt(index);
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key associated with the value to get.</param>
        public TValue GetValue(TKey key)
        {
            if (_keyedCollection.Contains(key) == false)
            {
                throw new ArgumentException("The given key is not present in the dictionary: {0}".FormatWith(key));
            }
            var kvp = _keyedCollection[key];
            return kvp.Value;
        }

        /// <summary>
        /// Sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key associated with the value to set.</param>
        /// <param name="value">The the value to set.</param>
        public void SetValue(TKey key, TValue value)
        {
            var kvp = new KeyValuePair<TKey, TValue>(key, value);
            var idx = IndexOf(key);
            if (idx > -1)
            {
                _keyedCollection[idx] = kvp;
            }
            else
            {
                _keyedCollection.Add(kvp);
            }
        }

        /// <summary>
        /// Tries to get the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key of the desired element.</param>
        /// <param name="value">
        /// When this method returns, contains the value associated with the specified key if
        /// that key was found.  Otherwise it will contain the default value for parameter's type.
        /// This parameter should be provided uninitialized.
        /// </param>
        /// <returns>True if the value was found.  False otherwise.</returns>
        /// <remarks></remarks>
        public bool TryGetValue(TKey key, out TValue value)
        {
            if (_keyedCollection.Contains(key))
            {
                value = _keyedCollection[key].Value;
                return true;
            }
            else
            {
                value = default(TValue);
                return false;
            }
        }

        #endregion

        #region Sorting
        public void SortKeys()
        {
            _keyedCollection.SortByKeys();
        }

        public void SortKeys(IComparer<TKey> comparer)
        {
            _keyedCollection.SortByKeys(comparer);
        }

        public void SortKeys(Comparison<TKey> comparison)
        {
            _keyedCollection.SortByKeys(comparison);
        }

        public void SortValues()
        {
            var comparer = Comparer<TValue>.Default;
            SortValues(comparer);
        }

        public void SortValues(IComparer<TValue> comparer)
        {
            _keyedCollection.Sort((x, y) => comparer.Compare(x.Value, y.Value));
        }

        public void SortValues(Comparison<TValue> comparison)
        {
            _keyedCollection.Sort((x, y) => comparison(x.Value, y.Value));
        }
        #endregion

        #region IDictionary<TKey, TValue>

        void IDictionary<TKey, TValue>.Add(TKey key, TValue value)
        {
            Add(key, value);
        }

        bool IDictionary<TKey, TValue>.ContainsKey(TKey key)
        {
            return ContainsKey(key);
        }

        ICollection<TKey> IDictionary<TKey, TValue>.Keys
        {
            get { return Keys; }
        }

        bool IDictionary<TKey, TValue>.Remove(TKey key)
        {
            return Remove(key);
        }

        bool IDictionary<TKey, TValue>.TryGetValue(TKey key, out TValue value)
        {
            return TryGetValue(key, out value);
        }

        ICollection<TValue> IDictionary<TKey, TValue>.Values
        {
            get { return Values; }
        }

        TValue IDictionary<TKey, TValue>.this[TKey key]
        {
            get
            {
                return this[key];
            }
            set
            {
                this[key] = value;
            }
        }

        #endregion

        #region ICollection<KeyValuePair<TKey, TValue>>

        void ICollection<KeyValuePair<TKey, TValue>>.Add(KeyValuePair<TKey, TValue> item)
        {
            _keyedCollection.Add(item);
        }

        void ICollection<KeyValuePair<TKey, TValue>>.Clear()
        {
            _keyedCollection.Clear();
        }

        bool ICollection<KeyValuePair<TKey, TValue>>.Contains(KeyValuePair<TKey, TValue> item)
        {
            return _keyedCollection.Contains(item);
        }

        void ICollection<KeyValuePair<TKey, TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
        {
            _keyedCollection.CopyTo(array, arrayIndex);
        }

        int ICollection<KeyValuePair<TKey, TValue>>.Count
        {
            get { return _keyedCollection.Count; }
        }

        bool ICollection<KeyValuePair<TKey, TValue>>.IsReadOnly
        {
            get { return false; }
        }

        bool ICollection<KeyValuePair<TKey, TValue>>.Remove(KeyValuePair<TKey, TValue> item)
        {
            return _keyedCollection.Remove(item);
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>>

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        #region IEnumerable

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        #region IOrderedDictionary

        IDictionaryEnumerator IOrderedDictionary.GetEnumerator()
        {
            return new DictionaryEnumerator<TKey, TValue>(this);
        }

        void IOrderedDictionary.Insert(int index, object key, object value)
        {
            Insert(index, (TKey)key, (TValue)value);
        }

        void IOrderedDictionary.RemoveAt(int index)
        {
            RemoveAt(index);
        }

        object IOrderedDictionary.this[int index]
        {
            get
            {
                return this[index];
            }
            set
            {
                this[index] = (TValue)value;
            }
        }

        #endregion

        #region IDictionary

        void IDictionary.Add(object key, object value)
        {
            Add((TKey)key, (TValue)value);
        }

        void IDictionary.Clear()
        {
            Clear();
        }

        bool IDictionary.Contains(object key)
        {
            return _keyedCollection.Contains((TKey)key);
        }

        IDictionaryEnumerator IDictionary.GetEnumerator()
        {
            return new DictionaryEnumerator<TKey, TValue>(this);
        }

        bool IDictionary.IsFixedSize
        {
            get { return false; }
        }

        bool IDictionary.IsReadOnly
        {
            get { return false; }
        }

        ICollection IDictionary.Keys
        {
            get { return (ICollection)this.Keys; }
        }

        void IDictionary.Remove(object key)
        {
            Remove((TKey)key);
        }

        ICollection IDictionary.Values
        {
            get { return (ICollection)this.Values; }
        }

        object IDictionary.this[object key]
        {
            get
            {
                return this[(TKey)key];
            }
            set
            {
                this[(TKey)key] = (TValue)value;
            }
        }

        #endregion

        #region ICollection

        void ICollection.CopyTo(Array array, int index)
        {
            ((ICollection)_keyedCollection).CopyTo(array, index);
        }

        int ICollection.Count
        {
            get { return ((ICollection)_keyedCollection).Count; }
        }

        bool ICollection.IsSynchronized
        {
            get { return ((ICollection)_keyedCollection).IsSynchronized; }
        }

        object ICollection.SyncRoot
        {
            get { return ((ICollection)_keyedCollection).SyncRoot; }
        }

        #endregion
    }
}
```

`UAssetAPI/UnrealTypes/UE4VersionToObjectVersion.cs`:

```cs
namespace UAssetAPI.UnrealTypes
{
    public enum UE4VersionToObjectVersion
    {
        VER_UE4_0 = 342,
        VER_UE4_1 = 352,
        VER_UE4_2 = 363,
        VER_UE4_3 = 382,
        VER_UE4_4 = 385,
        VER_UE4_5 = 401,
        VER_UE4_6 = 413,
        VER_UE4_7 = 434,
        VER_UE4_8 = 451,
        VER_UE4_9 = 482,
        VER_UE4_10 = 482,
        VER_UE4_11 = 498,
        VER_UE4_12 = 504,
        VER_UE4_13 = 505,
        VER_UE4_14 = 508,
        VER_UE4_15 = 510,
        VER_UE4_16 = 513,
        VER_UE4_17 = 513,
        VER_UE4_18 = 514,
        VER_UE4_19 = 516,
        VER_UE4_20 = 516,
        VER_UE4_21 = 517,
        VER_UE4_22 = 517,
        VER_UE4_23 = 517,
        VER_UE4_24 = 518,
        VER_UE4_25 = 518,
        VER_UE4_26 = 519,
        VER_UE4_27 = 522,
        VER_UE5_0EA = 522,
        VER_UE5_0 = 522,
        VER_UE5_1 = 522,
        VER_UE5_2 = 522,
        VER_UE5_3 = 522,
        VER_UE5_4 = 522,
        VER_UE5_5 = 522,
        VER_UE5_6 = 522,
        VER_UE5_7 = 522,
    }

    public enum UE5VersionToObjectVersion
    {
        VER_UE5_0_EA = 1002,
        VER_UE5_0 = 1004,
        VER_UE5_1 = 1008,
        VER_UE5_2 = 1009,
        VER_UE5_3 = 1009,
        VER_UE5_4 = 1012,
        VER_UE5_5 = 1013,
        VER_UE5_6 = 1017,
        VER_UE5_7 = 1017,
    }
}

```

`UAssetAPI/Unversioned/FFragment.cs`:

```cs
using System;

namespace UAssetAPI.Unversioned
{
    /// <summary>
    /// Unversioned header fragment.
    /// </summary>
    public class FFragment
    {
        /// <summary>
        /// Number of properties to skip before values.
        /// </summary>
        public int SkipNum;

        /// <summary>
        /// Number of subsequent property values stored.
        /// </summary>
        public int ValueNum = 0;

        /// <summary>
        /// Is this the last fragment of the header?
        /// </summary>
        public bool bIsLast = false;

        public int FirstNum = -1;
        public int LastNum
        {
            get
            {
                return FirstNum + ValueNum - 1;
            }
        }

        public bool bHasAnyZeroes = false;

        internal static readonly byte SkipMax = 127;
        internal static readonly byte ValueMax = 127;
        internal static readonly uint SkipNumMask = 0x007fu;
        internal static readonly uint HasZeroMask = 0x0080u;
        internal static readonly int ValueNumShift = 9;
        internal static readonly uint IsLastMask = 0x0100u;

        public override string ToString()
        {
            return "{" + SkipNum + "," + ValueNum + "," + bHasAnyZeroes + "," + bIsLast + "}";
        }

        public ushort Pack()
        {
            if (SkipNum > SkipMax) throw new InvalidOperationException("Skip num " + SkipNum + " is greater than maximum possible value " + SkipMax);
            if (ValueNum > ValueMax) throw new InvalidOperationException("Value num " + ValueNum + " is greater than maximum possible value " + ValueMax);
            return (ushort)((byte)SkipNum | (bHasAnyZeroes ? HasZeroMask : 0) | (ushort)((byte)ValueNum << ValueNumShift) | (bIsLast ? IsLastMask : 0));
        }

        /// <summary>
        /// Used for debugging
        /// </summary>
        internal string PackedForm => BitConverter.ToString(BitConverter.GetBytes(Pack()));

        public static FFragment Unpack(ushort Int)
        {
            FFragment Fragment = new FFragment();
            Fragment.SkipNum = (byte)(Int & SkipNumMask);
            Fragment.bHasAnyZeroes = (Int & HasZeroMask) != 0;
            Fragment.ValueNum = (byte)(Int >> ValueNumShift);
            Fragment.bIsLast = (Int & IsLastMask) != 0;
            return Fragment;
        }

        public static FFragment GetFromBounds(int LastNumBefore, int FirstNum, int LastNum, bool hasAnyZeros, bool isLast) // for 1st fragment: LastNumBefore = -1
        {
            FFragment Fragment = new FFragment();
            Fragment.SkipNum = FirstNum - LastNumBefore - 1;
            Fragment.ValueNum = LastNum - FirstNum + 1;
            Fragment.bHasAnyZeroes = hasAnyZeros;
            Fragment.bIsLast = isLast;

            Fragment.FirstNum = FirstNum;
            return Fragment;
        }

        public FFragment()
        {

        }

        public FFragment(int skipNum, int valueNum, bool bIsLast, bool bHasAnyZeroes, int firstNum = -1) // specifying firstNum is not usually necessary
        {
            SkipNum = skipNum;
            ValueNum = valueNum;
            this.bIsLast = bIsLast;
            this.bHasAnyZeroes = bHasAnyZeroes;
            this.FirstNum = firstNum;
        }
    }
}

```

`UAssetAPI/Unversioned/FUnversionedHeader.cs`:

```cs
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;

namespace UAssetAPI.Unversioned
{
    // https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Source/Runtime/CoreUObject/Private/Serialization/UnversionedPropertySerialization.cpp#L414

    /// <summary>
    /// List of serialized property indices and which of them are non-zero.
    /// Serialized as a stream of 16-bit skip-x keep-y fragments and a zero bitmask.
    /// </summary>
    public class FUnversionedHeader
    {
        public LinkedList<FFragment> Fragments;
        public LinkedListNode<FFragment> CurrentFragment;
        public int UnversionedPropertyIndex = 0;
        public int ZeroMaskIndex = 0;
        public uint ZeroMaskNum = 0;
        public BitArray ZeroMask;
        public bool bHasNonZeroValues = false;

        public void Read(AssetBinaryReader reader)
        {
            if (!reader.Asset.HasUnversionedProperties) return;
            Fragments = new LinkedList<FFragment>();

            FFragment Fragment;
            uint UnmaskedNum = 0;
            int firstNum = 0;
            do
            {
                Fragment = FFragment.Unpack(reader.ReadUInt16());
                Fragment.FirstNum = firstNum + Fragment.SkipNum;
                firstNum = firstNum + Fragment.SkipNum + Fragment.ValueNum;
                Fragments.AddLast(Fragment);
#if DEBUGVERBOSE
                Debug.WriteLine("R: " + Fragment);
#endif

                if (Fragment.bHasAnyZeroes)
                {
                    ZeroMaskNum += (uint)Fragment.ValueNum;
                }
                else
                {
                    UnmaskedNum += (uint)Fragment.ValueNum;
                }
            }
            while (!Fragment.bIsLast);

            if (ZeroMaskNum > 0)
            {
                LoadZeroMaskData(reader, ZeroMaskNum);
                bHasNonZeroValues = UnmaskedNum > 0 || !CheckIfZeroMaskIsAllOnes();
            }
            else
            {
                ZeroMask = new BitArray(0);
                bHasNonZeroValues = UnmaskedNum > 0;
            }

            CurrentFragment = Fragments.First;
            UnversionedPropertyIndex = CurrentFragment.Value.FirstNum;
        }

        public void LoadZeroMaskData(AssetBinaryReader reader, uint NumBits)
        {
            if (NumBits <= 8)
            {
                ZeroMask = new BitArray(reader.ReadBytes(1));
            }
            else if (NumBits <= 16)
            {
                ZeroMask = new BitArray(reader.ReadBytes(2));
            }
            else
            {
                int numWords = UAPUtils.DivideAndRoundUp((int)NumBits, 32);
                int[] intData = new int[numWords];
                for (int i = 0; i < numWords; i++)
                {
                    intData[i] = reader.ReadInt32();
                }
                ZeroMask = new BitArray(intData);
            }
        }

        public byte[] SaveZeroMaskData()
        {
            int NumBits = ZeroMask.Length;

            byte[] res;
            if (NumBits <= 8)
            {
                res = new byte[1];
            }
            else if (NumBits <= 16)
            {
                res = new byte[2];
            }
            else
            {
                int numWords = UAPUtils.DivideAndRoundUp(NumBits, 32);
                res = new byte[numWords * sizeof(int)];
            }

            ZeroMask.CopyTo(res, 0);
            return res;
        }

        public bool CheckIfZeroMaskIsAllOnes()
        {
            for (int i = 0; i < ZeroMask.Length; i++)
            {
                if (!ZeroMask[i]) return false;
            }
            return true;
        }

        public void Write(AssetBinaryWriter writer)
        {
            if (!writer.Asset.HasUnversionedProperties) return;
            foreach (FFragment Fragment in Fragments)
            {
                writer.Write(Fragment.Pack());
            }

            if (ZeroMask.Length > 0)
            {
                writer.Write(SaveZeroMaskData());
            }
        }

        public bool HasValues()
        {
            return bHasNonZeroValues | (ZeroMask.Length > 0);
        }

        public bool HasNonZeroValues()
        {
            return bHasNonZeroValues;
        }

        public FUnversionedHeader(AssetBinaryReader reader)
        {
            Read(reader);
        }

        public FUnversionedHeader()
        {

        }
    }
}

```

`UAssetAPI/Unversioned/Oodle.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;

namespace UAssetAPI.Unversioned
{
    public class Oodle
    {
        // oodle download link is broken
        public const string OODLE_DOWNLOAD_LINK = "https://cdn.discordapp.com/attachments/817251677086285848/992648087371792404/oo2core_9_win64.dll";
        public const string OODLE_DLL_NAME = @"oo2core_9_win64.dll";
        private static Regex RemoveFilePrefixRegex = new Regex(@"^file:?[\\\/]+", RegexOptions.Compiled | RegexOptions.IgnoreCase);

        [DllImport(OODLE_DLL_NAME)]
        private static extern int OodleLZ_Decompress(byte[] buffer, long bufferSize, byte[] outputBuffer, long outputBufferSize, uint a, uint b, ulong c, uint d, uint e, uint f, uint g, uint h, uint i, uint threadModule);

        public static byte[] Decompress(byte[] buffer, int size, int uncompressedSize)
        {
            throw new NotImplementedException("Oodle decompression is no longer supported");

            /*var targetPath = Path.Combine(Path.GetDirectoryName(RemoveFilePrefixRegex.Replace(Assembly.GetAssembly(typeof(Oodle)).CodeBase, string.Empty)), OODLE_DLL_NAME);
            if (!File.Exists(targetPath))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(targetPath));
                using (var client = new WebClient())
                {
                    client.DownloadFile(OODLE_DOWNLOAD_LINK, targetPath);
                }
            }

            byte[] decompressedBuffer = new byte[uncompressedSize];
            int decompressedCount = OodleLZ_Decompress(buffer, size, decompressedBuffer, uncompressedSize, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3);

            if (decompressedCount == uncompressedSize)
            {
                return decompressedBuffer;
            }
            else if (decompressedCount < uncompressedSize)
            {
                return decompressedBuffer.Take(decompressedCount).ToArray();
            }

            return new byte[0];*/
        }
    }
}

```

`UAssetAPI/Unversioned/SaveGame.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Unversioned
{
    public enum ESaveGameFileVersion
    {
        InitialVersion = 1,
        // serializing custom versions into the savegame data to handle that type of versioning
        AddedCustomVersions = 2,
        // added a new UE5 version number to FPackageFileSummary
        PackageFileSummaryVersionChange = 3,

        // -----<new versions can be added above this line>-------------------------------------------------
        VersionPlusOne,
        LatestVersion = VersionPlusOne - 1
    }

    public enum ECustomVersionSerializationFormat
    {
        Unknown,
        Guids,
        Enums,
        Optimized
    }

    /// <summary>
    /// Represents an Unreal save game file. Parsing is only implemented for engine and custom version data.
    /// </summary>
    public class SaveGame
    {
        /// <summary>
        /// The path of the file on disk.
        /// </summary>
        [JsonIgnore]
        public string FilePath = null;

        public ESaveGameFileVersion SaveGameFileVersion;
        public ObjectVersion ObjectVersion;
        public ObjectVersionUE5 ObjectVersionUE5;
        public FEngineVersion EngineVersion;

        public ECustomVersionSerializationFormat CustomVersionSerializationFormat;
        /// <summary>
        /// All the custom versions stored in the archive.
        /// </summary>
        public List<CustomVersion> CustomVersionContainer = null;

        /// <summary>
        /// Creates a MemoryStream from an asset path.
        /// </summary>
        /// <param name="p">The path to the input file.</param>
        /// <returns>A new MemoryStream that stores the binary data of the input file.</returns>
        public MemoryStream PathToStream(string p)
        {
            using (FileStream origStream = File.Open(p, FileMode.Open))
            {
                MemoryStream completeStream = new MemoryStream();
                origStream.CopyTo(completeStream);

                completeStream.Seek(0, SeekOrigin.Begin);
                return completeStream;
            }
        }

        /// <summary>
        /// Creates a BinaryReader from an asset path.
        /// </summary>
        /// <param name="p">The path to the input file.</param>
        /// <returns>A new BinaryReader that stores the binary data of the input file.</returns>
        public UnrealBinaryReader PathToReader(string p)
        {
            return new UnrealBinaryReader(PathToStream(p));
        }

        public static readonly byte[] SAVE_MAGIC = Encoding.ASCII.GetBytes("GVAS");
        /// <summary>
        /// Reads a save game from disk.
        /// <para/>
        /// Parsing is only implemented for engine and custom version data.
        /// </summary>
        /// <param name="reader">The binary reader to use.</param>
        public void Read(UnrealBinaryReader reader)
        {
            if (!reader.ReadBytes(SAVE_MAGIC.Length).SequenceEqual(SAVE_MAGIC)) throw new FormatException("Invalid save game magic");
            SaveGameFileVersion = (ESaveGameFileVersion)reader.ReadUInt32();
            ObjectVersion = (ObjectVersion)reader.ReadUInt32();
            if (SaveGameFileVersion >= ESaveGameFileVersion.PackageFileSummaryVersionChange) ObjectVersionUE5 = (ObjectVersionUE5)reader.ReadUInt32();
            EngineVersion = new FEngineVersion(reader);
            if (SaveGameFileVersion >= ESaveGameFileVersion.AddedCustomVersions)
            {
                CustomVersionSerializationFormat = (ECustomVersionSerializationFormat)reader.ReadUInt32();
                CustomVersionContainer = reader.ReadCustomVersionContainer(CustomVersionSerializationFormat);
            }
        }

        /// <summary>
        /// Patches a .usmap file to contain the versioning info within this save file.
        /// </summary>
        /// <param name="usmapPath">The path to the .usmap file to patch.</param>
        public void PatchUsmap(string usmapPath)
        {
            byte[] restOfData = new byte[0];
            UsmapVersion ver = UsmapVersion.Initial;
            using (FileStream origStream = File.Open(usmapPath, FileMode.Open))
            {
                UnrealBinaryReader reader = new UnrealBinaryReader(origStream);

                reader.BaseStream.Seek(0, SeekOrigin.Begin);
                ushort fileSignature = reader.ReadUInt16();
                if (fileSignature != Usmap.USMAP_MAGIC) throw new FormatException(".usmap: File signature mismatch");

                ver = (UsmapVersion)reader.ReadByte();
                if (ver < UsmapVersion.Initial || ver > UsmapVersion.Latest) throw new FormatException(".usmap: Unknown file version " + ver);
                if (ver >= UsmapVersion.PackageVersioning)
                {
                    bool bHasVersioning = reader.ReadInt32() > 0;
                    if (bHasVersioning)
                    {
                        reader.ReadUInt32();
                        reader.ReadUInt32();
                        reader.ReadCustomVersionContainer(ECustomVersionSerializationFormat.Optimized);
                        reader.ReadUInt32();
                    }
                }

                restOfData = reader.ReadBytes((int)(reader.BaseStream.Length - reader.BaseStream.Position));
            }

            if (ver < UsmapVersion.PackageVersioning) ver = UsmapVersion.PackageVersioning;

            using (FileStream origStream = File.Open(usmapPath, FileMode.Create))
            {
                UnrealBinaryWriter writer = new UnrealBinaryWriter(origStream);

                writer.Seek(0, SeekOrigin.Begin);
                writer.Write(Usmap.USMAP_MAGIC);
                writer.Write((byte)ver);
                writer.Write((int)1);
                writer.Write((uint)ObjectVersion);
                writer.Write((uint)ObjectVersionUE5);
                writer.WriteCustomVersionContainer(ECustomVersionSerializationFormat.Optimized, CustomVersionContainer);
                writer.Write(EngineVersion.Changelist);
                writer.Write(restOfData); 
            }
        }

        /// <summary>
        /// Reads a save game from disk and initializes a new instance of the <see cref="SaveGame"/> class to store its data in memory.
        /// <para/>
        /// Parsing is only implemented for engine and custom version data.
        /// </summary>
        /// <param name="path">The path of the .sav file on disk that this instance will read from.</param>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        public SaveGame(string path)
        {
            FilePath = path;
            Read(PathToReader(FilePath));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SaveGame"/> class. This instance will store no file data and does not represent any file in particular until the <see cref="Read"/> method is manually called.
        /// </summary>
        public SaveGame()
        {

        }
    }
}

```

`UAssetAPI/Unversioned/Usmap.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UAssetAPI.CustomVersions;
using UAssetAPI.ExportTypes;
using UAssetAPI.FieldTypes;
using UAssetAPI.PropertyTypes.Objects;
using UAssetAPI.UnrealTypes;

namespace UAssetAPI.Unversioned
{
    public class UsmapSchemaPropertiesJsonConverter : JsonConverter<IReadOnlyDictionary<int, UsmapProperty>>
    {
        public override IReadOnlyDictionary<int, UsmapProperty> ReadJson(JsonReader reader, Type objectType, IReadOnlyDictionary<int, UsmapProperty> existingValue, bool hasExistingValue, JsonSerializer serializer)
        {
            return null;
        }

        public override void WriteJson(JsonWriter writer, IReadOnlyDictionary<int, UsmapProperty> value, JsonSerializer serializer)
        {
            writer.WriteStartObject();
            foreach (KeyValuePair<int, UsmapProperty> entry in value)
            {
                if (entry.Value == null) continue;
                writer.WritePropertyName(entry.Value.Name);
                serializer.Serialize(writer, entry.Value.PropertyData?.ToString() ?? "null");
            }
            writer.WriteEndObject();
        }
    }


    public enum UsmapVersion : byte
    {
        /// <summary>
        /// Initial format.
        /// </summary>
        Initial,

        /// <summary>
        /// Adds optional asset package versioning
        /// </summary>
        PackageVersioning,

        /// <summary>
        /// 16-bit wide names in name map
        /// </summary>
        LongFName,

        /// <summary>
        /// 16-bit enum entry count
        /// </summary>
        LargeEnums,

        /// <summary>
        /// Adds enum values (instead of assuming ordinal)
        /// </summary>
        ExplicitEnumValues,

        LatestPlusOne,
        Latest = LatestPlusOne - 1
    }

    public enum UsmapExtensionLayoutVersion : byte
    {
        /// <summary>
        /// Initial format.
        /// </summary>
        Initial
    }

    public enum UsmapStructKind : byte
    {
        None = 0,
        UScriptStruct = 1,
        UClass = 2,
    }

    public enum ECompressionMethod : byte
    {
        None,
        Oodle,
        Brotli,
        ZStandard,

        Unknown = 0xFF
    };

    public enum EPropertyType
    {
        ByteProperty,
        BoolProperty,
        IntProperty,
        FloatProperty,
        ObjectProperty,
        NameProperty,
        DelegateProperty,
        DoubleProperty,
        ArrayProperty,
        StructProperty,
        StrProperty,
        TextProperty,
        InterfaceProperty,
        MulticastDelegateProperty,
        WeakObjectProperty, //
        LazyObjectProperty, // When deserialized, these 3 properties will be SoftObjects
        AssetObjectProperty, //
        SoftObjectProperty,
        UInt64Property,
        UInt32Property,
        UInt16Property,
        Int64Property,
        Int16Property,
        Int8Property,
        MapProperty,
        SetProperty,
        EnumProperty,
        FieldPathProperty,
        OptionalProperty,
        Utf8StrProperty,
        AnsiStrProperty,

        Unknown = 0xFF
    };

    public class UsmapMapData : UsmapPropertyData
    {
        public UsmapPropertyData InnerType;
        public UsmapPropertyData ValueType;

        public UsmapMapData()
        {
            Type = EPropertyType.MapProperty;
        }
        public override string ToString()
        {
            return base.ToString() + "<" + InnerType.ToString() + ", " + ValueType.ToString() + ">";
        }

    }

    public class UsmapArrayData : UsmapPropertyData
    {
        public UsmapPropertyData InnerType;

        public UsmapArrayData(EPropertyType type) // array or map
        {
            Type = type;
        }

        public override string ToString()
        {
            return base.ToString() + "<" + InnerType.ToString() + ">";
        }
    }

    public class UsmapStructData : UsmapPropertyData
    {
        public string StructType;

        public UsmapStructData(string structType)
        {
            StructType = structType;
            Type = EPropertyType.StructProperty;
        }

        public UsmapStructData()
        {
            Type = EPropertyType.StructProperty;
        }

        public override string ToString()
        {
            return base.ToString() + "<" + StructType + ">";
        }
    }

    public class UsmapEnumData : UsmapPropertyData
    {
        public UsmapPropertyData InnerType;
        public string Name;
        public List<string> Values;

        public UsmapEnumData(string name, List<string> values)
        {
            Name = name;
            Values = values;
            Type = EPropertyType.EnumProperty;
        }

        public UsmapEnumData()
        {
            Type = EPropertyType.EnumProperty;
        }

        public override string ToString()
        {
            return base.ToString() + "<" + Name + "<" + InnerType.ToString() + ">>";
        }
    }

    public class UsmapPropertyData
    {
        public EPropertyType Type = EPropertyType.Unknown;

        public UsmapPropertyData(EPropertyType type)
        {
            Type = type;
        }

        public UsmapPropertyData()
        {

        }

        public override string ToString()
        {
            return Type.ToString();
        }
    }

    public class UsmapProperty : ICloneable
    {
        public string Name;
        public ushort SchemaIndex;
        public ushort ArrayIndex; // not serialized
        public byte ArraySize;
        [JsonConverter(typeof(StringEnumConverter))]
        public EPropertyFlags PropertyFlags;
        public UsmapPropertyData PropertyData;

        public UsmapProperty(string name, ushort schemaIndex, ushort arrayIndex, byte arraySize, UsmapPropertyData propertyData)
        {
            Name = name;
            SchemaIndex = schemaIndex;
            ArrayIndex = arrayIndex;
            ArraySize = arraySize;
            PropertyData = propertyData;
        }

        public object Clone()
        {
            return new UsmapProperty(Name, SchemaIndex, ArrayIndex, ArraySize, PropertyData);
        }

        public override string ToString()
        {
            return Name + " : " + SchemaIndex + " : " + ArrayIndex + " : " + ArraySize + " : (" + PropertyData.ToString() + ")";
        }
    }

    internal class PropertyMapComparer : IEqualityComparer<Tuple<string, int>>
    {
        public StringComparer Comparer;

        public bool Equals(Tuple<string, int> lhs, Tuple<string, int> rhs)
        {
            return Comparer.Equals(lhs.Item1, rhs.Item1) && lhs.Item2 == rhs.Item2;
        }

        public int GetHashCode(Tuple<string, int> tuple)
        {
            return Comparer.GetHashCode(tuple.Item1) ^ tuple.Item2.GetHashCode();
        }
    }

    public class UsmapSchema
    {
        public string Name;
        public string SuperType;
        public string SuperTypeModulePath;
        [JsonIgnore]
        public ushort PropCount;
        public string ModulePath;
        /// <summary>
        /// Whether or not this schema was retrieved from a .uasset file.
        /// </summary>
        [JsonIgnore]
        public bool FromAsset = false;

        [JsonConverter(typeof(UsmapSchemaPropertiesJsonConverter))]
        public IReadOnlyDictionary<int, UsmapProperty> Properties => properties;

        [JsonIgnore]
        private ConcurrentDictionary<int, UsmapProperty> properties;
        [JsonIgnore]
        private ConcurrentDictionary<Tuple<string, int>, UsmapProperty> propertiesMap;

        [JsonConverter(typeof(StringEnumConverter))]
        public UsmapStructKind StructKind;
        public int StructOrClassFlags;

        public UsmapProperty GetProperty(string key, int dupIndex)
        {
            var keyTuple = new Tuple<string, int>(key, dupIndex);
            return propertiesMap.ContainsKey(keyTuple) ? propertiesMap[keyTuple] : null;
        }

        public void ConstructPropertiesMap(bool isCaseInsensitive)
        {
            propertiesMap = new ConcurrentDictionary<Tuple<string, int>, UsmapProperty>(new PropertyMapComparer { Comparer = isCaseInsensitive ? StringComparer.InvariantCultureIgnoreCase : StringComparer.InvariantCulture });
            foreach (KeyValuePair<int, UsmapProperty> entry in properties)
            {
                propertiesMap[new Tuple<string, int>(entry.Value.Name, entry.Value.ArrayIndex)] = entry.Value;
            }
        }

        public UsmapSchema(string name, string superType, ushort propCount, ConcurrentDictionary<int, UsmapProperty> props, bool isCaseInsensitive, string superTypeModulePath, bool fromAsset = false)
        {
            Name = name;
            SuperType = superType;
            SuperTypeModulePath = superTypeModulePath;
            PropCount = propCount;
            properties = props;
            FromAsset = fromAsset;

            ConstructPropertiesMap(isCaseInsensitive);
        }

        public UsmapSchema()
        {

        }
    }

    public class UsmapEnum
    {
        public string Name;
        public string ModulePath;
        public int EnumFlags;
        public ConcurrentDictionary<long, string> Values;

        public UsmapEnum(string name, ConcurrentDictionary<long, string> values)
        {
            Name = name;
            Values = values;
        }

        public UsmapEnum()
        {

        }
    }


    public class Usmap
    {
        /// <summary>
        /// The path of the file on disk. This does not need to be specified for regular parsing.
        /// </summary>
        [JsonIgnore]
        public string FilePath;

        /// <summary>
        /// Magic number for the .usmap format
        /// </summary>
        [JsonIgnore]
        public static readonly ushort USMAP_MAGIC = 0x30C4;

        /// <summary>
        /// .usmap file version
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public UsmapVersion Version;

        /// <summary>
        /// Game UE4 object version
        /// </summary>
        public ObjectVersion FileVersionUE4;

        /// <summary>
        /// Game UE5 object version
        /// </summary>
        public ObjectVersionUE5 FileVersionUE5;

        /// <summary>
        /// All the custom versions stored in the archive.
        /// </summary>
        public List<CustomVersion> CustomVersionContainer = null;

        public uint NetCL;

        private bool _AreFNamesCaseInsensitive = true;
        /// <summary>
        /// Whether or not FNames are case insensitive. Modifying this property is an expensive operation, and will re-construct several dictionaries.
        /// </summary>
        public bool AreFNamesCaseInsensitive
        {
            get
            {
                return _AreFNamesCaseInsensitive;
            }
            set
            {
                if (value == _AreFNamesCaseInsensitive) return;
                _AreFNamesCaseInsensitive = value;

                var EnumMapNuevo = new Dictionary<string, UsmapEnum>(value ? StringComparer.InvariantCultureIgnoreCase : StringComparer.InvariantCulture);
                foreach (var entry in EnumMap) EnumMapNuevo.Add(entry.Key, entry.Value);
                EnumMap = EnumMapNuevo;

                var SchemasNuevo = new Dictionary<string, UsmapSchema>(value ? StringComparer.InvariantCultureIgnoreCase : StringComparer.InvariantCulture);
                foreach (var entry in Schemas)
                {
                    entry.Value.ConstructPropertiesMap(value);
                    SchemasNuevo.Add(entry.Key, entry.Value);
                }
                Schemas = SchemasNuevo;
            }
        }

        /// <summary>
        /// Whether or not to skip blueprint schemas serialized in this mappings file. Only useful for testing.
        /// </summary>
        [JsonIgnore]
        public bool SkipBlueprintSchemas = false;

        /// <summary>
        /// .usmap name map
        /// </summary>
        [JsonIgnore]
        public List<string> NameMap;

        /// <summary>
        /// .usmap enum map
        /// </summary>
        public IDictionary<string, UsmapEnum> EnumMap;

        /// <summary>
        /// .usmap schema map
        /// </summary>
        public IDictionary<string, UsmapSchema> Schemas;

        /// <summary>
        /// List of extensions that failed to parse.
        /// </summary>
        public List<string> FailedExtensions;

        /// <summary>
        /// Serialize this usmap as JSON. This should only be used for debugging or visualization.
        /// <para/>
        /// The serialized JSON is lossy and cannot be converted back into a complete .usmap file.
        /// </summary>
        /// <returns>The serialized JSON as a string.</returns>
        public string SerializeJSON(Formatting jsonFormatting = Formatting.None)
        {
            return JsonConvert.SerializeObject(this, jsonFormatting);
        }

        private static UsmapPropertyData ConvertFPropertyToUsmapPropertyData(StructExport exp, FProperty entry)
        {
            var typ = entry.GetUsmapPropertyType();
            UsmapPropertyData converted1;
            switch (typ)
            {
                case EPropertyType.EnumProperty:
                    {
                        FPackageIndex enumIndex = (entry as FEnumProperty).Enum;
                        var underlyingProp = (entry as FEnumProperty).UnderlyingProp;
                        if (enumIndex.IsExport())
                        {
                            var exp2 = enumIndex.ToExport<EnumExport>(exp.Asset);
                            var allNames = new List<string>();
                            foreach (var cosa in exp2.Enum.Names) allNames.Add(cosa.Item1.ToString());
                            converted1 = new UsmapEnumData(exp2.ObjectName.ToString(), allNames) { InnerType = ConvertFPropertyToUsmapPropertyData(exp, underlyingProp) };
                        }
                        else if (enumIndex.IsImport())
                        {
                            string enumName = enumIndex.ToImport(exp.Asset).ObjectName?.Value.Value;
                            if (string.IsNullOrEmpty(enumName) || !exp.Asset.Mappings.EnumMap.TryGetValue(enumName, out UsmapEnum value))
                            {
                                if (!exp.Asset.HasUnversionedProperties)
                                {
                                    return new UsmapEnumData(enumName, []) { InnerType = new UsmapPropertyData(EPropertyType.ByteProperty) };
                                }
                                else
                                {
                                    throw new InvalidOperationException("Attempt to index into non-existent enum " + enumName);
                                }
                            }
                            var allNames = new List<string>();
                            foreach (var cosa in value.Values) allNames.Add(cosa.ToString());
                            converted1 = new UsmapEnumData(enumName, allNames) { InnerType = ConvertFPropertyToUsmapPropertyData(exp, underlyingProp) };
                        }
                        else
                        {
                            converted1 = null;
                        }
                    }
                    break;
                case EPropertyType.ByteProperty:
                    {
                        FPackageIndex enumIndex = (entry as FByteProperty).Enum;
                        if (enumIndex.IsExport())
                        {
                            var exp2 = enumIndex.ToExport<EnumExport>(exp.Asset);
                            var allNames = new List<string>();
                            foreach (var cosa in exp2.Enum.Names) allNames.Add(cosa.Item1.ToString());
                            converted1 = new UsmapEnumData(exp2.ObjectName.ToString(), allNames) { InnerType = new UsmapPropertyData(EPropertyType.ByteProperty) };
                        }
                        else if (enumIndex.IsImport())
                        {
                            string enumName = enumIndex.ToImport(exp.Asset).ObjectName?.Value.Value;
                            if (string.IsNullOrEmpty(enumName) || !exp.Asset.Mappings.EnumMap.TryGetValue(enumName, out UsmapEnum value))
                            {
                                if (!exp.Asset.HasUnversionedProperties)
                                {
                                    return new UsmapEnumData(enumName, []) { InnerType = new UsmapPropertyData(EPropertyType.ByteProperty) };
                                }
                                else
                                {
                                    throw new InvalidOperationException("Attempt to index into non-existent enum " + enumName);
                                }
                            }
                            var allNames = new List<string>();
                            foreach (var cosa in value.Values) allNames.Add(cosa.ToString());
                            converted1 = new UsmapEnumData(enumName, allNames) { InnerType = new UsmapPropertyData(EPropertyType.ByteProperty) };
                        }
                        else
                        {
                            converted1 = new UsmapPropertyData(EPropertyType.ByteProperty); // this is most likely an InnerType of an EnumProperty
                        }
                    }
                    break;
                case EPropertyType.StructProperty:
                    var strucstr = Export.GetClassTypeForAncestry((entry as FStructProperty).Struct, exp.Asset, out _);
                    converted1 = new UsmapStructData(strucstr.ToString());
                    break;
                case EPropertyType.SetProperty:
                    converted1 = new UsmapArrayData(typ) { InnerType = ConvertFPropertyToUsmapPropertyData(exp, (entry as FSetProperty).ElementProp) };
                    break;
                case EPropertyType.ArrayProperty:
                    converted1 = new UsmapArrayData(typ) { InnerType = ConvertFPropertyToUsmapPropertyData(exp, (entry as FArrayProperty).Inner) };
                    break;
                case EPropertyType.MapProperty:
                    converted1 = new UsmapMapData()
                    { 
                        InnerType = ConvertFPropertyToUsmapPropertyData(exp, (entry as FMapProperty).KeyProp),
                        ValueType = ConvertFPropertyToUsmapPropertyData(exp, (entry as FMapProperty).ValueProp)
                    };
                    break;
                default:
                    converted1 = new UsmapPropertyData(typ);
                    break;
            }
            return converted1;
        }

        private static UsmapPropertyData ConvertUPropertyToUsmapPropertyData(PropertyExport exp)
        {
            var asset = exp.Asset;
            var typ = exp.Property.GetUsmapPropertyType();
            UsmapPropertyData converted;
            switch (exp.Property)
            {
                case UEnumProperty enumprop:
                    var enumIndex = enumprop.Enum;
                    var underlyingProp = enumprop.UnderlyingProp;
                    if (enumIndex.IsExport())
                    {
                        var exp2 = enumIndex.ToExport<EnumExport>(exp.Asset);
                        var allNames = new List<string>();
                        foreach (var cosa in exp2.Enum.Names) allNames.Add(cosa.Item1.ToString());
                        converted = new UsmapEnumData(exp2.ObjectName.ToString(), allNames) { InnerType = ConvertUPropertyToUsmapPropertyData(underlyingProp.ToExport<PropertyExport>(asset)) };
                    }
                    else if (enumIndex.IsImport())
                    {
                        string enumName = enumIndex.ToImport(exp.Asset).ObjectName?.Value.Value;
                        if (enumName == null || !exp.Asset.Mappings.EnumMap.TryGetValue(enumName, out UsmapEnum value))
                        {
                            if (!exp.Asset.HasUnversionedProperties)
                            {
                                return new UsmapEnumData(enumName, []) { InnerType = new UsmapPropertyData(EPropertyType.ByteProperty) };
                            }
                            else
                            {
                                throw new InvalidOperationException("Attempt to index into non-existent enum " + enumName);
                            }
                        }
                        var allNames = new List<string>();
                        foreach (var cosa in value.Values) allNames.Add(cosa.ToString());
                        converted = new UsmapEnumData(enumName, allNames) { InnerType = ConvertUPropertyToUsmapPropertyData(underlyingProp.ToExport<PropertyExport>(asset)) };
                    }
                    else
                    {
                        converted = null;
                    }
                    break;
                case UByteProperty byt:
                    enumIndex = byt.Enum;
                    if (enumIndex.IsExport())
                    {
                        var exp2 = enumIndex.ToExport<EnumExport>(exp.Asset);
                        var allNames = new List<string>();
                        foreach (var cosa in exp2.Enum.Names) allNames.Add(cosa.Item1.ToString());
                        converted = new UsmapEnumData(exp2.ObjectName.ToString(), allNames) { InnerType = new UsmapPropertyData(EPropertyType.ByteProperty) };
                    }
                    else if (enumIndex.IsImport())
                    {
                        string enumName = enumIndex.ToImport(exp.Asset).ObjectName?.Value.Value;
                        if (enumName == null || !exp.Asset.Mappings.EnumMap.TryGetValue(enumName, out UsmapEnum value))
                        {
                            if (!exp.Asset.HasUnversionedProperties)
                            {
                                return new UsmapEnumData(enumName, []) { InnerType = new UsmapPropertyData(EPropertyType.ByteProperty) };
                            }
                            else
                            {
                                //should not happen cause it was before 425 
                                throw new InvalidOperationException("Attempt to index into non-existent enum " + enumName);
                            }
                        }
                        var allNames = new List<string>();
                        foreach (var cosa in value.Values) allNames.Add(cosa.ToString());
                        converted = new UsmapEnumData(enumName, allNames) { InnerType = new UsmapPropertyData(EPropertyType.ByteProperty) };
                    }
                    else
                    {
                        converted = new UsmapPropertyData(EPropertyType.ByteProperty); // this is most likely an InnerType of an EnumProperty
                    }
                    break;
                case UStructProperty strukt:
                    var strucstr = Export.GetClassTypeForAncestry(strukt.Struct, asset, out _);
                    converted = new UsmapStructData(strucstr.ToString());
                    break;
                case UArrayProperty array:
                    converted = new UsmapArrayData(EPropertyType.ArrayProperty) { InnerType = ConvertUPropertyToUsmapPropertyData(array.Inner.ToExport<PropertyExport>(asset)) };
                    break;
                case USetProperty set:
                    converted = new UsmapArrayData(EPropertyType.SetProperty) { InnerType = ConvertUPropertyToUsmapPropertyData(set.ElementProp.ToExport<PropertyExport>(asset)) };
                    break;
                case UMapProperty map:
                    converted = new UsmapMapData()
                    {
                        InnerType = ConvertUPropertyToUsmapPropertyData(map.KeyProp.ToExport<PropertyExport>(asset)),
                        ValueType = ConvertUPropertyToUsmapPropertyData(map.ValueProp.ToExport<PropertyExport>(asset))
                    };
                    break;
                default:
                    converted = new UsmapPropertyData(typ);
                    break;
            }
            return converted;
        }

        public static UsmapSchema GetSchemaFromStructExport(string exportName, UAsset asset)
        {
            if (asset == null) throw new InvalidOperationException("Cannot evaluate struct export without package reference");
            foreach (var exp in asset.Exports)
            {
                if (exp.ObjectName.Value.Value == exportName && exp is StructExport sexp) return GetSchemaFromStructExport(sexp, asset.Mappings?.AreFNamesCaseInsensitive ?? true);
            }
            return null;
        }

        public static UsmapSchema GetSchemaFromStructExport(StructExport exp, bool isCaseInsensitive)
        {
            var res = new ConcurrentDictionary<int, UsmapProperty>();
            int idx = 0;
            if (exp.Asset.GetCustomVersion<FCoreObjectVersion>() >= FCoreObjectVersion.FProperties)
            {
                foreach (FProperty entry in exp.LoadedProperties)
                {
                    UsmapProperty converted = new UsmapProperty(entry.Name.ToString(), (ushort)idx, 0, 1, ConvertFPropertyToUsmapPropertyData(exp, entry));
                    res[idx] = converted;
                    idx++;
                }
            }
            else
            {
                List<FPackageIndex> childlist = [];
                if (exp.Asset.GetCustomVersion<FFrameworkObjectVersion>() < FFrameworkObjectVersion.RemoveUField_Next && exp.Children.Length > 0)
                {
                    var next = exp.Children.First();
                    while (!next.IsNull())
                    {
                        childlist.Add(next);
                        next = next.ToExport(exp.Asset) switch
                        {
                            FunctionExport func => func.Field?.Next,
                            PropertyExport prop => prop.Property?.Next,
                            _ => null
                        };
                    }
                }
                var children = exp.Asset.GetCustomVersion<FFrameworkObjectVersion>() >= FFrameworkObjectVersion.RemoveUField_Next ? exp.Children : childlist.ToArray();

                foreach (var entry in children)
                {
                    if (entry.ToExport(exp.Asset) is not PropertyExport field) continue;

                    UsmapProperty converted = new UsmapProperty(field.ObjectName.ToString(), (ushort)idx, 0, 1, ConvertUPropertyToUsmapPropertyData(field));
                    res[idx] = converted;
                    idx++;
                }
            }

            string ssName = exp.SuperStruct.IsImport() ? exp.SuperStruct.ToImport(exp.Asset).ObjectName.ToString() : null;
            string ssPath = (exp.SuperStruct.IsImport() && exp.SuperStruct.ToImport(exp.Asset).OuterIndex.IsImport()) ? exp.SuperStruct.ToImport(exp.Asset).OuterIndex.ToImport(exp.Asset).ObjectName.ToString() : null;
            return new UsmapSchema(exp.ObjectName.ToString(), ssName, (ushort)res.Count, res, isCaseInsensitive, ssPath, true);
        }

        /// <summary>
        /// Retrieve all the properties that a particular schema can reference.
        /// </summary>
        /// <param name="schemaName">The name of the schema of interest.</param>
        /// <param name="modulePath">Module path of the schema of interest.</param>
        /// <param name="asset">An asset to also search for schemas within.</param>
        /// <returns>All the properties that the schema can reference.</returns>
        public IList<UsmapProperty> GetAllProperties(string schemaName, string modulePath = null, UAsset asset = null)
        {
            List<UsmapProperty> res = new List<UsmapProperty>();
            UsmapSchema relevantSchema = this.GetSchemaFromName(schemaName, asset, modulePath);
            while (schemaName != null && relevantSchema != null)
            {
                res.AddRange(relevantSchema.Properties.Values);
                schemaName = relevantSchema.SuperType;
                relevantSchema = this.GetSchemaFromName(schemaName, asset);
            }
            return res;
        }

        /// <summary>
        /// Retrieve all the properties that a particular schema can reference as an annotated, human-readable text file.
        /// </summary>
        /// <param name="schemaName">The name of the schema of interest.</param>
        /// <param name="asset">An asset to also search for schemas within.</param>
        /// <param name="customAnnotations">A map of strings to give custom annotations.</param>
        /// <param name="recursive">Whether or not to dump data for parent schemas as well.</param>
        /// <param name="headerPrefix">The prefix of the subheader for each relevant schema.</param>
        /// <param name="headerSuffix">The suffix of the subheader for each relevant schema.</param>
        /// <returns>An annotated, human-readable text file containing the properties that the schema can reference.</returns>
        public string GetAllPropertiesAnnotated(string schemaName, UAsset asset, IDictionary<string, string> customAnnotations = null, bool recursive = true, string headerPrefix = "--- ", string headerSuffix = " ---")
        {
            List<string> res = new List<string>();
            bool hasDoneFirst = false;
            UsmapSchema relevantSchema = this.GetSchemaFromName(schemaName, asset);
            while (schemaName != null && relevantSchema != null)
            {
                string schemaAnnotation = relevantSchema.FromAsset ? " (blueprint)" : string.Empty;
                res.Add(headerPrefix + schemaName + schemaAnnotation + headerSuffix);

                if (recursive || !hasDoneFirst)
                {
                    foreach (UsmapProperty prop in relevantSchema.Properties.Values)
                    {
                        if (prop.ArrayIndex > 0) continue;
                        string propAnnotation = customAnnotations != null && customAnnotations.ContainsKey(prop.Name) ? (" (" + customAnnotations[prop.Name] + ")") : string.Empty;
                        res.Add(prop.Name + propAnnotation);
                        res.Add("\t" + (prop.PropertyData?.Type.ToString() ?? "Unknown type"));
                    }
                    if (relevantSchema.Properties.Values.Count() == 0) res.Add("N/A");
                    res.Add(string.Empty);
                }

                schemaName = relevantSchema.SuperType;
                relevantSchema = this.GetSchemaFromName(schemaName, asset);
                hasDoneFirst = true;
            }
            return string.Join("\n", res.ToArray());
        }

        // not a set to ensure thread safety
        public ConcurrentDictionary<string, byte> PathsAlreadyProcessedForSchemas = new ConcurrentDictionary<string, byte>();
        public UsmapSchema GetSchemaFromName(string nm, UAsset asset = null, string modulePath = null, bool throwExceptions = true)
        {
            if (string.IsNullOrEmpty(nm)) return null;

            string withModulePath = null;
            if (modulePath != null) withModulePath = modulePath + "." + nm;

            string[] withoutModulePathComponents = nm.Split(".");
            string withoutModulePath = withoutModulePathComponents.Length > 1 ? withoutModulePathComponents[withoutModulePathComponents.Length - 1] : null;

            UsmapSchema relevantSchema = null;
            if (withModulePath != null && this.Schemas.ContainsKey(withModulePath))
            {
                relevantSchema = this.Schemas[withModulePath];
            }
            else if (this.Schemas.ContainsKey(nm)) // fallback to without module path
            {
                relevantSchema = this.Schemas[nm];
            }
            else if (withoutModulePath != null && this.Schemas.ContainsKey(withoutModulePath))
            {
                relevantSchema = this.Schemas[withoutModulePath];
            }
            else 
            {
                // note: this is probably not needed anymore since we now collate schemas on asset load
                relevantSchema = Usmap.GetSchemaFromStructExport(nm, asset);
            }
            if (throwExceptions && relevantSchema == null) throw new FormatException("Failed to find a valid schema for parent name " + nm);
            return relevantSchema;
        }

        /// <summary>
        /// Attempts to retrieve the corresponding .usmap property, given its ancestry.
        /// </summary>
        /// <typeparam name="T">The type of property to output.</typeparam>
        /// <param name="propertyName">The name of the property to search for.</param>
        /// <param name="ancestry">The ancestry of the property to search for.</param>
        /// <param name="dupIndex">The duplication index of the property to search for. If unknown, set to 0.</param>
        /// <param name="asset">An asset to also search for schemas within.</param>
        /// <param name="propDat">The property.</param>
        /// <param name="idx">The index of the property.</param>
        /// <returns>Whether or not the property was successfully found.</returns>
        public bool TryGetProperty<T>(FName propertyName, AncestryInfo ancestry, int dupIndex, UAsset asset, out T propDat, out int idx) where T : UsmapProperty
        {
            propDat = null;

            idx = 0;
            var schemaName = ancestry.Parent.ToString();
            UsmapSchema relevantSchema = this.GetSchemaFromName(schemaName, asset);
            while (schemaName != null && relevantSchema != null)
            {
                propDat = relevantSchema.GetProperty(propertyName.ToString(), dupIndex) as T;
                if (propDat != null)
                {
                    idx += propDat.SchemaIndex;
                    return true;
                }

                idx += relevantSchema.PropCount;
                schemaName = relevantSchema.SuperType;
                relevantSchema = this.GetSchemaFromName(schemaName, asset);
            }

            return false;
        }

        /// <summary>
        /// Attempts to retrieve the corresponding .usmap property data corresponding to a specific property, given its ancestry.
        /// </summary>
        /// <typeparam name="T">The type of property data to output.</typeparam>
        /// <param name="propertyName">The name of the property to search for.</param>
        /// <param name="ancestry">The ancestry of the property to search for.</param>
        /// <param name="asset">An asset to also search for schemas within.</param>
        /// <param name="propDat">The property data.</param>
        /// <returns>Whether or not the property data was successfully found.</returns>
        public bool TryGetPropertyData<T>(FName propertyName, AncestryInfo ancestry, UAsset asset, out T propDat) where T : UsmapPropertyData
        {
            propDat = null;

            if (propertyName == null) return false;

            if (propertyName.IsDummy && int.TryParse(propertyName.Value.Value, out _))
            {
                // this is actually an array member; try to find its parent array
                if (this.TryGetPropertyData(ancestry.Parent, ancestry.CloneWithoutParent(), asset, out UsmapArrayData arrDat))
                {
                    propDat = arrDat.InnerType as T;
                    if (propDat != null) return true;
                }
            }

            var schemaName = ancestry.Parent?.Value?.Value;
            UsmapSchema relevantSchema = this.GetSchemaFromName(schemaName, asset, null, false);
            while (schemaName != null && relevantSchema != null)
            {
                propDat = relevantSchema.GetProperty(propertyName.Value.Value, 0)?.PropertyData as T;
                if (propDat != null) return true;
                schemaName = relevantSchema.SuperType;
                relevantSchema = this.GetSchemaFromName(schemaName, asset, null, false);
            }

            return false;
        }

        /// <summary>
        /// Creates a MemoryStream from an asset path.
        /// </summary>
        /// <param name="p">The path to the input file.</param>
        /// <returns>A new MemoryStream that stores the binary data of the input file.</returns>
        public static MemoryStream PathToStream(string p)
        {
            using (FileStream origStream = File.Open(p, FileMode.Open))
            {
                MemoryStream completeStream = new MemoryStream();
                origStream.CopyTo(completeStream);

                completeStream.Seek(0, SeekOrigin.Begin);
                return completeStream;
            }
        }

        /// <summary>
        /// Creates a BinaryReader from an asset path.
        /// </summary>
        /// <param name="p">The path to the input file.</param>
        /// <returns>A new BinaryReader that stores the binary data of the input file.</returns>
        public UsmapBinaryReader PathToReader(string p)
        {
            return new UsmapBinaryReader(PathToStream(p), this);
        }

        public UsmapBinaryReader ReadHeader(UsmapBinaryReader reader)
        {
            reader.BaseStream.Seek(0, SeekOrigin.Begin);
            ushort fileSignature = reader.ReadUInt16();
            if (fileSignature != USMAP_MAGIC) throw new FormatException(".usmap: File signature mismatch");

            Version = (UsmapVersion)reader.ReadByte();
            if (Version < UsmapVersion.Initial || Version > UsmapVersion.Latest) throw new FormatException(".usmap: Unknown file version " + Version);

            // package versioning
            if (Version >= UsmapVersion.PackageVersioning)
            {
                bool bHasVersioning = reader.ReadInt32() > 0;
                if (bHasVersioning)
                {
                    FileVersionUE4 = (ObjectVersion)reader.ReadInt32();
                    FileVersionUE5 = (ObjectVersionUE5)reader.ReadInt32();

                    CustomVersionContainer = new List<CustomVersion>();
                    int numCustomVersions = reader.ReadInt32();
                    for (int i = 0; i < numCustomVersions; i++)
                    {
                        var customVersionID = new Guid(reader.ReadBytes(16));
                        var customVersionNumber = reader.ReadInt32();
                        CustomVersionContainer.Add(new CustomVersion(customVersionID, customVersionNumber));
                    }

                    NetCL = reader.ReadUInt32();
                }
            }

            ECompressionMethod compressionMethod = (ECompressionMethod)reader.ReadByte();

            uint compressedSize = reader.ReadUInt32();
            uint decompressedSize = reader.ReadUInt32();

            switch (compressionMethod)
            {
                case ECompressionMethod.None:
                    if (compressedSize != decompressedSize) throw new FormatException(".usmap: Compressed size must be equal to decompressed size");
                    return reader;
                case ECompressionMethod.ZStandard:
                    {
                        byte[] dat = new ZstdSharp.Decompressor().Unwrap(reader.ReadBytes((int)compressedSize), (int)decompressedSize).ToArray();
                        return new UsmapBinaryReader(new MemoryStream(dat), this);
                    }
                case ECompressionMethod.Oodle:
                    {
                        byte[] dat = Oodle.Decompress(reader.ReadBytes((int)compressedSize), (int)compressedSize, (int)decompressedSize);
                        return new UsmapBinaryReader(new MemoryStream(dat), this);
                    }
                default:
                    throw new NotImplementedException(".usmap: Compression method " + compressionMethod + " is unimplemented");
            }
        }

        private UsmapPropertyData InitPropData(EPropertyType typ)
        {
            switch (typ)
            {
                case EPropertyType.EnumProperty:
                    return new UsmapEnumData();
                case EPropertyType.StructProperty:
                    return new UsmapStructData();
                case EPropertyType.SetProperty:
                case EPropertyType.ArrayProperty:
                case EPropertyType.OptionalProperty:
                    return new UsmapArrayData(typ);
                case EPropertyType.MapProperty:
                    return new UsmapMapData();
            }

            return new UsmapPropertyData(typ);
        }

        private UsmapPropertyData DeserializePropData(UsmapBinaryReader reader)
        {
            var res = InitPropData((EPropertyType)reader.ReadByte());
            switch (res.Type)
            {
                case EPropertyType.EnumProperty:
                    ((UsmapEnumData)res).InnerType = DeserializePropData(reader);
                    ((UsmapEnumData)res).Name = reader.ReadName();
                    break;
                case EPropertyType.StructProperty:
                    ((UsmapStructData)res).StructType = reader.ReadName();
                    break;
                case EPropertyType.SetProperty:
                case EPropertyType.ArrayProperty:
                case EPropertyType.OptionalProperty:
                    ((UsmapArrayData)res).InnerType = DeserializePropData(reader);
                    break;
                case EPropertyType.MapProperty:
                    ((UsmapMapData)res).InnerType = DeserializePropData(reader);
                    ((UsmapMapData)res).ValueType = DeserializePropData(reader);
                    break;
                default:
                    break;
            }
            return res;
        }

        public void Read(UsmapBinaryReader compressedReader)
        {
            var reader = ReadHeader(compressedReader);

            // part 1: names
            //Console.WriteLine(reader.BaseStream.Position);
            NameMap = new List<string>();
            int numNames = reader.ReadInt32();
            for (int i = 0; i < numNames; i++)
            {
                int fixedLength = Version >= UsmapVersion.LongFName ? (int)reader.ReadInt16() : (int)reader.ReadByte();
                var str = reader.ReadString(fixedLength);
                NameMap.Add(str);
            }

            // part 2: enums
            //Console.WriteLine(reader.BaseStream.Position);
            EnumMap = new ConcurrentDictionary<string, UsmapEnum>(AreFNamesCaseInsensitive ? StringComparer.InvariantCultureIgnoreCase : StringComparer.InvariantCulture);
            int numEnums = reader.ReadInt32();
            UsmapEnum[] enumIndexMap = new UsmapEnum[numEnums];
            for (int i = 0; i < numEnums; i++)
            {
                string enumName = reader.ReadName();

                var newEnum = new UsmapEnum(enumName, new ConcurrentDictionary<long, string>());
                int numEnumEntries = Version >= UsmapVersion.LargeEnums ? (int)reader.ReadInt16() : (int)reader.ReadByte();

                if (Version >= UsmapVersion.ExplicitEnumValues)
                {
                    for (int j = 0; j < numEnumEntries; j++)
                    {
                        var value = reader.ReadInt64();
                        var name = reader.ReadName();
                        newEnum.Values[value] = name;
                    }
                }
                else
                {
                    for (int j = 0; j < numEnumEntries; j++)
                    {
                        newEnum.Values[j] = reader.ReadName();
                    }
                }

                if (!EnumMap.ContainsKey(enumName))
                {
                    enumIndexMap[i] = newEnum;
                    EnumMap[enumName] = newEnum;
                }
            }

            // part 3: schema
            //Console.WriteLine(reader.BaseStream.Position);
            Schemas = new ConcurrentDictionary<string, UsmapSchema>(AreFNamesCaseInsensitive ? StringComparer.InvariantCultureIgnoreCase : StringComparer.InvariantCulture);
            int numSchema = reader.ReadInt32();
            UsmapSchema[] schemaIndexMap = new UsmapSchema[numSchema];
            for (int i = 0; i < numSchema; i++)
            {
                string schemaName = reader.ReadName();
                string schemaSuperName = reader.ReadName();
                ushort numProps = reader.ReadUInt16();
                ushort serializablePropCount = reader.ReadUInt16();
                ConcurrentDictionary<int, UsmapProperty> props = new ConcurrentDictionary<int, UsmapProperty>();
                for (int j = 0; j < serializablePropCount; j++)
                {
                    ushort SchemaIdx = reader.ReadUInt16();
                    byte ArraySize = reader.ReadByte();
                    string Name = reader.ReadName();

                    var currProp = new UsmapProperty(Name, SchemaIdx, 0, ArraySize, null);
                    currProp.PropertyData = DeserializePropData(reader);
                    for (int k = 0; k < ArraySize; k++)
                    {
                        var cln = (UsmapProperty)currProp.Clone();
                        cln.SchemaIndex = (ushort)(SchemaIdx + k);
                        cln.ArrayIndex = (ushort)k;
                        props[SchemaIdx + k] = cln;
                    }
                }

                var newSchema = new UsmapSchema(schemaName, schemaSuperName, numProps, props, this.AreFNamesCaseInsensitive, null);
                schemaIndexMap[i] = newSchema;

                if (SkipBlueprintSchemas && schemaName.Length >= 2 && schemaName.EndsWith("_C")) continue;
                if (SkipBlueprintSchemas && schemaName == "AnimBlueprintGeneratedConstantData") continue;
                if (SkipBlueprintSchemas && schemaName == "AnimBlueprintGeneratedMutableData") continue;

                // add to schema map
                Schemas[schemaName] = newSchema;
            }

            void ReadExtension(string extId, uint extLeng)
            {
                long endPos = reader.BaseStream.Position + extLeng;

                switch(extId)
                {
                    case "PPTH": // Replaces MODL, reuses name map and added full names for Enums
                        byte ppthVer = reader.ReadByte();
                        if (ppthVer > 0) break;

                        int ppthNumEnums = reader.ReadInt32();
                        for (int i = 0; i < ppthNumEnums; i++)
                        {
                            enumIndexMap[i].ModulePath = reader.ReadName();
                        }
                        int ppthNumSchemas = reader.ReadInt32();
                        for (int i = 0; i < ppthNumSchemas; i++)
                        {
                            schemaIndexMap[i].ModulePath = reader.ReadName();
                            Schemas[schemaIndexMap[i].ModulePath + "." + schemaIndexMap[i].Name] = schemaIndexMap[i];
                        }

                        if (reader.BaseStream.Position != endPos) throw new FormatException("Failed to parse extension " + extId + ": ended at " + reader.BaseStream.Position + ", expected " + endPos);
                        break;
                    case "EATR": // Extended Attributes
                        byte eatrVer = reader.ReadByte();
                        if (eatrVer > 0) break;

                        int eatrNumEnums = reader.ReadInt32();
                        for (int i = 0; i < eatrNumEnums; i++)
                        {
                            enumIndexMap[i].EnumFlags = reader.ReadInt32();
                        }
                        int eatrNumSchemas = reader.ReadInt32();
                        for (int i = 0; i < eatrNumSchemas; i++)
                        {
                            schemaIndexMap[i].StructKind = (UsmapStructKind)reader.ReadByte();
                            schemaIndexMap[i].StructOrClassFlags = reader.ReadInt32();
                            int eatrNumProps = reader.ReadInt32();
                            for (int j = 0; j < eatrNumProps; j++)
                            {
                                var flgs = (EPropertyFlags)reader.ReadUInt64();
                                if (j < schemaIndexMap[i].Properties.Count) schemaIndexMap[i].Properties[j].PropertyFlags = flgs;
                            }
                        }

                        if (reader.BaseStream.Position != endPos) throw new FormatException("Failed to parse extension " + extId + ": ended at " + reader.BaseStream.Position + ", expected " + endPos);
                        break;
                    case "ENVP": // Enum Name Value Pairs
                        byte envpVer = reader.ReadByte();
                        if (envpVer > 0) break;

                        int envpNumEnums = reader.ReadInt32();
                        for (int i = 0; i < envpNumEnums; i++)
                        {
                            enumIndexMap[i].Values.Clear();
                            int envpNumEnumEntries = reader.ReadInt32(); // not a byte this time!!!
                            for (int j = 0; j < envpNumEnumEntries; j++)
                            {
                                string envpEntryVal = reader.ReadName();
                                long envpEntryKey = reader.ReadInt64();
                                enumIndexMap[i].Values[envpEntryKey] = envpEntryVal;
                            }
                        }

                        if (reader.BaseStream.Position != endPos) throw new FormatException("Failed to parse extension " + extId + ": ended at " + reader.BaseStream.Position + ", expected " + endPos);
                        break;
                    case "MODL": // traditional list of module paths
                        ushort numModulePaths = reader.ReadUInt16();
                        string[] modulePaths = new string[numModulePaths];
                        for (int i = 0; i < numModulePaths; i++) modulePaths[i] = reader.ReadString();
                        for (int i = 0; i < schemaIndexMap.Length; i++)
                        {
                            schemaIndexMap[i].ModulePath = modulePaths[numModulePaths > byte.MaxValue ? reader.ReadUInt16() : reader.ReadByte()];
                        }

                        if (reader.BaseStream.Position != endPos) throw new FormatException("Failed to parse extension " + extId + ": ended at " + reader.BaseStream.Position + ", expected " + endPos);
                        break;
                    default:
                        break;
                }

                reader.BaseStream.Position = endPos;
            }

            // read extension data if it's present
            FailedExtensions = new List<string>();
            if (reader.BaseStream.Length > reader.BaseStream.Position)
            {
                uint usmapExtensionsMagic = reader.ReadUInt32();
                if (usmapExtensionsMagic == 0x54584543) // "CEXT"
                {
                    UsmapExtensionLayoutVersion layoutVer = (UsmapExtensionLayoutVersion)reader.ReadByte();
                    switch(layoutVer)
                    {
                        case UsmapExtensionLayoutVersion.Initial:
                            int numExtensions = reader.ReadInt32();
                            for (int i = 0; i < numExtensions; i++)
                            {
                                string extId = reader.ReadString(4);
                                uint extLeng = reader.ReadUInt32();
                                try
                                {
                                    ReadExtension(extId, extLeng);
                                }
                                catch
                                {
                                    FailedExtensions.Add(extId);
                                }
                            }
                            break;
                        default:
                            throw new InvalidOperationException("Unknown extension layout version " + layoutVer);
                    }
                }
                else if (usmapExtensionsMagic == 1) // legacy
                {
                    ReadExtension("MODL", (uint)(reader.BaseStream.Length - reader.BaseStream.Position));
                }
            }
        }

        /// <summary>
        /// Reads a .usmap file from disk and initializes a new instance of the <see cref="Usmap"/> class to store its data in memory.
        /// </summary>
        /// <param name="path">The path of the file file on disk that this instance will read from.</param>
        /// <exception cref="FormatException">Throw when the file cannot be parsed correctly.</exception>
        public Usmap(string path)
        {
            this.FilePath = path;
            Read(PathToReader(path));
        }

        /// <summary>
        /// Reads a .usmap file from a UsmapBinaryReader and initializes a new instance of the <see cref="Usmap"/> class to store its data in memory.
        /// </summary>
        /// <param name="reader">The file's UsmapBinaryReader that this instance will read from.</param>
        /// <exception cref="FormatException">Throw when the asset cannot be parsed correctly.</exception>
        public Usmap(UsmapBinaryReader reader)
        {
            Read(reader);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Usmap"/> class. This instance will store no data and does not represent any file in particular until the <see cref="Read"/> method is manually called.
        /// </summary>
        public Usmap()
        {

        }
    }
}

```

`UAssetAPI/Unversioned/UsmapBinaryReader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using UAssetAPI.Kismet.Bytecode;
using UAssetAPI.UnrealTypes;
using UAssetAPI.ExportTypes;
using UAssetAPI.Unversioned;

namespace UAssetAPI
{
    /// <summary>
    /// Reads primitive data types from .usmap files.
    /// </summary>
    public class UsmapBinaryReader : BinaryReader
    {
        public Usmap File;

        public UsmapBinaryReader(Stream stream, Usmap file) : base(stream)
        {
            File = file;
        }

        private byte[] ReverseIfBigEndian(byte[] data)
        {
            if (!BitConverter.IsLittleEndian) Array.Reverse(data);
            return data;
        }

        public override short ReadInt16()
        {
            return BitConverter.ToInt16(ReverseIfBigEndian(base.ReadBytes(2)), 0);
        }

        public override ushort ReadUInt16()
        {
            return BitConverter.ToUInt16(ReverseIfBigEndian(base.ReadBytes(2)), 0);
        }

        public override int ReadInt32()
        {
            return BitConverter.ToInt32(ReverseIfBigEndian(base.ReadBytes(4)), 0);
        }

        public override uint ReadUInt32()
        {
            return BitConverter.ToUInt32(ReverseIfBigEndian(base.ReadBytes(4)), 0);
        }

        public override long ReadInt64()
        {
            return BitConverter.ToInt64(ReverseIfBigEndian(base.ReadBytes(8)), 0);
        }

        public override ulong ReadUInt64()
        {
            return BitConverter.ToUInt64(ReverseIfBigEndian(base.ReadBytes(8)), 0);
        }

        public override float ReadSingle()
        {
            return BitConverter.ToSingle(ReverseIfBigEndian(base.ReadBytes(4)), 0);
        }

        public override double ReadDouble()
        {
            return BitConverter.ToDouble(ReverseIfBigEndian(base.ReadBytes(8)), 0);
        }

        public override string ReadString()
        {
            return ReadString(-1);
        }

        public string ReadString(int fixedLength = -1)
        {
            int length = fixedLength > -1 ? fixedLength : this.ReadByte();
            switch (length)
            {
                case 0:
                    return null;
                default:
                    byte[] data = this.ReadBytes(length);
                    return Encoding.ASCII.GetString(data, 0, data.Length);
            }
        }

        public string ReadName()
        {
            int val = ReadInt32();
            if (val < 0) return null;
            return File.NameMap[val];
        }
    }
}

```

`docs/book.toml`:

```toml
[book]
authors = ["atenfyr"]
language = "en"
multilingual = false
src = "src"
title = "UAssetAPI Documentation"

[output.html]
additional-css = ["css/custom.css"]

[output.html.fold]
enable = true
level = 0
```

`docs/correct_pages.py`:

```py
import glob, re

SUBSTRINGS_TO_CHANGE = {
    re.escape("""### **Item**

```csharp
public PropertyData Item { get; set; }
```

#### Property Value

[PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

"""): "",

    re.escape("""### **Item**

```csharp
public Export Item { get; set; }
```

#### Property Value

[Export](./uassetapi.exporttypes.export.md)<br>

"""): "",

    r", [\S]+?, Version=[\d\.]+, Culture=.+?, PublicKeyToken=.+?\]": "]",


}

for file in glob.glob("src/api/*.md"):
    dat = ""
    with open(file, "r") as f:
        dat = f.read()
    for entry in SUBSTRINGS_TO_CHANGE:
        dat = re.sub(entry, SUBSTRINGS_TO_CHANGE[entry], dat)
    with open(file, "w") as f:
        f.write(dat)
```

`docs/correct_summary.py`:

```py
dat = ""
with open("index.md", "r") as f:
    dat = f.read()

res = dat.replace("\n\n", "\n").split("\n")[1:]
for i in range(len(res)):
    if len(res[i]) < 2: continue
    if res[i][:2] == "##":
        res[i] = "  - [" + res[i][3:] + "]()"
    else:
        res[i] = "    - " + res[i].replace("./", "api/")
    res[i] += "\n"

res_header = ""
with open("src/SUMMARY_header.md", "r") as f:
    res_header = f.read()
with open("src/SUMMARY.md", "w") as f:
    f.write(res_header)
    f.write("\n# Full Documentation\n- [Class Documentation]()\n")
    f.writelines(res)

```

`docs/css/custom.css`:

```css
:root {
    --sidebar-width: 375px;
}
```

`docs/generate_docs.bat`:

```bat
@echo off
set "startdir=%cd%"
cd ..\UAssetAPI\bin\Debug\net8.0
copy /Y "%UserProfile%\.nuget\packages\newtonsoft.json\13.0.3\lib\netstandard2.0" .
rd /S /Q "%startdir%\src\api"
"%startdir%\XMLDoc2Markdown\XMLDoc2Markdown.exe" UAssetAPI.dll "%startdir%\src\api"
cd %startdir%
move ".\src\api\index.md" .
python correct_summary.py
python correct_pages.py
del index.md

```

`docs/generate_docs.sh`:

```sh
#!/bin/bash

# cd to script dir https://stackoverflow.com/a/17744637
cd "$(cd -P -- "$(dirname -- "$0")" && pwd -P)"

startdir="$(pwd)"
(
  cd ../UAssetAPI/bin/Debug/net8.0
  cp -r "$HOME/.nuget/packages/newtonsoft.json/13.0.3/lib/netstandard2.0/"* .
  rm -r "$startdir/src/api"
  "$startdir/XMLDoc2Markdown/XMLDoc2Markdown" UAssetAPI.dll "$startdir/src/api"
)
mv src/api/index.md .
python correct_summary.py
python correct_pages.py
rm index.md

```

`docs/src/README.md`:

```md
# UAssetAPI Documentation

UAssetAPI is a .NET library for reading and writing Unreal Engine game assets.

## Features
- Low-level read/write capability for a wide variety of cooked and uncooked .uasset files from ~4.13 to 5.3
- Support for more than 100 property types and 12 export types
- Support for JSON export and import to a proprietary format that maintains binary equality
- Support for reading and writing raw Kismet (blueprint) bytecode
- Reading capability for the unofficial .usmap format to parse ambiguous and unversioned properties
- Robust fail-safes for many properties and exports that fail serialization
- Automatic reflection for new property types in other loaded assemblies

## Usage
To get started using UAssetAPI, first build the API using the [Build Instructions guide](guide/build.md) and learn how to perform basic operations on your cooked .uasset files using the [Basic Usage guide](guide/basic.md).

UAssetGUI, a graphical wrapper around UAssetAPI which allows you to directly view and modify game assets by hand, is also available and can be downloaded for free on GitHub at [https://github.com/atenfyr/UAssetGUI/releases](https://github.com/atenfyr/UAssetGUI/releases).

## Support
The source code of UAssetAPI is publicly available on GitHub at [https://github.com/atenfyr/UAssetAPI](https://github.com/atenfyr/UAssetAPI), and all contributions are greatly appreciated.

Any bugs or feature requests that you may have can be submitted on the GitHub page as an issue. You can also direct any questions you may have to the folks on the Unreal Engine Modding Discord server, which you can join with this invite link: [https://discord.gg/zVvsE9mEEa](https://discord.gg/zVvsE9mEEa).
```

`docs/src/SUMMARY.md`:

```md
# Summary
[Introduction](README.md)

# User Guide
- [Build Instructions](guide/build.md)
- [Basic Usage](guide/basic.md)
- [More Examples](guide/extras.md)

# Full Documentation
- [Class Documentation]()
  - [UAssetAPI]()
    - [AC7Decrypt](api/uassetapi.ac7decrypt.md)
    - [AC7XorKey](api/uassetapi.ac7xorkey.md)
    - [AssetBinaryReader](api/uassetapi.assetbinaryreader.md)
    - [AssetBinaryWriter](api/uassetapi.assetbinarywriter.md)
    - [CRCGenerator](api/uassetapi.crcgenerator.md)
    - [CustomSerializationFlags](api/uassetapi.customserializationflags.md)
    - [CustomVersion](api/uassetapi.customversion.md)
    - [FEngineVersion](api/uassetapi.fengineversion.md)
    - [FGenerationInfo](api/uassetapi.fgenerationinfo.md)
    - [Import](api/uassetapi.import.md)
    - [INameMap](api/uassetapi.inamemap.md)
    - [InvalidMappingsException](api/uassetapi.invalidmappingsexception.md)
    - [MainSerializer](api/uassetapi.mainserializer.md)
    - [NameMapOutOfRangeException](api/uassetapi.namemapoutofrangeexception.md)
    - [PakBuilder](api/uassetapi.pakbuilder.md)
    - [PakCompression](api/uassetapi.pakcompression.md)
    - [PakReader](api/uassetapi.pakreader.md)
    - [PakVersion](api/uassetapi.pakversion.md)
    - [PakWriter](api/uassetapi.pakwriter.md)
    - [RePakInterop](api/uassetapi.repakinterop.md)
    - [StreamCallbacks](api/uassetapi.streamcallbacks.md)
    - [UAPUtils](api/uassetapi.uaputils.md)
    - [UAsset](api/uassetapi.uasset.md)
    - [UnknownEngineVersionException](api/uassetapi.unknownengineversionexception.md)
    - [UnrealBinaryReader](api/uassetapi.unrealbinaryreader.md)
    - [UnrealBinaryWriter](api/uassetapi.unrealbinarywriter.md)
    - [UsmapBinaryReader](api/uassetapi.usmapbinaryreader.md)
  - [UAssetAPI.CustomVersions]()
    - [FAnimPhysObjectVersion](api/uassetapi.customversions.fanimphysobjectversion.md)
    - [FAssetRegistryVersion](api/uassetapi.customversions.fassetregistryversion.md)
    - [FCoreObjectVersion](api/uassetapi.customversions.fcoreobjectversion.md)
    - [FEditorObjectVersion](api/uassetapi.customversions.feditorobjectversion.md)
    - [FFortniteMainBranchObjectVersion](api/uassetapi.customversions.ffortnitemainbranchobjectversion.md)
    - [FFortniteReleaseBranchCustomObjectVersion](api/uassetapi.customversions.ffortnitereleasebranchcustomobjectversion.md)
    - [FFrameworkObjectVersion](api/uassetapi.customversions.fframeworkobjectversion.md)
    - [FNiagaraCustomVersion](api/uassetapi.customversions.fniagaracustomversion.md)
    - [FNiagaraObjectVersion](api/uassetapi.customversions.fniagaraobjectversion.md)
    - [FReleaseObjectVersion](api/uassetapi.customversions.freleaseobjectversion.md)
    - [FSequencerObjectVersion](api/uassetapi.customversions.fsequencerobjectversion.md)
    - [FUE5ReleaseStreamObjectVersion](api/uassetapi.customversions.fue5releasestreamobjectversion.md)
    - [IntroducedAttribute](api/uassetapi.customversions.introducedattribute.md)
  - [UAssetAPI.ExportTypes]()
    - [ClassExport](api/uassetapi.exporttypes.classexport.md)
    - [DataTableExport](api/uassetapi.exporttypes.datatableexport.md)
    - [EClassSerializationControlExtension](api/uassetapi.exporttypes.eclassserializationcontrolextension.md)
    - [ECppForm](api/uassetapi.exporttypes.ecppform.md)
    - [EExportFilterFlags](api/uassetapi.exporttypes.eexportfilterflags.md)
    - [EnumExport](api/uassetapi.exporttypes.enumexport.md)
    - [Export](api/uassetapi.exporttypes.export.md)
    - [FieldExport](api/uassetapi.exporttypes.fieldexport.md)
    - [FStringTable](api/uassetapi.exporttypes.fstringtable.md)
    - [FunctionExport](api/uassetapi.exporttypes.functionexport.md)
    - [FURL](api/uassetapi.exporttypes.furl.md)
    - [LevelExport](api/uassetapi.exporttypes.levelexport.md)
    - [MetaDataExport](api/uassetapi.exporttypes.metadataexport.md)
    - [NormalExport](api/uassetapi.exporttypes.normalexport.md)
    - [ObjectMetaDataEntry](api/uassetapi.exporttypes.objectmetadataentry.md)
    - [PropertyExport](api/uassetapi.exporttypes.propertyexport.md)
    - [RawExport](api/uassetapi.exporttypes.rawexport.md)
    - [SerializedInterfaceReference](api/uassetapi.exporttypes.serializedinterfacereference.md)
    - [StringTableExport](api/uassetapi.exporttypes.stringtableexport.md)
    - [StructExport](api/uassetapi.exporttypes.structexport.md)
    - [UDataTable](api/uassetapi.exporttypes.udatatable.md)
    - [UEnum](api/uassetapi.exporttypes.uenum.md)
    - [UserDefinedStructExport](api/uassetapi.exporttypes.userdefinedstructexport.md)
  - [UAssetAPI.FieldTypes]()
    - [EArrayDim](api/uassetapi.fieldtypes.earraydim.md)
    - [ELifetimeCondition](api/uassetapi.fieldtypes.elifetimecondition.md)
    - [FArrayProperty](api/uassetapi.fieldtypes.farrayproperty.md)
    - [FBoolProperty](api/uassetapi.fieldtypes.fboolproperty.md)
    - [FByteProperty](api/uassetapi.fieldtypes.fbyteproperty.md)
    - [FClassProperty](api/uassetapi.fieldtypes.fclassproperty.md)
    - [FDelegateProperty](api/uassetapi.fieldtypes.fdelegateproperty.md)
    - [FEnumProperty](api/uassetapi.fieldtypes.fenumproperty.md)
    - [FField](api/uassetapi.fieldtypes.ffield.md)
    - [FGenericProperty](api/uassetapi.fieldtypes.fgenericproperty.md)
    - [FInterfaceProperty](api/uassetapi.fieldtypes.finterfaceproperty.md)
    - [FMapProperty](api/uassetapi.fieldtypes.fmapproperty.md)
    - [FMulticastDelegateProperty](api/uassetapi.fieldtypes.fmulticastdelegateproperty.md)
    - [FMulticastInlineDelegateProperty](api/uassetapi.fieldtypes.fmulticastinlinedelegateproperty.md)
    - [FNumericProperty](api/uassetapi.fieldtypes.fnumericproperty.md)
    - [FObjectProperty](api/uassetapi.fieldtypes.fobjectproperty.md)
    - [FOptionalProperty](api/uassetapi.fieldtypes.foptionalproperty.md)
    - [FProperty](api/uassetapi.fieldtypes.fproperty.md)
    - [FSetProperty](api/uassetapi.fieldtypes.fsetproperty.md)
    - [FSoftClassProperty](api/uassetapi.fieldtypes.fsoftclassproperty.md)
    - [FSoftObjectProperty](api/uassetapi.fieldtypes.fsoftobjectproperty.md)
    - [FStructProperty](api/uassetapi.fieldtypes.fstructproperty.md)
    - [FWeakObjectProperty](api/uassetapi.fieldtypes.fweakobjectproperty.md)
    - [UArrayProperty](api/uassetapi.fieldtypes.uarrayproperty.md)
    - [UAssetClassProperty](api/uassetapi.fieldtypes.uassetclassproperty.md)
    - [UAssetObjectProperty](api/uassetapi.fieldtypes.uassetobjectproperty.md)
    - [UBoolProperty](api/uassetapi.fieldtypes.uboolproperty.md)
    - [UByteProperty](api/uassetapi.fieldtypes.ubyteproperty.md)
    - [UClassProperty](api/uassetapi.fieldtypes.uclassproperty.md)
    - [UDelegateProperty](api/uassetapi.fieldtypes.udelegateproperty.md)
    - [UDoubleProperty](api/uassetapi.fieldtypes.udoubleproperty.md)
    - [UEnumProperty](api/uassetapi.fieldtypes.uenumproperty.md)
    - [UField](api/uassetapi.fieldtypes.ufield.md)
    - [UFloatProperty](api/uassetapi.fieldtypes.ufloatproperty.md)
    - [UGenericProperty](api/uassetapi.fieldtypes.ugenericproperty.md)
    - [UInt16Property](api/uassetapi.fieldtypes.uint16property.md)
    - [UInt64Property](api/uassetapi.fieldtypes.uint64property.md)
    - [UInt8Property](api/uassetapi.fieldtypes.uint8property.md)
    - [UInterfaceProperty](api/uassetapi.fieldtypes.uinterfaceproperty.md)
    - [UIntProperty](api/uassetapi.fieldtypes.uintproperty.md)
    - [ULazyObjectProperty](api/uassetapi.fieldtypes.ulazyobjectproperty.md)
    - [UMapProperty](api/uassetapi.fieldtypes.umapproperty.md)
    - [UMulticastDelegateProperty](api/uassetapi.fieldtypes.umulticastdelegateproperty.md)
    - [UMulticastInlineDelegateProperty](api/uassetapi.fieldtypes.umulticastinlinedelegateproperty.md)
    - [UMulticastSparseDelegateProperty](api/uassetapi.fieldtypes.umulticastsparsedelegateproperty.md)
    - [UNameProperty](api/uassetapi.fieldtypes.unameproperty.md)
    - [UNumericProperty](api/uassetapi.fieldtypes.unumericproperty.md)
    - [UObjectProperty](api/uassetapi.fieldtypes.uobjectproperty.md)
    - [UProperty](api/uassetapi.fieldtypes.uproperty.md)
    - [USetProperty](api/uassetapi.fieldtypes.usetproperty.md)
    - [USoftClassProperty](api/uassetapi.fieldtypes.usoftclassproperty.md)
    - [USoftObjectProperty](api/uassetapi.fieldtypes.usoftobjectproperty.md)
    - [UStrProperty](api/uassetapi.fieldtypes.ustrproperty.md)
    - [UStructProperty](api/uassetapi.fieldtypes.ustructproperty.md)
    - [UTextProperty](api/uassetapi.fieldtypes.utextproperty.md)
    - [UUInt16Property](api/uassetapi.fieldtypes.uuint16property.md)
    - [UUInt32Property](api/uassetapi.fieldtypes.uuint32property.md)
    - [UUInt64Property](api/uassetapi.fieldtypes.uuint64property.md)
    - [UWeakObjectProperty](api/uassetapi.fieldtypes.uweakobjectproperty.md)
  - [UAssetAPI.JSON]()
    - [ByteArrayJsonConverter](api/uassetapi.json.bytearrayjsonconverter.md)
    - [FNameJsonConverter](api/uassetapi.json.fnamejsonconverter.md)
    - [FPackageIndexJsonConverter](api/uassetapi.json.fpackageindexjsonconverter.md)
    - [FSignedZeroJsonConverter](api/uassetapi.json.fsignedzerojsonconverter.md)
    - [FStringJsonConverter](api/uassetapi.json.fstringjsonconverter.md)
    - [FStringTableJsonConverter](api/uassetapi.json.fstringtablejsonconverter.md)
    - [GuidJsonConverter](api/uassetapi.json.guidjsonconverter.md)
    - [TMapJsonConverter&lt;TKey, TValue&gt;](api/uassetapi.json.tmapjsonconverter-2.md)
    - [UAssetContractResolver](api/uassetapi.json.uassetcontractresolver.md)
  - [UAssetAPI.Kismet]()
    - [KismetSerializer](api/uassetapi.kismet.kismetserializer.md)
  - [UAssetAPI.Kismet.Bytecode]()
    - [EBlueprintTextLiteralType](api/uassetapi.kismet.bytecode.eblueprinttextliteraltype.md)
    - [ECastToken](api/uassetapi.kismet.bytecode.ecasttoken.md)
    - [EExprToken](api/uassetapi.kismet.bytecode.eexprtoken.md)
    - [EScriptInstrumentationType](api/uassetapi.kismet.bytecode.escriptinstrumentationtype.md)
    - [ExpressionSerializer](api/uassetapi.kismet.bytecode.expressionserializer.md)
    - [FScriptText](api/uassetapi.kismet.bytecode.fscripttext.md)
    - [KismetExpression](api/uassetapi.kismet.bytecode.kismetexpression.md)
    - [KismetExpression&lt;T&gt;](api/uassetapi.kismet.bytecode.kismetexpression-1.md)
    - [KismetPropertyPointer](api/uassetapi.kismet.bytecode.kismetpropertypointer.md)
  - [UAssetAPI.Kismet.Bytecode.Expressions]()
    - [EX_AddMulticastDelegate](api/uassetapi.kismet.bytecode.expressions.ex_addmulticastdelegate.md)
    - [EX_ArrayConst](api/uassetapi.kismet.bytecode.expressions.ex_arrayconst.md)
    - [EX_ArrayGetByRef](api/uassetapi.kismet.bytecode.expressions.ex_arraygetbyref.md)
    - [EX_Assert](api/uassetapi.kismet.bytecode.expressions.ex_assert.md)
    - [EX_BindDelegate](api/uassetapi.kismet.bytecode.expressions.ex_binddelegate.md)
    - [EX_BitFieldConst](api/uassetapi.kismet.bytecode.expressions.ex_bitfieldconst.md)
    - [EX_Breakpoint](api/uassetapi.kismet.bytecode.expressions.ex_breakpoint.md)
    - [EX_ByteConst](api/uassetapi.kismet.bytecode.expressions.ex_byteconst.md)
    - [EX_CallMath](api/uassetapi.kismet.bytecode.expressions.ex_callmath.md)
    - [EX_CallMulticastDelegate](api/uassetapi.kismet.bytecode.expressions.ex_callmulticastdelegate.md)
    - [EX_CastBase](api/uassetapi.kismet.bytecode.expressions.ex_castbase.md)
    - [EX_ClassContext](api/uassetapi.kismet.bytecode.expressions.ex_classcontext.md)
    - [EX_ClassSparseDataVariable](api/uassetapi.kismet.bytecode.expressions.ex_classsparsedatavariable.md)
    - [EX_ClearMulticastDelegate](api/uassetapi.kismet.bytecode.expressions.ex_clearmulticastdelegate.md)
    - [EX_ComputedJump](api/uassetapi.kismet.bytecode.expressions.ex_computedjump.md)
    - [EX_Context](api/uassetapi.kismet.bytecode.expressions.ex_context.md)
    - [EX_Context_FailSilent](api/uassetapi.kismet.bytecode.expressions.ex_context_failsilent.md)
    - [EX_CrossInterfaceCast](api/uassetapi.kismet.bytecode.expressions.ex_crossinterfacecast.md)
    - [EX_DefaultVariable](api/uassetapi.kismet.bytecode.expressions.ex_defaultvariable.md)
    - [EX_DeprecatedOp4A](api/uassetapi.kismet.bytecode.expressions.ex_deprecatedop4a.md)
    - [EX_DoubleConst](api/uassetapi.kismet.bytecode.expressions.ex_doubleconst.md)
    - [EX_DynamicCast](api/uassetapi.kismet.bytecode.expressions.ex_dynamiccast.md)
    - [EX_EndArray](api/uassetapi.kismet.bytecode.expressions.ex_endarray.md)
    - [EX_EndArrayConst](api/uassetapi.kismet.bytecode.expressions.ex_endarrayconst.md)
    - [EX_EndFunctionParms](api/uassetapi.kismet.bytecode.expressions.ex_endfunctionparms.md)
    - [EX_EndMap](api/uassetapi.kismet.bytecode.expressions.ex_endmap.md)
    - [EX_EndMapConst](api/uassetapi.kismet.bytecode.expressions.ex_endmapconst.md)
    - [EX_EndOfScript](api/uassetapi.kismet.bytecode.expressions.ex_endofscript.md)
    - [EX_EndParmValue](api/uassetapi.kismet.bytecode.expressions.ex_endparmvalue.md)
    - [EX_EndSet](api/uassetapi.kismet.bytecode.expressions.ex_endset.md)
    - [EX_EndSetConst](api/uassetapi.kismet.bytecode.expressions.ex_endsetconst.md)
    - [EX_EndStructConst](api/uassetapi.kismet.bytecode.expressions.ex_endstructconst.md)
    - [EX_False](api/uassetapi.kismet.bytecode.expressions.ex_false.md)
    - [EX_FieldPathConst](api/uassetapi.kismet.bytecode.expressions.ex_fieldpathconst.md)
    - [EX_FinalFunction](api/uassetapi.kismet.bytecode.expressions.ex_finalfunction.md)
    - [EX_FloatConst](api/uassetapi.kismet.bytecode.expressions.ex_floatconst.md)
    - [EX_InstanceDelegate](api/uassetapi.kismet.bytecode.expressions.ex_instancedelegate.md)
    - [EX_InstanceVariable](api/uassetapi.kismet.bytecode.expressions.ex_instancevariable.md)
    - [EX_InstrumentationEvent](api/uassetapi.kismet.bytecode.expressions.ex_instrumentationevent.md)
    - [EX_Int64Const](api/uassetapi.kismet.bytecode.expressions.ex_int64const.md)
    - [EX_IntConst](api/uassetapi.kismet.bytecode.expressions.ex_intconst.md)
    - [EX_IntConstByte](api/uassetapi.kismet.bytecode.expressions.ex_intconstbyte.md)
    - [EX_InterfaceContext](api/uassetapi.kismet.bytecode.expressions.ex_interfacecontext.md)
    - [EX_InterfaceToObjCast](api/uassetapi.kismet.bytecode.expressions.ex_interfacetoobjcast.md)
    - [EX_IntOne](api/uassetapi.kismet.bytecode.expressions.ex_intone.md)
    - [EX_IntZero](api/uassetapi.kismet.bytecode.expressions.ex_intzero.md)
    - [EX_Jump](api/uassetapi.kismet.bytecode.expressions.ex_jump.md)
    - [EX_JumpIfNot](api/uassetapi.kismet.bytecode.expressions.ex_jumpifnot.md)
    - [EX_Let](api/uassetapi.kismet.bytecode.expressions.ex_let.md)
    - [EX_LetBase](api/uassetapi.kismet.bytecode.expressions.ex_letbase.md)
    - [EX_LetBool](api/uassetapi.kismet.bytecode.expressions.ex_letbool.md)
    - [EX_LetDelegate](api/uassetapi.kismet.bytecode.expressions.ex_letdelegate.md)
    - [EX_LetMulticastDelegate](api/uassetapi.kismet.bytecode.expressions.ex_letmulticastdelegate.md)
    - [EX_LetObj](api/uassetapi.kismet.bytecode.expressions.ex_letobj.md)
    - [EX_LetValueOnPersistentFrame](api/uassetapi.kismet.bytecode.expressions.ex_letvalueonpersistentframe.md)
    - [EX_LetWeakObjPtr](api/uassetapi.kismet.bytecode.expressions.ex_letweakobjptr.md)
    - [EX_LocalFinalFunction](api/uassetapi.kismet.bytecode.expressions.ex_localfinalfunction.md)
    - [EX_LocalOutVariable](api/uassetapi.kismet.bytecode.expressions.ex_localoutvariable.md)
    - [EX_LocalVariable](api/uassetapi.kismet.bytecode.expressions.ex_localvariable.md)
    - [EX_LocalVirtualFunction](api/uassetapi.kismet.bytecode.expressions.ex_localvirtualfunction.md)
    - [EX_MapConst](api/uassetapi.kismet.bytecode.expressions.ex_mapconst.md)
    - [EX_MetaCast](api/uassetapi.kismet.bytecode.expressions.ex_metacast.md)
    - [EX_NameConst](api/uassetapi.kismet.bytecode.expressions.ex_nameconst.md)
    - [EX_NoInterface](api/uassetapi.kismet.bytecode.expressions.ex_nointerface.md)
    - [EX_NoObject](api/uassetapi.kismet.bytecode.expressions.ex_noobject.md)
    - [EX_Nothing](api/uassetapi.kismet.bytecode.expressions.ex_nothing.md)
    - [EX_NothingInt32](api/uassetapi.kismet.bytecode.expressions.ex_nothingint32.md)
    - [EX_ObjectConst](api/uassetapi.kismet.bytecode.expressions.ex_objectconst.md)
    - [EX_ObjToInterfaceCast](api/uassetapi.kismet.bytecode.expressions.ex_objtointerfacecast.md)
    - [EX_PopExecutionFlow](api/uassetapi.kismet.bytecode.expressions.ex_popexecutionflow.md)
    - [EX_PopExecutionFlowIfNot](api/uassetapi.kismet.bytecode.expressions.ex_popexecutionflowifnot.md)
    - [EX_PrimitiveCast](api/uassetapi.kismet.bytecode.expressions.ex_primitivecast.md)
    - [EX_PropertyConst](api/uassetapi.kismet.bytecode.expressions.ex_propertyconst.md)
    - [EX_PushExecutionFlow](api/uassetapi.kismet.bytecode.expressions.ex_pushexecutionflow.md)
    - [EX_RemoveMulticastDelegate](api/uassetapi.kismet.bytecode.expressions.ex_removemulticastdelegate.md)
    - [EX_Return](api/uassetapi.kismet.bytecode.expressions.ex_return.md)
    - [EX_RotationConst](api/uassetapi.kismet.bytecode.expressions.ex_rotationconst.md)
    - [EX_Self](api/uassetapi.kismet.bytecode.expressions.ex_self.md)
    - [EX_SetArray](api/uassetapi.kismet.bytecode.expressions.ex_setarray.md)
    - [EX_SetConst](api/uassetapi.kismet.bytecode.expressions.ex_setconst.md)
    - [EX_SetMap](api/uassetapi.kismet.bytecode.expressions.ex_setmap.md)
    - [EX_SetSet](api/uassetapi.kismet.bytecode.expressions.ex_setset.md)
    - [EX_Skip](api/uassetapi.kismet.bytecode.expressions.ex_skip.md)
    - [EX_SkipOffsetConst](api/uassetapi.kismet.bytecode.expressions.ex_skipoffsetconst.md)
    - [EX_SoftObjectConst](api/uassetapi.kismet.bytecode.expressions.ex_softobjectconst.md)
    - [EX_StringConst](api/uassetapi.kismet.bytecode.expressions.ex_stringconst.md)
    - [EX_StructConst](api/uassetapi.kismet.bytecode.expressions.ex_structconst.md)
    - [EX_StructMemberContext](api/uassetapi.kismet.bytecode.expressions.ex_structmembercontext.md)
    - [EX_SwitchValue](api/uassetapi.kismet.bytecode.expressions.ex_switchvalue.md)
    - [EX_TextConst](api/uassetapi.kismet.bytecode.expressions.ex_textconst.md)
    - [EX_Tracepoint](api/uassetapi.kismet.bytecode.expressions.ex_tracepoint.md)
    - [EX_TransformConst](api/uassetapi.kismet.bytecode.expressions.ex_transformconst.md)
    - [EX_True](api/uassetapi.kismet.bytecode.expressions.ex_true.md)
    - [EX_UInt64Const](api/uassetapi.kismet.bytecode.expressions.ex_uint64const.md)
    - [EX_UnicodeStringConst](api/uassetapi.kismet.bytecode.expressions.ex_unicodestringconst.md)
    - [EX_VariableBase](api/uassetapi.kismet.bytecode.expressions.ex_variablebase.md)
    - [EX_Vector3fConst](api/uassetapi.kismet.bytecode.expressions.ex_vector3fconst.md)
    - [EX_VectorConst](api/uassetapi.kismet.bytecode.expressions.ex_vectorconst.md)
    - [EX_VirtualFunction](api/uassetapi.kismet.bytecode.expressions.ex_virtualfunction.md)
    - [EX_WireTracepoint](api/uassetapi.kismet.bytecode.expressions.ex_wiretracepoint.md)
    - [FKismetSwitchCase](api/uassetapi.kismet.bytecode.expressions.fkismetswitchcase.md)
  - [UAssetAPI.PropertyTypes.Objects]()
    - [AncestryInfo](api/uassetapi.propertytypes.objects.ancestryinfo.md)
    - [ArrayPropertyData](api/uassetapi.propertytypes.objects.arraypropertydata.md)
    - [AssetObjectPropertyData](api/uassetapi.propertytypes.objects.assetobjectpropertydata.md)
    - [BasePropertyData&lt;T&gt;](api/uassetapi.propertytypes.objects.basepropertydata-1.md)
    - [BoolPropertyData](api/uassetapi.propertytypes.objects.boolpropertydata.md)
    - [BytePropertyData](api/uassetapi.propertytypes.objects.bytepropertydata.md)
    - [BytePropertyType](api/uassetapi.propertytypes.objects.bytepropertytype.md)
    - [DelegatePropertyData](api/uassetapi.propertytypes.objects.delegatepropertydata.md)
    - [DoublePropertyData](api/uassetapi.propertytypes.objects.doublepropertydata.md)
    - [EnumPropertyData](api/uassetapi.propertytypes.objects.enumpropertydata.md)
    - [EOverriddenPropertyOperation](api/uassetapi.propertytypes.objects.eoverriddenpropertyoperation.md)
    - [EPropertyTagExtension](api/uassetapi.propertytypes.objects.epropertytagextension.md)
    - [EPropertyTagFlags](api/uassetapi.propertytypes.objects.epropertytagflags.md)
    - [ETextFlag](api/uassetapi.propertytypes.objects.etextflag.md)
    - [ETransformType](api/uassetapi.propertytypes.objects.etransformtype.md)
    - [FDelegate](api/uassetapi.propertytypes.objects.fdelegate.md)
    - [FFormatArgumentData](api/uassetapi.propertytypes.objects.fformatargumentdata.md)
    - [FFormatArgumentValue](api/uassetapi.propertytypes.objects.fformatargumentvalue.md)
    - [FieldPathPropertyData](api/uassetapi.propertytypes.objects.fieldpathpropertydata.md)
    - [FloatPropertyData](api/uassetapi.propertytypes.objects.floatpropertydata.md)
    - [FNumberFormattingOptions](api/uassetapi.propertytypes.objects.fnumberformattingoptions.md)
    - [FSoftObjectPath](api/uassetapi.propertytypes.objects.fsoftobjectpath.md)
    - [FTopLevelAssetPath](api/uassetapi.propertytypes.objects.ftoplevelassetpath.md)
    - [Int16PropertyData](api/uassetapi.propertytypes.objects.int16propertydata.md)
    - [Int64PropertyData](api/uassetapi.propertytypes.objects.int64propertydata.md)
    - [Int8PropertyData](api/uassetapi.propertytypes.objects.int8propertydata.md)
    - [InterfacePropertyData](api/uassetapi.propertytypes.objects.interfacepropertydata.md)
    - [IntPropertyData](api/uassetapi.propertytypes.objects.intpropertydata.md)
    - [IStruct&lt;T&gt;](api/uassetapi.propertytypes.objects.istruct-1.md)
    - [MapPropertyData](api/uassetapi.propertytypes.objects.mappropertydata.md)
    - [MulticastDelegatePropertyData](api/uassetapi.propertytypes.objects.multicastdelegatepropertydata.md)
    - [MulticastInlineDelegatePropertyData](api/uassetapi.propertytypes.objects.multicastinlinedelegatepropertydata.md)
    - [MulticastSparseDelegatePropertyData](api/uassetapi.propertytypes.objects.multicastsparsedelegatepropertydata.md)
    - [NamePropertyData](api/uassetapi.propertytypes.objects.namepropertydata.md)
    - [ObjectPropertyData](api/uassetapi.propertytypes.objects.objectpropertydata.md)
    - [PropertyData](api/uassetapi.propertytypes.objects.propertydata.md)
    - [PropertyData&lt;T&gt;](api/uassetapi.propertytypes.objects.propertydata-1.md)
    - [PropertySerializationContext](api/uassetapi.propertytypes.objects.propertyserializationcontext.md)
    - [SetPropertyData](api/uassetapi.propertytypes.objects.setpropertydata.md)
    - [SoftObjectPropertyData](api/uassetapi.propertytypes.objects.softobjectpropertydata.md)
    - [StrPropertyData](api/uassetapi.propertytypes.objects.strpropertydata.md)
    - [TextHistoryType](api/uassetapi.propertytypes.objects.texthistorytype.md)
    - [TextPropertyData](api/uassetapi.propertytypes.objects.textpropertydata.md)
    - [UInt16PropertyData](api/uassetapi.propertytypes.objects.uint16propertydata.md)
    - [UInt32PropertyData](api/uassetapi.propertytypes.objects.uint32propertydata.md)
    - [UInt64PropertyData](api/uassetapi.propertytypes.objects.uint64propertydata.md)
    - [UnknownPropertyData](api/uassetapi.propertytypes.objects.unknownpropertydata.md)
    - [WeakObjectPropertyData](api/uassetapi.propertytypes.objects.weakobjectpropertydata.md)
  - [UAssetAPI.PropertyTypes.Structs]()
    - [Box2DPropertyData](api/uassetapi.propertytypes.structs.box2dpropertydata.md)
    - [Box2fPropertyData](api/uassetapi.propertytypes.structs.box2fpropertydata.md)
    - [BoxPropertyData](api/uassetapi.propertytypes.structs.boxpropertydata.md)
    - [ClothLODDataCommonPropertyData](api/uassetapi.propertytypes.structs.clothloddatacommonpropertydata.md)
    - [ClothLODDataPropertyData](api/uassetapi.propertytypes.structs.clothloddatapropertydata.md)
    - [ClothTetherDataPropertyData](api/uassetapi.propertytypes.structs.clothtetherdatapropertydata.md)
    - [ColorMaterialInputPropertyData](api/uassetapi.propertytypes.structs.colormaterialinputpropertydata.md)
    - [ColorPropertyData](api/uassetapi.propertytypes.structs.colorpropertydata.md)
    - [DateTimePropertyData](api/uassetapi.propertytypes.structs.datetimepropertydata.md)
    - [DeprecateSlateVector2DPropertyData](api/uassetapi.propertytypes.structs.deprecateslatevector2dpropertydata.md)
    - [ESectionEvaluationFlags](api/uassetapi.propertytypes.structs.esectionevaluationflags.md)
    - [ExpressionInputPropertyData](api/uassetapi.propertytypes.structs.expressioninputpropertydata.md)
    - [FEntityAndMetaDataIndex](api/uassetapi.propertytypes.structs.fentityandmetadataindex.md)
    - [FEntry](api/uassetapi.propertytypes.structs.fentry.md)
    - [FEvaluationTreeEntryHandle](api/uassetapi.propertytypes.structs.fevaluationtreeentryhandle.md)
    - [FLevelSequenceLegacyObjectReference](api/uassetapi.propertytypes.structs.flevelsequencelegacyobjectreference.md)
    - [FloatRangePropertyData](api/uassetapi.propertytypes.structs.floatrangepropertydata.md)
    - [FMeshToMeshVertData](api/uassetapi.propertytypes.structs.fmeshtomeshvertdata.md)
    - [FMovieSceneChannel&lt;T&gt;](api/uassetapi.propertytypes.structs.fmoviescenechannel-1.md)
    - [FMovieSceneDoubleChannel](api/uassetapi.propertytypes.structs.fmoviescenedoublechannel.md)
    - [FMovieSceneDoubleValue](api/uassetapi.propertytypes.structs.fmoviescenedoublevalue.md)
    - [FMovieSceneEvaluationFieldEntityTree](api/uassetapi.propertytypes.structs.fmoviesceneevaluationfieldentitytree.md)
    - [FMovieSceneEvaluationKey](api/uassetapi.propertytypes.structs.fmoviesceneevaluationkey.md)
    - [FMovieSceneEvaluationTree](api/uassetapi.propertytypes.structs.fmoviesceneevaluationtree.md)
    - [FMovieSceneEvaluationTreeNode](api/uassetapi.propertytypes.structs.fmoviesceneevaluationtreenode.md)
    - [FMovieSceneEvaluationTreeNodeHandle](api/uassetapi.propertytypes.structs.fmoviesceneevaluationtreenodehandle.md)
    - [FMovieSceneEventParameters](api/uassetapi.propertytypes.structs.fmoviesceneeventparameters.md)
    - [FMovieSceneFloatChannel](api/uassetapi.propertytypes.structs.fmoviescenefloatchannel.md)
    - [FMovieSceneFloatValue](api/uassetapi.propertytypes.structs.fmoviescenefloatvalue.md)
    - [FMovieSceneSegment](api/uassetapi.propertytypes.structs.fmoviescenesegment.md)
    - [FMovieSceneSubSectionData](api/uassetapi.propertytypes.structs.fmoviescenesubsectiondata.md)
    - [FMovieSceneSubSectionFieldData](api/uassetapi.propertytypes.structs.fmoviescenesubsectionfielddata.md)
    - [FMovieSceneSubSequenceTree](api/uassetapi.propertytypes.structs.fmoviescenesubsequencetree.md)
    - [FMovieSceneSubSequenceTreeEntry](api/uassetapi.propertytypes.structs.fmoviescenesubsequencetreeentry.md)
    - [FMovieSceneTangentData](api/uassetapi.propertytypes.structs.fmoviescenetangentdata.md)
    - [FMovieSceneTrackFieldData](api/uassetapi.propertytypes.structs.fmoviescenetrackfielddata.md)
    - [FMovieSceneValue&lt;T&gt;](api/uassetapi.propertytypes.structs.fmoviescenevalue-1.md)
    - [FNameCurveKey](api/uassetapi.propertytypes.structs.fnamecurvekey.md)
    - [FNavAgentSelector](api/uassetapi.propertytypes.structs.fnavagentselector.md)
    - [FontCharacterPropertyData](api/uassetapi.propertytypes.structs.fontcharacterpropertydata.md)
    - [FontDataPropertyData](api/uassetapi.propertytypes.structs.fontdatapropertydata.md)
    - [FrameNumberPropertyData](api/uassetapi.propertytypes.structs.framenumberpropertydata.md)
    - [FSectionEvaluationDataTree](api/uassetapi.propertytypes.structs.fsectionevaluationdatatree.md)
    - [FStringCurveKey](api/uassetapi.propertytypes.structs.fstringcurvekey.md)
    - [GameplayTagContainerPropertyData](api/uassetapi.propertytypes.structs.gameplaytagcontainerpropertydata.md)
    - [GuidPropertyData](api/uassetapi.propertytypes.structs.guidpropertydata.md)
    - [IntPointPropertyData](api/uassetapi.propertytypes.structs.intpointpropertydata.md)
    - [IntVector2PropertyData](api/uassetapi.propertytypes.structs.intvector2propertydata.md)
    - [IntVectorPropertyData](api/uassetapi.propertytypes.structs.intvectorpropertydata.md)
    - [KeyHandleMapPropertyData](api/uassetapi.propertytypes.structs.keyhandlemappropertydata.md)
    - [LevelSequenceObjectReferenceMapPropertyData](api/uassetapi.propertytypes.structs.levelsequenceobjectreferencemappropertydata.md)
    - [LinearColorPropertyData](api/uassetapi.propertytypes.structs.linearcolorpropertydata.md)
    - [MaterialAttributesInputPropertyData](api/uassetapi.propertytypes.structs.materialattributesinputpropertydata.md)
    - [MaterialInputPropertyData&lt;T&gt;](api/uassetapi.propertytypes.structs.materialinputpropertydata-1.md)
    - [MaterialOverrideNanitePropertyData](api/uassetapi.propertytypes.structs.materialoverridenanitepropertydata.md)
    - [MatrixPropertyData](api/uassetapi.propertytypes.structs.matrixpropertydata.md)
    - [MovieSceneDoubleChannelPropertyData](api/uassetapi.propertytypes.structs.moviescenedoublechannelpropertydata.md)
    - [MovieSceneEvalTemplatePtrPropertyData](api/uassetapi.propertytypes.structs.moviesceneevaltemplateptrpropertydata.md)
    - [MovieSceneEvaluationFieldEntityTreePropertyData](api/uassetapi.propertytypes.structs.moviesceneevaluationfieldentitytreepropertydata.md)
    - [MovieSceneEvaluationKeyPropertyData](api/uassetapi.propertytypes.structs.moviesceneevaluationkeypropertydata.md)
    - [MovieSceneEventParametersPropertyData](api/uassetapi.propertytypes.structs.moviesceneeventparameterspropertydata.md)
    - [MovieSceneFloatChannelPropertyData](api/uassetapi.propertytypes.structs.moviescenefloatchannelpropertydata.md)
    - [MovieSceneFloatValuePropertyData](api/uassetapi.propertytypes.structs.moviescenefloatvaluepropertydata.md)
    - [MovieSceneFrameRangePropertyData](api/uassetapi.propertytypes.structs.moviesceneframerangepropertydata.md)
    - [MovieSceneGenerationLedgerPropertyData](api/uassetapi.propertytypes.structs.moviescenegenerationledgerpropertydata.md)
    - [MovieSceneSegmentIdentifierPropertyData](api/uassetapi.propertytypes.structs.moviescenesegmentidentifierpropertydata.md)
    - [MovieSceneSegmentPropertyData](api/uassetapi.propertytypes.structs.moviescenesegmentpropertydata.md)
    - [MovieSceneSequenceIDPropertyData](api/uassetapi.propertytypes.structs.moviescenesequenceidpropertydata.md)
    - [MovieSceneSequenceInstanceDataPtrPropertyData](api/uassetapi.propertytypes.structs.moviescenesequenceinstancedataptrpropertydata.md)
    - [MovieSceneSubSectionFieldDataPropertyData](api/uassetapi.propertytypes.structs.moviescenesubsectionfielddatapropertydata.md)
    - [MovieSceneSubSequenceTreePropertyData](api/uassetapi.propertytypes.structs.moviescenesubsequencetreepropertydata.md)
    - [MovieSceneTemplatePropertyData](api/uassetapi.propertytypes.structs.moviescenetemplatepropertydata.md)
    - [MovieSceneTrackFieldDataPropertyData](api/uassetapi.propertytypes.structs.moviescenetrackfielddatapropertydata.md)
    - [MovieSceneTrackIdentifierPropertyData](api/uassetapi.propertytypes.structs.moviescenetrackidentifierpropertydata.md)
    - [MovieSceneTrackImplementationPtrPropertyData](api/uassetapi.propertytypes.structs.moviescenetrackimplementationptrpropertydata.md)
    - [NameCurveKeyPropertyData](api/uassetapi.propertytypes.structs.namecurvekeypropertydata.md)
    - [NavAgentSelectorPropertyData](api/uassetapi.propertytypes.structs.navagentselectorpropertydata.md)
    - [NiagaraDataChannelVariablePropertyData](api/uassetapi.propertytypes.structs.niagaradatachannelvariablepropertydata.md)
    - [NiagaraDataInterfaceGPUParamInfoPropertyData](api/uassetapi.propertytypes.structs.niagaradatainterfacegpuparaminfopropertydata.md)
    - [NiagaraVariableBasePropertyData](api/uassetapi.propertytypes.structs.niagaravariablebasepropertydata.md)
    - [NiagaraVariablePropertyData](api/uassetapi.propertytypes.structs.niagaravariablepropertydata.md)
    - [NiagaraVariableWithOffsetPropertyData](api/uassetapi.propertytypes.structs.niagaravariablewithoffsetpropertydata.md)
    - [PerPlatformBoolPropertyData](api/uassetapi.propertytypes.structs.perplatformboolpropertydata.md)
    - [PerPlatformFloatPropertyData](api/uassetapi.propertytypes.structs.perplatformfloatpropertydata.md)
    - [PerPlatformFrameRatePropertyData](api/uassetapi.propertytypes.structs.perplatformframeratepropertydata.md)
    - [PerPlatformIntPropertyData](api/uassetapi.propertytypes.structs.perplatformintpropertydata.md)
    - [PerQualityLevelFloatPropertyData](api/uassetapi.propertytypes.structs.perqualitylevelfloatpropertydata.md)
    - [PerQualityLevelIntPropertyData](api/uassetapi.propertytypes.structs.perqualitylevelintpropertydata.md)
    - [PlanePropertyData](api/uassetapi.propertytypes.structs.planepropertydata.md)
    - [QuatPropertyData](api/uassetapi.propertytypes.structs.quatpropertydata.md)
    - [RawStructPropertyData](api/uassetapi.propertytypes.structs.rawstructpropertydata.md)
    - [RichCurveKeyPropertyData](api/uassetapi.propertytypes.structs.richcurvekeypropertydata.md)
    - [RotatorPropertyData](api/uassetapi.propertytypes.structs.rotatorpropertydata.md)
    - [ScalarMaterialInputPropertyData](api/uassetapi.propertytypes.structs.scalarmaterialinputpropertydata.md)
    - [SectionEvaluationDataTreePropertyData](api/uassetapi.propertytypes.structs.sectionevaluationdatatreepropertydata.md)
    - [SkeletalMeshAreaWeightedTriangleSamplerPropertyData](api/uassetapi.propertytypes.structs.skeletalmeshareaweightedtrianglesamplerpropertydata.md)
    - [SkeletalMeshSamplingLODBuiltDataPropertyData](api/uassetapi.propertytypes.structs.skeletalmeshsamplinglodbuiltdatapropertydata.md)
    - [SmartNamePropertyData](api/uassetapi.propertytypes.structs.smartnamepropertydata.md)
    - [SoftAssetPathPropertyData](api/uassetapi.propertytypes.structs.softassetpathpropertydata.md)
    - [SoftClassPathPropertyData](api/uassetapi.propertytypes.structs.softclasspathpropertydata.md)
    - [SoftObjectPathPropertyData](api/uassetapi.propertytypes.structs.softobjectpathpropertydata.md)
    - [StringAssetReferencePropertyData](api/uassetapi.propertytypes.structs.stringassetreferencepropertydata.md)
    - [StringClassReferencePropertyData](api/uassetapi.propertytypes.structs.stringclassreferencepropertydata.md)
    - [StringCurveKeyPropertyData](api/uassetapi.propertytypes.structs.stringcurvekeypropertydata.md)
    - [StructPropertyData](api/uassetapi.propertytypes.structs.structpropertydata.md)
    - [TBoxPropertyData&lt;T&gt;](api/uassetapi.propertytypes.structs.tboxpropertydata-1.md)
    - [TEvaluationTreeEntryContainer&lt;T&gt;](api/uassetapi.propertytypes.structs.tevaluationtreeentrycontainer-1.md)
    - [TimespanPropertyData](api/uassetapi.propertytypes.structs.timespanpropertydata.md)
    - [TMovieSceneEvaluationTree&lt;T&gt;](api/uassetapi.propertytypes.structs.tmoviesceneevaluationtree-1.md)
    - [TPerPlatformPropertyData&lt;T&gt;](api/uassetapi.propertytypes.structs.tperplatformpropertydata-1.md)
    - [TPerQualityLevelPropertyData&lt;T&gt;](api/uassetapi.propertytypes.structs.tperqualitylevelpropertydata-1.md)
    - [TwoVectorsPropertyData](api/uassetapi.propertytypes.structs.twovectorspropertydata.md)
    - [Vector2DPropertyData](api/uassetapi.propertytypes.structs.vector2dpropertydata.md)
    - [Vector2fPropertyData](api/uassetapi.propertytypes.structs.vector2fpropertydata.md)
    - [Vector2MaterialInputPropertyData](api/uassetapi.propertytypes.structs.vector2materialinputpropertydata.md)
    - [Vector3fPropertyData](api/uassetapi.propertytypes.structs.vector3fpropertydata.md)
    - [Vector4fPropertyData](api/uassetapi.propertytypes.structs.vector4fpropertydata.md)
    - [Vector4PropertyData](api/uassetapi.propertytypes.structs.vector4propertydata.md)
    - [VectorMaterialInputPropertyData](api/uassetapi.propertytypes.structs.vectormaterialinputpropertydata.md)
    - [VectorNetQuantize100PropertyData](api/uassetapi.propertytypes.structs.vectornetquantize100propertydata.md)
    - [VectorNetQuantize10PropertyData](api/uassetapi.propertytypes.structs.vectornetquantize10propertydata.md)
    - [VectorNetQuantizeNormalPropertyData](api/uassetapi.propertytypes.structs.vectornetquantizenormalpropertydata.md)
    - [VectorNetQuantizePropertyData](api/uassetapi.propertytypes.structs.vectornetquantizepropertydata.md)
    - [VectorPropertyData](api/uassetapi.propertytypes.structs.vectorpropertydata.md)
    - [ViewTargetBlendFunction](api/uassetapi.propertytypes.structs.viewtargetblendfunction.md)
    - [ViewTargetBlendParamsPropertyData](api/uassetapi.propertytypes.structs.viewtargetblendparamspropertydata.md)
    - [WeightedRandomSamplerPropertyData](api/uassetapi.propertytypes.structs.weightedrandomsamplerpropertydata.md)
  - [UAssetAPI.StructTypes]()
    - [SkeletalMeshSamplingRegionBuiltDataPropertyData](api/uassetapi.structtypes.skeletalmeshsamplingregionbuiltdatapropertydata.md)
  - [UAssetAPI.UnrealTypes]()
    - [Comparer2&lt;T&gt;](api/uassetapi.unrealtypes.comparer2-1.md)
    - [DictionaryEnumerator&lt;TKey, TValue&gt;](api/uassetapi.unrealtypes.dictionaryenumerator-2.md)
    - [EAxis](api/uassetapi.unrealtypes.eaxis.md)
    - [EClassFlags](api/uassetapi.unrealtypes.eclassflags.md)
    - [EFontHinting](api/uassetapi.unrealtypes.efonthinting.md)
    - [EFontLoadingPolicy](api/uassetapi.unrealtypes.efontloadingpolicy.md)
    - [EFunctionFlags](api/uassetapi.unrealtypes.efunctionflags.md)
    - [EInterpCurveMode](api/uassetapi.unrealtypes.einterpcurvemode.md)
    - [EMappedNameType](api/uassetapi.unrealtypes.emappednametype.md)
    - [EngineVersion](api/uassetapi.unrealtypes.engineversion.md)
    - [EObjectDataResourceFlags](api/uassetapi.unrealtypes.eobjectdataresourceflags.md)
    - [EObjectDataResourceVersion](api/uassetapi.unrealtypes.eobjectdataresourceversion.md)
    - [EObjectFlags](api/uassetapi.unrealtypes.eobjectflags.md)
    - [EPackageFlags](api/uassetapi.unrealtypes.epackageflags.md)
    - [EPropertyFlags](api/uassetapi.unrealtypes.epropertyflags.md)
    - [ERangeBoundTypes](api/uassetapi.unrealtypes.erangeboundtypes.md)
    - [FFieldPath](api/uassetapi.unrealtypes.ffieldpath.md)
    - [FFontCharacter](api/uassetapi.unrealtypes.ffontcharacter.md)
    - [FFontData](api/uassetapi.unrealtypes.ffontdata.md)
    - [FFrameNumber](api/uassetapi.unrealtypes.fframenumber.md)
    - [FFrameRate](api/uassetapi.unrealtypes.fframerate.md)
    - [FFrameTime](api/uassetapi.unrealtypes.fframetime.md)
    - [FGatherableTextData](api/uassetapi.unrealtypes.fgatherabletextdata.md)
    - [FIntVector](api/uassetapi.unrealtypes.fintvector.md)
    - [FIntVector2](api/uassetapi.unrealtypes.fintvector2.md)
    - [FLinearColor](api/uassetapi.unrealtypes.flinearcolor.md)
    - [FLocMetadataObject](api/uassetapi.unrealtypes.flocmetadataobject.md)
    - [FMatrix](api/uassetapi.unrealtypes.fmatrix.md)
    - [FName](api/uassetapi.unrealtypes.fname.md)
    - [FNiagaraDataInterfaceGeneratedFunction](api/uassetapi.unrealtypes.fniagaradatainterfacegeneratedfunction.md)
    - [FNiagaraDataInterfaceGPUParamInfo](api/uassetapi.unrealtypes.fniagaradatainterfacegpuparaminfo.md)
    - [FNiagaraVariableCommonReference](api/uassetapi.unrealtypes.fniagaravariablecommonreference.md)
    - [FObjectDataResource](api/uassetapi.unrealtypes.fobjectdataresource.md)
    - [FObjectThumbnail](api/uassetapi.unrealtypes.fobjectthumbnail.md)
    - [FPackageIndex](api/uassetapi.unrealtypes.fpackageindex.md)
    - [FPlane](api/uassetapi.unrealtypes.fplane.md)
    - [FPropertyTypeName](api/uassetapi.unrealtypes.fpropertytypename.md)
    - [FPropertyTypeNameConverter](api/uassetapi.unrealtypes.fpropertytypenameconverter.md)
    - [FPropertyTypeNameNode](api/uassetapi.unrealtypes.fpropertytypenamenode.md)
    - [FQualifiedFrameTime](api/uassetapi.unrealtypes.fqualifiedframetime.md)
    - [FQuat](api/uassetapi.unrealtypes.fquat.md)
    - [FRichCurveKey](api/uassetapi.unrealtypes.frichcurvekey.md)
    - [FRotator](api/uassetapi.unrealtypes.frotator.md)
    - [FSkeletalMeshAreaWeightedTriangleSampler](api/uassetapi.unrealtypes.fskeletalmeshareaweightedtrianglesampler.md)
    - [FSkeletalMeshSamplingRegionBuiltData](api/uassetapi.unrealtypes.fskeletalmeshsamplingregionbuiltdata.md)
    - [FString](api/uassetapi.unrealtypes.fstring.md)
    - [FTextSourceData](api/uassetapi.unrealtypes.ftextsourcedata.md)
    - [FTextSourceSiteContext](api/uassetapi.unrealtypes.ftextsourcesitecontext.md)
    - [FTimecode](api/uassetapi.unrealtypes.ftimecode.md)
    - [FTransform](api/uassetapi.unrealtypes.ftransform.md)
    - [FTwoVectors](api/uassetapi.unrealtypes.ftwovectors.md)
    - [FUniqueNetId](api/uassetapi.unrealtypes.funiquenetid.md)
    - [FVector](api/uassetapi.unrealtypes.fvector.md)
    - [FVector2D](api/uassetapi.unrealtypes.fvector2d.md)
    - [FVector2f](api/uassetapi.unrealtypes.fvector2f.md)
    - [FVector3f](api/uassetapi.unrealtypes.fvector3f.md)
    - [FVector4](api/uassetapi.unrealtypes.fvector4.md)
    - [FVector4f](api/uassetapi.unrealtypes.fvector4f.md)
    - [FWeightedRandomSampler](api/uassetapi.unrealtypes.fweightedrandomsampler.md)
    - [FWorldTileInfo](api/uassetapi.unrealtypes.fworldtileinfo.md)
    - [FWorldTileLayer](api/uassetapi.unrealtypes.fworldtilelayer.md)
    - [FWorldTileLODInfo](api/uassetapi.unrealtypes.fworldtilelodinfo.md)
    - [IOrderedDictionary&lt;TKey, TValue&gt;](api/uassetapi.unrealtypes.iordereddictionary-2.md)
    - [KeyedCollection2&lt;TKey, TItem&gt;](api/uassetapi.unrealtypes.keyedcollection2-2.md)
    - [LinearHelpers](api/uassetapi.unrealtypes.linearhelpers.md)
    - [ObjectVersion](api/uassetapi.unrealtypes.objectversion.md)
    - [ObjectVersionUE5](api/uassetapi.unrealtypes.objectversionue5.md)
    - [TBox&lt;T&gt;](api/uassetapi.unrealtypes.tbox-1.md)
    - [TMap&lt;TKey, TValue&gt;](api/uassetapi.unrealtypes.tmap-2.md)
    - [TPerQualityLevel&lt;T&gt;](api/uassetapi.unrealtypes.tperqualitylevel-1.md)
    - [TRange&lt;T&gt;](api/uassetapi.unrealtypes.trange-1.md)
    - [TRangeBound&lt;T&gt;](api/uassetapi.unrealtypes.trangebound-1.md)
    - [UE4VersionToObjectVersion](api/uassetapi.unrealtypes.ue4versiontoobjectversion.md)
    - [UE5VersionToObjectVersion](api/uassetapi.unrealtypes.ue5versiontoobjectversion.md)
    - [UniqueNetIdReplPropertyData](api/uassetapi.unrealtypes.uniquenetidreplpropertydata.md)
    - [UniversalObjectLocatorFragmentPropertyData](api/uassetapi.unrealtypes.universalobjectlocatorfragmentpropertydata.md)
  - [UAssetAPI.UnrealTypes.EngineEnums]()
    - [AnimationCompressionFormat](api/uassetapi.unrealtypes.engineenums.animationcompressionformat.md)
    - [AnimationKeyFormat](api/uassetapi.unrealtypes.engineenums.animationkeyformat.md)
    - [AnimPhysCollisionType](api/uassetapi.unrealtypes.engineenums.animphyscollisiontype.md)
    - [AnimPhysTwistAxis](api/uassetapi.unrealtypes.engineenums.animphystwistaxis.md)
    - [Beam2SourceTargetMethod](api/uassetapi.unrealtypes.engineenums.beam2sourcetargetmethod.md)
    - [Beam2SourceTargetTangentMethod](api/uassetapi.unrealtypes.engineenums.beam2sourcetargettangentmethod.md)
    - [BeamModifierType](api/uassetapi.unrealtypes.engineenums.beammodifiertype.md)
    - [CylinderHeightAxis](api/uassetapi.unrealtypes.engineenums.cylinderheightaxis.md)
    - [DistributionParamMode](api/uassetapi.unrealtypes.engineenums.distributionparammode.md)
    - [EActorUpdateOverlapsMethod](api/uassetapi.unrealtypes.engineenums.eactorupdateoverlapsmethod.md)
    - [EAdditiveAnimationType](api/uassetapi.unrealtypes.engineenums.eadditiveanimationtype.md)
    - [EAdditiveBasePoseType](api/uassetapi.unrealtypes.engineenums.eadditivebaseposetype.md)
    - [EAdManagerDelegate](api/uassetapi.unrealtypes.engineenums.eadmanagerdelegate.md)
    - [EAirAbsorptionMethod](api/uassetapi.unrealtypes.engineenums.eairabsorptionmethod.md)
    - [EAlphaBlendOption](api/uassetapi.unrealtypes.engineenums.ealphablendoption.md)
    - [EAlphaChannelMode](api/uassetapi.unrealtypes.engineenums.ealphachannelmode.md)
    - [EAngularConstraintMotion](api/uassetapi.unrealtypes.engineenums.eangularconstraintmotion.md)
    - [EAngularDriveMode](api/uassetapi.unrealtypes.engineenums.eangulardrivemode.md)
    - [EAnimAlphaInputType](api/uassetapi.unrealtypes.engineenums.eanimalphainputtype.md)
    - [EAnimAssetCurveFlags](api/uassetapi.unrealtypes.engineenums.eanimassetcurveflags.md)
    - [EAnimationMode](api/uassetapi.unrealtypes.engineenums.eanimationmode.md)
    - [EAnimCurveType](api/uassetapi.unrealtypes.engineenums.eanimcurvetype.md)
    - [EAnimGroupRole](api/uassetapi.unrealtypes.engineenums.eanimgrouprole.md)
    - [EAnimInterpolationType](api/uassetapi.unrealtypes.engineenums.eaniminterpolationtype.md)
    - [EAnimLinkMethod](api/uassetapi.unrealtypes.engineenums.eanimlinkmethod.md)
    - [EAnimNotifyEventType](api/uassetapi.unrealtypes.engineenums.eanimnotifyeventtype.md)
    - [EAntiAliasingMethod](api/uassetapi.unrealtypes.engineenums.eantialiasingmethod.md)
    - [EApplicationState](api/uassetapi.unrealtypes.engineenums.eapplicationstate.md)
    - [EAspectRatioAxisConstraint](api/uassetapi.unrealtypes.engineenums.easpectratioaxisconstraint.md)
    - [EAttachLocation](api/uassetapi.unrealtypes.engineenums.eattachlocation.md)
    - [EAttachmentRule](api/uassetapi.unrealtypes.engineenums.eattachmentrule.md)
    - [EAttenuationDistanceModel](api/uassetapi.unrealtypes.engineenums.eattenuationdistancemodel.md)
    - [EAttenuationShape](api/uassetapi.unrealtypes.engineenums.eattenuationshape.md)
    - [EAttractorParticleSelectionMethod](api/uassetapi.unrealtypes.engineenums.eattractorparticleselectionmethod.md)
    - [EAudioComponentPlayState](api/uassetapi.unrealtypes.engineenums.eaudiocomponentplaystate.md)
    - [EAudioFaderCurve](api/uassetapi.unrealtypes.engineenums.eaudiofadercurve.md)
    - [EAudioOutputTarget](api/uassetapi.unrealtypes.engineenums.eaudiooutputtarget.md)
    - [EAudioRecordingExportType](api/uassetapi.unrealtypes.engineenums.eaudiorecordingexporttype.md)
    - [EAutoExposureMethod](api/uassetapi.unrealtypes.engineenums.eautoexposuremethod.md)
    - [EAutoExposureMethodUI](api/uassetapi.unrealtypes.engineenums.eautoexposuremethodui.md)
    - [EAutoPossessAI](api/uassetapi.unrealtypes.engineenums.eautopossessai.md)
    - [EAutoReceiveInput](api/uassetapi.unrealtypes.engineenums.eautoreceiveinput.md)
    - [EAxisOption](api/uassetapi.unrealtypes.engineenums.eaxisoption.md)
    - [EBeam2Method](api/uassetapi.unrealtypes.engineenums.ebeam2method.md)
    - [EBeamTaperMethod](api/uassetapi.unrealtypes.engineenums.ebeamtapermethod.md)
    - [EBlendableLocation](api/uassetapi.unrealtypes.engineenums.eblendablelocation.md)
    - [EBlendMode](api/uassetapi.unrealtypes.engineenums.eblendmode.md)
    - [EBlendSpaceAxis](api/uassetapi.unrealtypes.engineenums.eblendspaceaxis.md)
    - [EBloomMethod](api/uassetapi.unrealtypes.engineenums.ebloommethod.md)
    - [EBlueprintCompileMode](api/uassetapi.unrealtypes.engineenums.eblueprintcompilemode.md)
    - [EBlueprintNativizationFlag](api/uassetapi.unrealtypes.engineenums.eblueprintnativizationflag.md)
    - [EBlueprintPinStyleType](api/uassetapi.unrealtypes.engineenums.eblueprintpinstyletype.md)
    - [EBlueprintStatus](api/uassetapi.unrealtypes.engineenums.eblueprintstatus.md)
    - [EBlueprintType](api/uassetapi.unrealtypes.engineenums.eblueprinttype.md)
    - [EBodyCollisionResponse](api/uassetapi.unrealtypes.engineenums.ebodycollisionresponse.md)
    - [EBoneAxis](api/uassetapi.unrealtypes.engineenums.eboneaxis.md)
    - [EBoneControlSpace](api/uassetapi.unrealtypes.engineenums.ebonecontrolspace.md)
    - [EBoneFilterActionOption](api/uassetapi.unrealtypes.engineenums.ebonefilteractionoption.md)
    - [EBoneRotationSource](api/uassetapi.unrealtypes.engineenums.ebonerotationsource.md)
    - [EBoneSpaces](api/uassetapi.unrealtypes.engineenums.ebonespaces.md)
    - [EBoneTranslationRetargetingMode](api/uassetapi.unrealtypes.engineenums.ebonetranslationretargetingmode.md)
    - [EBoneVisibilityStatus](api/uassetapi.unrealtypes.engineenums.ebonevisibilitystatus.md)
    - [EBrushType](api/uassetapi.unrealtypes.engineenums.ebrushtype.md)
    - [ECameraAlphaBlendMode](api/uassetapi.unrealtypes.engineenums.ecameraalphablendmode.md)
    - [ECameraAnimPlaySpace](api/uassetapi.unrealtypes.engineenums.ecameraanimplayspace.md)
    - [ECameraProjectionMode](api/uassetapi.unrealtypes.engineenums.ecameraprojectionmode.md)
    - [ECameraShakeAttenuation](api/uassetapi.unrealtypes.engineenums.ecamerashakeattenuation.md)
    - [ECanBeCharacterBase](api/uassetapi.unrealtypes.engineenums.ecanbecharacterbase.md)
    - [ECanCreateConnectionResponse](api/uassetapi.unrealtypes.engineenums.ecancreateconnectionresponse.md)
    - [EChannelMaskParameterColor](api/uassetapi.unrealtypes.engineenums.echannelmaskparametercolor.md)
    - [EClampMode](api/uassetapi.unrealtypes.engineenums.eclampmode.md)
    - [EClearSceneOptions](api/uassetapi.unrealtypes.engineenums.eclearsceneoptions.md)
    - [EClothMassMode](api/uassetapi.unrealtypes.engineenums.eclothmassmode.md)
    - [ECloudStorageDelegate](api/uassetapi.unrealtypes.engineenums.ecloudstoragedelegate.md)
    - [ECollisionChannel](api/uassetapi.unrealtypes.engineenums.ecollisionchannel.md)
    - [ECollisionEnabled](api/uassetapi.unrealtypes.engineenums.ecollisionenabled.md)
    - [ECollisionResponse](api/uassetapi.unrealtypes.engineenums.ecollisionresponse.md)
    - [ECollisionTraceFlag](api/uassetapi.unrealtypes.engineenums.ecollisiontraceflag.md)
    - [EComponentCreationMethod](api/uassetapi.unrealtypes.engineenums.ecomponentcreationmethod.md)
    - [EComponentMobility](api/uassetapi.unrealtypes.engineenums.ecomponentmobility.md)
    - [EComponentSocketType](api/uassetapi.unrealtypes.engineenums.ecomponentsockettype.md)
    - [EComponentType](api/uassetapi.unrealtypes.engineenums.ecomponenttype.md)
    - [ECompositeTextureMode](api/uassetapi.unrealtypes.engineenums.ecompositetexturemode.md)
    - [ECompositingSampleCount](api/uassetapi.unrealtypes.engineenums.ecompositingsamplecount.md)
    - [EConstraintFrame](api/uassetapi.unrealtypes.engineenums.econstraintframe.md)
    - [EConstraintTransform](api/uassetapi.unrealtypes.engineenums.econstrainttransform.md)
    - [EControlConstraint](api/uassetapi.unrealtypes.engineenums.econtrolconstraint.md)
    - [EControllerAnalogStick](api/uassetapi.unrealtypes.engineenums.econtrolleranalogstick.md)
    - [ECopyType](api/uassetapi.unrealtypes.engineenums.ecopytype.md)
    - [ECsgOper](api/uassetapi.unrealtypes.engineenums.ecsgoper.md)
    - [ECurveBlendOption](api/uassetapi.unrealtypes.engineenums.ecurveblendoption.md)
    - [ECurveTableMode](api/uassetapi.unrealtypes.engineenums.ecurvetablemode.md)
    - [ECustomDepthStencil](api/uassetapi.unrealtypes.engineenums.ecustomdepthstencil.md)
    - [ECustomMaterialOutputType](api/uassetapi.unrealtypes.engineenums.ecustommaterialoutputtype.md)
    - [ECustomTimeStepSynchronizationState](api/uassetapi.unrealtypes.engineenums.ecustomtimestepsynchronizationstate.md)
    - [EDecalBlendMode](api/uassetapi.unrealtypes.engineenums.edecalblendmode.md)
    - [EDecompressionType](api/uassetapi.unrealtypes.engineenums.edecompressiontype.md)
    - [EDefaultBackBufferPixelFormat](api/uassetapi.unrealtypes.engineenums.edefaultbackbufferpixelformat.md)
    - [EDemoPlayFailure](api/uassetapi.unrealtypes.engineenums.edemoplayfailure.md)
    - [EDepthOfFieldFunctionValue](api/uassetapi.unrealtypes.engineenums.edepthoffieldfunctionvalue.md)
    - [EDepthOfFieldMethod](api/uassetapi.unrealtypes.engineenums.edepthoffieldmethod.md)
    - [EDetachmentRule](api/uassetapi.unrealtypes.engineenums.edetachmentrule.md)
    - [EDetailMode](api/uassetapi.unrealtypes.engineenums.edetailmode.md)
    - [EDistributionVectorLockFlags](api/uassetapi.unrealtypes.engineenums.edistributionvectorlockflags.md)
    - [EDistributionVectorMirrorFlags](api/uassetapi.unrealtypes.engineenums.edistributionvectormirrorflags.md)
    - [EDOFMode](api/uassetapi.unrealtypes.engineenums.edofmode.md)
    - [EDrawDebugItemType](api/uassetapi.unrealtypes.engineenums.edrawdebugitemtype.md)
    - [EDrawDebugTrace](api/uassetapi.unrealtypes.engineenums.edrawdebugtrace.md)
    - [EDynamicForceFeedbackAction](api/uassetapi.unrealtypes.engineenums.edynamicforcefeedbackaction.md)
    - [EEarlyZPass](api/uassetapi.unrealtypes.engineenums.eearlyzpass.md)
    - [EEasingFunc](api/uassetapi.unrealtypes.engineenums.eeasingfunc.md)
    - [EEdGraphPinDirection](api/uassetapi.unrealtypes.engineenums.eedgraphpindirection.md)
    - [EEmitterDynamicParameterValue](api/uassetapi.unrealtypes.engineenums.eemitterdynamicparametervalue.md)
    - [EEmitterNormalsMode](api/uassetapi.unrealtypes.engineenums.eemitternormalsmode.md)
    - [EEmitterRenderMode](api/uassetapi.unrealtypes.engineenums.eemitterrendermode.md)
    - [EEndPlayReason](api/uassetapi.unrealtypes.engineenums.eendplayreason.md)
    - [EEvaluateCurveTableResult](api/uassetapi.unrealtypes.engineenums.eevaluatecurvetableresult.md)
    - [EEvaluatorDataSource](api/uassetapi.unrealtypes.engineenums.eevaluatordatasource.md)
    - [EEvaluatorMode](api/uassetapi.unrealtypes.engineenums.eevaluatormode.md)
    - [EFastArraySerializerDeltaFlags](api/uassetapi.unrealtypes.engineenums.efastarrayserializerdeltaflags.md)
    - [EFilterInterpolationType](api/uassetapi.unrealtypes.engineenums.efilterinterpolationtype.md)
    - [EFontCacheType](api/uassetapi.unrealtypes.engineenums.efontcachetype.md)
    - [EFontImportCharacterSet](api/uassetapi.unrealtypes.engineenums.efontimportcharacterset.md)
    - [EFormatArgumentType](api/uassetapi.unrealtypes.engineenums.eformatargumenttype.md)
    - [EFrictionCombineMode](api/uassetapi.unrealtypes.engineenums.efrictioncombinemode.md)
    - [EFullyLoadPackageType](api/uassetapi.unrealtypes.engineenums.efullyloadpackagetype.md)
    - [EFunctionInputType](api/uassetapi.unrealtypes.engineenums.efunctioninputtype.md)
    - [EGBufferFormat](api/uassetapi.unrealtypes.engineenums.egbufferformat.md)
    - [EGrammaticalGender](api/uassetapi.unrealtypes.engineenums.egrammaticalgender.md)
    - [EGrammaticalNumber](api/uassetapi.unrealtypes.engineenums.egrammaticalnumber.md)
    - [EGraphAxisStyle](api/uassetapi.unrealtypes.engineenums.egraphaxisstyle.md)
    - [EGraphDataStyle](api/uassetapi.unrealtypes.engineenums.egraphdatastyle.md)
    - [EGraphType](api/uassetapi.unrealtypes.engineenums.egraphtype.md)
    - [EHasCustomNavigableGeometry](api/uassetapi.unrealtypes.engineenums.ehascustomnavigablegeometry.md)
    - [EHitProxyPriority](api/uassetapi.unrealtypes.engineenums.ehitproxypriority.md)
    - [EHorizTextAligment](api/uassetapi.unrealtypes.engineenums.ehoriztextaligment.md)
    - [EImportanceLevel](api/uassetapi.unrealtypes.engineenums.eimportancelevel.md)
    - [EImportanceWeight](api/uassetapi.unrealtypes.engineenums.eimportanceweight.md)
    - [EIndirectLightingCacheQuality](api/uassetapi.unrealtypes.engineenums.eindirectlightingcachequality.md)
    - [EInertializationBoneState](api/uassetapi.unrealtypes.engineenums.einertializationbonestate.md)
    - [EInertializationSpace](api/uassetapi.unrealtypes.engineenums.einertializationspace.md)
    - [EInertializationState](api/uassetapi.unrealtypes.engineenums.einertializationstate.md)
    - [EInitialOscillatorOffset](api/uassetapi.unrealtypes.engineenums.einitialoscillatoroffset.md)
    - [EInputEvent](api/uassetapi.unrealtypes.engineenums.einputevent.md)
    - [EInterpMoveAxis](api/uassetapi.unrealtypes.engineenums.einterpmoveaxis.md)
    - [EInterpToBehaviourType](api/uassetapi.unrealtypes.engineenums.einterptobehaviourtype.md)
    - [EInterpTrackMoveRotMode](api/uassetapi.unrealtypes.engineenums.einterptrackmoverotmode.md)
    - [EKinematicBonesUpdateToPhysics](api/uassetapi.unrealtypes.engineenums.ekinematicbonesupdatetophysics.md)
    - [ELandscapeCullingPrecision](api/uassetapi.unrealtypes.engineenums.elandscapecullingprecision.md)
    - [ELegendPosition](api/uassetapi.unrealtypes.engineenums.elegendposition.md)
    - [ELerpInterpolationMode](api/uassetapi.unrealtypes.engineenums.elerpinterpolationmode.md)
    - [ELightingBuildQuality](api/uassetapi.unrealtypes.engineenums.elightingbuildquality.md)
    - [ELightMapPaddingType](api/uassetapi.unrealtypes.engineenums.elightmappaddingtype.md)
    - [ELightmapType](api/uassetapi.unrealtypes.engineenums.elightmaptype.md)
    - [ELightUnits](api/uassetapi.unrealtypes.engineenums.elightunits.md)
    - [ELinearConstraintMotion](api/uassetapi.unrealtypes.engineenums.elinearconstraintmotion.md)
    - [ELocationBoneSocketSelectionMethod](api/uassetapi.unrealtypes.engineenums.elocationbonesocketselectionmethod.md)
    - [ELocationBoneSocketSource](api/uassetapi.unrealtypes.engineenums.elocationbonesocketsource.md)
    - [ELocationEmitterSelectionMethod](api/uassetapi.unrealtypes.engineenums.elocationemitterselectionmethod.md)
    - [ELocationSkelVertSurfaceSource](api/uassetapi.unrealtypes.engineenums.elocationskelvertsurfacesource.md)
    - [EMaterialAttributeBlend](api/uassetapi.unrealtypes.engineenums.ematerialattributeblend.md)
    - [EMaterialDecalResponse](api/uassetapi.unrealtypes.engineenums.ematerialdecalresponse.md)
    - [EMaterialDomain](api/uassetapi.unrealtypes.engineenums.ematerialdomain.md)
    - [EMaterialExposedTextureProperty](api/uassetapi.unrealtypes.engineenums.ematerialexposedtextureproperty.md)
    - [EMaterialExposedViewProperty](api/uassetapi.unrealtypes.engineenums.ematerialexposedviewproperty.md)
    - [EMaterialFunctionUsage](api/uassetapi.unrealtypes.engineenums.ematerialfunctionusage.md)
    - [EMaterialMergeType](api/uassetapi.unrealtypes.engineenums.ematerialmergetype.md)
    - [EMaterialParameterAssociation](api/uassetapi.unrealtypes.engineenums.ematerialparameterassociation.md)
    - [EMaterialPositionTransformSource](api/uassetapi.unrealtypes.engineenums.ematerialpositiontransformsource.md)
    - [EMaterialProperty](api/uassetapi.unrealtypes.engineenums.ematerialproperty.md)
    - [EMaterialSamplerType](api/uassetapi.unrealtypes.engineenums.ematerialsamplertype.md)
    - [EMaterialSceneAttributeInputMode](api/uassetapi.unrealtypes.engineenums.ematerialsceneattributeinputmode.md)
    - [EMaterialShadingModel](api/uassetapi.unrealtypes.engineenums.ematerialshadingmodel.md)
    - [EMaterialStencilCompare](api/uassetapi.unrealtypes.engineenums.ematerialstencilcompare.md)
    - [EMaterialTessellationMode](api/uassetapi.unrealtypes.engineenums.ematerialtessellationmode.md)
    - [EMaterialUsage](api/uassetapi.unrealtypes.engineenums.ematerialusage.md)
    - [EMaterialVectorCoordTransform](api/uassetapi.unrealtypes.engineenums.ematerialvectorcoordtransform.md)
    - [EMaterialVectorCoordTransformSource](api/uassetapi.unrealtypes.engineenums.ematerialvectorcoordtransformsource.md)
    - [EMatrixColumns](api/uassetapi.unrealtypes.engineenums.ematrixcolumns.md)
    - [EMaxConcurrentResolutionRule](api/uassetapi.unrealtypes.engineenums.emaxconcurrentresolutionrule.md)
    - [EMeshBufferAccess](api/uassetapi.unrealtypes.engineenums.emeshbufferaccess.md)
    - [EMeshCameraFacingOptions](api/uassetapi.unrealtypes.engineenums.emeshcamerafacingoptions.md)
    - [EMeshCameraFacingUpAxis](api/uassetapi.unrealtypes.engineenums.emeshcamerafacingupaxis.md)
    - [EMeshFeatureImportance](api/uassetapi.unrealtypes.engineenums.emeshfeatureimportance.md)
    - [EMeshInstancingReplacementMethod](api/uassetapi.unrealtypes.engineenums.emeshinstancingreplacementmethod.md)
    - [EMeshLODSelectionType](api/uassetapi.unrealtypes.engineenums.emeshlodselectiontype.md)
    - [EMeshMergeType](api/uassetapi.unrealtypes.engineenums.emeshmergetype.md)
    - [EMeshScreenAlignment](api/uassetapi.unrealtypes.engineenums.emeshscreenalignment.md)
    - [EMicroTransactionDelegate](api/uassetapi.unrealtypes.engineenums.emicrotransactiondelegate.md)
    - [EMicroTransactionResult](api/uassetapi.unrealtypes.engineenums.emicrotransactionresult.md)
    - [EMobileMSAASampleCount](api/uassetapi.unrealtypes.engineenums.emobilemsaasamplecount.md)
    - [EModuleType](api/uassetapi.unrealtypes.engineenums.emoduletype.md)
    - [EMonoChannelUpmixMethod](api/uassetapi.unrealtypes.engineenums.emonochannelupmixmethod.md)
    - [EMontageNotifyTickType](api/uassetapi.unrealtypes.engineenums.emontagenotifyticktype.md)
    - [EMontagePlayReturnType](api/uassetapi.unrealtypes.engineenums.emontageplayreturntype.md)
    - [EMontageSubStepResult](api/uassetapi.unrealtypes.engineenums.emontagesubstepresult.md)
    - [EMouseCaptureMode](api/uassetapi.unrealtypes.engineenums.emousecapturemode.md)
    - [EMouseLockMode](api/uassetapi.unrealtypes.engineenums.emouselockmode.md)
    - [EMoveComponentAction](api/uassetapi.unrealtypes.engineenums.emovecomponentaction.md)
    - [EMovementMode](api/uassetapi.unrealtypes.engineenums.emovementmode.md)
    - [ENaturalSoundFalloffMode](api/uassetapi.unrealtypes.engineenums.enaturalsoundfalloffmode.md)
    - [ENavDataGatheringMode](api/uassetapi.unrealtypes.engineenums.enavdatagatheringmode.md)
    - [ENavDataGatheringModeConfig](api/uassetapi.unrealtypes.engineenums.enavdatagatheringmodeconfig.md)
    - [ENavigationOptionFlag](api/uassetapi.unrealtypes.engineenums.enavigationoptionflag.md)
    - [ENavigationQueryResult](api/uassetapi.unrealtypes.engineenums.enavigationqueryresult.md)
    - [ENavLinkDirection](api/uassetapi.unrealtypes.engineenums.enavlinkdirection.md)
    - [ENavPathEvent](api/uassetapi.unrealtypes.engineenums.enavpathevent.md)
    - [ENetDormancy](api/uassetapi.unrealtypes.engineenums.enetdormancy.md)
    - [ENetRole](api/uassetapi.unrealtypes.engineenums.enetrole.md)
    - [ENetworkFailure](api/uassetapi.unrealtypes.engineenums.enetworkfailure.md)
    - [ENetworkLagState](api/uassetapi.unrealtypes.engineenums.enetworklagstate.md)
    - [ENetworkSmoothingMode](api/uassetapi.unrealtypes.engineenums.enetworksmoothingmode.md)
    - [ENodeAdvancedPins](api/uassetapi.unrealtypes.engineenums.enodeadvancedpins.md)
    - [ENodeEnabledState](api/uassetapi.unrealtypes.engineenums.enodeenabledstate.md)
    - [ENodeTitleType](api/uassetapi.unrealtypes.engineenums.enodetitletype.md)
    - [ENoiseFunction](api/uassetapi.unrealtypes.engineenums.enoisefunction.md)
    - [ENormalMode](api/uassetapi.unrealtypes.engineenums.enormalmode.md)
    - [ENotifyFilterType](api/uassetapi.unrealtypes.engineenums.enotifyfiltertype.md)
    - [ENotifyTriggerMode](api/uassetapi.unrealtypes.engineenums.enotifytriggermode.md)
    - [EObjectTypeQuery](api/uassetapi.unrealtypes.engineenums.eobjecttypequery.md)
    - [EOcclusionCombineMode](api/uassetapi.unrealtypes.engineenums.eocclusioncombinemode.md)
    - [EOpacitySourceMode](api/uassetapi.unrealtypes.engineenums.eopacitysourcemode.md)
    - [EOptimizationType](api/uassetapi.unrealtypes.engineenums.eoptimizationtype.md)
    - [EOrbitChainMode](api/uassetapi.unrealtypes.engineenums.eorbitchainmode.md)
    - [EOscillatorWaveform](api/uassetapi.unrealtypes.engineenums.eoscillatorwaveform.md)
    - [EOverlapFilterOption](api/uassetapi.unrealtypes.engineenums.eoverlapfilteroption.md)
    - [EPanningMethod](api/uassetapi.unrealtypes.engineenums.epanningmethod.md)
    - [EParticleAxisLock](api/uassetapi.unrealtypes.engineenums.eparticleaxislock.md)
    - [EParticleBurstMethod](api/uassetapi.unrealtypes.engineenums.eparticleburstmethod.md)
    - [EParticleCameraOffsetUpdateMethod](api/uassetapi.unrealtypes.engineenums.eparticlecameraoffsetupdatemethod.md)
    - [EParticleCollisionComplete](api/uassetapi.unrealtypes.engineenums.eparticlecollisioncomplete.md)
    - [EParticleCollisionMode](api/uassetapi.unrealtypes.engineenums.eparticlecollisionmode.md)
    - [EParticleCollisionResponse](api/uassetapi.unrealtypes.engineenums.eparticlecollisionresponse.md)
    - [EParticleDetailMode](api/uassetapi.unrealtypes.engineenums.eparticledetailmode.md)
    - [EParticleEventType](api/uassetapi.unrealtypes.engineenums.eparticleeventtype.md)
    - [EParticleScreenAlignment](api/uassetapi.unrealtypes.engineenums.eparticlescreenalignment.md)
    - [EParticleSignificanceLevel](api/uassetapi.unrealtypes.engineenums.eparticlesignificancelevel.md)
    - [EParticleSortMode](api/uassetapi.unrealtypes.engineenums.eparticlesortmode.md)
    - [EParticleSourceSelectionMethod](api/uassetapi.unrealtypes.engineenums.eparticlesourceselectionmethod.md)
    - [EParticleSubUVInterpMethod](api/uassetapi.unrealtypes.engineenums.eparticlesubuvinterpmethod.md)
    - [EParticleSysParamType](api/uassetapi.unrealtypes.engineenums.eparticlesysparamtype.md)
    - [EParticleSystemInsignificanceReaction](api/uassetapi.unrealtypes.engineenums.eparticlesysteminsignificancereaction.md)
    - [EParticleSystemOcclusionBoundsMethod](api/uassetapi.unrealtypes.engineenums.eparticlesystemocclusionboundsmethod.md)
    - [EParticleSystemUpdateMode](api/uassetapi.unrealtypes.engineenums.eparticlesystemupdatemode.md)
    - [EParticleUVFlipMode](api/uassetapi.unrealtypes.engineenums.eparticleuvflipmode.md)
    - [EPhysBodyOp](api/uassetapi.unrealtypes.engineenums.ephysbodyop.md)
    - [EPhysicalMaterialMaskColor](api/uassetapi.unrealtypes.engineenums.ephysicalmaterialmaskcolor.md)
    - [EPhysicalSurface](api/uassetapi.unrealtypes.engineenums.ephysicalsurface.md)
    - [EPhysicsTransformUpdateMode](api/uassetapi.unrealtypes.engineenums.ephysicstransformupdatemode.md)
    - [EPhysicsType](api/uassetapi.unrealtypes.engineenums.ephysicstype.md)
    - [EPinContainerType](api/uassetapi.unrealtypes.engineenums.epincontainertype.md)
    - [EPinHidingMode](api/uassetapi.unrealtypes.engineenums.epinhidingmode.md)
    - [EPlaneConstraintAxisSetting](api/uassetapi.unrealtypes.engineenums.eplaneconstraintaxissetting.md)
    - [EPlatformInterfaceDataType](api/uassetapi.unrealtypes.engineenums.eplatforminterfacedatatype.md)
    - [EPostCopyOperation](api/uassetapi.unrealtypes.engineenums.epostcopyoperation.md)
    - [EPreviewAnimationBlueprintApplicationMethod](api/uassetapi.unrealtypes.engineenums.epreviewanimationblueprintapplicationmethod.md)
    - [EPrimaryAssetCookRule](api/uassetapi.unrealtypes.engineenums.eprimaryassetcookrule.md)
    - [EPriorityAttenuationMethod](api/uassetapi.unrealtypes.engineenums.epriorityattenuationmethod.md)
    - [EProxyNormalComputationMethod](api/uassetapi.unrealtypes.engineenums.eproxynormalcomputationmethod.md)
    - [EPSCPoolMethod](api/uassetapi.unrealtypes.engineenums.epscpoolmethod.md)
    - [EQuitPreference](api/uassetapi.unrealtypes.engineenums.equitpreference.md)
    - [ERadialImpulseFalloff](api/uassetapi.unrealtypes.engineenums.eradialimpulsefalloff.md)
    - [ERawCurveTrackTypes](api/uassetapi.unrealtypes.engineenums.erawcurvetracktypes.md)
    - [ERayTracingGlobalIlluminationType](api/uassetapi.unrealtypes.engineenums.eraytracingglobalilluminationtype.md)
    - [EReflectedAndRefractedRayTracedShadows](api/uassetapi.unrealtypes.engineenums.ereflectedandrefractedraytracedshadows.md)
    - [EReflectionSourceType](api/uassetapi.unrealtypes.engineenums.ereflectionsourcetype.md)
    - [EReflectionsType](api/uassetapi.unrealtypes.engineenums.ereflectionstype.md)
    - [ERefractionMode](api/uassetapi.unrealtypes.engineenums.erefractionmode.md)
    - [ERelativeTransformSpace](api/uassetapi.unrealtypes.engineenums.erelativetransformspace.md)
    - [ERendererStencilMask](api/uassetapi.unrealtypes.engineenums.erendererstencilmask.md)
    - [ERenderFocusRule](api/uassetapi.unrealtypes.engineenums.erenderfocusrule.md)
    - [EReporterLineStyle](api/uassetapi.unrealtypes.engineenums.ereporterlinestyle.md)
    - [EReverbSendMethod](api/uassetapi.unrealtypes.engineenums.ereverbsendmethod.md)
    - [ERichCurveCompressionFormat](api/uassetapi.unrealtypes.engineenums.erichcurvecompressionformat.md)
    - [ERichCurveExtrapolation](api/uassetapi.unrealtypes.engineenums.erichcurveextrapolation.md)
    - [ERichCurveInterpMode](api/uassetapi.unrealtypes.engineenums.erichcurveinterpmode.md)
    - [ERichCurveKeyTimeCompressionFormat](api/uassetapi.unrealtypes.engineenums.erichcurvekeytimecompressionformat.md)
    - [ERichCurveTangentMode](api/uassetapi.unrealtypes.engineenums.erichcurvetangentmode.md)
    - [ERichCurveTangentWeightMode](api/uassetapi.unrealtypes.engineenums.erichcurvetangentweightmode.md)
    - [ERootMotionAccumulateMode](api/uassetapi.unrealtypes.engineenums.erootmotionaccumulatemode.md)
    - [ERootMotionFinishVelocityMode](api/uassetapi.unrealtypes.engineenums.erootmotionfinishvelocitymode.md)
    - [ERootMotionMode](api/uassetapi.unrealtypes.engineenums.erootmotionmode.md)
    - [ERootMotionRootLock](api/uassetapi.unrealtypes.engineenums.erootmotionrootlock.md)
    - [ERootMotionSourceSettingsFlags](api/uassetapi.unrealtypes.engineenums.erootmotionsourcesettingsflags.md)
    - [ERootMotionSourceStatusFlags](api/uassetapi.unrealtypes.engineenums.erootmotionsourcestatusflags.md)
    - [ERotatorQuantization](api/uassetapi.unrealtypes.engineenums.erotatorquantization.md)
    - [ERoundingMode](api/uassetapi.unrealtypes.engineenums.eroundingmode.md)
    - [ERuntimeVirtualTextureMainPassType](api/uassetapi.unrealtypes.engineenums.eruntimevirtualtexturemainpasstype.md)
    - [ERuntimeVirtualTextureMaterialType](api/uassetapi.unrealtypes.engineenums.eruntimevirtualtexturematerialtype.md)
    - [ERuntimeVirtualTextureMipValueMode](api/uassetapi.unrealtypes.engineenums.eruntimevirtualtexturemipvaluemode.md)
    - [ESamplerSourceMode](api/uassetapi.unrealtypes.engineenums.esamplersourcemode.md)
    - [ESceneCaptureCompositeMode](api/uassetapi.unrealtypes.engineenums.escenecapturecompositemode.md)
    - [ESceneCapturePrimitiveRenderMode](api/uassetapi.unrealtypes.engineenums.escenecaptureprimitiverendermode.md)
    - [ESceneCaptureSource](api/uassetapi.unrealtypes.engineenums.escenecapturesource.md)
    - [ESceneDepthPriorityGroup](api/uassetapi.unrealtypes.engineenums.escenedepthprioritygroup.md)
    - [ESceneTextureId](api/uassetapi.unrealtypes.engineenums.escenetextureid.md)
    - [EScreenOrientation](api/uassetapi.unrealtypes.engineenums.escreenorientation.md)
    - [ESendLevelControlMethod](api/uassetapi.unrealtypes.engineenums.esendlevelcontrolmethod.md)
    - [ESettingsDOF](api/uassetapi.unrealtypes.engineenums.esettingsdof.md)
    - [ESettingsLockedAxis](api/uassetapi.unrealtypes.engineenums.esettingslockedaxis.md)
    - [EShadowMapFlags](api/uassetapi.unrealtypes.engineenums.eshadowmapflags.md)
    - [ESkeletalMeshGeoImportVersions](api/uassetapi.unrealtypes.engineenums.eskeletalmeshgeoimportversions.md)
    - [ESkeletalMeshSkinningImportVersions](api/uassetapi.unrealtypes.engineenums.eskeletalmeshskinningimportversions.md)
    - [ESkinCacheDefaultBehavior](api/uassetapi.unrealtypes.engineenums.eskincachedefaultbehavior.md)
    - [ESkinCacheUsage](api/uassetapi.unrealtypes.engineenums.eskincacheusage.md)
    - [ESkyAtmosphereTransformMode](api/uassetapi.unrealtypes.engineenums.eskyatmospheretransformmode.md)
    - [ESkyLightSourceType](api/uassetapi.unrealtypes.engineenums.eskylightsourcetype.md)
    - [ESlateGesture](api/uassetapi.unrealtypes.engineenums.eslategesture.md)
    - [ESleepFamily](api/uassetapi.unrealtypes.engineenums.esleepfamily.md)
    - [ESoundDistanceCalc](api/uassetapi.unrealtypes.engineenums.esounddistancecalc.md)
    - [ESoundGroup](api/uassetapi.unrealtypes.engineenums.esoundgroup.md)
    - [ESoundSpatializationAlgorithm](api/uassetapi.unrealtypes.engineenums.esoundspatializationalgorithm.md)
    - [ESoundWaveFFTSize](api/uassetapi.unrealtypes.engineenums.esoundwavefftsize.md)
    - [ESoundWaveLoadingBehavior](api/uassetapi.unrealtypes.engineenums.esoundwaveloadingbehavior.md)
    - [ESourceBusChannels](api/uassetapi.unrealtypes.engineenums.esourcebuschannels.md)
    - [ESourceBusSendLevelControlMethod](api/uassetapi.unrealtypes.engineenums.esourcebussendlevelcontrolmethod.md)
    - [ESpawnActorCollisionHandlingMethod](api/uassetapi.unrealtypes.engineenums.espawnactorcollisionhandlingmethod.md)
    - [ESpeedTreeGeometryType](api/uassetapi.unrealtypes.engineenums.espeedtreegeometrytype.md)
    - [ESpeedTreeLODType](api/uassetapi.unrealtypes.engineenums.espeedtreelodtype.md)
    - [ESpeedTreeWindType](api/uassetapi.unrealtypes.engineenums.espeedtreewindtype.md)
    - [ESplineCoordinateSpace](api/uassetapi.unrealtypes.engineenums.esplinecoordinatespace.md)
    - [ESplineMeshAxis](api/uassetapi.unrealtypes.engineenums.esplinemeshaxis.md)
    - [ESplinePointType](api/uassetapi.unrealtypes.engineenums.esplinepointtype.md)
    - [EStandbyType](api/uassetapi.unrealtypes.engineenums.estandbytype.md)
    - [EStaticMeshReductionTerimationCriterion](api/uassetapi.unrealtypes.engineenums.estaticmeshreductionterimationcriterion.md)
    - [EStereoLayerShape](api/uassetapi.unrealtypes.engineenums.estereolayershape.md)
    - [EStereoLayerType](api/uassetapi.unrealtypes.engineenums.estereolayertype.md)
    - [EStreamingVolumeUsage](api/uassetapi.unrealtypes.engineenums.estreamingvolumeusage.md)
    - [ESubmixSendMethod](api/uassetapi.unrealtypes.engineenums.esubmixsendmethod.md)
    - [ESubUVBoundingVertexCount](api/uassetapi.unrealtypes.engineenums.esubuvboundingvertexcount.md)
    - [ESuggestProjVelocityTraceOption](api/uassetapi.unrealtypes.engineenums.esuggestprojvelocitytraceoption.md)
    - [ETeleportType](api/uassetapi.unrealtypes.engineenums.eteleporttype.md)
    - [ETemperatureSeverityType](api/uassetapi.unrealtypes.engineenums.etemperatureseveritytype.md)
    - [ETextGender](api/uassetapi.unrealtypes.engineenums.etextgender.md)
    - [ETextureColorChannel](api/uassetapi.unrealtypes.engineenums.etexturecolorchannel.md)
    - [ETextureCompressionQuality](api/uassetapi.unrealtypes.engineenums.etexturecompressionquality.md)
    - [ETextureLossyCompressionAmount](api/uassetapi.unrealtypes.engineenums.etexturelossycompressionamount.md)
    - [ETextureMipCount](api/uassetapi.unrealtypes.engineenums.etexturemipcount.md)
    - [ETextureMipLoadOptions](api/uassetapi.unrealtypes.engineenums.etexturemiploadoptions.md)
    - [ETextureMipValueMode](api/uassetapi.unrealtypes.engineenums.etexturemipvaluemode.md)
    - [ETexturePowerOfTwoSetting](api/uassetapi.unrealtypes.engineenums.etexturepoweroftwosetting.md)
    - [ETextureRenderTargetFormat](api/uassetapi.unrealtypes.engineenums.etexturerendertargetformat.md)
    - [ETextureSamplerFilter](api/uassetapi.unrealtypes.engineenums.etexturesamplerfilter.md)
    - [ETextureSizingType](api/uassetapi.unrealtypes.engineenums.etexturesizingtype.md)
    - [ETextureSourceArtType](api/uassetapi.unrealtypes.engineenums.etexturesourcearttype.md)
    - [ETextureSourceFormat](api/uassetapi.unrealtypes.engineenums.etexturesourceformat.md)
    - [ETickingGroup](api/uassetapi.unrealtypes.engineenums.etickinggroup.md)
    - [ETimecodeProviderSynchronizationState](api/uassetapi.unrealtypes.engineenums.etimecodeprovidersynchronizationstate.md)
    - [ETimelineDirection](api/uassetapi.unrealtypes.engineenums.etimelinedirection.md)
    - [ETimelineLengthMode](api/uassetapi.unrealtypes.engineenums.etimelinelengthmode.md)
    - [ETimelineSigType](api/uassetapi.unrealtypes.engineenums.etimelinesigtype.md)
    - [ETimeStretchCurveMapping](api/uassetapi.unrealtypes.engineenums.etimestretchcurvemapping.md)
    - [ETraceTypeQuery](api/uassetapi.unrealtypes.engineenums.etracetypequery.md)
    - [ETrackActiveCondition](api/uassetapi.unrealtypes.engineenums.etrackactivecondition.md)
    - [ETrackToggleAction](api/uassetapi.unrealtypes.engineenums.etracktoggleaction.md)
    - [ETrail2SourceMethod](api/uassetapi.unrealtypes.engineenums.etrail2sourcemethod.md)
    - [ETrailsRenderAxisOption](api/uassetapi.unrealtypes.engineenums.etrailsrenderaxisoption.md)
    - [ETrailWidthMode](api/uassetapi.unrealtypes.engineenums.etrailwidthmode.md)
    - [ETransitionBlendMode](api/uassetapi.unrealtypes.engineenums.etransitionblendmode.md)
    - [ETransitionLogicType](api/uassetapi.unrealtypes.engineenums.etransitionlogictype.md)
    - [ETransitionType](api/uassetapi.unrealtypes.engineenums.etransitiontype.md)
    - [ETranslucencyLightingMode](api/uassetapi.unrealtypes.engineenums.etranslucencylightingmode.md)
    - [ETranslucencyType](api/uassetapi.unrealtypes.engineenums.etranslucencytype.md)
    - [ETranslucentSortPolicy](api/uassetapi.unrealtypes.engineenums.etranslucentsortpolicy.md)
    - [ETravelFailure](api/uassetapi.unrealtypes.engineenums.etravelfailure.md)
    - [ETravelType](api/uassetapi.unrealtypes.engineenums.etraveltype.md)
    - [ETwitterIntegrationDelegate](api/uassetapi.unrealtypes.engineenums.etwitterintegrationdelegate.md)
    - [ETwitterRequestMethod](api/uassetapi.unrealtypes.engineenums.etwitterrequestmethod.md)
    - [ETypeAdvanceAnim](api/uassetapi.unrealtypes.engineenums.etypeadvanceanim.md)
    - [EUIScalingRule](api/uassetapi.unrealtypes.engineenums.euiscalingrule.md)
    - [EUpdateRateShiftBucket](api/uassetapi.unrealtypes.engineenums.eupdaterateshiftbucket.md)
    - [EUserDefinedStructureStatus](api/uassetapi.unrealtypes.engineenums.euserdefinedstructurestatus.md)
    - [EUVOutput](api/uassetapi.unrealtypes.engineenums.euvoutput.md)
    - [EVectorFieldConstructionOp](api/uassetapi.unrealtypes.engineenums.evectorfieldconstructionop.md)
    - [EVectorNoiseFunction](api/uassetapi.unrealtypes.engineenums.evectornoisefunction.md)
    - [EVectorQuantization](api/uassetapi.unrealtypes.engineenums.evectorquantization.md)
    - [EVertexPaintAxis](api/uassetapi.unrealtypes.engineenums.evertexpaintaxis.md)
    - [EVerticalTextAligment](api/uassetapi.unrealtypes.engineenums.everticaltextaligment.md)
    - [EViewModeIndex](api/uassetapi.unrealtypes.engineenums.eviewmodeindex.md)
    - [EViewTargetBlendFunction](api/uassetapi.unrealtypes.engineenums.eviewtargetblendfunction.md)
    - [EVirtualizationMode](api/uassetapi.unrealtypes.engineenums.evirtualizationmode.md)
    - [EVisibilityAggressiveness](api/uassetapi.unrealtypes.engineenums.evisibilityaggressiveness.md)
    - [EVisibilityBasedAnimTickOption](api/uassetapi.unrealtypes.engineenums.evisibilitybasedanimtickoption.md)
    - [EVisibilityTrackAction](api/uassetapi.unrealtypes.engineenums.evisibilitytrackaction.md)
    - [EVisibilityTrackCondition](api/uassetapi.unrealtypes.engineenums.evisibilitytrackcondition.md)
    - [EVoiceSampleRate](api/uassetapi.unrealtypes.engineenums.evoicesamplerate.md)
    - [EVolumeLightingMethod](api/uassetapi.unrealtypes.engineenums.evolumelightingmethod.md)
    - [EWalkableSlopeBehavior](api/uassetapi.unrealtypes.engineenums.ewalkableslopebehavior.md)
    - [EWindowMode](api/uassetapi.unrealtypes.engineenums.ewindowmode.md)
    - [EWindowTitleBarMode](api/uassetapi.unrealtypes.engineenums.ewindowtitlebarmode.md)
    - [EWindSourceType](api/uassetapi.unrealtypes.engineenums.ewindsourcetype.md)
    - [EWorldPositionIncludedOffsets](api/uassetapi.unrealtypes.engineenums.eworldpositionincludedoffsets.md)
    - [FNavigationSystemRunMode](api/uassetapi.unrealtypes.engineenums.fnavigationsystemrunmode.md)
    - [ModulationParamMode](api/uassetapi.unrealtypes.engineenums.modulationparammode.md)
    - [ParticleReplayState](api/uassetapi.unrealtypes.engineenums.particlereplaystate.md)
    - [ParticleSystemLODMethod](api/uassetapi.unrealtypes.engineenums.particlesystemlodmethod.md)
    - [ReverbPreset](api/uassetapi.unrealtypes.engineenums.reverbpreset.md)
    - [SkeletalMeshOptimizationImportance](api/uassetapi.unrealtypes.engineenums.skeletalmeshoptimizationimportance.md)
    - [SkeletalMeshOptimizationType](api/uassetapi.unrealtypes.engineenums.skeletalmeshoptimizationtype.md)
    - [SkeletalMeshTerminationCriterion](api/uassetapi.unrealtypes.engineenums.skeletalmeshterminationcriterion.md)
    - [TextureAddress](api/uassetapi.unrealtypes.engineenums.textureaddress.md)
    - [TextureCompressionSettings](api/uassetapi.unrealtypes.engineenums.texturecompressionsettings.md)
    - [TextureFilter](api/uassetapi.unrealtypes.engineenums.texturefilter.md)
    - [TextureGroup](api/uassetapi.unrealtypes.engineenums.texturegroup.md)
    - [TextureMipGenSettings](api/uassetapi.unrealtypes.engineenums.texturemipgensettings.md)
  - [UAssetAPI.Unversioned]()
    - [ECompressionMethod](api/uassetapi.unversioned.ecompressionmethod.md)
    - [ECustomVersionSerializationFormat](api/uassetapi.unversioned.ecustomversionserializationformat.md)
    - [EPropertyType](api/uassetapi.unversioned.epropertytype.md)
    - [ESaveGameFileVersion](api/uassetapi.unversioned.esavegamefileversion.md)
    - [FFragment](api/uassetapi.unversioned.ffragment.md)
    - [FUnversionedHeader](api/uassetapi.unversioned.funversionedheader.md)
    - [Oodle](api/uassetapi.unversioned.oodle.md)
    - [SaveGame](api/uassetapi.unversioned.savegame.md)
    - [Usmap](api/uassetapi.unversioned.usmap.md)
    - [UsmapArrayData](api/uassetapi.unversioned.usmaparraydata.md)
    - [UsmapEnum](api/uassetapi.unversioned.usmapenum.md)
    - [UsmapEnumData](api/uassetapi.unversioned.usmapenumdata.md)
    - [UsmapExtensionLayoutVersion](api/uassetapi.unversioned.usmapextensionlayoutversion.md)
    - [UsmapMapData](api/uassetapi.unversioned.usmapmapdata.md)
    - [UsmapProperty](api/uassetapi.unversioned.usmapproperty.md)
    - [UsmapPropertyData](api/uassetapi.unversioned.usmappropertydata.md)
    - [UsmapSchema](api/uassetapi.unversioned.usmapschema.md)
    - [UsmapSchemaPropertiesJsonConverter](api/uassetapi.unversioned.usmapschemapropertiesjsonconverter.md)
    - [UsmapStructData](api/uassetapi.unversioned.usmapstructdata.md)
    - [UsmapStructKind](api/uassetapi.unversioned.usmapstructkind.md)
    - [UsmapVersion](api/uassetapi.unversioned.usmapversion.md)

```

`docs/src/SUMMARY_header.md`:

```md
# Summary
[Introduction](README.md)

# User Guide
- [Build Instructions](guide/build.md)
- [Basic Usage](guide/basic.md)
- [More Examples](guide/extras.md)

```

`docs/src/api/uassetapi.ac7decrypt.md`:

```md
# AC7Decrypt

Namespace: UAssetAPI

Decryptor for Ace Combat 7 assets.

```csharp
public class AC7Decrypt
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [AC7Decrypt](./uassetapi.ac7decrypt.md)

## Constructors

### **AC7Decrypt()**

```csharp
public AC7Decrypt()
```

## Methods

### **Decrypt(String, String)**

Decrypts an Ace Combat 7 encrypted asset on disk.

```csharp
public void Decrypt(string input, string output)
```

#### Parameters

`input` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to an encrypted asset on disk.

`output` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path that the decrypted asset should be saved to.

### **Encrypt(String, String)**

Encrypts an Ace Combat 7 encrypted asset on disk.

```csharp
public void Encrypt(string input, string output)
```

#### Parameters

`input` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to a decrypted asset on disk.

`output` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path that the encrypted asset should be saved to.

### **DecryptUAssetBytes(Byte[], AC7XorKey)**

```csharp
public Byte[] DecryptUAssetBytes(Byte[] uasset, AC7XorKey xorkey)
```

#### Parameters

`uasset` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`xorkey` [AC7XorKey](./uassetapi.ac7xorkey.md)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **EncryptUAssetBytes(Byte[], AC7XorKey)**

```csharp
public Byte[] EncryptUAssetBytes(Byte[] uasset, AC7XorKey xorkey)
```

#### Parameters

`uasset` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`xorkey` [AC7XorKey](./uassetapi.ac7xorkey.md)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **DecryptUexpBytes(Byte[], AC7XorKey)**

```csharp
public Byte[] DecryptUexpBytes(Byte[] uexp, AC7XorKey xorkey)
```

#### Parameters

`uexp` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`xorkey` [AC7XorKey](./uassetapi.ac7xorkey.md)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **EncryptUexpBytes(Byte[], AC7XorKey)**

```csharp
public Byte[] EncryptUexpBytes(Byte[] uexp, AC7XorKey xorkey)
```

#### Parameters

`uexp` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`xorkey` [AC7XorKey](./uassetapi.ac7xorkey.md)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

```

`docs/src/api/uassetapi.ac7xorkey.md`:

```md
# AC7XorKey

Namespace: UAssetAPI

XOR key for decrypting a particular Ace Combat 7 asset.

```csharp
public class AC7XorKey
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [AC7XorKey](./uassetapi.ac7xorkey.md)

## Fields

### **NameKey**

```csharp
public int NameKey;
```

### **Offset**

```csharp
public int Offset;
```

### **pk1**

```csharp
public int pk1;
```

### **pk2**

```csharp
public int pk2;
```

## Constructors

### **AC7XorKey(String)**

Generates an encryption key for a particular asset on disk.

```csharp
public AC7XorKey(string fname)
```

#### Parameters

`fname` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The name of the asset being encrypted on disk without the extension.

## Methods

### **SkipCount(Int32)**

```csharp
public void SkipCount(int count)
```

#### Parameters

`count` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.assetbinaryreader.md`:

```md
# AssetBinaryReader

Namespace: UAssetAPI

Reads primitive data types from Unreal Engine assets.

```csharp
public class AssetBinaryReader : UnrealBinaryReader, System.IDisposable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [BinaryReader](https://docs.microsoft.com/en-us/dotnet/api/system.io.binaryreader) → [UnrealBinaryReader](./uassetapi.unrealbinaryreader.md) → [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
Implements [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable)

## Fields

### **Asset**

```csharp
public UAsset Asset;
```

### **LoadUexp**

```csharp
public bool LoadUexp;
```

## Properties

### **BaseStream**

```csharp
public Stream BaseStream { get; }
```

#### Property Value

[Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

## Constructors

### **AssetBinaryReader(Stream, UAsset)**

```csharp
public AssetBinaryReader(Stream stream, UAsset asset)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **AssetBinaryReader(Stream, Boolean, UAsset)**

```csharp
public AssetBinaryReader(Stream stream, bool inLoadUexp, UAsset asset)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`inLoadUexp` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

## Methods

### **ReadPropertyGuid()**

```csharp
public Nullable<Guid> ReadPropertyGuid()
```

#### Returns

[Nullable&lt;Guid&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.nullable-1)<br>

### **ReadFName()**

```csharp
public FName ReadFName()
```

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **ReadArray&lt;T&gt;(Func&lt;T&gt;)**

```csharp
public T[] ReadArray<T>(Func<T> readElement)
```

#### Type Parameters

`T`<br>

#### Parameters

`readElement` Func&lt;T&gt;<br>

#### Returns

T[]<br>

### **ReadObjectThumbnail()**

```csharp
public FObjectThumbnail ReadObjectThumbnail()
```

#### Returns

[FObjectThumbnail](./uassetapi.unrealtypes.fobjectthumbnail.md)<br>

### **ReadLocMetadataObject()**

```csharp
public FLocMetadataObject ReadLocMetadataObject()
```

#### Returns

[FLocMetadataObject](./uassetapi.unrealtypes.flocmetadataobject.md)<br>

### **XFERSTRING()**

```csharp
public string XFERSTRING()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **XFERUNICODESTRING()**

```csharp
public string XFERUNICODESTRING()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **XFERTEXT()**

```csharp
public void XFERTEXT()
```

### **XFERNAME()**

```csharp
public FName XFERNAME()
```

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **XFER_FUNC_NAME()**

```csharp
public FName XFER_FUNC_NAME()
```

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **XFERPTR()**

```csharp
public FPackageIndex XFERPTR()
```

#### Returns

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **XFER_FUNC_POINTER()**

```csharp
public FPackageIndex XFER_FUNC_POINTER()
```

#### Returns

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **XFER_PROP_POINTER()**

```csharp
public KismetPropertyPointer XFER_PROP_POINTER()
```

#### Returns

[KismetPropertyPointer](./uassetapi.kismet.bytecode.kismetpropertypointer.md)<br>

### **XFER_OBJECT_POINTER()**

```csharp
public FPackageIndex XFER_OBJECT_POINTER()
```

#### Returns

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **ReadExpressionArray(EExprToken)**

```csharp
public KismetExpression[] ReadExpressionArray(EExprToken endToken)
```

#### Parameters

`endToken` [EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

#### Returns

[KismetExpression[]](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

```

`docs/src/api/uassetapi.assetbinarywriter.md`:

```md
# AssetBinaryWriter

Namespace: UAssetAPI

Writes primitive data types from Unreal Engine assets.

```csharp
public class AssetBinaryWriter : UnrealBinaryWriter, System.IDisposable, System.IAsyncDisposable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [BinaryWriter](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter) → [UnrealBinaryWriter](./uassetapi.unrealbinarywriter.md) → [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
Implements [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable), [IAsyncDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.iasyncdisposable)

## Fields

### **Asset**

```csharp
public UAsset Asset;
```

## Properties

### **BaseStream**

```csharp
public Stream BaseStream { get; }
```

#### Property Value

[Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

## Constructors

### **AssetBinaryWriter(UAsset)**

```csharp
public AssetBinaryWriter(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **AssetBinaryWriter(Stream, UAsset)**

```csharp
public AssetBinaryWriter(Stream stream, UAsset asset)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **AssetBinaryWriter(Stream, Encoding, UAsset)**

```csharp
public AssetBinaryWriter(Stream stream, Encoding encoding, UAsset asset)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`encoding` [Encoding](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **AssetBinaryWriter(Stream, Encoding, Boolean, UAsset)**

```csharp
public AssetBinaryWriter(Stream stream, Encoding encoding, bool leaveOpen, UAsset asset)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`encoding` [Encoding](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding)<br>

`leaveOpen` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

## Methods

### **Write(FName)**

```csharp
public void Write(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **WritePropertyGuid(Nullable&lt;Guid&gt;)**

```csharp
public void WritePropertyGuid(Nullable<Guid> guid)
```

#### Parameters

`guid` [Nullable&lt;Guid&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.nullable-1)<br>

### **Write(FObjectThumbnail)**

```csharp
public void Write(FObjectThumbnail thumbnail)
```

#### Parameters

`thumbnail` [FObjectThumbnail](./uassetapi.unrealtypes.fobjectthumbnail.md)<br>

### **Write(FLocMetadataObject)**

```csharp
public void Write(FLocMetadataObject metadataObject)
```

#### Parameters

`metadataObject` [FLocMetadataObject](./uassetapi.unrealtypes.flocmetadataobject.md)<br>

### **XFERSTRING(String)**

This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!

```csharp
public int XFERSTRING(string val)
```

#### Parameters

`val` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **XFERUNICODESTRING(String)**

This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!

```csharp
public int XFERUNICODESTRING(string val)
```

#### Parameters

`val` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **XFERNAME(FName)**

This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!

```csharp
public int XFERNAME(FName val)
```

#### Parameters

`val` [FName](./uassetapi.unrealtypes.fname.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **XFER_FUNC_NAME(FName)**

This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!

```csharp
public int XFER_FUNC_NAME(FName val)
```

#### Parameters

`val` [FName](./uassetapi.unrealtypes.fname.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **XFERPTR(FPackageIndex)**

This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!

```csharp
public int XFERPTR(FPackageIndex val)
```

#### Parameters

`val` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **XFER_FUNC_POINTER(FPackageIndex)**

This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!

```csharp
public int XFER_FUNC_POINTER(FPackageIndex val)
```

#### Parameters

`val` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **XFER_PROP_POINTER(KismetPropertyPointer)**

This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!

```csharp
public int XFER_PROP_POINTER(KismetPropertyPointer val)
```

#### Parameters

`val` [KismetPropertyPointer](./uassetapi.kismet.bytecode.kismetpropertypointer.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **XFER_OBJECT_POINTER(FPackageIndex)**

This method is intended only to be used in parsing Kismet bytecode; please do not use it for any other purpose!

```csharp
public int XFER_OBJECT_POINTER(FPackageIndex val)
```

#### Parameters

`val` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.crcgenerator.md`:

```md
# CRCGenerator

Namespace: UAssetAPI

```csharp
public static class CRCGenerator
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [CRCGenerator](./uassetapi.crcgenerator.md)

## Fields

### **CRCTable_DEPRECATED**

```csharp
public static UInt32[] CRCTable_DEPRECATED;
```

### **CRCTablesSB8**

```csharp
public static UInt32[,] CRCTablesSB8;
```

## Methods

### **GenerateHash(FString, Boolean, Boolean)**

```csharp
public static uint GenerateHash(FString text, bool disableCasePreservingHash, bool version420)
```

#### Parameters

`text` [FString](./uassetapi.unrealtypes.fstring.md)<br>

`disableCasePreservingHash` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`version420` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **GenerateHash(String, Boolean, Boolean)**

```csharp
public static uint GenerateHash(string text, bool disableCasePreservingHash, bool version420)
```

#### Parameters

`text` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`disableCasePreservingHash` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`version420` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **GenerateHash(String, Encoding, Boolean, Boolean)**

```csharp
public static uint GenerateHash(string text, Encoding encoding, bool disableCasePreservingHash, bool version420)
```

#### Parameters

`text` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`encoding` [Encoding](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding)<br>

`disableCasePreservingHash` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`version420` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **ToUpper(Char)**

```csharp
public static char ToUpper(char input)
```

#### Parameters

`input` [Char](https://docs.microsoft.com/en-us/dotnet/api/system.char)<br>

#### Returns

[Char](https://docs.microsoft.com/en-us/dotnet/api/system.char)<br>

### **ToUpperVersion420(Char)**

```csharp
public static char ToUpperVersion420(char input)
```

#### Parameters

`input` [Char](https://docs.microsoft.com/en-us/dotnet/api/system.char)<br>

#### Returns

[Char](https://docs.microsoft.com/en-us/dotnet/api/system.char)<br>

### **ToUpper(String)**

```csharp
public static string ToUpper(string input)
```

#### Parameters

`input` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **ToLower(Char)**

```csharp
public static char ToLower(char input)
```

#### Parameters

`input` [Char](https://docs.microsoft.com/en-us/dotnet/api/system.char)<br>

#### Returns

[Char](https://docs.microsoft.com/en-us/dotnet/api/system.char)<br>

### **ToLower(String, Boolean)**

```csharp
public static string ToLower(string input, bool coalesceToSlash)
```

#### Parameters

`input` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`coalesceToSlash` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **ToLower(FString, Boolean)**

```csharp
public static FString ToLower(FString input, bool coalesceToSlash)
```

#### Parameters

`input` [FString](./uassetapi.unrealtypes.fstring.md)<br>

`coalesceToSlash` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Strihash_DEPRECATED(String, Encoding, Boolean)**

```csharp
public static uint Strihash_DEPRECATED(string text, Encoding encoding, bool version420)
```

#### Parameters

`text` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`encoding` [Encoding](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding)<br>

`version420` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **StrCrc32(String, UInt32)**

```csharp
public static uint StrCrc32(string text, uint CRC)
```

#### Parameters

`text` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`CRC` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

#### Returns

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

```

`docs/src/api/uassetapi.customserializationflags.md`:

```md
# CustomSerializationFlags

Namespace: UAssetAPI

```csharp
public enum CustomSerializationFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [CustomSerializationFlags](./uassetapi.customserializationflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| None | 0 | No flags. |
| NoDummies | 1 | Serialize all dummy FNames to the name map. |
| SkipParsingBytecode | 2 | Skip Kismet bytecode serialization. |
| SkipPreloadDependencyLoading | 4 | Skip loading other assets referenced in preload dependencies. You may wish to set this flag when possible in multi-threading applications, since preload dependency loading could lead to file handle race conditions. |
| SkipParsingExports | 8 | Skip parsing exports at read time. Entries in the export map will be read as raw exports. You can manually parse exports with the [UAsset.ParseExport(AssetBinaryReader, Int32, Boolean)](./uassetapi.uasset.md#parseexportassetbinaryreader-int32-boolean) method. |

```

`docs/src/api/uassetapi.customversion.md`:

```md
# CustomVersion

Namespace: UAssetAPI

A custom version. Controls more specific serialization than the main engine object version does.

```csharp
public class CustomVersion : System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [CustomVersion](./uassetapi.customversion.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

```csharp
public FString Name;
```

### **Key**

```csharp
public Guid Key;
```

### **FriendlyName**

```csharp
public string FriendlyName;
```

### **Version**

```csharp
public int Version;
```

### **IsSerialized**

```csharp
public bool IsSerialized;
```

### **GuidToCustomVersionStringMap**

Static map of custom version GUIDs to the object or enum that they represent in the Unreal Engine. This list is not necessarily exhaustive, so feel free to add to it if need be.

```csharp
public static Dictionary<Guid, string> GuidToCustomVersionStringMap;
```

### **UnusedCustomVersionKey**

A GUID that represents an unused custom version.

```csharp
public static Guid UnusedCustomVersionKey;
```

## Constructors

### **CustomVersion(String, Int32)**

Initializes a new instance of the [CustomVersion](./uassetapi.customversion.md) class given an object or enum name and a version number.

```csharp
public CustomVersion(string friendlyName, int version)
```

#### Parameters

`friendlyName` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The friendly name to use when initializing this custom version.

`version` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The version number to use when initializing this custom version.

### **CustomVersion(Guid, Int32)**

Initializes a new instance of the [CustomVersion](./uassetapi.customversion.md) class given a custom version GUID and a version number.

```csharp
public CustomVersion(Guid key, int version)
```

#### Parameters

`key` [Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>
The GUID to use when initializing this custom version.

`version` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The version number to use when initializing this custom version.

### **CustomVersion()**

Initializes a new instance of the [CustomVersion](./uassetapi.customversion.md) class.

```csharp
public CustomVersion()
```

## Methods

### **GetCustomVersionFriendlyNameFromGuid(Guid)**

Returns the name of the object or enum that a custom version GUID represents, as specified in [CustomVersion.GuidToCustomVersionStringMap](./uassetapi.customversion.md#guidtocustomversionstringmap).

```csharp
public static string GetCustomVersionFriendlyNameFromGuid(Guid guid)
```

#### Parameters

`guid` [Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>
A GUID that represents a custom version.

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
A string that represents the friendly name of the corresponding custom version.

### **GetCustomVersionGuidFromFriendlyName(String)**

Returns the GUID of the custom version that the object or enum name provided represents.

```csharp
public static Guid GetCustomVersionGuidFromFriendlyName(string friendlyName)
```

#### Parameters

`friendlyName` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The name of a custom version object or enum.

#### Returns

[Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>
A GUID that represents the custom version

### **SetIsSerialized(Boolean)**

```csharp
public CustomVersion SetIsSerialized(bool val)
```

#### Parameters

`val` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[CustomVersion](./uassetapi.customversion.md)<br>

### **Clone()**

```csharp
public object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.customversions.fanimphysobjectversion.md`:

```md
# FAnimPhysObjectVersion

Namespace: UAssetAPI.CustomVersions

Custom serialization version for changes made in Dev-AnimPhys stream

```csharp
public enum FAnimPhysObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FAnimPhysObjectVersion](./uassetapi.customversions.fanimphysobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| ConvertAnimNodeLookAtAxis | 1 | convert animnode look at to use just default axis instead of enum, which doesn't do much |
| BoxSphylElemsUseRotators | 2 | Change FKSphylElem and FKBoxElem to use Rotators not Quats for easier editing |
| ThumbnailSceneInfoAndAssetImportDataAreTransactional | 3 | Change thumbnail scene info and asset import data to be transactional |
| AddedClothingMaskWorkflow | 4 | Enabled clothing masks rather than painting parameters directly |
| RemoveUIDFromSmartNameSerialize | 5 | Remove UID from smart name serialize, it just breaks determinism |
| CreateTargetReference | 6 | Convert FName Socket to FSocketReference and added TargetReference that support bone and socket |
| TuneSoftLimitStiffnessAndDamping | 7 | Tune soft limit stiffness and damping coefficients |
| FixInvalidClothParticleMasses | 8 | Fix possible inf/nans in clothing particle masses |
| CacheClothMeshInfluences | 9 | Moved influence count to cached data |
| SmartNameRefactorForDeterministicCooking | 10 | Remove GUID from Smart Names entirely + remove automatic name fixup |
| RenameDisableAnimCurvesToAllowAnimCurveEvaluation | 11 | rename the variable and allow individual curves to be set |
| AddLODToCurveMetaData | 12 | link curve to LOD, so curve metadata has to include LODIndex |
| FixupBadBlendProfileReferences | 13 | Fixed blend profile references persisting after paste when they aren't compatible |
| AllowMultipleAudioPluginSettings | 14 | Allowing multiple audio plugin settings |
| ChangeRetargetSourceReferenceToSoftObjectPtr | 15 | Change RetargetSource reference to SoftObjectPtr |
| SaveEditorOnlyFullPoseForPoseAsset | 16 | Save editor only full pose for pose asset |
| GeometryCacheAssetDeprecation | 17 | Asset change and cleanup to facilitate new streaming system |

```

`docs/src/api/uassetapi.customversions.fassetregistryversion.md`:

```md
# FAssetRegistryVersion

Namespace: UAssetAPI.CustomVersions

Version used for serializing asset registry caches, both runtime and editor

```csharp
public enum FAssetRegistryVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FAssetRegistryVersion](./uassetapi.customversions.fassetregistryversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| PreVersioning | 0 | From before file versioning was implemented |
| HardSoftDependencies | 1 | The first version of the runtime asset registry to include file versioning. |
| AddAssetRegistryState | 2 | Added FAssetRegistryState and support for piecemeal serialization |
| ChangedAssetData | 3 | AssetData serialization format changed, versions before this are not readable |
| RemovedMD5Hash | 4 | Removed MD5 hash from package data |
| AddedHardManage | 5 | Added hard/soft manage references |
| AddedCookedMD5Hash | 6 | Added MD5 hash of cooked package to package data |
| AddedDependencyFlags | 7 | Added UE::AssetRegistry::EDependencyProperty to each dependency |
| FixedTags | 8 | Major tag format change that replaces USE_COMPACT_ASSET_REGISTRY: |
| WorkspaceDomain | 9 | Added Version information to AssetPackageData |
| PackageImportedClasses | 10 | Added ImportedClasses to AssetPackageData |
| PackageFileSummaryVersionChange | 11 | A new version number of UE5 was added to FPackageFileSummary |
| ObjectResourceOptionalVersionChange | 12 | Change to linker export/import resource serializationn |
| AddedChunkHashes | 13 | Added FIoHash for each FIoChunkId in the package to the AssetPackageData. |
| ClassPaths | 14 | Classes are serialized as path names rather than short object names, e.g. /Script/Engine.StaticMesh |
| RemoveAssetPathFNames | 15 | Asset bundles are serialized as FTopLevelAssetPath instead of FSoftObjectPath, deprecated FAssetData::ObjectPath |
| AddedHeader | 16 | Added header with bFilterEditorOnlyData flag |
| AssetPackageDataHasExtension | 17 | Added Extension to AssetPackageData. |

```

`docs/src/api/uassetapi.customversions.fcoreobjectversion.md`:

```md
# FCoreObjectVersion

Namespace: UAssetAPI.CustomVersions

Custom serialization version for changes made in Dev-Core stream.

```csharp
public enum FCoreObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FCoreObjectVersion](./uassetapi.customversions.fcoreobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |

```

`docs/src/api/uassetapi.customversions.feditorobjectversion.md`:

```md
# FEditorObjectVersion

Namespace: UAssetAPI.CustomVersions

Custom serialization version for changes made in Dev-Editor stream.

```csharp
public enum FEditorObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FEditorObjectVersion](./uassetapi.customversions.feditorobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| GatheredTextProcessVersionFlagging | 1 | Localizable text gathered and stored in packages is now flagged with a localizable text gathering process version |
| GatheredTextPackageCacheFixesV1 | 2 | Fixed several issues with the gathered text cache stored in package headers |
| RootMetaDataSupport | 3 | Added support for "root" meta-data (meta-data not associated with a particular object in a package) |
| GatheredTextPackageCacheFixesV2 | 4 | Fixed issues with how Blueprint bytecode was cached |
| TextFormatArgumentDataIsVariant | 5 | Updated FFormatArgumentData to allow variant data to be marshaled from a BP into C++ |
| SplineComponentCurvesInStruct | 6 | Changes to SplineComponent |
| ComboBoxControllerSupportUpdate | 7 | Updated ComboBox to support toggling the menu open, better controller support |
| RefactorMeshEditorMaterials | 8 | Refactor mesh editor materials |
| AddedFontFaceAssets | 9 | Added UFontFace assets |
| UPropertryForMeshSection | 10 | Add UPROPERTY for TMap of Mesh section, so the serialize will be done normally (and export to text will work correctly) |
| WidgetGraphSchema | 11 | Update the schema of all widget blueprints to use the WidgetGraphSchema |
| AddedBackgroundBlurContentSlot | 12 | Added a specialized content slot to the background blur widget |
| StableUserDefinedEnumDisplayNames | 13 | Updated UserDefinedEnums to have stable keyed display names |
| AddedInlineFontFaceAssets | 14 | Added "Inline" option to UFontFace assets |
| UPropertryForMeshSectionSerialize | 15 | Fix a serialization issue with static mesh FMeshSectionInfoMap FProperty |
| FastWidgetTemplates | 16 | Adding a version bump for the new fast widget construction in case of problems. |
| MaterialThumbnailRenderingChanges | 17 | Update material thumbnails to be more intelligent on default primitive shape for certain material types |
| NewSlateClippingSystem | 18 | Introducing a new clipping system for Slate/UMG |
| MovieSceneMetaDataSerialization | 19 | MovieScene Meta Data added as native Serialization |
| GatheredTextEditorOnlyPackageLocId | 20 | Text gathered from properties now adds two variants: a version without the package localization ID (for use at runtime), and a version with it (which is editor-only) |
| AddedAlwaysSignNumberFormattingOption | 21 | Added AlwaysSign to FNumberFormattingOptions |
| AddedMaterialSharedInputs | 22 | Added additional objects that must be serialized as part of this new material feature |
| AddedMorphTargetSectionIndices | 23 | Added morph target section indices |
| SerializeInstancedStaticMeshRenderData | 24 | Serialize the instanced static mesh render data, to avoid building it at runtime |
| MeshDescriptionNewSerialization_MovedToRelease | 25 | Change to MeshDescription serialization (moved to release) |
| MeshDescriptionNewAttributeFormat | 26 | New format for mesh description attributes |
| ChangeSceneCaptureRootComponent | 27 | Switch root component of SceneCapture actors from MeshComponent to SceneComponent |
| StaticMeshDeprecatedRawMesh | 28 | StaticMesh serializes MeshDescription instead of RawMesh |
| MeshDescriptionBulkDataGuid | 29 | MeshDescriptionBulkData contains a Guid used as a DDC key |
| MeshDescriptionRemovedHoles | 30 | Change to MeshDescription serialization (removed FMeshPolygon::HoleContours) |
| ChangedWidgetComponentWindowVisibilityDefault | 31 | Change to the WidgetCompoent WindowVisibilty default value |
| CultureInvariantTextSerializationKeyStability | 32 | Avoid keying culture invariant display strings during serialization to avoid non-deterministic cooking issues |
| ScrollBarThicknessChange | 33 | Change to UScrollBar and UScrollBox thickness property (removed implicit padding of 2, so thickness value must be incremented by 4). |
| RemoveLandscapeHoleMaterial | 34 | Deprecated LandscapeHoleMaterial |
| MeshDescriptionTriangles | 35 | MeshDescription defined by triangles instead of arbitrary polygons |
| ComputeWeightedNormals | 36 | Add weighted area and angle when computing the normals |
| SkeletalMeshBuildRefactor | 37 | SkeletalMesh now can be rebuild in editor, no more need to re-import |
| SkeletalMeshMoveEditorSourceDataToPrivateAsset | 38 | Move all SkeletalMesh source data into a private uasset in the same package has the skeletalmesh |
| NumberParsingOptionsNumberLimitsAndClamping | 39 | Parse text only if the number is inside the limits of its type |
| SkeletalMeshSourceDataSupport16bitOfMaterialNumber | 40 | Make sure we can have more then 255 material in the skeletal mesh source data |

```

`docs/src/api/uassetapi.customversions.ffortnitemainbranchobjectversion.md`:

```md
# FFortniteMainBranchObjectVersion

Namespace: UAssetAPI.CustomVersions

Custom serialization version for changes made in the //Fortnite/Main stream.

```csharp
public enum FFortniteMainBranchObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FFortniteMainBranchObjectVersion](./uassetapi.customversions.ffortnitemainbranchobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| WorldCompositionTile3DOffset | 1 | World composition tile offset changed from 2d to 3d |
| MaterialInstanceSerializeOptimization_ShaderFName | 2 | Minor material serialization optimization |
| CullDistanceRefactor_RemovedDefaultDistance | 3 | Refactored cull distances to account for HLOD, explicit override and globals in priority |
| SaveGeneratedMorphTargetByEngine | 6 | Support to remove morphtarget generated by bRemapMorphtarget |
| ConvertReductionSettingOptions | 7 | Convert reduction setting options |
| StaticParameterTerrainLayerWeightBlendType | 8 | Serialize the type of blending used for landscape layer weight static params |
| FixUpNoneNameAnimationCurves | 9 | Fix up None Named animation curve names, |
| EnsureActiveBoneIndicesToContainParents | 10 | Ensure ActiveBoneIndices to have parents even not skinned for old assets |
| SerializeInstancedStaticMeshRenderData | 11 | Serialize the instanced static mesh render data, to avoid building it at runtime |
| CachedMaterialQualityNodeUsage | 12 | Cache material quality node usage |
| FontOutlineDropShadowFixup | 13 | Font outlines no longer apply to drop shadows for new objects but we maintain the opposite way for backwards compat |
| NewSkeletalMeshImporterWorkflow | 14 | New skeletal mesh import workflow (Geometry only or animation only re-import ) |
| NewLandscapeMaterialPerLOD | 15 | Migrate data from previous data structure to new one to support materials per LOD on the Landscape |
| RemoveUnnecessaryTracksFromPose | 16 | New Pose Asset data type |
| FoliageLazyObjPtrToSoftObjPtr | 17 | Migrate Foliage TLazyObjectPtr to TSoftObjectPtr |
| REVERTED_StoreTimelineNamesInTemplate | 18 | TimelineTemplates store their derived names instead of dynamically generating. This code tied to this version was reverted and redone at a later date |
| AddBakePoseOverrideForSkeletalMeshReductionSetting | 19 | Added BakePoseOverride for LOD setting |
| StoreTimelineNamesInTemplate | 20 | TimelineTemplates store their derived names instead of dynamically generating |
| WidgetStopDuplicatingAnimations | 21 | New Pose Asset data type |
| AllowSkeletalMeshToReduceTheBaseLOD | 22 | Allow reducing of the base LOD, we need to store some imported model data so we can reduce again from the same data. |
| ShrinkCurveTableSize | 23 | Curve Table size reduction |
| WidgetAnimationDefaultToSelfFail | 24 | Widgets upgraded with WidgetStopDuplicatingAnimations, may not correctly default-to-self for the widget parameter. |
| FortHUDElementNowRequiresTag | 25 | HUDWidgets now require an element tag |
| FortMappedCookedAnimation | 26 | Animation saved as bulk data when cooked |
| SupportVirtualBoneInRetargeting | 27 | Support Virtual Bone in Retarget Manager |
| FixUpWaterMetadata | 28 | Fixup bad defaults in water metadata |
| MoveWaterMetadataToActor | 29 | Move the location of water metadata |
| ReplaceLakeCollision | 30 | Replaced lake collision component |
| AnimLayerGuidConformation | 31 | Anim layer node names are now conformed by Guid |
| MakeOceanCollisionTransient | 32 | Ocean collision component has become dynamic |
| FFieldPathOwnerSerialization | 33 | FFieldPath will serialize the owner struct reference and only a short path to its property |
| FixUpUnderwaterPostProcessMaterial | 34 | Simplified WaterBody post process material handling |
| SupportMultipleWaterBodiesPerExclusionVolume | 35 | A single water exclusion volume can now exclude N water bodies |
| RigVMByteCodeDeterminism | 36 | Serialize rigvm operators one by one instead of the full byte code array to ensure determinism |
| LandscapePhysicalMaterialRenderData | 37 | Serialize the physical materials generated by the render material |
| FixupRuntimeVirtualTextureVolume | 38 | RuntimeVirtualTextureVolume fix transforms |
| FixUpRiverCollisionComponents | 39 | Retrieve water body collision components that were lost in cooked builds |
| FixDuplicateRiverSplineMeshCollisionComponents | 40 | Fix duplicate spline mesh components on rivers |
| ContainsStableActorGUIDs | 41 | Indicates level has stable actor guids |
| LevelsetSerializationSupportForBodySetup | 42 | Levelset Serialization support for BodySetup. |
| ChaosSolverPropertiesMoved | 43 | Moving Chaos solver properties to allow them to exist in the project physics settings |
| GameFeatureData_MovedComponentListAndCheats | 44 | Moving some UFortGameFeatureData properties and behaviors into the UGameFeatureAction pattern |
| ChaosClothAddfictitiousforces | 45 | Add centrifugal forces for cloth |
| ChaosConvexVariableStructureDataAndVerticesArray | 46 | Chaos Convex StructureData supports different index sizes based on num verts/planes. Chaos FConvex uses array of FVec3s for vertices instead of particles (Merged from //UE4/Main) |
| RemoveLandscapeWaterInfo | 47 | Remove the WaterVelocityHeightTexture dependency on MPC_Landscape and LandscapeWaterIndo |
| ChaosClothAddWeightedValue | 48 | Added the weighted value property type to store the cloths weight maps' low/high ranges |
| ChaosClothAddTetherStiffnessWeightMap | 49 | Added the Long Range Attachment stiffness weight map |
| ChaosClothFixLODTransitionMaps | 50 | Fix corrupted LOD transition maps |
| ChaosClothAddTetherScaleAndDragLiftWeightMaps | 51 | Enable a few more weight maps to better art direct the cloth simulation |
| ChaosClothAddMaterialWeightMaps | 52 | Enable material (edge, bending, and area stiffness) weight maps |
| SerializeFloatChannelShowCurve | 53 | Added bShowCurve for movie scene float channel serialization |
| LandscapeGrassSingleArray | 54 | Minimize slack waste by using a single array for grass data |
| AddedSubSequenceEntryWarpCounter | 55 | Add loop counters to sequencer's compiled sub-sequence data |
| WaterBodyComponentRefactor | 56 | Water plugin is now component-based rather than actor based |
| BPGCCookedEditorTags | 57 | Cooked BPGC storing editor-only asset tags |
| TTerrainLayerWeightsAreNotParameters | 58 | Terrain layer weights are no longer considered material parameters |
| GravityOverrideDefinedInWorldSpace | 59 | Anim Dynamics Node Gravity Override vector is now defined in world space, not simulation space. Legacy behavior can be maintained with a flag, which is set false by default for new nodes, true for nodes predating this change. |
| AnimDynamicsEditableChainParameters | 60 | Anim Dynamics Node Physics parameters for each body in a chain are now stored in an array and can be edited. |
| WaterZonesRefactor | 61 | Decoupled the generation of the water texture from the Water Brush and the landscape |
| ChaosClothFasterDamping | 62 | Add faster damping calculations to the cloth simulation and rename previous Damping parameter to LocalDamping. |
| MigratedFunctionHandlersToDefaults | 63 | Migrated function handlers to the CDO/archetype data |
| ChaosInertiaConvertedToVec3 | 64 | Storing inertia tensor as vec3 instead of matrix. |
| MigratedEventDefinitionToDefaults | 65 | Migrated event definitions to the CDO/archetype data |
| LevelInstanceActorGuidSerialize | 66 | Serialize LevelInstanceActorGuid on new ILevelInstanceInterface implementation |
| SingleFrameAndKeyAnimModel | 67 | Single-frame/key AnimDataModel patch-up |
| RemappedEvaluateWorldPositionOffsetInRayTracing | 68 | Remapped bEvaluateWorldPositionOffset to bEvaluateWorldPositionOffsetInRayTracing |
| WaterBodyComponentCollisionSettingsRefactor | 69 | Water body collision settings are now those of the base UPrimitiveComponent, rather than duplicated in UWaterBodyComponent |
| WidgetInheritedNamedSlots | 70 | Introducing widget inherited named slots. This wouldn't have required a version bump, except in the previous version, users could make NamedSlots and then Seed them with any random widgets, as a sorta 'default' setup. In order to preserve that, we're bumping the version so that we can set a new field on UNamedSlot to control if a widget exposes its named slot to everyone (even if it has content), which by default they wont any longer. |
| WaterHLODSupportAdded | 71 | Added water HLOD material |
| PoseWatchMigrateSkeletonDrawParametersToPoseElement | 72 | Moved parameters affecting Skeleton pose rendering from the PoseWatch class to the PoseWatchPoseElement class. |
| WaterExclusionVolumeExcludeAllDefault | 73 | Reset default value for Water exclusion volumes to make them more intuitive and support the "it just works" philosophy. |
| WaterNontessellatedLODSupportAdded | 74 | Added water non-tessellated LOD |
| HierarchicalSimplificationMethodEnumAdded | 75 | Added FHierarchicalSimplification::SimplificationMethod |
| WorldPartitionStreamingCellsNamingShortened | 76 | Changed how world partition streaming cells are named |
| WorldPartitionActorDescSerializeContentBundleGuid | 77 | Serialize ContentBundleGuid in WorldPartitionActorDesc |
| WorldPartitionActorDescSerializeActorIsRuntimeOnly | 78 | Serialize IsActorRuntimeOnly in WorldPartitionActorDesc |
| NaniteMaterialOverride | 79 | Add Nanite Material Override option to materials and material instances. |
| WorldPartitionHLODActorDescSerializeStats | 80 | Serialize HLOD stats in HLODActorDesc |
| WorldPartitionStreamingSourceComponentTargetDeprecation | 81 | WorldPartitionStreamingSourceComponent property deprecation |
| FixedLocalizationGatherForExternalActorPackage | 82 | Fixed localization gathering for external actor packages |
| WorldPartitionHLODActorUseSourceCellGuid | 83 | Change HLODActors to RuntimeCells mapping to use a GUID instead of the cell name |
| ChaosGeometryCollectionInternalFacesAttribute | 84 | Add an attribute to geometry collection to track internal faces, rather than relying on material ID numbering |
| DynamicCastNodesUsePureStateEnum | 85 | Dynamic cast nodes use an enumerated pure node state to include a value for the default setting |
| WorldPartitionActorFilter | 86 | Add FWorldPartitionActorFilter to FLevelInstanceActorDesc/FDataLayerInstanceDesc |
| AudioAttenuationNonSpatializedRadiusBlend | 87 | Change the non-spatialized radius to blend to a pure 2D spatialized sound vs omnidirectional |
| WorldPartitionActorClassDescSerialize | 88 | Serialize actor class descriptors |
| WorldPartitionFActorContainerIDu64ToGuid | 89 | FActorContainerID is now an FGuid instead of a uint64 |
| WorldPartitionPrivateDataLayers | 90 | FDataLayerInstanceDesc support for private data layers |
| ChaosImplicitObjectUnionBVHRefactor | 91 | Reduce size and improve behaviour of Chaos::FImplicitObjectUnion |
| LevelInstanceActorDescDeltaSerializeFilter | 92 | FLevelInstanceActorDesc DeltaSerialize Filter |
| FixNaniteLandscapeMeshDDCKey | 93 | Fix the Nanite landscape mesh non-deterministic DDC keys |
| ChaosGeometryCollectionConnectionEdgeGroup | 94 | Change how connection graphs are stored on Geometry Collections to an edge-array representation |
| WaterBodyStaticMeshComponents | 95 | Moved the water info mesh data and static water body meshes into new static mesh components for water bodies. |
| WorldPartitionActorDescSerializeInvalidBounds | 96 | Serialize invalid bounds in world partition actor descriptors |
| NavigationLinkID32To64 | 97 | Upgrade Navigation Links to use 64 bits for the ID |
| WorldPartitionActorDescSerializeEditorOnlyReferences | 98 | Serialize editor only references in world partition actor descriptors |
| WorldPartitionActorDescSerializeSoftObjectPathSupport | 99 | Add support for soft object paths in actor descriptors |
| WorldPartitionClasDescGuidTransient | 100 | Don't serialize class descriptor GUIDs |
| WorldPartitionActorDescIsMainWorldOnly | 101 | Serialize ActorDesc bIsMainWorldOnly |
| WorldPartitionActorFilterStringAssetPath | 102 | FWorldPartitionActorFilter go back to FString serialize of AssetPaths to avoid FArchiveReplaceOrClearExternalReferences clearing CDO references on BP Compile |
| PackedLevelActorDesc | 103 | Add FPackedLevelActorDesc for APackedLevelActor and support for APackedLevelActor Filters |
| WorldPartitionRuntimeSpatialHashCVarOverrides | 104 | Add customizable values for several UWorldPartitionRuntimeSpatialHash cvars |
| WorldPartitionHLODSourceActorsRefactor | 105 | WorldPartition HLOD now contains a source actors object |
| GeometryCollectionConvertVertexColorToSRGB | 107 | Geometry Collection now by-default converts vertex colors to sRGB when creating render data |
| WaterOwningZonePointerFixup | 108 | Water bodies before this version need to update their water zone on load since they won't have been serialized yet. |
| WaterBodyStaticMeshDuplicateTransient | 109 | Set flags on water static meshes to duplicate transient to avoid underlying static mesh duplication issue |
| MVVMConvertPropertyPathToSkeletalClass | 110 | Update paths to use the SkeletalClass |
| WaterBodyStaticMeshFixup | 111 | Fixup all flags/outering on static meshes on water bodies by rebuilding them completely |
| AnimGraphNodeBindingExtensions | 112 | Binding extensions for anim graph nodes |
| RigVMSaveDebugMapInGraphFunctionData | 113 | Function data stores a map from work to debug operands |
| FixMissingAnimGraphNodeBindingExtensions | 114 | Fix missing binding extensions for some anim graph nodes |
| ISMComponentEditableWhenInheritedSkipSerialization | 115 | EditableWhenInherited: Skip custom serialization on non Archetypes |
| LandscapeSupportPerComponentGrassTypes | 116 | GrassTypes are now per-component, rather than per-landscape proxy : |
| WorldPartitionDataLayersLogicOperatorAdded | 117 | World partition actor data layers activation logic operator support defaults for old maps |
| MovieSceneSortedBindings | 118 | Started sorting Possessables, Spawnables, and MovieSceneBindings for better search performance. |
| RemoveAnimCurveCompressionCodecInstanceGuid | 119 | Remove the UAnimCurveCompressionCodec::InstanceGuid which causes cook determinism issues |
| WorldPartitionHLODActorDescSerializeSourceHLODLayer | 120 | Serialize the source HLOD Layer for HLOD actor descriptors. |
| WorldPartitionHLODActorDescSerializeEditorBounds | 121 | Serialize custom editor bounds for HLOD actor descriptors. |
| LocalExposureDefaultChangeFrom1_Reverted | 122 | Changed default Local Exposure Contrast from 1.0 to 0.8 (reverted) |
| AddDataLayerInstanceExternalPackage | 123 | Added support of external packaging of Data Layer Instances |
| MVVMPropertyPathSelf | 124 | Update paths to keep a flag if they are the widget BP |
| AddDataflowObjectSerialization | 125 | Enabled ObjectPtr property serialization for Dataflow nodes |
| AnimNotifyAddRateScale | 126 | Add anim notify rate scaling, defaults to on for new content, off for old content |
| FixedTangentTransformForNonuniformBuildScale | 127 | Fix tangents for non-uniform build scales, and add a flag to optionally match the previous (incorrect) tangents |
| AnimNodeRootDefaultGroupChange | 128 | AnimNode Layers will now start in a Shared Group, instead of being each one on a different group at runtime |
| AnimNextMoveGraphsToEntries | 129 | Move AnimNext graphs to sub-entries of assets |
| AnimationSequenceCompressedDataRemoveDebugData | 130 | Removed debug information containing compressed data author, time etc. from animation DDC data as it introduces indeterminism |
| OrthographicCameraDefaultSettings | 131 | Changes to Orthographic Camera default settings |
| LandscapeAddedHLODSettings | 132 | Added settings to Landscape HLODs |
| MeshDescriptionForSkeletalMesh | 133 | Skeletal Mesh uses Mesh Description to store mesh bulk data. |
| SkeletalHalfEdgeData | 134 | Skeletal Mesh optionally cooks half edge data per lod |
| AnimNextCombineGraphContexts | 135 | Combine graph contexts for AnimNext graphs |
| AnimNextCombineParameterBlocksAndGraphs | 136 | Combine parameter blocks and graphs |
| AnimNextMoveWorkspaces | 137 | Move workspaces to a seperate plugin |
| LevelInstancePropertyOverrides | 138 | Level Instance Property overrides |
| VolumetricLightMapGridDescSupport | 139 | Added FVolumetricLightMapGridDesc in MapBuildData |
| IntroduceLandscapeEditLayerClass | 140 | Introduce new structure for customizing the landscape edit layer behavior |
| AnimNextWorkspaceEntryConversion | 141 | Change workspaces to store asset references as external objects |
| DataflowAnyTypeSupport | 142 | Add support for anytype in dataflow |
| PhysicsAssetUseManifoldFlags | 143 | Adding a new flag in RBAN Solver Setting to be able to use manifolds |
| SimAndQueryDataSupportInChaosVisualDebugger | 144 | Added support for to record sim and query data of Shape Instance data in CVD |
| ChaosClothAssetUSDImportNodeAddAssetDependencies | 145 | Add the imported asset dependencies to the Cloth Asset USD Import node |
| LumenRayLightingModeOverrideEnum | 146 | Changed HitLighting to HitLightingForReflections, and HitLighting now means hit lighting for entire Lumen |
| PCGPartitionActorDesc | 147 | PCGPartitionActorDesc |
| LandscapeTargetLayersInLandscapeActor | 148 | Target layers are now defined in the Landscape actor and not continuously synced from the assigned material. |
| DataflowTemplatedTypeFix | 149 | Fix to get full name of templated type ( Tarray &gt; TArray{Float} for example ) |
| LevelInstanceStaticLightingSupport | 150 | Changes for LevelInstance support in StaticLighting |
| PCGGridDescriptor | 151 | PCGGridDescriptor |
| AnimNextGraphAccessSpecifiers | 152 | AnimNext graphs now have public/private state |
| MaterialPixelDepthOffsetMode | 153 | Added a more stable pixel depth offset mode. |
| DataflowHideablePins | 154 | Added hideable pins to dataflow |
| ClothAssetSkeletalMeshMultiSectionImport | 155 | Added multiple section import to the cloth asset skeletal mesh import node |
| WorldPartitionActorDescSerializeEditorBounds | 156 | Serialize EditorBounds in WorldPartitionActorDesc |
| FixupLandscapeTargetLayersInLandscapeActor | 157 | Fixup for the data that has been damaged by LandscapeTargetLayersInLandscapeActor (loss of landscape layer info object assignments) |
| ChaosClothAllowZeroBucklingStiffness | 159 | Fix chaos cloth buckling stiffness parameter bug |
| LevelSequenceUpgradeDynamicBindings_NoOp | 160 | LevelSequenceUpgradeDynamicBindings was removed but was intended for this position. Putting this here to make sure versioning of subsequent assets remains the same |
| GameFeatureDataActionAddToFrontendDefaultToUnload | 161 | AddToFrontend GFA now defaults to unload plugin on exit frontend |
| LevelSequenceUpgradeDynamicBindings | 162 | Upgraded movie scene 'dynamic bindings' to use the new Custom Bindings system |
| ChaosStoreKinematicTargetRotationAsSinglePrecision | 163 | Changed the precision for the stored rotation on kinematic targets to match the precision used in particles |
| PCGApplyOnActorNodeMoveTargetActorEdgeToInput | 164 | PCG changes around the ApplyOnActor node, where we collapsed the TargetActor to the input pin. |
| TimelinePlayingStateTrackerDeprecation | 165 | Deprecation of the bPlaying flag on FTimeline struct types in favor of a better PlayingStateTracker type to improve replication reliability |
| MeshPaintTextureUsesEditorOnly | 166 | Enable SkipOnlyEditorOnly style cooking of UStaticMeshComponent::MeshPaintTexture |
| LandscapeBodyInstanceAsSharedProperty | 167 | Fixup and synchronize some landscape properties that have moved to the property sharing/overriding system : |
| AnimNextModuleRefactor | 168 | Multiple changes to AnimNext modules, variables etc. |
| SubsurfaceProfileGuid | 169 | Subsurface profile now has a guid to be able to select one of many in a Substrate material. |
| SolverIterationsDataSupportInChaosVisualDebugger | 170 | Added support for to record the new solver iteration settings in CVD |
| MaterialInputUsesLinearColor | 171 | Updated FColorMaterialInput to use FLinearColor instead of FColor |
| FunctionalTestCanRunInEditorWorld | 172 | Updated editor only AFunctionalTest running logic to run tests editor world if the actors don't support PIE |
| VisualLoggerSupportDisplayName | 173 | Added support for display name in the Visual Logger |
| GyroscopicTorquesSupportInChaosVisualDebugger | 174 | Added support for the GyroscopicTorque flag in CVD |
| AddManagedArrayCollectionPropertySerialization | 175 | Added managed array property serialization |
| LandscapeTexturePatchUsesTextureAssetResolution | 176 | Landscape texture patches in Texture Asset source mode now use proper resolution when calculating transform |
| WorldPartitionActorDescSerializeRelativeTransform | 177 | Added support for relative transform in WorldPartitionActorDesc |
| SceneGraphEntitiesPrivateByDefault | 178 | Make sure scene graph entities are not public by default |
| DebugColorForPhysicalMaterials | 179 | Added debug color for physical materials |
| AddedPreprocessedFontGeometry | 180 | Added PreprocessedFontGeometry to FFontFaceData |
| DynamicMeshSerializeSculptLayers | 181 | Added Dynamic Mesh Sculpt Layer serialization |
| SpatialHashRuntimeGridInfoSpriteFixup | 182 | Fix reachable garbage object warnings from some legacy ASpatialHashRuntimeGridInfo actors |
| AnimSequenceRawDataOnlyFlagRemoval | 183 | Removed UAnimSequence::bUseRawDataOnly flag alongside compression refactor |
| ResetLevelInstanceHLODRelevancy | 184 | HLOD relevancy of Level Instances was previously ignored, now taken into account. Reset to the default behavior. |
| SceneCaptureDefaultSettings | 185 | Updated default scene capture post-processing settings to reflect the underlying implementation overrides |
| AddClothAssetBase | 186 | Add Cloth Asset Base class serialization |
| PCGInlineConstantDefaultValues | 187 | Add inline constant default values to the PCG graph nodes. |
| AddMaterialSubstrateSubsurfaceType | 188 | Add MaterialSubstrateSubsurfaceType type to UMaterialExpressionSubstrateSlabBSDF for replacing bUseSSSDifffusion |
| AddedRuntimeVirtualTextureUseStreamingMipsInEditorMode | 189 | Added option to visualize runtime virtual textures' streamed mips only in PIE |
| MediaPlateHoldoutComponentRemoval | 190 | Media plate holdout composite components have been replaced by a checkbox |
| PCGLandscapeCacheDefaultSerializationChanged | 191 | Changed PCG landscape cache default from "serialize at cook" to "never serialize" |
| SoftObjectPathUtf8SubPaths | 192 | FSoftObjectPath::SubPathString changed to FUtf8String |
| SoftObjectPathTrailingNULsMaintained | 193 | FSoftObjectPath::SubPathString could be saved with trailing NULs and need truncating |
| WaterBodyPhysicalMaterialPropertyRemoval | 194 | Water body components no longer need to maintain their own PhysicalMaterial property since they are primitive components. After this version, leverage that one instead. |
| PCGAttributeSetToPointAlwaysConverts | 195 | PCG fixed attribute set -&gt; point conversion passing through empty point data as-is and violating output pin type. |
| ConvertGlintDensity | 197 | Convert Sustrate glint density properly |
| ClothAssetSkinweightsValidation | 198 | Introduced skinweight validation to avoid render crashes and disappearing simulation meshes |
| VerseRightToLeftHandedness | 199 | Switching verse from right handed to left handed |
| AdditionalGameThreadDataSupportInChaosVisualDebugger | 200 | Added additional data required to record and represent particle data from the game thread (Kinematic targets, and SQ rejection reasons) |
| UpgradeWidgetBlueprintLegacySequencePlayer | 201 | Upgrade UMG widget blueprints using legacy animation API |
| PCGSplineDirectionClockwiseFix | 202 | Changed clockwise detection algorithm for PCGSplineDirection node with the correct one, but add a version to not break previous nodes. |
| RectLightFixedEVUnitConversion | 203 | Rect Lights set in EV units had the wrong intensity (older files need a flag set to keep the old look) |
| ParticleInflatedBoundsInChaosVisualDebugger | 204 | Add particle bounds to data exported to CVD |
| MigrateLandscapeEditLayerProperties | 205 | Migrate properties from FLandscapeLayer to ULandscapeEditLayer |
| ThreadContextDataInChaosVisualDebuggerDebugDrawData | 206 | Added more context data to CVD's traced shapes so we can play it back at the solver stage level (not just game thread frames) |
| PCGChangedSurfaceSamplerDefaultGridCreationMode | 207 | Changed default grid mode in surface sampler to a version that's more intuitive and less error-prone |
| MediaPlateOverlayTechniqueRemoval | 208 | Media plate overlay composite technique replacement with holdout composite |
| PerParticleFlagToAllowPartialIslandSleepInConnectedIsland | 209 | Added particle flag to allow/disallow partial island sleeping in the island the particle is in |
| MaterialFunctionBlendTopBottomInputEnum | 210 | Material Function Blend Deserialize Top/Bottom input nodes with clearer enum marker. |
| MorphTargetCookedCPUDataCompressed | 211 | Cooked CPU-side morph target points are now stored internally in the same compressed format as the GPU morph data. |
| AnimNextVariableReferences | 212 | AnimNext variables converted to references |
| LensComponentDefaultToDistortionSVE | 213 | The default distortion rendering mode used by the Lens Component is now the Lens Distortion Scene View Extension |
| ChangeDefaultAlphaBlendType | 214 | Animation default blend option changed from Linear to HermiteCubic (aka SmoothStep, ease in / ease out) |
| PerParticleIterationCountMovedToDynamicMisc | 215 | Moved Position/Velocity/Projection Iteration Counts from FChaosVDFRigidParticleControlFlags to FChaosVDParticleDynamicMisc |
| AddedMissingSerializationForPropertiesInDynamicMisc | 216 | Added missing custom serialization for some properties in the ParticleDynamicMisc structure used by the Chaos Visual Debugger |
| PCGDeprecateWorldPartitionGenerationSources | 217 | Change default value for deprecated bEnableWorldPartitionGenerationSources |
| CompositeActorSceneCaptureRefactor | 218 | Refactored the composite (plugin) actor scene capture management. |
| HLODLayerEditorOnlyObject | 219 | Moved HLOD Layer properties to an editor only optional object |
| DeduplicatedDebugNameSerializationInCVD | 220 | Deduplicated particle debug names serialization in the Chaos Visual Debugger |
| SpecializeBloomIntensity | 221 | Add BloomGaussianIntensity and BloomConvolutionIntensity |
| WorldPartitionActorComponentDesc | 222 | Add support for world partition actor component descriptors |
| MigrateLandscapeNonEditLayerToEditLayer | 223 | Migrate Non-Edit layer landscapes to use the edit layer (ULandscapeEditLayer) system |
| DynamicMeshAttributesMorphTargets | 224 | FDynamicMeshAttributeSet has Morph Targets. |
| LandscapeAdvancedWeightBlending | 225 | Introduce landscape advanced weight blending |

```

`docs/src/api/uassetapi.customversions.ffortnitereleasebranchcustomobjectversion.md`:

```md
# FFortniteReleaseBranchCustomObjectVersion

Namespace: UAssetAPI.CustomVersions

```csharp
public enum FFortniteReleaseBranchCustomObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FFortniteReleaseBranchCustomObjectVersion](./uassetapi.customversions.ffortnitereleasebranchcustomobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| DisableLevelset_v14_10 | 1 | Custom 14.10 File Object Version |
| ChaosClothAddTethersToCachedData | 2 | Add the long range attachment tethers to the cloth asset to avoid a large hitch during the cloth's initialization. |
| ChaosKinematicTargetRemoveScale | 3 | Chaos::TKinematicTarget no longer stores a full transform, only position/rotation. |
| ActorComponentUCSModifiedPropertiesSparseStorage | 4 | Move UCSModifiedProperties out of ActorComponent and in to sparse storage |
| FixupNaniteLandscapeMeshes | 5 | Fixup Nanite meshes which were using the wrong material and didn't have proper UVs : |
| RemoveUselessLandscapeMeshesCookedCollisionData | 6 | Remove any cooked collision data from nanite landscape / editor spline meshes since collisions are not needed there : |
| SerializeAnimCurveCompressionCodecGuidOnCook | 7 | Serialize out UAnimCurveCompressionCodec::InstanceGUID to maintain deterministic DDC key generation in cooked-editor |
| FixNaniteLandscapeMeshNames | 8 | Fix the Nanite landscape mesh being reused because of a bad name |
| LandscapeSharedPropertiesEnforcement | 9 | Fixup and synchronize shared properties modified before the synchronicity enforcement |
| WorldPartitionRuntimeCellGuidWithCellSize | 10 | Include the cell size when computing the cell guid |
| NaniteMaterialOverrideUsesEditorOnly | 11 | Enable SkipOnlyEditorOnly style cooking of NaniteOverrideMaterial |
| SinglePrecisonParticleData | 12 | Store game thread particles data in single precision |
| PCGPointStructuredSerializer | 13 | UPCGPoint custom serialization |
| NavMovementComponentMovingPropertiesToStruct | 14 | Deprecation of Nav Movement Properties and moving them to a new struct |
| DynamicMeshAttributesSerializeBones | 15 | Add bone serialization for dynamic mesh attributes |
| VersionPlusOne | 16 | -----new versions can be added above this line------------------------------------------------- |

```

`docs/src/api/uassetapi.customversions.fframeworkobjectversion.md`:

```md
# FFrameworkObjectVersion

Namespace: UAssetAPI.CustomVersions

Custom serialization version for changes made in Dev-Framework stream.

```csharp
public enum FFrameworkObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FFrameworkObjectVersion](./uassetapi.customversions.fframeworkobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| UseBodySetupCollisionProfile | 1 | BodySetup's default instance collision profile is used by default when creating a new instance. |
| AnimBlueprintSubgraphFix | 2 | Regenerate subgraph arrays correctly in animation blueprints to remove duplicates and add missing graphs that appear read only when edited |
| MeshSocketScaleUtilization | 3 | Static and skeletal mesh sockets now use the specified scale |
| ExplicitAttachmentRules | 4 | Attachment rules are now explicit in how they affect location, rotation and scale |
| MoveCompressedAnimDataToTheDDC | 5 | Moved compressed anim data from uasset to the DDC |
| FixNonTransactionalPins | 6 | Some graph pins created using legacy code seem to have lost the RF_Transactional flag, which causes issues with undo. Restore the flag at this version |
| SmartNameRefactor | 7 | Create new struct for SmartName, and use that for CurveName |
| AddSourceReferenceSkeletonToRig | 8 | Add Reference Skeleton to Rig |
| ConstraintInstanceBehaviorParameters | 9 | Refactor ConstraintInstance so that we have an easy way to swap behavior paramters |
| PoseAssetSupportPerBoneMask | 10 | Pose Asset support mask per bone |
| PhysAssetUseSkeletalBodySetup | 11 | Physics Assets now use SkeletalBodySetup instead of BodySetup |
| RemoveSoundWaveCompressionName | 12 | Remove SoundWave CompressionName |
| AddInternalClothingGraphicalSkinning | 13 | Switched render data for clothing over to unreal data, reskinned to the simulation mesh |
| WheelOffsetIsFromWheel | 14 | Wheel force offset is now applied at the wheel instead of vehicle COM |
| MoveCurveTypesToSkeleton | 15 | Move curve metadata to be saved in skeleton. Individual asset still saves some flag - i.e. disabled curve and editable or not, but major flag - i.e. material types - moves to skeleton and handle in one place |
| CacheDestructibleOverlaps | 16 | Cache destructible overlaps on save |
| GeometryCacheMissingMaterials | 17 | Added serialization of materials applied to geometry cache objects |
| LODsUseResolutionIndependentScreenSize | 18 | Switch static and skeletal meshes to calculate LODs based on resolution-independent screen size |
| BlendSpacePostLoadSnapToGrid | 19 | Blend space post load verification |
| SupportBlendSpaceRateScale | 20 | Addition of rate scales to blend space samples |
| LODHysteresisUseResolutionIndependentScreenSize | 21 | LOD hysteresis also needs conversion from the LODsUseResolutionIndependentScreenSize version |
| ChangeAudioComponentOverrideSubtitlePriorityDefault | 22 | AudioComponent override subtitle priority default change |
| HardSoundReferences | 23 | Serialize hard references to sound files when possible |
| EnforceConstInAnimBlueprintFunctionGraphs | 24 | Enforce const correctness in Animation Blueprint function graphs |
| InputKeySelectorTextStyle | 25 | Upgrade the InputKeySelector to use a text style |
| EdGraphPinContainerType | 26 | Represent a pins container type as an enum not 3 independent booleans |
| ChangeAssetPinsToString | 27 | Switch asset pins to store as string instead of hard object reference |
| LocalVariablesBlueprintVisible | 28 | Fix Local Variables so that the properties are correctly flagged as blueprint visible |
| RemoveUField_Next | 29 | Stopped serializing UField_Next so that UFunctions could be serialized in dependently of a UClass in order to allow us to do all UFunction loading in a single pass (after classes and CDOs are created) |
| UserDefinedStructsBlueprintVisible | 30 | Fix User Defined structs so that all members are correct flagged blueprint visible |
| PinsStoreFName | 31 | FMaterialInput and FEdGraphPin store their name as FName instead of FString |
| UserDefinedStructsStoreDefaultInstance | 32 | User defined structs store their default instance, which is used for initializing instances |
| FunctionTerminatorNodesUseMemberReference | 33 | Function terminator nodes serialize an FMemberReference rather than a name/class pair |
| EditableEventsUseConstRefParameters | 34 | Custom event and non-native interface event implementations add 'const' to reference parameters |
| BlueprintGeneratedClassIsAlwaysAuthoritative | 35 | No longer serialize the legacy flag that indicates this state, as it is now implied since we don't serialize the skeleton CDO |
| EnforceBlueprintFunctionVisibility | 36 | Enforce visibility of blueprint functions - e.g. raise an error if calling a private function from another blueprint: |
| StoringUCSSerializationIndex | 37 | ActorComponents now store their serialization index |

```

`docs/src/api/uassetapi.customversions.fniagaracustomversion.md`:

```md
# FNiagaraCustomVersion

Namespace: UAssetAPI.CustomVersions

```csharp
public enum FNiagaraCustomVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FNiagaraCustomVersion](./uassetapi.customversions.fniagaracustomversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made in niagara |
| VMExternalFunctionBindingRework | 1 | Reworked vm external function binding to be more robust. |
| PostLoadCompilationEnabled | 2 | Making all Niagara files reference the version number, allowing post loading recompilation if necessary. |
| VMExternalFunctionBindingReworkPartDeux | 3 | Moved some runtime cost from external functions into the binding step and used variadic templates to neaten that code greatly. |
| DataInterfacePerInstanceRework | 4 | Moved per instance data needed for certain data interfaces out to it's own struct. |
| NiagaraShaderMaps | 5 | Added shader maps and corresponding infrastructure |
| UpdateSpawnEventGraphCombination | 6 | Combined Spawn, Update, and Event scripts into one graph. |
| DataSetLayoutRework | 7 | Reworked data layout to store float and int data separately. |
| AddedEmitterAndSystemScripts | 8 | Reworked scripts to support emitter and system scripts |
| ScriptExecutionContextRework | 9 | Rework of script execution contexts to allow better reuse and reduce overhead of parameter handling. |
| RemovalOfNiagaraVariableIDs | 10 | Removed the Niagara variable ID's making hookup impossible until next compile |
| SystemEmitterScriptSimulations | 11 | System and emitter script simulations. |
| IntegerRandom | 12 | Adding integer random to VM. TODO: The vm really needs its own versioning system that will force a recompile when changes. |
| AddedEmitterSpawnAttributes | 13 | Added emitter spawn attributes |
| NiagaraShaderMapCooking | 14 | cooking of shader maps and corresponding infrastructure |
| NiagaraShaderMapCooking2 | 15 | don't serialize shader maps for system scripts |
| AddedScriptRapidIterationVariables | 16 | Added script rapid iteration variables, usually top-level module parameters... |
| AddedTypeToDataInterfaceInfos | 17 | Added type to data interface infos |
| EnabledAutogeneratedDefaultValuesForFunctionCallNodes | 18 | Hooked up autogenerated default values for function call nodes. |
| CurveLUTNowOnByDefault | 19 | Now curve data interfaces have look-up tables on by default. |
| ScriptsNowUseAGuidForIdentificationInsteadOfAnIndex | 20 | Scripts now use a guid for identification instead of an index when there are more than one with the same usage. |
| NiagaraCombinedGPUSpawnUpdate | 21 | don't serialize shader maps for update scripts |
| DontCompileGPUWhenNotNeeded | 22 | don't serialize shader maps for emitters that don't run on gpu. |
| NowSerializingReadWriteDataSets | 24 | We weren't serializing event data sets previously. |
| TranslatorClearOutBetweenEmitters | 25 | Forcing the internal parameter map vars to be reset between emitter calls. |
| AddSamplerDataInterfaceParams | 26 | added sampler shader params based on DI buffer descriptors |
| GPUShadersForceRecompileNeeded | 27 | Need to force the GPU shaders to recompile |
| PlaybackRangeStoredOnSystem | 28 | The playback range for the timeline is now stored in the system editor data. |
| MovedToDerivedDataCache | 29 | All cached values will auto-recompile. |
| DataInterfacesNotAllocated | 30 | Data interfaces are preallocated |
| EmittersHaveGenericUniqueNames | 31 | emitter scripts are built using "Emitter." instead of the full name. |
| MovingTranslatorVersionToGuid | 32 | no longer have compiler version enum value in this list, instead moved to a guid, which works better for the DDC |
| AddingParamMapToDataSetBaseNode | 33 | adding a parameter map in/out to the data set base node |
| DataInterfaceComputeShaderParamRefactor | 34 | refactor of CS parameters allowing regular params as well as buffers. |
| CurveLUTRegen | 35 | bumping version and forcing curves to regen their LUT on version change. |
| AssignmentNodeUsesBeginDefaults | 36 | Changing the graph generation for assignment nodes so that it uses a "Begin Defaults" node where appropriate. |
| AssignmentNodeHasCorrectUsageBitmask | 37 | Updating the usage flage bitmask for assignment nodes to match the part of the stack it's used in. |
| EmitterLocalSpaceLiteralConstant | 38 | Emitter local space is compiled into the hlsl as a literal constant to expose it to emitter scripts and allow for some better optimization of particle transforms. |
| TextureDataInterfaceUsesCustomSerialize | 39 | The cpu cache of the texture is now directly serialized instead of using array property serialization. |
| TextureDataInterfaceSizeSerialize | 40 | The texture data interface now streams size info |
| SkelMeshInterfaceAPIImprovements | 41 | API to skeletal mesh interface was improved but requires a recompile and some graph fixup. |
| ImproveLoadTimeFixupOfOpAddPins | 42 | Only do op add pin fixup on existing nodes which are before this version |
| MoveCommonInputMetadataToProperties | 43 | Moved commonly used input metadata out of the strin/string property metadata map to actual properties on the metadata struct. |
| UseHashesToIdentifyCompileStateOfTopLevelScripts | 44 | Move to using the traversed graph hash and the base script id for the FNiagaraVMExecutableDataId instead of the change id guid to prevent invalidating the DDC. |
| MetaDataAndParametersUpdate | 45 | Reworked how the metadata is stored in NiagaraGraph from storing a Map of FNiagaraVariableMetaData to storing a map of UNiagaraScriptVariable* to be used with the Details panel. |
| MoveInheritanceDataFromTheEmitterHandleToTheEmitter | 46 | Moved the emitter inheritance data from the emitter handle to the emitter to allow for chained emitter inheritance. |
| AddLibraryAssetProperty | 47 | Add property to all Niagara scripts indicating whether or not they belong to the library |
| AddAdditionalDefinesProperty | 48 | Addding additional defines to the GPU script |
| RemoveGraphUsageCompileIds | 49 | Remove the random compile id guids from the cached script usage and from the compile and script ids since the hashes serve the same purpose and are deterministic. |
| AddRIAndDetailLevel | 50 | Adding UseRapidIterationParams and DetailLevelMask to the GPU script |
| ChangeEmitterCompiledDataToSharedRefs | 51 | Changing the system and emitter compiled data to shared pointers to deal with lifetime issues in the editor. They now are handled directly in system serialize. |
| DisableSortingByDefault | 52 | Sorting on Renderers is disabled by default, we add a version to maintain existing systems that expected sorting to be enabled |
| MemorySaving | 53 | Convert TMap into TArray to save memory, TMap contains an inline allocator which pushes the size to 80 bytes |
| AddSimulationStageUsageEnum | 54 | Added a new value to the script usage enum, and we need a custom version to fix the existing bitfields. |
| AddGeneratedFunctionsToGPUParamInfo | 55 | Save the functions generated by a GPU data interface inside FNiagaraDataInterfaceGPUParamInfo |
| PlatformScalingRefactor | 56 | Removed DetailLevel in favor of FNiagaraPlatfomSet based selection of per platform settings. |
| PrecompileNamespaceFixup | 57 | Promote parameters used across script executions to the Dataset, and Demote unused parameters. |
| FixNullScriptVariables | 58 | Postload fixup in UNiagaraGraph to fixup VariableToScriptVariable map entries being null. |
| PrecompileNamespaceFixup2 | 59 | Move FNiagaraVariableMetaData from storing scope enum to storing registered scope name. |
| SimulationStageInUsageBitmask | 60 | Enable the simulation stage flag by default in the usage bitmask of modules and functions |
| StandardizeParameterNames | 61 | Fix graph parameter map parameters on post load so that they all have a consisten parsable format and update the UI to show and filter based on these formats. |
| ComponentsOnlyHaveUserVariables | 62 | Make sure that UNiagaraComponents only have override maps for User variables. |
| RibbonRendererUVRefactor | 63 | Refactor the options for UV settings on the ribbon renderer. |
| VariablesUseTypeDefRegistry | 64 | Replace the TypeDefinition in VariableBase with an index into the type registry |
| AddLibraryVisibilityProperty | 65 | Expand the visibility options of the scripts to be able to hide a script completely from the user |
| ModuleVersioning | 67 | Added support for multiple versions of script data |
| ChangeSystemDeterministicDefault | 69 | Changed the default mode from deterministic to non-deterministic which matches emitters |
| StaticSwitchFunctionPinsUsePersistentGuids | 70 | Update static switch pins to use the PersistentId from their script variable so that when they're renamed their values aren't lost when reallocating pins. |
| VisibilityCullingImprovements | 71 | Extended visibility culling options and moved properties into their own struct. |
| PopulateFunctionCallNodePinNameBindings | 73 | Function call node refresh from external changes has been refactored so that they don't need to populate their name bindings every load. |
| ComponentRendererSpawnProperty | 74 | Changed the default value for the component renderer's OnlyCreateComponentsOnParticleSpawn property |
| RepopulateFunctionCallNodePinNameBindings | 75 | Previous repopulate didn't handle module attributes like Particles.Module.Name so they need to be repopulated for renaming to work correctly. |
| EventSpawnsUpdateInitialAttributeValues | 76 | Event spawns now optionally update Initial. attribute values. New default is true but old data is kept false to maintain existing behavior. |
| AddVariadicParametersToGPUFunctionInfo | 77 | Adds list of variadic parameters to the information about GPU functions. |
| DynamicPinNodeFixup | 78 | Some data fixup for NiagaraNodeWithDynamicPins. |
| RibbonRendererLinkOrderDefaultIsUniqueID | 79 | Ribbon renderer will default to unique ID rather than normalized age to make more things 'just work' |
| SubImageBlendEnabledByDefault | 80 | Renderer SubImage Blends are enabled by default |
| RibbonPlaneUseGeometryNormals | 81 | Ribbon renderer will use geometry normals by default rather than screen / facing aligned normals |
| InitialOwnerVelocityFromActor | 82 | Actors velocity is used for the initial velocity before the component has any tracking, old assets use the old zero velocity |
| ParameterBindingWithValueRenameFixup | 83 | FNiagaraParameterBindingWithValue wouldn't necessarily have the appropriate ResolvedParameter namespace when it comes to emitter merging |
| SimCache_BulkDataVersion1 | 84 | Sim Cache moved to bulk data by default |
| InheritanceUxRefactor | 85 | Decoupling of 'Template' and 'Inheritance' |
| NDCSpawnGroupOverrideDisabledByDefault | 86 | NDC Read DIs will not override spawn group by default when spawning particles. Old content will remain unchanged. |
| CustomSortingBindingToAge | 87 | Before it was normalized age which can introduce flickering with sorting and random lifetimes |
| StatelessInitialMeshOrientationV1 | 88 | Update Initial Mesh Orientation Module |
| HierarchyEditorScriptSupport | 89 | Hierarchy Editor was implemented |
| EmitterStateAddLoopDelayEnabled | 90 | Added loop delay enabled to emitter state |
| SerializeUsageBitMaskToGPUFunctionInfo | 91 | Make sure that we serialize the UsageBitMask with the GPUFunctionInfo |
| AddedNewInterpolatedSpawnMode | 92 | Changed the interpolated spawn property into an enum |
| UserAssetTagStorageInMetaData | 93 | Adding user asset tag storage in UMetaData for all UPackages |
| VersionPlusOne | 94 | DO NOT ADD A NEW VERSION UNLESS YOU HAVE TALKED TO THE NIAGARA LEAD. Mismanagement of these versions can lead to data loss if it is adjusted in multiple streams simultaneously. -----new versions can be added above this line------------------------------------------------- |

```

`docs/src/api/uassetapi.customversions.fniagaraobjectversion.md`:

```md
# FNiagaraObjectVersion

Namespace: UAssetAPI.CustomVersions

```csharp
public enum FNiagaraObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FNiagaraObjectVersion](./uassetapi.customversions.fniagaraobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| VersionPlusOne | 2 | -----new versions can be added above this line------------------------------------------------- |

```

`docs/src/api/uassetapi.customversions.freleaseobjectversion.md`:

```md
# FReleaseObjectVersion

Namespace: UAssetAPI.CustomVersions

Custom serialization version for changes made in Release streams.

```csharp
public enum FReleaseObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FReleaseObjectVersion](./uassetapi.customversions.freleaseobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| StaticMeshExtendedBoundsFix | 1 | Static Mesh extended bounds radius fix |
| NoSyncAsyncPhysAsset | 2 | Physics asset bodies are either in the sync scene or the async scene, but not both |
| LevelTransArrayConvertedToTArray | 3 | ULevel was using TTransArray incorrectly (serializing the entire array in addition to individual mutations). converted to a TArray |
| AddComponentNodeTemplateUniqueNames | 4 | Add Component node templates now use their own unique naming scheme to ensure more reliable archetype lookups. |
| UPropertryForMeshSectionSerialize | 5 | Fix a serialization issue with static mesh FMeshSectionInfoMap FProperty |
| ConvertHLODScreenSize | 6 | Existing HLOD settings screen size to screen area conversion |
| SpeedTreeBillboardSectionInfoFixup | 7 | Adding mesh section info data for existing billboard LOD models |
| EventSectionParameterStringAssetRef | 8 | Change FMovieSceneEventParameters::StructType to be a string asset reference from a TWeakObjectPtr UScriptStruct |
| SkyLightRemoveMobileIrradianceMap | 9 | Remove serialized irradiance map data from skylight. |
| RenameNoTwistToAllowTwistInTwoBoneIK | 10 | rename bNoTwist to bAllowTwist |
| MaterialLayersParameterSerializationRefactor | 11 | Material layers serialization refactor |
| AddSkeletalMeshSectionDisable | 12 | Added disable flag to skeletal mesh data |
| RemovedMaterialSharedInputCollection | 13 | Removed objects that were serialized as part of this material feature |
| HISMCClusterTreeMigration | 14 | HISMC Cluster Tree migration to add new data |
| PinDefaultValuesVerified | 15 | Default values on pins in blueprints could be saved incoherently |
| FixBrokenStateMachineReferencesInTransitionGetters | 16 | During copy and paste transition getters could end up with broken state machine references |
| MeshDescriptionNewSerialization | 17 | Change to MeshDescription serialization |
| UnclampRGBColorCurves | 18 | Change to not clamp RGB values &gt; 1 on linear color curves |
| LinkTimeAnimBlueprintRootDiscoveryBugFix | 19 | BugFix for FAnimObjectVersion::LinkTimeAnimBlueprintRootDiscovery. |
| TrailNodeBlendVariableNameChange | 20 | Change trail anim node variable deprecation |
| PropertiesSerializeRepCondition | 21 | Make sure the Blueprint Replicated Property Conditions are actually serialized properly. |
| FocalDistanceDisablesDOF | 22 | DepthOfFieldFocalDistance at 0 now disables DOF instead of DepthOfFieldFstop at 0. |
| Unused_SoundClass2DReverbSend | 23 | Removed versioning, but version entry must still exist to keep assets saved with this version loadable |
| GroomAssetVersion1 | 24 | Groom asset version |
| GroomAssetVersion2 | 25 | Groom asset version |
| SerializeAnimModifierState | 26 | Store applied version of Animation Modifier to use when reverting |
| GroomAssetVersion3 | 27 | Groom asset version |
| DeprecateFilmbackSettings | 28 | Upgrade filmback |
| CustomImplicitCollisionType | 29 | custom collision type |
| FFieldPathOwnerSerialization | 30 | FFieldPath will serialize the owner struct reference and only a short path to its property |
| ReleaseUE4VersionFixup | 31 | Dummy version to allow us to Fix up the fact that ReleaseObjectVersion was changed elsewhere |
| PinTypeIncludesUObjectWrapperFlag | 32 | Pin types include a flag that propagates the 'CPF_UObjectWrapper' flag to generated properties |
| WeightFMeshToMeshVertData | 33 | Added Weight member to FMeshToMeshVertData |
| AnimationGraphNodeBindingsDisplayedAsPins | 34 | Animation graph node bindings displayed as pins |
| SerializeRigVMOffsetSegmentPaths | 35 | Serialized rigvm offset segment paths |
| AbcVelocitiesSupport | 36 | Upgrade AbcGeomCacheImportSettings for velocities |
| MarginAddedToConvexAndBox | 37 | Add margin support to Chaos Convex |
| StructureDataAddedToConvex | 38 | Add structure data to Chaos Convex |
| AddedFrontRightUpAxesToLiveLinkPreProcessor | 39 | Changed axis UI for LiveLink AxisSwitch Pre Processor |
| FixupCopiedEventSections | 40 | Some sequencer event sections that were copy-pasted left broken links to the director BP |
| RemoteControlSerializeFunctionArgumentsSize | 41 | Serialize the number of bytes written when serializing function arguments |
| AddedSubSequenceEntryWarpCounter | 42 | Add loop counters to sequencer's compiled sub-sequence data |
| LonglatTextureCubeDefaultMaxResolution | 43 | Remove default resolution limit of 512 pixels for cubemaps generated from long-lat sources |

```

`docs/src/api/uassetapi.customversions.fsequencerobjectversion.md`:

```md
# FSequencerObjectVersion

Namespace: UAssetAPI.CustomVersions

```csharp
public enum FSequencerObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FSequencerObjectVersion](./uassetapi.customversions.fsequencerobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| RenameMediaSourcePlatformPlayers | 1 | Per-platform overrides player overrides for media sources changed name and type. |
| ConvertEnableRootMotionToForceRootLock | 2 | Enable root motion isn't the right flag to use, but force root lock |
| ConvertMultipleRowsToTracks | 3 | Convert multiple rows to tracks |
| WhenFinishedDefaultsToRestoreState | 4 | When finished now defaults to restore state |
| EvaluationTree | 5 | EvaluationTree added |
| WhenFinishedDefaultsToProjectDefault | 6 | When finished now defaults to project default |
| FloatToIntConversion | 7 | Use int range rather than float range in FMovieSceneSegment |
| PurgeSpawnableBlueprints | 8 | Purged old spawnable blueprint classes from level sequence assets |
| FinishUMGEvaluation | 9 | Finish UMG evaluation on end |
| SerializeFloatChannel | 10 | Manual serialization of float channel |
| ModifyLinearKeysForOldInterp | 11 | Change the linear keys so they act the old way and interpolate always. |
| SerializeFloatChannelCompletely | 12 | Full Manual serialization of float channel |
| SpawnableImprovements | 13 | Set ContinuouslyRespawn to false by default, added FMovieSceneSpawnable::bNetAddressableName |

```

`docs/src/api/uassetapi.customversions.fue5releasestreamobjectversion.md`:

```md
# FUE5ReleaseStreamObjectVersion

Namespace: UAssetAPI.CustomVersions

```csharp
public enum FUE5ReleaseStreamObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FUE5ReleaseStreamObjectVersion](./uassetapi.customversions.fue5releasestreamobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| BeforeCustomVersionWasAdded | 0 | Before any version changes were made |
| ReflectionMethodEnum | 1 | Added Lumen reflections to new reflection enum, changed defaults |
| WorldPartitionActorDescSerializeHLODInfo | 2 | Serialize HLOD info in WorldPartitionActorDesc |
| RemovingTessellation | 3 | Removing Tessellation from materials and meshes. |
| LevelInstanceSerializeRuntimeBehavior | 4 | LevelInstance serialize runtime behavior |
| PoseAssetRuntimeRefactor | 5 | Refactoring Pose Asset runtime data structures |
| WorldPartitionActorDescSerializeActorFolderPath | 6 | Serialize the folder path of actor descs |
| HairStrandsVertexFormatChange | 7 | Change hair strands vertex format |
| AddChaosMaxLinearAngularSpeed | 8 | Added max linear and angular speed to Chaos bodies |
| PackedLevelInstanceVersion | 9 | PackedLevelInstance version |
| PackedLevelInstanceBoundsFix | 10 | PackedLevelInstance bounds fix |
| CustomPropertyAnimGraphNodesUseOptionalPinManager | 11 | Custom property anim graph nodes (linked anim graphs, control rig etc.) now use optional pin manager |
| TextFormatArgumentData64bitSupport | 12 | Add native double and int64 support to FFormatArgumentData |
| MaterialLayerStacksAreNotParameters | 13 | Material layer stacks are no longer considered 'static parameters' |
| MaterialInterfaceSavedCachedData | 14 | CachedExpressionData is moved from UMaterial to UMaterialInterface |
| AddClothMappingLODBias | 15 | Add support for multiple cloth deformer LODs to be able to raytrace cloth with a different LOD than the one it is rendered with |
| AddLevelActorPackagingScheme | 16 | Add support for different external actor packaging schemes |
| WorldPartitionActorDescSerializeAttachParent | 17 | Add support for linking to the attached parent actor in WorldPartitionActorDesc |
| ConvertedActorGridPlacementToSpatiallyLoadedFlag | 18 | Converted AActor GridPlacement to bIsSpatiallyLoaded flag |
| ActorGridPlacementDeprecateDefaultValueFixup | 19 | Fixup for bad default value for GridPlacement_DEPRECATED |
| PackedLevelActorUseWorldPartitionActorDesc | 20 | PackedLevelActor started using FWorldPartitionActorDesc (not currently checked against but added as a security) |
| AddLevelActorFolders | 21 | Add support for actor folder objects |
| RemoveSkeletalMeshLODModelBulkDatas | 22 | Remove FSkeletalMeshLODModel bulk datas |
| ExcludeBrightnessFromEncodedHDRCubemap | 23 | Exclude brightness from the EncodedHDRCubemap, |
| VolumetricCloudSampleCountUnification | 24 | Unified volumetric cloud component quality sample count slider between main and reflection views for consistency |
| PoseAssetRawDataGUID | 25 | Pose asset GUID generated from source AnimationSequence |
| ConvolutionBloomIntensity | 26 | Convolution bloom now take into account FPostProcessSettings::BloomIntensity for scatter dispersion. |
| WorldPartitionHLODActorDescSerializeHLODSubActors | 27 | Serialize FHLODSubActors instead of FGuids in WorldPartition HLODActorDesc |
| LargeWorldCoordinates | 28 | Large Worlds - serialize double types as doubles |
| BlueprintPinsUseRealNumbers | 29 | Deserialize old BP float and double types as real numbers for pins |
| UpdatedDirectionalLightShadowDefaults | 30 | Changed shadow defaults for directional light components, version needed to not affect old things |
| GeometryCollectionConvexDefaults | 31 | Refresh geometry collections that had not already generated convex bodies. |
| ChaosClothFasterDamping | 32 | Add faster damping calculations to the cloth simulation and rename previous Damping parameter to LocalDamping. |
| WorldPartitionLandscapeActorDescSerializeLandscapeActorGuid | 33 | Serialize LandscapeActorGuid in FLandscapeActorDesc sub class. |
| AddedInertiaTensorAndRotationOfMassAddedToConvex | 34 | add inertia tensor and rotation of mass to convex |
| ChaosInertiaConvertedToVec3 | 35 | Storing inertia tensor as vec3 instead of matrix. |
| SerializeFloatPinDefaultValuesAsSinglePrecision | 36 | For Blueprint real numbers, ensure that legacy float data is serialized as single-precision |
| AnimLayeredBoneBlendMasks | 37 | Upgrade the BlendMasks array in existing LayeredBoneBlend nodes |
| StoreReflectionCaptureEncodedHDRDataInRG11B10Format | 38 | Uses RG11B10 format to store the encoded reflection capture data on mobile |
| RawAnimSequenceTrackSerializer | 39 | Add WithSerializer type trait and implementation for FRawAnimSequenceTrack |
| RemoveDuplicatedStyleInfo | 40 | Removed font from FEditableTextBoxStyle, and added FTextBlockStyle instead. |
| LinkedAnimGraphMemberReference | 41 | Added member reference to linked anim graphs |
| DynamicMeshComponentsDefaultUseExternalTangents | 42 | Changed default tangent behavior for new dynamic mesh components |
| MediaCaptureNewResizeMethods | 43 | Added resize methods to media capture |
| RigVMSaveDebugMapInGraphFunctionData | 44 | Function data stores a map from work to debug operands |
| LocalExposureDefaultChangeFrom1 | 45 | Changed default Local Exposure Contrast Scale from 1.0 to 0.8 |
| WorldPartitionActorDescSerializeActorIsListedInSceneOutliner | 46 | Serialize bActorIsListedInSceneOutliner in WorldPartitionActorDesc |
| OpenColorIODisabledDisplayConfigurationDefault | 47 | Disabled opencolorio display configuration by default |
| WorldPartitionExternalDataLayers | 48 | Serialize ExternalDataLayerAsset in WorldPartitionActorDesc |
| ChaosClothFictitiousAngularVelocitySubframeFix | 49 | Fix Chaos Cloth fictitious angular scale bug that requires existing parameter rescaling. |
| SinglePrecisonParticleDataPT | 50 | Store physics thread particles data in single precision |
| OrthographicAutoNearFarPlane | 51 | Orthographic Near and Far Plane Auto-resolve enabled by default |
| VersionPlusOne | 52 | -----new versions can be added above this line------------------------------------------------- |

```

`docs/src/api/uassetapi.customversions.introducedattribute.md`:

```md
# IntroducedAttribute

Namespace: UAssetAPI.CustomVersions

Represents the engine version at the time that a custom version was implemented.

```csharp
public class IntroducedAttribute : System.Attribute
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Attribute](https://docs.microsoft.com/en-us/dotnet/api/system.attribute) → [IntroducedAttribute](./uassetapi.customversions.introducedattribute.md)

## Fields

### **IntroducedVersion**

```csharp
public EngineVersion IntroducedVersion;
```

## Properties

### **TypeId**

```csharp
public object TypeId { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **IntroducedAttribute(EngineVersion)**

```csharp
public IntroducedAttribute(EngineVersion introducedVersion)
```

#### Parameters

`introducedVersion` [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>

```

`docs/src/api/uassetapi.exporttypes.classexport.md`:

```md
# ClassExport

Namespace: UAssetAPI.ExportTypes

Represents an object class.

```csharp
public class ClassExport : StructExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [FieldExport](./uassetapi.exporttypes.fieldexport.md) → [StructExport](./uassetapi.exporttypes.structexport.md) → [ClassExport](./uassetapi.exporttypes.classexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **FuncMap**

Map of all functions by name contained in this class

```csharp
public TMap<FName, FPackageIndex> FuncMap;
```

### **ClassFlags**

Class flags; See [EClassFlags](./uassetapi.unrealtypes.eclassflags.md) for more information

```csharp
public EClassFlags ClassFlags;
```

### **ClassWithin**

The required type for the outer of instances of this class

```csharp
public FPackageIndex ClassWithin;
```

### **ClassConfigName**

Which Name.ini file to load Config variables out of

```csharp
public FName ClassConfigName;
```

### **Interfaces**

The list of interfaces which this class implements, along with the pointer property that is located at the offset of the interface's vtable.
 If the interface class isn't native, the property will be empty.

```csharp
public SerializedInterfaceReference[] Interfaces;
```

### **ClassGeneratedBy**

This is the blueprint that caused the generation of this class, or null if it is a native compiled-in class

```csharp
public FPackageIndex ClassGeneratedBy;
```

### **bDeprecatedForceScriptOrder**

Does this class use deprecated script order?

```csharp
public bool bDeprecatedForceScriptOrder;
```

### **bCooked**

Used to check if the class was cooked or not

```csharp
public bool bCooked;
```

### **ClassDefaultObject**

The class default object; used for delta serialization and object initialization

```csharp
public FPackageIndex ClassDefaultObject;
```

### **SuperStruct**

Struct this inherits from, may be null

```csharp
public FPackageIndex SuperStruct;
```

### **Children**

List of child fields

```csharp
public FPackageIndex[] Children;
```

### **LoadedProperties**

Properties serialized with this struct definition

```csharp
public FProperty[] LoadedProperties;
```

### **ScriptBytecode**

The bytecode instructions contained within this struct.

```csharp
public KismetExpression[] ScriptBytecode;
```

### **ScriptBytecodeSize**

Bytecode size in total in deserialized memory. Filled out in lieu of [StructExport.ScriptBytecode](./uassetapi.exporttypes.structexport.md#scriptbytecode) if an error occurs during bytecode parsing.

```csharp
public int ScriptBytecodeSize;
```

### **ScriptBytecodeRaw**

Raw binary bytecode data. Filled out in lieu of [StructExport.ScriptBytecode](./uassetapi.exporttypes.structexport.md#scriptbytecode) if an error occurs during bytecode parsing.

```csharp
public Byte[] ScriptBytecodeRaw;
```

### **Field**

```csharp
public UField Field;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **ClassExport(Export)**

```csharp
public ClassExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **ClassExport(UAsset, Byte[])**

```csharp
public ClassExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **ClassExport()**

```csharp
public ClassExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.datatableexport.md`:

```md
# DataTableExport

Namespace: UAssetAPI.ExportTypes

Export for an imported spreadsheet table. See [UDataTable](./uassetapi.exporttypes.udatatable.md).

```csharp
public class DataTableExport : NormalExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [DataTableExport](./uassetapi.exporttypes.datatableexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Table**

```csharp
public UDataTable Table;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **DataTableExport(Export)**

```csharp
public DataTableExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **DataTableExport(UDataTable, UAsset, Byte[])**

```csharp
public DataTableExport(UDataTable data, UAsset asset, Byte[] extras)
```

#### Parameters

`data` [UDataTable](./uassetapi.exporttypes.udatatable.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **DataTableExport()**

```csharp
public DataTableExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.eclassserializationcontrolextension.md`:

```md
# EClassSerializationControlExtension

Namespace: UAssetAPI.ExportTypes

Enum flags that indicate that additional data may be serialized prior to actual tagged property serialization
 Those extensions are used to store additional function to control how TPS will resolved. e.g. use overridable serialization

```csharp
public enum EClassSerializationControlExtension
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EClassSerializationControlExtension](./uassetapi.exporttypes.eclassserializationcontrolextension.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.exporttypes.ecppform.md`:

```md
# ECppForm

Namespace: UAssetAPI.ExportTypes

How this enum is declared in C++. Affects the internal naming of enum values.

```csharp
public enum ECppForm
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECppForm](./uassetapi.exporttypes.ecppform.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.exporttypes.eexportfilterflags.md`:

```md
# EExportFilterFlags

Namespace: UAssetAPI.ExportTypes

Enum used to determine whether an export should be loaded or not on the client/server. Not actually a bitflag.

```csharp
public enum EExportFilterFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EExportFilterFlags](./uassetapi.exporttypes.eexportfilterflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.exporttypes.enumexport.md`:

```md
# EnumExport

Namespace: UAssetAPI.ExportTypes

Export data for an enumeration. See [UEnum](./uassetapi.exporttypes.uenum.md).

```csharp
public class EnumExport : NormalExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [EnumExport](./uassetapi.exporttypes.enumexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Enum**

The enum that is stored in this export.

```csharp
public UEnum Enum;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **EnumExport(Export)**

```csharp
public EnumExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **EnumExport(UAsset, Byte[])**

```csharp
public EnumExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **EnumExport()**

```csharp
public EnumExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.export.md`:

```md
# Export

Namespace: UAssetAPI.ExportTypes

UObject resource type for objects that are contained within this package and can be referenced by other packages.

```csharp
public class Export : System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Constructors

### **Export(UAsset, Byte[])**

```csharp
public Export(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **Export()**

```csharp
public Export()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

Resolves the ancestry of all child properties of this export.

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

### **ReadExportMapEntry(AssetBinaryReader)**

```csharp
public void ReadExportMapEntry(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **GetExportMapEntrySize(UAsset)**

```csharp
public static long GetExportMapEntrySize(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

### **WriteExportMapEntry(AssetBinaryWriter)**

```csharp
public void WriteExportMapEntry(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

### **GetAllObjectExportFields(UAsset)**

```csharp
public static MemberInfo[] GetAllObjectExportFields(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[MemberInfo[]](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo)<br>

### **GetAllFieldNames(UAsset)**

```csharp
public static String[] GetAllFieldNames(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **GetExportClassType()**

```csharp
public FName GetExportClassType()
```

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **GetClassTypeForAncestry(UAsset, FName&)**

```csharp
public FName GetClassTypeForAncestry(UAsset asset, FName& modulePath)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`modulePath` [FName&](./uassetapi.unrealtypes.fname&.md)<br>

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **GetClassTypeForAncestry(FPackageIndex, UAsset, FName&)**

```csharp
public static FName GetClassTypeForAncestry(FPackageIndex classIndex, UAsset asset, FName& modulePath)
```

#### Parameters

`classIndex` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

`modulePath` [FName&](./uassetapi.unrealtypes.fname&.md)<br>

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Clone()**

```csharp
public object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ConvertToChildExport&lt;T&gt;()**

Creates a child export instance with the same export details as the current export.

```csharp
public T ConvertToChildExport<T>()
```

#### Type Parameters

`T`<br>
The type of child export to create.

#### Returns

T<br>
An instance of the child export type provided with the export details copied over.

```

`docs/src/api/uassetapi.exporttypes.fieldexport.md`:

```md
# FieldExport

Namespace: UAssetAPI.ExportTypes

Export data for a [UField](./uassetapi.fieldtypes.ufield.md).

```csharp
public class FieldExport : NormalExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [FieldExport](./uassetapi.exporttypes.fieldexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Field**

```csharp
public UField Field;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **FieldExport(Export)**

```csharp
public FieldExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **FieldExport(UAsset, Byte[])**

```csharp
public FieldExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **FieldExport()**

```csharp
public FieldExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.fstringtable.md`:

```md
# FStringTable

Namespace: UAssetAPI.ExportTypes

A string table. Holds Key-&gt;SourceString pairs of text.

```csharp
public class FStringTable : UAssetAPI.UnrealTypes.TMap`2[[UAssetAPI.UnrealTypes.FString],[UAssetAPI.UnrealTypes.FString]], UAssetAPI.UnrealTypes.IOrderedDictionary`2[[UAssetAPI.UnrealTypes.FString],[UAssetAPI.UnrealTypes.FString]], System.Collections.Generic.IDictionary`2[[UAssetAPI.UnrealTypes.FString],[UAssetAPI.UnrealTypes.FString]], System.Collections.Generic.ICollection`1[[System.Collections.Generic.KeyValuePair`2[[UAssetAPI.UnrealTypes.FString],[UAssetAPI.UnrealTypes.FString]]]], System.Collections.Generic.IEnumerable`1[[System.Collections.Generic.KeyValuePair`2[[UAssetAPI.UnrealTypes.FString],[UAssetAPI.UnrealTypes.FString]]]], System.Collections.IEnumerable, System.Collections.Specialized.IOrderedDictionary, System.Collections.IDictionary, System.Collections.ICollection
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [TMap&lt;FString, FString&gt;](./uassetapi.unrealtypes.tmap-2.md) → [FStringTable](./uassetapi.exporttypes.fstringtable.md)<br>
Implements [IOrderedDictionary&lt;FString, FString&gt;](./uassetapi.unrealtypes.iordereddictionary-2.md), [IDictionary&lt;FString, FString&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.idictionary-2), [ICollection&lt;KeyValuePair&lt;FString, FString&gt;&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1), [IEnumerable&lt;KeyValuePair&lt;FString, FString&gt;&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1), [IEnumerable](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable), IOrderedDictionary, [IDictionary](https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary), [ICollection](https://docs.microsoft.com/en-us/dotnet/api/system.collections.icollection)

## Fields

### **TableNamespace**

```csharp
public FString TableNamespace;
```

## Properties

### **Item**

```csharp
public FString Item { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Item**

```csharp
public FString Item { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Count**

Gets the number of items in the dictionary

```csharp
public int Count { get; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Keys**

Gets all the keys in the ordered dictionary in their proper order.

```csharp
public ICollection<FString> Keys { get; }
```

#### Property Value

[ICollection&lt;FString&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1)<br>

### **Values**

Gets all the values in the ordered dictionary in their proper order.

```csharp
public ICollection<FString> Values { get; }
```

#### Property Value

[ICollection&lt;FString&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1)<br>

### **Comparer**

Gets the key comparer for this dictionary

```csharp
public IEqualityComparer<FString> Comparer { get; }
```

#### Property Value

[IEqualityComparer&lt;FString&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.iequalitycomparer-1)<br>

## Constructors

### **FStringTable(FString)**

```csharp
public FStringTable(FString tableNamespace)
```

#### Parameters

`tableNamespace` [FString](./uassetapi.unrealtypes.fstring.md)<br>

### **FStringTable()**

```csharp
public FStringTable()
```

```

`docs/src/api/uassetapi.exporttypes.functionexport.md`:

```md
# FunctionExport

Namespace: UAssetAPI.ExportTypes

Export data for a blueprint function.

```csharp
public class FunctionExport : StructExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [FieldExport](./uassetapi.exporttypes.fieldexport.md) → [StructExport](./uassetapi.exporttypes.structexport.md) → [FunctionExport](./uassetapi.exporttypes.functionexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **FunctionFlags**

```csharp
public EFunctionFlags FunctionFlags;
```

### **SuperStruct**

Struct this inherits from, may be null

```csharp
public FPackageIndex SuperStruct;
```

### **Children**

List of child fields

```csharp
public FPackageIndex[] Children;
```

### **LoadedProperties**

Properties serialized with this struct definition

```csharp
public FProperty[] LoadedProperties;
```

### **ScriptBytecode**

The bytecode instructions contained within this struct.

```csharp
public KismetExpression[] ScriptBytecode;
```

### **ScriptBytecodeSize**

Bytecode size in total in deserialized memory. Filled out in lieu of [StructExport.ScriptBytecode](./uassetapi.exporttypes.structexport.md#scriptbytecode) if an error occurs during bytecode parsing.

```csharp
public int ScriptBytecodeSize;
```

### **ScriptBytecodeRaw**

Raw binary bytecode data. Filled out in lieu of [StructExport.ScriptBytecode](./uassetapi.exporttypes.structexport.md#scriptbytecode) if an error occurs during bytecode parsing.

```csharp
public Byte[] ScriptBytecodeRaw;
```

### **Field**

```csharp
public UField Field;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **FunctionExport(Export)**

```csharp
public FunctionExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **FunctionExport(UAsset, Byte[])**

```csharp
public FunctionExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **FunctionExport()**

```csharp
public FunctionExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.furl.md`:

```md
# FURL

Namespace: UAssetAPI.ExportTypes

URL structure.

```csharp
public struct FURL
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FURL](./uassetapi.exporttypes.furl.md)

## Fields

### **Protocol**

```csharp
public FString Protocol;
```

### **Host**

```csharp
public FString Host;
```

### **Port**

```csharp
public int Port;
```

### **Valid**

```csharp
public int Valid;
```

### **Map**

```csharp
public FString Map;
```

### **Op**

```csharp
public List<FString> Op;
```

### **Portal**

```csharp
public FString Portal;
```

## Constructors

### **FURL(AssetBinaryReader)**

```csharp
FURL(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.exporttypes.levelexport.md`:

```md
# LevelExport

Namespace: UAssetAPI.ExportTypes

```csharp
public class LevelExport : NormalExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [LevelExport](./uassetapi.exporttypes.levelexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Owner**

```csharp
public FPackageIndex Owner;
```

### **Actors**

```csharp
public List<FPackageIndex> Actors;
```

### **URL**

```csharp
public FURL URL;
```

### **Model**

```csharp
public FPackageIndex Model;
```

### **ModelComponents**

```csharp
public List<FPackageIndex> ModelComponents;
```

### **LevelScriptActor**

```csharp
public FPackageIndex LevelScriptActor;
```

### **NavListStart**

```csharp
public FPackageIndex NavListStart;
```

### **NavListEnd**

```csharp
public FPackageIndex NavListEnd;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **LevelExport(Export)**

```csharp
public LevelExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **LevelExport(UAsset, Byte[])**

```csharp
public LevelExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **LevelExport()**

```csharp
public LevelExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.metadataexport.md`:

```md
# MetaDataExport

Namespace: UAssetAPI.ExportTypes

```csharp
public class MetaDataExport : NormalExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [MetaDataExport](./uassetapi.exporttypes.metadataexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **ObjectMetaData**

```csharp
public List<ObjectMetaDataEntry> ObjectMetaData;
```

### **RootMetaData**

```csharp
public TMap<FName, FString> RootMetaData;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **MetaDataExport(Export)**

```csharp
public MetaDataExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **MetaDataExport(UAsset, Byte[])**

```csharp
public MetaDataExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **MetaDataExport()**

```csharp
public MetaDataExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.normalexport.md`:

```md
# NormalExport

Namespace: UAssetAPI.ExportTypes

A regular export representing a UObject, with no special serialization.

```csharp
public class NormalExport : Export, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **NormalExport(Export)**

```csharp
public NormalExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **NormalExport(UAsset, Byte[])**

```csharp
public NormalExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **NormalExport(List&lt;PropertyData&gt;, UAsset, Byte[])**

```csharp
public NormalExport(List<PropertyData> data, UAsset asset, Byte[] extras)
```

#### Parameters

`data` [List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **NormalExport()**

```csharp
public NormalExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.objectmetadataentry.md`:

```md
# ObjectMetaDataEntry

Namespace: UAssetAPI.ExportTypes

```csharp
public struct ObjectMetaDataEntry
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [ObjectMetaDataEntry](./uassetapi.exporttypes.objectmetadataentry.md)

## Fields

### **Import**

```csharp
public int Import;
```

### **MetaData**

```csharp
public TMap<FName, FString> MetaData;
```

## Constructors

### **ObjectMetaDataEntry(Int32, TMap&lt;FName, FString&gt;)**

```csharp
ObjectMetaDataEntry(int import, TMap<FName, FString> metaData)
```

#### Parameters

`import` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`metaData` [TMap&lt;FName, FString&gt;](./uassetapi.unrealtypes.tmap-2.md)<br>

```

`docs/src/api/uassetapi.exporttypes.propertyexport.md`:

```md
# PropertyExport

Namespace: UAssetAPI.ExportTypes

Export data for a [UProperty](./uassetapi.fieldtypes.uproperty.md).

```csharp
public class PropertyExport : NormalExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [PropertyExport](./uassetapi.exporttypes.propertyexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Property**

```csharp
public UProperty Property;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **PropertyExport(Export)**

```csharp
public PropertyExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **PropertyExport(UAsset, Byte[])**

```csharp
public PropertyExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **PropertyExport()**

```csharp
public PropertyExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.rawexport.md`:

```md
# RawExport

Namespace: UAssetAPI.ExportTypes

An export that could not be properly parsed by UAssetAPI, and is instead represented as an array of bytes as a fallback.

```csharp
public class RawExport : Export, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [RawExport](./uassetapi.exporttypes.rawexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Data**

```csharp
public Byte[] Data;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Constructors

### **RawExport(Export)**

```csharp
public RawExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **RawExport(Byte[], UAsset, Byte[])**

```csharp
public RawExport(Byte[] data, UAsset asset, Byte[] extras)
```

#### Parameters

`data` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **RawExport()**

```csharp
public RawExport()
```

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.serializedinterfacereference.md`:

```md
# SerializedInterfaceReference

Namespace: UAssetAPI.ExportTypes

Represents an interface that a UClass ([ClassExport](./uassetapi.exporttypes.classexport.md)) implements.

```csharp
public struct SerializedInterfaceReference
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [SerializedInterfaceReference](./uassetapi.exporttypes.serializedinterfacereference.md)

## Fields

### **Class**

```csharp
public int Class;
```

### **PointerOffset**

```csharp
public int PointerOffset;
```

### **bImplementedByK2**

```csharp
public bool bImplementedByK2;
```

## Constructors

### **SerializedInterfaceReference(Int32, Int32, Boolean)**

```csharp
SerializedInterfaceReference(int class, int pointerOffset, bool bImplementedByK2)
```

#### Parameters

`class` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`pointerOffset` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`bImplementedByK2` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

```

`docs/src/api/uassetapi.exporttypes.stringtableexport.md`:

```md
# StringTableExport

Namespace: UAssetAPI.ExportTypes

Export data for a string table. See [FStringTable](./uassetapi.exporttypes.fstringtable.md).

```csharp
public class StringTableExport : NormalExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [StringTableExport](./uassetapi.exporttypes.stringtableexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Table**

```csharp
public FStringTable Table;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **StringTableExport(Export)**

```csharp
public StringTableExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **StringTableExport(FStringTable, UAsset, Byte[])**

```csharp
public StringTableExport(FStringTable data, UAsset asset, Byte[] extras)
```

#### Parameters

`data` [FStringTable](./uassetapi.exporttypes.fstringtable.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **StringTableExport()**

```csharp
public StringTableExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.structexport.md`:

```md
# StructExport

Namespace: UAssetAPI.ExportTypes

Base export for all UObject types that contain fields.

```csharp
public class StructExport : FieldExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [FieldExport](./uassetapi.exporttypes.fieldexport.md) → [StructExport](./uassetapi.exporttypes.structexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **SuperStruct**

Struct this inherits from, may be null

```csharp
public FPackageIndex SuperStruct;
```

### **Children**

List of child fields

```csharp
public FPackageIndex[] Children;
```

### **LoadedProperties**

Properties serialized with this struct definition

```csharp
public FProperty[] LoadedProperties;
```

### **ScriptBytecode**

The bytecode instructions contained within this struct.

```csharp
public KismetExpression[] ScriptBytecode;
```

### **ScriptBytecodeSize**

Bytecode size in total in deserialized memory. Filled out in lieu of [StructExport.ScriptBytecode](./uassetapi.exporttypes.structexport.md#scriptbytecode) if an error occurs during bytecode parsing.

```csharp
public int ScriptBytecodeSize;
```

### **ScriptBytecodeRaw**

Raw binary bytecode data. Filled out in lieu of [StructExport.ScriptBytecode](./uassetapi.exporttypes.structexport.md#scriptbytecode) if an error occurs during bytecode parsing.

```csharp
public Byte[] ScriptBytecodeRaw;
```

### **Field**

```csharp
public UField Field;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **StructExport(Export)**

```csharp
public StructExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **StructExport(UAsset, Byte[])**

```csharp
public StructExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **StructExport()**

```csharp
public StructExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.exporttypes.udatatable.md`:

```md
# UDataTable

Namespace: UAssetAPI.ExportTypes

Imported spreadsheet table.

```csharp
public class UDataTable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UDataTable](./uassetapi.exporttypes.udatatable.md)

## Fields

### **Data**

```csharp
public List<StructPropertyData> Data;
```

## Constructors

### **UDataTable()**

```csharp
public UDataTable()
```

### **UDataTable(List&lt;StructPropertyData&gt;)**

```csharp
public UDataTable(List<StructPropertyData> data)
```

#### Parameters

`data` [List&lt;StructPropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

```

`docs/src/api/uassetapi.exporttypes.uenum.md`:

```md
# UEnum

Namespace: UAssetAPI.ExportTypes

Reflection data for an enumeration.

```csharp
public class UEnum
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UEnum](./uassetapi.exporttypes.uenum.md)

## Fields

### **Names**

List of pairs of all enum names and values.

```csharp
public List<Tuple<FName, long>> Names;
```

### **CppForm**

How the enum was originally defined.

```csharp
public ECppForm CppForm;
```

## Constructors

### **UEnum()**

```csharp
public UEnum()
```

## Methods

### **Read(AssetBinaryReader, UAsset)**

```csharp
public void Read(AssetBinaryReader reader, UAsset asset)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **Write(AssetBinaryWriter, UAsset)**

```csharp
public void Write(AssetBinaryWriter writer, UAsset asset)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.exporttypes.userdefinedstructexport.md`:

```md
# UserDefinedStructExport

Namespace: UAssetAPI.ExportTypes

```csharp
public class UserDefinedStructExport : StructExport, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Export](./uassetapi.exporttypes.export.md) → [NormalExport](./uassetapi.exporttypes.normalexport.md) → [FieldExport](./uassetapi.exporttypes.fieldexport.md) → [StructExport](./uassetapi.exporttypes.structexport.md) → [UserDefinedStructExport](./uassetapi.exporttypes.userdefinedstructexport.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructFlags**

```csharp
public uint StructFlags;
```

### **StructData**

```csharp
public List<PropertyData> StructData;
```

### **SerializationControl2**

```csharp
public EClassSerializationControlExtension SerializationControl2;
```

### **Operation2**

```csharp
public EOverriddenPropertyOperation Operation2;
```

### **SuperStruct**

Struct this inherits from, may be null

```csharp
public FPackageIndex SuperStruct;
```

### **Children**

List of child fields

```csharp
public FPackageIndex[] Children;
```

### **LoadedProperties**

Properties serialized with this struct definition

```csharp
public FProperty[] LoadedProperties;
```

### **ScriptBytecode**

The bytecode instructions contained within this struct.

```csharp
public KismetExpression[] ScriptBytecode;
```

### **ScriptBytecodeSize**

Bytecode size in total in deserialized memory. Filled out in lieu of [StructExport.ScriptBytecode](./uassetapi.exporttypes.structexport.md#scriptbytecode) if an error occurs during bytecode parsing.

```csharp
public int ScriptBytecodeSize;
```

### **ScriptBytecodeRaw**

Raw binary bytecode data. Filled out in lieu of [StructExport.ScriptBytecode](./uassetapi.exporttypes.structexport.md#scriptbytecode) if an error occurs during bytecode parsing.

```csharp
public Byte[] ScriptBytecodeRaw;
```

### **Field**

```csharp
public UField Field;
```

### **Data**

```csharp
public List<PropertyData> Data;
```

### **ObjectGuid**

```csharp
public Nullable<Guid> ObjectGuid;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **HasLeadingFourNullBytes**

```csharp
public bool HasLeadingFourNullBytes;
```

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassIndex**

Location of this export's class (import/other export). 0 = this export is a UClass

```csharp
public FPackageIndex ClassIndex;
```

### **SuperIndex**

Location of this export's parent class (import/other export). 0 = this export is not derived from UStruct

```csharp
public FPackageIndex SuperIndex;
```

### **TemplateIndex**

Location of this export's template (import/other export). 0 = there is some problem

```csharp
public FPackageIndex TemplateIndex;
```

### **ObjectFlags**

The object flags for the UObject represented by this resource. Only flags that match the RF_Load combination mask will be loaded from disk and applied to the UObject.

```csharp
public EObjectFlags ObjectFlags;
```

### **SerialSize**

The number of bytes to serialize when saving/loading this export's UObject.

```csharp
public long SerialSize;
```

### **SerialOffset**

The location (into the FLinker's underlying file reader archive) of the beginning of the data for this export's UObject. Used for verification only.

```csharp
public long SerialOffset;
```

### **ScriptSerializationStartOffset**

The location (relative to SerialOffset) of the beginning of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4).

```csharp
public long ScriptSerializationStartOffset;
```

### **ScriptSerializationEndOffset**

The location (relative to SerialOffset) of the end of the portion of this export's data that is serialized using tagged property serialization.
 Serialized into packages using tagged property serialization as of [ObjectVersionUE5.SCRIPT_SERIALIZATION_OFFSET](./uassetapi.unrealtypes.objectversionue5.md#script_serialization_offset) (5.4)

```csharp
public long ScriptSerializationEndOffset;
```

### **bForcedExport**

Was this export forced into the export table via OBJECTMARK_ForceTagExp?

```csharp
public bool bForcedExport;
```

### **bNotForClient**

Should this export not be loaded on clients?

```csharp
public bool bNotForClient;
```

### **bNotForServer**

Should this export not be loaded on servers?

```csharp
public bool bNotForServer;
```

### **PackageGuid**

If this object is a top level package (which must have been forced into the export table via OBJECTMARK_ForceTagExp), this is the GUID for the original package file. Deprecated

```csharp
public Guid PackageGuid;
```

### **IsInheritedInstance**



```csharp
public bool IsInheritedInstance;
```

### **PackageFlags**

If this export is a top-level package, this is the flags for the original package

```csharp
public EPackageFlags PackageFlags;
```

### **bNotAlwaysLoadedForEditorGame**

Should this export be always loaded in editor game?

```csharp
public bool bNotAlwaysLoadedForEditorGame;
```

### **bIsAsset**

Is this export an asset?

```csharp
public bool bIsAsset;
```

### **GeneratePublicHash**



```csharp
public bool GeneratePublicHash;
```

### **SerializationBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeSerializationDependencies;
```

### **CreateBeforeSerializationDependencies**

```csharp
public List<FPackageIndex> CreateBeforeSerializationDependencies;
```

### **SerializationBeforeCreateDependencies**

```csharp
public List<FPackageIndex> SerializationBeforeCreateDependencies;
```

### **CreateBeforeCreateDependencies**

```csharp
public List<FPackageIndex> CreateBeforeCreateDependencies;
```

### **Extras**

Miscellaneous, unparsed export data, stored as a byte array.

```csharp
public Byte[] Extras;
```

### **Asset**

The asset that this export is parsed with.

```csharp
public UAsset Asset;
```

## Properties

## Constructors

### **UserDefinedStructExport(Export)**

```csharp
public UserDefinedStructExport(Export super)
```

#### Parameters

`super` [Export](./uassetapi.exporttypes.export.md)<br>

### **UserDefinedStructExport(UAsset, Byte[])**

```csharp
public UserDefinedStructExport(UAsset asset, Byte[] extras)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`extras` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **UserDefinedStructExport()**

```csharp
public UserDefinedStructExport()
```

## Methods

### **Read(AssetBinaryReader, Int32)**

```csharp
public void Read(AssetBinaryReader reader, int nextStarting)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`nextStarting` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fengineversion.md`:

```md
# FEngineVersion

Namespace: UAssetAPI

Holds basic Unreal version numbers.

```csharp
public struct FEngineVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FEngineVersion](./uassetapi.fengineversion.md)

## Fields

### **Major**

Major version number.

```csharp
public ushort Major;
```

### **Minor**

Minor version number.

```csharp
public ushort Minor;
```

### **Patch**

Patch version number.

```csharp
public ushort Patch;
```

### **Changelist**

Changelist number. This is used by the engine to arbitrate when Major/Minor/Patch version numbers match.

```csharp
public uint Changelist;
```

### **Branch**

Branch name.

```csharp
public FString Branch;
```

## Constructors

### **FEngineVersion(UnrealBinaryReader)**

```csharp
FEngineVersion(UnrealBinaryReader reader)
```

#### Parameters

`reader` [UnrealBinaryReader](./uassetapi.unrealbinaryreader.md)<br>

### **FEngineVersion(UInt16, UInt16, UInt16, UInt32, FString)**

```csharp
FEngineVersion(ushort major, ushort minor, ushort patch, uint changelist, FString branch)
```

#### Parameters

`major` [UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

`minor` [UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

`patch` [UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

`changelist` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`branch` [FString](./uassetapi.unrealtypes.fstring.md)<br>

## Methods

### **Write(UnrealBinaryWriter)**

```csharp
void Write(UnrealBinaryWriter writer)
```

#### Parameters

`writer` [UnrealBinaryWriter](./uassetapi.unrealbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fgenerationinfo.md`:

```md
# FGenerationInfo

Namespace: UAssetAPI

Revision data for an Unreal package file.

```csharp
public class FGenerationInfo
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FGenerationInfo](./uassetapi.fgenerationinfo.md)

## Fields

### **ExportCount**

Number of exports in the export map for this generation.

```csharp
public int ExportCount;
```

### **NameCount**

Number of names in the name map for this generation.

```csharp
public int NameCount;
```

## Constructors

### **FGenerationInfo(Int32, Int32)**

```csharp
public FGenerationInfo(int exportCount, int nameCount)
```

#### Parameters

`exportCount` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`nameCount` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.fieldtypes.earraydim.md`:

```md
# EArrayDim

Namespace: UAssetAPI.FieldTypes

The type of array that this property represents. This is represented an integer in the engine.

```csharp
public enum EArrayDim
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EArrayDim](./uassetapi.fieldtypes.earraydim.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.fieldtypes.elifetimecondition.md`:

```md
# ELifetimeCondition

Namespace: UAssetAPI.FieldTypes

Secondary condition to check before considering the replication of a lifetime property.

```csharp
public enum ELifetimeCondition
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELifetimeCondition](./uassetapi.fieldtypes.elifetimecondition.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| COND_None | 0 | This property has no condition, and will send anytime it changes |
| COND_InitialOnly | 1 | This property will only attempt to send on the initial bunch |
| COND_OwnerOnly | 2 | This property will only send to the actor's owner |
| COND_SkipOwner | 3 | This property send to every connection EXCEPT the owner |
| COND_SimulatedOnly | 4 | This property will only send to simulated actors |
| COND_AutonomousOnly | 5 | This property will only send to autonomous actors |
| COND_SimulatedOrPhysics | 6 | This property will send to simulated OR bRepPhysics actors |
| COND_InitialOrOwner | 7 | This property will send on the initial packet, or to the actors owner |
| COND_Custom | 8 | This property has no particular condition, but wants the ability to toggle on/off via SetCustomIsActiveOverride |
| COND_ReplayOrOwner | 9 | This property will only send to the replay connection, or to the actors owner |
| COND_ReplayOnly | 10 | This property will only send to the replay connection |
| COND_SimulatedOnlyNoReplay | 11 | This property will send to actors only, but not to replay connections |
| COND_SimulatedOrPhysicsNoReplay | 12 | This property will send to simulated Or bRepPhysics actors, but not to replay connections |
| COND_SkipReplay | 13 | This property will not send to the replay connection |
| COND_Never | 15 | This property will never be replicated |

```

`docs/src/api/uassetapi.fieldtypes.farrayproperty.md`:

```md
# FArrayProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FArrayProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FArrayProperty](./uassetapi.fieldtypes.farrayproperty.md)

## Fields

### **Inner**

```csharp
public FProperty Inner;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FArrayProperty()**

```csharp
public FArrayProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fboolproperty.md`:

```md
# FBoolProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FBoolProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FBoolProperty](./uassetapi.fieldtypes.fboolproperty.md)

## Fields

### **FieldSize**

Size of the bitfield/bool property. Equal to ElementSize but used to check if the property has been properly initialized (0-8, where 0 means uninitialized).

```csharp
public byte FieldSize;
```

### **ByteOffset**

Offset from the memeber variable to the byte of the property (0-7).

```csharp
public byte ByteOffset;
```

### **ByteMask**

Mask of the byte with the property value.

```csharp
public byte ByteMask;
```

### **FieldMask**

Mask of the field with the property value. Either equal to ByteMask or 255 in case of 'bool' type.

```csharp
public byte FieldMask;
```

### **NativeBool**

```csharp
public bool NativeBool;
```

### **Value**

```csharp
public bool Value;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FBoolProperty()**

```csharp
public FBoolProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fbyteproperty.md`:

```md
# FByteProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FByteProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FByteProperty](./uassetapi.fieldtypes.fbyteproperty.md)

## Fields

### **Enum**

A pointer to the UEnum represented by this property

```csharp
public FPackageIndex Enum;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FByteProperty()**

```csharp
public FByteProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fclassproperty.md`:

```md
# FClassProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FClassProperty : FObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FObjectProperty](./uassetapi.fieldtypes.fobjectproperty.md) → [FClassProperty](./uassetapi.fieldtypes.fclassproperty.md)

## Fields

### **MetaClass**

```csharp
public FPackageIndex MetaClass;
```

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FClassProperty()**

```csharp
public FClassProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fdelegateproperty.md`:

```md
# FDelegateProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FDelegateProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FDelegateProperty](./uassetapi.fieldtypes.fdelegateproperty.md)

## Fields

### **SignatureFunction**

```csharp
public FPackageIndex SignatureFunction;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FDelegateProperty()**

```csharp
public FDelegateProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fenumproperty.md`:

```md
# FEnumProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FEnumProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FEnumProperty](./uassetapi.fieldtypes.fenumproperty.md)

## Fields

### **Enum**

A pointer to the UEnum represented by this property

```csharp
public FPackageIndex Enum;
```

### **UnderlyingProp**

The FNumericProperty which represents the underlying type of the enum

```csharp
public FProperty UnderlyingProp;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FEnumProperty()**

```csharp
public FEnumProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.ffield.md`:

```md
# FField

Namespace: UAssetAPI.FieldTypes

Base class of reflection data objects.

```csharp
public class FField
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md)

## Fields

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FField()**

```csharp
public FField()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fgenericproperty.md`:

```md
# FGenericProperty

Namespace: UAssetAPI.FieldTypes

This is a UAssetAPI-specific property that represents anything that we don't have special serialization for

```csharp
public class FGenericProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FGenericProperty](./uassetapi.fieldtypes.fgenericproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FGenericProperty()**

```csharp
public FGenericProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.finterfaceproperty.md`:

```md
# FInterfaceProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FInterfaceProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FInterfaceProperty](./uassetapi.fieldtypes.finterfaceproperty.md)

## Fields

### **InterfaceClass**

```csharp
public FPackageIndex InterfaceClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FInterfaceProperty()**

```csharp
public FInterfaceProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fmapproperty.md`:

```md
# FMapProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FMapProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FMapProperty](./uassetapi.fieldtypes.fmapproperty.md)

## Fields

### **KeyProp**

```csharp
public FProperty KeyProp;
```

### **ValueProp**

```csharp
public FProperty ValueProp;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FMapProperty()**

```csharp
public FMapProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fmulticastdelegateproperty.md`:

```md
# FMulticastDelegateProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FMulticastDelegateProperty : FDelegateProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FDelegateProperty](./uassetapi.fieldtypes.fdelegateproperty.md) → [FMulticastDelegateProperty](./uassetapi.fieldtypes.fmulticastdelegateproperty.md)

## Fields

### **SignatureFunction**

```csharp
public FPackageIndex SignatureFunction;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FMulticastDelegateProperty()**

```csharp
public FMulticastDelegateProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.fmulticastinlinedelegateproperty.md`:

```md
# FMulticastInlineDelegateProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FMulticastInlineDelegateProperty : FMulticastDelegateProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FDelegateProperty](./uassetapi.fieldtypes.fdelegateproperty.md) → [FMulticastDelegateProperty](./uassetapi.fieldtypes.fmulticastdelegateproperty.md) → [FMulticastInlineDelegateProperty](./uassetapi.fieldtypes.fmulticastinlinedelegateproperty.md)

## Fields

### **SignatureFunction**

```csharp
public FPackageIndex SignatureFunction;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FMulticastInlineDelegateProperty()**

```csharp
public FMulticastInlineDelegateProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.fnumericproperty.md`:

```md
# FNumericProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FNumericProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FNumericProperty](./uassetapi.fieldtypes.fnumericproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FNumericProperty()**

```csharp
public FNumericProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fobjectproperty.md`:

```md
# FObjectProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FObjectProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FObjectProperty](./uassetapi.fieldtypes.fobjectproperty.md)

## Fields

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FObjectProperty()**

```csharp
public FObjectProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.foptionalproperty.md`:

```md
# FOptionalProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FOptionalProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FOptionalProperty](./uassetapi.fieldtypes.foptionalproperty.md)

## Fields

### **ValueProperty**

```csharp
public FProperty ValueProperty;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FOptionalProperty()**

```csharp
public FOptionalProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fproperty.md`:

```md
# FProperty

Namespace: UAssetAPI.FieldTypes

An UnrealScript variable.

```csharp
public abstract class FProperty : FField
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FProperty()**

```csharp
public FProperty()
```

## Methods

### **SetObject(Object)**

```csharp
public void SetObject(object value)
```

#### Parameters

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **GetObject&lt;T&gt;()**

```csharp
public T GetObject<T>()
```

#### Type Parameters

`T`<br>

#### Returns

T<br>

### **GetUsmapPropertyType()**

```csharp
public EPropertyType GetUsmapPropertyType()
```

#### Returns

[EPropertyType](./uassetapi.unversioned.epropertytype.md)<br>

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fsetproperty.md`:

```md
# FSetProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FSetProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FSetProperty](./uassetapi.fieldtypes.fsetproperty.md)

## Fields

### **ElementProp**

```csharp
public FProperty ElementProp;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FSetProperty()**

```csharp
public FSetProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fsoftclassproperty.md`:

```md
# FSoftClassProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FSoftClassProperty : FObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FObjectProperty](./uassetapi.fieldtypes.fobjectproperty.md) → [FSoftClassProperty](./uassetapi.fieldtypes.fsoftclassproperty.md)

## Fields

### **MetaClass**

```csharp
public FPackageIndex MetaClass;
```

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FSoftClassProperty()**

```csharp
public FSoftClassProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fsoftobjectproperty.md`:

```md
# FSoftObjectProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FSoftObjectProperty : FObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FObjectProperty](./uassetapi.fieldtypes.fobjectproperty.md) → [FSoftObjectProperty](./uassetapi.fieldtypes.fsoftobjectproperty.md)

## Fields

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FSoftObjectProperty()**

```csharp
public FSoftObjectProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.fstructproperty.md`:

```md
# FStructProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FStructProperty : FProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FStructProperty](./uassetapi.fieldtypes.fstructproperty.md)

## Fields

### **Struct**

```csharp
public FPackageIndex Struct;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FStructProperty()**

```csharp
public FStructProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.fweakobjectproperty.md`:

```md
# FWeakObjectProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class FWeakObjectProperty : FObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FField](./uassetapi.fieldtypes.ffield.md) → [FProperty](./uassetapi.fieldtypes.fproperty.md) → [FObjectProperty](./uassetapi.fieldtypes.fobjectproperty.md) → [FWeakObjectProperty](./uassetapi.fieldtypes.fweakobjectproperty.md)

## Fields

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepIndex**

```csharp
public ushort RepIndex;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **UsmapPropertyTypeOverrides**

```csharp
public IDictionary<string, EPropertyType> UsmapPropertyTypeOverrides;
```

### **SerializedType**

```csharp
public FName SerializedType;
```

### **Name**

```csharp
public FName Name;
```

### **Flags**

```csharp
public EObjectFlags Flags;
```

### **MetaDataMap**

```csharp
public TMap<FName, FString> MetaDataMap;
```

## Constructors

### **FWeakObjectProperty()**

```csharp
public FWeakObjectProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.uarrayproperty.md`:

```md
# UArrayProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UArrayProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UArrayProperty](./uassetapi.fieldtypes.uarrayproperty.md)

## Fields

### **Inner**

```csharp
public FPackageIndex Inner;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UArrayProperty()**

```csharp
public UArrayProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.uassetclassproperty.md`:

```md
# UAssetClassProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UAssetClassProperty : UObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UObjectProperty](./uassetapi.fieldtypes.uobjectproperty.md) → [UAssetClassProperty](./uassetapi.fieldtypes.uassetclassproperty.md)

## Fields

### **MetaClass**

```csharp
public FPackageIndex MetaClass;
```

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UAssetClassProperty()**

```csharp
public UAssetClassProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.uassetobjectproperty.md`:

```md
# UAssetObjectProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UAssetObjectProperty : UObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UObjectProperty](./uassetapi.fieldtypes.uobjectproperty.md) → [UAssetObjectProperty](./uassetapi.fieldtypes.uassetobjectproperty.md)

## Fields

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UAssetObjectProperty()**

```csharp
public UAssetObjectProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.uboolproperty.md`:

```md
# UBoolProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UBoolProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UBoolProperty](./uassetapi.fieldtypes.uboolproperty.md)

## Fields

### **NativeBool**

```csharp
public bool NativeBool;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UBoolProperty()**

```csharp
public UBoolProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.ubyteproperty.md`:

```md
# UByteProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UByteProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UByteProperty](./uassetapi.fieldtypes.ubyteproperty.md)

## Fields

### **Enum**

A pointer to the UEnum represented by this property

```csharp
public FPackageIndex Enum;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UByteProperty()**

```csharp
public UByteProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.uclassproperty.md`:

```md
# UClassProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UClassProperty : UObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UObjectProperty](./uassetapi.fieldtypes.uobjectproperty.md) → [UClassProperty](./uassetapi.fieldtypes.uclassproperty.md)

## Fields

### **MetaClass**

```csharp
public FPackageIndex MetaClass;
```

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UClassProperty()**

```csharp
public UClassProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.udelegateproperty.md`:

```md
# UDelegateProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UDelegateProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UDelegateProperty](./uassetapi.fieldtypes.udelegateproperty.md)

## Fields

### **SignatureFunction**

```csharp
public FPackageIndex SignatureFunction;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UDelegateProperty()**

```csharp
public UDelegateProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.udoubleproperty.md`:

```md
# UDoubleProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UDoubleProperty : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UDoubleProperty](./uassetapi.fieldtypes.udoubleproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UDoubleProperty()**

```csharp
public UDoubleProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.uenumproperty.md`:

```md
# UEnumProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UEnumProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UEnumProperty](./uassetapi.fieldtypes.uenumproperty.md)

## Fields

### **Enum**

A pointer to the UEnum represented by this property

```csharp
public FPackageIndex Enum;
```

### **UnderlyingProp**

The FNumericProperty which represents the underlying type of the enum

```csharp
public FPackageIndex UnderlyingProp;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UEnumProperty()**

```csharp
public UEnumProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.ufield.md`:

```md
# UField

Namespace: UAssetAPI.FieldTypes

Base class of reflection data objects.

```csharp
public class UField
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md)

## Fields

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UField()**

```csharp
public UField()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.ufloatproperty.md`:

```md
# UFloatProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UFloatProperty : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UFloatProperty](./uassetapi.fieldtypes.ufloatproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UFloatProperty()**

```csharp
public UFloatProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.ugenericproperty.md`:

```md
# UGenericProperty

Namespace: UAssetAPI.FieldTypes

This is a UAssetAPI-specific property that represents anything that we don't have special serialization for

```csharp
public class UGenericProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UGenericProperty](./uassetapi.fieldtypes.ugenericproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UGenericProperty()**

```csharp
public UGenericProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.uint16property.md`:

```md
# UInt16Property

Namespace: UAssetAPI.FieldTypes

```csharp
public class UInt16Property : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UInt16Property](./uassetapi.fieldtypes.uint16property.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UInt16Property()**

```csharp
public UInt16Property()
```

```

`docs/src/api/uassetapi.fieldtypes.uint64property.md`:

```md
# UInt64Property

Namespace: UAssetAPI.FieldTypes

```csharp
public class UInt64Property : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UInt64Property](./uassetapi.fieldtypes.uint64property.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UInt64Property()**

```csharp
public UInt64Property()
```

```

`docs/src/api/uassetapi.fieldtypes.uint8property.md`:

```md
# UInt8Property

Namespace: UAssetAPI.FieldTypes

```csharp
public class UInt8Property : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UInt8Property](./uassetapi.fieldtypes.uint8property.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UInt8Property()**

```csharp
public UInt8Property()
```

```

`docs/src/api/uassetapi.fieldtypes.uinterfaceproperty.md`:

```md
# UInterfaceProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UInterfaceProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UInterfaceProperty](./uassetapi.fieldtypes.uinterfaceproperty.md)

## Fields

### **InterfaceClass**

```csharp
public FPackageIndex InterfaceClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UInterfaceProperty()**

```csharp
public UInterfaceProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.uintproperty.md`:

```md
# UIntProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UIntProperty : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UIntProperty](./uassetapi.fieldtypes.uintproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UIntProperty()**

```csharp
public UIntProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.ulazyobjectproperty.md`:

```md
# ULazyObjectProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class ULazyObjectProperty : UObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UObjectProperty](./uassetapi.fieldtypes.uobjectproperty.md) → [ULazyObjectProperty](./uassetapi.fieldtypes.ulazyobjectproperty.md)

## Fields

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **ULazyObjectProperty()**

```csharp
public ULazyObjectProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.umapproperty.md`:

```md
# UMapProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UMapProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UMapProperty](./uassetapi.fieldtypes.umapproperty.md)

## Fields

### **KeyProp**

```csharp
public FPackageIndex KeyProp;
```

### **ValueProp**

```csharp
public FPackageIndex ValueProp;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UMapProperty()**

```csharp
public UMapProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.umulticastdelegateproperty.md`:

```md
# UMulticastDelegateProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UMulticastDelegateProperty : UDelegateProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UDelegateProperty](./uassetapi.fieldtypes.udelegateproperty.md) → [UMulticastDelegateProperty](./uassetapi.fieldtypes.umulticastdelegateproperty.md)

## Fields

### **SignatureFunction**

```csharp
public FPackageIndex SignatureFunction;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UMulticastDelegateProperty()**

```csharp
public UMulticastDelegateProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.umulticastinlinedelegateproperty.md`:

```md
# UMulticastInlineDelegateProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UMulticastInlineDelegateProperty : UMulticastDelegateProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UDelegateProperty](./uassetapi.fieldtypes.udelegateproperty.md) → [UMulticastDelegateProperty](./uassetapi.fieldtypes.umulticastdelegateproperty.md) → [UMulticastInlineDelegateProperty](./uassetapi.fieldtypes.umulticastinlinedelegateproperty.md)

## Fields

### **SignatureFunction**

```csharp
public FPackageIndex SignatureFunction;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UMulticastInlineDelegateProperty()**

```csharp
public UMulticastInlineDelegateProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.umulticastsparsedelegateproperty.md`:

```md
# UMulticastSparseDelegateProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UMulticastSparseDelegateProperty : UMulticastDelegateProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UDelegateProperty](./uassetapi.fieldtypes.udelegateproperty.md) → [UMulticastDelegateProperty](./uassetapi.fieldtypes.umulticastdelegateproperty.md) → [UMulticastSparseDelegateProperty](./uassetapi.fieldtypes.umulticastsparsedelegateproperty.md)

## Fields

### **SignatureFunction**

```csharp
public FPackageIndex SignatureFunction;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UMulticastSparseDelegateProperty()**

```csharp
public UMulticastSparseDelegateProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.unameproperty.md`:

```md
# UNameProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UNameProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNameProperty](./uassetapi.fieldtypes.unameproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UNameProperty()**

```csharp
public UNameProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.unumericproperty.md`:

```md
# UNumericProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UNumericProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UNumericProperty()**

```csharp
public UNumericProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.uobjectproperty.md`:

```md
# UObjectProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UObjectProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UObjectProperty](./uassetapi.fieldtypes.uobjectproperty.md)

## Fields

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UObjectProperty()**

```csharp
public UObjectProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.uproperty.md`:

```md
# UProperty

Namespace: UAssetAPI.FieldTypes

An UnrealScript variable.

```csharp
public abstract class UProperty : UField
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UProperty()**

```csharp
public UProperty()
```

## Methods

### **SetObject(Object)**

```csharp
public void SetObject(object value)
```

#### Parameters

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **GetObject&lt;T&gt;()**

```csharp
public T GetObject<T>()
```

#### Type Parameters

`T`<br>

#### Returns

T<br>

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

### **GetUsmapPropertyType()**

```csharp
public EPropertyType GetUsmapPropertyType()
```

#### Returns

[EPropertyType](./uassetapi.unversioned.epropertytype.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.usetproperty.md`:

```md
# USetProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class USetProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [USetProperty](./uassetapi.fieldtypes.usetproperty.md)

## Fields

### **ElementProp**

```csharp
public FPackageIndex ElementProp;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **USetProperty()**

```csharp
public USetProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.usoftclassproperty.md`:

```md
# USoftClassProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class USoftClassProperty : UObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UObjectProperty](./uassetapi.fieldtypes.uobjectproperty.md) → [USoftClassProperty](./uassetapi.fieldtypes.usoftclassproperty.md)

## Fields

### **MetaClass**

```csharp
public FPackageIndex MetaClass;
```

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **USoftClassProperty()**

```csharp
public USoftClassProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.usoftobjectproperty.md`:

```md
# USoftObjectProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class USoftObjectProperty : UObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UObjectProperty](./uassetapi.fieldtypes.uobjectproperty.md) → [USoftObjectProperty](./uassetapi.fieldtypes.usoftobjectproperty.md)

## Fields

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **USoftObjectProperty()**

```csharp
public USoftObjectProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.ustrproperty.md`:

```md
# UStrProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UStrProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UStrProperty](./uassetapi.fieldtypes.ustrproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UStrProperty()**

```csharp
public UStrProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.ustructproperty.md`:

```md
# UStructProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UStructProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UStructProperty](./uassetapi.fieldtypes.ustructproperty.md)

## Fields

### **Struct**

```csharp
public FPackageIndex Struct;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UStructProperty()**

```csharp
public UStructProperty()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.fieldtypes.utextproperty.md`:

```md
# UTextProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UTextProperty : UProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UTextProperty](./uassetapi.fieldtypes.utextproperty.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UTextProperty()**

```csharp
public UTextProperty()
```

```

`docs/src/api/uassetapi.fieldtypes.uuint16property.md`:

```md
# UUInt16Property

Namespace: UAssetAPI.FieldTypes

```csharp
public class UUInt16Property : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UUInt16Property](./uassetapi.fieldtypes.uuint16property.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UUInt16Property()**

```csharp
public UUInt16Property()
```

```

`docs/src/api/uassetapi.fieldtypes.uuint32property.md`:

```md
# UUInt32Property

Namespace: UAssetAPI.FieldTypes

```csharp
public class UUInt32Property : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UUInt32Property](./uassetapi.fieldtypes.uuint32property.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UUInt32Property()**

```csharp
public UUInt32Property()
```

```

`docs/src/api/uassetapi.fieldtypes.uuint64property.md`:

```md
# UUInt64Property

Namespace: UAssetAPI.FieldTypes

```csharp
public class UUInt64Property : UNumericProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UNumericProperty](./uassetapi.fieldtypes.unumericproperty.md) → [UUInt64Property](./uassetapi.fieldtypes.uuint64property.md)

## Fields

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UUInt64Property()**

```csharp
public UUInt64Property()
```

```

`docs/src/api/uassetapi.fieldtypes.uweakobjectproperty.md`:

```md
# UWeakObjectProperty

Namespace: UAssetAPI.FieldTypes

```csharp
public class UWeakObjectProperty : UObjectProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UField](./uassetapi.fieldtypes.ufield.md) → [UProperty](./uassetapi.fieldtypes.uproperty.md) → [UObjectProperty](./uassetapi.fieldtypes.uobjectproperty.md) → [UWeakObjectProperty](./uassetapi.fieldtypes.uweakobjectproperty.md)

## Fields

### **PropertyClass**

```csharp
public FPackageIndex PropertyClass;
```

### **ArrayDim**

```csharp
public EArrayDim ArrayDim;
```

### **ElementSize**

```csharp
public int ElementSize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **RepNotifyFunc**

```csharp
public FName RepNotifyFunc;
```

### **BlueprintReplicationCondition**

```csharp
public ELifetimeCondition BlueprintReplicationCondition;
```

### **RawValue**

```csharp
public object RawValue;
```

### **Next**

Next Field in the linked list. Removed entirely in the custom version FFrameworkObjectVersion::RemoveUField_Next in favor of a regular array

```csharp
public FPackageIndex Next;
```

## Constructors

### **UWeakObjectProperty()**

```csharp
public UWeakObjectProperty()
```

```

`docs/src/api/uassetapi.import.md`:

```md
# Import

Namespace: UAssetAPI

UObject resource type for objects that are referenced by this package, but contained within another package.

```csharp
public class Import
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Import](./uassetapi.import.md)

## Fields

### **ObjectName**

The name of the UObject represented by this resource.

```csharp
public FName ObjectName;
```

### **OuterIndex**

Location of the resource for this resource's Outer (import/other export). 0 = this resource is a top-level UPackage

```csharp
public FPackageIndex OuterIndex;
```

### **ClassPackage**

```csharp
public FName ClassPackage;
```

### **ClassName**

```csharp
public FName ClassName;
```

### **PackageName**

Package Name this import belongs to. Can be none, in that case follow the outer chain
 until a set PackageName is found or until OuterIndex is null

```csharp
public FName PackageName;
```

### **bImportOptional**

```csharp
public bool bImportOptional;
```

## Constructors

### **Import(String, String, FPackageIndex, String, Boolean, UAsset)**

```csharp
public Import(string classPackage, string className, FPackageIndex outerIndex, string objectName, bool importOptional, UAsset asset)
```

#### Parameters

`classPackage` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`className` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`outerIndex` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

`objectName` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`importOptional` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **Import(FName, FName, FPackageIndex, FName, Boolean)**

```csharp
public Import(FName classPackage, FName className, FPackageIndex outerIndex, FName objectName, bool importOptional)
```

#### Parameters

`classPackage` [FName](./uassetapi.unrealtypes.fname.md)<br>

`className` [FName](./uassetapi.unrealtypes.fname.md)<br>

`outerIndex` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

`objectName` [FName](./uassetapi.unrealtypes.fname.md)<br>

`importOptional` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Import(AssetBinaryReader)**

```csharp
public Import(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Import()**

```csharp
public Import()
```

```

`docs/src/api/uassetapi.inamemap.md`:

```md
# INameMap

Namespace: UAssetAPI

```csharp
public interface INameMap
```

## Methods

### **GetNameMapIndexList()**

```csharp
IReadOnlyList<FString> GetNameMapIndexList()
```

#### Returns

[IReadOnlyList&lt;FString&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1)<br>

### **ClearNameIndexList()**

```csharp
void ClearNameIndexList()
```

### **SetNameReference(Int32, FString)**

```csharp
void SetNameReference(int index, FString value)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`value` [FString](./uassetapi.unrealtypes.fstring.md)<br>

### **GetNameReference(Int32)**

```csharp
FString GetNameReference(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **ContainsNameReference(FString)**

```csharp
bool ContainsNameReference(FString search)
```

#### Parameters

`search` [FString](./uassetapi.unrealtypes.fstring.md)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **SearchNameReference(FString)**

```csharp
int SearchNameReference(FString search)
```

#### Parameters

`search` [FString](./uassetapi.unrealtypes.fstring.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **AddNameReference(FString, Boolean, Boolean)**

```csharp
int AddNameReference(FString name, bool forceAddDuplicates, bool skipFixes)
```

#### Parameters

`name` [FString](./uassetapi.unrealtypes.fstring.md)<br>

`forceAddDuplicates` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`skipFixes` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **CanCreateDummies()**

```csharp
bool CanCreateDummies()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

```

`docs/src/api/uassetapi.invalidmappingsexception.md`:

```md
# InvalidMappingsException

Namespace: UAssetAPI

```csharp
public class InvalidMappingsException : System.InvalidOperationException, System.Runtime.Serialization.ISerializable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Exception](https://docs.microsoft.com/en-us/dotnet/api/system.exception) → [SystemException](https://docs.microsoft.com/en-us/dotnet/api/system.systemexception) → [InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception) → [InvalidMappingsException](./uassetapi.invalidmappingsexception.md)<br>
Implements [ISerializable](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.iserializable)

## Properties

### **TargetSite**

```csharp
public MethodBase TargetSite { get; }
```

#### Property Value

[MethodBase](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase)<br>

### **Message**

```csharp
public string Message { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Data**

```csharp
public IDictionary Data { get; }
```

#### Property Value

[IDictionary](https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary)<br>

### **InnerException**

```csharp
public Exception InnerException { get; }
```

#### Property Value

[Exception](https://docs.microsoft.com/en-us/dotnet/api/system.exception)<br>

### **HelpLink**

```csharp
public string HelpLink { get; set; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Source**

```csharp
public string Source { get; set; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **HResult**

```csharp
public int HResult { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **StackTrace**

```csharp
public string StackTrace { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **InvalidMappingsException(String)**

```csharp
public InvalidMappingsException(string message)
```

#### Parameters

`message` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.json.bytearrayjsonconverter.md`:

```md
# ByteArrayJsonConverter

Namespace: UAssetAPI.JSON

```csharp
public class ByteArrayJsonConverter : Newtonsoft.Json.JsonConverter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → [ByteArrayJsonConverter](./uassetapi.json.bytearrayjsonconverter.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **ByteArrayJsonConverter()**

```csharp
public ByteArrayJsonConverter()
```

## Methods

### **CanConvert(Type)**

```csharp
public bool CanConvert(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteJson(JsonWriter, Object, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, Object, JsonSerializer)**

```csharp
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.json.fnamejsonconverter.md`:

```md
# FNameJsonConverter

Namespace: UAssetAPI.JSON

```csharp
public class FNameJsonConverter : Newtonsoft.Json.JsonConverter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → [FNameJsonConverter](./uassetapi.json.fnamejsonconverter.md)

## Fields

### **ToBeFilled**

```csharp
public Dictionary<FName, string> ToBeFilled;
```

### **currentI**

```csharp
public int currentI;
```

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FNameJsonConverter(Dictionary&lt;FName, String&gt;)**

```csharp
public FNameJsonConverter(Dictionary<FName, string> dict)
```

#### Parameters

`dict` [Dictionary&lt;FName, String&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2)<br>

## Methods

### **CanConvert(Type)**

```csharp
public bool CanConvert(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteJson(JsonWriter, Object, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, Object, JsonSerializer)**

```csharp
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.json.fpackageindexjsonconverter.md`:

```md
# FPackageIndexJsonConverter

Namespace: UAssetAPI.JSON

```csharp
public class FPackageIndexJsonConverter : Newtonsoft.Json.JsonConverter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → [FPackageIndexJsonConverter](./uassetapi.json.fpackageindexjsonconverter.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FPackageIndexJsonConverter()**

```csharp
public FPackageIndexJsonConverter()
```

## Methods

### **CanConvert(Type)**

```csharp
public bool CanConvert(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteJson(JsonWriter, Object, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, Object, JsonSerializer)**

```csharp
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.json.fsignedzerojsonconverter.md`:

```md
# FSignedZeroJsonConverter

Namespace: UAssetAPI.JSON

```csharp
public class FSignedZeroJsonConverter : Newtonsoft.Json.JsonConverter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → [FSignedZeroJsonConverter](./uassetapi.json.fsignedzerojsonconverter.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FSignedZeroJsonConverter()**

```csharp
public FSignedZeroJsonConverter()
```

## Methods

### **CanConvert(Type)**

```csharp
public bool CanConvert(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteJson(JsonWriter, Object, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, Object, JsonSerializer)**

```csharp
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.json.fstringjsonconverter.md`:

```md
# FStringJsonConverter

Namespace: UAssetAPI.JSON

```csharp
public class FStringJsonConverter : Newtonsoft.Json.JsonConverter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → [FStringJsonConverter](./uassetapi.json.fstringjsonconverter.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FStringJsonConverter()**

```csharp
public FStringJsonConverter()
```

## Methods

### **CanConvert(Type)**

```csharp
public bool CanConvert(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteJson(JsonWriter, Object, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, Object, JsonSerializer)**

```csharp
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.json.fstringtablejsonconverter.md`:

```md
# FStringTableJsonConverter

Namespace: UAssetAPI.JSON

```csharp
public class FStringTableJsonConverter : Newtonsoft.Json.JsonConverter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → [FStringTableJsonConverter](./uassetapi.json.fstringtablejsonconverter.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FStringTableJsonConverter()**

```csharp
public FStringTableJsonConverter()
```

## Methods

### **CanConvert(Type)**

```csharp
public bool CanConvert(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteJson(JsonWriter, Object, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, Object, JsonSerializer)**

```csharp
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.json.guidjsonconverter.md`:

```md
# GuidJsonConverter

Namespace: UAssetAPI.JSON

```csharp
public class GuidJsonConverter : Newtonsoft.Json.JsonConverter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → [GuidJsonConverter](./uassetapi.json.guidjsonconverter.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **GuidJsonConverter()**

```csharp
public GuidJsonConverter()
```

## Methods

### **CanConvert(Type)**

```csharp
public bool CanConvert(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteJson(JsonWriter, Object, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, Object, JsonSerializer)**

```csharp
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.json.tmapjsonconverter-2.md`:

```md
# TMapJsonConverter&lt;TKey, TValue&gt;

Namespace: UAssetAPI.JSON

```csharp
public class TMapJsonConverter<TKey, TValue> : Newtonsoft.Json.JsonConverter
```

#### Type Parameters

`TKey`<br>

`TValue`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → [TMapJsonConverter&lt;TKey, TValue&gt;](./uassetapi.json.tmapjsonconverter-2.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **TMapJsonConverter()**

```csharp
public TMapJsonConverter()
```

## Methods

### **CanConvert(Type)**

```csharp
public bool CanConvert(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteJson(JsonWriter, Object, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, Object, JsonSerializer)**

```csharp
public object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`serializer` JsonSerializer<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.json.uassetcontractresolver.md`:

```md
# UAssetContractResolver

Namespace: UAssetAPI.JSON

```csharp
public class UAssetContractResolver : Newtonsoft.Json.Serialization.DefaultContractResolver, Newtonsoft.Json.Serialization.IContractResolver
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → DefaultContractResolver → [UAssetContractResolver](./uassetapi.json.uassetcontractresolver.md)<br>
Implements IContractResolver

## Fields

### **ToBeFilled**

```csharp
public Dictionary<FName, string> ToBeFilled;
```

## Properties

### **DynamicCodeGeneration**

```csharp
public bool DynamicCodeGeneration { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultMembersSearchFlags**

#### Caution

DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.

---

```csharp
public BindingFlags DefaultMembersSearchFlags { get; set; }
```

#### Property Value

[BindingFlags](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.bindingflags)<br>

### **SerializeCompilerGeneratedMembers**

```csharp
public bool SerializeCompilerGeneratedMembers { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IgnoreSerializableInterface**

```csharp
public bool IgnoreSerializableInterface { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IgnoreSerializableAttribute**

```csharp
public bool IgnoreSerializableAttribute { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IgnoreIsSpecifiedMembers**

```csharp
public bool IgnoreIsSpecifiedMembers { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IgnoreShouldSerializeMembers**

```csharp
public bool IgnoreShouldSerializeMembers { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **NamingStrategy**

```csharp
public NamingStrategy NamingStrategy { get; set; }
```

#### Property Value

NamingStrategy<br>

## Constructors

### **UAssetContractResolver(Dictionary&lt;FName, String&gt;)**

```csharp
public UAssetContractResolver(Dictionary<FName, string> toBeFilled)
```

#### Parameters

`toBeFilled` [Dictionary&lt;FName, String&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2)<br>

## Methods

### **ResolveContractConverter(Type)**

```csharp
protected JsonConverter ResolveContractConverter(Type objectType)
```

#### Parameters

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

JsonConverter<br>

```

`docs/src/api/uassetapi.kismet.bytecode.eblueprinttextliteraltype.md`:

```md
# EBlueprintTextLiteralType

Namespace: UAssetAPI.Kismet.Bytecode

Kinds of text literals

```csharp
public enum EBlueprintTextLiteralType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlueprintTextLiteralType](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| Empty | 0 | Text is an empty string. The bytecode contains no strings, and you should use FText::GetEmpty() to initialize the FText instance. |
| LocalizedText | 1 | Text is localized. The bytecode will contain three strings - source, key, and namespace - and should be loaded via FInternationalization |
| InvariantText | 2 | Text is culture invariant. The bytecode will contain one string, and you should use FText::AsCultureInvariant to initialize the FText instance. |
| LiteralString | 3 | Text is a literal FString. The bytecode will contain one string, and you should use FText::FromString to initialize the FText instance. |
| StringTableEntry | 4 | Text is from a string table. The bytecode will contain an object pointer (not used) and two strings - the table ID, and key - and should be found via FText::FromStringTable |

```

`docs/src/api/uassetapi.kismet.bytecode.ecasttoken.md`:

```md
# ECastToken

Namespace: UAssetAPI.Kismet.Bytecode

```csharp
public enum ECastToken
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECastToken](./uassetapi.kismet.bytecode.ecasttoken.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.kismet.bytecode.eexprtoken.md`:

```md
# EExprToken

Namespace: UAssetAPI.Kismet.Bytecode

Evaluatable expression item types.

```csharp
public enum EExprToken
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| EX_LocalVariable | 0 | A local variable. |
| EX_InstanceVariable | 1 | An object variable. |
| EX_DefaultVariable | 2 | Default variable for a class context. |
| EX_Return | 4 | Return from function. |
| EX_Jump | 6 | Goto a local address in code. |
| EX_JumpIfNot | 7 | Goto if not expression. |
| EX_Assert | 9 | Assertion. |
| EX_Nothing | 11 | No operation. |
| EX_NothingInt32 | 12 | No operation with an int32 argument (useful for debugging script disassembly). |
| EX_Let | 15 | Assign an arbitrary size value to a variable. |
| EX_BitFieldConst | 17 | Assign to a single bit, defined by an FProperty. |
| EX_ClassContext | 18 | Class default object context. |
| EX_MetaCast | 19 | Metaclass cast. |
| EX_LetBool | 20 | Let boolean variable. |
| EX_EndParmValue | 21 | end of default value for optional function parameter |
| EX_EndFunctionParms | 22 | End of function call parameters. |
| EX_Self | 23 | Self object. |
| EX_Skip | 24 | Skippable expression. |
| EX_Context | 25 | Call a function through an object context. |
| EX_Context_FailSilent | 26 | Call a function through an object context (can fail silently if the context is NULL; only generated for functions that don't have output or return values). |
| EX_VirtualFunction | 27 | A function call with parameters. |
| EX_FinalFunction | 28 | A prebound function call with parameters. |
| EX_IntConst | 29 | Int constant. |
| EX_FloatConst | 30 | Floating point constant. |
| EX_StringConst | 31 | String constant. |
| EX_ObjectConst | 32 | An object constant. |
| EX_NameConst | 33 | A name constant. |
| EX_RotationConst | 34 | A rotation constant. |
| EX_VectorConst | 35 | A vector constant. |
| EX_ByteConst | 36 | A byte constant. |
| EX_IntZero | 37 | Zero. |
| EX_IntOne | 38 | One. |
| EX_True | 39 | Bool True. |
| EX_False | 40 | Bool False. |
| EX_TextConst | 41 | FText constant |
| EX_NoObject | 42 | NoObject. |
| EX_TransformConst | 43 | A transform constant |
| EX_IntConstByte | 44 | Int constant that requires 1 byte. |
| EX_NoInterface | 45 | A null interface (similar to EX_NoObject, but for interfaces) |
| EX_DynamicCast | 46 | Safe dynamic class casting. |
| EX_StructConst | 47 | An arbitrary UStruct constant |
| EX_EndStructConst | 48 | End of UStruct constant |
| EX_SetArray | 49 | Set the value of arbitrary array |
| EX_PropertyConst | 51 | FProperty constant. |
| EX_UnicodeStringConst | 52 | Unicode string constant. |
| EX_Int64Const | 53 | 64-bit integer constant. |
| EX_UInt64Const | 54 | 64-bit unsigned integer constant. |
| EX_DoubleConst | 55 | Double-precision floating point constant. |
| EX_PrimitiveCast | 56 | A casting operator for primitives which reads the type as the subsequent byte |
| EX_Vector3fConst | 65 | A float vector constant. |
| EX_StructMemberContext | 66 | Context expression to address a property within a struct |
| EX_LetMulticastDelegate | 67 | Assignment to a multi-cast delegate |
| EX_LetDelegate | 68 | Assignment to a delegate |
| EX_LocalVirtualFunction | 69 | Special instructions to quickly call a virtual function that we know is going to run only locally |
| EX_LocalFinalFunction | 70 | Special instructions to quickly call a final function that we know is going to run only locally |
| EX_LocalOutVariable | 72 | local out (pass by reference) function parameter |
| EX_InstanceDelegate | 75 | const reference to a delegate or normal function object |
| EX_PushExecutionFlow | 76 | push an address on to the execution flow stack for future execution when a EX_PopExecutionFlow is executed. Execution continues on normally and doesn't change to the pushed address. |
| EX_PopExecutionFlow | 77 | continue execution at the last address previously pushed onto the execution flow stack. |
| EX_ComputedJump | 78 | Goto a local address in code, specified by an integer value. |
| EX_PopExecutionFlowIfNot | 79 | continue execution at the last address previously pushed onto the execution flow stack, if the condition is not true. |
| EX_Breakpoint | 80 | Breakpoint. Only observed in the editor, otherwise it behaves like EX_Nothing. |
| EX_InterfaceContext | 81 | Call a function through a native interface variable |
| EX_ObjToInterfaceCast | 82 | Converting an object reference to native interface variable |
| EX_EndOfScript | 83 | Last byte in script code |
| EX_CrossInterfaceCast | 84 | Converting an interface variable reference to native interface variable |
| EX_InterfaceToObjCast | 85 | Converting an interface variable reference to an object |
| EX_WireTracepoint | 90 | Trace point. Only observed in the editor, otherwise it behaves like EX_Nothing. |
| EX_SkipOffsetConst | 91 | A CodeSizeSkipOffset constant |
| EX_AddMulticastDelegate | 92 | Adds a delegate to a multicast delegate's targets |
| EX_ClearMulticastDelegate | 93 | Clears all delegates in a multicast target |
| EX_Tracepoint | 94 | Trace point. Only observed in the editor, otherwise it behaves like EX_Nothing. |
| EX_LetObj | 95 | assign to any object ref pointer |
| EX_LetWeakObjPtr | 96 | assign to a weak object pointer |
| EX_BindDelegate | 97 | bind object and name to delegate |
| EX_RemoveMulticastDelegate | 98 | Remove a delegate from a multicast delegate's targets |
| EX_CallMulticastDelegate | 99 | Call multicast delegate |
| EX_CallMath | 104 | static pure function from on local call space |
| EX_InstrumentationEvent | 106 | Instrumentation event |
| EX_ClassSparseDataVariable | 108 | Sparse data variable |
| EX_AutoRtfmTransact | 112 | AutoRTFM: run following code in a transaction |
| EX_AutoRtfmStopTransact | 113 | AutoRTFM: if in a transaction, abort or break, otherwise no operation |
| EX_AutoRtfmAbortIfNot | 114 | AutoRTFM: evaluate bool condition, abort transaction on false |

```

`docs/src/api/uassetapi.kismet.bytecode.escriptinstrumentationtype.md`:

```md
# EScriptInstrumentationType

Namespace: UAssetAPI.Kismet.Bytecode

```csharp
public enum EScriptInstrumentationType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EScriptInstrumentationType](./uassetapi.kismet.bytecode.escriptinstrumentationtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_addmulticastdelegate.md`:

```md
# EX_AddMulticastDelegate

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_AddMulticastDelegate](./uassetapi.kismet.bytecode.eexprtoken.md#ex_addmulticastdelegate) instruction.

```csharp
public class EX_AddMulticastDelegate : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_AddMulticastDelegate](./uassetapi.kismet.bytecode.expressions.ex_addmulticastdelegate.md)

## Fields

### **Delegate**

Delegate property to assign to.

```csharp
public KismetExpression Delegate;
```

### **DelegateToAdd**

Delegate to add to the MC delegate for broadcast.

```csharp
public KismetExpression DelegateToAdd;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_AddMulticastDelegate()**

```csharp
public EX_AddMulticastDelegate()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_arrayconst.md`:

```md
# EX_ArrayConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ArrayConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_arrayconst) instruction.

```csharp
public class EX_ArrayConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[UAssetAPI.Kismet.Bytecode.KismetExpression[]]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;KismetExpression[]&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_ArrayConst](./uassetapi.kismet.bytecode.expressions.ex_arrayconst.md)

## Fields

### **InnerProperty**

Pointer to this constant's inner property (FProperty*).

```csharp
public KismetPropertyPointer InnerProperty;
```

### **Elements**

Array constant entries.

```csharp
public KismetExpression[] Elements;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public KismetExpression[] Value { get; set; }
```

#### Property Value

[KismetExpression[]](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ArrayConst()**

```csharp
public EX_ArrayConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_arraygetbyref.md`:

```md
# EX_ArrayGetByRef

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ArrayGetByRef](./uassetapi.kismet.bytecode.eexprtoken.md#ex_arraygetbyref) instruction.

```csharp
public class EX_ArrayGetByRef : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_ArrayGetByRef](./uassetapi.kismet.bytecode.expressions.ex_arraygetbyref.md)

## Fields

### **ArrayVariable**

The array variable.

```csharp
public KismetExpression ArrayVariable;
```

### **ArrayIndex**

The index to access in the array.

```csharp
public KismetExpression ArrayIndex;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ArrayGetByRef()**

```csharp
public EX_ArrayGetByRef()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_assert.md`:

```md
# EX_Assert

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Assert](./uassetapi.kismet.bytecode.eexprtoken.md#ex_assert) instruction.

```csharp
public class EX_Assert : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Assert](./uassetapi.kismet.bytecode.expressions.ex_assert.md)

## Fields

### **LineNumber**

Line number.

```csharp
public ushort LineNumber;
```

### **DebugMode**

Whether or not this assertion is in debug mode.

```csharp
public bool DebugMode;
```

### **AssertExpression**

Expression to assert.

```csharp
public KismetExpression AssertExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Assert()**

```csharp
public EX_Assert()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_binddelegate.md`:

```md
# EX_BindDelegate

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_BindDelegate](./uassetapi.kismet.bytecode.eexprtoken.md#ex_binddelegate) instruction.

```csharp
public class EX_BindDelegate : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_BindDelegate](./uassetapi.kismet.bytecode.expressions.ex_binddelegate.md)

## Fields

### **FunctionName**

The name of the function assigned to the delegate.

```csharp
public FName FunctionName;
```

### **Delegate**

Delegate property to assign to.

```csharp
public KismetExpression Delegate;
```

### **ObjectTerm**

Object to bind.

```csharp
public KismetExpression ObjectTerm;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_BindDelegate()**

```csharp
public EX_BindDelegate()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_bitfieldconst.md`:

```md
# EX_BitFieldConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_BitFieldConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_bitfieldconst) instruction.
 Assigns to a single bit, defined by an FProperty.

```csharp
public class EX_BitFieldConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_BitFieldConst](./uassetapi.kismet.bytecode.expressions.ex_bitfieldconst.md)

## Fields

### **Property**

A pointer to the bit property.

```csharp
public KismetPropertyPointer Property;
```

### **Value**

The bit value.

```csharp
public byte Value;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_BitFieldConst()**

```csharp
public EX_BitFieldConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_breakpoint.md`:

```md
# EX_Breakpoint

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Breakpoint](./uassetapi.kismet.bytecode.eexprtoken.md#ex_breakpoint) instruction.

```csharp
public class EX_Breakpoint : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Breakpoint](./uassetapi.kismet.bytecode.expressions.ex_breakpoint.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Breakpoint()**

```csharp
public EX_Breakpoint()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_byteconst.md`:

```md
# EX_ByteConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ByteConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_byteconst) instruction.

```csharp
public class EX_ByteConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.Byte]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;Byte&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_ByteConst](./uassetapi.kismet.bytecode.expressions.ex_byteconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public byte Value { get; set; }
```

#### Property Value

[Byte](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ByteConst()**

```csharp
public EX_ByteConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_callmath.md`:

```md
# EX_CallMath

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_CallMath](./uassetapi.kismet.bytecode.eexprtoken.md#ex_callmath) instruction.

```csharp
public class EX_CallMath : EX_FinalFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_FinalFunction](./uassetapi.kismet.bytecode.expressions.ex_finalfunction.md) → [EX_CallMath](./uassetapi.kismet.bytecode.expressions.ex_callmath.md)

## Fields

### **StackNode**

Stack node.

```csharp
public FPackageIndex StackNode;
```

### **Parameters**

List of parameters for this function.

```csharp
public KismetExpression[] Parameters;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_CallMath()**

```csharp
public EX_CallMath()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_callmulticastdelegate.md`:

```md
# EX_CallMulticastDelegate

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_CallMulticastDelegate](./uassetapi.kismet.bytecode.eexprtoken.md#ex_callmulticastdelegate) instruction.

```csharp
public class EX_CallMulticastDelegate : EX_FinalFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_FinalFunction](./uassetapi.kismet.bytecode.expressions.ex_finalfunction.md) → [EX_CallMulticastDelegate](./uassetapi.kismet.bytecode.expressions.ex_callmulticastdelegate.md)

## Fields

### **Delegate**

Delegate property.

```csharp
public KismetExpression Delegate;
```

### **StackNode**

Stack node.

```csharp
public FPackageIndex StackNode;
```

### **Parameters**

List of parameters for this function.

```csharp
public KismetExpression[] Parameters;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_CallMulticastDelegate()**

```csharp
public EX_CallMulticastDelegate()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_castbase.md`:

```md
# EX_CastBase

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

Base class for several type cast expressions

```csharp
public abstract class EX_CastBase : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_CastBase](./uassetapi.kismet.bytecode.expressions.ex_castbase.md)

## Fields

### **ClassPtr**

The interface class to convert to.

```csharp
public FPackageIndex ClassPtr;
```

### **Target**

The target of this expression.

```csharp
public KismetExpression Target;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_classcontext.md`:

```md
# EX_ClassContext

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ClassContext](./uassetapi.kismet.bytecode.eexprtoken.md#ex_classcontext) instruction.

```csharp
public class EX_ClassContext : EX_Context
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Context](./uassetapi.kismet.bytecode.expressions.ex_context.md) → [EX_ClassContext](./uassetapi.kismet.bytecode.expressions.ex_classcontext.md)

## Fields

### **ObjectExpression**

Object expression.

```csharp
public KismetExpression ObjectExpression;
```

### **Offset**

Code offset for NULL expressions.

```csharp
public uint Offset;
```

### **PropertyType**

Old property type.

```csharp
public byte PropertyType;
```

### **RValuePointer**

Property corresponding to the r-value data, in case the l-value needs to be mem-zero'd. FField*

```csharp
public KismetPropertyPointer RValuePointer;
```

### **ContextExpression**

Context expression.

```csharp
public KismetExpression ContextExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ClassContext()**

```csharp
public EX_ClassContext()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_classsparsedatavariable.md`:

```md
# EX_ClassSparseDataVariable

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ClassSparseDataVariable](./uassetapi.kismet.bytecode.eexprtoken.md#ex_classsparsedatavariable) instruction.

```csharp
public class EX_ClassSparseDataVariable : EX_VariableBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VariableBase](./uassetapi.kismet.bytecode.expressions.ex_variablebase.md) → [EX_ClassSparseDataVariable](./uassetapi.kismet.bytecode.expressions.ex_classsparsedatavariable.md)

## Fields

### **Variable**

A pointer to the variable in question.

```csharp
public KismetPropertyPointer Variable;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ClassSparseDataVariable()**

```csharp
public EX_ClassSparseDataVariable()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_clearmulticastdelegate.md`:

```md
# EX_ClearMulticastDelegate

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ClearMulticastDelegate](./uassetapi.kismet.bytecode.eexprtoken.md#ex_clearmulticastdelegate) instruction.

```csharp
public class EX_ClearMulticastDelegate : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_ClearMulticastDelegate](./uassetapi.kismet.bytecode.expressions.ex_clearmulticastdelegate.md)

## Fields

### **DelegateToClear**

Delegate property to clear.

```csharp
public KismetExpression DelegateToClear;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ClearMulticastDelegate()**

```csharp
public EX_ClearMulticastDelegate()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_computedjump.md`:

```md
# EX_ComputedJump

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ComputedJump](./uassetapi.kismet.bytecode.eexprtoken.md#ex_computedjump) instruction.

```csharp
public class EX_ComputedJump : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_ComputedJump](./uassetapi.kismet.bytecode.expressions.ex_computedjump.md)

## Fields

### **CodeOffsetExpression**

An integer expression corresponding to the offset to jump to.

```csharp
public KismetExpression CodeOffsetExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ComputedJump()**

```csharp
public EX_ComputedJump()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_context.md`:

```md
# EX_Context

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Context](./uassetapi.kismet.bytecode.eexprtoken.md#ex_context) instruction.

```csharp
public class EX_Context : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Context](./uassetapi.kismet.bytecode.expressions.ex_context.md)

## Fields

### **ObjectExpression**

Object expression.

```csharp
public KismetExpression ObjectExpression;
```

### **Offset**

Code offset for NULL expressions.

```csharp
public uint Offset;
```

### **PropertyType**

Old property type.

```csharp
public byte PropertyType;
```

### **RValuePointer**

Property corresponding to the r-value data, in case the l-value needs to be mem-zero'd. FField*

```csharp
public KismetPropertyPointer RValuePointer;
```

### **ContextExpression**

Context expression.

```csharp
public KismetExpression ContextExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Context()**

```csharp
public EX_Context()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_context_failsilent.md`:

```md
# EX_Context_FailSilent

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Context_FailSilent](./uassetapi.kismet.bytecode.eexprtoken.md#ex_context_failsilent) instruction.

```csharp
public class EX_Context_FailSilent : EX_Context
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Context](./uassetapi.kismet.bytecode.expressions.ex_context.md) → [EX_Context_FailSilent](./uassetapi.kismet.bytecode.expressions.ex_context_failsilent.md)

## Fields

### **ObjectExpression**

Object expression.

```csharp
public KismetExpression ObjectExpression;
```

### **Offset**

Code offset for NULL expressions.

```csharp
public uint Offset;
```

### **PropertyType**

Old property type.

```csharp
public byte PropertyType;
```

### **RValuePointer**

Property corresponding to the r-value data, in case the l-value needs to be mem-zero'd. FField*

```csharp
public KismetPropertyPointer RValuePointer;
```

### **ContextExpression**

Context expression.

```csharp
public KismetExpression ContextExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Context_FailSilent()**

```csharp
public EX_Context_FailSilent()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_crossinterfacecast.md`:

```md
# EX_CrossInterfaceCast

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_CrossInterfaceCast](./uassetapi.kismet.bytecode.eexprtoken.md#ex_crossinterfacecast) instruction.

```csharp
public class EX_CrossInterfaceCast : EX_CastBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_CastBase](./uassetapi.kismet.bytecode.expressions.ex_castbase.md) → [EX_CrossInterfaceCast](./uassetapi.kismet.bytecode.expressions.ex_crossinterfacecast.md)

## Fields

### **ClassPtr**

The interface class to convert to.

```csharp
public FPackageIndex ClassPtr;
```

### **Target**

The target of this expression.

```csharp
public KismetExpression Target;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_CrossInterfaceCast()**

```csharp
public EX_CrossInterfaceCast()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_defaultvariable.md`:

```md
# EX_DefaultVariable

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_DefaultVariable](./uassetapi.kismet.bytecode.eexprtoken.md#ex_defaultvariable) instruction.

```csharp
public class EX_DefaultVariable : EX_VariableBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VariableBase](./uassetapi.kismet.bytecode.expressions.ex_variablebase.md) → [EX_DefaultVariable](./uassetapi.kismet.bytecode.expressions.ex_defaultvariable.md)

## Fields

### **Variable**

A pointer to the variable in question.

```csharp
public KismetPropertyPointer Variable;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_DefaultVariable()**

```csharp
public EX_DefaultVariable()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_deprecatedop4a.md`:

```md
# EX_DeprecatedOp4A

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_DeprecatedOp4A](./uassetapi.kismet.bytecode.eexprtoken.md#ex_deprecatedop4a) instruction.

```csharp
public class EX_DeprecatedOp4A : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_DeprecatedOp4A](./uassetapi.kismet.bytecode.expressions.ex_deprecatedop4a.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_DeprecatedOp4A()**

```csharp
public EX_DeprecatedOp4A()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_doubleconst.md`:

```md
# EX_DoubleConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_DoubleConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_doubleconst) instruction.

```csharp
public class EX_DoubleConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_DoubleConst](./uassetapi.kismet.bytecode.expressions.ex_doubleconst.md)

## Fields

### **Value**

The value of this double constant expression.

```csharp
public double Value;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_DoubleConst()**

```csharp
public EX_DoubleConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_dynamiccast.md`:

```md
# EX_DynamicCast

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_DynamicCast](./uassetapi.kismet.bytecode.eexprtoken.md#ex_dynamiccast) instruction.

```csharp
public class EX_DynamicCast : EX_CastBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_CastBase](./uassetapi.kismet.bytecode.expressions.ex_castbase.md) → [EX_DynamicCast](./uassetapi.kismet.bytecode.expressions.ex_dynamiccast.md)

## Fields

### **ClassPtr**

The interface class to convert to.

```csharp
public FPackageIndex ClassPtr;
```

### **Target**

The target of this expression.

```csharp
public KismetExpression Target;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_DynamicCast()**

```csharp
public EX_DynamicCast()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endarray.md`:

```md
# EX_EndArray

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndArray](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endarray) instruction.

```csharp
public class EX_EndArray : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndArray](./uassetapi.kismet.bytecode.expressions.ex_endarray.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndArray()**

```csharp
public EX_EndArray()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endarrayconst.md`:

```md
# EX_EndArrayConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndArrayConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endarrayconst) instruction.

```csharp
public class EX_EndArrayConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndArrayConst](./uassetapi.kismet.bytecode.expressions.ex_endarrayconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndArrayConst()**

```csharp
public EX_EndArrayConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endfunctionparms.md`:

```md
# EX_EndFunctionParms

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndFunctionParms](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endfunctionparms) instruction.

```csharp
public class EX_EndFunctionParms : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndFunctionParms](./uassetapi.kismet.bytecode.expressions.ex_endfunctionparms.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndFunctionParms()**

```csharp
public EX_EndFunctionParms()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endmap.md`:

```md
# EX_EndMap

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndMap](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endmap) instruction.

```csharp
public class EX_EndMap : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndMap](./uassetapi.kismet.bytecode.expressions.ex_endmap.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndMap()**

```csharp
public EX_EndMap()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endmapconst.md`:

```md
# EX_EndMapConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndMapConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endmapconst) instruction.

```csharp
public class EX_EndMapConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndMapConst](./uassetapi.kismet.bytecode.expressions.ex_endmapconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndMapConst()**

```csharp
public EX_EndMapConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endofscript.md`:

```md
# EX_EndOfScript

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndOfScript](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endofscript) instruction.

```csharp
public class EX_EndOfScript : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndOfScript](./uassetapi.kismet.bytecode.expressions.ex_endofscript.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndOfScript()**

```csharp
public EX_EndOfScript()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endparmvalue.md`:

```md
# EX_EndParmValue

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndParmValue](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endparmvalue) instruction.

```csharp
public class EX_EndParmValue : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndParmValue](./uassetapi.kismet.bytecode.expressions.ex_endparmvalue.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndParmValue()**

```csharp
public EX_EndParmValue()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endset.md`:

```md
# EX_EndSet

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndSet](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endset) instruction.

```csharp
public class EX_EndSet : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndSet](./uassetapi.kismet.bytecode.expressions.ex_endset.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndSet()**

```csharp
public EX_EndSet()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endsetconst.md`:

```md
# EX_EndSetConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndSetConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endsetconst) instruction.

```csharp
public class EX_EndSetConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndSetConst](./uassetapi.kismet.bytecode.expressions.ex_endsetconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndSetConst()**

```csharp
public EX_EndSetConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_endstructconst.md`:

```md
# EX_EndStructConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_EndStructConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_endstructconst) instruction.

```csharp
public class EX_EndStructConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_EndStructConst](./uassetapi.kismet.bytecode.expressions.ex_endstructconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_EndStructConst()**

```csharp
public EX_EndStructConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_false.md`:

```md
# EX_False

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_False](./uassetapi.kismet.bytecode.eexprtoken.md#ex_false) instruction.

```csharp
public class EX_False : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_False](./uassetapi.kismet.bytecode.expressions.ex_false.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_False()**

```csharp
public EX_False()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_fieldpathconst.md`:

```md
# EX_FieldPathConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_FieldPathConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_fieldpathconst) instruction.

```csharp
public class EX_FieldPathConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[UAssetAPI.Kismet.Bytecode.KismetExpression]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;KismetExpression&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_FieldPathConst](./uassetapi.kismet.bytecode.expressions.ex_fieldpathconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public KismetExpression Value { get; set; }
```

#### Property Value

[KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_FieldPathConst()**

```csharp
public EX_FieldPathConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_finalfunction.md`:

```md
# EX_FinalFunction

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_FinalFunction](./uassetapi.kismet.bytecode.eexprtoken.md#ex_finalfunction) instruction.

```csharp
public class EX_FinalFunction : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_FinalFunction](./uassetapi.kismet.bytecode.expressions.ex_finalfunction.md)

## Fields

### **StackNode**

Stack node.

```csharp
public FPackageIndex StackNode;
```

### **Parameters**

List of parameters for this function.

```csharp
public KismetExpression[] Parameters;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_FinalFunction()**

```csharp
public EX_FinalFunction()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_floatconst.md`:

```md
# EX_FloatConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_FloatConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_floatconst) instruction.

```csharp
public class EX_FloatConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_FloatConst](./uassetapi.kismet.bytecode.expressions.ex_floatconst.md)

## Fields

### **Value**

The value of this float constant expression.

```csharp
public float Value;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_FloatConst()**

```csharp
public EX_FloatConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_instancedelegate.md`:

```md
# EX_InstanceDelegate

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_InstanceDelegate](./uassetapi.kismet.bytecode.eexprtoken.md#ex_instancedelegate) instruction.

```csharp
public class EX_InstanceDelegate : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_InstanceDelegate](./uassetapi.kismet.bytecode.expressions.ex_instancedelegate.md)

## Fields

### **FunctionName**

The name of the function assigned to the delegate.

```csharp
public FName FunctionName;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_InstanceDelegate()**

```csharp
public EX_InstanceDelegate()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_instancevariable.md`:

```md
# EX_InstanceVariable

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_InstanceVariable](./uassetapi.kismet.bytecode.eexprtoken.md#ex_instancevariable) instruction.

```csharp
public class EX_InstanceVariable : EX_VariableBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VariableBase](./uassetapi.kismet.bytecode.expressions.ex_variablebase.md) → [EX_InstanceVariable](./uassetapi.kismet.bytecode.expressions.ex_instancevariable.md)

## Fields

### **Variable**

A pointer to the variable in question.

```csharp
public KismetPropertyPointer Variable;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_InstanceVariable()**

```csharp
public EX_InstanceVariable()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_instrumentationevent.md`:

```md
# EX_InstrumentationEvent

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_InstrumentationEvent](./uassetapi.kismet.bytecode.eexprtoken.md#ex_instrumentationevent) instruction.

```csharp
public class EX_InstrumentationEvent : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_InstrumentationEvent](./uassetapi.kismet.bytecode.expressions.ex_instrumentationevent.md)

## Fields

### **EventType**

```csharp
public EScriptInstrumentationType EventType;
```

### **EventName**

```csharp
public FName EventName;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_InstrumentationEvent()**

```csharp
public EX_InstrumentationEvent()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_int64const.md`:

```md
# EX_Int64Const

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Int64Const](./uassetapi.kismet.bytecode.eexprtoken.md#ex_int64const) instruction.

```csharp
public class EX_Int64Const : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.Int64]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;Int64&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_Int64Const](./uassetapi.kismet.bytecode.expressions.ex_int64const.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public long Value { get; set; }
```

#### Property Value

[Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Int64Const()**

```csharp
public EX_Int64Const()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_intconst.md`:

```md
# EX_IntConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_IntConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_intconst) instruction.

```csharp
public class EX_IntConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.Int32]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;Int32&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_IntConst](./uassetapi.kismet.bytecode.expressions.ex_intconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public int Value { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_IntConst()**

```csharp
public EX_IntConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_intconstbyte.md`:

```md
# EX_IntConstByte

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_IntConstByte](./uassetapi.kismet.bytecode.eexprtoken.md#ex_intconstbyte) instruction.

```csharp
public class EX_IntConstByte : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.Byte]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;Byte&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_IntConstByte](./uassetapi.kismet.bytecode.expressions.ex_intconstbyte.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public byte Value { get; set; }
```

#### Property Value

[Byte](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_IntConstByte()**

```csharp
public EX_IntConstByte()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_interfacecontext.md`:

```md
# EX_InterfaceContext

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_InterfaceContext](./uassetapi.kismet.bytecode.eexprtoken.md#ex_interfacecontext) instruction.

```csharp
public class EX_InterfaceContext : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_InterfaceContext](./uassetapi.kismet.bytecode.expressions.ex_interfacecontext.md)

## Fields

### **InterfaceValue**

Interface value.

```csharp
public KismetExpression InterfaceValue;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_InterfaceContext()**

```csharp
public EX_InterfaceContext()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_interfacetoobjcast.md`:

```md
# EX_InterfaceToObjCast

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_InterfaceToObjCast](./uassetapi.kismet.bytecode.eexprtoken.md#ex_interfacetoobjcast) instruction.

```csharp
public class EX_InterfaceToObjCast : EX_CastBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_CastBase](./uassetapi.kismet.bytecode.expressions.ex_castbase.md) → [EX_InterfaceToObjCast](./uassetapi.kismet.bytecode.expressions.ex_interfacetoobjcast.md)

## Fields

### **ClassPtr**

The interface class to convert to.

```csharp
public FPackageIndex ClassPtr;
```

### **Target**

The target of this expression.

```csharp
public KismetExpression Target;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_InterfaceToObjCast()**

```csharp
public EX_InterfaceToObjCast()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_intone.md`:

```md
# EX_IntOne

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_IntOne](./uassetapi.kismet.bytecode.eexprtoken.md#ex_intone) instruction.

```csharp
public class EX_IntOne : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_IntOne](./uassetapi.kismet.bytecode.expressions.ex_intone.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_IntOne()**

```csharp
public EX_IntOne()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_intzero.md`:

```md
# EX_IntZero

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_IntZero](./uassetapi.kismet.bytecode.eexprtoken.md#ex_intzero) instruction.

```csharp
public class EX_IntZero : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_IntZero](./uassetapi.kismet.bytecode.expressions.ex_intzero.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_IntZero()**

```csharp
public EX_IntZero()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_jump.md`:

```md
# EX_Jump

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Jump](./uassetapi.kismet.bytecode.eexprtoken.md#ex_jump) instruction.

```csharp
public class EX_Jump : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Jump](./uassetapi.kismet.bytecode.expressions.ex_jump.md)

## Fields

### **CodeOffset**

The offset to jump to.

```csharp
public uint CodeOffset;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Jump()**

```csharp
public EX_Jump()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_jumpifnot.md`:

```md
# EX_JumpIfNot

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_JumpIfNot](./uassetapi.kismet.bytecode.eexprtoken.md#ex_jumpifnot) instruction.
 Conditional equivalent of the [EExprToken.EX_Jump](./uassetapi.kismet.bytecode.eexprtoken.md#ex_jump) expression.

```csharp
public class EX_JumpIfNot : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_JumpIfNot](./uassetapi.kismet.bytecode.expressions.ex_jumpifnot.md)

## Fields

### **CodeOffset**

The offset to jump to if the provided expression evaluates to false.

```csharp
public uint CodeOffset;
```

### **BooleanExpression**

Expression to evaluate to determine whether or not a jump should be performed.

```csharp
public KismetExpression BooleanExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_JumpIfNot()**

```csharp
public EX_JumpIfNot()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_let.md`:

```md
# EX_Let

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Let](./uassetapi.kismet.bytecode.eexprtoken.md#ex_let) instruction.

```csharp
public class EX_Let : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Let](./uassetapi.kismet.bytecode.expressions.ex_let.md)

## Fields

### **Value**

A pointer to the variable.

```csharp
public KismetPropertyPointer Value;
```

### **Variable**

```csharp
public KismetExpression Variable;
```

### **Expression**

```csharp
public KismetExpression Expression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Let()**

```csharp
public EX_Let()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_letbase.md`:

```md
# EX_LetBase

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

Base class for several Let (assignment) expressions

```csharp
public abstract class EX_LetBase : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_LetBase](./uassetapi.kismet.bytecode.expressions.ex_letbase.md)

## Fields

### **VariableExpression**

Variable expression.

```csharp
public KismetExpression VariableExpression;
```

### **AssignmentExpression**

Assignment expression.

```csharp
public KismetExpression AssignmentExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_letbool.md`:

```md
# EX_LetBool

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LetBool](./uassetapi.kismet.bytecode.eexprtoken.md#ex_letbool) instruction.

```csharp
public class EX_LetBool : EX_LetBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_LetBase](./uassetapi.kismet.bytecode.expressions.ex_letbase.md) → [EX_LetBool](./uassetapi.kismet.bytecode.expressions.ex_letbool.md)

## Fields

### **VariableExpression**

Variable expression.

```csharp
public KismetExpression VariableExpression;
```

### **AssignmentExpression**

Assignment expression.

```csharp
public KismetExpression AssignmentExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LetBool()**

```csharp
public EX_LetBool()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_letdelegate.md`:

```md
# EX_LetDelegate

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LetDelegate](./uassetapi.kismet.bytecode.eexprtoken.md#ex_letdelegate) instruction.

```csharp
public class EX_LetDelegate : EX_LetBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_LetBase](./uassetapi.kismet.bytecode.expressions.ex_letbase.md) → [EX_LetDelegate](./uassetapi.kismet.bytecode.expressions.ex_letdelegate.md)

## Fields

### **VariableExpression**

Variable expression.

```csharp
public KismetExpression VariableExpression;
```

### **AssignmentExpression**

Assignment expression.

```csharp
public KismetExpression AssignmentExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LetDelegate()**

```csharp
public EX_LetDelegate()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_letmulticastdelegate.md`:

```md
# EX_LetMulticastDelegate

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LetMulticastDelegate](./uassetapi.kismet.bytecode.eexprtoken.md#ex_letmulticastdelegate) instruction.

```csharp
public class EX_LetMulticastDelegate : EX_LetBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_LetBase](./uassetapi.kismet.bytecode.expressions.ex_letbase.md) → [EX_LetMulticastDelegate](./uassetapi.kismet.bytecode.expressions.ex_letmulticastdelegate.md)

## Fields

### **VariableExpression**

Variable expression.

```csharp
public KismetExpression VariableExpression;
```

### **AssignmentExpression**

Assignment expression.

```csharp
public KismetExpression AssignmentExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LetMulticastDelegate()**

```csharp
public EX_LetMulticastDelegate()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_letobj.md`:

```md
# EX_LetObj

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LetObj](./uassetapi.kismet.bytecode.eexprtoken.md#ex_letobj) instruction.

```csharp
public class EX_LetObj : EX_LetBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_LetBase](./uassetapi.kismet.bytecode.expressions.ex_letbase.md) → [EX_LetObj](./uassetapi.kismet.bytecode.expressions.ex_letobj.md)

## Fields

### **VariableExpression**

Variable expression.

```csharp
public KismetExpression VariableExpression;
```

### **AssignmentExpression**

Assignment expression.

```csharp
public KismetExpression AssignmentExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LetObj()**

```csharp
public EX_LetObj()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_letvalueonpersistentframe.md`:

```md
# EX_LetValueOnPersistentFrame

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LetValueOnPersistentFrame](./uassetapi.kismet.bytecode.eexprtoken.md#ex_letvalueonpersistentframe) instruction.

```csharp
public class EX_LetValueOnPersistentFrame : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_LetValueOnPersistentFrame](./uassetapi.kismet.bytecode.expressions.ex_letvalueonpersistentframe.md)

## Fields

### **DestinationProperty**

Destination property pointer.

```csharp
public KismetPropertyPointer DestinationProperty;
```

### **AssignmentExpression**

Assignment expression.

```csharp
public KismetExpression AssignmentExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LetValueOnPersistentFrame()**

```csharp
public EX_LetValueOnPersistentFrame()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_letweakobjptr.md`:

```md
# EX_LetWeakObjPtr

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LetWeakObjPtr](./uassetapi.kismet.bytecode.eexprtoken.md#ex_letweakobjptr) instruction.

```csharp
public class EX_LetWeakObjPtr : EX_LetBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_LetBase](./uassetapi.kismet.bytecode.expressions.ex_letbase.md) → [EX_LetWeakObjPtr](./uassetapi.kismet.bytecode.expressions.ex_letweakobjptr.md)

## Fields

### **VariableExpression**

Variable expression.

```csharp
public KismetExpression VariableExpression;
```

### **AssignmentExpression**

Assignment expression.

```csharp
public KismetExpression AssignmentExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LetWeakObjPtr()**

```csharp
public EX_LetWeakObjPtr()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_localfinalfunction.md`:

```md
# EX_LocalFinalFunction

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LocalFinalFunction](./uassetapi.kismet.bytecode.eexprtoken.md#ex_localfinalfunction) instruction.

```csharp
public class EX_LocalFinalFunction : EX_FinalFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_FinalFunction](./uassetapi.kismet.bytecode.expressions.ex_finalfunction.md) → [EX_LocalFinalFunction](./uassetapi.kismet.bytecode.expressions.ex_localfinalfunction.md)

## Fields

### **StackNode**

Stack node.

```csharp
public FPackageIndex StackNode;
```

### **Parameters**

List of parameters for this function.

```csharp
public KismetExpression[] Parameters;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LocalFinalFunction()**

```csharp
public EX_LocalFinalFunction()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_localoutvariable.md`:

```md
# EX_LocalOutVariable

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LocalOutVariable](./uassetapi.kismet.bytecode.eexprtoken.md#ex_localoutvariable) instruction.

```csharp
public class EX_LocalOutVariable : EX_VariableBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VariableBase](./uassetapi.kismet.bytecode.expressions.ex_variablebase.md) → [EX_LocalOutVariable](./uassetapi.kismet.bytecode.expressions.ex_localoutvariable.md)

## Fields

### **Variable**

A pointer to the variable in question.

```csharp
public KismetPropertyPointer Variable;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LocalOutVariable()**

```csharp
public EX_LocalOutVariable()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_localvariable.md`:

```md
# EX_LocalVariable

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LocalVariable](./uassetapi.kismet.bytecode.eexprtoken.md#ex_localvariable) instruction.

```csharp
public class EX_LocalVariable : EX_VariableBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VariableBase](./uassetapi.kismet.bytecode.expressions.ex_variablebase.md) → [EX_LocalVariable](./uassetapi.kismet.bytecode.expressions.ex_localvariable.md)

## Fields

### **Variable**

A pointer to the variable in question.

```csharp
public KismetPropertyPointer Variable;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LocalVariable()**

```csharp
public EX_LocalVariable()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_localvirtualfunction.md`:

```md
# EX_LocalVirtualFunction

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_LocalVirtualFunction](./uassetapi.kismet.bytecode.eexprtoken.md#ex_localvirtualfunction) instruction.

```csharp
public class EX_LocalVirtualFunction : EX_VirtualFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VirtualFunction](./uassetapi.kismet.bytecode.expressions.ex_virtualfunction.md) → [EX_LocalVirtualFunction](./uassetapi.kismet.bytecode.expressions.ex_localvirtualfunction.md)

## Fields

### **VirtualFunctionName**

Virtual function name.

```csharp
public FName VirtualFunctionName;
```

### **Parameters**

List of parameters for this function.

```csharp
public KismetExpression[] Parameters;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_LocalVirtualFunction()**

```csharp
public EX_LocalVirtualFunction()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_mapconst.md`:

```md
# EX_MapConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_MapConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_mapconst) instruction.

```csharp
public class EX_MapConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_MapConst](./uassetapi.kismet.bytecode.expressions.ex_mapconst.md)

## Fields

### **KeyProperty**

Pointer to this constant's key property (FProperty*).

```csharp
public KismetPropertyPointer KeyProperty;
```

### **ValueProperty**

Pointer to this constant's value property (FProperty*).

```csharp
public KismetPropertyPointer ValueProperty;
```

### **Elements**

Set constant entries.

```csharp
public KismetExpression[] Elements;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_MapConst()**

```csharp
public EX_MapConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_metacast.md`:

```md
# EX_MetaCast

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_MetaCast](./uassetapi.kismet.bytecode.eexprtoken.md#ex_metacast) instruction.

```csharp
public class EX_MetaCast : EX_CastBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_CastBase](./uassetapi.kismet.bytecode.expressions.ex_castbase.md) → [EX_MetaCast](./uassetapi.kismet.bytecode.expressions.ex_metacast.md)

## Fields

### **ClassPtr**

The interface class to convert to.

```csharp
public FPackageIndex ClassPtr;
```

### **Target**

The target of this expression.

```csharp
public KismetExpression Target;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_MetaCast()**

```csharp
public EX_MetaCast()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_nameconst.md`:

```md
# EX_NameConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_NameConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_nameconst) instruction.

```csharp
public class EX_NameConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[UAssetAPI.UnrealTypes.FName]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;FName&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_NameConst](./uassetapi.kismet.bytecode.expressions.ex_nameconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public FName Value { get; set; }
```

#### Property Value

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_NameConst()**

```csharp
public EX_NameConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_nointerface.md`:

```md
# EX_NoInterface

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_NoInterface](./uassetapi.kismet.bytecode.eexprtoken.md#ex_nointerface) instruction.

```csharp
public class EX_NoInterface : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_NoInterface](./uassetapi.kismet.bytecode.expressions.ex_nointerface.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_NoInterface()**

```csharp
public EX_NoInterface()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_noobject.md`:

```md
# EX_NoObject

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_NoObject](./uassetapi.kismet.bytecode.eexprtoken.md#ex_noobject) instruction.

```csharp
public class EX_NoObject : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_NoObject](./uassetapi.kismet.bytecode.expressions.ex_noobject.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_NoObject()**

```csharp
public EX_NoObject()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_nothing.md`:

```md
# EX_Nothing

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Nothing](./uassetapi.kismet.bytecode.eexprtoken.md#ex_nothing) instruction.
 Represents a no-op.

```csharp
public class EX_Nothing : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Nothing](./uassetapi.kismet.bytecode.expressions.ex_nothing.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Nothing()**

```csharp
public EX_Nothing()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_nothingint32.md`:

```md
# EX_NothingInt32

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_NothingInt32](./uassetapi.kismet.bytecode.eexprtoken.md#ex_nothingint32) instruction.
 No operation with an int32 argument (useful for debugging script disassembly).

```csharp
public class EX_NothingInt32 : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.Int32]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;Int32&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_NothingInt32](./uassetapi.kismet.bytecode.expressions.ex_nothingint32.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public int Value { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_NothingInt32()**

```csharp
public EX_NothingInt32()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_objectconst.md`:

```md
# EX_ObjectConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ObjectConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_objectconst) instruction.

```csharp
public class EX_ObjectConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[UAssetAPI.UnrealTypes.FPackageIndex]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;FPackageIndex&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_ObjectConst](./uassetapi.kismet.bytecode.expressions.ex_objectconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public FPackageIndex Value { get; set; }
```

#### Property Value

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ObjectConst()**

```csharp
public EX_ObjectConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_objtointerfacecast.md`:

```md
# EX_ObjToInterfaceCast

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_ObjToInterfaceCast](./uassetapi.kismet.bytecode.eexprtoken.md#ex_objtointerfacecast) instruction.
 A conversion from an object or interface variable to a native interface variable.

```csharp
public class EX_ObjToInterfaceCast : EX_CastBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_CastBase](./uassetapi.kismet.bytecode.expressions.ex_castbase.md) → [EX_ObjToInterfaceCast](./uassetapi.kismet.bytecode.expressions.ex_objtointerfacecast.md)

## Fields

### **ClassPtr**

The interface class to convert to.

```csharp
public FPackageIndex ClassPtr;
```

### **Target**

The target of this expression.

```csharp
public KismetExpression Target;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_ObjToInterfaceCast()**

```csharp
public EX_ObjToInterfaceCast()
```

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_popexecutionflow.md`:

```md
# EX_PopExecutionFlow

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_PopExecutionFlow](./uassetapi.kismet.bytecode.eexprtoken.md#ex_popexecutionflow) instruction.

```csharp
public class EX_PopExecutionFlow : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_PopExecutionFlow](./uassetapi.kismet.bytecode.expressions.ex_popexecutionflow.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_PopExecutionFlow()**

```csharp
public EX_PopExecutionFlow()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_popexecutionflowifnot.md`:

```md
# EX_PopExecutionFlowIfNot

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_PopExecutionFlowIfNot](./uassetapi.kismet.bytecode.eexprtoken.md#ex_popexecutionflowifnot) instruction.
 Conditional equivalent of the [EExprToken.EX_PopExecutionFlow](./uassetapi.kismet.bytecode.eexprtoken.md#ex_popexecutionflow) expression.

```csharp
public class EX_PopExecutionFlowIfNot : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_PopExecutionFlowIfNot](./uassetapi.kismet.bytecode.expressions.ex_popexecutionflowifnot.md)

## Fields

### **BooleanExpression**

Expression to evaluate to determine whether or not a pop should be performed.

```csharp
public KismetExpression BooleanExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_PopExecutionFlowIfNot()**

```csharp
public EX_PopExecutionFlowIfNot()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_primitivecast.md`:

```md
# EX_PrimitiveCast

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_PrimitiveCast](./uassetapi.kismet.bytecode.eexprtoken.md#ex_primitivecast) instruction.

```csharp
public class EX_PrimitiveCast : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_PrimitiveCast](./uassetapi.kismet.bytecode.expressions.ex_primitivecast.md)

## Fields

### **ConversionType**

The type to cast to.

```csharp
public ECastToken ConversionType;
```

### **Target**

The target of this expression.

```csharp
public KismetExpression Target;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_PrimitiveCast()**

```csharp
public EX_PrimitiveCast()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_propertyconst.md`:

```md
# EX_PropertyConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_PropertyConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_propertyconst) instruction.

```csharp
public class EX_PropertyConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_PropertyConst](./uassetapi.kismet.bytecode.expressions.ex_propertyconst.md)

## Fields

### **Property**

A pointer to the property in question.

```csharp
public KismetPropertyPointer Property;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_PropertyConst()**

```csharp
public EX_PropertyConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_pushexecutionflow.md`:

```md
# EX_PushExecutionFlow

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_PushExecutionFlow](./uassetapi.kismet.bytecode.eexprtoken.md#ex_pushexecutionflow) instruction.

```csharp
public class EX_PushExecutionFlow : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_PushExecutionFlow](./uassetapi.kismet.bytecode.expressions.ex_pushexecutionflow.md)

## Fields

### **PushingAddress**

The address to push onto the execution flow stack.

```csharp
public uint PushingAddress;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_PushExecutionFlow()**

```csharp
public EX_PushExecutionFlow()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_removemulticastdelegate.md`:

```md
# EX_RemoveMulticastDelegate

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_RemoveMulticastDelegate](./uassetapi.kismet.bytecode.eexprtoken.md#ex_removemulticastdelegate) instruction.

```csharp
public class EX_RemoveMulticastDelegate : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_RemoveMulticastDelegate](./uassetapi.kismet.bytecode.expressions.ex_removemulticastdelegate.md)

## Fields

### **Delegate**

Delegate property to assign to.

```csharp
public KismetExpression Delegate;
```

### **DelegateToAdd**

Delegate to add to the MC delegate for broadcast.

```csharp
public KismetExpression DelegateToAdd;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_RemoveMulticastDelegate()**

```csharp
public EX_RemoveMulticastDelegate()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_return.md`:

```md
# EX_Return

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Return](./uassetapi.kismet.bytecode.eexprtoken.md#ex_return) instruction.

```csharp
public class EX_Return : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Return](./uassetapi.kismet.bytecode.expressions.ex_return.md)

## Fields

### **ReturnExpression**

The return expression.

```csharp
public KismetExpression ReturnExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Return()**

```csharp
public EX_Return()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_rotationconst.md`:

```md
# EX_RotationConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_RotationConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_rotationconst) instruction.

```csharp
public class EX_RotationConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_RotationConst](./uassetapi.kismet.bytecode.expressions.ex_rotationconst.md)

## Fields

### **Value**

```csharp
public FRotator Value;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_RotationConst()**

```csharp
public EX_RotationConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_self.md`:

```md
# EX_Self

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Self](./uassetapi.kismet.bytecode.eexprtoken.md#ex_self) instruction.

```csharp
public class EX_Self : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Self](./uassetapi.kismet.bytecode.expressions.ex_self.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Self()**

```csharp
public EX_Self()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_setarray.md`:

```md
# EX_SetArray

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_SetArray](./uassetapi.kismet.bytecode.eexprtoken.md#ex_setarray) instruction.

```csharp
public class EX_SetArray : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_SetArray](./uassetapi.kismet.bytecode.expressions.ex_setarray.md)

## Fields

### **AssigningProperty**

Array property to assign to

```csharp
public KismetExpression AssigningProperty;
```

### **ArrayInnerProp**

Pointer to the array inner property (FProperty*).
 Only used in engine versions prior to [ObjectVersion.VER_UE4_CHANGE_SETARRAY_BYTECODE](./uassetapi.unrealtypes.objectversion.md#ver_ue4_change_setarray_bytecode).

```csharp
public FPackageIndex ArrayInnerProp;
```

### **Elements**

Array items.

```csharp
public KismetExpression[] Elements;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_SetArray()**

```csharp
public EX_SetArray()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_setconst.md`:

```md
# EX_SetConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_SetConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_setconst) instruction.

```csharp
public class EX_SetConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_SetConst](./uassetapi.kismet.bytecode.expressions.ex_setconst.md)

## Fields

### **InnerProperty**

Pointer to this constant's inner property (FProperty*).

```csharp
public KismetPropertyPointer InnerProperty;
```

### **Elements**

Set constant entries.

```csharp
public KismetExpression[] Elements;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_SetConst()**

```csharp
public EX_SetConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_setmap.md`:

```md
# EX_SetMap

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_SetMap](./uassetapi.kismet.bytecode.eexprtoken.md#ex_setmap) instruction.

```csharp
public class EX_SetMap : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_SetMap](./uassetapi.kismet.bytecode.expressions.ex_setmap.md)

## Fields

### **MapProperty**

Map property.

```csharp
public KismetExpression MapProperty;
```

### **Elements**

Set entries.

```csharp
public KismetExpression[] Elements;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_SetMap()**

```csharp
public EX_SetMap()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_setset.md`:

```md
# EX_SetSet

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_SetSet](./uassetapi.kismet.bytecode.eexprtoken.md#ex_setset) instruction.

```csharp
public class EX_SetSet : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_SetSet](./uassetapi.kismet.bytecode.expressions.ex_setset.md)

## Fields

### **SetProperty**

Set property.

```csharp
public KismetExpression SetProperty;
```

### **Elements**

Set entries.

```csharp
public KismetExpression[] Elements;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_SetSet()**

```csharp
public EX_SetSet()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_skip.md`:

```md
# EX_Skip

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Skip](./uassetapi.kismet.bytecode.eexprtoken.md#ex_skip) instruction.

```csharp
public class EX_Skip : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Skip](./uassetapi.kismet.bytecode.expressions.ex_skip.md)

## Fields

### **CodeOffset**

The offset to skip to.

```csharp
public uint CodeOffset;
```

### **SkipExpression**

An expression to possibly skip.

```csharp
public KismetExpression SkipExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Skip()**

```csharp
public EX_Skip()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_skipoffsetconst.md`:

```md
# EX_SkipOffsetConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_SkipOffsetConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_skipoffsetconst) instruction.
 Represents a code offset constant.

```csharp
public class EX_SkipOffsetConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.UInt32]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;UInt32&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_SkipOffsetConst](./uassetapi.kismet.bytecode.expressions.ex_skipoffsetconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public uint Value { get; set; }
```

#### Property Value

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_SkipOffsetConst()**

```csharp
public EX_SkipOffsetConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_softobjectconst.md`:

```md
# EX_SoftObjectConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_SoftObjectConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_softobjectconst) instruction.

```csharp
public class EX_SoftObjectConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[UAssetAPI.Kismet.Bytecode.KismetExpression]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;KismetExpression&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_SoftObjectConst](./uassetapi.kismet.bytecode.expressions.ex_softobjectconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public KismetExpression Value { get; set; }
```

#### Property Value

[KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_SoftObjectConst()**

```csharp
public EX_SoftObjectConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_stringconst.md`:

```md
# EX_StringConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_StringConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_stringconst) instruction.

```csharp
public class EX_StringConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.String]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;String&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_StringConst](./uassetapi.kismet.bytecode.expressions.ex_stringconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public string Value { get; set; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_StringConst()**

```csharp
public EX_StringConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_structconst.md`:

```md
# EX_StructConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_StructConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_structconst) instruction.

```csharp
public class EX_StructConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[UAssetAPI.Kismet.Bytecode.KismetExpression[]]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;KismetExpression[]&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_StructConst](./uassetapi.kismet.bytecode.expressions.ex_structconst.md)

## Fields

### **Struct**

Pointer to the UScriptStruct in question.

```csharp
public FPackageIndex Struct;
```

### **StructSize**

The size of the struct that this constant represents in memory in bytes.

```csharp
public int StructSize;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public KismetExpression[] Value { get; set; }
```

#### Property Value

[KismetExpression[]](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_StructConst()**

```csharp
public EX_StructConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_structmembercontext.md`:

```md
# EX_StructMemberContext

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_StructMemberContext](./uassetapi.kismet.bytecode.eexprtoken.md#ex_structmembercontext) instruction.

```csharp
public class EX_StructMemberContext : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_StructMemberContext](./uassetapi.kismet.bytecode.expressions.ex_structmembercontext.md)

## Fields

### **StructMemberExpression**

A pointer to the struct member expression (FProperty*).

```csharp
public KismetPropertyPointer StructMemberExpression;
```

### **StructExpression**

Struct expression.

```csharp
public KismetExpression StructExpression;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_StructMemberContext()**

```csharp
public EX_StructMemberContext()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_switchvalue.md`:

```md
# EX_SwitchValue

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_SwitchValue](./uassetapi.kismet.bytecode.eexprtoken.md#ex_switchvalue) instruction.

```csharp
public class EX_SwitchValue : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_SwitchValue](./uassetapi.kismet.bytecode.expressions.ex_switchvalue.md)

## Fields

### **EndGotoOffset**

Code offset to jump to when finished.

```csharp
public uint EndGotoOffset;
```

### **IndexTerm**

The index term of this switch statement.

```csharp
public KismetExpression IndexTerm;
```

### **DefaultTerm**

The default term of this switch statement.

```csharp
public KismetExpression DefaultTerm;
```

### **Cases**

All the cases in this switch statement.

```csharp
public FKismetSwitchCase[] Cases;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_SwitchValue()**

```csharp
public EX_SwitchValue()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_textconst.md`:

```md
# EX_TextConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_TextConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_textconst) instruction.

```csharp
public class EX_TextConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[UAssetAPI.Kismet.Bytecode.FScriptText]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;FScriptText&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_TextConst](./uassetapi.kismet.bytecode.expressions.ex_textconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public FScriptText Value { get; set; }
```

#### Property Value

[FScriptText](./uassetapi.kismet.bytecode.fscripttext.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_TextConst()**

```csharp
public EX_TextConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_tracepoint.md`:

```md
# EX_Tracepoint

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Tracepoint](./uassetapi.kismet.bytecode.eexprtoken.md#ex_tracepoint) instruction.

```csharp
public class EX_Tracepoint : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Tracepoint](./uassetapi.kismet.bytecode.expressions.ex_tracepoint.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Tracepoint()**

```csharp
public EX_Tracepoint()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_transformconst.md`:

```md
# EX_TransformConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_TransformConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_transformconst) instruction.

```csharp
public class EX_TransformConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[UAssetAPI.UnrealTypes.FTransform]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;FTransform&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_TransformConst](./uassetapi.kismet.bytecode.expressions.ex_transformconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public FTransform Value { get; set; }
```

#### Property Value

[FTransform](./uassetapi.unrealtypes.ftransform.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_TransformConst()**

```csharp
public EX_TransformConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_true.md`:

```md
# EX_True

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_True](./uassetapi.kismet.bytecode.eexprtoken.md#ex_true) instruction.

```csharp
public class EX_True : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_True](./uassetapi.kismet.bytecode.expressions.ex_true.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_True()**

```csharp
public EX_True()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_uint64const.md`:

```md
# EX_UInt64Const

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_UInt64Const](./uassetapi.kismet.bytecode.eexprtoken.md#ex_uint64const) instruction.

```csharp
public class EX_UInt64Const : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.UInt64]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;UInt64&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_UInt64Const](./uassetapi.kismet.bytecode.expressions.ex_uint64const.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public ulong Value { get; set; }
```

#### Property Value

[UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_UInt64Const()**

```csharp
public EX_UInt64Const()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_unicodestringconst.md`:

```md
# EX_UnicodeStringConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_UnicodeStringConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_unicodestringconst) instruction.

```csharp
public class EX_UnicodeStringConst : UAssetAPI.Kismet.Bytecode.KismetExpression`1[[System.String]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;String&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md) → [EX_UnicodeStringConst](./uassetapi.kismet.bytecode.expressions.ex_unicodestringconst.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Value**

The value of this expression if it is a constant.

```csharp
public string Value { get; set; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_UnicodeStringConst()**

```csharp
public EX_UnicodeStringConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_variablebase.md`:

```md
# EX_VariableBase

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

Base class for Kismet Variable expressions

```csharp
public abstract class EX_VariableBase : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VariableBase](./uassetapi.kismet.bytecode.expressions.ex_variablebase.md)

## Fields

### **Variable**

A pointer to the variable in question.

```csharp
public KismetPropertyPointer Variable;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_vector3fconst.md`:

```md
# EX_Vector3fConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_Vector3fConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_vector3fconst) instruction.
 A float vector constant (always 3 floats, regardless of LWC).

```csharp
public class EX_Vector3fConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_Vector3fConst](./uassetapi.kismet.bytecode.expressions.ex_vector3fconst.md)

## Fields

### **X**

```csharp
public float X;
```

### **Y**

```csharp
public float Y;
```

### **Z**

```csharp
public float Z;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_Vector3fConst()**

```csharp
public EX_Vector3fConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_vectorconst.md`:

```md
# EX_VectorConst

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_VectorConst](./uassetapi.kismet.bytecode.eexprtoken.md#ex_vectorconst) instruction.

```csharp
public class EX_VectorConst : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VectorConst](./uassetapi.kismet.bytecode.expressions.ex_vectorconst.md)

## Fields

### **Value**

```csharp
public FVector Value;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_VectorConst()**

```csharp
public EX_VectorConst()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_virtualfunction.md`:

```md
# EX_VirtualFunction

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_VirtualFunction](./uassetapi.kismet.bytecode.eexprtoken.md#ex_virtualfunction) instruction.

```csharp
public class EX_VirtualFunction : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_VirtualFunction](./uassetapi.kismet.bytecode.expressions.ex_virtualfunction.md)

## Fields

### **VirtualFunctionName**

Virtual function name.

```csharp
public FName VirtualFunctionName;
```

### **Parameters**

List of parameters for this function.

```csharp
public KismetExpression[] Parameters;
```

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_VirtualFunction()**

```csharp
public EX_VirtualFunction()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.ex_wiretracepoint.md`:

```md
# EX_WireTracepoint

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

A single Kismet bytecode instruction, corresponding to the [EExprToken.EX_WireTracepoint](./uassetapi.kismet.bytecode.eexprtoken.md#ex_wiretracepoint) instruction.

```csharp
public class EX_WireTracepoint : UAssetAPI.Kismet.Bytecode.KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [EX_WireTracepoint](./uassetapi.kismet.bytecode.expressions.ex_wiretracepoint.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **EX_WireTracepoint()**

```csharp
public EX_WireTracepoint()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out the expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes the expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.expressions.fkismetswitchcase.md`:

```md
# FKismetSwitchCase

Namespace: UAssetAPI.Kismet.Bytecode.Expressions

Represents a case in a Kismet bytecode switch statement.

```csharp
public struct FKismetSwitchCase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FKismetSwitchCase](./uassetapi.kismet.bytecode.expressions.fkismetswitchcase.md)

## Fields

### **CaseIndexValueTerm**

The index value term of this case.

```csharp
public KismetExpression CaseIndexValueTerm;
```

### **NextOffset**

Code offset to the next case.

```csharp
public uint NextOffset;
```

### **CaseTerm**

The main case term.

```csharp
public KismetExpression CaseTerm;
```

## Constructors

### **FKismetSwitchCase(KismetExpression, UInt32, KismetExpression)**

```csharp
FKismetSwitchCase(KismetExpression caseIndexValueTerm, uint nextOffset, KismetExpression caseTerm)
```

#### Parameters

`caseIndexValueTerm` [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

`nextOffset` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`caseTerm` [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.expressionserializer.md`:

```md
# ExpressionSerializer

Namespace: UAssetAPI.Kismet.Bytecode

```csharp
public static class ExpressionSerializer
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ExpressionSerializer](./uassetapi.kismet.bytecode.expressionserializer.md)

## Methods

### **ReadExpression(AssetBinaryReader)**

```csharp
public static KismetExpression ReadExpression(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

### **WriteExpression(KismetExpression, AssetBinaryWriter)**

```csharp
public static int WriteExpression(KismetExpression expr, AssetBinaryWriter writer)
```

#### Parameters

`expr` [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.kismet.bytecode.fscripttext.md`:

```md
# FScriptText

Namespace: UAssetAPI.Kismet.Bytecode

Represents an FText as serialized in Kismet bytecode.

```csharp
public class FScriptText
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FScriptText](./uassetapi.kismet.bytecode.fscripttext.md)

## Fields

### **TextLiteralType**

```csharp
public EBlueprintTextLiteralType TextLiteralType;
```

### **LocalizedSource**

Source of this text if it is localized text. Used when [FScriptText.TextLiteralType](./uassetapi.kismet.bytecode.fscripttext.md#textliteraltype) is [EBlueprintTextLiteralType.InvariantText](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md#invarianttext).

```csharp
public KismetExpression LocalizedSource;
```

### **LocalizedKey**

Key of this text if it is localized text. Used when [FScriptText.TextLiteralType](./uassetapi.kismet.bytecode.fscripttext.md#textliteraltype) is [EBlueprintTextLiteralType.InvariantText](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md#invarianttext).

```csharp
public KismetExpression LocalizedKey;
```

### **LocalizedNamespace**

Namespace of this text if it is localized text. Used when [FScriptText.TextLiteralType](./uassetapi.kismet.bytecode.fscripttext.md#textliteraltype) is [EBlueprintTextLiteralType.InvariantText](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md#invarianttext).

```csharp
public KismetExpression LocalizedNamespace;
```

### **InvariantLiteralString**

Value of this text if it is an invariant string literal. Used when [FScriptText.TextLiteralType](./uassetapi.kismet.bytecode.fscripttext.md#textliteraltype) is [EBlueprintTextLiteralType.InvariantText](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md#invarianttext).

```csharp
public KismetExpression InvariantLiteralString;
```

### **LiteralString**

Value of this text if it is a string literal. Used when [FScriptText.TextLiteralType](./uassetapi.kismet.bytecode.fscripttext.md#textliteraltype) is [EBlueprintTextLiteralType.LiteralString](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md#literalstring).

```csharp
public KismetExpression LiteralString;
```

### **StringTableAsset**

Pointer to this text's UStringTable. Not used at runtime, but exists for asset dependency gathering. Used when [FScriptText.TextLiteralType](./uassetapi.kismet.bytecode.fscripttext.md#textliteraltype) is [EBlueprintTextLiteralType.StringTableEntry](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md#stringtableentry).

```csharp
public FPackageIndex StringTableAsset;
```

### **StringTableId**

Table ID string literal (namespace). Used when [FScriptText.TextLiteralType](./uassetapi.kismet.bytecode.fscripttext.md#textliteraltype) is [EBlueprintTextLiteralType.StringTableEntry](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md#stringtableentry).

```csharp
public KismetExpression StringTableId;
```

### **StringTableKey**

String table key string literal. Used when [FScriptText.TextLiteralType](./uassetapi.kismet.bytecode.fscripttext.md#textliteraltype) is [EBlueprintTextLiteralType.StringTableEntry](./uassetapi.kismet.bytecode.eblueprinttextliteraltype.md#stringtableentry).

```csharp
public KismetExpression StringTableKey;
```

## Constructors

### **FScriptText()**

```csharp
public FScriptText()
```

## Methods

### **Read(AssetBinaryReader)**

Reads out an FBlueprintText from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes an FBlueprintText to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

```

`docs/src/api/uassetapi.kismet.bytecode.kismetexpression-1.md`:

```md
# KismetExpression&lt;T&gt;

Namespace: UAssetAPI.Kismet.Bytecode

```csharp
public abstract class KismetExpression<T> : KismetExpression
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md) → [KismetExpression&lt;T&gt;](./uassetapi.kismet.bytecode.kismetexpression-1.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Value**

The value of this expression if it is a constant.

```csharp
public T Value { get; set; }
```

#### Property Value

T<br>

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **KismetExpression()**

```csharp
public KismetExpression()
```

```

`docs/src/api/uassetapi.kismet.bytecode.kismetexpression.md`:

```md
# KismetExpression

Namespace: UAssetAPI.Kismet.Bytecode

A Kismet bytecode instruction.

```csharp
public class KismetExpression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)

## Fields

### **Tag**

An optional tag which can be set on any expression in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

### **RawValue**

```csharp
public object RawValue;
```

## Properties

### **Token**

The token of this expression.

```csharp
public EExprToken Token { get; }
```

#### Property Value

[EExprToken](./uassetapi.kismet.bytecode.eexprtoken.md)<br>

### **Inst**

The token of this instruction expressed as a string.

```csharp
public string Inst { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **KismetExpression()**

```csharp
public KismetExpression()
```

## Methods

### **SetObject(Object)**

```csharp
public void SetObject(object value)
```

#### Parameters

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **GetObject&lt;T&gt;()**

```csharp
public T GetObject<T>()
```

#### Type Parameters

`T`<br>

#### Returns

T<br>

### **Read(AssetBinaryReader)**

Reads out an expression from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **Write(AssetBinaryWriter)**

Writes an expression to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The iCode offset of the data that was written.

### **Visit(UAsset, UInt32&, Action&lt;KismetExpression, UInt32&gt;)**

Visits this expression and all child expressions, calling the visitor function for each with the in-memory offset.
 Note: The offset is the in-memory offset, not the serialization offset.

```csharp
public void Visit(UAsset asset, UInt32& offset, Action<KismetExpression, uint> visitor)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>
The asset containing this expression.

`offset` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>
Reference to the current in-memory offset, which is incremented as expressions are visited.

`visitor` [Action&lt;KismetExpression, UInt32&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.action-2)<br>
The visitor function to call for each expression with the expression and its offset.

### **GetSize(UAsset)**

Gets the in-memory size of this expression and all child expressions.

```csharp
public uint GetSize(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>
The asset containing this expression.

#### Returns

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>
The size in bytes of this expression.

```

`docs/src/api/uassetapi.kismet.bytecode.kismetpropertypointer.md`:

```md
# KismetPropertyPointer

Namespace: UAssetAPI.Kismet.Bytecode

Represents a Kismet bytecode pointer to an FProperty or FField.

```csharp
public class KismetPropertyPointer
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetPropertyPointer](./uassetapi.kismet.bytecode.kismetpropertypointer.md)

## Fields

### **Old**

The pointer serialized as an FPackageIndex. Used in versions older than [FReleaseObjectVersion.FFieldPathOwnerSerialization](./uassetapi.customversions.freleaseobjectversion.md#ffieldpathownerserialization).

```csharp
public FPackageIndex Old;
```

### **New**

The pointer serialized as an FFieldPath. Used in versions newer than [FReleaseObjectVersion.FFieldPathOwnerSerialization](./uassetapi.customversions.freleaseobjectversion.md#ffieldpathownerserialization).

```csharp
public FFieldPath New;
```

## Constructors

### **KismetPropertyPointer(FPackageIndex)**

```csharp
public KismetPropertyPointer(FPackageIndex older)
```

#### Parameters

`older` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **KismetPropertyPointer(FFieldPath)**

```csharp
public KismetPropertyPointer(FFieldPath newer)
```

#### Parameters

`newer` [FFieldPath](./uassetapi.unrealtypes.ffieldpath.md)<br>

### **KismetPropertyPointer()**

```csharp
public KismetPropertyPointer()
```

## Methods

### **ShouldSerializeOld()**

```csharp
public bool ShouldSerializeOld()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **ShouldSerializeNew()**

```csharp
public bool ShouldSerializeNew()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

```

`docs/src/api/uassetapi.kismet.kismetserializer.md`:

```md
# KismetSerializer

Namespace: UAssetAPI.Kismet

```csharp
public static class KismetSerializer
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [KismetSerializer](./uassetapi.kismet.kismetserializer.md)

## Fields

### **asset**

```csharp
public static UAsset asset;
```

## Methods

### **SerializeScript(KismetExpression[])**

```csharp
public static JArray SerializeScript(KismetExpression[] code)
```

#### Parameters

`code` [KismetExpression[]](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

#### Returns

JArray<br>

### **GetName(Int32)**

```csharp
public static string GetName(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **GetClassIndex()**

```csharp
public static int GetClassIndex()
```

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **GetFullName(Int32, Boolean)**

```csharp
public static string GetFullName(int index, bool alt)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`alt` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **GetParentName(Int32)**

```csharp
public static string GetParentName(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FindProperty(Int32, FName, FProperty&)**

```csharp
public static bool FindProperty(int index, FName propname, FProperty& property)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`propname` [FName](./uassetapi.unrealtypes.fname.md)<br>

`property` [FProperty&](./uassetapi.fieldtypes.fproperty&.md)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **GetPropertyCategoryInfo(FProperty)**

```csharp
public static FEdGraphPinType GetPropertyCategoryInfo(FProperty prop)
```

#### Parameters

`prop` [FProperty](./uassetapi.fieldtypes.fproperty.md)<br>

#### Returns

[FEdGraphPinType](./uassetapi.kismet.kismetserializer.fedgraphpintype.md)<br>

### **FillSimpleMemberReference(Int32)**

```csharp
public static FSimpleMemberReference FillSimpleMemberReference(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[FSimpleMemberReference](./uassetapi.kismet.kismetserializer.fsimplememberreference.md)<br>

### **SerializeGraphPinType(FEdGraphPinType)**

```csharp
public static JObject SerializeGraphPinType(FEdGraphPinType pin)
```

#### Parameters

`pin` [FEdGraphPinType](./uassetapi.kismet.kismetserializer.fedgraphpintype.md)<br>

#### Returns

JObject<br>

### **ConvertPropertyToPinType(FProperty)**

```csharp
public static FEdGraphPinType ConvertPropertyToPinType(FProperty property)
```

#### Parameters

`property` [FProperty](./uassetapi.fieldtypes.fproperty.md)<br>

#### Returns

[FEdGraphPinType](./uassetapi.kismet.kismetserializer.fedgraphpintype.md)<br>

### **SerializePropertyPointer(KismetPropertyPointer, String[])**

```csharp
public static JProperty[] SerializePropertyPointer(KismetPropertyPointer pointer, String[] names)
```

#### Parameters

`pointer` [KismetPropertyPointer](./uassetapi.kismet.bytecode.kismetpropertypointer.md)<br>

`names` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

JProperty[]<br>

### **SerializeExpression(KismetExpression, Int32&, Boolean)**

```csharp
public static JObject SerializeExpression(KismetExpression expression, Int32& index, bool addindex)
```

#### Parameters

`expression` [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

`index` [Int32&](https://docs.microsoft.com/en-us/dotnet/api/system.int32&)<br>

`addindex` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

JObject<br>

### **ReadString(KismetExpression, Int32&)**

```csharp
public static string ReadString(KismetExpression expr, Int32& index)
```

#### Parameters

`expr` [KismetExpression](./uassetapi.kismet.bytecode.kismetexpression.md)<br>

`index` [Int32&](https://docs.microsoft.com/en-us/dotnet/api/system.int32&)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.mainserializer.md`:

```md
# MainSerializer

Namespace: UAssetAPI

The main serializer for most property types in UAssetAPI.

```csharp
public static class MainSerializer
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [MainSerializer](./uassetapi.mainserializer.md)

## Fields

### **AdditionalPropertyRegistry**

```csharp
public static String[] AdditionalPropertyRegistry;
```

## Methods

### **GetNamesOfAssembliesReferencedBy(Assembly)**

```csharp
public static IEnumerable<string> GetNamesOfAssembliesReferencedBy(Assembly assembly)
```

#### Parameters

`assembly` [Assembly](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly)<br>

#### Returns

[IEnumerable&lt;String&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1)<br>

### **GenerateUnversionedHeader(List`1&, FName, FName, UAsset)**

Generates an unversioned header based on a list of properties, and sorts the list in the correct order to be serialized.

```csharp
public static FUnversionedHeader GenerateUnversionedHeader(List`1& data, FName parentName, FName parentModulePath, UAsset asset)
```

#### Parameters

`data` [List`1&](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1&)<br>
The list of properties to sort and generate an unversioned header from.

`parentName` [FName](./uassetapi.unrealtypes.fname.md)<br>
The name of the parent of all the properties.

`parentModulePath` [FName](./uassetapi.unrealtypes.fname.md)<br>
The path to the module that the parent class/struct of this property is contained within.

`asset` [UAsset](./uassetapi.uasset.md)<br>
The UAsset which the properties are contained within.

#### Returns

[FUnversionedHeader](./uassetapi.unversioned.funversionedheader.md)<br>

### **TypeToClass(FName, FName, AncestryInfo, FName, FName, UAsset, AssetBinaryReader, Int32, EPropertyTagFlags, Int32, Boolean, Boolean, FPropertyTypeName)**

Initializes the correct PropertyData class based off of serialized name, type, etc.

```csharp
public static PropertyData TypeToClass(FName type, FName name, AncestryInfo ancestry, FName parentName, FName parentModulePath, UAsset asset, AssetBinaryReader reader, int leng, EPropertyTagFlags propertyTagFlags, int ArrayIndex, bool includeHeader, bool isZero, FPropertyTypeName propertyTypeName)
```

#### Parameters

`type` [FName](./uassetapi.unrealtypes.fname.md)<br>
The serialized type of this property.

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>
The serialized name of this property.

`ancestry` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>
The ancestry of the parent of this property.

`parentName` [FName](./uassetapi.unrealtypes.fname.md)<br>
The name of the parent class/struct of this property.

`parentModulePath` [FName](./uassetapi.unrealtypes.fname.md)<br>
The path to the module that the parent class/struct of this property is contained within.

`asset` [UAsset](./uassetapi.uasset.md)<br>
The UAsset which this property is contained within.

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from. If left unspecified, you must call the [PropertyData.Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)](./uassetapi.propertytypes.objects.propertydata.md#readassetbinaryreader-boolean-int64-int64-propertyserializationcontext) method manually.

`leng` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The length of this property on disk in bytes.

`propertyTagFlags` [EPropertyTagFlags](./uassetapi.propertytypes.objects.epropertytagflags.md)<br>
Property tag flags, if available.

`ArrayIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The duplication index of this property.

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Does this property serialize its header in the current context?

`isZero` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Is the body of this property empty?

`propertyTypeName` [FPropertyTypeName](./uassetapi.unrealtypes.fpropertytypename.md)<br>
The complete property type name, if available.

#### Returns

[PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>
A new PropertyData instance based off of the passed parameters.

### **Read(AssetBinaryReader, AncestryInfo, FName, FName, FUnversionedHeader, Boolean)**

Reads a property into memory.

```csharp
public static PropertyData Read(AssetBinaryReader reader, AncestryInfo ancestry, FName parentName, FName parentModulePath, FUnversionedHeader header, bool includeHeader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from. The underlying stream should be at the position of the property to be read.

`ancestry` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>
The ancestry of the parent of this property.

`parentName` [FName](./uassetapi.unrealtypes.fname.md)<br>
The name of the parent class/struct of this property.

`parentModulePath` [FName](./uassetapi.unrealtypes.fname.md)<br>
The path to the module that the parent class/struct of this property is contained within.

`header` [FUnversionedHeader](./uassetapi.unversioned.funversionedheader.md)<br>
The unversioned header to be used when reading this property. Leave null if none exists.

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Does this property serialize its header in the current context?

#### Returns

[PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>
The property read from disk.

### **ReadFProperty(AssetBinaryReader)**

Reads an FProperty into memory. Primarily used as a part of [StructExport](./uassetapi.exporttypes.structexport.md) serialization.

```csharp
public static FProperty ReadFProperty(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from. The underlying stream should be at the position of the FProperty to be read.

#### Returns

[FProperty](./uassetapi.fieldtypes.fproperty.md)<br>
The FProperty read from disk.

### **WriteFProperty(FProperty, AssetBinaryWriter)**

Serializes an FProperty from memory.

```csharp
public static void WriteFProperty(FProperty prop, AssetBinaryWriter writer)
```

#### Parameters

`prop` [FProperty](./uassetapi.fieldtypes.fproperty.md)<br>
The FProperty to serialize.

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to serialize the FProperty to.

### **ReadUProperty(AssetBinaryReader, FName)**

Reads a UProperty into memory. Primarily used as a part of [PropertyExport](./uassetapi.exporttypes.propertyexport.md) serialization.

```csharp
public static UProperty ReadUProperty(AssetBinaryReader reader, FName serializedType)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from. The underlying stream should be at the position of the UProperty to be read.

`serializedType` [FName](./uassetapi.unrealtypes.fname.md)<br>
The type of UProperty to be read.

#### Returns

[UProperty](./uassetapi.fieldtypes.uproperty.md)<br>
The FProperty read from disk.

### **ReadUProperty(AssetBinaryReader, Type)**

Reads a UProperty into memory. Primarily used as a part of [PropertyExport](./uassetapi.exporttypes.propertyexport.md) serialization.

```csharp
public static UProperty ReadUProperty(AssetBinaryReader reader, Type requestedType)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from. The underlying stream should be at the position of the UProperty to be read.

`requestedType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>
The type of UProperty to be read.

#### Returns

[UProperty](./uassetapi.fieldtypes.uproperty.md)<br>
The FProperty read from disk.

### **ReadUProperty&lt;T&gt;(AssetBinaryReader)**

Reads a UProperty into memory. Primarily used as a part of [PropertyExport](./uassetapi.exporttypes.propertyexport.md) serialization.

```csharp
public static T ReadUProperty<T>(AssetBinaryReader reader)
```

#### Type Parameters

`T`<br>

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from. The underlying stream should be at the position of the UProperty to be read.

#### Returns

T<br>
The FProperty read from disk.

### **WriteUProperty(UProperty, AssetBinaryWriter)**

Serializes a UProperty from memory.

```csharp
public static void WriteUProperty(UProperty prop, AssetBinaryWriter writer)
```

#### Parameters

`prop` [UProperty](./uassetapi.fieldtypes.uproperty.md)<br>
The UProperty to serialize.

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to serialize the UProperty to.

### **Write(PropertyData, AssetBinaryWriter, Boolean)**

Serializes a property from memory.

```csharp
public static int Write(PropertyData property, AssetBinaryWriter writer, bool includeHeader)
```

#### Parameters

`property` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>
The property to serialize.

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to serialize the property to.

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Does this property serialize its header in the current context?

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The serial offset where the length of the property is stored.

```

`docs/src/api/uassetapi.namemapoutofrangeexception.md`:

```md
# NameMapOutOfRangeException

Namespace: UAssetAPI

```csharp
public class NameMapOutOfRangeException : System.FormatException, System.Runtime.Serialization.ISerializable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Exception](https://docs.microsoft.com/en-us/dotnet/api/system.exception) → [SystemException](https://docs.microsoft.com/en-us/dotnet/api/system.systemexception) → [FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception) → [NameMapOutOfRangeException](./uassetapi.namemapoutofrangeexception.md)<br>
Implements [ISerializable](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.iserializable)

## Fields

### **RequiredName**

```csharp
public FString RequiredName;
```

## Properties

### **TargetSite**

```csharp
public MethodBase TargetSite { get; }
```

#### Property Value

[MethodBase](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase)<br>

### **Message**

```csharp
public string Message { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Data**

```csharp
public IDictionary Data { get; }
```

#### Property Value

[IDictionary](https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary)<br>

### **InnerException**

```csharp
public Exception InnerException { get; }
```

#### Property Value

[Exception](https://docs.microsoft.com/en-us/dotnet/api/system.exception)<br>

### **HelpLink**

```csharp
public string HelpLink { get; set; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Source**

```csharp
public string Source { get; set; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **HResult**

```csharp
public int HResult { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **StackTrace**

```csharp
public string StackTrace { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **NameMapOutOfRangeException(FString)**

```csharp
public NameMapOutOfRangeException(FString requiredName)
```

#### Parameters

`requiredName` [FString](./uassetapi.unrealtypes.fstring.md)<br>

```

`docs/src/api/uassetapi.pakbuilder.md`:

```md
# PakBuilder

Namespace: UAssetAPI

```csharp
public class PakBuilder : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid, System.IDisposable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [CriticalFinalizerObject](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.constrainedexecution.criticalfinalizerobject) → [SafeHandle](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle) → [SafeHandleZeroOrMinusOneIsInvalid](https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.safehandles.safehandlezeroorminusoneisinvalid) → [PakBuilder](./uassetapi.pakbuilder.md)<br>
Implements [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable)

## Properties

### **IsInvalid**

```csharp
public bool IsInvalid { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IsClosed**

```csharp
public bool IsClosed { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **PakBuilder()**

```csharp
public PakBuilder()
```

## Methods

### **ReleaseHandle()**

```csharp
protected bool ReleaseHandle()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Key(Byte[])**

```csharp
public PakBuilder Key(Byte[] key)
```

#### Parameters

`key` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

#### Returns

[PakBuilder](./uassetapi.pakbuilder.md)<br>

### **Compression(PakCompression[])**

```csharp
public PakBuilder Compression(PakCompression[] compressions)
```

#### Parameters

`compressions` [PakCompression[]](./uassetapi.pakcompression.md)<br>

#### Returns

[PakBuilder](./uassetapi.pakbuilder.md)<br>

### **Writer(Stream, PakVersion, String, UInt64)**

```csharp
public PakWriter Writer(Stream stream, PakVersion version, string mountPoint, ulong pathHashSeed)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`version` [PakVersion](./uassetapi.pakversion.md)<br>

`mountPoint` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`pathHashSeed` [UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

#### Returns

[PakWriter](./uassetapi.pakwriter.md)<br>

### **Reader(Stream)**

```csharp
public PakReader Reader(Stream stream)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

#### Returns

[PakReader](./uassetapi.pakreader.md)<br>

```

`docs/src/api/uassetapi.pakcompression.md`:

```md
# PakCompression

Namespace: UAssetAPI

```csharp
public enum PakCompression
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [PakCompression](./uassetapi.pakcompression.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.pakreader.md`:

```md
# PakReader

Namespace: UAssetAPI

```csharp
public class PakReader : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid, System.IDisposable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [CriticalFinalizerObject](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.constrainedexecution.criticalfinalizerobject) → [SafeHandle](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle) → [SafeHandleZeroOrMinusOneIsInvalid](https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.safehandles.safehandlezeroorminusoneisinvalid) → [PakReader](./uassetapi.pakreader.md)<br>
Implements [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable)

## Properties

### **IsInvalid**

```csharp
public bool IsInvalid { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IsClosed**

```csharp
public bool IsClosed { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **PakReader(IntPtr, Stream)**

```csharp
public PakReader(IntPtr handle, Stream stream)
```

#### Parameters

`handle` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

## Methods

### **ReleaseHandle()**

```csharp
protected bool ReleaseHandle()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **GetMountPoint()**

```csharp
public string GetMountPoint()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **GetVersion()**

```csharp
public PakVersion GetVersion()
```

#### Returns

[PakVersion](./uassetapi.pakversion.md)<br>

### **Get(Stream, String)**

```csharp
public Byte[] Get(Stream stream, string path)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **Files()**

```csharp
public String[] Files()
```

#### Returns

[String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.pakversion.md`:

```md
# PakVersion

Namespace: UAssetAPI

```csharp
public enum PakVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [PakVersion](./uassetapi.pakversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.pakwriter.md`:

```md
# PakWriter

Namespace: UAssetAPI

```csharp
public class PakWriter : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid, System.IDisposable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [CriticalFinalizerObject](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.constrainedexecution.criticalfinalizerobject) → [SafeHandle](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle) → [SafeHandleZeroOrMinusOneIsInvalid](https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.safehandles.safehandlezeroorminusoneisinvalid) → [PakWriter](./uassetapi.pakwriter.md)<br>
Implements [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable)

## Properties

### **IsInvalid**

```csharp
public bool IsInvalid { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IsClosed**

```csharp
public bool IsClosed { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **PakWriter(IntPtr, IntPtr)**

```csharp
public PakWriter(IntPtr handle, IntPtr streamCtx)
```

#### Parameters

`handle` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`streamCtx` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

## Methods

### **ReleaseHandle()**

```csharp
protected bool ReleaseHandle()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **WriteFile(String, Byte[])**

```csharp
public void WriteFile(string path, Byte[] data)
```

#### Parameters

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`data` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **WriteIndex()**

```csharp
public void WriteIndex()
```

```

`docs/src/api/uassetapi.propertytypes.objects.ancestryinfo.md`:

```md
# AncestryInfo

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public class AncestryInfo : System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Ancestors**

```csharp
public List<FName> Ancestors;
```

## Properties

### **Parent**

```csharp
public FName Parent { get; set; }
```

#### Property Value

[FName](./uassetapi.unrealtypes.fname.md)<br>

## Constructors

### **AncestryInfo()**

```csharp
public AncestryInfo()
```

## Methods

### **Clone()**

```csharp
public object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **CloneWithoutParent()**

```csharp
public AncestryInfo CloneWithoutParent()
```

#### Returns

[AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Initialize(AncestryInfo, FName, FName)**

```csharp
public void Initialize(AncestryInfo ancestors, FName dad, FName modulePath)
```

#### Parameters

`ancestors` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

`dad` [FName](./uassetapi.unrealtypes.fname.md)<br>

`modulePath` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SetAsParent(FName, FName)**

```csharp
public void SetAsParent(FName dad, FName modulePath)
```

#### Parameters

`dad` [FName](./uassetapi.unrealtypes.fname.md)<br>

`modulePath` [FName](./uassetapi.unrealtypes.fname.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.arraypropertydata.md`:

```md
# ArrayPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes an array.

```csharp
public class ArrayPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;PropertyData[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [ArrayPropertyData](./uassetapi.propertytypes.objects.arraypropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **ArrayType**

```csharp
public FName ArrayType;
```

### **DummyStruct**

```csharp
public StructPropertyData DummyStruct;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public PropertyData[] Value { get; set; }
```

#### Property Value

[PropertyData[]](./uassetapi.propertytypes.objects.propertydata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ArrayPropertyData(FName)**

```csharp
public ArrayPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ArrayPropertyData()**

```csharp
public ArrayPropertyData()
```

## Methods

### **ShouldSerializeDummyStruct()**

```csharp
public bool ShouldSerializeDummyStruct()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.assetobjectpropertydata.md`:

```md
# AssetObjectPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a reference variable to another object which may be null, and may become valid or invalid at any point. Near synonym for [SoftObjectPropertyData](./uassetapi.propertytypes.objects.softobjectpropertydata.md).

```csharp
public class AssetObjectPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FString&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [AssetObjectPropertyData](./uassetapi.propertytypes.objects.assetobjectpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **ID**

```csharp
public uint ID;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FString Value { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **AssetObjectPropertyData(FName)**

```csharp
public AssetObjectPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **AssetObjectPropertyData()**

```csharp
public AssetObjectPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.boolpropertydata.md`:

```md
# BoolPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a boolean ([Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)).

```csharp
public class BoolPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Boolean&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BoolPropertyData](./uassetapi.propertytypes.objects.boolpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public bool Value { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **BoolPropertyData(FName)**

```csharp
public BoolPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **BoolPropertyData()**

```csharp
public BoolPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.bytepropertydata.md`:

```md
# BytePropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a byte or an enumeration value.

```csharp
public class BytePropertyData : PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [BytePropertyData](./uassetapi.propertytypes.objects.bytepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **ByteType**

```csharp
public BytePropertyType ByteType;
```

### **EnumType**

```csharp
public FName EnumType;
```

### **Value**

```csharp
public byte Value;
```

### **EnumValue**

```csharp
public FName EnumValue;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **BytePropertyData(FName)**

```csharp
public BytePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **BytePropertyData()**

```csharp
public BytePropertyData()
```

## Methods

### **ShouldSerializeValue()**

```csharp
public bool ShouldSerializeValue()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **ShouldSerializeEnumValue()**

```csharp
public bool ShouldSerializeEnumValue()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **GetEnumBase()**

```csharp
public FName GetEnumBase()
```

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **GetEnumFull()**

```csharp
public FName GetEnumFull()
```

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.bytepropertytype.md`:

```md
# BytePropertyType

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public enum BytePropertyType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [BytePropertyType](./uassetapi.propertytypes.objects.bytepropertytype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.objects.delegatepropertydata.md`:

```md
# DelegatePropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a function bound to an Object.

```csharp
public class DelegatePropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FDelegate&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [DelegatePropertyData](./uassetapi.propertytypes.objects.delegatepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FDelegate Value { get; set; }
```

#### Property Value

[FDelegate](./uassetapi.propertytypes.objects.fdelegate.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **DelegatePropertyData(FName)**

```csharp
public DelegatePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **DelegatePropertyData()**

```csharp
public DelegatePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.doublepropertydata.md`:

```md
# DoublePropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes an IEEE 64-bit floating point variable ([Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)).

```csharp
public class DoublePropertyData : PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [DoublePropertyData](./uassetapi.propertytypes.objects.doublepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **Value**

The double that this property represents.

```csharp
public double Value { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **DoublePropertyData(FName)**

```csharp
public DoublePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **DoublePropertyData()**

```csharp
public DoublePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.enumpropertydata.md`:

```md
# EnumPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes an enumeration value.

```csharp
public class EnumPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FName&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [EnumPropertyData](./uassetapi.propertytypes.objects.enumpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **EnumType**

```csharp
public FName EnumType;
```

### **InnerType**

Only used with unversioned properties.

```csharp
public FName InnerType;
```

### **InvalidEnumIndexFallbackPrefix**

```csharp
public static string InvalidEnumIndexFallbackPrefix;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FName Value { get; set; }
```

#### Property Value

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **EnumPropertyData(FName)**

```csharp
public EnumPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **EnumPropertyData()**

```csharp
public EnumPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **InitializeZero(AssetBinaryReader)**

```csharp
internal void InitializeZero(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.eoverriddenpropertyoperation.md`:

```md
# EOverriddenPropertyOperation

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public enum EOverriddenPropertyOperation
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EOverriddenPropertyOperation](./uassetapi.propertytypes.objects.eoverriddenpropertyoperation.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| None | 0 | no overridden operation was recorded on this property |
| Modified | 1 | some sub property has recorded overridden operation |
| Replace | 2 | everything has been overridden from this property down to every sub property/sub object |
| Add | 3 | this element was added in the container |
| Remove | 4 | this element was removed from the container |

```

`docs/src/api/uassetapi.propertytypes.objects.epropertytagextension.md`:

```md
# EPropertyTagExtension

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public enum EPropertyTagExtension
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPropertyTagExtension](./uassetapi.propertytypes.objects.epropertytagextension.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.objects.epropertytagflags.md`:

```md
# EPropertyTagFlags

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public enum EPropertyTagFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPropertyTagFlags](./uassetapi.propertytypes.objects.epropertytagflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.objects.etextflag.md`:

```md
# ETextFlag

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public enum ETextFlag
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextFlag](./uassetapi.propertytypes.objects.etextflag.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.objects.etransformtype.md`:

```md
# ETransformType

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public enum ETransformType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETransformType](./uassetapi.propertytypes.objects.etransformtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.objects.fdelegate.md`:

```md
# FDelegate

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a function bound to an Object.

```csharp
public class FDelegate
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FDelegate](./uassetapi.propertytypes.objects.fdelegate.md)

## Fields

### **Object**

References the main actor export

```csharp
public FPackageIndex Object;
```

### **Delegate**

The name of the delegate

```csharp
public FName Delegate;
```

## Constructors

### **FDelegate(FPackageIndex, FName)**

```csharp
public FDelegate(FPackageIndex _object, FName delegate)
```

#### Parameters

`_object` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

`delegate` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **FDelegate()**

```csharp
public FDelegate()
```

### **FDelegate(AssetBinaryReader)**

```csharp
public FDelegate(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.fformatargumentdata.md`:

```md
# FFormatArgumentData

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public class FFormatArgumentData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FFormatArgumentData](./uassetapi.propertytypes.objects.fformatargumentdata.md)

## Fields

### **ArgumentName**

```csharp
public FString ArgumentName;
```

### **ArgumentValue**

```csharp
public FFormatArgumentValue ArgumentValue;
```

## Constructors

### **FFormatArgumentData()**

```csharp
public FFormatArgumentData()
```

### **FFormatArgumentData(FString, FFormatArgumentValue)**

```csharp
public FFormatArgumentData(FString name, FFormatArgumentValue value)
```

#### Parameters

`name` [FString](./uassetapi.unrealtypes.fstring.md)<br>

`value` [FFormatArgumentValue](./uassetapi.propertytypes.objects.fformatargumentvalue.md)<br>

### **FFormatArgumentData(AssetBinaryReader)**

```csharp
public FFormatArgumentData(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.fformatargumentvalue.md`:

```md
# FFormatArgumentValue

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public class FFormatArgumentValue
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FFormatArgumentValue](./uassetapi.propertytypes.objects.fformatargumentvalue.md)

## Fields

### **Type**

```csharp
public EFormatArgumentType Type;
```

### **Value**

```csharp
public object Value;
```

## Constructors

### **FFormatArgumentValue()**

```csharp
public FFormatArgumentValue()
```

### **FFormatArgumentValue(EFormatArgumentType, Object)**

```csharp
public FFormatArgumentValue(EFormatArgumentType type, object value)
```

#### Parameters

`type` [EFormatArgumentType](./uassetapi.unrealtypes.engineenums.eformatargumenttype.md)<br>

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **FFormatArgumentValue(AssetBinaryReader, Boolean)**

```csharp
public FFormatArgumentValue(AssetBinaryReader reader, bool isArgumentData)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`isArgumentData` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Methods

### **Write(AssetBinaryWriter, Boolean)**

```csharp
public int Write(AssetBinaryWriter writer, bool isArgumentData)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`isArgumentData` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.fieldpathpropertydata.md`:

```md
# FieldPathPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a reference variable to another object which may be null, and may become valid or invalid at any point. Near synonym for [SoftObjectPropertyData](./uassetapi.propertytypes.objects.softobjectpropertydata.md).

```csharp
public class FieldPathPropertyData : BasePropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FFieldPath&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FFieldPath&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [FieldPathPropertyData](./uassetapi.propertytypes.objects.fieldpathpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FFieldPath Value { get; set; }
```

#### Property Value

[FFieldPath](./uassetapi.unrealtypes.ffieldpath.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FieldPathPropertyData(FName)**

```csharp
public FieldPathPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **FieldPathPropertyData()**

```csharp
public FieldPathPropertyData()
```

## Methods

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.floatpropertydata.md`:

```md
# FloatPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes an IEEE 32-bit floating point variable ([Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)).

```csharp
public class FloatPropertyData : PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [FloatPropertyData](./uassetapi.propertytypes.objects.floatpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **Value**

The float that this property represents.

```csharp
public float Value { get; set; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FloatPropertyData(FName)**

```csharp
public FloatPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **FloatPropertyData()**

```csharp
public FloatPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.fnumberformattingoptions.md`:

```md
# FNumberFormattingOptions

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public class FNumberFormattingOptions
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FNumberFormattingOptions](./uassetapi.propertytypes.objects.fnumberformattingoptions.md)

## Fields

### **AlwaysSign**

```csharp
public bool AlwaysSign;
```

### **UseGrouping**

```csharp
public bool UseGrouping;
```

### **RoundingMode**

```csharp
public ERoundingMode RoundingMode;
```

### **MinimumIntegralDigits**

```csharp
public int MinimumIntegralDigits;
```

### **MaximumIntegralDigits**

```csharp
public int MaximumIntegralDigits;
```

### **MinimumFractionalDigits**

```csharp
public int MinimumFractionalDigits;
```

### **MaximumFractionalDigits**

```csharp
public int MaximumFractionalDigits;
```

## Constructors

### **FNumberFormattingOptions()**

```csharp
public FNumberFormattingOptions()
```

### **FNumberFormattingOptions(AssetBinaryReader)**

```csharp
public FNumberFormattingOptions(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.fsoftobjectpath.md`:

```md
# FSoftObjectPath

Namespace: UAssetAPI.PropertyTypes.Objects

A reference variable to another object which may be null, and may become valid or invalid at any point.

```csharp
public struct FSoftObjectPath
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>
Implements [IEquatable&lt;FSoftObjectPath&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.iequatable-1), [IStruct&lt;FSoftObjectPath&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **AssetPath**

Asset path, patch to a top level object in a package. This is /package/path.assetname/

```csharp
public FTopLevelAssetPath AssetPath;
```

### **SubPathString**

Optional FString for subobject within an asset. This is the sub path after the :

```csharp
public FString SubPathString;
```

## Constructors

### **FSoftObjectPath(FName, FName, FString)**

```csharp
FSoftObjectPath(FName packageName, FName assetName, FString subPathString)
```

#### Parameters

`packageName` [FName](./uassetapi.unrealtypes.fname.md)<br>

`assetName` [FName](./uassetapi.unrealtypes.fname.md)<br>

`subPathString` [FString](./uassetapi.unrealtypes.fstring.md)<br>

### **FSoftObjectPath(FTopLevelAssetPath, FString)**

```csharp
FSoftObjectPath(FTopLevelAssetPath assetPath, FString subPathString)
```

#### Parameters

`assetPath` [FTopLevelAssetPath](./uassetapi.propertytypes.objects.ftoplevelassetpath.md)<br>

`subPathString` [FString](./uassetapi.unrealtypes.fstring.md)<br>

### **FSoftObjectPath(AssetBinaryReader, Boolean)**

```csharp
FSoftObjectPath(AssetBinaryReader reader, bool allowIndex)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`allowIndex` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FSoftObjectPath Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

### **Write(AssetBinaryWriter, Boolean)**

```csharp
int Write(AssetBinaryWriter writer, bool allowIndex)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`allowIndex` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Equals(FSoftObjectPath)**

```csharp
bool Equals(FSoftObjectPath other)
```

#### Parameters

`other` [FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Equals(Object)**

```csharp
bool Equals(object obj)
```

#### Parameters

`obj` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **GetHashCode()**

```csharp
int GetHashCode()
```

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FSoftObjectPath FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.ftoplevelassetpath.md`:

```md
# FTopLevelAssetPath

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public struct FTopLevelAssetPath
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FTopLevelAssetPath](./uassetapi.propertytypes.objects.ftoplevelassetpath.md)

## Fields

### **PackageName**

Name of the package containing the asset e.g. /Path/To/Package
 If less than 5.1, this is null

```csharp
public FName PackageName;
```

### **AssetName**

Name of the asset within the package e.g. 'AssetName'.
 If less than 5.1, this contains the full path instead

```csharp
public FName AssetName;
```

## Constructors

### **FTopLevelAssetPath(FName, FName)**

```csharp
FTopLevelAssetPath(FName packageName, FName assetName)
```

#### Parameters

`packageName` [FName](./uassetapi.unrealtypes.fname.md)<br>

`assetName` [FName](./uassetapi.unrealtypes.fname.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.int16propertydata.md`:

```md
# Int16PropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a 16-bit signed integer variable ([Int16](https://docs.microsoft.com/en-us/dotnet/api/system.int16)).

```csharp
public class Int16PropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Int16&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [Int16PropertyData](./uassetapi.propertytypes.objects.int16propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public short Value { get; set; }
```

#### Property Value

[Int16](https://docs.microsoft.com/en-us/dotnet/api/system.int16)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **Int16PropertyData(FName)**

```csharp
public Int16PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Int16PropertyData()**

```csharp
public Int16PropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.int64propertydata.md`:

```md
# Int64PropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a 64-bit signed integer variable ([Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)).

```csharp
public class Int64PropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Int64&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [Int64PropertyData](./uassetapi.propertytypes.objects.int64propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public long Value { get; set; }
```

#### Property Value

[Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **Int64PropertyData(FName)**

```csharp
public Int64PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Int64PropertyData()**

```csharp
public Int64PropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.int8propertydata.md`:

```md
# Int8PropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes an 8-bit signed integer variable ([SByte](https://docs.microsoft.com/en-us/dotnet/api/system.sbyte)).

```csharp
public class Int8PropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;SByte&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [Int8PropertyData](./uassetapi.propertytypes.objects.int8propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public sbyte Value { get; set; }
```

#### Property Value

[SByte](https://docs.microsoft.com/en-us/dotnet/api/system.sbyte)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **Int8PropertyData(FName)**

```csharp
public Int8PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Int8PropertyData()**

```csharp
public Int8PropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.interfacepropertydata.md`:

```md
# InterfacePropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a reference variable to another object (import/export) which may be null ([FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)).

```csharp
public class InterfacePropertyData : ObjectPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FPackageIndex&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [ObjectPropertyData](./uassetapi.propertytypes.objects.objectpropertydata.md) → [InterfacePropertyData](./uassetapi.propertytypes.objects.interfacepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FPackageIndex Value { get; set; }
```

#### Property Value

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **InterfacePropertyData(FName)**

```csharp
public InterfacePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **InterfacePropertyData()**

```csharp
public InterfacePropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.objects.intpropertydata.md`:

```md
# IntPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a 32-bit signed integer variable ([Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)).

```csharp
public class IntPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Int32&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [IntPropertyData](./uassetapi.propertytypes.objects.intpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public int Value { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **IntPropertyData(FName)**

```csharp
public IntPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **IntPropertyData()**

```csharp
public IntPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.istruct-1.md`:

```md
# IStruct&lt;T&gt;

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public interface IStruct<T>
```

#### Type Parameters

`T`<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
T Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

T<br>

### **FromString(String[], UAsset)**

```csharp
T FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

T<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.mappropertydata.md`:

```md
# MapPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a map.

```csharp
public class MapPropertyData : PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [MapPropertyData](./uassetapi.propertytypes.objects.mappropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Value**

The map that this property represents.

```csharp
public TMap<PropertyData, PropertyData> Value;
```

### **KeyType**

Used when the length of the map is zero.

```csharp
public FName KeyType;
```

### **ValueType**

Used when the length of the map is zero.

```csharp
public FName ValueType;
```

### **KeysToRemove**

```csharp
public PropertyData[] KeysToRemove;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MapPropertyData(FName)**

```csharp
public MapPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MapPropertyData()**

```csharp
public MapPropertyData()
```

## Methods

### **ShouldSerializeKeyType()**

```csharp
public bool ShouldSerializeKeyType()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **ShouldSerializeValueType()**

```csharp
public bool ShouldSerializeValueType()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.multicastdelegatepropertydata.md`:

```md
# MulticastDelegatePropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a list of functions bound to an Object.

```csharp
public class MulticastDelegatePropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FDelegate[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MulticastDelegatePropertyData](./uassetapi.propertytypes.objects.multicastdelegatepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FDelegate[] Value { get; set; }
```

#### Property Value

[FDelegate[]](./uassetapi.propertytypes.objects.fdelegate.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MulticastDelegatePropertyData(FName)**

```csharp
public MulticastDelegatePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MulticastDelegatePropertyData()**

```csharp
public MulticastDelegatePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.multicastinlinedelegatepropertydata.md`:

```md
# MulticastInlineDelegatePropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a list of functions bound to an Object.

```csharp
public class MulticastInlineDelegatePropertyData : MulticastDelegatePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FDelegate[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MulticastDelegatePropertyData](./uassetapi.propertytypes.objects.multicastdelegatepropertydata.md) → [MulticastInlineDelegatePropertyData](./uassetapi.propertytypes.objects.multicastinlinedelegatepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FDelegate[] Value { get; set; }
```

#### Property Value

[FDelegate[]](./uassetapi.propertytypes.objects.fdelegate.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MulticastInlineDelegatePropertyData(FName)**

```csharp
public MulticastInlineDelegatePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MulticastInlineDelegatePropertyData()**

```csharp
public MulticastInlineDelegatePropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.objects.multicastsparsedelegatepropertydata.md`:

```md
# MulticastSparseDelegatePropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a list of functions bound to an Object.

```csharp
public class MulticastSparseDelegatePropertyData : MulticastDelegatePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FDelegate[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MulticastDelegatePropertyData](./uassetapi.propertytypes.objects.multicastdelegatepropertydata.md) → [MulticastSparseDelegatePropertyData](./uassetapi.propertytypes.objects.multicastsparsedelegatepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FDelegate[] Value { get; set; }
```

#### Property Value

[FDelegate[]](./uassetapi.propertytypes.objects.fdelegate.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MulticastSparseDelegatePropertyData(FName)**

```csharp
public MulticastSparseDelegatePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MulticastSparseDelegatePropertyData()**

```csharp
public MulticastSparseDelegatePropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.objects.namepropertydata.md`:

```md
# NamePropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes an [FName](./uassetapi.unrealtypes.fname.md).

```csharp
public class NamePropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FName&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [NamePropertyData](./uassetapi.propertytypes.objects.namepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FName Value { get; set; }
```

#### Property Value

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **NamePropertyData(FName)**

```csharp
public NamePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NamePropertyData()**

```csharp
public NamePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **CanBeZero(UAsset)**

```csharp
public bool CanBeZero(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.objectpropertydata.md`:

```md
# ObjectPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a reference variable to another object (import/export) which may be null ([FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)).

```csharp
public class ObjectPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FPackageIndex&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [ObjectPropertyData](./uassetapi.propertytypes.objects.objectpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FPackageIndex Value { get; set; }
```

#### Property Value

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **ObjectPropertyData(FName)**

```csharp
public ObjectPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ObjectPropertyData()**

```csharp
public ObjectPropertyData()
```

## Methods

### **IsImport()**

Returns true if this ObjectProperty represents an import.

```csharp
public bool IsImport()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Is this ObjectProperty an import?

### **IsExport()**

Returns true if this ObjectProperty represents an export.

```csharp
public bool IsExport()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Is this ObjectProperty an export?

### **IsNull()**

Return true if this ObjectProperty represents null (i.e. neither an import nor an export)

```csharp
public bool IsNull()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Does this ObjectProperty represent null?

### **ToImport(UAsset)**

Check that this ObjectProperty is an import index and return the corresponding import.

```csharp
public Import ToImport(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[Import](./uassetapi.import.md)<br>
The import that this ObjectProperty represents in the import map.

#### Exceptions

[InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)<br>
Thrown when this is not an index into the import map.

### **ToExport(UAsset)**

Check that this ObjectProperty is an export index and return the corresponding export.

```csharp
public Export ToExport(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[Export](./uassetapi.exporttypes.export.md)<br>
The export that this ObjectProperty represents in the the export map.

#### Exceptions

[InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)<br>
Thrown when this is not an index into the export map.

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.propertydata-1.md`:

```md
# PropertyData&lt;T&gt;

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public abstract class PropertyData<T> : PropertyData, System.ICloneable
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;T&gt;](./uassetapi.propertytypes.objects.propertydata-1.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public T Value { get; set; }
```

#### Property Value

T<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

The type of this property as an FString.

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PropertyData(FName)**

```csharp
public PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PropertyData()**

```csharp
public PropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.objects.propertydata.md`:

```md
# PropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Generic Unreal property class.

```csharp
public abstract class PropertyData : System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

The type of this property as an FString.

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PropertyData(FName)**

```csharp
public PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PropertyData()**

```csharp
public PropertyData()
```

## Methods

### **ShouldSerializeOverrideOperation()**

```csharp
public bool ShouldSerializeOverrideOperation()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **ShouldSerializebExperimentalOverridableLogic()**

```csharp
public bool ShouldSerializebExperimentalOverridableLogic()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **SetObject(Object)**

```csharp
public void SetObject(object value)
```

#### Parameters

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **GetObject&lt;T&gt;()**

```csharp
public T GetObject<T>()
```

#### Type Parameters

`T`<br>

#### Returns

T<br>

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

Reads out a property from a BinaryReader.

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not to also read the "header" of the property, which is data considered by the Unreal Engine to be data that is part of the PropertyData base class rather than any particular child class.

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>
An estimate for the length of the data being read out.

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>
A second estimate for the length of the data being read out.

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>
The context in which this property is being read.

### **ResolveAncestries(UAsset, AncestryInfo)**

Resolves the ancestry of all child properties of this property.

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **ReadEndPropertyTag(AssetBinaryReader)**

Complete reading the property tag of this property.

```csharp
protected void ReadEndPropertyTag(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

Writes a property to a BinaryWriter.

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>
The BinaryWriter to write from.

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not to also write the "header" of the property, which is data considered by the Unreal Engine to be data that is part of the PropertyData base class rather than any particular child class.

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>
The context in which this property is being written.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The length in bytes of the data that was written.

### **InitializeZero(AssetBinaryReader)**

Initialize this property when serialized as zero.

```csharp
internal void InitializeZero(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The BinaryReader to read from.

### **WriteEndPropertyTag(AssetBinaryWriter)**

Complete writing the property tag of this property.

```csharp
protected void WriteEndPropertyTag(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

### **CanBeZero(UAsset)**

Does the body of this property entirely consist of null bytes? If so, the body can be skipped during serialization in unversioned properties.

```csharp
public bool CanBeZero(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>
The asset to test serialization within.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not the property can be serialized as zero.

### **FromString(String[], UAsset)**

Sets certain fields of the property based off of an array of strings.

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
An array of strings to derive certain fields from.

`asset` [UAsset](./uassetapi.uasset.md)<br>
The asset that the property belongs to.

### **Clone()**

Performs a deep clone of the current PropertyData instance.

```csharp
public object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>
A deep copy of the current property.

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.propertyserializationcontext.md`:

```md
# PropertySerializationContext

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public enum PropertySerializationContext
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.objects.setpropertydata.md`:

```md
# SetPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a set.

```csharp
public class SetPropertyData : ArrayPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;PropertyData[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [ArrayPropertyData](./uassetapi.propertytypes.objects.arraypropertydata.md) → [SetPropertyData](./uassetapi.propertytypes.objects.setpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **ElementsToRemove**

```csharp
public PropertyData[] ElementsToRemove;
```

### **ArrayType**

```csharp
public FName ArrayType;
```

### **DummyStruct**

```csharp
public StructPropertyData DummyStruct;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public PropertyData[] Value { get; set; }
```

#### Property Value

[PropertyData[]](./uassetapi.propertytypes.objects.propertydata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SetPropertyData(FName)**

```csharp
public SetPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SetPropertyData()**

```csharp
public SetPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.softobjectpropertydata.md`:

```md
# SoftObjectPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a reference variable to another object which may be null, and may become valid or invalid at any point. Near synonym for [AssetObjectPropertyData](./uassetapi.propertytypes.objects.assetobjectpropertydata.md).

```csharp
public class SoftObjectPropertyData : BasePropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FSoftObjectPath&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FSoftObjectPath&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [SoftObjectPropertyData](./uassetapi.propertytypes.objects.softobjectpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FSoftObjectPath Value { get; set; }
```

#### Property Value

[FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SoftObjectPropertyData(FName)**

```csharp
public SoftObjectPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SoftObjectPropertyData()**

```csharp
public SoftObjectPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.objects.strpropertydata.md`:

```md
# StrPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes an [FString](./uassetapi.unrealtypes.fstring.md).

```csharp
public class StrPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FString&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StrPropertyData](./uassetapi.propertytypes.objects.strpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FString Value { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **StrPropertyData(FName)**

```csharp
public StrPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **StrPropertyData()**

```csharp
public StrPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.texthistorytype.md`:

```md
# TextHistoryType

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public enum TextHistoryType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [TextHistoryType](./uassetapi.propertytypes.objects.texthistorytype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.objects.textpropertydata.md`:

```md
# TextPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes an FText.

```csharp
public class TextPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FString&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TextPropertyData](./uassetapi.propertytypes.objects.textpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Flags**

Flags with various information on what sort of FText this is

```csharp
public ETextFlag Flags;
```

### **HistoryType**

The HistoryType of this FText.

```csharp
public TextHistoryType HistoryType;
```

### **TableId**

The string table ID being referenced, if applicable

```csharp
public FName TableId;
```

### **Namespace**

A namespace to use when parsing texts that use LOCTEXT

```csharp
public FString Namespace;
```

### **CultureInvariantString**

The source string for this FText. In the Unreal Engine, this is also known as SourceString.

```csharp
public FString CultureInvariantString;
```

### **SourceFmt**

```csharp
public TextPropertyData SourceFmt;
```

### **Arguments**

```csharp
public FFormatArgumentValue[] Arguments;
```

### **ArgumentsData**

```csharp
public FFormatArgumentData[] ArgumentsData;
```

### **TransformType**

```csharp
public ETransformType TransformType;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FString Value { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **TextPropertyData(FName)**

```csharp
public TextPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **TextPropertyData()**

```csharp
public TextPropertyData()
```

## Methods

### **ShouldSerializeTableId()**

```csharp
public bool ShouldSerializeTableId()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.uint16propertydata.md`:

```md
# UInt16PropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a 16-bit unsigned integer variable ([UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)).

```csharp
public class UInt16PropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;UInt16&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [UInt16PropertyData](./uassetapi.propertytypes.objects.uint16propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public ushort Value { get; set; }
```

#### Property Value

[UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **UInt16PropertyData(FName)**

```csharp
public UInt16PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **UInt16PropertyData()**

```csharp
public UInt16PropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.uint32propertydata.md`:

```md
# UInt32PropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a 32-bit unsigned integer variable ([UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)).

```csharp
public class UInt32PropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;UInt32&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [UInt32PropertyData](./uassetapi.propertytypes.objects.uint32propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public uint Value { get; set; }
```

#### Property Value

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **UInt32PropertyData(FName)**

```csharp
public UInt32PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **UInt32PropertyData()**

```csharp
public UInt32PropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.uint64propertydata.md`:

```md
# UInt64PropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a 64-bit unsigned integer variable ([UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)).

```csharp
public class UInt64PropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;UInt64&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [UInt64PropertyData](./uassetapi.propertytypes.objects.uint64propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public ulong Value { get; set; }
```

#### Property Value

[UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **UInt64PropertyData(FName)**

```csharp
public UInt64PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **UInt64PropertyData()**

```csharp
public UInt64PropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.unknownpropertydata.md`:

```md
# UnknownPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

Describes a property which UAssetAPI has no specific serialization for, and is instead represented as an array of bytes as a fallback.

```csharp
public class UnknownPropertyData : PropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Byte[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [UnknownPropertyData](./uassetapi.propertytypes.objects.unknownpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **SerializingPropertyType**

```csharp
public FString SerializingPropertyType;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Byte[] Value { get; set; }
```

#### Property Value

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **UnknownPropertyData(FName)**

```csharp
public UnknownPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **UnknownPropertyData()**

```csharp
public UnknownPropertyData()
```

## Methods

### **SetSerializingPropertyType(FString)**

```csharp
public void SetSerializingPropertyType(FString newType)
```

#### Parameters

`newType` [FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.objects.weakobjectpropertydata.md`:

```md
# WeakObjectPropertyData

Namespace: UAssetAPI.PropertyTypes.Objects

```csharp
public class WeakObjectPropertyData : ObjectPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FPackageIndex&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [ObjectPropertyData](./uassetapi.propertytypes.objects.objectpropertydata.md) → [WeakObjectPropertyData](./uassetapi.propertytypes.objects.weakobjectpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **DefaultValue**

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FPackageIndex Value { get; set; }
```

#### Property Value

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **WeakObjectPropertyData(FName)**

```csharp
public WeakObjectPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **WeakObjectPropertyData()**

```csharp
public WeakObjectPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.box2dpropertydata.md`:

```md
# Box2DPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class Box2DPropertyData : TBoxPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;TBox&lt;FVector2D&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TBoxPropertyData&lt;FVector2D&gt;](./uassetapi.propertytypes.structs.tboxpropertydata-1.md) → [Box2DPropertyData](./uassetapi.propertytypes.structs.box2dpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public TBox<FVector2D> Value { get; set; }
```

#### Property Value

[TBox&lt;FVector2D&gt;](./uassetapi.unrealtypes.tbox-1.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **Box2DPropertyData(FName)**

```csharp
public Box2DPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Box2DPropertyData()**

```csharp
public Box2DPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.box2fpropertydata.md`:

```md
# Box2fPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class Box2fPropertyData : TBoxPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;TBox&lt;FVector2f&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TBoxPropertyData&lt;FVector2f&gt;](./uassetapi.propertytypes.structs.tboxpropertydata-1.md) → [Box2fPropertyData](./uassetapi.propertytypes.structs.box2fpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public TBox<FVector2f> Value { get; set; }
```

#### Property Value

[TBox&lt;FVector2f&gt;](./uassetapi.unrealtypes.tbox-1.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **Box2fPropertyData(FName)**

```csharp
public Box2fPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Box2fPropertyData()**

```csharp
public Box2fPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.boxpropertydata.md`:

```md
# BoxPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class BoxPropertyData : TBoxPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;TBox&lt;FVector&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TBoxPropertyData&lt;FVector&gt;](./uassetapi.propertytypes.structs.tboxpropertydata-1.md) → [BoxPropertyData](./uassetapi.propertytypes.structs.boxpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public TBox<FVector> Value { get; set; }
```

#### Property Value

[TBox&lt;FVector&gt;](./uassetapi.unrealtypes.tbox-1.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **BoxPropertyData(FName)**

```csharp
public BoxPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **BoxPropertyData()**

```csharp
public BoxPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.clothloddatacommonpropertydata.md`:

```md
# ClothLODDataCommonPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class ClothLODDataCommonPropertyData : ClothLODDataPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [ClothLODDataPropertyData](./uassetapi.propertytypes.structs.clothloddatapropertydata.md) → [ClothLODDataCommonPropertyData](./uassetapi.propertytypes.structs.clothloddatacommonpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **TransitionUpSkinData**

Skinning data for transitioning from a higher detail LOD to this one

```csharp
public FMeshToMeshVertData[] TransitionUpSkinData;
```

### **TransitionDownSkinData**

Skinning data for transitioning from a lower detail LOD to this one

```csharp
public FMeshToMeshVertData[] TransitionDownSkinData;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ClothLODDataCommonPropertyData(FName, FName)**

```csharp
public ClothLODDataCommonPropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ClothLODDataCommonPropertyData(FName)**

```csharp
public ClothLODDataCommonPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ClothLODDataCommonPropertyData()**

```csharp
public ClothLODDataCommonPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.clothloddatapropertydata.md`:

```md
# ClothLODDataPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Common Cloth LOD representation for all clothing assets.

```csharp
public class ClothLODDataPropertyData : StructPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [ClothLODDataPropertyData](./uassetapi.propertytypes.structs.clothloddatapropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **TransitionUpSkinData**

Skinning data for transitioning from a higher detail LOD to this one

```csharp
public FMeshToMeshVertData[] TransitionUpSkinData;
```

### **TransitionDownSkinData**

Skinning data for transitioning from a lower detail LOD to this one

```csharp
public FMeshToMeshVertData[] TransitionDownSkinData;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ClothLODDataPropertyData(FName, FName)**

```csharp
public ClothLODDataPropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ClothLODDataPropertyData(FName)**

```csharp
public ClothLODDataPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ClothLODDataPropertyData()**

```csharp
public ClothLODDataPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.clothtetherdatapropertydata.md`:

```md
# ClothTetherDataPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Long range attachment tether pathfinding based on Dijkstra's algorithm.

```csharp
public class ClothTetherDataPropertyData : StructPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [ClothTetherDataPropertyData](./uassetapi.propertytypes.structs.clothtetherdatapropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Tethers**

```csharp
public ValueTuple`3[][] Tethers;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ClothTetherDataPropertyData(FName, FName)**

```csharp
public ClothTetherDataPropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ClothTetherDataPropertyData(FName)**

```csharp
public ClothTetherDataPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ClothTetherDataPropertyData()**

```csharp
public ClothTetherDataPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.colormaterialinputpropertydata.md`:

```md
# ColorMaterialInputPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class ColorMaterialInputPropertyData : MaterialInputPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;ColorPropertyData&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MaterialInputPropertyData&lt;ColorPropertyData&gt;](./uassetapi.propertytypes.structs.materialinputpropertydata-1.md) → [ColorMaterialInputPropertyData](./uassetapi.propertytypes.structs.colormaterialinputpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Expression**

```csharp
public FPackageIndex Expression;
```

### **OutputIndex**

```csharp
public int OutputIndex;
```

### **InputName**

```csharp
public FName InputName;
```

### **InputNameOld**

```csharp
public FString InputNameOld;
```

### **Mask**

```csharp
public int Mask;
```

### **MaskR**

```csharp
public int MaskR;
```

### **MaskG**

```csharp
public int MaskG;
```

### **MaskB**

```csharp
public int MaskB;
```

### **MaskA**

```csharp
public int MaskA;
```

### **ExpressionName**

```csharp
public FName ExpressionName;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public ColorPropertyData Value { get; set; }
```

#### Property Value

[ColorPropertyData](./uassetapi.propertytypes.structs.colorpropertydata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ColorMaterialInputPropertyData(FName)**

```csharp
public ColorMaterialInputPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ColorMaterialInputPropertyData()**

```csharp
public ColorMaterialInputPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.colorpropertydata.md`:

```md
# ColorPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Describes a color with 8 bits of precision per channel.

```csharp
public class ColorPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.Drawing.Color]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Color&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [ColorPropertyData](./uassetapi.propertytypes.structs.colorpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Color Value { get; set; }
```

#### Property Value

Color<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ColorPropertyData(FName)**

```csharp
public ColorPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ColorPropertyData()**

```csharp
public ColorPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.datetimepropertydata.md`:

```md
# DateTimePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Implements a date and time.
 
 Values of this type represent dates and times between Midnight 00:00:00, January 1, 0001 and
 Midnight 23:59:59.9999999, December 31, 9999 in the Gregorian calendar. Internally, the time
 values are stored in ticks of 0.1 microseconds (= 100 nanoseconds) since January 1, 0001.
 
 The companion class [TimespanPropertyData](./uassetapi.propertytypes.structs.timespanpropertydata.md) ([TimeSpan](https://docs.microsoft.com/en-us/dotnet/api/system.timespan)) is provided for
 enabling date and time based arithmetic, such as calculating the difference between two dates
 or adding a certain amount of time to a given date.

```csharp
public class DateTimePropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.DateTime]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;DateTime&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [DateTimePropertyData](./uassetapi.propertytypes.structs.datetimepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public DateTime Value { get; set; }
```

#### Property Value

[DateTime](https://docs.microsoft.com/en-us/dotnet/api/system.datetime)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **DateTimePropertyData(FName)**

```csharp
public DateTimePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **DateTimePropertyData()**

```csharp
public DateTimePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.deprecateslatevector2dpropertydata.md`:

```md
# DeprecateSlateVector2DPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class DeprecateSlateVector2DPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FVector2f]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FVector2f&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FVector2f&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [DeprecateSlateVector2DPropertyData](./uassetapi.propertytypes.structs.deprecateslatevector2dpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FVector2f Value { get; set; }
```

#### Property Value

[FVector2f](./uassetapi.unrealtypes.fvector2f.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **DeprecateSlateVector2DPropertyData(FName)**

```csharp
public DeprecateSlateVector2DPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **DeprecateSlateVector2DPropertyData()**

```csharp
public DeprecateSlateVector2DPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.esectionevaluationflags.md`:

```md
# ESectionEvaluationFlags

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public enum ESectionEvaluationFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESectionEvaluationFlags](./uassetapi.propertytypes.structs.esectionevaluationflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.structs.expressioninputpropertydata.md`:

```md
# ExpressionInputPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class ExpressionInputPropertyData : MaterialInputPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Int32&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MaterialInputPropertyData&lt;Int32&gt;](./uassetapi.propertytypes.structs.materialinputpropertydata-1.md) → [ExpressionInputPropertyData](./uassetapi.propertytypes.structs.expressioninputpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Expression**

```csharp
public FPackageIndex Expression;
```

### **OutputIndex**

```csharp
public int OutputIndex;
```

### **InputName**

```csharp
public FName InputName;
```

### **InputNameOld**

```csharp
public FString InputNameOld;
```

### **Mask**

```csharp
public int Mask;
```

### **MaskR**

```csharp
public int MaskR;
```

### **MaskG**

```csharp
public int MaskG;
```

### **MaskB**

```csharp
public int MaskB;
```

### **MaskA**

```csharp
public int MaskA;
```

### **ExpressionName**

```csharp
public FName ExpressionName;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public int Value { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ExpressionInputPropertyData(FName)**

```csharp
public ExpressionInputPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ExpressionInputPropertyData()**

```csharp
public ExpressionInputPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.fentityandmetadataindex.md`:

```md
# FEntityAndMetaDataIndex

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FEntityAndMetaDataIndex
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FEntityAndMetaDataIndex](./uassetapi.propertytypes.structs.fentityandmetadataindex.md)

## Fields

### **EntityIndex**

```csharp
public int EntityIndex;
```

### **MetaDataIndex**

```csharp
public int MetaDataIndex;
```

## Constructors

### **FEntityAndMetaDataIndex(Int32, Int32)**

```csharp
FEntityAndMetaDataIndex(int entityIndex, int metaDataIndex)
```

#### Parameters

`entityIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`metaDataIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FEntityAndMetaDataIndex(AssetBinaryReader)**

```csharp
FEntityAndMetaDataIndex(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fentry.md`:

```md
# FEntry

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FEntry
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FEntry](./uassetapi.propertytypes.structs.fentry.md)

## Fields

### **StartIndex**

The index into Items of the first item

```csharp
public int StartIndex;
```

### **Size**

The number of currently valid items

```csharp
public int Size;
```

### **Capacity**

The total capacity of allowed items before reallocating

```csharp
public int Capacity;
```

## Constructors

### **FEntry(Int32, Int32, Int32)**

```csharp
FEntry(int startIndex, int size, int capacity)
```

#### Parameters

`startIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`size` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`capacity` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FEntry(AssetBinaryReader)**

```csharp
FEntry(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fevaluationtreeentryhandle.md`:

```md
# FEvaluationTreeEntryHandle

Namespace: UAssetAPI.PropertyTypes.Structs

A structure that uniquely identifies an entry within a TEvaluationTreeEntryContaine

```csharp
public struct FEvaluationTreeEntryHandle
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FEvaluationTreeEntryHandle](./uassetapi.propertytypes.structs.fevaluationtreeentryhandle.md)

## Fields

### **EntryIndex**

Specifies an index into TEvaluationTreeEntryContainer::Entries

```csharp
public int EntryIndex;
```

## Constructors

### **FEvaluationTreeEntryHandle(Int32)**

```csharp
FEvaluationTreeEntryHandle(int _EntryIndex)
```

#### Parameters

`_EntryIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FEvaluationTreeEntryHandle(AssetBinaryReader)**

```csharp
FEvaluationTreeEntryHandle(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.flevelsequencelegacyobjectreference.md`:

```md
# FLevelSequenceLegacyObjectReference

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FLevelSequenceLegacyObjectReference
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FLevelSequenceLegacyObjectReference](./uassetapi.propertytypes.structs.flevelsequencelegacyobjectreference.md)

## Fields

### **ObjectId**

```csharp
public Guid ObjectId;
```

### **ObjectPath**

```csharp
public FString ObjectPath;
```

## Constructors

### **FLevelSequenceLegacyObjectReference(Guid, FString)**

```csharp
public FLevelSequenceLegacyObjectReference(Guid objectId, FString objectPath)
```

#### Parameters

`objectId` [Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>

`objectPath` [FString](./uassetapi.unrealtypes.fstring.md)<br>

### **FLevelSequenceLegacyObjectReference(AssetBinaryReader)**

```csharp
public FLevelSequenceLegacyObjectReference(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.floatrangepropertydata.md`:

```md
# FloatRangePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FloatRangePropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [FloatRangePropertyData](./uassetapi.propertytypes.structs.floatrangepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **LowerBound**

```csharp
public float LowerBound;
```

### **UpperBound**

```csharp
public float UpperBound;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **FloatRangePropertyData(FName)**

```csharp
public FloatRangePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **FloatRangePropertyData()**

```csharp
public FloatRangePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmeshtomeshvertdata.md`:

```md
# FMeshToMeshVertData

Namespace: UAssetAPI.PropertyTypes.Structs

A structure for holding mesh-to-mesh triangle influences to skin one mesh to another (similar to a wrap deformer)

```csharp
public class FMeshToMeshVertData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMeshToMeshVertData](./uassetapi.propertytypes.structs.fmeshtomeshvertdata.md)

## Fields

### **PositionBaryCoordsAndDist**

Barycentric coords and distance along normal for the position of the final vert

```csharp
public Vector4fPropertyData PositionBaryCoordsAndDist;
```

### **NormalBaryCoordsAndDist**

Barycentric coords and distance along normal for the location of the unit normal endpoint.
 Actual normal = ResolvedNormalPosition - ResolvedPosition

```csharp
public Vector4fPropertyData NormalBaryCoordsAndDist;
```

### **TangentBaryCoordsAndDist**

Barycentric coords and distance along normal for the location of the unit Tangent endpoint.
 Actual normal = ResolvedNormalPosition - ResolvedPosition

```csharp
public Vector4fPropertyData TangentBaryCoordsAndDist;
```

### **SourceMeshVertIndices**

Contains the 3 indices for verts in the source mesh forming a triangle, the last element
 is a flag to decide how the skinning works, 0xffff uses no simulation, and just normal
 skinning, anything else uses the source mesh and the above skin data to get the final position

```csharp
public UInt16[] SourceMeshVertIndices;
```

### **Weight**

For weighted averaging of multiple triangle influences

```csharp
public float Weight;
```

### **Padding**

Dummy for alignment

```csharp
public uint Padding;
```

## Constructors

### **FMeshToMeshVertData(AssetBinaryReader)**

```csharp
public FMeshToMeshVertData(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **FMeshToMeshVertData(Vector4fPropertyData, Vector4fPropertyData, Vector4fPropertyData, UInt16[], Single, UInt32)**

```csharp
public FMeshToMeshVertData(Vector4fPropertyData positionBaryCoordsAndDist, Vector4fPropertyData normalBaryCoordsAndDist, Vector4fPropertyData tangentBaryCoordsAndDist, UInt16[] sourceMeshVertIndices, float weight, uint padding)
```

#### Parameters

`positionBaryCoordsAndDist` [Vector4fPropertyData](./uassetapi.propertytypes.structs.vector4fpropertydata.md)<br>

`normalBaryCoordsAndDist` [Vector4fPropertyData](./uassetapi.propertytypes.structs.vector4fpropertydata.md)<br>

`tangentBaryCoordsAndDist` [Vector4fPropertyData](./uassetapi.propertytypes.structs.vector4fpropertydata.md)<br>

`sourceMeshVertIndices` [UInt16[]](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

`weight` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`padding` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **FMeshToMeshVertData()**

```csharp
public FMeshToMeshVertData()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenechannel-1.md`:

```md
# FMovieSceneChannel&lt;T&gt;

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneChannel<T>
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneChannel&lt;T&gt;](./uassetapi.propertytypes.structs.fmoviescenechannel-1.md)

## Fields

### **PreInfinityExtrap**

```csharp
public ERichCurveExtrapolation PreInfinityExtrap;
```

### **PostInfinityExtrap**

```csharp
public ERichCurveExtrapolation PostInfinityExtrap;
```

### **TimesStructLength**

```csharp
public int TimesStructLength;
```

### **Times**

```csharp
public FFrameNumber[] Times;
```

### **ValuesStructLength**

```csharp
public int ValuesStructLength;
```

### **Values**

```csharp
public FMovieSceneValue`1[] Values;
```

### **DefaultValue**

```csharp
public T DefaultValue;
```

### **bHasDefaultValue**

```csharp
public bool bHasDefaultValue;
```

### **TickResolution**

```csharp
public FFrameRate TickResolution;
```

### **bShowCurve**

```csharp
public bool bShowCurve;
```

## Constructors

### **FMovieSceneChannel()**

```csharp
public FMovieSceneChannel()
```

### **FMovieSceneChannel(AssetBinaryReader, Func&lt;T&gt;)**

```csharp
public FMovieSceneChannel(AssetBinaryReader reader, Func<T> valueReader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`valueReader` Func&lt;T&gt;<br>

## Methods

### **Write(AssetBinaryWriter, Action&lt;T&gt;)**

```csharp
public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`valueWriter` Action&lt;T&gt;<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenedoublechannel.md`:

```md
# FMovieSceneDoubleChannel

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneDoubleChannel : FMovieSceneChannel`1
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneChannel&lt;Double&gt;](./uassetapi.propertytypes.structs.fmoviescenechannel-1.md) → [FMovieSceneDoubleChannel](./uassetapi.propertytypes.structs.fmoviescenedoublechannel.md)

## Fields

### **PreInfinityExtrap**

```csharp
public ERichCurveExtrapolation PreInfinityExtrap;
```

### **PostInfinityExtrap**

```csharp
public ERichCurveExtrapolation PostInfinityExtrap;
```

### **TimesStructLength**

```csharp
public int TimesStructLength;
```

### **Times**

```csharp
public FFrameNumber[] Times;
```

### **ValuesStructLength**

```csharp
public int ValuesStructLength;
```

### **Values**

```csharp
public FMovieSceneValue`1[] Values;
```

### **DefaultValue**

```csharp
public double DefaultValue;
```

### **bHasDefaultValue**

```csharp
public bool bHasDefaultValue;
```

### **TickResolution**

```csharp
public FFrameRate TickResolution;
```

### **bShowCurve**

```csharp
public bool bShowCurve;
```

## Constructors

### **FMovieSceneDoubleChannel(AssetBinaryReader)**

```csharp
public FMovieSceneDoubleChannel(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenedoublevalue.md`:

```md
# FMovieSceneDoubleValue

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneDoubleValue : FMovieSceneValue`1
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneValue&lt;Double&gt;](./uassetapi.propertytypes.structs.fmoviescenevalue-1.md) → [FMovieSceneDoubleValue](./uassetapi.propertytypes.structs.fmoviescenedoublevalue.md)

## Fields

### **Value**

```csharp
public double Value;
```

### **Tangent**

```csharp
public FMovieSceneTangentData Tangent;
```

### **InterpMode**

```csharp
public ERichCurveInterpMode InterpMode;
```

### **TangentMode**

```csharp
public ERichCurveTangentMode TangentMode;
```

### **padding**

```csharp
public Byte[] padding;
```

## Constructors

### **FMovieSceneDoubleValue(AssetBinaryReader)**

```csharp
public FMovieSceneDoubleValue(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviesceneevaluationfieldentitytree.md`:

```md
# FMovieSceneEvaluationFieldEntityTree

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FMovieSceneEvaluationFieldEntityTree
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneEvaluationFieldEntityTree](./uassetapi.propertytypes.structs.fmoviesceneevaluationfieldentitytree.md)

## Fields

### **SerializedData**

```csharp
public TMovieSceneEvaluationTree<FEntityAndMetaDataIndex> SerializedData;
```

## Constructors

### **FMovieSceneEvaluationFieldEntityTree(AssetBinaryReader)**

```csharp
FMovieSceneEvaluationFieldEntityTree(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviesceneevaluationkey.md`:

```md
# FMovieSceneEvaluationKey

Namespace: UAssetAPI.PropertyTypes.Structs

Keyable struct that represents a particular entity within an evaluation template (either a section/template or a track)

```csharp
public struct FMovieSceneEvaluationKey
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneEvaluationKey](./uassetapi.propertytypes.structs.fmoviesceneevaluationkey.md)

## Fields

### **SequenceID**

ID of the sequence that the entity is contained within

```csharp
public uint SequenceID;
```

### **TrackIdentifier**

ID of the track this key relates to

```csharp
public uint TrackIdentifier;
```

### **SectionIndex**

Index of the section template within the track this key relates to (or -1 where this key relates to a track)

```csharp
public uint SectionIndex;
```

## Constructors

### **FMovieSceneEvaluationKey(UInt32, UInt32, UInt32)**

```csharp
FMovieSceneEvaluationKey(uint _SequenceID, uint _TrackIdentifier, uint _SectionIndex)
```

#### Parameters

`_SequenceID` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`_TrackIdentifier` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`_SectionIndex` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **FMovieSceneEvaluationKey(AssetBinaryReader)**

```csharp
FMovieSceneEvaluationKey(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviesceneevaluationtree.md`:

```md
# FMovieSceneEvaluationTree

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneEvaluationTree
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneEvaluationTree](./uassetapi.propertytypes.structs.fmoviesceneevaluationtree.md)

## Fields

### **RootNode**

This tree's root node

```csharp
public FMovieSceneEvaluationTreeNode RootNode;
```

### **ChildNodes**

Segmented array of all child nodes within this tree (in no particular order)

```csharp
public TEvaluationTreeEntryContainer<FMovieSceneEvaluationTreeNode> ChildNodes;
```

## Constructors

### **FMovieSceneEvaluationTree(AssetBinaryReader)**

```csharp
public FMovieSceneEvaluationTree(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviesceneevaluationtreenode.md`:

```md
# FMovieSceneEvaluationTreeNode

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneEvaluationTreeNode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneEvaluationTreeNode](./uassetapi.propertytypes.structs.fmoviesceneevaluationtreenode.md)

## Fields

### **Range**

The time-range that this node represents

```csharp
public TRange<FFrameNumber> Range;
```

### **Parent**

```csharp
public FMovieSceneEvaluationTreeNodeHandle Parent;
```

### **ChildrenID**

Identifier for the child node entries associated with this node (FMovieSceneEvaluationTree::ChildNodes)

```csharp
public FEvaluationTreeEntryHandle ChildrenID;
```

### **DataID**

Identifier for externally stored data entries associated with this node

```csharp
public FEvaluationTreeEntryHandle DataID;
```

## Constructors

### **FMovieSceneEvaluationTreeNode(AssetBinaryReader)**

```csharp
public FMovieSceneEvaluationTreeNode(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviesceneevaluationtreenodehandle.md`:

```md
# FMovieSceneEvaluationTreeNodeHandle

Namespace: UAssetAPI.PropertyTypes.Structs

A handle to a node in an FMovieSceneEvaluationTree, defined in terms of an entry handle (corrsponding to FMovieSceneEvaluationTree::ChildNodes), and its child index

```csharp
public struct FMovieSceneEvaluationTreeNodeHandle
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneEvaluationTreeNodeHandle](./uassetapi.propertytypes.structs.fmoviesceneevaluationtreenodehandle.md)

## Fields

### **ChildrenHandle**

Entry handle for the parent's children in FMovieSceneEvaluationTree::ChildNodes

```csharp
public FEvaluationTreeEntryHandle ChildrenHandle;
```

### **Index**

The index of this child within its parent's children

```csharp
public int Index;
```

## Constructors

### **FMovieSceneEvaluationTreeNodeHandle(Int32, Int32)**

```csharp
FMovieSceneEvaluationTreeNodeHandle(int _ChildrenHandle, int _Index)
```

#### Parameters

`_ChildrenHandle` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`_Index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FMovieSceneEvaluationTreeNodeHandle(AssetBinaryReader)**

```csharp
FMovieSceneEvaluationTreeNodeHandle(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviesceneeventparameters.md`:

```md
# FMovieSceneEventParameters

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FMovieSceneEventParameters
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneEventParameters](./uassetapi.propertytypes.structs.fmoviesceneeventparameters.md)

## Fields

### **StructType**

```csharp
public FSoftObjectPath StructType;
```

### **StructBytes**

```csharp
public Byte[] StructBytes;
```

## Constructors

### **FMovieSceneEventParameters(FSoftObjectPath, Byte[])**

```csharp
FMovieSceneEventParameters(FSoftObjectPath structType, Byte[] structBytes)
```

#### Parameters

`structType` [FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

`structBytes` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **FMovieSceneEventParameters(AssetBinaryReader)**

```csharp
FMovieSceneEventParameters(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenefloatchannel.md`:

```md
# FMovieSceneFloatChannel

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneFloatChannel : FMovieSceneChannel`1
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneChannel&lt;Single&gt;](./uassetapi.propertytypes.structs.fmoviescenechannel-1.md) → [FMovieSceneFloatChannel](./uassetapi.propertytypes.structs.fmoviescenefloatchannel.md)

## Fields

### **PreInfinityExtrap**

```csharp
public ERichCurveExtrapolation PreInfinityExtrap;
```

### **PostInfinityExtrap**

```csharp
public ERichCurveExtrapolation PostInfinityExtrap;
```

### **TimesStructLength**

```csharp
public int TimesStructLength;
```

### **Times**

```csharp
public FFrameNumber[] Times;
```

### **ValuesStructLength**

```csharp
public int ValuesStructLength;
```

### **Values**

```csharp
public FMovieSceneValue`1[] Values;
```

### **DefaultValue**

```csharp
public float DefaultValue;
```

### **bHasDefaultValue**

```csharp
public bool bHasDefaultValue;
```

### **TickResolution**

```csharp
public FFrameRate TickResolution;
```

### **bShowCurve**

```csharp
public bool bShowCurve;
```

## Constructors

### **FMovieSceneFloatChannel(AssetBinaryReader)**

```csharp
public FMovieSceneFloatChannel(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenefloatvalue.md`:

```md
# FMovieSceneFloatValue

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneFloatValue : FMovieSceneValue`1
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneValue&lt;Single&gt;](./uassetapi.propertytypes.structs.fmoviescenevalue-1.md) → [FMovieSceneFloatValue](./uassetapi.propertytypes.structs.fmoviescenefloatvalue.md)

## Fields

### **Value**

```csharp
public float Value;
```

### **Tangent**

```csharp
public FMovieSceneTangentData Tangent;
```

### **InterpMode**

```csharp
public ERichCurveInterpMode InterpMode;
```

### **TangentMode**

```csharp
public ERichCurveTangentMode TangentMode;
```

### **padding**

```csharp
public Byte[] padding;
```

## Constructors

### **FMovieSceneFloatValue(AssetBinaryReader)**

```csharp
public FMovieSceneFloatValue(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenesegment.md`:

```md
# FMovieSceneSegment

Namespace: UAssetAPI.PropertyTypes.Structs

Information about a single segment of an evaluation track

```csharp
public class FMovieSceneSegment
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneSegment](./uassetapi.propertytypes.structs.fmoviescenesegment.md)

## Fields

### **RangeOld**

The segment's range

```csharp
public TRange<float> RangeOld;
```

### **Range**

```csharp
public TRange<FFrameNumber> Range;
```

### **ID**

```csharp
public int ID;
```

### **bAllowEmpty**

Whether this segment has been generated yet or not

```csharp
public bool bAllowEmpty;
```

### **Impls**

Array of implementations that reside at the segment's range

```csharp
public StructPropertyData[] Impls;
```

## Constructors

### **FMovieSceneSegment()**

```csharp
public FMovieSceneSegment()
```

### **FMovieSceneSegment(AssetBinaryReader)**

```csharp
public FMovieSceneSegment(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenesubsectiondata.md`:

```md
# FMovieSceneSubSectionData

Namespace: UAssetAPI.PropertyTypes.Structs

Data that represents a single sub-section

```csharp
public struct FMovieSceneSubSectionData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneSubSectionData](./uassetapi.propertytypes.structs.fmoviescenesubsectiondata.md)

## Fields

### **Section**

The sub section itself

```csharp
public FPackageIndex Section;
```

### **ObjectBindingId**

The object binding that the sub section belongs to (usually zero)

```csharp
public Guid ObjectBindingId;
```

### **Flags**

Evaluation flags for the section

```csharp
public ESectionEvaluationFlags Flags;
```

## Constructors

### **FMovieSceneSubSectionData(FPackageIndex, Guid, ESectionEvaluationFlags)**

```csharp
FMovieSceneSubSectionData(FPackageIndex section, Guid objectBindingId, ESectionEvaluationFlags flags)
```

#### Parameters

`section` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

`objectBindingId` [Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>

`flags` [ESectionEvaluationFlags](./uassetapi.propertytypes.structs.esectionevaluationflags.md)<br>

### **FMovieSceneSubSectionData(AssetBinaryReader)**

```csharp
FMovieSceneSubSectionData(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenesubsectionfielddata.md`:

```md
# FMovieSceneSubSectionFieldData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FMovieSceneSubSectionFieldData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneSubSectionFieldData](./uassetapi.propertytypes.structs.fmoviescenesubsectionfielddata.md)

## Fields

### **Field**

```csharp
public TMovieSceneEvaluationTree<FMovieSceneSubSectionData> Field;
```

## Constructors

### **FMovieSceneSubSectionFieldData(AssetBinaryReader)**

```csharp
FMovieSceneSubSectionFieldData(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenesubsequencetree.md`:

```md
# FMovieSceneSubSequenceTree

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FMovieSceneSubSequenceTree
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneSubSequenceTree](./uassetapi.propertytypes.structs.fmoviescenesubsequencetree.md)

## Fields

### **Data**

```csharp
public TMovieSceneEvaluationTree<FMovieSceneSubSequenceTreeEntry> Data;
```

## Constructors

### **FMovieSceneSubSequenceTree(AssetBinaryReader)**

```csharp
FMovieSceneSubSequenceTree(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenesubsequencetreeentry.md`:

```md
# FMovieSceneSubSequenceTreeEntry

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FMovieSceneSubSequenceTreeEntry
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneSubSequenceTreeEntry](./uassetapi.propertytypes.structs.fmoviescenesubsequencetreeentry.md)

## Fields

### **SequenceID**

```csharp
public uint SequenceID;
```

### **Flags**

```csharp
public ESectionEvaluationFlags Flags;
```

### **RootToSequenceWarpCounter**

```csharp
public StructPropertyData RootToSequenceWarpCounter;
```

## Constructors

### **FMovieSceneSubSequenceTreeEntry(UInt32, Byte, StructPropertyData)**

```csharp
FMovieSceneSubSequenceTreeEntry(uint sequenceID, byte flags, StructPropertyData _struct)
```

#### Parameters

`sequenceID` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`flags` [Byte](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`_struct` [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md)<br>

### **FMovieSceneSubSequenceTreeEntry(AssetBinaryReader)**

```csharp
FMovieSceneSubSequenceTreeEntry(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenetangentdata.md`:

```md
# FMovieSceneTangentData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneTangentData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneTangentData](./uassetapi.propertytypes.structs.fmoviescenetangentdata.md)

## Fields

### **ArriveTangent**

```csharp
public float ArriveTangent;
```

### **LeaveTangent**

```csharp
public float LeaveTangent;
```

### **ArriveTangentWeight**

```csharp
public float ArriveTangentWeight;
```

### **LeaveTangentWeight**

```csharp
public float LeaveTangentWeight;
```

### **TangentWeightMode**

```csharp
public ERichCurveTangentWeightMode TangentWeightMode;
```

### **padding**

```csharp
public Byte[] padding;
```

## Constructors

### **FMovieSceneTangentData()**

```csharp
public FMovieSceneTangentData()
```

### **FMovieSceneTangentData(AssetBinaryReader)**

```csharp
public FMovieSceneTangentData(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenetrackfielddata.md`:

```md
# FMovieSceneTrackFieldData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FMovieSceneTrackFieldData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMovieSceneTrackFieldData](./uassetapi.propertytypes.structs.fmoviescenetrackfielddata.md)

## Fields

### **Field**

```csharp
public TMovieSceneEvaluationTree<uint> Field;
```

## Constructors

### **FMovieSceneTrackFieldData(AssetBinaryReader)**

```csharp
FMovieSceneTrackFieldData(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fmoviescenevalue-1.md`:

```md
# FMovieSceneValue&lt;T&gt;

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FMovieSceneValue<T>
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneValue&lt;T&gt;](./uassetapi.propertytypes.structs.fmoviescenevalue-1.md)

## Fields

### **Value**

```csharp
public T Value;
```

### **Tangent**

```csharp
public FMovieSceneTangentData Tangent;
```

### **InterpMode**

```csharp
public ERichCurveInterpMode InterpMode;
```

### **TangentMode**

```csharp
public ERichCurveTangentMode TangentMode;
```

### **padding**

```csharp
public Byte[] padding;
```

## Constructors

### **FMovieSceneValue(AssetBinaryReader, T)**

```csharp
public FMovieSceneValue(AssetBinaryReader reader, T value)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`value` T<br>

## Methods

### **Write(AssetBinaryWriter, Action&lt;T&gt;)**

```csharp
public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`valueWriter` Action&lt;T&gt;<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fnamecurvekey.md`:

```md
# FNameCurveKey

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FNameCurveKey
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FNameCurveKey](./uassetapi.propertytypes.structs.fnamecurvekey.md)<br>
Implements [IStruct&lt;FNameCurveKey&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **Time**

```csharp
public float Time;
```

### **Value**

```csharp
public FName Value;
```

## Constructors

### **FNameCurveKey(Single, FName)**

```csharp
FNameCurveKey(float time, FName value)
```

#### Parameters

`time` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`value` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **FNameCurveKey(AssetBinaryReader)**

```csharp
FNameCurveKey(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FNameCurveKey Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FNameCurveKey](./uassetapi.propertytypes.structs.fnamecurvekey.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FNameCurveKey FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FNameCurveKey](./uassetapi.propertytypes.structs.fnamecurvekey.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fnavagentselector.md`:

```md
# FNavAgentSelector

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FNavAgentSelector
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FNavAgentSelector](./uassetapi.propertytypes.structs.fnavagentselector.md)<br>
Implements [IStruct&lt;FNavAgentSelector&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **PackedBits**

```csharp
public uint PackedBits;
```

## Constructors

### **FNavAgentSelector(UInt32)**

```csharp
FNavAgentSelector(uint packedBits)
```

#### Parameters

`packedBits` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **FNavAgentSelector(AssetBinaryReader)**

```csharp
FNavAgentSelector(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FNavAgentSelector Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FNavAgentSelector](./uassetapi.propertytypes.structs.fnavagentselector.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FNavAgentSelector FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FNavAgentSelector](./uassetapi.propertytypes.structs.fnavagentselector.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fontcharacterpropertydata.md`:

```md
# FontCharacterPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FontCharacterPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.UnrealTypes.FFontCharacter]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FFontCharacter&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [FontCharacterPropertyData](./uassetapi.propertytypes.structs.fontcharacterpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FFontCharacter Value { get; set; }
```

#### Property Value

[FFontCharacter](./uassetapi.unrealtypes.ffontcharacter.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **FontCharacterPropertyData(FName)**

```csharp
public FontCharacterPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **FontCharacterPropertyData()**

```csharp
public FontCharacterPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fontdatapropertydata.md`:

```md
# FontDataPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FontDataPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.UnrealTypes.FFontData]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FFontData&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [FontDataPropertyData](./uassetapi.propertytypes.structs.fontdatapropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FFontData Value { get; set; }
```

#### Property Value

[FFontData](./uassetapi.unrealtypes.ffontdata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **FontDataPropertyData(FName)**

```csharp
public FontDataPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **FontDataPropertyData()**

```csharp
public FontDataPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.framenumberpropertydata.md`:

```md
# FrameNumberPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class FrameNumberPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FFrameNumber]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FFrameNumber&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FFrameNumber&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [FrameNumberPropertyData](./uassetapi.propertytypes.structs.framenumberpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FFrameNumber Value { get; set; }
```

#### Property Value

[FFrameNumber](./uassetapi.unrealtypes.fframenumber.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **FrameNumberPropertyData(FName)**

```csharp
public FrameNumberPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **FrameNumberPropertyData()**

```csharp
public FrameNumberPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.fsectionevaluationdatatree.md`:

```md
# FSectionEvaluationDataTree

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FSectionEvaluationDataTree
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FSectionEvaluationDataTree](./uassetapi.propertytypes.structs.fsectionevaluationdatatree.md)

## Fields

### **Tree**

```csharp
public TMovieSceneEvaluationTree<StructPropertyData> Tree;
```

## Constructors

### **FSectionEvaluationDataTree(AssetBinaryReader)**

```csharp
FSectionEvaluationDataTree(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **&lt;.ctor&gt;g__ReadTree|1_1(AssetBinaryReader)**

```csharp
StructPropertyData <.ctor>g__ReadTree|1_1(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md)<br>

### **&lt;Write&gt;g__WriteTree|2_0(AssetBinaryWriter, StructPropertyData)**

```csharp
void <Write>g__WriteTree|2_0(AssetBinaryWriter writer, StructPropertyData data)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`data` [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.fstringcurvekey.md`:

```md
# FStringCurveKey

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct FStringCurveKey
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FStringCurveKey](./uassetapi.propertytypes.structs.fstringcurvekey.md)<br>
Implements [IStruct&lt;FStringCurveKey&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **Time**

```csharp
public float Time;
```

### **Value**

```csharp
public FString Value;
```

## Constructors

### **FStringCurveKey(Single, FString)**

```csharp
FStringCurveKey(float time, FString value)
```

#### Parameters

`time` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`value` [FString](./uassetapi.unrealtypes.fstring.md)<br>

### **FStringCurveKey(AssetBinaryReader)**

```csharp
FStringCurveKey(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FStringCurveKey Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FStringCurveKey](./uassetapi.propertytypes.structs.fstringcurvekey.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FStringCurveKey FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FStringCurveKey](./uassetapi.propertytypes.structs.fstringcurvekey.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.gameplaytagcontainerpropertydata.md`:

```md
# GameplayTagContainerPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class GameplayTagContainerPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.UnrealTypes.FName[]]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FName[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [GameplayTagContainerPropertyData](./uassetapi.propertytypes.structs.gameplaytagcontainerpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FName[] Value { get; set; }
```

#### Property Value

[FName[]](./uassetapi.unrealtypes.fname.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **GameplayTagContainerPropertyData(FName)**

```csharp
public GameplayTagContainerPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **GameplayTagContainerPropertyData()**

```csharp
public GameplayTagContainerPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.guidpropertydata.md`:

```md
# GuidPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Describes a 128-bit [Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid).

```csharp
public class GuidPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.Guid]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Guid&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [GuidPropertyData](./uassetapi.propertytypes.structs.guidpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Guid Value { get; set; }
```

#### Property Value

[Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **GuidPropertyData(FName)**

```csharp
public GuidPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **GuidPropertyData()**

```csharp
public GuidPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.intpointpropertydata.md`:

```md
# IntPointPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class IntPointPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.Int32[]]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Int32[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [IntPointPropertyData](./uassetapi.propertytypes.structs.intpointpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Int32[] Value { get; set; }
```

#### Property Value

[Int32[]](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **IntPointPropertyData(FName)**

```csharp
public IntPointPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **IntPointPropertyData()**

```csharp
public IntPointPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.intvector2propertydata.md`:

```md
# IntVector2PropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class IntVector2PropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FIntVector2]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FIntVector2&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FIntVector2&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [IntVector2PropertyData](./uassetapi.propertytypes.structs.intvector2propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FIntVector2 Value { get; set; }
```

#### Property Value

[FIntVector2](./uassetapi.unrealtypes.fintvector2.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **IntVector2PropertyData(FName)**

```csharp
public IntVector2PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **IntVector2PropertyData()**

```csharp
public IntVector2PropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.intvectorpropertydata.md`:

```md
# IntVectorPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class IntVectorPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FIntVector]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FIntVector&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FIntVector&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [IntVectorPropertyData](./uassetapi.propertytypes.structs.intvectorpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FIntVector Value { get; set; }
```

#### Property Value

[FIntVector](./uassetapi.unrealtypes.fintvector.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **IntVectorPropertyData(FName)**

```csharp
public IntVectorPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **IntVectorPropertyData()**

```csharp
public IntVectorPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.keyhandlemappropertydata.md`:

```md
# KeyHandleMapPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class KeyHandleMapPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [KeyHandleMapPropertyData](./uassetapi.propertytypes.structs.keyhandlemappropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **KeyHandleMapPropertyData(FName)**

```csharp
public KeyHandleMapPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **KeyHandleMapPropertyData()**

```csharp
public KeyHandleMapPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.levelsequenceobjectreferencemappropertydata.md`:

```md
# LevelSequenceObjectReferenceMapPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class LevelSequenceObjectReferenceMapPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.UnrealTypes.TMap`2[[System.Guid],[UAssetAPI.PropertyTypes.Structs.FLevelSequenceLegacyObjectReference]]]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;TMap&lt;Guid, FLevelSequenceLegacyObjectReference&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [LevelSequenceObjectReferenceMapPropertyData](./uassetapi.propertytypes.structs.levelsequenceobjectreferencemappropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public TMap<Guid, FLevelSequenceLegacyObjectReference> Value { get; set; }
```

#### Property Value

[TMap&lt;Guid, FLevelSequenceLegacyObjectReference&gt;](./uassetapi.unrealtypes.tmap-2.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **LevelSequenceObjectReferenceMapPropertyData(FName)**

```csharp
public LevelSequenceObjectReferenceMapPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **LevelSequenceObjectReferenceMapPropertyData()**

```csharp
public LevelSequenceObjectReferenceMapPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.linearcolorpropertydata.md`:

```md
# LinearColorPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class LinearColorPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FLinearColor]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FLinearColor&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FLinearColor&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [LinearColorPropertyData](./uassetapi.propertytypes.structs.linearcolorpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FLinearColor Value { get; set; }
```

#### Property Value

[FLinearColor](./uassetapi.unrealtypes.flinearcolor.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **LinearColorPropertyData(FName)**

```csharp
public LinearColorPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **LinearColorPropertyData()**

```csharp
public LinearColorPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.materialattributesinputpropertydata.md`:

```md
# MaterialAttributesInputPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MaterialAttributesInputPropertyData : MaterialInputPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Int32&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MaterialInputPropertyData&lt;Int32&gt;](./uassetapi.propertytypes.structs.materialinputpropertydata-1.md) → [MaterialAttributesInputPropertyData](./uassetapi.propertytypes.structs.materialattributesinputpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Expression**

```csharp
public FPackageIndex Expression;
```

### **OutputIndex**

```csharp
public int OutputIndex;
```

### **InputName**

```csharp
public FName InputName;
```

### **InputNameOld**

```csharp
public FString InputNameOld;
```

### **Mask**

```csharp
public int Mask;
```

### **MaskR**

```csharp
public int MaskR;
```

### **MaskG**

```csharp
public int MaskG;
```

### **MaskB**

```csharp
public int MaskB;
```

### **MaskA**

```csharp
public int MaskA;
```

### **ExpressionName**

```csharp
public FName ExpressionName;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public int Value { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MaterialAttributesInputPropertyData(FName)**

```csharp
public MaterialAttributesInputPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MaterialAttributesInputPropertyData()**

```csharp
public MaterialAttributesInputPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.materialoverridenanitepropertydata.md`:

```md
# MaterialOverrideNanitePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MaterialOverrideNanitePropertyData : StructPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [MaterialOverrideNanitePropertyData](./uassetapi.propertytypes.structs.materialoverridenanitepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **OverrideMaterialRef**

```csharp
public FSoftObjectPath OverrideMaterialRef;
```

### **bEnableOverride**

```csharp
public bool bEnableOverride;
```

### **OverrideMaterial**

```csharp
public FPackageIndex OverrideMaterial;
```

### **bSerializeAsCookedData**

```csharp
public bool bSerializeAsCookedData;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MaterialOverrideNanitePropertyData(FName, FName)**

```csharp
public MaterialOverrideNanitePropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MaterialOverrideNanitePropertyData(FName)**

```csharp
public MaterialOverrideNanitePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MaterialOverrideNanitePropertyData()**

```csharp
public MaterialOverrideNanitePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.matrixpropertydata.md`:

```md
# MatrixPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MatrixPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FMatrix]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMatrix&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FMatrix&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [MatrixPropertyData](./uassetapi.propertytypes.structs.matrixpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMatrix Value { get; set; }
```

#### Property Value

[FMatrix](./uassetapi.unrealtypes.fmatrix.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MatrixPropertyData(FName)**

```csharp
public MatrixPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MatrixPropertyData()**

```csharp
public MatrixPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenedoublechannelpropertydata.md`:

```md
# MovieSceneDoubleChannelPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneDoubleChannelPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneDoubleChannel]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneDoubleChannel&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneDoubleChannelPropertyData](./uassetapi.propertytypes.structs.moviescenedoublechannelpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneDoubleChannel Value { get; set; }
```

#### Property Value

[FMovieSceneDoubleChannel](./uassetapi.propertytypes.structs.fmoviescenedoublechannel.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneDoubleChannelPropertyData(FName)**

```csharp
public MovieSceneDoubleChannelPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneDoubleChannelPropertyData()**

```csharp
public MovieSceneDoubleChannelPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviesceneevaltemplateptrpropertydata.md`:

```md
# MovieSceneEvalTemplatePtrPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneEvalTemplatePtrPropertyData : MovieSceneTemplatePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [MovieSceneTemplatePropertyData](./uassetapi.propertytypes.structs.moviescenetemplatepropertydata.md) → [MovieSceneEvalTemplatePtrPropertyData](./uassetapi.propertytypes.structs.moviesceneevaltemplateptrpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneEvalTemplatePtrPropertyData(FName, FName)**

```csharp
public MovieSceneEvalTemplatePtrPropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneEvalTemplatePtrPropertyData(FName)**

```csharp
public MovieSceneEvalTemplatePtrPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneEvalTemplatePtrPropertyData()**

```csharp
public MovieSceneEvalTemplatePtrPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.moviesceneevaluationfieldentitytreepropertydata.md`:

```md
# MovieSceneEvaluationFieldEntityTreePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneEvaluationFieldEntityTreePropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneEvaluationFieldEntityTree]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneEvaluationFieldEntityTree&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneEvaluationFieldEntityTreePropertyData](./uassetapi.propertytypes.structs.moviesceneevaluationfieldentitytreepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneEvaluationFieldEntityTree Value { get; set; }
```

#### Property Value

[FMovieSceneEvaluationFieldEntityTree](./uassetapi.propertytypes.structs.fmoviesceneevaluationfieldentitytree.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneEvaluationFieldEntityTreePropertyData(FName)**

```csharp
public MovieSceneEvaluationFieldEntityTreePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneEvaluationFieldEntityTreePropertyData()**

```csharp
public MovieSceneEvaluationFieldEntityTreePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviesceneevaluationkeypropertydata.md`:

```md
# MovieSceneEvaluationKeyPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneEvaluationKeyPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneEvaluationKey]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneEvaluationKey&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneEvaluationKeyPropertyData](./uassetapi.propertytypes.structs.moviesceneevaluationkeypropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneEvaluationKey Value { get; set; }
```

#### Property Value

[FMovieSceneEvaluationKey](./uassetapi.propertytypes.structs.fmoviesceneevaluationkey.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneEvaluationKeyPropertyData(FName)**

```csharp
public MovieSceneEvaluationKeyPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneEvaluationKeyPropertyData()**

```csharp
public MovieSceneEvaluationKeyPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviesceneeventparameterspropertydata.md`:

```md
# MovieSceneEventParametersPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneEventParametersPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneEventParameters]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneEventParameters&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneEventParametersPropertyData](./uassetapi.propertytypes.structs.moviesceneeventparameterspropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneEventParameters Value { get; set; }
```

#### Property Value

[FMovieSceneEventParameters](./uassetapi.propertytypes.structs.fmoviesceneeventparameters.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneEventParametersPropertyData(FName)**

```csharp
public MovieSceneEventParametersPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneEventParametersPropertyData()**

```csharp
public MovieSceneEventParametersPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenefloatchannelpropertydata.md`:

```md
# MovieSceneFloatChannelPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneFloatChannelPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneFloatChannel]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneFloatChannel&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneFloatChannelPropertyData](./uassetapi.propertytypes.structs.moviescenefloatchannelpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneFloatChannel Value { get; set; }
```

#### Property Value

[FMovieSceneFloatChannel](./uassetapi.propertytypes.structs.fmoviescenefloatchannel.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneFloatChannelPropertyData(FName)**

```csharp
public MovieSceneFloatChannelPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneFloatChannelPropertyData()**

```csharp
public MovieSceneFloatChannelPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenefloatvaluepropertydata.md`:

```md
# MovieSceneFloatValuePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneFloatValuePropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneFloatValue]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneFloatValue&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneFloatValuePropertyData](./uassetapi.propertytypes.structs.moviescenefloatvaluepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneFloatValue Value { get; set; }
```

#### Property Value

[FMovieSceneFloatValue](./uassetapi.propertytypes.structs.fmoviescenefloatvalue.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneFloatValuePropertyData(FName)**

```csharp
public MovieSceneFloatValuePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneFloatValuePropertyData()**

```csharp
public MovieSceneFloatValuePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviesceneframerangepropertydata.md`:

```md
# MovieSceneFrameRangePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneFrameRangePropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.UnrealTypes.TRange`1[[UAssetAPI.UnrealTypes.FFrameNumber]]]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;TRange&lt;FFrameNumber&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneFrameRangePropertyData](./uassetapi.propertytypes.structs.moviesceneframerangepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public TRange<FFrameNumber> Value { get; set; }
```

#### Property Value

[TRange&lt;FFrameNumber&gt;](./uassetapi.unrealtypes.trange-1.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneFrameRangePropertyData(FName)**

```csharp
public MovieSceneFrameRangePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneFrameRangePropertyData()**

```csharp
public MovieSceneFrameRangePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenegenerationledgerpropertydata.md`:

```md
# MovieSceneGenerationLedgerPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneGenerationLedgerPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [MovieSceneGenerationLedgerPropertyData](./uassetapi.propertytypes.structs.moviescenegenerationledgerpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneGenerationLedgerPropertyData(FName)**

```csharp
public MovieSceneGenerationLedgerPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneGenerationLedgerPropertyData()**

```csharp
public MovieSceneGenerationLedgerPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenesegmentidentifierpropertydata.md`:

```md
# MovieSceneSegmentIdentifierPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneSegmentIdentifierPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.Int32]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Int32&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneSegmentIdentifierPropertyData](./uassetapi.propertytypes.structs.moviescenesegmentidentifierpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public int Value { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneSegmentIdentifierPropertyData(FName)**

```csharp
public MovieSceneSegmentIdentifierPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneSegmentIdentifierPropertyData()**

```csharp
public MovieSceneSegmentIdentifierPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenesegmentpropertydata.md`:

```md
# MovieSceneSegmentPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneSegmentPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneSegment]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneSegment&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneSegmentPropertyData](./uassetapi.propertytypes.structs.moviescenesegmentpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneSegment Value { get; set; }
```

#### Property Value

[FMovieSceneSegment](./uassetapi.propertytypes.structs.fmoviescenesegment.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneSegmentPropertyData(FName)**

```csharp
public MovieSceneSegmentPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneSegmentPropertyData()**

```csharp
public MovieSceneSegmentPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenesequenceidpropertydata.md`:

```md
# MovieSceneSequenceIDPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneSequenceIDPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.UInt32]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;UInt32&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneSequenceIDPropertyData](./uassetapi.propertytypes.structs.moviescenesequenceidpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public uint Value { get; set; }
```

#### Property Value

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneSequenceIDPropertyData(FName)**

```csharp
public MovieSceneSequenceIDPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneSequenceIDPropertyData()**

```csharp
public MovieSceneSequenceIDPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenesequenceinstancedataptrpropertydata.md`:

```md
# MovieSceneSequenceInstanceDataPtrPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneSequenceInstanceDataPtrPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.UnrealTypes.FPackageIndex]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FPackageIndex&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneSequenceInstanceDataPtrPropertyData](./uassetapi.propertytypes.structs.moviescenesequenceinstancedataptrpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FPackageIndex Value { get; set; }
```

#### Property Value

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneSequenceInstanceDataPtrPropertyData(FName)**

```csharp
public MovieSceneSequenceInstanceDataPtrPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneSequenceInstanceDataPtrPropertyData()**

```csharp
public MovieSceneSequenceInstanceDataPtrPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenesubsectionfielddatapropertydata.md`:

```md
# MovieSceneSubSectionFieldDataPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneSubSectionFieldDataPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneSubSectionFieldData]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneSubSectionFieldData&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneSubSectionFieldDataPropertyData](./uassetapi.propertytypes.structs.moviescenesubsectionfielddatapropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneSubSectionFieldData Value { get; set; }
```

#### Property Value

[FMovieSceneSubSectionFieldData](./uassetapi.propertytypes.structs.fmoviescenesubsectionfielddata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneSubSectionFieldDataPropertyData(FName)**

```csharp
public MovieSceneSubSectionFieldDataPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneSubSectionFieldDataPropertyData()**

```csharp
public MovieSceneSubSectionFieldDataPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenesubsequencetreepropertydata.md`:

```md
# MovieSceneSubSequenceTreePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneSubSequenceTreePropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneSubSequenceTree]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneSubSequenceTree&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneSubSequenceTreePropertyData](./uassetapi.propertytypes.structs.moviescenesubsequencetreepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneSubSequenceTree Value { get; set; }
```

#### Property Value

[FMovieSceneSubSequenceTree](./uassetapi.propertytypes.structs.fmoviescenesubsequencetree.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneSubSequenceTreePropertyData(FName)**

```csharp
public MovieSceneSubSequenceTreePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneSubSequenceTreePropertyData()**

```csharp
public MovieSceneSubSequenceTreePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenetemplatepropertydata.md`:

```md
# MovieSceneTemplatePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneTemplatePropertyData : StructPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [MovieSceneTemplatePropertyData](./uassetapi.propertytypes.structs.moviescenetemplatepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneTemplatePropertyData(FName, FName)**

```csharp
public MovieSceneTemplatePropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneTemplatePropertyData(FName)**

```csharp
public MovieSceneTemplatePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneTemplatePropertyData()**

```csharp
public MovieSceneTemplatePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenetrackfielddatapropertydata.md`:

```md
# MovieSceneTrackFieldDataPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneTrackFieldDataPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FMovieSceneTrackFieldData]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FMovieSceneTrackFieldData&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneTrackFieldDataPropertyData](./uassetapi.propertytypes.structs.moviescenetrackfielddatapropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FMovieSceneTrackFieldData Value { get; set; }
```

#### Property Value

[FMovieSceneTrackFieldData](./uassetapi.propertytypes.structs.fmoviescenetrackfielddata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneTrackFieldDataPropertyData(FName)**

```csharp
public MovieSceneTrackFieldDataPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneTrackFieldDataPropertyData()**

```csharp
public MovieSceneTrackFieldDataPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenetrackidentifierpropertydata.md`:

```md
# MovieSceneTrackIdentifierPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneTrackIdentifierPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.UInt32]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;UInt32&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MovieSceneTrackIdentifierPropertyData](./uassetapi.propertytypes.structs.moviescenetrackidentifierpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public uint Value { get; set; }
```

#### Property Value

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneTrackIdentifierPropertyData(FName)**

```csharp
public MovieSceneTrackIdentifierPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneTrackIdentifierPropertyData()**

```csharp
public MovieSceneTrackIdentifierPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.moviescenetrackimplementationptrpropertydata.md`:

```md
# MovieSceneTrackImplementationPtrPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class MovieSceneTrackImplementationPtrPropertyData : MovieSceneTemplatePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [MovieSceneTemplatePropertyData](./uassetapi.propertytypes.structs.moviescenetemplatepropertydata.md) → [MovieSceneTrackImplementationPtrPropertyData](./uassetapi.propertytypes.structs.moviescenetrackimplementationptrpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **MovieSceneTrackImplementationPtrPropertyData(FName, FName)**

```csharp
public MovieSceneTrackImplementationPtrPropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneTrackImplementationPtrPropertyData(FName)**

```csharp
public MovieSceneTrackImplementationPtrPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **MovieSceneTrackImplementationPtrPropertyData()**

```csharp
public MovieSceneTrackImplementationPtrPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.namecurvekeypropertydata.md`:

```md
# NameCurveKeyPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class NameCurveKeyPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.PropertyTypes.Structs.FNameCurveKey]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FNameCurveKey&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FNameCurveKey&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [NameCurveKeyPropertyData](./uassetapi.propertytypes.structs.namecurvekeypropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FNameCurveKey Value { get; set; }
```

#### Property Value

[FNameCurveKey](./uassetapi.propertytypes.structs.fnamecurvekey.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **NameCurveKeyPropertyData(FName)**

```csharp
public NameCurveKeyPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NameCurveKeyPropertyData()**

```csharp
public NameCurveKeyPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.navagentselectorpropertydata.md`:

```md
# NavAgentSelectorPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class NavAgentSelectorPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.PropertyTypes.Structs.FNavAgentSelector]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FNavAgentSelector&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FNavAgentSelector&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [NavAgentSelectorPropertyData](./uassetapi.propertytypes.structs.navagentselectorpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FNavAgentSelector Value { get; set; }
```

#### Property Value

[FNavAgentSelector](./uassetapi.propertytypes.structs.fnavagentselector.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **NavAgentSelectorPropertyData(FName)**

```csharp
public NavAgentSelectorPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NavAgentSelectorPropertyData()**

```csharp
public NavAgentSelectorPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.niagaradatachannelvariablepropertydata.md`:

```md
# NiagaraDataChannelVariablePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class NiagaraDataChannelVariablePropertyData : NiagaraVariableBasePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [NiagaraVariableBasePropertyData](./uassetapi.propertytypes.structs.niagaravariablebasepropertydata.md) → [NiagaraDataChannelVariablePropertyData](./uassetapi.propertytypes.structs.niagaradatachannelvariablepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **VariableName**

```csharp
public FName VariableName;
```

### **TypeDef**

```csharp
public StructPropertyData TypeDef;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **NiagaraDataChannelVariablePropertyData(FName, FName)**

```csharp
public NiagaraDataChannelVariablePropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraDataChannelVariablePropertyData(FName)**

```csharp
public NiagaraDataChannelVariablePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraDataChannelVariablePropertyData()**

```csharp
public NiagaraDataChannelVariablePropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.niagaradatainterfacegpuparaminfopropertydata.md`:

```md
# NiagaraDataInterfaceGPUParamInfoPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class NiagaraDataInterfaceGPUParamInfoPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FNiagaraDataInterfaceGPUParamInfo]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FNiagaraDataInterfaceGPUParamInfo&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FNiagaraDataInterfaceGPUParamInfo&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [NiagaraDataInterfaceGPUParamInfoPropertyData](./uassetapi.propertytypes.structs.niagaradatainterfacegpuparaminfopropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FNiagaraDataInterfaceGPUParamInfo Value { get; set; }
```

#### Property Value

[FNiagaraDataInterfaceGPUParamInfo](./uassetapi.unrealtypes.fniagaradatainterfacegpuparaminfo.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **NiagaraDataInterfaceGPUParamInfoPropertyData(FName)**

```csharp
public NiagaraDataInterfaceGPUParamInfoPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraDataInterfaceGPUParamInfoPropertyData()**

```csharp
public NiagaraDataInterfaceGPUParamInfoPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.niagaravariablebasepropertydata.md`:

```md
# NiagaraVariableBasePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class NiagaraVariableBasePropertyData : StructPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [NiagaraVariableBasePropertyData](./uassetapi.propertytypes.structs.niagaravariablebasepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **VariableName**

```csharp
public FName VariableName;
```

### **TypeDef**

```csharp
public StructPropertyData TypeDef;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **NiagaraVariableBasePropertyData(FName, FName)**

```csharp
public NiagaraVariableBasePropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraVariableBasePropertyData(FName)**

```csharp
public NiagaraVariableBasePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraVariableBasePropertyData()**

```csharp
public NiagaraVariableBasePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.niagaravariablepropertydata.md`:

```md
# NiagaraVariablePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class NiagaraVariablePropertyData : NiagaraVariableBasePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [NiagaraVariableBasePropertyData](./uassetapi.propertytypes.structs.niagaravariablebasepropertydata.md) → [NiagaraVariablePropertyData](./uassetapi.propertytypes.structs.niagaravariablepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **VarData**

```csharp
public Byte[] VarData;
```

### **VariableName**

```csharp
public FName VariableName;
```

### **TypeDef**

```csharp
public StructPropertyData TypeDef;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **NiagaraVariablePropertyData(FName, FName)**

```csharp
public NiagaraVariablePropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraVariablePropertyData(FName)**

```csharp
public NiagaraVariablePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraVariablePropertyData()**

```csharp
public NiagaraVariablePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.niagaravariablewithoffsetpropertydata.md`:

```md
# NiagaraVariableWithOffsetPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class NiagaraVariableWithOffsetPropertyData : NiagaraVariableBasePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [NiagaraVariableBasePropertyData](./uassetapi.propertytypes.structs.niagaravariablebasepropertydata.md) → [NiagaraVariableWithOffsetPropertyData](./uassetapi.propertytypes.structs.niagaravariablewithoffsetpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **VariableOffset**

```csharp
public int VariableOffset;
```

### **VariableName**

```csharp
public FName VariableName;
```

### **TypeDef**

```csharp
public StructPropertyData TypeDef;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **NiagaraVariableWithOffsetPropertyData(FName, FName)**

```csharp
public NiagaraVariableWithOffsetPropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraVariableWithOffsetPropertyData(FName)**

```csharp
public NiagaraVariableWithOffsetPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **NiagaraVariableWithOffsetPropertyData()**

```csharp
public NiagaraVariableWithOffsetPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.perplatformboolpropertydata.md`:

```md
# PerPlatformBoolPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

[BoolPropertyData](./uassetapi.propertytypes.objects.boolpropertydata.md) ([Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)) property with per-platform overrides.

```csharp
public class PerPlatformBoolPropertyData : TPerPlatformPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Boolean[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TPerPlatformPropertyData&lt;Boolean&gt;](./uassetapi.propertytypes.structs.tperplatformpropertydata-1.md) → [PerPlatformBoolPropertyData](./uassetapi.propertytypes.structs.perplatformboolpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Boolean[] Value { get; set; }
```

#### Property Value

[Boolean[]](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PerPlatformBoolPropertyData(FName)**

```csharp
public PerPlatformBoolPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PerPlatformBoolPropertyData()**

```csharp
public PerPlatformBoolPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.perplatformfloatpropertydata.md`:

```md
# PerPlatformFloatPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

[FloatPropertyData](./uassetapi.propertytypes.objects.floatpropertydata.md) ([Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)) property with per-platform overrides.

```csharp
public class PerPlatformFloatPropertyData : TPerPlatformPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Single[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TPerPlatformPropertyData&lt;Single&gt;](./uassetapi.propertytypes.structs.tperplatformpropertydata-1.md) → [PerPlatformFloatPropertyData](./uassetapi.propertytypes.structs.perplatformfloatpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Single[] Value { get; set; }
```

#### Property Value

[Single[]](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PerPlatformFloatPropertyData(FName)**

```csharp
public PerPlatformFloatPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PerPlatformFloatPropertyData()**

```csharp
public PerPlatformFloatPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.perplatformframeratepropertydata.md`:

```md
# PerPlatformFrameRatePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

[PerPlatformFrameRatePropertyData](./uassetapi.propertytypes.structs.perplatformframeratepropertydata.md) ([FFrameRate](./uassetapi.unrealtypes.fframerate.md)) property with per-platform overrides.

```csharp
public class PerPlatformFrameRatePropertyData : TPerPlatformPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FFrameRate[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TPerPlatformPropertyData&lt;FFrameRate&gt;](./uassetapi.propertytypes.structs.tperplatformpropertydata-1.md) → [PerPlatformFrameRatePropertyData](./uassetapi.propertytypes.structs.perplatformframeratepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FFrameRate[] Value { get; set; }
```

#### Property Value

[FFrameRate[]](./uassetapi.unrealtypes.fframerate.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PerPlatformFrameRatePropertyData(FName)**

```csharp
public PerPlatformFrameRatePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PerPlatformFrameRatePropertyData()**

```csharp
public PerPlatformFrameRatePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.perplatformintpropertydata.md`:

```md
# PerPlatformIntPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

[IntPropertyData](./uassetapi.propertytypes.objects.intpropertydata.md) ([Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)) property with per-platform overrides.

```csharp
public class PerPlatformIntPropertyData : TPerPlatformPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Int32[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TPerPlatformPropertyData&lt;Int32&gt;](./uassetapi.propertytypes.structs.tperplatformpropertydata-1.md) → [PerPlatformIntPropertyData](./uassetapi.propertytypes.structs.perplatformintpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Int32[] Value { get; set; }
```

#### Property Value

[Int32[]](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PerPlatformIntPropertyData(FName)**

```csharp
public PerPlatformIntPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PerPlatformIntPropertyData()**

```csharp
public PerPlatformIntPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.perqualitylevelfloatpropertydata.md`:

```md
# PerQualityLevelFloatPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class PerQualityLevelFloatPropertyData : TPerQualityLevelPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;TPerQualityLevel&lt;Single&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TPerQualityLevelPropertyData&lt;Single&gt;](./uassetapi.propertytypes.structs.tperqualitylevelpropertydata-1.md) → [PerQualityLevelFloatPropertyData](./uassetapi.propertytypes.structs.perqualitylevelfloatpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public TPerQualityLevel<float> Value { get; set; }
```

#### Property Value

[TPerQualityLevel&lt;Single&gt;](./uassetapi.unrealtypes.tperqualitylevel-1.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PerQualityLevelFloatPropertyData(FName)**

```csharp
public PerQualityLevelFloatPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PerQualityLevelFloatPropertyData()**

```csharp
public PerQualityLevelFloatPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.perqualitylevelintpropertydata.md`:

```md
# PerQualityLevelIntPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class PerQualityLevelIntPropertyData : TPerQualityLevelPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;TPerQualityLevel&lt;Int32&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TPerQualityLevelPropertyData&lt;Int32&gt;](./uassetapi.propertytypes.structs.tperqualitylevelpropertydata-1.md) → [PerQualityLevelIntPropertyData](./uassetapi.propertytypes.structs.perqualitylevelintpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public TPerQualityLevel<int> Value { get; set; }
```

#### Property Value

[TPerQualityLevel&lt;Int32&gt;](./uassetapi.unrealtypes.tperqualitylevel-1.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PerQualityLevelIntPropertyData(FName)**

```csharp
public PerQualityLevelIntPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PerQualityLevelIntPropertyData()**

```csharp
public PerQualityLevelIntPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.planepropertydata.md`:

```md
# PlanePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A plane in 3-D space stores the coeffecients as Xx+Yy+Zz=W.

```csharp
public class PlanePropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FPlane]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FPlane&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FPlane&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [PlanePropertyData](./uassetapi.propertytypes.structs.planepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FPlane Value { get; set; }
```

#### Property Value

[FPlane](./uassetapi.unrealtypes.fplane.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **PlanePropertyData(FName)**

```csharp
public PlanePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **PlanePropertyData()**

```csharp
public PlanePropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.quatpropertydata.md`:

```md
# QuatPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Floating point quaternion that can represent a rotation about an axis in 3-D space.
 The X, Y, Z, W components also double as the Axis/Angle format.

```csharp
public class QuatPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FQuat]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FQuat&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FQuat&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [QuatPropertyData](./uassetapi.propertytypes.structs.quatpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FQuat Value { get; set; }
```

#### Property Value

[FQuat](./uassetapi.unrealtypes.fquat.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **QuatPropertyData(FName)**

```csharp
public QuatPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **QuatPropertyData()**

```csharp
public QuatPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.rawstructpropertydata.md`:

```md
# RawStructPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class RawStructPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.Byte[]]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Byte[]&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [RawStructPropertyData](./uassetapi.propertytypes.structs.rawstructpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Byte[] Value { get; set; }
```

#### Property Value

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **RawStructPropertyData(FName)**

```csharp
public RawStructPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **RawStructPropertyData()**

```csharp
public RawStructPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.richcurvekeypropertydata.md`:

```md
# RichCurveKeyPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class RichCurveKeyPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FRichCurveKey]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FRichCurveKey&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FRichCurveKey&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [RichCurveKeyPropertyData](./uassetapi.propertytypes.structs.richcurvekeypropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FRichCurveKey Value { get; set; }
```

#### Property Value

[FRichCurveKey](./uassetapi.unrealtypes.frichcurvekey.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **RichCurveKeyPropertyData(FName)**

```csharp
public RichCurveKeyPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **RichCurveKeyPropertyData()**

```csharp
public RichCurveKeyPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.rotatorpropertydata.md`:

```md
# RotatorPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Implements a container for rotation information.
 All rotation values are stored in degrees.

```csharp
public class RotatorPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FRotator]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FRotator&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FRotator&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [RotatorPropertyData](./uassetapi.propertytypes.structs.rotatorpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FRotator Value { get; set; }
```

#### Property Value

[FRotator](./uassetapi.unrealtypes.frotator.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **RotatorPropertyData(FName)**

```csharp
public RotatorPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **RotatorPropertyData()**

```csharp
public RotatorPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.scalarmaterialinputpropertydata.md`:

```md
# ScalarMaterialInputPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class ScalarMaterialInputPropertyData : MaterialInputPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Single&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MaterialInputPropertyData&lt;Single&gt;](./uassetapi.propertytypes.structs.materialinputpropertydata-1.md) → [ScalarMaterialInputPropertyData](./uassetapi.propertytypes.structs.scalarmaterialinputpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Expression**

```csharp
public FPackageIndex Expression;
```

### **OutputIndex**

```csharp
public int OutputIndex;
```

### **InputName**

```csharp
public FName InputName;
```

### **InputNameOld**

```csharp
public FString InputNameOld;
```

### **Mask**

```csharp
public int Mask;
```

### **MaskR**

```csharp
public int MaskR;
```

### **MaskG**

```csharp
public int MaskG;
```

### **MaskB**

```csharp
public int MaskB;
```

### **MaskA**

```csharp
public int MaskA;
```

### **ExpressionName**

```csharp
public FName ExpressionName;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public float Value { get; set; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ScalarMaterialInputPropertyData(FName)**

```csharp
public ScalarMaterialInputPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ScalarMaterialInputPropertyData()**

```csharp
public ScalarMaterialInputPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.sectionevaluationdatatreepropertydata.md`:

```md
# SectionEvaluationDataTreePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class SectionEvaluationDataTreePropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.FSectionEvaluationDataTree]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FSectionEvaluationDataTree&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [SectionEvaluationDataTreePropertyData](./uassetapi.propertytypes.structs.sectionevaluationdatatreepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FSectionEvaluationDataTree Value { get; set; }
```

#### Property Value

[FSectionEvaluationDataTree](./uassetapi.propertytypes.structs.fsectionevaluationdatatree.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SectionEvaluationDataTreePropertyData(FName)**

```csharp
public SectionEvaluationDataTreePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SectionEvaluationDataTreePropertyData()**

```csharp
public SectionEvaluationDataTreePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.skeletalmeshareaweightedtrianglesamplerpropertydata.md`:

```md
# SkeletalMeshAreaWeightedTriangleSamplerPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class SkeletalMeshAreaWeightedTriangleSamplerPropertyData : WeightedRandomSamplerPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FWeightedRandomSampler&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FWeightedRandomSampler&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [WeightedRandomSamplerPropertyData](./uassetapi.propertytypes.structs.weightedrandomsamplerpropertydata.md) → [SkeletalMeshAreaWeightedTriangleSamplerPropertyData](./uassetapi.propertytypes.structs.skeletalmeshareaweightedtrianglesamplerpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FWeightedRandomSampler Value { get; set; }
```

#### Property Value

[FWeightedRandomSampler](./uassetapi.unrealtypes.fweightedrandomsampler.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SkeletalMeshAreaWeightedTriangleSamplerPropertyData(FName)**

```csharp
public SkeletalMeshAreaWeightedTriangleSamplerPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SkeletalMeshAreaWeightedTriangleSamplerPropertyData()**

```csharp
public SkeletalMeshAreaWeightedTriangleSamplerPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.skeletalmeshsamplinglodbuiltdatapropertydata.md`:

```md
# SkeletalMeshSamplingLODBuiltDataPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class SkeletalMeshSamplingLODBuiltDataPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Structs.SkeletalMeshAreaWeightedTriangleSamplerPropertyData]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;SkeletalMeshAreaWeightedTriangleSamplerPropertyData&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [SkeletalMeshSamplingLODBuiltDataPropertyData](./uassetapi.propertytypes.structs.skeletalmeshsamplinglodbuiltdatapropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public SkeletalMeshAreaWeightedTriangleSamplerPropertyData Value { get; set; }
```

#### Property Value

[SkeletalMeshAreaWeightedTriangleSamplerPropertyData](./uassetapi.propertytypes.structs.skeletalmeshareaweightedtrianglesamplerpropertydata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SkeletalMeshSamplingLODBuiltDataPropertyData(FName)**

```csharp
public SkeletalMeshSamplingLODBuiltDataPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SkeletalMeshSamplingLODBuiltDataPropertyData()**

```csharp
public SkeletalMeshSamplingLODBuiltDataPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.smartnamepropertydata.md`:

```md
# SmartNamePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Special FName struct used within animations.

```csharp
public class SmartNamePropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [SmartNamePropertyData](./uassetapi.propertytypes.structs.smartnamepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **DisplayName**

The display name of this FSmartName.

```csharp
public FName DisplayName;
```

### **SmartNameID**

SmartName::UID_Type - for faster access

```csharp
public ushort SmartNameID;
```

### **TempGUID**

Uncertain

```csharp
public Guid TempGUID;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SmartNamePropertyData(FName)**

```csharp
public SmartNamePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SmartNamePropertyData()**

```csharp
public SmartNamePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.softassetpathpropertydata.md`:

```md
# SoftAssetPathPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class SoftAssetPathPropertyData : SoftObjectPathPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FSoftObjectPath&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [SoftObjectPathPropertyData](./uassetapi.propertytypes.structs.softobjectpathpropertydata.md) → [SoftAssetPathPropertyData](./uassetapi.propertytypes.structs.softassetpathpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Path**

Used in older versions of the Unreal Engine.

```csharp
public FString Path;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FSoftObjectPath Value { get; set; }
```

#### Property Value

[FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SoftAssetPathPropertyData(FName)**

```csharp
public SoftAssetPathPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SoftAssetPathPropertyData()**

```csharp
public SoftAssetPathPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.softclasspathpropertydata.md`:

```md
# SoftClassPathPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A struct that contains a string reference to a class. Can be used to make soft references to classes.

```csharp
public class SoftClassPathPropertyData : SoftObjectPathPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FSoftObjectPath&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [SoftObjectPathPropertyData](./uassetapi.propertytypes.structs.softobjectpathpropertydata.md) → [SoftClassPathPropertyData](./uassetapi.propertytypes.structs.softclasspathpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Path**

Used in older versions of the Unreal Engine.

```csharp
public FString Path;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FSoftObjectPath Value { get; set; }
```

#### Property Value

[FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SoftClassPathPropertyData(FName)**

```csharp
public SoftClassPathPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SoftClassPathPropertyData()**

```csharp
public SoftClassPathPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.softobjectpathpropertydata.md`:

```md
# SoftObjectPathPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A struct that contains a string reference to an object, either a top level asset or a subobject.
 This can be used to make soft references to assets that are loaded on demand.
 This is stored internally as an FName pointing to the top level asset (/package/path.assetname) and an option a string subobject path.

```csharp
public class SoftObjectPathPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.PropertyTypes.Objects.FSoftObjectPath]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FSoftObjectPath&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [SoftObjectPathPropertyData](./uassetapi.propertytypes.structs.softobjectpathpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Path**

Used in older versions of the Unreal Engine.

```csharp
public FString Path;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FSoftObjectPath Value { get; set; }
```

#### Property Value

[FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SoftObjectPathPropertyData(FName)**

```csharp
public SoftObjectPathPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SoftObjectPathPropertyData()**

```csharp
public SoftObjectPathPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.stringassetreferencepropertydata.md`:

```md
# StringAssetReferencePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A struct that contains a string reference to a class. Can be used to make soft references to classes.

```csharp
public class StringAssetReferencePropertyData : SoftObjectPathPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FSoftObjectPath&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [SoftObjectPathPropertyData](./uassetapi.propertytypes.structs.softobjectpathpropertydata.md) → [StringAssetReferencePropertyData](./uassetapi.propertytypes.structs.stringassetreferencepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Path**

Used in older versions of the Unreal Engine.

```csharp
public FString Path;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FSoftObjectPath Value { get; set; }
```

#### Property Value

[FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **StringAssetReferencePropertyData(FName)**

```csharp
public StringAssetReferencePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **StringAssetReferencePropertyData()**

```csharp
public StringAssetReferencePropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.stringclassreferencepropertydata.md`:

```md
# StringClassReferencePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class StringClassReferencePropertyData : SoftObjectPathPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FSoftObjectPath&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [SoftObjectPathPropertyData](./uassetapi.propertytypes.structs.softobjectpathpropertydata.md) → [StringClassReferencePropertyData](./uassetapi.propertytypes.structs.stringclassreferencepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Path**

Used in older versions of the Unreal Engine.

```csharp
public FString Path;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FSoftObjectPath Value { get; set; }
```

#### Property Value

[FSoftObjectPath](./uassetapi.propertytypes.objects.fsoftobjectpath.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **StringClassReferencePropertyData(FName)**

```csharp
public StringClassReferencePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **StringClassReferencePropertyData()**

```csharp
public StringClassReferencePropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.stringcurvekeypropertydata.md`:

```md
# StringCurveKeyPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class StringCurveKeyPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.PropertyTypes.Structs.FStringCurveKey]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FStringCurveKey&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FStringCurveKey&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [StringCurveKeyPropertyData](./uassetapi.propertytypes.structs.stringcurvekeypropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FStringCurveKey Value { get; set; }
```

#### Property Value

[FStringCurveKey](./uassetapi.propertytypes.structs.fstringcurvekey.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **StringCurveKeyPropertyData(FName)**

```csharp
public StringCurveKeyPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **StringCurveKeyPropertyData()**

```csharp
public StringCurveKeyPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.structpropertydata.md`:

```md
# StructPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class StructPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.Collections.Generic.List`1[[UAssetAPI.PropertyTypes.Objects.PropertyData]]]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasCustomStructSerialization**

Determines whether or not this particular property has custom serialization within a StructProperty.

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **StructPropertyData(FName)**

```csharp
public StructPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **StructPropertyData(FName, FName)**

```csharp
public StructPropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **StructPropertyData()**

```csharp
public StructPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **DetermineIfSerializeWithCustomStructSerialization(UAsset, PropertySerializationContext, RegistryEntry&)**

```csharp
internal bool DetermineIfSerializeWithCustomStructSerialization(UAsset Asset, PropertySerializationContext serializationContext, RegistryEntry& targetEntry)
```

#### Parameters

`Asset` [UAsset](./uassetapi.uasset.md)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

`targetEntry` [RegistryEntry&](./uassetapi.registryentry&.md)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.tevaluationtreeentrycontainer-1.md`:

```md
# TEvaluationTreeEntryContainer&lt;T&gt;

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public struct TEvaluationTreeEntryContainer<T>
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [TEvaluationTreeEntryContainer&lt;T&gt;](./uassetapi.propertytypes.structs.tevaluationtreeentrycontainer-1.md)

## Fields

### **Entries**

List of allocated entries for each allocated entry. Should only ever grow, never shrink. Shrinking would cause previously established handles to become invalid. */

```csharp
public FEntry[] Entries;
```

### **Items**

Linear array of allocated entry contents. Once allocated, indices are never invalidated until Compact is called. Entries needing more capacity are re-allocated on the end of the array.

```csharp
public T[] Items;
```

## Constructors

### **TEvaluationTreeEntryContainer(FEntry[], T[])**

```csharp
TEvaluationTreeEntryContainer(FEntry[] entries, T[] items)
```

#### Parameters

`entries` [FEntry[]](./uassetapi.propertytypes.structs.fentry.md)<br>

`items` T[]<br>

### **TEvaluationTreeEntryContainer(AssetBinaryReader, Func&lt;T&gt;)**

```csharp
TEvaluationTreeEntryContainer(AssetBinaryReader reader, Func<T> valueReader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`valueReader` Func&lt;T&gt;<br>

## Methods

### **Write(AssetBinaryWriter, Action&lt;T&gt;)**

```csharp
void Write(AssetBinaryWriter writer, Action<T> valueWriter)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`valueWriter` Action&lt;T&gt;<br>

```

`docs/src/api/uassetapi.propertytypes.structs.timespanpropertydata.md`:

```md
# TimespanPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

Implements a time span.
 A time span is the difference between two dates and times. For example, the time span between
 12:00:00 January 1, 2000 and 18:00:00 January 2, 2000 is 30.0 hours. Time spans are measured in
 positive or negative ticks depending on whether the difference is measured forward or backward.
 Each tick has a resolution of 0.1 microseconds (= 100 nanoseconds).
 
 In conjunction with the companion class [DateTimePropertyData](./uassetapi.propertytypes.structs.datetimepropertydata.md) ([DateTime](https://docs.microsoft.com/en-us/dotnet/api/system.datetime)),
 time spans can be used to perform date and time based arithmetic, such as calculating the
 difference between two dates or adding a certain amount of time to a given date.

```csharp
public class TimespanPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[System.TimeSpan]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;TimeSpan&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [TimespanPropertyData](./uassetapi.propertytypes.structs.timespanpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public TimeSpan Value { get; set; }
```

#### Property Value

[TimeSpan](https://docs.microsoft.com/en-us/dotnet/api/system.timespan)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **TimespanPropertyData(FName)**

```csharp
public TimespanPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **TimespanPropertyData()**

```csharp
public TimespanPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **HandleCloned(PropertyData)**

```csharp
protected void HandleCloned(PropertyData res)
```

#### Parameters

`res` [PropertyData](./uassetapi.propertytypes.objects.propertydata.md)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.tmoviesceneevaluationtree-1.md`:

```md
# TMovieSceneEvaluationTree&lt;T&gt;

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class TMovieSceneEvaluationTree<T> : FMovieSceneEvaluationTree
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FMovieSceneEvaluationTree](./uassetapi.propertytypes.structs.fmoviesceneevaluationtree.md) → [TMovieSceneEvaluationTree&lt;T&gt;](./uassetapi.propertytypes.structs.tmoviesceneevaluationtree-1.md)

## Fields

### **Data**

Tree data container that corresponds to FMovieSceneEvaluationTreeNode::DataID

```csharp
public TEvaluationTreeEntryContainer<T> Data;
```

### **RootNode**

This tree's root node

```csharp
public FMovieSceneEvaluationTreeNode RootNode;
```

### **ChildNodes**

Segmented array of all child nodes within this tree (in no particular order)

```csharp
public TEvaluationTreeEntryContainer<FMovieSceneEvaluationTreeNode> ChildNodes;
```

## Constructors

### **TMovieSceneEvaluationTree(AssetBinaryReader, Func&lt;T&gt;)**

```csharp
public TMovieSceneEvaluationTree(AssetBinaryReader reader, Func<T> valueReader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`valueReader` Func&lt;T&gt;<br>

## Methods

### **Write(AssetBinaryWriter, Action&lt;T&gt;)**

```csharp
public void Write(AssetBinaryWriter writer, Action<T> valueWriter)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`valueWriter` Action&lt;T&gt;<br>

```

`docs/src/api/uassetapi.propertytypes.structs.twovectorspropertydata.md`:

```md
# TwoVectorsPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class TwoVectorsPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FTwoVectors]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FTwoVectors&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FTwoVectors&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [TwoVectorsPropertyData](./uassetapi.propertytypes.structs.twovectorspropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FTwoVectors Value { get; set; }
```

#### Property Value

[FTwoVectors](./uassetapi.unrealtypes.ftwovectors.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **TwoVectorsPropertyData(FName)**

```csharp
public TwoVectorsPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **TwoVectorsPropertyData()**

```csharp
public TwoVectorsPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vector2dpropertydata.md`:

```md
# Vector2DPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A vector in 2-D space composed of components (X, Y) with floating/double point precision.

```csharp
public class Vector2DPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FVector2D]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FVector2D&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FVector2D&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [Vector2DPropertyData](./uassetapi.propertytypes.structs.vector2dpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FVector2D Value { get; set; }
```

#### Property Value

[FVector2D](./uassetapi.unrealtypes.fvector2d.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **Vector2DPropertyData(FName)**

```csharp
public Vector2DPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Vector2DPropertyData()**

```csharp
public Vector2DPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vector2fpropertydata.md`:

```md
# Vector2fPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A vector in 2-D space composed of components (X, Y) with floating/double point precision.

```csharp
public class Vector2fPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FVector2f]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FVector2f&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FVector2f&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [Vector2fPropertyData](./uassetapi.propertytypes.structs.vector2fpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FVector2f Value { get; set; }
```

#### Property Value

[FVector2f](./uassetapi.unrealtypes.fvector2f.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **Vector2fPropertyData(FName)**

```csharp
public Vector2fPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Vector2fPropertyData()**

```csharp
public Vector2fPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vector2materialinputpropertydata.md`:

```md
# Vector2MaterialInputPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class Vector2MaterialInputPropertyData : MaterialInputPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;Vector2DPropertyData&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MaterialInputPropertyData&lt;Vector2DPropertyData&gt;](./uassetapi.propertytypes.structs.materialinputpropertydata-1.md) → [Vector2MaterialInputPropertyData](./uassetapi.propertytypes.structs.vector2materialinputpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Expression**

```csharp
public FPackageIndex Expression;
```

### **OutputIndex**

```csharp
public int OutputIndex;
```

### **InputName**

```csharp
public FName InputName;
```

### **InputNameOld**

```csharp
public FString InputNameOld;
```

### **Mask**

```csharp
public int Mask;
```

### **MaskR**

```csharp
public int MaskR;
```

### **MaskG**

```csharp
public int MaskG;
```

### **MaskB**

```csharp
public int MaskB;
```

### **MaskA**

```csharp
public int MaskA;
```

### **ExpressionName**

```csharp
public FName ExpressionName;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public Vector2DPropertyData Value { get; set; }
```

#### Property Value

[Vector2DPropertyData](./uassetapi.propertytypes.structs.vector2dpropertydata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **Vector2MaterialInputPropertyData(FName)**

```csharp
public Vector2MaterialInputPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Vector2MaterialInputPropertyData()**

```csharp
public Vector2MaterialInputPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.vector3fpropertydata.md`:

```md
# Vector3fPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A vector in 3-D space composed of components (X, Y, Z) with floating point precision.

```csharp
public class Vector3fPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FVector3f]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FVector3f&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FVector3f&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [Vector3fPropertyData](./uassetapi.propertytypes.structs.vector3fpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FVector3f Value { get; set; }
```

#### Property Value

[FVector3f](./uassetapi.unrealtypes.fvector3f.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **Vector3fPropertyData(FName)**

```csharp
public Vector3fPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Vector3fPropertyData()**

```csharp
public Vector3fPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vector4fpropertydata.md`:

```md
# Vector4fPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A vector in 4-D space composed of components (X, Y, Z, W) with floating point precision.

```csharp
public class Vector4fPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FVector4f]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FVector4f&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FVector4f&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [Vector4fPropertyData](./uassetapi.propertytypes.structs.vector4fpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FVector4f Value { get; set; }
```

#### Property Value

[FVector4f](./uassetapi.unrealtypes.fvector4f.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **Vector4fPropertyData(FName)**

```csharp
public Vector4fPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Vector4fPropertyData()**

```csharp
public Vector4fPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vector4propertydata.md`:

```md
# Vector4PropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A vector in 4-D space composed of components (X, Y, Z, W) with floating/double point precision.

```csharp
public class Vector4PropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FVector4]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FVector4&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FVector4&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [Vector4PropertyData](./uassetapi.propertytypes.structs.vector4propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FVector4 Value { get; set; }
```

#### Property Value

[FVector4](./uassetapi.unrealtypes.fvector4.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **Vector4PropertyData(FName)**

```csharp
public Vector4PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **Vector4PropertyData()**

```csharp
public Vector4PropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vectormaterialinputpropertydata.md`:

```md
# VectorMaterialInputPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class VectorMaterialInputPropertyData : MaterialInputPropertyData`1, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;VectorPropertyData&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [MaterialInputPropertyData&lt;VectorPropertyData&gt;](./uassetapi.propertytypes.structs.materialinputpropertydata-1.md) → [VectorMaterialInputPropertyData](./uassetapi.propertytypes.structs.vectormaterialinputpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Expression**

```csharp
public FPackageIndex Expression;
```

### **OutputIndex**

```csharp
public int OutputIndex;
```

### **InputName**

```csharp
public FName InputName;
```

### **InputNameOld**

```csharp
public FString InputNameOld;
```

### **Mask**

```csharp
public int Mask;
```

### **MaskR**

```csharp
public int MaskR;
```

### **MaskG**

```csharp
public int MaskG;
```

### **MaskB**

```csharp
public int MaskB;
```

### **MaskA**

```csharp
public int MaskA;
```

### **ExpressionName**

```csharp
public FName ExpressionName;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public VectorPropertyData Value { get; set; }
```

#### Property Value

[VectorPropertyData](./uassetapi.propertytypes.structs.vectorpropertydata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **VectorMaterialInputPropertyData(FName)**

```csharp
public VectorMaterialInputPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **VectorMaterialInputPropertyData()**

```csharp
public VectorMaterialInputPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.vectornetquantize100propertydata.md`:

```md
# VectorNetQuantize100PropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class VectorNetQuantize100PropertyData : VectorNetQuantizePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [VectorNetQuantizePropertyData](./uassetapi.propertytypes.structs.vectornetquantizepropertydata.md) → [VectorNetQuantize100PropertyData](./uassetapi.propertytypes.structs.vectornetquantize100propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **VectorNetQuantize100PropertyData(FName)**

```csharp
public VectorNetQuantize100PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **VectorNetQuantize100PropertyData()**

```csharp
public VectorNetQuantize100PropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vectornetquantize10propertydata.md`:

```md
# VectorNetQuantize10PropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class VectorNetQuantize10PropertyData : VectorNetQuantizePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [VectorNetQuantizePropertyData](./uassetapi.propertytypes.structs.vectornetquantizepropertydata.md) → [VectorNetQuantize10PropertyData](./uassetapi.propertytypes.structs.vectornetquantize10propertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **VectorNetQuantize10PropertyData(FName)**

```csharp
public VectorNetQuantize10PropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **VectorNetQuantize10PropertyData()**

```csharp
public VectorNetQuantize10PropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vectornetquantizenormalpropertydata.md`:

```md
# VectorNetQuantizeNormalPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class VectorNetQuantizeNormalPropertyData : VectorNetQuantizePropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [VectorNetQuantizePropertyData](./uassetapi.propertytypes.structs.vectornetquantizepropertydata.md) → [VectorNetQuantizeNormalPropertyData](./uassetapi.propertytypes.structs.vectornetquantizenormalpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **VectorNetQuantizeNormalPropertyData(FName)**

```csharp
public VectorNetQuantizeNormalPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **VectorNetQuantizeNormalPropertyData()**

```csharp
public VectorNetQuantizeNormalPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.vectornetquantizepropertydata.md`:

```md
# VectorNetQuantizePropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class VectorNetQuantizePropertyData : StructPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [VectorNetQuantizePropertyData](./uassetapi.propertytypes.structs.vectornetquantizepropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **VectorNetQuantizePropertyData(FName, FName)**

```csharp
public VectorNetQuantizePropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **VectorNetQuantizePropertyData(FName)**

```csharp
public VectorNetQuantizePropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **VectorNetQuantizePropertyData()**

```csharp
public VectorNetQuantizePropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.vectorpropertydata.md`:

```md
# VectorPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A vector in 3-D space composed of components (X, Y, Z) with floating/double point precision.

```csharp
public class VectorPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FVector]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FVector&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FVector&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [VectorPropertyData](./uassetapi.propertytypes.structs.vectorpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FVector Value { get; set; }
```

#### Property Value

[FVector](./uassetapi.unrealtypes.fvector.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **VectorPropertyData(FName)**

```csharp
public VectorPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **VectorPropertyData()**

```csharp
public VectorPropertyData()
```

```

`docs/src/api/uassetapi.propertytypes.structs.viewtargetblendfunction.md`:

```md
# ViewTargetBlendFunction

Namespace: UAssetAPI.PropertyTypes.Structs

Options that define how to blend when changing view targets in [ViewTargetBlendParamsPropertyData](./uassetapi.propertytypes.structs.viewtargetblendparamspropertydata.md).

```csharp
public enum ViewTargetBlendFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ViewTargetBlendFunction](./uassetapi.propertytypes.structs.viewtargetblendfunction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.propertytypes.structs.viewtargetblendparamspropertydata.md`:

```md
# ViewTargetBlendParamsPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

A set of parameters to describe how to transition between view targets.
 Referred to as FViewTargetTransitionParams in the Unreal Engine.

```csharp
public class ViewTargetBlendParamsPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [ViewTargetBlendParamsPropertyData](./uassetapi.propertytypes.structs.viewtargetblendparamspropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **BlendTime**

```csharp
public float BlendTime;
```

### **BlendFunction**

```csharp
public ViewTargetBlendFunction BlendFunction;
```

### **BlendExp**

```csharp
public float BlendExp;
```

### **bLockOutgoing**

```csharp
public bool bLockOutgoing;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **ViewTargetBlendParamsPropertyData(FName)**

```csharp
public ViewTargetBlendParamsPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **ViewTargetBlendParamsPropertyData()**

```csharp
public ViewTargetBlendParamsPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public void FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.propertytypes.structs.weightedrandomsamplerpropertydata.md`:

```md
# WeightedRandomSamplerPropertyData

Namespace: UAssetAPI.PropertyTypes.Structs

```csharp
public class WeightedRandomSamplerPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FWeightedRandomSampler]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FWeightedRandomSampler&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FWeightedRandomSampler&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [WeightedRandomSamplerPropertyData](./uassetapi.propertytypes.structs.weightedrandomsamplerpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FWeightedRandomSampler Value { get; set; }
```

#### Property Value

[FWeightedRandomSampler](./uassetapi.unrealtypes.fweightedrandomsampler.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **WeightedRandomSamplerPropertyData(FName)**

```csharp
public WeightedRandomSamplerPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **WeightedRandomSamplerPropertyData()**

```csharp
public WeightedRandomSamplerPropertyData()
```

```

`docs/src/api/uassetapi.repakinterop.md`:

```md
# RePakInterop

Namespace: UAssetAPI

```csharp
public static class RePakInterop
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [RePakInterop](./uassetapi.repakinterop.md)

## Fields

### **NativeLib**

```csharp
public static string NativeLib;
```

## Methods

### **pak_setup_allocator()**

```csharp
public static IntPtr pak_setup_allocator()
```

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_teardown_allocator()**

```csharp
public static IntPtr pak_teardown_allocator()
```

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_builder_new()**

```csharp
public static IntPtr pak_builder_new()
```

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_builder_drop(IntPtr)**

```csharp
public static void pak_builder_drop(IntPtr builder)
```

#### Parameters

`builder` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_reader_drop(IntPtr)**

```csharp
public static void pak_reader_drop(IntPtr reader)
```

#### Parameters

`reader` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_writer_drop(IntPtr)**

```csharp
public static void pak_writer_drop(IntPtr writer)
```

#### Parameters

`writer` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_buffer_drop(IntPtr, UInt64)**

```csharp
public static void pak_buffer_drop(IntPtr buffer, ulong length)
```

#### Parameters

`buffer` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`length` [UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

### **pak_cstring_drop(IntPtr)**

```csharp
public static void pak_cstring_drop(IntPtr cstrign)
```

#### Parameters

`cstrign` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_builder_key(IntPtr, Byte[])**

```csharp
public static IntPtr pak_builder_key(IntPtr builder, Byte[] key)
```

#### Parameters

`builder` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`key` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_builder_compression(IntPtr, Byte[], Int32)**

```csharp
public static IntPtr pak_builder_compression(IntPtr builder, Byte[] compressions, int length)
```

#### Parameters

`builder` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`compressions` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`length` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_builder_reader(IntPtr, StreamCallbacks)**

```csharp
public static IntPtr pak_builder_reader(IntPtr builder, StreamCallbacks ctx)
```

#### Parameters

`builder` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`ctx` [StreamCallbacks](./uassetapi.repakinterop.streamcallbacks.md)<br>

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_builder_writer(IntPtr, StreamCallbacks, PakVersion, String, UInt64)**

```csharp
public static IntPtr pak_builder_writer(IntPtr builder, StreamCallbacks ctx, PakVersion version, string mount_point, ulong path_hash_seed)
```

#### Parameters

`builder` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`ctx` [StreamCallbacks](./uassetapi.repakinterop.streamcallbacks.md)<br>

`version` [PakVersion](./uassetapi.pakversion.md)<br>

`mount_point` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`path_hash_seed` [UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_reader_version(IntPtr)**

```csharp
public static PakVersion pak_reader_version(IntPtr reader)
```

#### Parameters

`reader` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

#### Returns

[PakVersion](./uassetapi.pakversion.md)<br>

### **pak_reader_mount_point(IntPtr)**

```csharp
public static IntPtr pak_reader_mount_point(IntPtr reader)
```

#### Parameters

`reader` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_reader_get(IntPtr, String, StreamCallbacks, IntPtr&, UInt64&)**

```csharp
public static int pak_reader_get(IntPtr reader, string path, StreamCallbacks ctx, IntPtr& buffer, UInt64& length)
```

#### Parameters

`reader` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`ctx` [StreamCallbacks](./uassetapi.repakinterop.streamcallbacks.md)<br>

`buffer` [IntPtr&](https://docs.microsoft.com/en-us/dotnet/api/system.intptr&)<br>

`length` [UInt64&](https://docs.microsoft.com/en-us/dotnet/api/system.uint64&)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **pak_reader_files(IntPtr, UInt64&)**

```csharp
public static IntPtr pak_reader_files(IntPtr reader, UInt64& length)
```

#### Parameters

`reader` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`length` [UInt64&](https://docs.microsoft.com/en-us/dotnet/api/system.uint64&)<br>

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_drop_files(IntPtr, UInt64)**

```csharp
public static IntPtr pak_drop_files(IntPtr buffer, ulong length)
```

#### Parameters

`buffer` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`length` [UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

#### Returns

[IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **pak_writer_write_file(IntPtr, String, Byte[], Int32)**

```csharp
public static int pak_writer_write_file(IntPtr writer, string path, Byte[] data, int data_len)
```

#### Parameters

`writer` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`data` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`data_len` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **pak_writer_write_index(IntPtr)**

```csharp
public static int pak_writer_write_index(IntPtr writer)
```

#### Parameters

`writer` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.streamcallbacks.md`:

```md
# StreamCallbacks

Namespace: UAssetAPI

```csharp
public static class StreamCallbacks
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [StreamCallbacks](./uassetapi.streamcallbacks.md)

## Methods

### **Create(Stream)**

```csharp
public static StreamCallbacks Create(Stream stream)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

#### Returns

[StreamCallbacks](./uassetapi.repakinterop.streamcallbacks.md)<br>

### **Free(IntPtr)**

```csharp
public static void Free(IntPtr streamCtx)
```

#### Parameters

`streamCtx` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

### **ReadCallback(IntPtr, IntPtr, UInt64)**

```csharp
public static long ReadCallback(IntPtr context, IntPtr buffer, ulong bufferLen)
```

#### Parameters

`context` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`buffer` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`bufferLen` [UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

#### Returns

[Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

### **WriteCallback(IntPtr, IntPtr, Int32)**

```csharp
public static int WriteCallback(IntPtr context, IntPtr buffer, int bufferLen)
```

#### Parameters

`context` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`buffer` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`bufferLen` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **SeekCallback(IntPtr, Int64, Int32)**

```csharp
public static ulong SeekCallback(IntPtr context, long offset, int origin)
```

#### Parameters

`context` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

`offset` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`origin` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

### **FlushCallback(IntPtr)**

```csharp
public static int FlushCallback(IntPtr context)
```

#### Parameters

`context` [IntPtr](https://docs.microsoft.com/en-us/dotnet/api/system.intptr)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.structtypes.skeletalmeshsamplingregionbuiltdatapropertydata.md`:

```md
# SkeletalMeshSamplingRegionBuiltDataPropertyData

Namespace: UAssetAPI.StructTypes

```csharp
public class SkeletalMeshSamplingRegionBuiltDataPropertyData : UAssetAPI.PropertyTypes.Objects.BasePropertyData`1[[UAssetAPI.UnrealTypes.FSkeletalMeshSamplingRegionBuiltData]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FSkeletalMeshSamplingRegionBuiltData&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [BasePropertyData&lt;FSkeletalMeshSamplingRegionBuiltData&gt;](./uassetapi.propertytypes.objects.basepropertydata-1.md) → [SkeletalMeshSamplingRegionBuiltDataPropertyData](./uassetapi.structtypes.skeletalmeshsamplingregionbuiltdatapropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FSkeletalMeshSamplingRegionBuiltData Value { get; set; }
```

#### Property Value

[FSkeletalMeshSamplingRegionBuiltData](./uassetapi.unrealtypes.fskeletalmeshsamplingregionbuiltdata.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **SkeletalMeshSamplingRegionBuiltDataPropertyData(FName)**

```csharp
public SkeletalMeshSamplingRegionBuiltDataPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **SkeletalMeshSamplingRegionBuiltDataPropertyData()**

```csharp
public SkeletalMeshSamplingRegionBuiltDataPropertyData()
```

```

`docs/src/api/uassetapi.uaputils.md`:

```md
# UAPUtils

Namespace: UAssetAPI

```csharp
public static class UAPUtils
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UAPUtils](./uassetapi.uaputils.md)

## Fields

### **CurrentCommit**

```csharp
public static string CurrentCommit;
```

## Methods

### **SerializeJson(Object, Boolean)**

```csharp
public static string SerializeJson(object obj, bool isFormatted)
```

#### Parameters

`obj` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`isFormatted` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FindAllInstances&lt;T&gt;(Object)**

```csharp
public static List<T> FindAllInstances<T>(object parent)
```

#### Type Parameters

`T`<br>

#### Parameters

`parent` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

#### Returns

List&lt;T&gt;<br>

### **Clamp&lt;T&gt;(T, T, T)**

```csharp
public static T Clamp<T>(T val, T min, T max)
```

#### Type Parameters

`T`<br>

#### Parameters

`val` T<br>

`min` T<br>

`max` T<br>

#### Returns

T<br>

### **GetOrderedFields&lt;T&gt;()**

```csharp
public static FieldInfo[] GetOrderedFields<T>()
```

#### Type Parameters

`T`<br>

#### Returns

[FieldInfo[]](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.fieldinfo)<br>

### **GetOrderedFields(Type)**

```csharp
public static FieldInfo[] GetOrderedFields(Type t)
```

#### Parameters

`t` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[FieldInfo[]](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.fieldinfo)<br>

### **GetOrderedMembers&lt;T&gt;()**

```csharp
public static MemberInfo[] GetOrderedMembers<T>()
```

#### Type Parameters

`T`<br>

#### Returns

[MemberInfo[]](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo)<br>

### **GetOrderedMembers(Type)**

```csharp
public static MemberInfo[] GetOrderedMembers(Type t)
```

#### Parameters

`t` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[MemberInfo[]](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo)<br>

### **GetValue(MemberInfo, Object)**

```csharp
public static object GetValue(MemberInfo memberInfo, object forObject)
```

#### Parameters

`memberInfo` [MemberInfo](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo)<br>

`forObject` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **SetValue(MemberInfo, Object, Object)**

```csharp
public static void SetValue(MemberInfo memberInfo, object forObject, object forVal)
```

#### Parameters

`memberInfo` [MemberInfo](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo)<br>

`forObject` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

`forVal` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **GetImportNameReferenceWithoutZero(Int32, UAsset)**

```csharp
public static FString GetImportNameReferenceWithoutZero(int j, UAsset asset)
```

#### Parameters

`j` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **InterpretAsGuidAndConvertToUnsignedInts(String)**

```csharp
public static UInt32[] InterpretAsGuidAndConvertToUnsignedInts(string value)
```

#### Parameters

`value` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[UInt32[]](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **ConvertStringToByteArray(String)**

```csharp
public static Byte[] ConvertStringToByteArray(string val)
```

#### Parameters

`val` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **ToUnsignedInts(Guid)**

```csharp
public static UInt32[] ToUnsignedInts(Guid value)
```

#### Parameters

`value` [Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>

#### Returns

[UInt32[]](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **GUID(UInt32, UInt32, UInt32, UInt32)**

```csharp
public static Guid GUID(uint value1, uint value2, uint value3, uint value4)
```

#### Parameters

`value1` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`value2` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`value3` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`value4` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

#### Returns

[Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>

### **ConvertToGUID(String)**

```csharp
public static Guid ConvertToGUID(string GuidString)
```

#### Parameters

`GuidString` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>

### **ConvertToString(Guid)**

```csharp
public static string ConvertToString(Guid val)
```

#### Parameters

`val` [Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **ConvertHexStringToByteArray(String)**

```csharp
public static Byte[] ConvertHexStringToByteArray(string hexString)
```

#### Parameters

`hexString` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **AlignPadding(Int64, Int32)**

```csharp
public static long AlignPadding(long pos, int align)
```

#### Parameters

`pos` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`align` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

### **AlignPadding(Int32, Int32)**

```csharp
public static int AlignPadding(int pos, int align)
```

#### Parameters

`pos` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`align` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **DivideAndRoundUp(Int32, Int32)**

```csharp
public static int DivideAndRoundUp(int a, int b)
```

#### Parameters

`a` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`b` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FixDirectorySeparatorsForDisk(String)**

```csharp
public static string FixDirectorySeparatorsForDisk(string path)
```

#### Parameters

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **SortByDependencies&lt;T&gt;(IEnumerable&lt;T&gt;, IDictionary&lt;T, IList&lt;T&gt;&gt;)**

```csharp
public static List<T> SortByDependencies<T>(IEnumerable<T> allExports, IDictionary<T, IList<T>> dependencies)
```

#### Type Parameters

`T`<br>

#### Parameters

`allExports` IEnumerable&lt;T&gt;<br>

`dependencies` IDictionary&lt;T, IList&lt;T&gt;&gt;<br>

#### Returns

List&lt;T&gt;<br>

```

`docs/src/api/uassetapi.uasset.md`:

```md
# UAsset

Namespace: UAssetAPI

Represents an Unreal Engine asset.

```csharp
public class UAsset : INameMap
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UAsset](./uassetapi.uasset.md)<br>
Implements [INameMap](./uassetapi.inamemap.md)

## Fields

### **Info**

Agent string to provide context in serialized JSON.

```csharp
public string Info;
```

### **FilePath**

The path of the file on disk that this asset represents. This does not need to be specified for regular parsing.

```csharp
public string FilePath;
```

### **Mappings**

The corresponding mapping data for the game that this asset is from. Optional unless unversioned properties are present.

```csharp
public Usmap Mappings;
```

### **CustomSerializationFlags**

List of custom serialization flags, used to override certain optional behavior in how UAssetAPI serializes assets.

```csharp
public CustomSerializationFlags CustomSerializationFlags;
```

### **UseSeparateBulkDataFiles**

Should the asset be split into separate .uasset, .uexp, and .ubulk files, as opposed to one single .uasset file?

```csharp
public bool UseSeparateBulkDataFiles;
```

### **IsUnversioned**

Should this asset not serialize its engine and custom versions?

```csharp
public bool IsUnversioned;
```

### **FileVersionLicenseeUE**

The licensee file version. Used by some games to add their own Engine-level versioning.

```csharp
public int FileVersionLicenseeUE;
```

### **ObjectVersion**

The object version of UE4 that will be used to parse this asset.

```csharp
public ObjectVersion ObjectVersion;
```

### **ObjectVersionUE5**

The object version of UE5 that will be used to parse this asset. Set to [ObjectVersionUE5.UNKNOWN](./uassetapi.unrealtypes.objectversionue5.md#unknown) for UE4 games.

```csharp
public ObjectVersionUE5 ObjectVersionUE5;
```

### **CustomVersionContainer**

All the custom versions stored in the archive.

```csharp
public List<CustomVersion> CustomVersionContainer;
```

### **SoftObjectPathList**

List of SoftObjectPath contained in this package.

```csharp
public List<FSoftObjectPath> SoftObjectPathList;
```

### **GatherableTextData**

Map of the gatherable text data.

```csharp
public List<FGatherableTextData> GatherableTextData;
```

### **Exports**

Map of object exports. UAssetAPI used to call these "categories."

```csharp
public List<Export> Exports;
```

### **SearchableNames**

List of Searchable Names, by object containing them. Sorted to keep order consistent.

```csharp
public SortedDictionary<FPackageIndex, List<FName>> SearchableNames;
```

### **Thumbnails**

Map of object full names to the thumbnails

```csharp
public Dictionary<string, FObjectThumbnail> Thumbnails;
```

### **WorldTileInfo**

Tile information used by WorldComposition.
 Defines properties necessary for tile positioning in the world.

```csharp
public FWorldTileInfo WorldTileInfo;
```

### **AppendedNullBytes**

The number of null bytes appended to the end of the package header (.uasset file).
 This should typically be zero, but may be greater when reading assets generated by external tools.

```csharp
public int AppendedNullBytes;
```

### **MapStructTypeOverride**

In MapProperties that have StructProperties as their keys or values, there is no universal, context-free way to determine the type of the struct.



To that end, this dictionary maps MapProperty names to the type of the structs within them (tuple of key struct type and value struct type) if they are not None-terminated property lists.

```csharp
public Dictionary<string, Tuple<FString, FString>> MapStructTypeOverride;
```

### **ArrayStructTypeOverride**

IN ENGINE VERSIONS BEFORE [ObjectVersion.VER_UE4_INNER_ARRAY_TAG_INFO](./uassetapi.unrealtypes.objectversion.md#ver_ue4_inner_array_tag_info):



In ArrayProperties that have StructProperties as their keys or values, there is no universal, context-free way to determine the type of the struct. To that end, this dictionary maps ArrayProperty names to the type of the structs within them.

```csharp
public Dictionary<string, FString> ArrayStructTypeOverride;
```

### **OtherAssetsFailedToAccess**

```csharp
public ISet<FName> OtherAssetsFailedToAccess;
```

### **LegacyFileVersion**

The package file version number when this package was saved.

```csharp
public int LegacyFileVersion;
```

**Remarks:**

The lower 16 bits stores the UE3 engine version, while the upper 16 bits stores the UE4/licensee version. For newer packages this is -7.
 VersionDescription-2indicates presence of enum-based custom versions-3indicates guid-based custom versions-4indicates removal of the UE3 version. Packages saved with this ID cannot be loaded in older engine versions-5indicates the replacement of writing out the "UE3 version" so older versions of engine can gracefully fail to open newer packages-6indicates optimizations to how custom versions are being serialized-7indicates the texture allocation info has been removed from the summary-8indicates that the UE5 version has been added to the summary-9indicates a contractual change in when early exits are required based on FileVersionTooNew. At or after this LegacyFileVersion, we support changing the PackageFileSummary serialization format for all bytes serialized after FileVersionLicensee, and that format change can be conditional on any of the versions parsed before that point. All packageloaders that understand the -9 legacyfileformat are required to early exit without further serialization at that point if FileVersionTooNew is true.

### **DataResourceVersion**

The version to use for serializing data resources.

```csharp
public EObjectDataResourceVersion DataResourceVersion;
```

### **DataResources**

List of serialized UObject binary/bulk data resources.

```csharp
public List<FObjectDataResource> DataResources;
```

### **UsesEventDrivenLoader**

Whether or not this asset is loaded with the Event Driven Loader.

```csharp
public bool UsesEventDrivenLoader;
```

### **WillSerializeNameHashes**

Whether or not this asset serializes hashes in the name map.
 If null, this will be automatically determined based on the object version.

```csharp
public Nullable<bool> WillSerializeNameHashes;
```

### **Imports**

Map of object imports. UAssetAPI used to call these "links."

```csharp
public List<Import> Imports;
```

### **DependsMap**

List of dependency lists for each export.

```csharp
public List<Int32[]> DependsMap;
```

### **SoftPackageReferenceList**

List of packages that are soft referenced by this package.

```csharp
public List<FString> SoftPackageReferenceList;
```

### **AssetRegistryData**

Uncertain

```csharp
public Byte[] AssetRegistryData;
```

### **BulkData**

Any bulk data that is not stored in the export map.

```csharp
public Byte[] BulkData;
```

### **ValorantGarbageData**

Some garbage data that appears to be present in certain games (e.g. Valorant)

```csharp
public Byte[] ValorantGarbageData;
```

### **SeaOfThievesGarbageData**

Some garbage data that appears to be present in certain games (e.g. Sea of Thieves)
 null = not present
 empty array = present, but serialize as offset = 0, length = 0

```csharp
public Byte[] SeaOfThievesGarbageData;
```

### **Generations**

Data about previous versions of this package.

```csharp
public List<FGenerationInfo> Generations;
```

### **PackageGuid**

Current ID for this package. Effectively unused.

```csharp
public Guid PackageGuid;
```

### **PersistentGuid**

Current persistent ID for this package.

```csharp
public Guid PersistentGuid;
```

### **RecordedEngineVersion**

Engine version this package was saved with. This may differ from CompatibleWithEngineVersion for assets saved with a hotfix release.

```csharp
public FEngineVersion RecordedEngineVersion;
```

### **RecordedCompatibleWithEngineVersion**

Engine version this package is compatible with. Assets saved by Hotfix releases and engine versions that maintain binary compatibility will have
 a CompatibleWithEngineVersion.Patch that matches the original release (as opposed to SavedByEngineVersion which will have a patch version of the new release).

```csharp
public FEngineVersion RecordedCompatibleWithEngineVersion;
```

### **ChunkIDs**

Streaming install ChunkIDs

```csharp
public Int32[] ChunkIDs;
```

### **PackageSource**

Value that is used by the Unreal Engine to determine if the package was saved by Epic, a licensee, modder, etc.

```csharp
public uint PackageSource;
```

### **FolderName**

In UE4: "FolderName": The Generic Browser folder name that this package lives in. Usually "None" in cooked assets.
 In UE5: "PackageName": The package name the file was last saved with.

```csharp
public FString FolderName;
```

### **OverrideNameMapHashes**

A map of name map entries to hashes to use when serializing instead of the default engine hash algorithm. Useful when external programs improperly specify name map hashes and binary equality must be maintained.

```csharp
public Dictionary<FString, uint> OverrideNameMapHashes;
```

### **LocalizationId**

Localization ID of this package

```csharp
public FString LocalizationId;
```

### **UASSET_MAGIC**

Magic number for the .uasset format

```csharp
public static uint UASSET_MAGIC;
```

### **ACE7_MAGIC**

Magic number for Ace Combat 7 encrypted .uasset format

```csharp
public static uint ACE7_MAGIC;
```

## Properties

### **PackageFlags**

The flags for this package.

```csharp
public EPackageFlags PackageFlags { get; set; }
```

#### Property Value

[EPackageFlags](./uassetapi.unrealtypes.epackageflags.md)<br>

### **HasUnversionedProperties**

Whether or not this asset uses unversioned properties.

```csharp
public bool HasUnversionedProperties { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IsFilterEditorOnly**

Whether or not this asset has PKG_FilterEditorOnly flag.

```csharp
public bool IsFilterEditorOnly { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **UAsset(String, EngineVersion, Usmap, CustomSerializationFlags)**

Reads an asset from disk and initializes a new instance of the [UAsset](./uassetapi.uasset.md) class to store its data in memory.

```csharp
public UAsset(string path, EngineVersion engineVersion, Usmap mappings, CustomSerializationFlags customSerializationFlags)
```

#### Parameters

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path of the asset file on disk that this instance will read from.

`engineVersion` [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>
The version of the Unreal Engine that will be used to parse this asset. If the asset is versioned, this can be left unspecified.

`mappings` [Usmap](./uassetapi.unversioned.usmap.md)<br>
A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.

`customSerializationFlags` [CustomSerializationFlags](./uassetapi.customserializationflags.md)<br>
A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.

#### Exceptions

[UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Thrown when this is an unversioned asset and [UAsset.ObjectVersion](./uassetapi.uasset.md#objectversion) is unspecified.

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the asset cannot be parsed correctly.

### **UAsset(String, Boolean, EngineVersion, Usmap, CustomSerializationFlags)**

Reads an asset from disk and initializes a new instance of the [UAsset](./uassetapi.uasset.md) class to store its data in memory.

```csharp
public UAsset(string path, bool loadUexp, EngineVersion engineVersion, Usmap mappings, CustomSerializationFlags customSerializationFlags)
```

#### Parameters

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path of the asset file on disk that this instance will read from.

`loadUexp` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether to load the .uexp file. False only reads the .uasset file.

`engineVersion` [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>
The version of the Unreal Engine that will be used to parse this asset. If the asset is versioned, this can be left unspecified.

`mappings` [Usmap](./uassetapi.unversioned.usmap.md)<br>
A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.

`customSerializationFlags` [CustomSerializationFlags](./uassetapi.customserializationflags.md)<br>
A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.

#### Exceptions

[UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Thrown when this is an unversioned asset and [UAsset.ObjectVersion](./uassetapi.uasset.md#objectversion) is unspecified.

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the asset cannot be parsed correctly.

### **UAsset(AssetBinaryReader, EngineVersion, Usmap, Boolean, CustomSerializationFlags)**

Reads an asset from a BinaryReader and initializes a new instance of the [UAsset](./uassetapi.uasset.md) class to store its data in memory.

```csharp
public UAsset(AssetBinaryReader reader, EngineVersion engineVersion, Usmap mappings, bool useSeparateBulkDataFiles, CustomSerializationFlags customSerializationFlags)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The asset's BinaryReader that this instance will read from. If a .uexp file exists, the .uexp file's data should be appended to the end of the .uasset file's data.

`engineVersion` [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>
The version of the Unreal Engine that will be used to parse this asset. If the asset is versioned, this can be left unspecified.

`mappings` [Usmap](./uassetapi.unversioned.usmap.md)<br>
A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.

`useSeparateBulkDataFiles` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Does this asset uses separate bulk data files (.uexp, .ubulk)?

`customSerializationFlags` [CustomSerializationFlags](./uassetapi.customserializationflags.md)<br>
A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.

#### Exceptions

[UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Thrown when this is an unversioned asset and [UAsset.ObjectVersion](./uassetapi.uasset.md#objectversion) is unspecified.

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the asset cannot be parsed correctly.

### **UAsset(EngineVersion, Usmap, CustomSerializationFlags)**

Initializes a new instance of the [UAsset](./uassetapi.uasset.md) class. This instance will store no asset data and does not represent any asset in particular until the [UAsset.Read(AssetBinaryReader, Int32[], Int32[])](./uassetapi.uasset.md#readassetbinaryreader-int32-int32) method is manually called.

```csharp
public UAsset(EngineVersion engineVersion, Usmap mappings, CustomSerializationFlags customSerializationFlags)
```

#### Parameters

`engineVersion` [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>
The version of the Unreal Engine that will be used to parse this asset. If the asset is versioned, this can be left unspecified.

`mappings` [Usmap](./uassetapi.unversioned.usmap.md)<br>
A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.

`customSerializationFlags` [CustomSerializationFlags](./uassetapi.customserializationflags.md)<br>
A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.

### **UAsset(String, ObjectVersion, ObjectVersionUE5, List&lt;CustomVersion&gt;, Usmap, CustomSerializationFlags)**

Reads an asset from disk and initializes a new instance of the [UAsset](./uassetapi.uasset.md) class to store its data in memory.

```csharp
public UAsset(string path, ObjectVersion objectVersion, ObjectVersionUE5 objectVersionUE5, List<CustomVersion> customVersionContainer, Usmap mappings, CustomSerializationFlags customSerializationFlags)
```

#### Parameters

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path of the asset file on disk that this instance will read from.

`objectVersion` [ObjectVersion](./uassetapi.unrealtypes.objectversion.md)<br>
The UE4 object version of the Unreal Engine that will be used to parse this asset.

`objectVersionUE5` [ObjectVersionUE5](./uassetapi.unrealtypes.objectversionue5.md)<br>
The UE5 object version of the Unreal Engine that will be used to parse this asset.

`customVersionContainer` [List&lt;CustomVersion&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>
A list of custom versions to parse this asset with.

`mappings` [Usmap](./uassetapi.unversioned.usmap.md)<br>
A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.

`customSerializationFlags` [CustomSerializationFlags](./uassetapi.customserializationflags.md)<br>
A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.

#### Exceptions

[UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Thrown when this is an unversioned asset and [UAsset.ObjectVersion](./uassetapi.uasset.md#objectversion) is unspecified.

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the asset cannot be parsed correctly.

### **UAsset(AssetBinaryReader, ObjectVersion, ObjectVersionUE5, List&lt;CustomVersion&gt;, Usmap, Boolean, CustomSerializationFlags)**

Reads an asset from a BinaryReader and initializes a new instance of the [UAsset](./uassetapi.uasset.md) class to store its data in memory.

```csharp
public UAsset(AssetBinaryReader reader, ObjectVersion objectVersion, ObjectVersionUE5 objectVersionUE5, List<CustomVersion> customVersionContainer, Usmap mappings, bool useSeparateBulkDataFiles, CustomSerializationFlags customSerializationFlags)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The asset's BinaryReader that this instance will read from.

`objectVersion` [ObjectVersion](./uassetapi.unrealtypes.objectversion.md)<br>
The UE4 object version of the Unreal Engine that will be used to parse this asset.

`objectVersionUE5` [ObjectVersionUE5](./uassetapi.unrealtypes.objectversionue5.md)<br>
The UE5 object version of the Unreal Engine that will be used to parse this asset.

`customVersionContainer` [List&lt;CustomVersion&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>
A list of custom versions to parse this asset with.

`mappings` [Usmap](./uassetapi.unversioned.usmap.md)<br>
A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.

`useSeparateBulkDataFiles` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Does this asset uses separate bulk data files (.uexp, .ubulk)?

`customSerializationFlags` [CustomSerializationFlags](./uassetapi.customserializationflags.md)<br>
A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.

#### Exceptions

[UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Thrown when this is an unversioned asset and [UAsset.ObjectVersion](./uassetapi.uasset.md#objectversion) is unspecified.

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the asset cannot be parsed correctly.

### **UAsset(ObjectVersion, ObjectVersionUE5, List&lt;CustomVersion&gt;, Usmap, CustomSerializationFlags)**

Initializes a new instance of the [UAsset](./uassetapi.uasset.md) class. This instance will store no asset data and does not represent any asset in particular until the [UAsset.Read(AssetBinaryReader, Int32[], Int32[])](./uassetapi.uasset.md#readassetbinaryreader-int32-int32) method is manually called.

```csharp
public UAsset(ObjectVersion objectVersion, ObjectVersionUE5 objectVersionUE5, List<CustomVersion> customVersionContainer, Usmap mappings, CustomSerializationFlags customSerializationFlags)
```

#### Parameters

`objectVersion` [ObjectVersion](./uassetapi.unrealtypes.objectversion.md)<br>
The UE4 object version of the Unreal Engine that will be used to parse this asset.

`objectVersionUE5` [ObjectVersionUE5](./uassetapi.unrealtypes.objectversionue5.md)<br>
The UE5 object version of the Unreal Engine that will be used to parse this asset.

`customVersionContainer` [List&lt;CustomVersion&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>
A list of custom versions to parse this asset with.

`mappings` [Usmap](./uassetapi.unversioned.usmap.md)<br>
A valid set of mappings for the game that this asset is from. Not required unless unversioned properties are used.

`customSerializationFlags` [CustomSerializationFlags](./uassetapi.customserializationflags.md)<br>
A set of custom serialization flags, which can be used to override certain optional behavior in how UAssetAPI serializes assets.

### **UAsset()**

Initializes a new instance of the [UAsset](./uassetapi.uasset.md) class. This instance will store no asset data and does not represent any asset in particular until the [UAsset.Read(AssetBinaryReader, Int32[], Int32[])](./uassetapi.uasset.md#readassetbinaryreader-int32-int32) method is manually called.

```csharp
public UAsset()
```

## Methods

### **FixNameMapLookupIfNeeded()**

```csharp
internal void FixNameMapLookupIfNeeded()
```

### **GetNameMapIndexList()**

Returns the name map as a read-only list of FStrings.

```csharp
public IReadOnlyList<FString> GetNameMapIndexList()
```

#### Returns

[IReadOnlyList&lt;FString&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1)<br>
The name map as a read-only list of FStrings.

### **ClearNameIndexList()**

Clears the name map. This method should be used with extreme caution, as it may break unparsed references to the name map.

```csharp
public void ClearNameIndexList()
```

### **SetNameReference(Int32, FString)**

Replaces a value in the name map at a particular index.

```csharp
public void SetNameReference(int index, FString value)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index to overwrite in the name map.

`value` [FString](./uassetapi.unrealtypes.fstring.md)<br>
The value that will be replaced in the name map.

### **GetNameReference(Int32)**

Gets a value in the name map at a particular index.

```csharp
public FString GetNameReference(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index to return the value at.

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>
The value at the index provided.

### **GetNameReferenceWithoutZero(Int32)**

Gets a value in the name map at a particular index, but with the index zero being treated as if it is not valid.

```csharp
public FString GetNameReferenceWithoutZero(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index to return the value at.

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>
The value at the index provided.

### **ContainsNameReference(FString)**

Checks whether or not the value exists in the name map.

```csharp
public bool ContainsNameReference(FString search)
```

#### Parameters

`search` [FString](./uassetapi.unrealtypes.fstring.md)<br>
The value to search the name map for.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
true if the value appears in the name map, otherwise false.

### **SearchNameReference(FString)**

Searches the name map for a particular value.

```csharp
public int SearchNameReference(FString search)
```

#### Parameters

`search` [FString](./uassetapi.unrealtypes.fstring.md)<br>
The value to search the name map for.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index at which the value appears in the name map.

#### Exceptions

[NameMapOutOfRangeException](./uassetapi.namemapoutofrangeexception.md)<br>
Thrown when the value provided does not appear in the name map.

### **AddNameReference(FString, Boolean, Boolean)**

Adds a new value to the name map.

```csharp
public int AddNameReference(FString name, bool forceAddDuplicates, bool skipFixes)
```

#### Parameters

`name` [FString](./uassetapi.unrealtypes.fstring.md)<br>
The value to add to the name map.

`forceAddDuplicates` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not to add a new entry if the value provided already exists in the name map.

`skipFixes` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not to skip other additional fixes made upon adding new entries to the name map. In nearly all cases, this should be false.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index of the new value in the name map. If the value already existed in the name map beforehand, that index will be returned instead.

#### Exceptions

[ArgumentException](https://docs.microsoft.com/en-us/dotnet/api/system.argumentexception)<br>
Thrown when forceAddDuplicates is false and the value provided is null or empty.

### **CanCreateDummies()**

Whether or not we can create dummies in this name map. If false, attempting to define a dummy will append to the name map instead.

```csharp
public bool CanCreateDummies()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
A boolean.

### **PathToStream(String, Boolean)**

Creates a MemoryStream from an asset path.

```csharp
public MemoryStream PathToStream(string p, bool loadUEXP)
```

#### Parameters

`p` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to the input file.

`loadUEXP` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether to load the UEXP file. False only reads the UASSET.

#### Returns

[MemoryStream](https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream)<br>
A new MemoryStream that stores the binary data of the input file.

### **PathToReader(String, Boolean)**

Creates a BinaryReader from an asset path.

```csharp
public AssetBinaryReader PathToReader(string p, bool loadUEXP)
```

#### Parameters

`p` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to the input file.

`loadUEXP` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether to load the .uexp file. False only reads the .uasset file.

#### Returns

[AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
A new BinaryReader that stores the binary data of the input file.

### **GetClassExport()**

Searches for and returns this asset's ClassExport, if one exists.

```csharp
public ClassExport GetClassExport()
```

#### Returns

[ClassExport](./uassetapi.exporttypes.classexport.md)<br>
The asset's ClassExport if one exists, otherwise null.

### **ResolveAncestries()**

Resolves the ancestry of all properties present in this asset.

```csharp
public void ResolveAncestries()
```

### **FindAssetOnDiskFromPath(String)**

Attempt to find another asset on disk given an asset path (i.e. one starting with /Game/).

```csharp
public string FindAssetOnDiskFromPath(string path)
```

#### Parameters

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The asset path.

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to the file on disk, or null if none could be found.

### **SetEngineVersion(EngineVersion)**

Sets the version of the Unreal Engine to use in serialization.

```csharp
public void SetEngineVersion(EngineVersion newVersion)
```

#### Parameters

`newVersion` [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>
The new version of the Unreal Engine to use in serialization.

#### Exceptions

[InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)<br>
Thrown when an invalid EngineVersion is specified.

### **GetEngineVersion(ObjectVersion, ObjectVersionUE5, List&lt;CustomVersion&gt;)**

```csharp
public static EngineVersion GetEngineVersion(ObjectVersion objectVersion, ObjectVersionUE5 objectVersionUE5, List<CustomVersion> customVersionContainer)
```

#### Parameters

`objectVersion` [ObjectVersion](./uassetapi.unrealtypes.objectversion.md)<br>

`objectVersionUE5` [ObjectVersionUE5](./uassetapi.unrealtypes.objectversionue5.md)<br>

`customVersionContainer` [List&lt;CustomVersion&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

#### Returns

[EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>

### **GetEngineVersion()**

Estimates the retail version of the Unreal Engine based on the object and custom versions.

```csharp
public EngineVersion GetEngineVersion()
```

#### Returns

[EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>
The estimated retail version of the Unreal Engine.

### **GetCustomVersion(Guid)**

Fetches the version of a custom version in this asset.

```csharp
public int GetCustomVersion(Guid key)
```

#### Parameters

`key` [Guid](https://docs.microsoft.com/en-us/dotnet/api/system.guid)<br>
The GUID of the custom version to retrieve.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The version of the retrieved custom version.

### **GetCustomVersion(String)**

Fetches the version of a custom version in this asset.

```csharp
public int GetCustomVersion(string friendlyName)
```

#### Parameters

`friendlyName` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The friendly name of the custom version to retrieve.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The version of the retrieved custom version.

### **GetCustomVersion&lt;T&gt;()**

Fetches a custom version's enum value based off of its type.

```csharp
public T GetCustomVersion<T>()
```

#### Type Parameters

`T`<br>
The enum type of the custom version to retrieve.

#### Returns

T<br>
The enum value of the requested custom version.

#### Exceptions

[ArgumentException](https://docs.microsoft.com/en-us/dotnet/api/system.argumentexception)<br>
Thrown when T is not an enumerated type.

### **GuessCustomVersionFromTypeAndEngineVersion(EngineVersion, Type)**

```csharp
public static int GuessCustomVersionFromTypeAndEngineVersion(EngineVersion chosenVersion, Type typ)
```

#### Parameters

`chosenVersion` [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>

`typ` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **GetDefaultCustomVersionContainer(EngineVersion)**

Fetches a list of all default custom versions for a specific Unreal version.

```csharp
public static List<CustomVersion> GetDefaultCustomVersionContainer(EngineVersion chosenVersion)
```

#### Parameters

`chosenVersion` [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>
The version of the engine to check against.

#### Returns

[List&lt;CustomVersion&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>
A list of all the default custom version values for the given engine version.

### **ParseExport(AssetBinaryReader, Int32, Boolean)**

Read an export from disk.

```csharp
public void ParseExport(AssetBinaryReader reader, int i, bool read)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The binary reader.

`i` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index of the export in the export map to read.

`read` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not to serialize the body of the export. If false, simply converts to the respective sub-type.

### **ConvertExportToChildExportAndRead(AssetBinaryReader, Int32, Boolean)**

```csharp
public void ConvertExportToChildExportAndRead(AssetBinaryReader reader, int i, bool read)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`i` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`read` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **VerifyBinaryEquality()**

Checks whether or not this asset maintains binary equality when serialized.

```csharp
public bool VerifyBinaryEquality()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not the asset maintained binary equality.

### **GetParentClass(FName&, FName&)**

Finds the class path and export name of the SuperStruct of this asset, if it exists.

```csharp
public void GetParentClass(FName& parentClassPath, FName& parentClassExportName)
```

#### Parameters

`parentClassPath` [FName&](./uassetapi.unrealtypes.fname&.md)<br>
The class path of the SuperStruct of this asset, if it exists.

`parentClassExportName` [FName&](./uassetapi.unrealtypes.fname&.md)<br>
The export name of the SuperStruct of this asset, if it exists.

### **GetParentClassExportName(FName&)**

```csharp
internal FName GetParentClassExportName(FName& modulePath)
```

#### Parameters

`modulePath` [FName&](./uassetapi.unrealtypes.fname&.md)<br>

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **AddImport(Import)**

Adds a new import to the import map. This is equivalent to adding directly to the [UAsset.Imports](./uassetapi.uasset.md#imports) list.

```csharp
public FPackageIndex AddImport(Import li)
```

#### Parameters

`li` [Import](./uassetapi.import.md)<br>
The new import to add to the import map.

#### Returns

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>
The FPackageIndex corresponding to the newly-added import.

### **SearchForImport(FName, FName, FPackageIndex, FName)**

Searches for an import in the import map based off of certain parameters.

```csharp
public int SearchForImport(FName classPackage, FName className, FPackageIndex outerIndex, FName objectName)
```

#### Parameters

`classPackage` [FName](./uassetapi.unrealtypes.fname.md)<br>
The ClassPackage that the requested import will have.

`className` [FName](./uassetapi.unrealtypes.fname.md)<br>
The ClassName that the requested import will have.

`outerIndex` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>
The CuterIndex that the requested import will have.

`objectName` [FName](./uassetapi.unrealtypes.fname.md)<br>
The ObjectName that the requested import will have.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index of the requested import in the name map, or zero if one could not be found.

### **SearchForImport(FName, FName, FName)**

Searches for an import in the import map based off of certain parameters.

```csharp
public int SearchForImport(FName classPackage, FName className, FName objectName)
```

#### Parameters

`classPackage` [FName](./uassetapi.unrealtypes.fname.md)<br>
The ClassPackage that the requested import will have.

`className` [FName](./uassetapi.unrealtypes.fname.md)<br>
The ClassName that the requested import will have.

`objectName` [FName](./uassetapi.unrealtypes.fname.md)<br>
The ObjectName that the requested import will have.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index of the requested import in the name map, or zero if one could not be found.

### **SearchForImport(FName)**

Searches for an import in the import map based off of certain parameters.

```csharp
public int SearchForImport(FName objectName)
```

#### Parameters

`objectName` [FName](./uassetapi.unrealtypes.fname.md)<br>
The ObjectName that the requested import will have.

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index of the requested import in the name map, or zero if one could not be found.

### **PullSchemasFromAnotherAsset(FName)**

```csharp
public bool PullSchemasFromAnotherAsset(FName path)
```

#### Parameters

`path` [FName](./uassetapi.unrealtypes.fname.md)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CopySplitUp(Stream, Stream, Int32, Int32)**

Copies a portion of a stream to another stream.

```csharp
internal static void CopySplitUp(Stream input, Stream output, int start, int leng)
```

#### Parameters

`input` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>
The input stream.

`output` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>
The output stream.

`start` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The offset in the input stream to start copying from.

`leng` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The length in bytes of the data to be copied.

### **Read(AssetBinaryReader, Int32[], Int32[])**

Reads an asset into memory.

```csharp
public void Read(AssetBinaryReader reader, Int32[] manualSkips, Int32[] forceReads)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>
The input reader.

`manualSkips` [Int32[]](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
An array of export indices to skip parsing. For most applications, this should be left blank.

`forceReads` [Int32[]](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
An array of export indices that must be read, overriding entries in the manualSkips parameter. For most applications, this should be left blank.

#### Exceptions

[UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Thrown when this is an unversioned asset and [UAsset.ObjectVersion](./uassetapi.uasset.md#objectversion) is unspecified.

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the asset cannot be parsed correctly.

### **WriteData()**

Serializes an asset from memory.

```csharp
public MemoryStream WriteData()
```

#### Returns

[MemoryStream](https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream)<br>
A new MemoryStream containing the full binary data of the serialized asset.

### **Write(MemoryStream&, MemoryStream&)**

Serializes and writes an asset to two split streams (.uasset and .uexp) from memory.

```csharp
public void Write(MemoryStream& uassetStream, MemoryStream& uexpStream)
```

#### Parameters

`uassetStream` [MemoryStream&](https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream&)<br>
A stream containing the contents of the .uasset file.

`uexpStream` [MemoryStream&](https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream&)<br>
A stream containing the contents of the .uexp file, if needed, otherwise null.

#### Exceptions

[UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Thrown when [UAsset.ObjectVersion](./uassetapi.uasset.md#objectversion) is unspecified.

### **Write(String)**

Serializes and writes an asset to disk from memory.

```csharp
public void Write(string outputPath)
```

#### Parameters

`outputPath` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path on disk to write the asset to.

#### Exceptions

[UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Thrown when [UAsset.ObjectVersion](./uassetapi.uasset.md#objectversion) is unspecified.

### **SerializeJson(Boolean)**

Serializes this asset as JSON.

```csharp
public string SerializeJson(bool isFormatted)
```

#### Parameters

`isFormatted` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not the returned JSON string should be indented.

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
A serialized JSON string that represents the asset.

### **SerializeJson(Formatting)**

Serializes this asset as JSON.

```csharp
public string SerializeJson(Formatting jsonFormatting)
```

#### Parameters

`jsonFormatting` Formatting<br>
The formatting to use for the returned JSON string.

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
A serialized JSON string that represents the asset.

### **SerializeJsonObject(Object, Boolean)**

Serializes an object as JSON.

```csharp
public string SerializeJsonObject(object value, bool isFormatted)
```

#### Parameters

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>
The object to serialize as JSON.

`isFormatted` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not the returned JSON string should be indented.

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
A serialized JSON string that represents the object.

### **SerializeJsonObject(Object, Formatting)**

Serializes an object as JSON.

```csharp
public string SerializeJsonObject(object value, Formatting jsonFormatting)
```

#### Parameters

`value` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>
The object to serialize as JSON.

`jsonFormatting` Formatting<br>
The formatting to use for the returned JSON string.

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
A serialized JSON string that represents the object.

### **DeserializeJsonObject&lt;T&gt;(String)**

Deserializes an object from JSON.

```csharp
public T DeserializeJsonObject<T>(string json)
```

#### Type Parameters

`T`<br>

#### Parameters

`json` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
A serialized JSON string to parse.

#### Returns

T<br>

### **DeserializeJson(String)**

Reads an asset from serialized JSON and initializes a new instance of the [UAsset](./uassetapi.uasset.md) class to store its data in memory.

```csharp
public static UAsset DeserializeJson(string json)
```

#### Parameters

`json` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
A serialized JSON string to parse.

#### Returns

[UAsset](./uassetapi.uasset.md)<br>

### **DeserializeJson(Stream)**

Reads an asset from serialized JSON and initializes a new instance of the [UAsset](./uassetapi.uasset.md) class to store its data in memory.

```csharp
public static UAsset DeserializeJson(Stream stream)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>
A stream containing serialized JSON string to parse.

#### Returns

[UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.unknownengineversionexception.md`:

```md
# UnknownEngineVersionException

Namespace: UAssetAPI

```csharp
public class UnknownEngineVersionException : System.InvalidOperationException, System.Runtime.Serialization.ISerializable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Exception](https://docs.microsoft.com/en-us/dotnet/api/system.exception) → [SystemException](https://docs.microsoft.com/en-us/dotnet/api/system.systemexception) → [InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception) → [UnknownEngineVersionException](./uassetapi.unknownengineversionexception.md)<br>
Implements [ISerializable](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.iserializable)

## Properties

### **TargetSite**

```csharp
public MethodBase TargetSite { get; }
```

#### Property Value

[MethodBase](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase)<br>

### **Message**

```csharp
public string Message { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Data**

```csharp
public IDictionary Data { get; }
```

#### Property Value

[IDictionary](https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary)<br>

### **InnerException**

```csharp
public Exception InnerException { get; }
```

#### Property Value

[Exception](https://docs.microsoft.com/en-us/dotnet/api/system.exception)<br>

### **HelpLink**

```csharp
public string HelpLink { get; set; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Source**

```csharp
public string Source { get; set; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **HResult**

```csharp
public int HResult { get; set; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **StackTrace**

```csharp
public string StackTrace { get; }
```

#### Property Value

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

## Constructors

### **UnknownEngineVersionException(String)**

```csharp
public UnknownEngineVersionException(string message)
```

#### Parameters

`message` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unrealbinaryreader.md`:

```md
# UnrealBinaryReader

Namespace: UAssetAPI

Any binary reader used in the parsing of Unreal file types.

```csharp
public class UnrealBinaryReader : System.IO.BinaryReader, System.IDisposable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [BinaryReader](https://docs.microsoft.com/en-us/dotnet/api/system.io.binaryreader) → [UnrealBinaryReader](./uassetapi.unrealbinaryreader.md)<br>
Implements [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable)

## Properties

### **BaseStream**

```csharp
public Stream BaseStream { get; }
```

#### Property Value

[Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

## Constructors

### **UnrealBinaryReader(Stream)**

```csharp
public UnrealBinaryReader(Stream stream)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

## Methods

### **ReverseIfBigEndian(Byte[])**

```csharp
protected Byte[] ReverseIfBigEndian(Byte[] data)
```

#### Parameters

`data` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **ReadInt16()**

```csharp
public short ReadInt16()
```

#### Returns

[Int16](https://docs.microsoft.com/en-us/dotnet/api/system.int16)<br>

### **ReadUInt16()**

```csharp
public ushort ReadUInt16()
```

#### Returns

[UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

### **ReadInt32()**

```csharp
public int ReadInt32()
```

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ReadUInt32()**

```csharp
public uint ReadUInt32()
```

#### Returns

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **ReadInt64()**

```csharp
public long ReadInt64()
```

#### Returns

[Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

### **ReadUInt64()**

```csharp
public ulong ReadUInt64()
```

#### Returns

[UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

### **ReadSingle()**

```csharp
public float ReadSingle()
```

#### Returns

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **ReadDouble()**

```csharp
public double ReadDouble()
```

#### Returns

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **ReadBooleanInt()**

```csharp
public bool ReadBooleanInt()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **ReadString()**

```csharp
public string ReadString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **ReadFString()**

```csharp
public FString ReadFString()
```

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **ReadUtf8String()**

```csharp
public FString ReadUtf8String()
```

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **ReadNameMapString(UInt32&)**

```csharp
public FString ReadNameMapString(UInt32& hashes)
```

#### Parameters

`hashes` [UInt32&](https://docs.microsoft.com/en-us/dotnet/api/system.uint32&)<br>

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **ReadCustomVersionContainer(ECustomVersionSerializationFormat, List&lt;CustomVersion&gt;, Usmap)**

```csharp
public List<CustomVersion> ReadCustomVersionContainer(ECustomVersionSerializationFormat format, List<CustomVersion> oldCustomVersionContainer, Usmap Mappings)
```

#### Parameters

`format` [ECustomVersionSerializationFormat](./uassetapi.unversioned.ecustomversionserializationformat.md)<br>

`oldCustomVersionContainer` [List&lt;CustomVersion&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

`Mappings` [Usmap](./uassetapi.unversioned.usmap.md)<br>

#### Returns

[List&lt;CustomVersion&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

```

`docs/src/api/uassetapi.unrealbinarywriter.md`:

```md
# UnrealBinaryWriter

Namespace: UAssetAPI

Any binary writer used in the parsing of Unreal file types.

```csharp
public class UnrealBinaryWriter : System.IO.BinaryWriter, System.IDisposable, System.IAsyncDisposable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [BinaryWriter](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter) → [UnrealBinaryWriter](./uassetapi.unrealbinarywriter.md)<br>
Implements [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable), [IAsyncDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.iasyncdisposable)

## Properties

### **BaseStream**

```csharp
public Stream BaseStream { get; }
```

#### Property Value

[Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

## Constructors

### **UnrealBinaryWriter()**

```csharp
public UnrealBinaryWriter()
```

### **UnrealBinaryWriter(Stream)**

```csharp
public UnrealBinaryWriter(Stream stream)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

### **UnrealBinaryWriter(Stream, Encoding)**

```csharp
public UnrealBinaryWriter(Stream stream, Encoding encoding)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`encoding` [Encoding](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding)<br>

### **UnrealBinaryWriter(Stream, Encoding, Boolean)**

```csharp
public UnrealBinaryWriter(Stream stream, Encoding encoding, bool leaveOpen)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`encoding` [Encoding](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding)<br>

`leaveOpen` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Methods

### **ReverseIfBigEndian(Byte[])**

```csharp
protected Byte[] ReverseIfBigEndian(Byte[] data)
```

#### Parameters

`data` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **Write(Int16)**

```csharp
public void Write(short value)
```

#### Parameters

`value` [Int16](https://docs.microsoft.com/en-us/dotnet/api/system.int16)<br>

### **Write(UInt16)**

```csharp
public void Write(ushort value)
```

#### Parameters

`value` [UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

### **Write(Int32)**

```csharp
public void Write(int value)
```

#### Parameters

`value` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Write(UInt32)**

```csharp
public void Write(uint value)
```

#### Parameters

`value` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **Write(Int64)**

```csharp
public void Write(long value)
```

#### Parameters

`value` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

### **Write(UInt64)**

```csharp
public void Write(ulong value)
```

#### Parameters

`value` [UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

### **Write(Single)**

```csharp
public void Write(float value)
```

#### Parameters

`value` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Write(Double)**

```csharp
public void Write(double value)
```

#### Parameters

`value` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **Write(String)**

```csharp
public void Write(string value)
```

#### Parameters

`value` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Write(FString)**

```csharp
public int Write(FString value)
```

#### Parameters

`value` [FString](./uassetapi.unrealtypes.fstring.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **WriteUtf8String(FString)**

```csharp
public int WriteUtf8String(FString value)
```

#### Parameters

`value` [FString](./uassetapi.unrealtypes.fstring.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **WriteCustomVersionContainer(ECustomVersionSerializationFormat, List&lt;CustomVersion&gt;)**

```csharp
public void WriteCustomVersionContainer(ECustomVersionSerializationFormat format, List<CustomVersion> CustomVersionContainer)
```

#### Parameters

`format` [ECustomVersionSerializationFormat](./uassetapi.unversioned.ecustomversionserializationformat.md)<br>

`CustomVersionContainer` [List&lt;CustomVersion&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

```

`docs/src/api/uassetapi.unrealtypes.comparer2-1.md`:

```md
# Comparer2&lt;T&gt;

Namespace: UAssetAPI.UnrealTypes

```csharp
public class Comparer2<T> : , System.Collections.IComparer, 
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → Comparer&lt;T&gt; → [Comparer2&lt;T&gt;](./uassetapi.unrealtypes.comparer2-1.md)<br>
Implements [IComparer](https://docs.microsoft.com/en-us/dotnet/api/system.collections.icomparer), IComparer&lt;T&gt;

## Constructors

### **Comparer2(Comparison&lt;T&gt;)**

```csharp
public Comparer2(Comparison<T> comparison)
```

#### Parameters

`comparison` Comparison&lt;T&gt;<br>

## Methods

### **Compare(T, T)**

```csharp
public int Compare(T arg1, T arg2)
```

#### Parameters

`arg1` T<br>

`arg2` T<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unrealtypes.dictionaryenumerator-2.md`:

```md
# DictionaryEnumerator&lt;TKey, TValue&gt;

Namespace: UAssetAPI.UnrealTypes

```csharp
public class DictionaryEnumerator<TKey, TValue> : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator, System.IDisposable
```

#### Type Parameters

`TKey`<br>

`TValue`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [DictionaryEnumerator&lt;TKey, TValue&gt;](./uassetapi.unrealtypes.dictionaryenumerator-2.md)<br>
Implements [IDictionaryEnumerator](https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionaryenumerator), [IEnumerator](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator), [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable)

## Properties

### **Entry**

```csharp
public DictionaryEntry Entry { get; }
```

#### Property Value

[DictionaryEntry](https://docs.microsoft.com/en-us/dotnet/api/system.collections.dictionaryentry)<br>

### **Key**

```csharp
public object Key { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Value**

```csharp
public object Value { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Current**

```csharp
public object Current { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **DictionaryEnumerator(IDictionary&lt;TKey, TValue&gt;)**

```csharp
public DictionaryEnumerator(IDictionary<TKey, TValue> value)
```

#### Parameters

`value` IDictionary&lt;TKey, TValue&gt;<br>

## Methods

### **Dispose()**

```csharp
public void Dispose()
```

### **Reset()**

```csharp
public void Reset()
```

### **MoveNext()**

```csharp
public bool MoveNext()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

```

`docs/src/api/uassetapi.unrealtypes.eaxis.md`:

```md
# EAxis

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum EAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAxis](./uassetapi.unrealtypes.eaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.eclassflags.md`:

```md
# EClassFlags

Namespace: UAssetAPI.UnrealTypes

Flags describing a class.

```csharp
public enum EClassFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EClassFlags](./uassetapi.unrealtypes.eclassflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| CLASS_None | 0 | No Flags |
| CLASS_Abstract | 1 | Class is abstract and can't be instantiated directly. |
| CLASS_DefaultConfig | 2 | Save object configuration only to Default INIs, never to local INIs. Must be combined with CLASS_Config |
| CLASS_Config | 4 | Load object configuration at construction time. |
| CLASS_Transient | 8 | This object type can't be saved; null it out at save time. |
| CLASS_Parsed | 16 | Successfully parsed. |
| CLASS_MatchedSerializers | 32 | ??? |
| CLASS_ProjectUserConfig | 64 | Indicates that the config settings for this class will be saved to Project/User*.ini (similar to CLASS_GlobalUserConfig) |
| CLASS_Native | 128 | Class is a native class - native interfaces will have CLASS_Native set, but not RF_MarkAsNative |
| CLASS_NoExport | 256 | Don't export to C++ header. |
| CLASS_NotPlaceable | 512 | Do not allow users to create in the editor. |
| CLASS_PerObjectConfig | 1024 | Handle object configuration on a per-object basis, rather than per-class. |
| CLASS_ReplicationDataIsSetUp | 2048 | Whether SetUpRuntimeReplicationData still needs to be called for this class |
| CLASS_EditInlineNew | 4096 | Class can be constructed from editinline New button. |
| CLASS_CollapseCategories | 8192 | Display properties in the editor without using categories. |
| CLASS_Interface | 16384 | Class is an interface |
| CLASS_CustomConstructor | 32768 | Do not export a constructor for this class, assuming it is in the cpptext |
| CLASS_Const | 65536 | All properties and functions in this class are const and should be exported as const |
| CLASS_LayoutChanging | 131072 | Class flag indicating the class is having its layout changed, and therefore is not ready for a CDO to be created |
| CLASS_CompiledFromBlueprint | 262144 | Indicates that the class was created from blueprint source material |
| CLASS_MinimalAPI | 524288 | Indicates that only the bare minimum bits of this class should be DLL exported/imported |
| CLASS_RequiredAPI | 1048576 | Indicates this class must be DLL exported/imported (along with all of it's members) |
| CLASS_DefaultToInstanced | 2097152 | Indicates that references to this class default to instanced. Used to be subclasses of UComponent, but now can be any UObject |
| CLASS_TokenStreamAssembled | 4194304 | Indicates that the parent token stream has been merged with ours. |
| CLASS_HasInstancedReference | 8388608 | Class has component properties. |
| CLASS_Hidden | 16777216 | Don't show this class in the editor class browser or edit inline new menus. |
| CLASS_Deprecated | 33554432 | Don't save objects of this class when serializing |
| CLASS_HideDropDown | 67108864 | Class not shown in editor drop down for class selection |
| CLASS_GlobalUserConfig | 134217728 | Class settings are saved to AppData/..../Blah.ini (as opposed to CLASS_DefaultConfig) |
| CLASS_Intrinsic | 268435456 | Class was declared directly in C++ and has no boilerplate generated by UnrealHeaderTool |
| CLASS_Constructed | 536870912 | Class has already been constructed (maybe in a previous DLL version before hot-reload). |
| CLASS_ConfigDoNotCheckDefaults | 1073741824 | Indicates that object configuration will not check against ini base/defaults when serialized |
| CLASS_NewerVersionExists | 2147483648 | Class has been consigned to oblivion as part of a blueprint recompile, and a newer version currently exists. |

```

`docs/src/api/uassetapi.unrealtypes.efonthinting.md`:

```md
# EFontHinting

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum EFontHinting
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFontHinting](./uassetapi.unrealtypes.efonthinting.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.efontloadingpolicy.md`:

```md
# EFontLoadingPolicy

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum EFontLoadingPolicy
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFontLoadingPolicy](./uassetapi.unrealtypes.efontloadingpolicy.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.efunctionflags.md`:

```md
# EFunctionFlags

Namespace: UAssetAPI.UnrealTypes

Flags describing a function.

```csharp
public enum EFunctionFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFunctionFlags](./uassetapi.unrealtypes.efunctionflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.einterpcurvemode.md`:

```md
# EInterpCurveMode

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum EInterpCurveMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInterpCurveMode](./uassetapi.unrealtypes.einterpcurvemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.emappednametype.md`:

```md
# EMappedNameType

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum EMappedNameType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMappedNameType](./uassetapi.unrealtypes.emappednametype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.animationcompressionformat.md`:

```md
# AnimationCompressionFormat

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum AnimationCompressionFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [AnimationCompressionFormat](./uassetapi.unrealtypes.engineenums.animationcompressionformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.animationkeyformat.md`:

```md
# AnimationKeyFormat

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum AnimationKeyFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [AnimationKeyFormat](./uassetapi.unrealtypes.engineenums.animationkeyformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.animphyscollisiontype.md`:

```md
# AnimPhysCollisionType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum AnimPhysCollisionType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [AnimPhysCollisionType](./uassetapi.unrealtypes.engineenums.animphyscollisiontype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.animphystwistaxis.md`:

```md
# AnimPhysTwistAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum AnimPhysTwistAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [AnimPhysTwistAxis](./uassetapi.unrealtypes.engineenums.animphystwistaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.beam2sourcetargetmethod.md`:

```md
# Beam2SourceTargetMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum Beam2SourceTargetMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [Beam2SourceTargetMethod](./uassetapi.unrealtypes.engineenums.beam2sourcetargetmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.beam2sourcetargettangentmethod.md`:

```md
# Beam2SourceTargetTangentMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum Beam2SourceTargetTangentMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [Beam2SourceTargetTangentMethod](./uassetapi.unrealtypes.engineenums.beam2sourcetargettangentmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.beammodifiertype.md`:

```md
# BeamModifierType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum BeamModifierType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [BeamModifierType](./uassetapi.unrealtypes.engineenums.beammodifiertype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.cylinderheightaxis.md`:

```md
# CylinderHeightAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum CylinderHeightAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [CylinderHeightAxis](./uassetapi.unrealtypes.engineenums.cylinderheightaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.distributionparammode.md`:

```md
# DistributionParamMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum DistributionParamMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [DistributionParamMode](./uassetapi.unrealtypes.engineenums.distributionparammode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eactorupdateoverlapsmethod.md`:

```md
# EActorUpdateOverlapsMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EActorUpdateOverlapsMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EActorUpdateOverlapsMethod](./uassetapi.unrealtypes.engineenums.eactorupdateoverlapsmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eadditiveanimationtype.md`:

```md
# EAdditiveAnimationType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAdditiveAnimationType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAdditiveAnimationType](./uassetapi.unrealtypes.engineenums.eadditiveanimationtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eadditivebaseposetype.md`:

```md
# EAdditiveBasePoseType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAdditiveBasePoseType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAdditiveBasePoseType](./uassetapi.unrealtypes.engineenums.eadditivebaseposetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eadmanagerdelegate.md`:

```md
# EAdManagerDelegate

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAdManagerDelegate
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAdManagerDelegate](./uassetapi.unrealtypes.engineenums.eadmanagerdelegate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eairabsorptionmethod.md`:

```md
# EAirAbsorptionMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAirAbsorptionMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAirAbsorptionMethod](./uassetapi.unrealtypes.engineenums.eairabsorptionmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ealphablendoption.md`:

```md
# EAlphaBlendOption

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAlphaBlendOption
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAlphaBlendOption](./uassetapi.unrealtypes.engineenums.ealphablendoption.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ealphachannelmode.md`:

```md
# EAlphaChannelMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAlphaChannelMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAlphaChannelMode](./uassetapi.unrealtypes.engineenums.ealphachannelmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eangularconstraintmotion.md`:

```md
# EAngularConstraintMotion

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAngularConstraintMotion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAngularConstraintMotion](./uassetapi.unrealtypes.engineenums.eangularconstraintmotion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eangulardrivemode.md`:

```md
# EAngularDriveMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAngularDriveMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAngularDriveMode](./uassetapi.unrealtypes.engineenums.eangulardrivemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eanimalphainputtype.md`:

```md
# EAnimAlphaInputType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAnimAlphaInputType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAnimAlphaInputType](./uassetapi.unrealtypes.engineenums.eanimalphainputtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eanimassetcurveflags.md`:

```md
# EAnimAssetCurveFlags

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAnimAssetCurveFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAnimAssetCurveFlags](./uassetapi.unrealtypes.engineenums.eanimassetcurveflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eanimationmode.md`:

```md
# EAnimationMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAnimationMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAnimationMode](./uassetapi.unrealtypes.engineenums.eanimationmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eanimcurvetype.md`:

```md
# EAnimCurveType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAnimCurveType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAnimCurveType](./uassetapi.unrealtypes.engineenums.eanimcurvetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eanimgrouprole.md`:

```md
# EAnimGroupRole

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAnimGroupRole
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAnimGroupRole](./uassetapi.unrealtypes.engineenums.eanimgrouprole.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eaniminterpolationtype.md`:

```md
# EAnimInterpolationType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAnimInterpolationType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAnimInterpolationType](./uassetapi.unrealtypes.engineenums.eaniminterpolationtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eanimlinkmethod.md`:

```md
# EAnimLinkMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAnimLinkMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAnimLinkMethod](./uassetapi.unrealtypes.engineenums.eanimlinkmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eanimnotifyeventtype.md`:

```md
# EAnimNotifyEventType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAnimNotifyEventType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAnimNotifyEventType](./uassetapi.unrealtypes.engineenums.eanimnotifyeventtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eantialiasingmethod.md`:

```md
# EAntiAliasingMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAntiAliasingMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAntiAliasingMethod](./uassetapi.unrealtypes.engineenums.eantialiasingmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eapplicationstate.md`:

```md
# EApplicationState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EApplicationState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EApplicationState](./uassetapi.unrealtypes.engineenums.eapplicationstate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.easpectratioaxisconstraint.md`:

```md
# EAspectRatioAxisConstraint

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAspectRatioAxisConstraint
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAspectRatioAxisConstraint](./uassetapi.unrealtypes.engineenums.easpectratioaxisconstraint.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eattachlocation.md`:

```md
# EAttachLocation

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAttachLocation
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAttachLocation](./uassetapi.unrealtypes.engineenums.eattachlocation.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eattachmentrule.md`:

```md
# EAttachmentRule

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAttachmentRule
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAttachmentRule](./uassetapi.unrealtypes.engineenums.eattachmentrule.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eattenuationdistancemodel.md`:

```md
# EAttenuationDistanceModel

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAttenuationDistanceModel
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAttenuationDistanceModel](./uassetapi.unrealtypes.engineenums.eattenuationdistancemodel.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eattenuationshape.md`:

```md
# EAttenuationShape

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAttenuationShape
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAttenuationShape](./uassetapi.unrealtypes.engineenums.eattenuationshape.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eattractorparticleselectionmethod.md`:

```md
# EAttractorParticleSelectionMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAttractorParticleSelectionMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAttractorParticleSelectionMethod](./uassetapi.unrealtypes.engineenums.eattractorparticleselectionmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eaudiocomponentplaystate.md`:

```md
# EAudioComponentPlayState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAudioComponentPlayState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAudioComponentPlayState](./uassetapi.unrealtypes.engineenums.eaudiocomponentplaystate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eaudiofadercurve.md`:

```md
# EAudioFaderCurve

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAudioFaderCurve
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAudioFaderCurve](./uassetapi.unrealtypes.engineenums.eaudiofadercurve.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eaudiooutputtarget.md`:

```md
# EAudioOutputTarget

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAudioOutputTarget
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAudioOutputTarget](./uassetapi.unrealtypes.engineenums.eaudiooutputtarget.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eaudiorecordingexporttype.md`:

```md
# EAudioRecordingExportType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAudioRecordingExportType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAudioRecordingExportType](./uassetapi.unrealtypes.engineenums.eaudiorecordingexporttype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eautoexposuremethod.md`:

```md
# EAutoExposureMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAutoExposureMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAutoExposureMethod](./uassetapi.unrealtypes.engineenums.eautoexposuremethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eautoexposuremethodui.md`:

```md
# EAutoExposureMethodUI

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAutoExposureMethodUI
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAutoExposureMethodUI](./uassetapi.unrealtypes.engineenums.eautoexposuremethodui.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eautopossessai.md`:

```md
# EAutoPossessAI

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAutoPossessAI
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAutoPossessAI](./uassetapi.unrealtypes.engineenums.eautopossessai.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eautoreceiveinput.md`:

```md
# EAutoReceiveInput

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAutoReceiveInput
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAutoReceiveInput](./uassetapi.unrealtypes.engineenums.eautoreceiveinput.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eaxisoption.md`:

```md
# EAxisOption

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EAxisOption
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EAxisOption](./uassetapi.unrealtypes.engineenums.eaxisoption.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebeam2method.md`:

```md
# EBeam2Method

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBeam2Method
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBeam2Method](./uassetapi.unrealtypes.engineenums.ebeam2method.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebeamtapermethod.md`:

```md
# EBeamTaperMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBeamTaperMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBeamTaperMethod](./uassetapi.unrealtypes.engineenums.ebeamtapermethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eblendablelocation.md`:

```md
# EBlendableLocation

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBlendableLocation
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlendableLocation](./uassetapi.unrealtypes.engineenums.eblendablelocation.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eblendmode.md`:

```md
# EBlendMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBlendMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlendMode](./uassetapi.unrealtypes.engineenums.eblendmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eblendspaceaxis.md`:

```md
# EBlendSpaceAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBlendSpaceAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlendSpaceAxis](./uassetapi.unrealtypes.engineenums.eblendspaceaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebloommethod.md`:

```md
# EBloomMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBloomMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBloomMethod](./uassetapi.unrealtypes.engineenums.ebloommethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eblueprintcompilemode.md`:

```md
# EBlueprintCompileMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBlueprintCompileMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlueprintCompileMode](./uassetapi.unrealtypes.engineenums.eblueprintcompilemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eblueprintnativizationflag.md`:

```md
# EBlueprintNativizationFlag

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBlueprintNativizationFlag
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlueprintNativizationFlag](./uassetapi.unrealtypes.engineenums.eblueprintnativizationflag.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eblueprintpinstyletype.md`:

```md
# EBlueprintPinStyleType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBlueprintPinStyleType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlueprintPinStyleType](./uassetapi.unrealtypes.engineenums.eblueprintpinstyletype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eblueprintstatus.md`:

```md
# EBlueprintStatus

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBlueprintStatus
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlueprintStatus](./uassetapi.unrealtypes.engineenums.eblueprintstatus.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eblueprinttype.md`:

```md
# EBlueprintType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBlueprintType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBlueprintType](./uassetapi.unrealtypes.engineenums.eblueprinttype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebodycollisionresponse.md`:

```md
# EBodyCollisionResponse

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBodyCollisionResponse
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBodyCollisionResponse](./uassetapi.unrealtypes.engineenums.ebodycollisionresponse.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eboneaxis.md`:

```md
# EBoneAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBoneAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBoneAxis](./uassetapi.unrealtypes.engineenums.eboneaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebonecontrolspace.md`:

```md
# EBoneControlSpace

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBoneControlSpace
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBoneControlSpace](./uassetapi.unrealtypes.engineenums.ebonecontrolspace.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebonefilteractionoption.md`:

```md
# EBoneFilterActionOption

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBoneFilterActionOption
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBoneFilterActionOption](./uassetapi.unrealtypes.engineenums.ebonefilteractionoption.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebonerotationsource.md`:

```md
# EBoneRotationSource

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBoneRotationSource
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBoneRotationSource](./uassetapi.unrealtypes.engineenums.ebonerotationsource.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebonespaces.md`:

```md
# EBoneSpaces

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBoneSpaces
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBoneSpaces](./uassetapi.unrealtypes.engineenums.ebonespaces.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebonetranslationretargetingmode.md`:

```md
# EBoneTranslationRetargetingMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBoneTranslationRetargetingMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBoneTranslationRetargetingMode](./uassetapi.unrealtypes.engineenums.ebonetranslationretargetingmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebonevisibilitystatus.md`:

```md
# EBoneVisibilityStatus

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBoneVisibilityStatus
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBoneVisibilityStatus](./uassetapi.unrealtypes.engineenums.ebonevisibilitystatus.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ebrushtype.md`:

```md
# EBrushType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EBrushType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EBrushType](./uassetapi.unrealtypes.engineenums.ebrushtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecameraalphablendmode.md`:

```md
# ECameraAlphaBlendMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECameraAlphaBlendMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECameraAlphaBlendMode](./uassetapi.unrealtypes.engineenums.ecameraalphablendmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecameraanimplayspace.md`:

```md
# ECameraAnimPlaySpace

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECameraAnimPlaySpace
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECameraAnimPlaySpace](./uassetapi.unrealtypes.engineenums.ecameraanimplayspace.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecameraprojectionmode.md`:

```md
# ECameraProjectionMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECameraProjectionMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECameraProjectionMode](./uassetapi.unrealtypes.engineenums.ecameraprojectionmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecamerashakeattenuation.md`:

```md
# ECameraShakeAttenuation

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECameraShakeAttenuation
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECameraShakeAttenuation](./uassetapi.unrealtypes.engineenums.ecamerashakeattenuation.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecanbecharacterbase.md`:

```md
# ECanBeCharacterBase

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECanBeCharacterBase
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECanBeCharacterBase](./uassetapi.unrealtypes.engineenums.ecanbecharacterbase.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecancreateconnectionresponse.md`:

```md
# ECanCreateConnectionResponse

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECanCreateConnectionResponse
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECanCreateConnectionResponse](./uassetapi.unrealtypes.engineenums.ecancreateconnectionresponse.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.echannelmaskparametercolor.md`:

```md
# EChannelMaskParameterColor

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EChannelMaskParameterColor
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EChannelMaskParameterColor](./uassetapi.unrealtypes.engineenums.echannelmaskparametercolor.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eclampmode.md`:

```md
# EClampMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EClampMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EClampMode](./uassetapi.unrealtypes.engineenums.eclampmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eclearsceneoptions.md`:

```md
# EClearSceneOptions

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EClearSceneOptions
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EClearSceneOptions](./uassetapi.unrealtypes.engineenums.eclearsceneoptions.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eclothmassmode.md`:

```md
# EClothMassMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EClothMassMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EClothMassMode](./uassetapi.unrealtypes.engineenums.eclothmassmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecloudstoragedelegate.md`:

```md
# ECloudStorageDelegate

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECloudStorageDelegate
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECloudStorageDelegate](./uassetapi.unrealtypes.engineenums.ecloudstoragedelegate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecollisionchannel.md`:

```md
# ECollisionChannel

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECollisionChannel
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECollisionChannel](./uassetapi.unrealtypes.engineenums.ecollisionchannel.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecollisionenabled.md`:

```md
# ECollisionEnabled

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECollisionEnabled
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECollisionEnabled](./uassetapi.unrealtypes.engineenums.ecollisionenabled.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecollisionresponse.md`:

```md
# ECollisionResponse

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECollisionResponse
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECollisionResponse](./uassetapi.unrealtypes.engineenums.ecollisionresponse.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecollisiontraceflag.md`:

```md
# ECollisionTraceFlag

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECollisionTraceFlag
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECollisionTraceFlag](./uassetapi.unrealtypes.engineenums.ecollisiontraceflag.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecomponentcreationmethod.md`:

```md
# EComponentCreationMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EComponentCreationMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EComponentCreationMethod](./uassetapi.unrealtypes.engineenums.ecomponentcreationmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecomponentmobility.md`:

```md
# EComponentMobility

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EComponentMobility
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EComponentMobility](./uassetapi.unrealtypes.engineenums.ecomponentmobility.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecomponentsockettype.md`:

```md
# EComponentSocketType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EComponentSocketType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EComponentSocketType](./uassetapi.unrealtypes.engineenums.ecomponentsockettype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecomponenttype.md`:

```md
# EComponentType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EComponentType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EComponentType](./uassetapi.unrealtypes.engineenums.ecomponenttype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecompositetexturemode.md`:

```md
# ECompositeTextureMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECompositeTextureMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECompositeTextureMode](./uassetapi.unrealtypes.engineenums.ecompositetexturemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecompositingsamplecount.md`:

```md
# ECompositingSampleCount

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECompositingSampleCount
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECompositingSampleCount](./uassetapi.unrealtypes.engineenums.ecompositingsamplecount.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.econstraintframe.md`:

```md
# EConstraintFrame

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EConstraintFrame
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EConstraintFrame](./uassetapi.unrealtypes.engineenums.econstraintframe.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.econstrainttransform.md`:

```md
# EConstraintTransform

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EConstraintTransform
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EConstraintTransform](./uassetapi.unrealtypes.engineenums.econstrainttransform.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.econtrolconstraint.md`:

```md
# EControlConstraint

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EControlConstraint
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EControlConstraint](./uassetapi.unrealtypes.engineenums.econtrolconstraint.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.econtrolleranalogstick.md`:

```md
# EControllerAnalogStick

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EControllerAnalogStick
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EControllerAnalogStick](./uassetapi.unrealtypes.engineenums.econtrolleranalogstick.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecopytype.md`:

```md
# ECopyType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECopyType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECopyType](./uassetapi.unrealtypes.engineenums.ecopytype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecsgoper.md`:

```md
# ECsgOper

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECsgOper
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECsgOper](./uassetapi.unrealtypes.engineenums.ecsgoper.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecurveblendoption.md`:

```md
# ECurveBlendOption

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECurveBlendOption
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECurveBlendOption](./uassetapi.unrealtypes.engineenums.ecurveblendoption.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecurvetablemode.md`:

```md
# ECurveTableMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECurveTableMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECurveTableMode](./uassetapi.unrealtypes.engineenums.ecurvetablemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecustomdepthstencil.md`:

```md
# ECustomDepthStencil

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECustomDepthStencil
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECustomDepthStencil](./uassetapi.unrealtypes.engineenums.ecustomdepthstencil.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecustommaterialoutputtype.md`:

```md
# ECustomMaterialOutputType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECustomMaterialOutputType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECustomMaterialOutputType](./uassetapi.unrealtypes.engineenums.ecustommaterialoutputtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ecustomtimestepsynchronizationstate.md`:

```md
# ECustomTimeStepSynchronizationState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ECustomTimeStepSynchronizationState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECustomTimeStepSynchronizationState](./uassetapi.unrealtypes.engineenums.ecustomtimestepsynchronizationstate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edecalblendmode.md`:

```md
# EDecalBlendMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDecalBlendMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDecalBlendMode](./uassetapi.unrealtypes.engineenums.edecalblendmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edecompressiontype.md`:

```md
# EDecompressionType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDecompressionType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDecompressionType](./uassetapi.unrealtypes.engineenums.edecompressiontype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edefaultbackbufferpixelformat.md`:

```md
# EDefaultBackBufferPixelFormat

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDefaultBackBufferPixelFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDefaultBackBufferPixelFormat](./uassetapi.unrealtypes.engineenums.edefaultbackbufferpixelformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edemoplayfailure.md`:

```md
# EDemoPlayFailure

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDemoPlayFailure
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDemoPlayFailure](./uassetapi.unrealtypes.engineenums.edemoplayfailure.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edepthoffieldfunctionvalue.md`:

```md
# EDepthOfFieldFunctionValue

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDepthOfFieldFunctionValue
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDepthOfFieldFunctionValue](./uassetapi.unrealtypes.engineenums.edepthoffieldfunctionvalue.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edepthoffieldmethod.md`:

```md
# EDepthOfFieldMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDepthOfFieldMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDepthOfFieldMethod](./uassetapi.unrealtypes.engineenums.edepthoffieldmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edetachmentrule.md`:

```md
# EDetachmentRule

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDetachmentRule
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDetachmentRule](./uassetapi.unrealtypes.engineenums.edetachmentrule.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edetailmode.md`:

```md
# EDetailMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDetailMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDetailMode](./uassetapi.unrealtypes.engineenums.edetailmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edistributionvectorlockflags.md`:

```md
# EDistributionVectorLockFlags

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDistributionVectorLockFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDistributionVectorLockFlags](./uassetapi.unrealtypes.engineenums.edistributionvectorlockflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edistributionvectormirrorflags.md`:

```md
# EDistributionVectorMirrorFlags

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDistributionVectorMirrorFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDistributionVectorMirrorFlags](./uassetapi.unrealtypes.engineenums.edistributionvectormirrorflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edofmode.md`:

```md
# EDOFMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDOFMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDOFMode](./uassetapi.unrealtypes.engineenums.edofmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edrawdebugitemtype.md`:

```md
# EDrawDebugItemType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDrawDebugItemType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDrawDebugItemType](./uassetapi.unrealtypes.engineenums.edrawdebugitemtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edrawdebugtrace.md`:

```md
# EDrawDebugTrace

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDrawDebugTrace
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDrawDebugTrace](./uassetapi.unrealtypes.engineenums.edrawdebugtrace.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.edynamicforcefeedbackaction.md`:

```md
# EDynamicForceFeedbackAction

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EDynamicForceFeedbackAction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EDynamicForceFeedbackAction](./uassetapi.unrealtypes.engineenums.edynamicforcefeedbackaction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eearlyzpass.md`:

```md
# EEarlyZPass

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEarlyZPass
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEarlyZPass](./uassetapi.unrealtypes.engineenums.eearlyzpass.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eeasingfunc.md`:

```md
# EEasingFunc

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEasingFunc
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEasingFunc](./uassetapi.unrealtypes.engineenums.eeasingfunc.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eedgraphpindirection.md`:

```md
# EEdGraphPinDirection

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEdGraphPinDirection
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEdGraphPinDirection](./uassetapi.unrealtypes.engineenums.eedgraphpindirection.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eemitterdynamicparametervalue.md`:

```md
# EEmitterDynamicParameterValue

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEmitterDynamicParameterValue
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEmitterDynamicParameterValue](./uassetapi.unrealtypes.engineenums.eemitterdynamicparametervalue.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eemitternormalsmode.md`:

```md
# EEmitterNormalsMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEmitterNormalsMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEmitterNormalsMode](./uassetapi.unrealtypes.engineenums.eemitternormalsmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eemitterrendermode.md`:

```md
# EEmitterRenderMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEmitterRenderMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEmitterRenderMode](./uassetapi.unrealtypes.engineenums.eemitterrendermode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eendplayreason.md`:

```md
# EEndPlayReason

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEndPlayReason
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEndPlayReason](./uassetapi.unrealtypes.engineenums.eendplayreason.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eevaluatecurvetableresult.md`:

```md
# EEvaluateCurveTableResult

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEvaluateCurveTableResult
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEvaluateCurveTableResult](./uassetapi.unrealtypes.engineenums.eevaluatecurvetableresult.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eevaluatordatasource.md`:

```md
# EEvaluatorDataSource

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEvaluatorDataSource
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEvaluatorDataSource](./uassetapi.unrealtypes.engineenums.eevaluatordatasource.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eevaluatormode.md`:

```md
# EEvaluatorMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EEvaluatorMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EEvaluatorMode](./uassetapi.unrealtypes.engineenums.eevaluatormode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.efastarrayserializerdeltaflags.md`:

```md
# EFastArraySerializerDeltaFlags

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EFastArraySerializerDeltaFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFastArraySerializerDeltaFlags](./uassetapi.unrealtypes.engineenums.efastarrayserializerdeltaflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.efilterinterpolationtype.md`:

```md
# EFilterInterpolationType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EFilterInterpolationType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFilterInterpolationType](./uassetapi.unrealtypes.engineenums.efilterinterpolationtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.efontcachetype.md`:

```md
# EFontCacheType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EFontCacheType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFontCacheType](./uassetapi.unrealtypes.engineenums.efontcachetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.efontimportcharacterset.md`:

```md
# EFontImportCharacterSet

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EFontImportCharacterSet
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFontImportCharacterSet](./uassetapi.unrealtypes.engineenums.efontimportcharacterset.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eformatargumenttype.md`:

```md
# EFormatArgumentType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EFormatArgumentType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFormatArgumentType](./uassetapi.unrealtypes.engineenums.eformatargumenttype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.efrictioncombinemode.md`:

```md
# EFrictionCombineMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EFrictionCombineMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFrictionCombineMode](./uassetapi.unrealtypes.engineenums.efrictioncombinemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.efullyloadpackagetype.md`:

```md
# EFullyLoadPackageType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EFullyLoadPackageType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFullyLoadPackageType](./uassetapi.unrealtypes.engineenums.efullyloadpackagetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.efunctioninputtype.md`:

```md
# EFunctionInputType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EFunctionInputType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EFunctionInputType](./uassetapi.unrealtypes.engineenums.efunctioninputtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.egbufferformat.md`:

```md
# EGBufferFormat

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EGBufferFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EGBufferFormat](./uassetapi.unrealtypes.engineenums.egbufferformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.egrammaticalgender.md`:

```md
# EGrammaticalGender

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EGrammaticalGender
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EGrammaticalGender](./uassetapi.unrealtypes.engineenums.egrammaticalgender.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.egrammaticalnumber.md`:

```md
# EGrammaticalNumber

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EGrammaticalNumber
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EGrammaticalNumber](./uassetapi.unrealtypes.engineenums.egrammaticalnumber.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.egraphaxisstyle.md`:

```md
# EGraphAxisStyle

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EGraphAxisStyle
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EGraphAxisStyle](./uassetapi.unrealtypes.engineenums.egraphaxisstyle.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.egraphdatastyle.md`:

```md
# EGraphDataStyle

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EGraphDataStyle
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EGraphDataStyle](./uassetapi.unrealtypes.engineenums.egraphdatastyle.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.egraphtype.md`:

```md
# EGraphType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EGraphType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EGraphType](./uassetapi.unrealtypes.engineenums.egraphtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ehascustomnavigablegeometry.md`:

```md
# EHasCustomNavigableGeometry

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EHasCustomNavigableGeometry
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EHasCustomNavigableGeometry](./uassetapi.unrealtypes.engineenums.ehascustomnavigablegeometry.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ehitproxypriority.md`:

```md
# EHitProxyPriority

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EHitProxyPriority
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EHitProxyPriority](./uassetapi.unrealtypes.engineenums.ehitproxypriority.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ehoriztextaligment.md`:

```md
# EHorizTextAligment

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EHorizTextAligment
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EHorizTextAligment](./uassetapi.unrealtypes.engineenums.ehoriztextaligment.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eimportancelevel.md`:

```md
# EImportanceLevel

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EImportanceLevel
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EImportanceLevel](./uassetapi.unrealtypes.engineenums.eimportancelevel.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eimportanceweight.md`:

```md
# EImportanceWeight

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EImportanceWeight
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EImportanceWeight](./uassetapi.unrealtypes.engineenums.eimportanceweight.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eindirectlightingcachequality.md`:

```md
# EIndirectLightingCacheQuality

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EIndirectLightingCacheQuality
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EIndirectLightingCacheQuality](./uassetapi.unrealtypes.engineenums.eindirectlightingcachequality.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.einertializationbonestate.md`:

```md
# EInertializationBoneState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EInertializationBoneState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInertializationBoneState](./uassetapi.unrealtypes.engineenums.einertializationbonestate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.einertializationspace.md`:

```md
# EInertializationSpace

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EInertializationSpace
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInertializationSpace](./uassetapi.unrealtypes.engineenums.einertializationspace.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.einertializationstate.md`:

```md
# EInertializationState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EInertializationState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInertializationState](./uassetapi.unrealtypes.engineenums.einertializationstate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.einitialoscillatoroffset.md`:

```md
# EInitialOscillatorOffset

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EInitialOscillatorOffset
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInitialOscillatorOffset](./uassetapi.unrealtypes.engineenums.einitialoscillatoroffset.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.einputevent.md`:

```md
# EInputEvent

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EInputEvent
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInputEvent](./uassetapi.unrealtypes.engineenums.einputevent.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.einterpmoveaxis.md`:

```md
# EInterpMoveAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EInterpMoveAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInterpMoveAxis](./uassetapi.unrealtypes.engineenums.einterpmoveaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.einterptobehaviourtype.md`:

```md
# EInterpToBehaviourType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EInterpToBehaviourType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInterpToBehaviourType](./uassetapi.unrealtypes.engineenums.einterptobehaviourtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.einterptrackmoverotmode.md`:

```md
# EInterpTrackMoveRotMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EInterpTrackMoveRotMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EInterpTrackMoveRotMode](./uassetapi.unrealtypes.engineenums.einterptrackmoverotmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ekinematicbonesupdatetophysics.md`:

```md
# EKinematicBonesUpdateToPhysics

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EKinematicBonesUpdateToPhysics
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EKinematicBonesUpdateToPhysics](./uassetapi.unrealtypes.engineenums.ekinematicbonesupdatetophysics.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elandscapecullingprecision.md`:

```md
# ELandscapeCullingPrecision

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELandscapeCullingPrecision
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELandscapeCullingPrecision](./uassetapi.unrealtypes.engineenums.elandscapecullingprecision.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elegendposition.md`:

```md
# ELegendPosition

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELegendPosition
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELegendPosition](./uassetapi.unrealtypes.engineenums.elegendposition.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elerpinterpolationmode.md`:

```md
# ELerpInterpolationMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELerpInterpolationMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELerpInterpolationMode](./uassetapi.unrealtypes.engineenums.elerpinterpolationmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elightingbuildquality.md`:

```md
# ELightingBuildQuality

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELightingBuildQuality
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELightingBuildQuality](./uassetapi.unrealtypes.engineenums.elightingbuildquality.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elightmappaddingtype.md`:

```md
# ELightMapPaddingType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELightMapPaddingType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELightMapPaddingType](./uassetapi.unrealtypes.engineenums.elightmappaddingtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elightmaptype.md`:

```md
# ELightmapType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELightmapType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELightmapType](./uassetapi.unrealtypes.engineenums.elightmaptype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elightunits.md`:

```md
# ELightUnits

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELightUnits
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELightUnits](./uassetapi.unrealtypes.engineenums.elightunits.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elinearconstraintmotion.md`:

```md
# ELinearConstraintMotion

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELinearConstraintMotion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELinearConstraintMotion](./uassetapi.unrealtypes.engineenums.elinearconstraintmotion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elocationbonesocketselectionmethod.md`:

```md
# ELocationBoneSocketSelectionMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELocationBoneSocketSelectionMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELocationBoneSocketSelectionMethod](./uassetapi.unrealtypes.engineenums.elocationbonesocketselectionmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elocationbonesocketsource.md`:

```md
# ELocationBoneSocketSource

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELocationBoneSocketSource
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELocationBoneSocketSource](./uassetapi.unrealtypes.engineenums.elocationbonesocketsource.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elocationemitterselectionmethod.md`:

```md
# ELocationEmitterSelectionMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELocationEmitterSelectionMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELocationEmitterSelectionMethod](./uassetapi.unrealtypes.engineenums.elocationemitterselectionmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.elocationskelvertsurfacesource.md`:

```md
# ELocationSkelVertSurfaceSource

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ELocationSkelVertSurfaceSource
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ELocationSkelVertSurfaceSource](./uassetapi.unrealtypes.engineenums.elocationskelvertsurfacesource.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialattributeblend.md`:

```md
# EMaterialAttributeBlend

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialAttributeBlend
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialAttributeBlend](./uassetapi.unrealtypes.engineenums.ematerialattributeblend.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialdecalresponse.md`:

```md
# EMaterialDecalResponse

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialDecalResponse
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialDecalResponse](./uassetapi.unrealtypes.engineenums.ematerialdecalresponse.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialdomain.md`:

```md
# EMaterialDomain

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialDomain
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialDomain](./uassetapi.unrealtypes.engineenums.ematerialdomain.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialexposedtextureproperty.md`:

```md
# EMaterialExposedTextureProperty

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialExposedTextureProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialExposedTextureProperty](./uassetapi.unrealtypes.engineenums.ematerialexposedtextureproperty.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialexposedviewproperty.md`:

```md
# EMaterialExposedViewProperty

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialExposedViewProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialExposedViewProperty](./uassetapi.unrealtypes.engineenums.ematerialexposedviewproperty.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialfunctionusage.md`:

```md
# EMaterialFunctionUsage

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialFunctionUsage
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialFunctionUsage](./uassetapi.unrealtypes.engineenums.ematerialfunctionusage.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialmergetype.md`:

```md
# EMaterialMergeType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialMergeType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialMergeType](./uassetapi.unrealtypes.engineenums.ematerialmergetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialparameterassociation.md`:

```md
# EMaterialParameterAssociation

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialParameterAssociation
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialParameterAssociation](./uassetapi.unrealtypes.engineenums.ematerialparameterassociation.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialpositiontransformsource.md`:

```md
# EMaterialPositionTransformSource

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialPositionTransformSource
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialPositionTransformSource](./uassetapi.unrealtypes.engineenums.ematerialpositiontransformsource.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialproperty.md`:

```md
# EMaterialProperty

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialProperty
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialProperty](./uassetapi.unrealtypes.engineenums.ematerialproperty.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialsamplertype.md`:

```md
# EMaterialSamplerType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialSamplerType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialSamplerType](./uassetapi.unrealtypes.engineenums.ematerialsamplertype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialsceneattributeinputmode.md`:

```md
# EMaterialSceneAttributeInputMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialSceneAttributeInputMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialSceneAttributeInputMode](./uassetapi.unrealtypes.engineenums.ematerialsceneattributeinputmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialshadingmodel.md`:

```md
# EMaterialShadingModel

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialShadingModel
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialShadingModel](./uassetapi.unrealtypes.engineenums.ematerialshadingmodel.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialstencilcompare.md`:

```md
# EMaterialStencilCompare

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialStencilCompare
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialStencilCompare](./uassetapi.unrealtypes.engineenums.ematerialstencilcompare.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialtessellationmode.md`:

```md
# EMaterialTessellationMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialTessellationMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialTessellationMode](./uassetapi.unrealtypes.engineenums.ematerialtessellationmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialusage.md`:

```md
# EMaterialUsage

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialUsage
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialUsage](./uassetapi.unrealtypes.engineenums.ematerialusage.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialvectorcoordtransform.md`:

```md
# EMaterialVectorCoordTransform

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialVectorCoordTransform
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialVectorCoordTransform](./uassetapi.unrealtypes.engineenums.ematerialvectorcoordtransform.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematerialvectorcoordtransformsource.md`:

```md
# EMaterialVectorCoordTransformSource

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaterialVectorCoordTransformSource
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaterialVectorCoordTransformSource](./uassetapi.unrealtypes.engineenums.ematerialvectorcoordtransformsource.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ematrixcolumns.md`:

```md
# EMatrixColumns

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMatrixColumns
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMatrixColumns](./uassetapi.unrealtypes.engineenums.ematrixcolumns.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emaxconcurrentresolutionrule.md`:

```md
# EMaxConcurrentResolutionRule

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMaxConcurrentResolutionRule
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMaxConcurrentResolutionRule](./uassetapi.unrealtypes.engineenums.emaxconcurrentresolutionrule.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emeshbufferaccess.md`:

```md
# EMeshBufferAccess

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMeshBufferAccess
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMeshBufferAccess](./uassetapi.unrealtypes.engineenums.emeshbufferaccess.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emeshcamerafacingoptions.md`:

```md
# EMeshCameraFacingOptions

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMeshCameraFacingOptions
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMeshCameraFacingOptions](./uassetapi.unrealtypes.engineenums.emeshcamerafacingoptions.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emeshcamerafacingupaxis.md`:

```md
# EMeshCameraFacingUpAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMeshCameraFacingUpAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMeshCameraFacingUpAxis](./uassetapi.unrealtypes.engineenums.emeshcamerafacingupaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emeshfeatureimportance.md`:

```md
# EMeshFeatureImportance

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMeshFeatureImportance
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMeshFeatureImportance](./uassetapi.unrealtypes.engineenums.emeshfeatureimportance.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emeshinstancingreplacementmethod.md`:

```md
# EMeshInstancingReplacementMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMeshInstancingReplacementMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMeshInstancingReplacementMethod](./uassetapi.unrealtypes.engineenums.emeshinstancingreplacementmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emeshlodselectiontype.md`:

```md
# EMeshLODSelectionType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMeshLODSelectionType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMeshLODSelectionType](./uassetapi.unrealtypes.engineenums.emeshlodselectiontype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emeshmergetype.md`:

```md
# EMeshMergeType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMeshMergeType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMeshMergeType](./uassetapi.unrealtypes.engineenums.emeshmergetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emeshscreenalignment.md`:

```md
# EMeshScreenAlignment

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMeshScreenAlignment
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMeshScreenAlignment](./uassetapi.unrealtypes.engineenums.emeshscreenalignment.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emicrotransactiondelegate.md`:

```md
# EMicroTransactionDelegate

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMicroTransactionDelegate
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMicroTransactionDelegate](./uassetapi.unrealtypes.engineenums.emicrotransactiondelegate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emicrotransactionresult.md`:

```md
# EMicroTransactionResult

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMicroTransactionResult
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMicroTransactionResult](./uassetapi.unrealtypes.engineenums.emicrotransactionresult.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emobilemsaasamplecount.md`:

```md
# EMobileMSAASampleCount

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMobileMSAASampleCount
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMobileMSAASampleCount](./uassetapi.unrealtypes.engineenums.emobilemsaasamplecount.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emoduletype.md`:

```md
# EModuleType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EModuleType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EModuleType](./uassetapi.unrealtypes.engineenums.emoduletype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emonochannelupmixmethod.md`:

```md
# EMonoChannelUpmixMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMonoChannelUpmixMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMonoChannelUpmixMethod](./uassetapi.unrealtypes.engineenums.emonochannelupmixmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emontagenotifyticktype.md`:

```md
# EMontageNotifyTickType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMontageNotifyTickType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMontageNotifyTickType](./uassetapi.unrealtypes.engineenums.emontagenotifyticktype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emontageplayreturntype.md`:

```md
# EMontagePlayReturnType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMontagePlayReturnType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMontagePlayReturnType](./uassetapi.unrealtypes.engineenums.emontageplayreturntype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emontagesubstepresult.md`:

```md
# EMontageSubStepResult

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMontageSubStepResult
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMontageSubStepResult](./uassetapi.unrealtypes.engineenums.emontagesubstepresult.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emousecapturemode.md`:

```md
# EMouseCaptureMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMouseCaptureMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMouseCaptureMode](./uassetapi.unrealtypes.engineenums.emousecapturemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emouselockmode.md`:

```md
# EMouseLockMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMouseLockMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMouseLockMode](./uassetapi.unrealtypes.engineenums.emouselockmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emovecomponentaction.md`:

```md
# EMoveComponentAction

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMoveComponentAction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMoveComponentAction](./uassetapi.unrealtypes.engineenums.emovecomponentaction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.emovementmode.md`:

```md
# EMovementMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EMovementMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EMovementMode](./uassetapi.unrealtypes.engineenums.emovementmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enaturalsoundfalloffmode.md`:

```md
# ENaturalSoundFalloffMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENaturalSoundFalloffMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENaturalSoundFalloffMode](./uassetapi.unrealtypes.engineenums.enaturalsoundfalloffmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enavdatagatheringmode.md`:

```md
# ENavDataGatheringMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENavDataGatheringMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENavDataGatheringMode](./uassetapi.unrealtypes.engineenums.enavdatagatheringmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enavdatagatheringmodeconfig.md`:

```md
# ENavDataGatheringModeConfig

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENavDataGatheringModeConfig
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENavDataGatheringModeConfig](./uassetapi.unrealtypes.engineenums.enavdatagatheringmodeconfig.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enavigationoptionflag.md`:

```md
# ENavigationOptionFlag

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENavigationOptionFlag
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENavigationOptionFlag](./uassetapi.unrealtypes.engineenums.enavigationoptionflag.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enavigationqueryresult.md`:

```md
# ENavigationQueryResult

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENavigationQueryResult
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENavigationQueryResult](./uassetapi.unrealtypes.engineenums.enavigationqueryresult.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enavlinkdirection.md`:

```md
# ENavLinkDirection

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENavLinkDirection
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENavLinkDirection](./uassetapi.unrealtypes.engineenums.enavlinkdirection.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enavpathevent.md`:

```md
# ENavPathEvent

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENavPathEvent
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENavPathEvent](./uassetapi.unrealtypes.engineenums.enavpathevent.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enetdormancy.md`:

```md
# ENetDormancy

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENetDormancy
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENetDormancy](./uassetapi.unrealtypes.engineenums.enetdormancy.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enetrole.md`:

```md
# ENetRole

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENetRole
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENetRole](./uassetapi.unrealtypes.engineenums.enetrole.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enetworkfailure.md`:

```md
# ENetworkFailure

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENetworkFailure
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENetworkFailure](./uassetapi.unrealtypes.engineenums.enetworkfailure.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enetworklagstate.md`:

```md
# ENetworkLagState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENetworkLagState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENetworkLagState](./uassetapi.unrealtypes.engineenums.enetworklagstate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enetworksmoothingmode.md`:

```md
# ENetworkSmoothingMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENetworkSmoothingMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENetworkSmoothingMode](./uassetapi.unrealtypes.engineenums.enetworksmoothingmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enodeadvancedpins.md`:

```md
# ENodeAdvancedPins

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENodeAdvancedPins
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENodeAdvancedPins](./uassetapi.unrealtypes.engineenums.enodeadvancedpins.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enodeenabledstate.md`:

```md
# ENodeEnabledState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENodeEnabledState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENodeEnabledState](./uassetapi.unrealtypes.engineenums.enodeenabledstate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enodetitletype.md`:

```md
# ENodeTitleType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENodeTitleType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENodeTitleType](./uassetapi.unrealtypes.engineenums.enodetitletype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enoisefunction.md`:

```md
# ENoiseFunction

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENoiseFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENoiseFunction](./uassetapi.unrealtypes.engineenums.enoisefunction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enormalmode.md`:

```md
# ENormalMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENormalMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENormalMode](./uassetapi.unrealtypes.engineenums.enormalmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enotifyfiltertype.md`:

```md
# ENotifyFilterType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENotifyFilterType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENotifyFilterType](./uassetapi.unrealtypes.engineenums.enotifyfiltertype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.enotifytriggermode.md`:

```md
# ENotifyTriggerMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ENotifyTriggerMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ENotifyTriggerMode](./uassetapi.unrealtypes.engineenums.enotifytriggermode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eobjecttypequery.md`:

```md
# EObjectTypeQuery

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EObjectTypeQuery
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EObjectTypeQuery](./uassetapi.unrealtypes.engineenums.eobjecttypequery.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eocclusioncombinemode.md`:

```md
# EOcclusionCombineMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EOcclusionCombineMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EOcclusionCombineMode](./uassetapi.unrealtypes.engineenums.eocclusioncombinemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eopacitysourcemode.md`:

```md
# EOpacitySourceMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EOpacitySourceMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EOpacitySourceMode](./uassetapi.unrealtypes.engineenums.eopacitysourcemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eoptimizationtype.md`:

```md
# EOptimizationType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EOptimizationType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EOptimizationType](./uassetapi.unrealtypes.engineenums.eoptimizationtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eorbitchainmode.md`:

```md
# EOrbitChainMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EOrbitChainMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EOrbitChainMode](./uassetapi.unrealtypes.engineenums.eorbitchainmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eoscillatorwaveform.md`:

```md
# EOscillatorWaveform

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EOscillatorWaveform
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EOscillatorWaveform](./uassetapi.unrealtypes.engineenums.eoscillatorwaveform.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eoverlapfilteroption.md`:

```md
# EOverlapFilterOption

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EOverlapFilterOption
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EOverlapFilterOption](./uassetapi.unrealtypes.engineenums.eoverlapfilteroption.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.epanningmethod.md`:

```md
# EPanningMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPanningMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPanningMethod](./uassetapi.unrealtypes.engineenums.epanningmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticleaxislock.md`:

```md
# EParticleAxisLock

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleAxisLock
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleAxisLock](./uassetapi.unrealtypes.engineenums.eparticleaxislock.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticleburstmethod.md`:

```md
# EParticleBurstMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleBurstMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleBurstMethod](./uassetapi.unrealtypes.engineenums.eparticleburstmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlecameraoffsetupdatemethod.md`:

```md
# EParticleCameraOffsetUpdateMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleCameraOffsetUpdateMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleCameraOffsetUpdateMethod](./uassetapi.unrealtypes.engineenums.eparticlecameraoffsetupdatemethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlecollisioncomplete.md`:

```md
# EParticleCollisionComplete

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleCollisionComplete
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleCollisionComplete](./uassetapi.unrealtypes.engineenums.eparticlecollisioncomplete.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlecollisionmode.md`:

```md
# EParticleCollisionMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleCollisionMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleCollisionMode](./uassetapi.unrealtypes.engineenums.eparticlecollisionmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlecollisionresponse.md`:

```md
# EParticleCollisionResponse

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleCollisionResponse
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleCollisionResponse](./uassetapi.unrealtypes.engineenums.eparticlecollisionresponse.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticledetailmode.md`:

```md
# EParticleDetailMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleDetailMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleDetailMode](./uassetapi.unrealtypes.engineenums.eparticledetailmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticleeventtype.md`:

```md
# EParticleEventType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleEventType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleEventType](./uassetapi.unrealtypes.engineenums.eparticleeventtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlescreenalignment.md`:

```md
# EParticleScreenAlignment

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleScreenAlignment
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleScreenAlignment](./uassetapi.unrealtypes.engineenums.eparticlescreenalignment.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlesignificancelevel.md`:

```md
# EParticleSignificanceLevel

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleSignificanceLevel
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleSignificanceLevel](./uassetapi.unrealtypes.engineenums.eparticlesignificancelevel.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlesortmode.md`:

```md
# EParticleSortMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleSortMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleSortMode](./uassetapi.unrealtypes.engineenums.eparticlesortmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlesourceselectionmethod.md`:

```md
# EParticleSourceSelectionMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleSourceSelectionMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleSourceSelectionMethod](./uassetapi.unrealtypes.engineenums.eparticlesourceselectionmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlesubuvinterpmethod.md`:

```md
# EParticleSubUVInterpMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleSubUVInterpMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleSubUVInterpMethod](./uassetapi.unrealtypes.engineenums.eparticlesubuvinterpmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlesysparamtype.md`:

```md
# EParticleSysParamType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleSysParamType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleSysParamType](./uassetapi.unrealtypes.engineenums.eparticlesysparamtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlesysteminsignificancereaction.md`:

```md
# EParticleSystemInsignificanceReaction

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleSystemInsignificanceReaction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleSystemInsignificanceReaction](./uassetapi.unrealtypes.engineenums.eparticlesysteminsignificancereaction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlesystemocclusionboundsmethod.md`:

```md
# EParticleSystemOcclusionBoundsMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleSystemOcclusionBoundsMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleSystemOcclusionBoundsMethod](./uassetapi.unrealtypes.engineenums.eparticlesystemocclusionboundsmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticlesystemupdatemode.md`:

```md
# EParticleSystemUpdateMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleSystemUpdateMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleSystemUpdateMode](./uassetapi.unrealtypes.engineenums.eparticlesystemupdatemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eparticleuvflipmode.md`:

```md
# EParticleUVFlipMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EParticleUVFlipMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EParticleUVFlipMode](./uassetapi.unrealtypes.engineenums.eparticleuvflipmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ephysbodyop.md`:

```md
# EPhysBodyOp

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPhysBodyOp
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPhysBodyOp](./uassetapi.unrealtypes.engineenums.ephysbodyop.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ephysicalmaterialmaskcolor.md`:

```md
# EPhysicalMaterialMaskColor

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPhysicalMaterialMaskColor
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPhysicalMaterialMaskColor](./uassetapi.unrealtypes.engineenums.ephysicalmaterialmaskcolor.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ephysicalsurface.md`:

```md
# EPhysicalSurface

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPhysicalSurface
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPhysicalSurface](./uassetapi.unrealtypes.engineenums.ephysicalsurface.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ephysicstransformupdatemode.md`:

```md
# EPhysicsTransformUpdateMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPhysicsTransformUpdateMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPhysicsTransformUpdateMode](./uassetapi.unrealtypes.engineenums.ephysicstransformupdatemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ephysicstype.md`:

```md
# EPhysicsType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPhysicsType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPhysicsType](./uassetapi.unrealtypes.engineenums.ephysicstype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.epincontainertype.md`:

```md
# EPinContainerType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPinContainerType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPinContainerType](./uassetapi.unrealtypes.engineenums.epincontainertype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.epinhidingmode.md`:

```md
# EPinHidingMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPinHidingMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPinHidingMode](./uassetapi.unrealtypes.engineenums.epinhidingmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eplaneconstraintaxissetting.md`:

```md
# EPlaneConstraintAxisSetting

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPlaneConstraintAxisSetting
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPlaneConstraintAxisSetting](./uassetapi.unrealtypes.engineenums.eplaneconstraintaxissetting.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eplatforminterfacedatatype.md`:

```md
# EPlatformInterfaceDataType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPlatformInterfaceDataType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPlatformInterfaceDataType](./uassetapi.unrealtypes.engineenums.eplatforminterfacedatatype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.epostcopyoperation.md`:

```md
# EPostCopyOperation

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPostCopyOperation
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPostCopyOperation](./uassetapi.unrealtypes.engineenums.epostcopyoperation.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.epreviewanimationblueprintapplicationmethod.md`:

```md
# EPreviewAnimationBlueprintApplicationMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPreviewAnimationBlueprintApplicationMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPreviewAnimationBlueprintApplicationMethod](./uassetapi.unrealtypes.engineenums.epreviewanimationblueprintapplicationmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eprimaryassetcookrule.md`:

```md
# EPrimaryAssetCookRule

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPrimaryAssetCookRule
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPrimaryAssetCookRule](./uassetapi.unrealtypes.engineenums.eprimaryassetcookrule.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.epriorityattenuationmethod.md`:

```md
# EPriorityAttenuationMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPriorityAttenuationMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPriorityAttenuationMethod](./uassetapi.unrealtypes.engineenums.epriorityattenuationmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eproxynormalcomputationmethod.md`:

```md
# EProxyNormalComputationMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EProxyNormalComputationMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EProxyNormalComputationMethod](./uassetapi.unrealtypes.engineenums.eproxynormalcomputationmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.epscpoolmethod.md`:

```md
# EPSCPoolMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EPSCPoolMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPSCPoolMethod](./uassetapi.unrealtypes.engineenums.epscpoolmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.equitpreference.md`:

```md
# EQuitPreference

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EQuitPreference
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EQuitPreference](./uassetapi.unrealtypes.engineenums.equitpreference.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eradialimpulsefalloff.md`:

```md
# ERadialImpulseFalloff

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERadialImpulseFalloff
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERadialImpulseFalloff](./uassetapi.unrealtypes.engineenums.eradialimpulsefalloff.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erawcurvetracktypes.md`:

```md
# ERawCurveTrackTypes

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERawCurveTrackTypes
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERawCurveTrackTypes](./uassetapi.unrealtypes.engineenums.erawcurvetracktypes.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eraytracingglobalilluminationtype.md`:

```md
# ERayTracingGlobalIlluminationType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERayTracingGlobalIlluminationType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERayTracingGlobalIlluminationType](./uassetapi.unrealtypes.engineenums.eraytracingglobalilluminationtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ereflectedandrefractedraytracedshadows.md`:

```md
# EReflectedAndRefractedRayTracedShadows

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EReflectedAndRefractedRayTracedShadows
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EReflectedAndRefractedRayTracedShadows](./uassetapi.unrealtypes.engineenums.ereflectedandrefractedraytracedshadows.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ereflectionsourcetype.md`:

```md
# EReflectionSourceType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EReflectionSourceType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EReflectionSourceType](./uassetapi.unrealtypes.engineenums.ereflectionsourcetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ereflectionstype.md`:

```md
# EReflectionsType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EReflectionsType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EReflectionsType](./uassetapi.unrealtypes.engineenums.ereflectionstype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erefractionmode.md`:

```md
# ERefractionMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERefractionMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERefractionMode](./uassetapi.unrealtypes.engineenums.erefractionmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erelativetransformspace.md`:

```md
# ERelativeTransformSpace

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERelativeTransformSpace
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERelativeTransformSpace](./uassetapi.unrealtypes.engineenums.erelativetransformspace.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erendererstencilmask.md`:

```md
# ERendererStencilMask

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERendererStencilMask
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERendererStencilMask](./uassetapi.unrealtypes.engineenums.erendererstencilmask.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erenderfocusrule.md`:

```md
# ERenderFocusRule

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERenderFocusRule
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERenderFocusRule](./uassetapi.unrealtypes.engineenums.erenderfocusrule.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ereporterlinestyle.md`:

```md
# EReporterLineStyle

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EReporterLineStyle
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EReporterLineStyle](./uassetapi.unrealtypes.engineenums.ereporterlinestyle.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ereverbsendmethod.md`:

```md
# EReverbSendMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EReverbSendMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EReverbSendMethod](./uassetapi.unrealtypes.engineenums.ereverbsendmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erichcurvecompressionformat.md`:

```md
# ERichCurveCompressionFormat

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERichCurveCompressionFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERichCurveCompressionFormat](./uassetapi.unrealtypes.engineenums.erichcurvecompressionformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erichcurveextrapolation.md`:

```md
# ERichCurveExtrapolation

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERichCurveExtrapolation
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERichCurveExtrapolation](./uassetapi.unrealtypes.engineenums.erichcurveextrapolation.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erichcurveinterpmode.md`:

```md
# ERichCurveInterpMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERichCurveInterpMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERichCurveInterpMode](./uassetapi.unrealtypes.engineenums.erichcurveinterpmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erichcurvekeytimecompressionformat.md`:

```md
# ERichCurveKeyTimeCompressionFormat

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERichCurveKeyTimeCompressionFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERichCurveKeyTimeCompressionFormat](./uassetapi.unrealtypes.engineenums.erichcurvekeytimecompressionformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erichcurvetangentmode.md`:

```md
# ERichCurveTangentMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERichCurveTangentMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERichCurveTangentMode](./uassetapi.unrealtypes.engineenums.erichcurvetangentmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erichcurvetangentweightmode.md`:

```md
# ERichCurveTangentWeightMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERichCurveTangentWeightMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERichCurveTangentWeightMode](./uassetapi.unrealtypes.engineenums.erichcurvetangentweightmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erootmotionaccumulatemode.md`:

```md
# ERootMotionAccumulateMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERootMotionAccumulateMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERootMotionAccumulateMode](./uassetapi.unrealtypes.engineenums.erootmotionaccumulatemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erootmotionfinishvelocitymode.md`:

```md
# ERootMotionFinishVelocityMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERootMotionFinishVelocityMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERootMotionFinishVelocityMode](./uassetapi.unrealtypes.engineenums.erootmotionfinishvelocitymode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erootmotionmode.md`:

```md
# ERootMotionMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERootMotionMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERootMotionMode](./uassetapi.unrealtypes.engineenums.erootmotionmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erootmotionrootlock.md`:

```md
# ERootMotionRootLock

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERootMotionRootLock
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERootMotionRootLock](./uassetapi.unrealtypes.engineenums.erootmotionrootlock.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erootmotionsourcesettingsflags.md`:

```md
# ERootMotionSourceSettingsFlags

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERootMotionSourceSettingsFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERootMotionSourceSettingsFlags](./uassetapi.unrealtypes.engineenums.erootmotionsourcesettingsflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erootmotionsourcestatusflags.md`:

```md
# ERootMotionSourceStatusFlags

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERootMotionSourceStatusFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERootMotionSourceStatusFlags](./uassetapi.unrealtypes.engineenums.erootmotionsourcestatusflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.erotatorquantization.md`:

```md
# ERotatorQuantization

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERotatorQuantization
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERotatorQuantization](./uassetapi.unrealtypes.engineenums.erotatorquantization.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eroundingmode.md`:

```md
# ERoundingMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERoundingMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERoundingMode](./uassetapi.unrealtypes.engineenums.eroundingmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eruntimevirtualtexturemainpasstype.md`:

```md
# ERuntimeVirtualTextureMainPassType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERuntimeVirtualTextureMainPassType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERuntimeVirtualTextureMainPassType](./uassetapi.unrealtypes.engineenums.eruntimevirtualtexturemainpasstype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eruntimevirtualtexturematerialtype.md`:

```md
# ERuntimeVirtualTextureMaterialType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERuntimeVirtualTextureMaterialType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERuntimeVirtualTextureMaterialType](./uassetapi.unrealtypes.engineenums.eruntimevirtualtexturematerialtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eruntimevirtualtexturemipvaluemode.md`:

```md
# ERuntimeVirtualTextureMipValueMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ERuntimeVirtualTextureMipValueMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERuntimeVirtualTextureMipValueMode](./uassetapi.unrealtypes.engineenums.eruntimevirtualtexturemipvaluemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esamplersourcemode.md`:

```md
# ESamplerSourceMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESamplerSourceMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESamplerSourceMode](./uassetapi.unrealtypes.engineenums.esamplersourcemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.escenecapturecompositemode.md`:

```md
# ESceneCaptureCompositeMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESceneCaptureCompositeMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESceneCaptureCompositeMode](./uassetapi.unrealtypes.engineenums.escenecapturecompositemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.escenecaptureprimitiverendermode.md`:

```md
# ESceneCapturePrimitiveRenderMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESceneCapturePrimitiveRenderMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESceneCapturePrimitiveRenderMode](./uassetapi.unrealtypes.engineenums.escenecaptureprimitiverendermode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.escenecapturesource.md`:

```md
# ESceneCaptureSource

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESceneCaptureSource
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESceneCaptureSource](./uassetapi.unrealtypes.engineenums.escenecapturesource.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.escenedepthprioritygroup.md`:

```md
# ESceneDepthPriorityGroup

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESceneDepthPriorityGroup
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESceneDepthPriorityGroup](./uassetapi.unrealtypes.engineenums.escenedepthprioritygroup.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.escenetextureid.md`:

```md
# ESceneTextureId

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESceneTextureId
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESceneTextureId](./uassetapi.unrealtypes.engineenums.escenetextureid.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.escreenorientation.md`:

```md
# EScreenOrientation

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EScreenOrientation
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EScreenOrientation](./uassetapi.unrealtypes.engineenums.escreenorientation.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esendlevelcontrolmethod.md`:

```md
# ESendLevelControlMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESendLevelControlMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESendLevelControlMethod](./uassetapi.unrealtypes.engineenums.esendlevelcontrolmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esettingsdof.md`:

```md
# ESettingsDOF

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESettingsDOF
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESettingsDOF](./uassetapi.unrealtypes.engineenums.esettingsdof.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esettingslockedaxis.md`:

```md
# ESettingsLockedAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESettingsLockedAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESettingsLockedAxis](./uassetapi.unrealtypes.engineenums.esettingslockedaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eshadowmapflags.md`:

```md
# EShadowMapFlags

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EShadowMapFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EShadowMapFlags](./uassetapi.unrealtypes.engineenums.eshadowmapflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eskeletalmeshgeoimportversions.md`:

```md
# ESkeletalMeshGeoImportVersions

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESkeletalMeshGeoImportVersions
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESkeletalMeshGeoImportVersions](./uassetapi.unrealtypes.engineenums.eskeletalmeshgeoimportversions.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eskeletalmeshskinningimportversions.md`:

```md
# ESkeletalMeshSkinningImportVersions

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESkeletalMeshSkinningImportVersions
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESkeletalMeshSkinningImportVersions](./uassetapi.unrealtypes.engineenums.eskeletalmeshskinningimportversions.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eskincachedefaultbehavior.md`:

```md
# ESkinCacheDefaultBehavior

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESkinCacheDefaultBehavior
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESkinCacheDefaultBehavior](./uassetapi.unrealtypes.engineenums.eskincachedefaultbehavior.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eskincacheusage.md`:

```md
# ESkinCacheUsage

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESkinCacheUsage
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESkinCacheUsage](./uassetapi.unrealtypes.engineenums.eskincacheusage.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eskyatmospheretransformmode.md`:

```md
# ESkyAtmosphereTransformMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESkyAtmosphereTransformMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESkyAtmosphereTransformMode](./uassetapi.unrealtypes.engineenums.eskyatmospheretransformmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eskylightsourcetype.md`:

```md
# ESkyLightSourceType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESkyLightSourceType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESkyLightSourceType](./uassetapi.unrealtypes.engineenums.eskylightsourcetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eslategesture.md`:

```md
# ESlateGesture

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESlateGesture
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESlateGesture](./uassetapi.unrealtypes.engineenums.eslategesture.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esleepfamily.md`:

```md
# ESleepFamily

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESleepFamily
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESleepFamily](./uassetapi.unrealtypes.engineenums.esleepfamily.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esounddistancecalc.md`:

```md
# ESoundDistanceCalc

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESoundDistanceCalc
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESoundDistanceCalc](./uassetapi.unrealtypes.engineenums.esounddistancecalc.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esoundgroup.md`:

```md
# ESoundGroup

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESoundGroup
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESoundGroup](./uassetapi.unrealtypes.engineenums.esoundgroup.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esoundspatializationalgorithm.md`:

```md
# ESoundSpatializationAlgorithm

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESoundSpatializationAlgorithm
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESoundSpatializationAlgorithm](./uassetapi.unrealtypes.engineenums.esoundspatializationalgorithm.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esoundwavefftsize.md`:

```md
# ESoundWaveFFTSize

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESoundWaveFFTSize
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESoundWaveFFTSize](./uassetapi.unrealtypes.engineenums.esoundwavefftsize.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esoundwaveloadingbehavior.md`:

```md
# ESoundWaveLoadingBehavior

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESoundWaveLoadingBehavior
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESoundWaveLoadingBehavior](./uassetapi.unrealtypes.engineenums.esoundwaveloadingbehavior.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esourcebuschannels.md`:

```md
# ESourceBusChannels

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESourceBusChannels
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESourceBusChannels](./uassetapi.unrealtypes.engineenums.esourcebuschannels.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esourcebussendlevelcontrolmethod.md`:

```md
# ESourceBusSendLevelControlMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESourceBusSendLevelControlMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESourceBusSendLevelControlMethod](./uassetapi.unrealtypes.engineenums.esourcebussendlevelcontrolmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.espawnactorcollisionhandlingmethod.md`:

```md
# ESpawnActorCollisionHandlingMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESpawnActorCollisionHandlingMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESpawnActorCollisionHandlingMethod](./uassetapi.unrealtypes.engineenums.espawnactorcollisionhandlingmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.espeedtreegeometrytype.md`:

```md
# ESpeedTreeGeometryType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESpeedTreeGeometryType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESpeedTreeGeometryType](./uassetapi.unrealtypes.engineenums.espeedtreegeometrytype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.espeedtreelodtype.md`:

```md
# ESpeedTreeLODType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESpeedTreeLODType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESpeedTreeLODType](./uassetapi.unrealtypes.engineenums.espeedtreelodtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.espeedtreewindtype.md`:

```md
# ESpeedTreeWindType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESpeedTreeWindType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESpeedTreeWindType](./uassetapi.unrealtypes.engineenums.espeedtreewindtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esplinecoordinatespace.md`:

```md
# ESplineCoordinateSpace

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESplineCoordinateSpace
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESplineCoordinateSpace](./uassetapi.unrealtypes.engineenums.esplinecoordinatespace.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esplinemeshaxis.md`:

```md
# ESplineMeshAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESplineMeshAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESplineMeshAxis](./uassetapi.unrealtypes.engineenums.esplinemeshaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esplinepointtype.md`:

```md
# ESplinePointType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESplinePointType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESplinePointType](./uassetapi.unrealtypes.engineenums.esplinepointtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.estandbytype.md`:

```md
# EStandbyType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EStandbyType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EStandbyType](./uassetapi.unrealtypes.engineenums.estandbytype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.estaticmeshreductionterimationcriterion.md`:

```md
# EStaticMeshReductionTerimationCriterion

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EStaticMeshReductionTerimationCriterion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EStaticMeshReductionTerimationCriterion](./uassetapi.unrealtypes.engineenums.estaticmeshreductionterimationcriterion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.estereolayershape.md`:

```md
# EStereoLayerShape

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EStereoLayerShape
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EStereoLayerShape](./uassetapi.unrealtypes.engineenums.estereolayershape.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.estereolayertype.md`:

```md
# EStereoLayerType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EStereoLayerType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EStereoLayerType](./uassetapi.unrealtypes.engineenums.estereolayertype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.estreamingvolumeusage.md`:

```md
# EStreamingVolumeUsage

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EStreamingVolumeUsage
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EStreamingVolumeUsage](./uassetapi.unrealtypes.engineenums.estreamingvolumeusage.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esubmixsendmethod.md`:

```md
# ESubmixSendMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESubmixSendMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESubmixSendMethod](./uassetapi.unrealtypes.engineenums.esubmixsendmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esubuvboundingvertexcount.md`:

```md
# ESubUVBoundingVertexCount

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESubUVBoundingVertexCount
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESubUVBoundingVertexCount](./uassetapi.unrealtypes.engineenums.esubuvboundingvertexcount.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.esuggestprojvelocitytraceoption.md`:

```md
# ESuggestProjVelocityTraceOption

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ESuggestProjVelocityTraceOption
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESuggestProjVelocityTraceOption](./uassetapi.unrealtypes.engineenums.esuggestprojvelocitytraceoption.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eteleporttype.md`:

```md
# ETeleportType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETeleportType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETeleportType](./uassetapi.unrealtypes.engineenums.eteleporttype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etemperatureseveritytype.md`:

```md
# ETemperatureSeverityType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETemperatureSeverityType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETemperatureSeverityType](./uassetapi.unrealtypes.engineenums.etemperatureseveritytype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etextgender.md`:

```md
# ETextGender

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextGender
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextGender](./uassetapi.unrealtypes.engineenums.etextgender.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturecolorchannel.md`:

```md
# ETextureColorChannel

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureColorChannel
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureColorChannel](./uassetapi.unrealtypes.engineenums.etexturecolorchannel.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturecompressionquality.md`:

```md
# ETextureCompressionQuality

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureCompressionQuality
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureCompressionQuality](./uassetapi.unrealtypes.engineenums.etexturecompressionquality.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturelossycompressionamount.md`:

```md
# ETextureLossyCompressionAmount

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureLossyCompressionAmount
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureLossyCompressionAmount](./uassetapi.unrealtypes.engineenums.etexturelossycompressionamount.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturemipcount.md`:

```md
# ETextureMipCount

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureMipCount
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureMipCount](./uassetapi.unrealtypes.engineenums.etexturemipcount.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturemiploadoptions.md`:

```md
# ETextureMipLoadOptions

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureMipLoadOptions
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureMipLoadOptions](./uassetapi.unrealtypes.engineenums.etexturemiploadoptions.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturemipvaluemode.md`:

```md
# ETextureMipValueMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureMipValueMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureMipValueMode](./uassetapi.unrealtypes.engineenums.etexturemipvaluemode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturepoweroftwosetting.md`:

```md
# ETexturePowerOfTwoSetting

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETexturePowerOfTwoSetting
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETexturePowerOfTwoSetting](./uassetapi.unrealtypes.engineenums.etexturepoweroftwosetting.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturerendertargetformat.md`:

```md
# ETextureRenderTargetFormat

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureRenderTargetFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureRenderTargetFormat](./uassetapi.unrealtypes.engineenums.etexturerendertargetformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturesamplerfilter.md`:

```md
# ETextureSamplerFilter

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureSamplerFilter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureSamplerFilter](./uassetapi.unrealtypes.engineenums.etexturesamplerfilter.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturesizingtype.md`:

```md
# ETextureSizingType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureSizingType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureSizingType](./uassetapi.unrealtypes.engineenums.etexturesizingtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturesourcearttype.md`:

```md
# ETextureSourceArtType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureSourceArtType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureSourceArtType](./uassetapi.unrealtypes.engineenums.etexturesourcearttype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etexturesourceformat.md`:

```md
# ETextureSourceFormat

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETextureSourceFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETextureSourceFormat](./uassetapi.unrealtypes.engineenums.etexturesourceformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etickinggroup.md`:

```md
# ETickingGroup

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETickingGroup
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETickingGroup](./uassetapi.unrealtypes.engineenums.etickinggroup.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etimecodeprovidersynchronizationstate.md`:

```md
# ETimecodeProviderSynchronizationState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETimecodeProviderSynchronizationState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETimecodeProviderSynchronizationState](./uassetapi.unrealtypes.engineenums.etimecodeprovidersynchronizationstate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etimelinedirection.md`:

```md
# ETimelineDirection

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETimelineDirection
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETimelineDirection](./uassetapi.unrealtypes.engineenums.etimelinedirection.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etimelinelengthmode.md`:

```md
# ETimelineLengthMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETimelineLengthMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETimelineLengthMode](./uassetapi.unrealtypes.engineenums.etimelinelengthmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etimelinesigtype.md`:

```md
# ETimelineSigType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETimelineSigType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETimelineSigType](./uassetapi.unrealtypes.engineenums.etimelinesigtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etimestretchcurvemapping.md`:

```md
# ETimeStretchCurveMapping

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETimeStretchCurveMapping
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETimeStretchCurveMapping](./uassetapi.unrealtypes.engineenums.etimestretchcurvemapping.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etracetypequery.md`:

```md
# ETraceTypeQuery

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETraceTypeQuery
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETraceTypeQuery](./uassetapi.unrealtypes.engineenums.etracetypequery.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etrackactivecondition.md`:

```md
# ETrackActiveCondition

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETrackActiveCondition
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETrackActiveCondition](./uassetapi.unrealtypes.engineenums.etrackactivecondition.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etracktoggleaction.md`:

```md
# ETrackToggleAction

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETrackToggleAction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETrackToggleAction](./uassetapi.unrealtypes.engineenums.etracktoggleaction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etrail2sourcemethod.md`:

```md
# ETrail2SourceMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETrail2SourceMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETrail2SourceMethod](./uassetapi.unrealtypes.engineenums.etrail2sourcemethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etrailsrenderaxisoption.md`:

```md
# ETrailsRenderAxisOption

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETrailsRenderAxisOption
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETrailsRenderAxisOption](./uassetapi.unrealtypes.engineenums.etrailsrenderaxisoption.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etrailwidthmode.md`:

```md
# ETrailWidthMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETrailWidthMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETrailWidthMode](./uassetapi.unrealtypes.engineenums.etrailwidthmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etransitionblendmode.md`:

```md
# ETransitionBlendMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETransitionBlendMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETransitionBlendMode](./uassetapi.unrealtypes.engineenums.etransitionblendmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etransitionlogictype.md`:

```md
# ETransitionLogicType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETransitionLogicType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETransitionLogicType](./uassetapi.unrealtypes.engineenums.etransitionlogictype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etransitiontype.md`:

```md
# ETransitionType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETransitionType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETransitionType](./uassetapi.unrealtypes.engineenums.etransitiontype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etranslucencylightingmode.md`:

```md
# ETranslucencyLightingMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETranslucencyLightingMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETranslucencyLightingMode](./uassetapi.unrealtypes.engineenums.etranslucencylightingmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etranslucencytype.md`:

```md
# ETranslucencyType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETranslucencyType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETranslucencyType](./uassetapi.unrealtypes.engineenums.etranslucencytype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etranslucentsortpolicy.md`:

```md
# ETranslucentSortPolicy

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETranslucentSortPolicy
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETranslucentSortPolicy](./uassetapi.unrealtypes.engineenums.etranslucentsortpolicy.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etravelfailure.md`:

```md
# ETravelFailure

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETravelFailure
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETravelFailure](./uassetapi.unrealtypes.engineenums.etravelfailure.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etraveltype.md`:

```md
# ETravelType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETravelType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETravelType](./uassetapi.unrealtypes.engineenums.etraveltype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etwitterintegrationdelegate.md`:

```md
# ETwitterIntegrationDelegate

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETwitterIntegrationDelegate
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETwitterIntegrationDelegate](./uassetapi.unrealtypes.engineenums.etwitterintegrationdelegate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etwitterrequestmethod.md`:

```md
# ETwitterRequestMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETwitterRequestMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETwitterRequestMethod](./uassetapi.unrealtypes.engineenums.etwitterrequestmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.etypeadvanceanim.md`:

```md
# ETypeAdvanceAnim

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ETypeAdvanceAnim
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ETypeAdvanceAnim](./uassetapi.unrealtypes.engineenums.etypeadvanceanim.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.euiscalingrule.md`:

```md
# EUIScalingRule

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EUIScalingRule
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EUIScalingRule](./uassetapi.unrealtypes.engineenums.euiscalingrule.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eupdaterateshiftbucket.md`:

```md
# EUpdateRateShiftBucket

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EUpdateRateShiftBucket
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EUpdateRateShiftBucket](./uassetapi.unrealtypes.engineenums.eupdaterateshiftbucket.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.euserdefinedstructurestatus.md`:

```md
# EUserDefinedStructureStatus

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EUserDefinedStructureStatus
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EUserDefinedStructureStatus](./uassetapi.unrealtypes.engineenums.euserdefinedstructurestatus.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.euvoutput.md`:

```md
# EUVOutput

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EUVOutput
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EUVOutput](./uassetapi.unrealtypes.engineenums.euvoutput.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evectorfieldconstructionop.md`:

```md
# EVectorFieldConstructionOp

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVectorFieldConstructionOp
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVectorFieldConstructionOp](./uassetapi.unrealtypes.engineenums.evectorfieldconstructionop.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evectornoisefunction.md`:

```md
# EVectorNoiseFunction

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVectorNoiseFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVectorNoiseFunction](./uassetapi.unrealtypes.engineenums.evectornoisefunction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evectorquantization.md`:

```md
# EVectorQuantization

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVectorQuantization
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVectorQuantization](./uassetapi.unrealtypes.engineenums.evectorquantization.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evertexpaintaxis.md`:

```md
# EVertexPaintAxis

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVertexPaintAxis
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVertexPaintAxis](./uassetapi.unrealtypes.engineenums.evertexpaintaxis.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.everticaltextaligment.md`:

```md
# EVerticalTextAligment

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVerticalTextAligment
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVerticalTextAligment](./uassetapi.unrealtypes.engineenums.everticaltextaligment.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eviewmodeindex.md`:

```md
# EViewModeIndex

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EViewModeIndex
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EViewModeIndex](./uassetapi.unrealtypes.engineenums.eviewmodeindex.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eviewtargetblendfunction.md`:

```md
# EViewTargetBlendFunction

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EViewTargetBlendFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EViewTargetBlendFunction](./uassetapi.unrealtypes.engineenums.eviewtargetblendfunction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evirtualizationmode.md`:

```md
# EVirtualizationMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVirtualizationMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVirtualizationMode](./uassetapi.unrealtypes.engineenums.evirtualizationmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evisibilityaggressiveness.md`:

```md
# EVisibilityAggressiveness

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVisibilityAggressiveness
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVisibilityAggressiveness](./uassetapi.unrealtypes.engineenums.evisibilityaggressiveness.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evisibilitybasedanimtickoption.md`:

```md
# EVisibilityBasedAnimTickOption

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVisibilityBasedAnimTickOption
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVisibilityBasedAnimTickOption](./uassetapi.unrealtypes.engineenums.evisibilitybasedanimtickoption.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evisibilitytrackaction.md`:

```md
# EVisibilityTrackAction

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVisibilityTrackAction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVisibilityTrackAction](./uassetapi.unrealtypes.engineenums.evisibilitytrackaction.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evisibilitytrackcondition.md`:

```md
# EVisibilityTrackCondition

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVisibilityTrackCondition
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVisibilityTrackCondition](./uassetapi.unrealtypes.engineenums.evisibilitytrackcondition.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evoicesamplerate.md`:

```md
# EVoiceSampleRate

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVoiceSampleRate
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVoiceSampleRate](./uassetapi.unrealtypes.engineenums.evoicesamplerate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.evolumelightingmethod.md`:

```md
# EVolumeLightingMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EVolumeLightingMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EVolumeLightingMethod](./uassetapi.unrealtypes.engineenums.evolumelightingmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ewalkableslopebehavior.md`:

```md
# EWalkableSlopeBehavior

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EWalkableSlopeBehavior
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EWalkableSlopeBehavior](./uassetapi.unrealtypes.engineenums.ewalkableslopebehavior.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ewindowmode.md`:

```md
# EWindowMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EWindowMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EWindowMode](./uassetapi.unrealtypes.engineenums.ewindowmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ewindowtitlebarmode.md`:

```md
# EWindowTitleBarMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EWindowTitleBarMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EWindowTitleBarMode](./uassetapi.unrealtypes.engineenums.ewindowtitlebarmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.ewindsourcetype.md`:

```md
# EWindSourceType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EWindSourceType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EWindSourceType](./uassetapi.unrealtypes.engineenums.ewindsourcetype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.eworldpositionincludedoffsets.md`:

```md
# EWorldPositionIncludedOffsets

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum EWorldPositionIncludedOffsets
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EWorldPositionIncludedOffsets](./uassetapi.unrealtypes.engineenums.eworldpositionincludedoffsets.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.fnavigationsystemrunmode.md`:

```md
# FNavigationSystemRunMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum FNavigationSystemRunMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [FNavigationSystemRunMode](./uassetapi.unrealtypes.engineenums.fnavigationsystemrunmode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.modulationparammode.md`:

```md
# ModulationParamMode

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ModulationParamMode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ModulationParamMode](./uassetapi.unrealtypes.engineenums.modulationparammode.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.particlereplaystate.md`:

```md
# ParticleReplayState

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ParticleReplayState
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ParticleReplayState](./uassetapi.unrealtypes.engineenums.particlereplaystate.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.particlesystemlodmethod.md`:

```md
# ParticleSystemLODMethod

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ParticleSystemLODMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ParticleSystemLODMethod](./uassetapi.unrealtypes.engineenums.particlesystemlodmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.reverbpreset.md`:

```md
# ReverbPreset

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum ReverbPreset
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ReverbPreset](./uassetapi.unrealtypes.engineenums.reverbpreset.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.skeletalmeshoptimizationimportance.md`:

```md
# SkeletalMeshOptimizationImportance

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum SkeletalMeshOptimizationImportance
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [SkeletalMeshOptimizationImportance](./uassetapi.unrealtypes.engineenums.skeletalmeshoptimizationimportance.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.skeletalmeshoptimizationtype.md`:

```md
# SkeletalMeshOptimizationType

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum SkeletalMeshOptimizationType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [SkeletalMeshOptimizationType](./uassetapi.unrealtypes.engineenums.skeletalmeshoptimizationtype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.skeletalmeshterminationcriterion.md`:

```md
# SkeletalMeshTerminationCriterion

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum SkeletalMeshTerminationCriterion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [SkeletalMeshTerminationCriterion](./uassetapi.unrealtypes.engineenums.skeletalmeshterminationcriterion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.textureaddress.md`:

```md
# TextureAddress

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum TextureAddress
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [TextureAddress](./uassetapi.unrealtypes.engineenums.textureaddress.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.texturecompressionsettings.md`:

```md
# TextureCompressionSettings

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum TextureCompressionSettings
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [TextureCompressionSettings](./uassetapi.unrealtypes.engineenums.texturecompressionsettings.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.texturefilter.md`:

```md
# TextureFilter

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum TextureFilter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [TextureFilter](./uassetapi.unrealtypes.engineenums.texturefilter.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.texturegroup.md`:

```md
# TextureGroup

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum TextureGroup
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [TextureGroup](./uassetapi.unrealtypes.engineenums.texturegroup.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineenums.texturemipgensettings.md`:

```md
# TextureMipGenSettings

Namespace: UAssetAPI.UnrealTypes.EngineEnums

```csharp
public enum TextureMipGenSettings
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [TextureMipGenSettings](./uassetapi.unrealtypes.engineenums.texturemipgensettings.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.engineversion.md`:

```md
# EngineVersion

Namespace: UAssetAPI.UnrealTypes

An enum used to represent all retail versions of the Unreal Engine. Each version entry represents a particular [ObjectVersion](./uassetapi.unrealtypes.objectversion.md), a particular [ObjectVersionUE5](./uassetapi.unrealtypes.objectversionue5.md), and the default set of all applicable [CustomVersion](./uassetapi.customversion.md) enum values.

```csharp
public enum EngineVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EngineVersion](./uassetapi.unrealtypes.engineversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| VER_UE4_0 | 2 | 4.0 |
| VER_UE4_1 | 3 | 4.1 |
| VER_UE4_2 | 4 | 4.2 |
| VER_UE4_3 | 5 | 4.3 |
| VER_UE4_4 | 6 | 4.4 |
| VER_UE4_5 | 7 | 4.5 |
| VER_UE4_6 | 8 | 4.6 |
| VER_UE4_7 | 9 | 4.7 |
| VER_UE4_8 | 10 | 4.8 |
| VER_UE4_9 | 11 | 4.9 |
| VER_UE4_10 | 12 | 4.10 |
| VER_UE4_11 | 13 | 4.11 |
| VER_UE4_12 | 14 | 4.12 |
| VER_UE4_13 | 15 | 4.13 |
| VER_UE4_14 | 16 | 4.14 |
| VER_UE4_15 | 17 | 4.15 |
| VER_UE4_16 | 18 | 4.16 |
| VER_UE4_17 | 19 | 4.17 |
| VER_UE4_18 | 20 | 4.18 |
| VER_UE4_19 | 21 | 4.19 |
| VER_UE4_20 | 22 | 4.20 |
| VER_UE4_21 | 23 | 4.21 |
| VER_UE4_22 | 24 | 4.22 |
| VER_UE4_23 | 25 | 4.23 |
| VER_UE4_24 | 26 | 4.24 |
| VER_UE4_25 | 27 | 4.25 |
| VER_UE4_26 | 28 | 4.26 |
| VER_UE4_27 | 29 | 4.27 |
| VER_UE5_0EA | 30 | 5.0EA |
| VER_UE5_0 | 31 | 5.0 |
| VER_UE5_1 | 32 | 5.1 |
| VER_UE5_2 | 33 | 5.2 |
| VER_UE5_3 | 34 | 5.3 |
| VER_UE5_4 | 35 | 5.4 |
| VER_UE5_5 | 36 | 5.5 |
| VER_UE5_6 | 37 | 5.6 |
| VER_UE5_7 | 38 | 5.7 |
| VER_UE4_AUTOMATIC_VERSION | 38 | The newest specified version of the Unreal Engine. |

```

`docs/src/api/uassetapi.unrealtypes.eobjectdataresourceflags.md`:

```md
# EObjectDataResourceFlags

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum EObjectDataResourceFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EObjectDataResourceFlags](./uassetapi.unrealtypes.eobjectdataresourceflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.eobjectdataresourceversion.md`:

```md
# EObjectDataResourceVersion

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum EObjectDataResourceVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EObjectDataResourceVersion](./uassetapi.unrealtypes.eobjectdataresourceversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.eobjectflags.md`:

```md
# EObjectFlags

Namespace: UAssetAPI.UnrealTypes

Flags describing an object instance

```csharp
public enum EObjectFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EObjectFlags](./uassetapi.unrealtypes.eobjectflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.epackageflags.md`:

```md
# EPackageFlags

Namespace: UAssetAPI.UnrealTypes

Package flags, passed into UPackage::SetPackageFlags and related functions in the Unreal Engine

```csharp
public enum EPackageFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPackageFlags](./uassetapi.unrealtypes.epackageflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| PKG_None | 0 | No flags |
| PKG_NewlyCreated | 1 | Newly created package, not saved yet. In editor only. |
| PKG_ClientOptional | 2 | Purely optional for clients. |
| PKG_ServerSideOnly | 4 | Only needed on the server side. |
| PKG_CompiledIn | 16 | This package is from "compiled in" classes. |
| PKG_ForDiffing | 32 | This package was loaded just for the purposes of diffing |
| PKG_EditorOnly | 64 | This is editor-only package (for example: editor module script package) |
| PKG_Developer | 128 | Developer module |
| PKG_UncookedOnly | 256 | Loaded only in uncooked builds (i.e. runtime in editor) |
| PKG_Cooked | 512 | Package is cooked |
| PKG_ContainsNoAsset | 1024 | Package doesn't contain any asset object (although asset tags can be present) |
| PKG_UnversionedProperties | 8192 | Uses unversioned property serialization instead of versioned tagged property serialization |
| PKG_ContainsMapData | 16384 | Contains map data (UObjects only referenced by a single ULevel) but is stored in a different package |
| PKG_Compiling | 65536 | package is currently being compiled |
| PKG_ContainsMap | 131072 | Set if the package contains a ULevel/ UWorld object |
| PKG_RequiresLocalizationGather | 262144 | ??? |
| PKG_PlayInEditor | 1048576 | Set if the package was created for the purpose of PIE |
| PKG_ContainsScript | 2097152 | Package is allowed to contain UClass objects |
| PKG_DisallowExport | 4194304 | Editor should not export asset in this package |
| PKG_DynamicImports | 268435456 | This package should resolve dynamic imports from its export at runtime. |
| PKG_RuntimeGenerated | 536870912 | This package contains elements that are runtime generated, and may not follow standard loading order rules |
| PKG_ReloadingForCooker | 1073741824 | This package is reloading in the cooker, try to avoid getting data we will never need. We won't save this package. |
| PKG_FilterEditorOnly | 2147483648 | Package has editor-only data filtered out |

```

`docs/src/api/uassetapi.unrealtypes.epropertyflags.md`:

```md
# EPropertyFlags

Namespace: UAssetAPI.UnrealTypes

Flags associated with each property in a class, overriding the property's default behavior.

```csharp
public enum EPropertyFlags
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPropertyFlags](./uassetapi.unrealtypes.epropertyflags.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| CPF_Edit | 1 | Property is user-settable in the editor. |
| CPF_ConstParm | 2 | This is a constant function parameter |
| CPF_BlueprintVisible | 4 | This property can be read by blueprint code |
| CPF_ExportObject | 8 | Object can be exported with actor. |
| CPF_BlueprintReadOnly | 16 | This property cannot be modified by blueprint code |
| CPF_Net | 32 | Property is relevant to network replication. |
| CPF_EditFixedSize | 64 | Indicates that elements of an array can be modified, but its size cannot be changed. |
| CPF_Parm | 128 | Function/When call parameter. |
| CPF_OutParm | 256 | Value is copied out after function call. |
| CPF_ZeroConstructor | 512 | memset is fine for construction |
| CPF_ReturnParm | 1024 | Return value. |
| CPF_DisableEditOnTemplate | 2048 | Disable editing of this property on an archetype/sub-blueprint |
| CPF_Transient | 8192 | Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs. |
| CPF_Config | 16384 | Property should be loaded/saved as permanent profile. |
| CPF_DisableEditOnInstance | 65536 | Disable editing on an instance of this class |
| CPF_EditConst | 131072 | Property is uneditable in the editor. |
| CPF_GlobalConfig | 262144 | Load config from base class, not subclass. |
| CPF_InstancedReference | 524288 | Property is a component references. |
| CPF_DuplicateTransient | 2097152 | Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.) |
| CPF_SaveGame | 16777216 | Property should be serialized for save games, this is only checked for game-specific archives with ArIsSaveGame |
| CPF_NoClear | 33554432 | Hide clear (and browse) button. |
| CPF_ReferenceParm | 134217728 | Value is passed by reference; CPF_OutParam and CPF_Param should also be set. |
| CPF_BlueprintAssignable | 268435456 | MC Delegates only. Property should be exposed for assigning in blueprint code |
| CPF_Deprecated | 536870912 | Property is deprecated. Read it from an archive, but don't save it. |
| CPF_IsPlainOldData | 1073741824 | If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue |
| CPF_RepSkip | 2147483648 | Not replicated. For non replicated properties in replicated structs |
| CPF_RepNotify | 4294967296 | Notify actors when a property is replicated |
| CPF_Interp | 8589934592 | interpolatable property for use with matinee |
| CPF_NonTransactional | 17179869184 | Property isn't transacted |
| CPF_EditorOnly | 34359738368 | Property should only be loaded in the editor |
| CPF_NoDestructor | 68719476736 | No destructor |
| CPF_AutoWeak | 274877906944 | Only used for weak pointers, means the export type is autoweak |
| CPF_ContainsInstancedReference | 549755813888 | Property contains component references. |
| CPF_AssetRegistrySearchable | 1099511627776 | asset instances will add properties with this flag to the asset registry automatically |
| CPF_SimpleDisplay | 2199023255552 | The property is visible by default in the editor details view |
| CPF_AdvancedDisplay | 4398046511104 | The property is advanced and not visible by default in the editor details view |
| CPF_Protected | 8796093022208 | property is protected from the perspective of script |
| CPF_BlueprintCallable | 17592186044416 | MC Delegates only. Property should be exposed for calling in blueprint code |
| CPF_BlueprintAuthorityOnly | 35184372088832 | MC Delegates only. This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly. |
| CPF_TextExportTransient | 70368744177664 | Property shouldn't be exported to text format (e.g. copy/paste) |
| CPF_NonPIEDuplicateTransient | 140737488355328 | Property should only be copied in PIE |
| CPF_ExposeOnSpawn | 281474976710656 | Property is exposed on spawn |
| CPF_PersistentInstance | 562949953421312 | A object referenced by the property is duplicated like a component. (Each actor should have an own instance.) |
| CPF_UObjectWrapper | 1125899906842624 | Property was parsed as a wrapper class like TSubclassOf T, FScriptInterface etc., rather than a USomething* |
| CPF_HasGetValueTypeHash | 2251799813685248 | This property can generate a meaningful hash value. |
| CPF_NativeAccessSpecifierPublic | 4503599627370496 | Public native access specifier |
| CPF_NativeAccessSpecifierProtected | 9007199254740992 | Protected native access specifier |
| CPF_NativeAccessSpecifierPrivate | 18014398509481984 | Private native access specifier |
| CPF_SkipSerialization | 36028797018963968 | Property shouldn't be serialized, can still be exported to text |

```

`docs/src/api/uassetapi.unrealtypes.erangeboundtypes.md`:

```md
# ERangeBoundTypes

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum ERangeBoundTypes
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ERangeBoundTypes](./uassetapi.unrealtypes.erangeboundtypes.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.ffieldpath.md`:

```md
# FFieldPath

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FFieldPath : UAssetAPI.PropertyTypes.Objects.IStruct`1[[UAssetAPI.UnrealTypes.FFieldPath]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FFieldPath](./uassetapi.unrealtypes.ffieldpath.md)<br>
Implements [IStruct&lt;FFieldPath&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **Path**

Path to the FField object from the innermost FField to the outermost UObject (UPackage)

```csharp
public FName[] Path;
```

### **ResolvedOwner**

The cached owner of this field.

```csharp
public FPackageIndex ResolvedOwner;
```

## Constructors

### **FFieldPath(FName[], FPackageIndex, Int32)**

```csharp
public FFieldPath(FName[] path, FPackageIndex resolvedOwner, int numExports)
```

#### Parameters

`path` [FName[]](./uassetapi.unrealtypes.fname.md)<br>

`resolvedOwner` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

`numExports` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FFieldPath()**

```csharp
public FFieldPath()
```

### **FFieldPath(AssetBinaryReader)**

```csharp
public FFieldPath(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
public static FFieldPath Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FFieldPath](./uassetapi.unrealtypes.ffieldpath.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public static FFieldPath FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FFieldPath](./uassetapi.unrealtypes.ffieldpath.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.ffontcharacter.md`:

```md
# FFontCharacter

Namespace: UAssetAPI.UnrealTypes

This struct is serialized using native serialization so any changes to it require a package version bump.

```csharp
public struct FFontCharacter
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FFontCharacter](./uassetapi.unrealtypes.ffontcharacter.md)

## Fields

### **StartU**

```csharp
public int StartU;
```

### **StartV**

```csharp
public int StartV;
```

### **USize**

```csharp
public int USize;
```

### **VSize**

```csharp
public int VSize;
```

### **TextureIndex**

```csharp
public byte TextureIndex;
```

### **VerticalOffset**

```csharp
public int VerticalOffset;
```

## Constructors

### **FFontCharacter(AssetBinaryReader)**

```csharp
FFontCharacter(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unrealtypes.ffontdata.md`:

```md
# FFontData

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FFontData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FFontData](./uassetapi.unrealtypes.ffontdata.md)

## Fields

### **LocalFontFaceAsset**

```csharp
public FPackageIndex LocalFontFaceAsset;
```

### **FontFilename**

```csharp
public FString FontFilename;
```

### **Hinting**

```csharp
public EFontHinting Hinting;
```

### **LoadingPolicy**

```csharp
public EFontLoadingPolicy LoadingPolicy;
```

### **SubFaceIndex**

```csharp
public int SubFaceIndex;
```

### **bIsCooked**

```csharp
public bool bIsCooked;
```

## Constructors

### **FFontData()**

```csharp
public FFontData()
```

### **FFontData(AssetBinaryReader)**

```csharp
public FFontData(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unrealtypes.fframenumber.md`:

```md
# FFrameNumber

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FFrameNumber
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FFrameNumber](./uassetapi.unrealtypes.fframenumber.md)<br>
Implements [IStruct&lt;FFrameNumber&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **Value**

```csharp
public int Value;
```

## Constructors

### **FFrameNumber()**

```csharp
FFrameNumber()
```

### **FFrameNumber(Int32)**

```csharp
FFrameNumber(int value)
```

#### Parameters

`value` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FFrameNumber(AssetBinaryReader)**

```csharp
FFrameNumber(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FFrameNumber Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FFrameNumber](./uassetapi.unrealtypes.fframenumber.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
FFrameNumber FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FFrameNumber](./uassetapi.unrealtypes.fframenumber.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fframerate.md`:

```md
# FFrameRate

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FFrameRate
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FFrameRate](./uassetapi.unrealtypes.fframerate.md)

## Fields

### **Numerator**

```csharp
public int Numerator;
```

### **Denominator**

```csharp
public int Denominator;
```

## Constructors

### **FFrameRate()**

```csharp
FFrameRate()
```

### **FFrameRate(Int32, Int32)**

```csharp
FFrameRate(int numerator, int denominator)
```

#### Parameters

`numerator` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`denominator` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FFrameRate(AssetBinaryReader)**

```csharp
FFrameRate(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **TryParse(String, FFrameRate&)**

```csharp
bool TryParse(string s, FFrameRate& result)
```

#### Parameters

`s` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`result` [FFrameRate&](./uassetapi.unrealtypes.fframerate&.md)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

```

`docs/src/api/uassetapi.unrealtypes.fframetime.md`:

```md
# FFrameTime

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FFrameTime
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FFrameTime](./uassetapi.unrealtypes.fframetime.md)

## Fields

### **FrameNumber**

```csharp
public FFrameNumber FrameNumber;
```

### **SubFrame**

```csharp
public float SubFrame;
```

## Constructors

### **FFrameTime()**

```csharp
FFrameTime()
```

### **FFrameTime(FFrameNumber, Single)**

```csharp
FFrameTime(FFrameNumber frameNumber, float subFrame)
```

#### Parameters

`frameNumber` [FFrameNumber](./uassetapi.unrealtypes.fframenumber.md)<br>

`subFrame` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FFrameTime(AssetBinaryReader)**

```csharp
FFrameTime(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fgatherabletextdata.md`:

```md
# FGatherableTextData

Namespace: UAssetAPI.UnrealTypes

Gatherable text data item

```csharp
public struct FGatherableTextData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FGatherableTextData](./uassetapi.unrealtypes.fgatherabletextdata.md)

## Properties

### **NamespaceName**

```csharp
public FString NamespaceName { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **SourceData**

```csharp
public FTextSourceData SourceData { get; set; }
```

#### Property Value

[FTextSourceData](./uassetapi.unrealtypes.ftextsourcedata.md)<br>

### **SourceSiteContexts**

```csharp
public List<FTextSourceSiteContext> SourceSiteContexts { get; set; }
```

#### Property Value

[List&lt;FTextSourceSiteContext&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

```

`docs/src/api/uassetapi.unrealtypes.fintvector.md`:

```md
# FIntVector

Namespace: UAssetAPI.UnrealTypes

Structure for integer vectors in 3-d space.

```csharp
public struct FIntVector
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FIntVector](./uassetapi.unrealtypes.fintvector.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FIntVector&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **X**

```csharp
public int X;
```

### **Y**

```csharp
public int Y;
```

### **Z**

```csharp
public int Z;
```

## Constructors

### **FIntVector(Int32, Int32, Int32)**

```csharp
FIntVector(int x, int y, int z)
```

#### Parameters

`x` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`y` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`z` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FIntVector(AssetBinaryReader)**

```csharp
FIntVector(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Read(AssetBinaryReader)**

```csharp
FIntVector Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FIntVector](./uassetapi.unrealtypes.fintvector.md)<br>

### **Clone()**

```csharp
object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **FromString(String[], UAsset)**

```csharp
FIntVector FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FIntVector](./uassetapi.unrealtypes.fintvector.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unrealtypes.fintvector2.md`:

```md
# FIntVector2

Namespace: UAssetAPI.UnrealTypes

Structure for integer vectors in 2-d space.

```csharp
public struct FIntVector2
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FIntVector2](./uassetapi.unrealtypes.fintvector2.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FIntVector2&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **X**

```csharp
public int X;
```

### **Y**

```csharp
public int Y;
```

## Constructors

### **FIntVector2(Int32, Int32)**

```csharp
FIntVector2(int x, int y)
```

#### Parameters

`x` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`y` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FIntVector2(AssetBinaryReader)**

```csharp
FIntVector2(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FIntVector2 Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FIntVector2](./uassetapi.unrealtypes.fintvector2.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FIntVector2 FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FIntVector2](./uassetapi.unrealtypes.fintvector2.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.flinearcolor.md`:

```md
# FLinearColor

Namespace: UAssetAPI.UnrealTypes

A linear, 32-bit/component floating point RGBA color.

```csharp
public struct FLinearColor
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FLinearColor](./uassetapi.unrealtypes.flinearcolor.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FLinearColor&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **R**

```csharp
public float R;
```

### **G**

```csharp
public float G;
```

### **B**

```csharp
public float B;
```

### **A**

```csharp
public float A;
```

## Constructors

### **FLinearColor(Single, Single, Single, Single)**

```csharp
FLinearColor(float R, float G, float B, float A)
```

#### Parameters

`R` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`G` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`B` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`A` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FLinearColor(AssetBinaryReader)**

```csharp
FLinearColor(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Clone()**

```csharp
object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Read(AssetBinaryReader)**

```csharp
FLinearColor Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FLinearColor](./uassetapi.unrealtypes.flinearcolor.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FLinearColor FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FLinearColor](./uassetapi.unrealtypes.flinearcolor.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.flocmetadataobject.md`:

```md
# FLocMetadataObject

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FLocMetadataObject
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FLocMetadataObject](./uassetapi.unrealtypes.flocmetadataobject.md)

## Properties

### **Values**

```csharp
public List<FLocMetadataValue> Values { get; set; }
```

#### Property Value

[List&lt;FLocMetadataValue&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

## Constructors

### **FLocMetadataObject()**

```csharp
public FLocMetadataObject()
```

```

`docs/src/api/uassetapi.unrealtypes.fmatrix.md`:

```md
# FMatrix

Namespace: UAssetAPI.UnrealTypes

4x4 matrix of floating point values.

```csharp
public struct FMatrix
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FMatrix](./uassetapi.unrealtypes.fmatrix.md)<br>
Implements [IStruct&lt;FMatrix&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **XPlane**

```csharp
public FPlane XPlane;
```

### **YPlane**

```csharp
public FPlane YPlane;
```

### **ZPlane**

```csharp
public FPlane ZPlane;
```

### **WPlane**

```csharp
public FPlane WPlane;
```

## Constructors

### **FMatrix(FPlane, FPlane, FPlane, FPlane)**

```csharp
FMatrix(FPlane xPlane, FPlane yPlane, FPlane zPlane, FPlane wPlane)
```

#### Parameters

`xPlane` [FPlane](./uassetapi.unrealtypes.fplane.md)<br>

`yPlane` [FPlane](./uassetapi.unrealtypes.fplane.md)<br>

`zPlane` [FPlane](./uassetapi.unrealtypes.fplane.md)<br>

`wPlane` [FPlane](./uassetapi.unrealtypes.fplane.md)<br>

### **FMatrix(AssetBinaryReader)**

```csharp
FMatrix(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FMatrix Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FMatrix](./uassetapi.unrealtypes.fmatrix.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
FMatrix FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FMatrix](./uassetapi.unrealtypes.fmatrix.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fname.md`:

```md
# FName

Namespace: UAssetAPI.UnrealTypes

Unreal name - consists of an FString (which is serialized as an index in the name map) and an instance number

```csharp
public class FName : System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FName](./uassetapi.unrealtypes.fname.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Number**

Instance number.

```csharp
public int Number;
```

### **Type**

The type of this FName; i.e. whether it points to a package-level name table, container-level name table, or global name table. This value is always [EMappedNameType.Package](./uassetapi.unrealtypes.emappednametype.md#package) for non-Zen assets.

```csharp
public EMappedNameType Type;
```

### **Asset**

The asset that this FName is bound to.

```csharp
public INameMap Asset;
```

## Properties

### **Value**

```csharp
public FString Value { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **IsDummy**

```csharp
public bool IsDummy { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IsGlobal**

Does this FName point into the global name table? This value is always false for non-Zen assets.

```csharp
public bool IsGlobal { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FName(INameMap, String, Int32)**

Creates a new FName instance.

```csharp
public FName(INameMap asset, string value, int number)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>
The asset that this FName is bound to.

`value` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The string literal that the new FName's value will be, verbatim.

`number` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The instance number of the new FName.

### **FName(INameMap, FString, Int32)**

Creates a new FName instance.

```csharp
public FName(INameMap asset, FString value, int number)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>
The asset that this FName is bound to.

`value` [FString](./uassetapi.unrealtypes.fstring.md)<br>
The FString that the FName's value will be, verbatim.

`number` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The instance number of the new FName.

### **FName(INameMap, Int32, Int32)**

Creates a new FName instance.

```csharp
public FName(INameMap asset, int index, int number)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>
The asset that this FName is bound to.

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index that this FName's value will be.

`number` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The instance number of the new FName.

### **FName(INameMap)**

Creates a new blank FName instance.

```csharp
public FName(INameMap asset)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>
The asset that this FName is bound to.

### **FName()**

Creates a new blank FName instance, with no asset bound to it. An asset must be bound to this FName before setting its value.

```csharp
public FName()
```

## Methods

### **ToString()**

Converts this FName instance into a human-readable string. This is the inverse of [FName.FromString(INameMap, String)](./uassetapi.unrealtypes.fname.md#fromstringinamemap-string).

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The human-readable string that represents this FName.

### **FromStringFragments(INameMap, String, String&, Int32&)**

```csharp
internal static void FromStringFragments(INameMap asset, string val, String& str, Int32& num)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>

`val` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`str` [String&](https://docs.microsoft.com/en-us/dotnet/api/system.string&)<br>

`num` [Int32&](https://docs.microsoft.com/en-us/dotnet/api/system.int32&)<br>

### **IsFromStringValid(INameMap, String)**

```csharp
public static bool IsFromStringValid(INameMap asset, string val)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>

`val` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **FromString(INameMap, String)**

Converts a human-readable string into an FName instance. This is the inverse of [FName.ToString()](./uassetapi.unrealtypes.fname.md#tostring).

```csharp
public static FName FromString(INameMap asset, string val)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>
The asset that the new FName will be bound to.

`val` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The human-readable string to convert into an FName instance.

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>
An FName instance that this string represents.

### **Transfer(INameMap)**

Creates a new FName with the same string value and number as the current instance but is bound to a different asset.

```csharp
public FName Transfer(INameMap newAsset)
```

#### Parameters

`newAsset` [INameMap](./uassetapi.inamemap.md)<br>
The asset to bound the new FName to.

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>
An equivalent FName bound to a different asset.

### **DefineDummy(INameMap, FString, Int32)**

Creates a new dummy FName.
 This can be used for cases where a valid FName must be produced without referencing a specific asset's name map.



USE WITH CAUTION! UAssetAPI must never attempt to serialize a dummy FName to disk.

```csharp
public static FName DefineDummy(INameMap asset, FString val, int number)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>
The asset that this FName is bound to.

`val` [FString](./uassetapi.unrealtypes.fstring.md)<br>
The FString that the FName's value will be, verbatim.

`number` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The instance number of the new FName.

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>
A dummy FName instance that represents the string.

### **DefineDummy(INameMap, String, Int32)**

Creates a new dummy FName.
 This can be used for cases where a valid FName must be produced without referencing a specific asset's name map.



USE WITH CAUTION! UAssetAPI must never attempt to serialize a dummy FName to disk.

```csharp
public static FName DefineDummy(INameMap asset, string val, int number)
```

#### Parameters

`asset` [INameMap](./uassetapi.inamemap.md)<br>
The asset that this FName is bound to.

`val` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The string literal that the FName's value will be, verbatim.

`number` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The instance number of the new FName.

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>
A dummy FName instance that represents the string.

### **Equals(Object)**

```csharp
public bool Equals(object obj)
```

#### Parameters

`obj` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **GetHashCode()**

```csharp
public int GetHashCode()
```

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
public object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.unrealtypes.fniagaradatainterfacegeneratedfunction.md`:

```md
# FNiagaraDataInterfaceGeneratedFunction

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FNiagaraDataInterfaceGeneratedFunction
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FNiagaraDataInterfaceGeneratedFunction](./uassetapi.unrealtypes.fniagaradatainterfacegeneratedfunction.md)

## Fields

### **DefinitionName**

```csharp
public FName DefinitionName;
```

### **InstanceName**

```csharp
public FString InstanceName;
```

### **Specifiers**

```csharp
public ValueTuple`2[] Specifiers;
```

### **VariadicInputs**

```csharp
public FNiagaraVariableCommonReference[] VariadicInputs;
```

### **VariadicOutputs**

```csharp
public FNiagaraVariableCommonReference[] VariadicOutputs;
```

### **MiscUsageBitMask**

```csharp
public ushort MiscUsageBitMask;
```

## Constructors

### **FNiagaraDataInterfaceGeneratedFunction()**

```csharp
public FNiagaraDataInterfaceGeneratedFunction()
```

### **FNiagaraDataInterfaceGeneratedFunction(AssetBinaryReader)**

```csharp
public FNiagaraDataInterfaceGeneratedFunction(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fniagaradatainterfacegpuparaminfo.md`:

```md
# FNiagaraDataInterfaceGPUParamInfo

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FNiagaraDataInterfaceGPUParamInfo : UAssetAPI.PropertyTypes.Objects.IStruct`1[[UAssetAPI.UnrealTypes.FNiagaraDataInterfaceGPUParamInfo]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FNiagaraDataInterfaceGPUParamInfo](./uassetapi.unrealtypes.fniagaradatainterfacegpuparaminfo.md)<br>
Implements [IStruct&lt;FNiagaraDataInterfaceGPUParamInfo&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **DataInterfaceHLSLSymbol**

```csharp
public FString DataInterfaceHLSLSymbol;
```

### **DIClassName**

```csharp
public FString DIClassName;
```

### **GeneratedFunctions**

```csharp
public FNiagaraDataInterfaceGeneratedFunction[] GeneratedFunctions;
```

## Constructors

### **FNiagaraDataInterfaceGPUParamInfo()**

```csharp
public FNiagaraDataInterfaceGPUParamInfo()
```

### **FNiagaraDataInterfaceGPUParamInfo(AssetBinaryReader)**

```csharp
public FNiagaraDataInterfaceGPUParamInfo(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
public static FNiagaraDataInterfaceGPUParamInfo Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FNiagaraDataInterfaceGPUParamInfo](./uassetapi.unrealtypes.fniagaradatainterfacegpuparaminfo.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public static FNiagaraDataInterfaceGPUParamInfo FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FNiagaraDataInterfaceGPUParamInfo](./uassetapi.unrealtypes.fniagaradatainterfacegpuparaminfo.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fniagaravariablecommonreference.md`:

```md
# FNiagaraVariableCommonReference

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FNiagaraVariableCommonReference
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FNiagaraVariableCommonReference](./uassetapi.unrealtypes.fniagaravariablecommonreference.md)

## Fields

### **Name**

```csharp
public FName Name;
```

### **Type**

```csharp
public FPackageIndex Type;
```

## Constructors

### **FNiagaraVariableCommonReference(AssetBinaryReader)**

```csharp
FNiagaraVariableCommonReference(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fobjectdataresource.md`:

```md
# FObjectDataResource

Namespace: UAssetAPI.UnrealTypes

UObject binary/bulk data resource type.

```csharp
public struct FObjectDataResource
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FObjectDataResource](./uassetapi.unrealtypes.fobjectdataresource.md)

## Fields

### **Flags**

```csharp
public EObjectDataResourceFlags Flags;
```

### **CookedIndex**

```csharp
public byte CookedIndex;
```

### **SerialOffset**

```csharp
public long SerialOffset;
```

### **DuplicateSerialOffset**

```csharp
public long DuplicateSerialOffset;
```

### **SerialSize**

```csharp
public long SerialSize;
```

### **RawSize**

```csharp
public long RawSize;
```

### **OuterIndex**

```csharp
public FPackageIndex OuterIndex;
```

### **LegacyBulkDataFlags**

```csharp
public uint LegacyBulkDataFlags;
```

## Constructors

### **FObjectDataResource(EObjectDataResourceFlags, Int64, Int64, Int64, Int64, FPackageIndex, UInt32, Byte)**

```csharp
FObjectDataResource(EObjectDataResourceFlags Flags, long SerialOffset, long DuplicateSerialOffset, long SerialSize, long RawSize, FPackageIndex OuterIndex, uint LegacyBulkDataFlags, byte CookedIndex)
```

#### Parameters

`Flags` [EObjectDataResourceFlags](./uassetapi.unrealtypes.eobjectdataresourceflags.md)<br>

`SerialOffset` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`DuplicateSerialOffset` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`SerialSize` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`RawSize` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`OuterIndex` [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>

`LegacyBulkDataFlags` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

`CookedIndex` [Byte](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

```

`docs/src/api/uassetapi.unrealtypes.fobjectthumbnail.md`:

```md
# FObjectThumbnail

Namespace: UAssetAPI.UnrealTypes

Unreal Object Thumbnail - Thumbnail image data for an object.

```csharp
public class FObjectThumbnail
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FObjectThumbnail](./uassetapi.unrealtypes.fobjectthumbnail.md)

## Fields

### **Width**

Thumbnail width

```csharp
public int Width;
```

### **Height**

Thumbnail height

```csharp
public int Height;
```

### **CompressedImageData**

Compressed image data bytes

```csharp
public Byte[] CompressedImageData;
```

### **ImageData**

Image data bytes

```csharp
public Byte[] ImageData;
```

## Constructors

### **FObjectThumbnail()**

```csharp
public FObjectThumbnail()
```

```

`docs/src/api/uassetapi.unrealtypes.fpackageindex.md`:

```md
# FPackageIndex

Namespace: UAssetAPI.UnrealTypes

Wrapper for index into an ImportMap or ExportMap.
 
 Values greater than zero indicate that this is an index into the ExportMap.
 The actual array index will be (FPackageIndex - 1).
 
 Values less than zero indicate that this is an index into the ImportMap.
 The actual array index will be (-FPackageIndex - 1)

```csharp
public class FPackageIndex
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)

## Fields

### **Index**

Values greater than zero indicate that this is an index into the ExportMap.
 The actual array index will be (FPackageIndex - 1).
 
 Values less than zero indicate that this is an index into the ImportMap.
 The actual array index will be (-FPackageIndex - 1)

```csharp
public int Index;
```

## Constructors

### **FPackageIndex(Int32)**

```csharp
public FPackageIndex(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FPackageIndex(AssetBinaryReader)**

```csharp
public FPackageIndex(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **FromRawIndex(Int32)**

Returns an FPackageIndex based off of the index provided. Equivalent to [FPackageIndex.FPackageIndex(Int32)](./uassetapi.unrealtypes.fpackageindex.md#fpackageindexint32).

```csharp
public static FPackageIndex FromRawIndex(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index to create a new FPackageIndex with.

#### Returns

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>
A new FPackageIndex with the index provided.

### **IsImport()**

Returns true if this is an index into the import map.

```csharp
public bool IsImport()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
true if this is an index into the import map, false otherwise

### **IsExport()**

Returns true if this is an index into the export map.

```csharp
public bool IsExport()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
true if this is an index into the export map, false otherwise

### **IsNull()**

Return true if this represents null (i.e. neither an import nor an export)

```csharp
public bool IsNull()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
true if this index represents null, false otherwise

### **FromImport(Int32)**

Creates a FPackageIndex from an index in the import map.

```csharp
public static FPackageIndex FromImport(int importIndex)
```

#### Parameters

`importIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
An import index to create an FPackageIndex from.

#### Returns

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>
An FPackageIndex created from the import index.

#### Exceptions

[InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)<br>
Thrown when the provided import index is less than zero.

### **FromExport(Int32)**

Creates a FPackageIndex from an index in the export map.

```csharp
public static FPackageIndex FromExport(int exportIndex)
```

#### Parameters

`exportIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
An export index to create an FPackageIndex from.

#### Returns

[FPackageIndex](./uassetapi.unrealtypes.fpackageindex.md)<br>
An FPackageIndex created from the export index.

#### Exceptions

[InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)<br>
Thrown when the provided export index is less than zero.

### **ToImport(UAsset)**

Check that this is an import index and return the corresponding import.

```csharp
public Import ToImport(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>
The asset that this index is used in.

#### Returns

[Import](./uassetapi.import.md)<br>
The import that this index represents in the import map.

#### Exceptions

[InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)<br>
Thrown when this is not an index into the import map.

### **ToExport(UAsset)**

Check that this is an export index and return the corresponding export.

```csharp
public Export ToExport(UAsset asset)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>
The asset that this index is used in.

#### Returns

[Export](./uassetapi.exporttypes.export.md)<br>
The export that this index represents in the the export map.

#### Exceptions

[InvalidOperationException](https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)<br>
Thrown when this is not an index into the export map.

### **ToExport&lt;T&gt;(UAsset)**

```csharp
public T ToExport<T>(UAsset asset)
```

#### Type Parameters

`T`<br>

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

T<br>

### **Equals(Object)**

```csharp
public bool Equals(object obj)
```

#### Parameters

`obj` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **GetHashCode()**

```csharp
public int GetHashCode()
```

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unrealtypes.fplane.md`:

```md
# FPlane

Namespace: UAssetAPI.UnrealTypes

Structure for three dimensional planes.
 Stores the coeffecients as Xx+Yy+Zz=W.
 This is different from many other Plane classes that use Xx+Yy+Zz+W=0.

```csharp
public struct FPlane
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FPlane](./uassetapi.unrealtypes.fplane.md)<br>
Implements [IStruct&lt;FPlane&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Properties

### **X**

The plane's X-component.

```csharp
public double X { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **XFloat**

```csharp
public float XFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Y**

The plane's Y-component.

```csharp
public double Y { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **YFloat**

```csharp
public float YFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Z**

The plane's Z-component.

```csharp
public double Z { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **ZFloat**

```csharp
public float ZFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **W**

The plane's W-component.

```csharp
public double W { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **WFloat**

```csharp
public float WFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

## Constructors

### **FPlane(Double, Double, Double, Double)**

```csharp
FPlane(double x, double y, double z, double w)
```

#### Parameters

`x` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`y` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`z` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`w` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **FPlane(Single, Single, Single, Single)**

```csharp
FPlane(float x, float y, float z, float w)
```

#### Parameters

`x` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`y` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`z` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`w` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FPlane(AssetBinaryReader)**

```csharp
FPlane(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Read(AssetBinaryReader)**

```csharp
FPlane Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FPlane](./uassetapi.unrealtypes.fplane.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FPlane FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FPlane](./uassetapi.unrealtypes.fplane.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fpropertytypename.md`:

```md
# FPropertyTypeName

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FPropertyTypeName
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FPropertyTypeName](./uassetapi.unrealtypes.fpropertytypename.md)

## Fields

### **Nodes**

```csharp
public List<FPropertyTypeNameNode> Nodes;
```

### **ShouldSerializeNodes**

```csharp
public bool ShouldSerializeNodes;
```

## Constructors

### **FPropertyTypeName(List&lt;FPropertyTypeNameNode&gt;, Boolean)**

```csharp
public FPropertyTypeName(List<FPropertyTypeNameNode> list, bool shouldSerialize)
```

#### Parameters

`list` [List&lt;FPropertyTypeNameNode&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

`shouldSerialize` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **FPropertyTypeName(AssetBinaryReader)**

```csharp
public FPropertyTypeName(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

### **GetName()**

```csharp
public FName GetName()
```

#### Returns

[FName](./uassetapi.unrealtypes.fname.md)<br>

### **GetParameter(Int32)**

```csharp
public FPropertyTypeName GetParameter(int paramIndex)
```

#### Parameters

`paramIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[FPropertyTypeName](./uassetapi.unrealtypes.fpropertytypename.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fpropertytypenameconverter.md`:

```md
# FPropertyTypeNameConverter

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FPropertyTypeNameConverter : Newtonsoft.Json.JsonConverter`1[[UAssetAPI.UnrealTypes.FPropertyTypeName]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → JsonConverter&lt;FPropertyTypeName&gt; → [FPropertyTypeNameConverter](./uassetapi.unrealtypes.fpropertytypenameconverter.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **FPropertyTypeNameConverter()**

```csharp
public FPropertyTypeNameConverter()
```

## Methods

### **WriteJson(JsonWriter, FPropertyTypeName, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, FPropertyTypeName value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [FPropertyTypeName](./uassetapi.unrealtypes.fpropertytypename.md)<br>

`serializer` JsonSerializer<br>

### **ReadJson(JsonReader, Type, FPropertyTypeName, Boolean, JsonSerializer)**

```csharp
public FPropertyTypeName ReadJson(JsonReader reader, Type objectType, FPropertyTypeName existingValue, bool hasExistingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [FPropertyTypeName](./uassetapi.unrealtypes.fpropertytypename.md)<br>

`hasExistingValue` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializer` JsonSerializer<br>

#### Returns

[FPropertyTypeName](./uassetapi.unrealtypes.fpropertytypename.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fpropertytypenamenode.md`:

```md
# FPropertyTypeNameNode

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FPropertyTypeNameNode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FPropertyTypeNameNode](./uassetapi.unrealtypes.fpropertytypenamenode.md)

## Fields

### **Name**

```csharp
public FName Name;
```

### **InnerCount**

```csharp
public int InnerCount;
```

## Constructors

### **FPropertyTypeNameNode(AssetBinaryReader)**

```csharp
FPropertyTypeNameNode(AssetBinaryReader Ar)
```

#### Parameters

`Ar` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fqualifiedframetime.md`:

```md
# FQualifiedFrameTime

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FQualifiedFrameTime
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FQualifiedFrameTime](./uassetapi.unrealtypes.fqualifiedframetime.md)

## Fields

### **Time**

```csharp
public FFrameTime Time;
```

### **Rate**

```csharp
public FFrameRate Rate;
```

## Constructors

### **FQualifiedFrameTime()**

```csharp
FQualifiedFrameTime()
```

### **FQualifiedFrameTime(FFrameTime, FFrameRate)**

```csharp
FQualifiedFrameTime(FFrameTime time, FFrameRate rate)
```

#### Parameters

`time` [FFrameTime](./uassetapi.unrealtypes.fframetime.md)<br>

`rate` [FFrameRate](./uassetapi.unrealtypes.fframerate.md)<br>

### **FQualifiedFrameTime(AssetBinaryReader)**

```csharp
FQualifiedFrameTime(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fquat.md`:

```md
# FQuat

Namespace: UAssetAPI.UnrealTypes

Floating point quaternion that can represent a rotation about an axis in 3-D space.
 The X, Y, Z, W components also double as the Axis/Angle format.

```csharp
public struct FQuat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FQuat](./uassetapi.unrealtypes.fquat.md)<br>
Implements [IStruct&lt;FQuat&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Properties

### **X**

The quaternion's X-component.

```csharp
public double X { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **XFloat**

```csharp
public float XFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Y**

The quaternion's Y-component.

```csharp
public double Y { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **YFloat**

```csharp
public float YFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Z**

The quaternion's Z-component.

```csharp
public double Z { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **ZFloat**

```csharp
public float ZFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **W**

The quaternion's W-component.

```csharp
public double W { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **WFloat**

```csharp
public float WFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

## Constructors

### **FQuat(Double, Double, Double, Double)**

```csharp
FQuat(double x, double y, double z, double w)
```

#### Parameters

`x` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`y` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`z` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`w` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **FQuat(Single, Single, Single, Single)**

```csharp
FQuat(float x, float y, float z, float w)
```

#### Parameters

`x` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`y` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`z` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`w` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FQuat(AssetBinaryReader)**

```csharp
FQuat(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Read(AssetBinaryReader)**

```csharp
FQuat Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FQuat](./uassetapi.unrealtypes.fquat.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FQuat FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FQuat](./uassetapi.unrealtypes.fquat.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.frichcurvekey.md`:

```md
# FRichCurveKey

Namespace: UAssetAPI.UnrealTypes

One key in a rich, editable float curve

```csharp
public struct FRichCurveKey
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FRichCurveKey](./uassetapi.unrealtypes.frichcurvekey.md)<br>
Implements [IStruct&lt;FRichCurveKey&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **InterpMode**

```csharp
public ERichCurveInterpMode InterpMode;
```

### **TangentMode**

```csharp
public ERichCurveTangentMode TangentMode;
```

### **TangentWeightMode**

```csharp
public ERichCurveTangentWeightMode TangentWeightMode;
```

### **Time**

```csharp
public float Time;
```

### **Value**

```csharp
public float Value;
```

### **ArriveTangent**

```csharp
public float ArriveTangent;
```

### **ArriveTangentWeight**

```csharp
public float ArriveTangentWeight;
```

### **LeaveTangent**

```csharp
public float LeaveTangent;
```

### **LeaveTangentWeight**

```csharp
public float LeaveTangentWeight;
```

## Constructors

### **FRichCurveKey()**

```csharp
FRichCurveKey()
```

### **FRichCurveKey(ERichCurveInterpMode, ERichCurveTangentMode, ERichCurveTangentWeightMode, Single, Single, Single, Single, Single, Single)**

```csharp
FRichCurveKey(ERichCurveInterpMode interpMode, ERichCurveTangentMode tangentMode, ERichCurveTangentWeightMode tangentWeightMode, float time, float value, float arriveTangent, float arriveTangentWeight, float leaveTangent, float leaveTangentWeight)
```

#### Parameters

`interpMode` [ERichCurveInterpMode](./uassetapi.unrealtypes.engineenums.erichcurveinterpmode.md)<br>

`tangentMode` [ERichCurveTangentMode](./uassetapi.unrealtypes.engineenums.erichcurvetangentmode.md)<br>

`tangentWeightMode` [ERichCurveTangentWeightMode](./uassetapi.unrealtypes.engineenums.erichcurvetangentweightmode.md)<br>

`time` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`value` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`arriveTangent` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`arriveTangentWeight` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`leaveTangent` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`leaveTangentWeight` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FRichCurveKey(AssetBinaryReader)**

```csharp
FRichCurveKey(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Read(AssetBinaryReader)**

```csharp
FRichCurveKey Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FRichCurveKey](./uassetapi.unrealtypes.frichcurvekey.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FRichCurveKey FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FRichCurveKey](./uassetapi.unrealtypes.frichcurvekey.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.frotator.md`:

```md
# FRotator

Namespace: UAssetAPI.UnrealTypes

Implements a container for rotation information.
 All rotation values are stored in degrees.

```csharp
public struct FRotator
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FRotator](./uassetapi.unrealtypes.frotator.md)<br>
Implements [IStruct&lt;FRotator&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Properties

### **Pitch**

Rotation around the right axis (around Y axis), Looking up and down (0=Straight Ahead, +Up, -Down)

```csharp
public double Pitch { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **PitchFloat**

```csharp
public float PitchFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Yaw**

Rotation around the up axis (around Z axis), Running in circles 0=East, +North, -South.

```csharp
public double Yaw { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **YawFloat**

```csharp
public float YawFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Roll**

Rotation around the forward axis (around X axis), Tilting your head, 0=Straight, +Clockwise, -CCW.

```csharp
public double Roll { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **RollFloat**

```csharp
public float RollFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

## Constructors

### **FRotator(Double, Double, Double)**

```csharp
FRotator(double pitch, double yaw, double roll)
```

#### Parameters

`pitch` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`yaw` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`roll` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **FRotator(Single, Single, Single)**

```csharp
FRotator(float pitch, float yaw, float roll)
```

#### Parameters

`pitch` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`yaw` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`roll` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FRotator(AssetBinaryReader)**

```csharp
FRotator(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Read(AssetBinaryReader)**

```csharp
FRotator Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FRotator](./uassetapi.unrealtypes.frotator.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FRotator FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FRotator](./uassetapi.unrealtypes.frotator.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fskeletalmeshareaweightedtrianglesampler.md`:

```md
# FSkeletalMeshAreaWeightedTriangleSampler

Namespace: UAssetAPI.UnrealTypes

Allows area weighted sampling of triangles on a skeletal mesh.

```csharp
public class FSkeletalMeshAreaWeightedTriangleSampler : FWeightedRandomSampler, System.ICloneable, UAssetAPI.PropertyTypes.Objects.IStruct`1[[UAssetAPI.UnrealTypes.FWeightedRandomSampler]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FWeightedRandomSampler](./uassetapi.unrealtypes.fweightedrandomsampler.md) → [FSkeletalMeshAreaWeightedTriangleSampler](./uassetapi.unrealtypes.fskeletalmeshareaweightedtrianglesampler.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FWeightedRandomSampler&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **Prob**

```csharp
public Single[] Prob;
```

### **Alias**

```csharp
public Int32[] Alias;
```

### **TotalWeight**

```csharp
public float TotalWeight;
```

## Constructors

### **FSkeletalMeshAreaWeightedTriangleSampler(AssetBinaryReader)**

```csharp
public FSkeletalMeshAreaWeightedTriangleSampler(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **FSkeletalMeshAreaWeightedTriangleSampler()**

```csharp
public FSkeletalMeshAreaWeightedTriangleSampler()
```

```

`docs/src/api/uassetapi.unrealtypes.fskeletalmeshsamplingregionbuiltdata.md`:

```md
# FSkeletalMeshSamplingRegionBuiltData

Namespace: UAssetAPI.UnrealTypes

Built data for sampling a single region of a skeletal mesh

```csharp
public class FSkeletalMeshSamplingRegionBuiltData : UAssetAPI.PropertyTypes.Objects.IStruct`1[[UAssetAPI.UnrealTypes.FSkeletalMeshSamplingRegionBuiltData]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FSkeletalMeshSamplingRegionBuiltData](./uassetapi.unrealtypes.fskeletalmeshsamplingregionbuiltdata.md)<br>
Implements [IStruct&lt;FSkeletalMeshSamplingRegionBuiltData&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **TriangleIndices**

```csharp
public Int32[] TriangleIndices;
```

### **Vertices**

```csharp
public Int32[] Vertices;
```

### **BoneIndices**

```csharp
public Int32[] BoneIndices;
```

## Constructors

### **FSkeletalMeshSamplingRegionBuiltData()**

```csharp
public FSkeletalMeshSamplingRegionBuiltData()
```

### **FSkeletalMeshSamplingRegionBuiltData(AssetBinaryReader)**

```csharp
public FSkeletalMeshSamplingRegionBuiltData(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
public static FSkeletalMeshSamplingRegionBuiltData Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FSkeletalMeshSamplingRegionBuiltData](./uassetapi.unrealtypes.fskeletalmeshsamplingregionbuiltdata.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FromString(String[], UAsset)**

```csharp
public static FSkeletalMeshSamplingRegionBuiltData FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FSkeletalMeshSamplingRegionBuiltData](./uassetapi.unrealtypes.fskeletalmeshsamplingregionbuiltdata.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fstring.md`:

```md
# FString

Namespace: UAssetAPI.UnrealTypes

Unreal string - consists of a string and an encoding

```csharp
public class FString : System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FString](./uassetapi.unrealtypes.fstring.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Value**

```csharp
public string Value;
```

### **Encoding**

```csharp
public Encoding Encoding;
```

### **IsCasePreserving**

Is this FString case preserving?

```csharp
public bool IsCasePreserving;
```

### **NullCase**

```csharp
public static string NullCase;
```

## Constructors

### **FString(String, Encoding)**

```csharp
public FString(string value, Encoding encoding)
```

#### Parameters

`value` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`encoding` [Encoding](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding)<br>

### **FString()**

```csharp
public FString()
```

## Methods

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Equals(Object)**

```csharp
public bool Equals(object obj)
```

#### Parameters

`obj` [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **GetHashCode()**

```csharp
public int GetHashCode()
```

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
public object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **FromString(String, Encoding)**

```csharp
public static FString FromString(string value, Encoding encoding)
```

#### Parameters

`value` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`encoding` [Encoding](https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding)<br>

#### Returns

[FString](./uassetapi.unrealtypes.fstring.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.ftextsourcedata.md`:

```md
# FTextSourceData

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FTextSourceData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FTextSourceData](./uassetapi.unrealtypes.ftextsourcedata.md)

## Properties

### **SourceString**

```csharp
public FString SourceString { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **SourceStringMetaData**

```csharp
public FLocMetadataObject SourceStringMetaData { get; set; }
```

#### Property Value

[FLocMetadataObject](./uassetapi.unrealtypes.flocmetadataobject.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.ftextsourcesitecontext.md`:

```md
# FTextSourceSiteContext

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FTextSourceSiteContext
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FTextSourceSiteContext](./uassetapi.unrealtypes.ftextsourcesitecontext.md)

## Properties

### **KeyName**

```csharp
public FString KeyName { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **SiteDescription**

```csharp
public FString SiteDescription { get; set; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **IsEditorOnly**

```csharp
public bool IsEditorOnly { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **IsOptional**

```csharp
public bool IsOptional { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **InfoMetaData**

```csharp
public FLocMetadataObject InfoMetaData { get; set; }
```

#### Property Value

[FLocMetadataObject](./uassetapi.unrealtypes.flocmetadataobject.md)<br>

### **KeyMetaData**

```csharp
public FLocMetadataObject KeyMetaData { get; set; }
```

#### Property Value

[FLocMetadataObject](./uassetapi.unrealtypes.flocmetadataobject.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.ftimecode.md`:

```md
# FTimecode

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FTimecode
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FTimecode](./uassetapi.unrealtypes.ftimecode.md)

## Fields

### **Hours**

```csharp
public int Hours;
```

### **Minutes**

```csharp
public int Minutes;
```

### **Seconds**

```csharp
public int Seconds;
```

### **Frames**

```csharp
public int Frames;
```

### **bDropFrameFormat**

```csharp
public bool bDropFrameFormat;
```

## Constructors

### **FTimecode()**

```csharp
FTimecode()
```

### **FTimecode(Int32, Int32, Int32, Int32, Boolean)**

```csharp
FTimecode(int hours, int minutes, int seconds, int frames, bool bDropFrameFormat)
```

#### Parameters

`hours` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`minutes` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`seconds` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`frames` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`bDropFrameFormat` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **FTimecode(AssetBinaryReader)**

```csharp
FTimecode(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.ftransform.md`:

```md
# FTransform

Namespace: UAssetAPI.UnrealTypes

Transform composed of Scale, Rotation (as a quaternion), and Translation.
 Transforms can be used to convert from one space to another, for example by transforming
 positions and directions from local space to world space.
 
 Transformation of position vectors is applied in the order: Scale -&gt; Rotate -&gt; Translate.
 Transformation of direction vectors is applied in the order: Scale -&gt; Rotate.
 
 Order matters when composing transforms: C = A * B will yield a transform C that logically
 first applies A then B to any subsequent transformation. Note that this is the opposite order of quaternion (FQuat) multiplication.
 
 Example: LocalToWorld = (DeltaRotation * LocalToWorld) will change rotation in local space by DeltaRotation.
 Example: LocalToWorld = (LocalToWorld * DeltaRotation) will change rotation in world space by DeltaRotation.

```csharp
public struct FTransform
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FTransform](./uassetapi.unrealtypes.ftransform.md)

## Fields

### **Rotation**

Rotation of this transformation, as a quaternion

```csharp
public FQuat Rotation;
```

### **Translation**

Translation of this transformation, as a vector.

```csharp
public FVector Translation;
```

### **Scale3D**

3D scale (always applied in local space) as a vector.

```csharp
public FVector Scale3D;
```

## Constructors

### **FTransform(FQuat, FVector, FVector)**

```csharp
FTransform(FQuat rotation, FVector translation, FVector scale3D)
```

#### Parameters

`rotation` [FQuat](./uassetapi.unrealtypes.fquat.md)<br>

`translation` [FVector](./uassetapi.unrealtypes.fvector.md)<br>

`scale3D` [FVector](./uassetapi.unrealtypes.fvector.md)<br>

### **FTransform(AssetBinaryReader)**

```csharp
FTransform(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unrealtypes.ftwovectors.md`:

```md
# FTwoVectors

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct FTwoVectors
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FTwoVectors](./uassetapi.unrealtypes.ftwovectors.md)<br>
Implements [IStruct&lt;FTwoVectors&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **V1**

```csharp
public FVector V1;
```

### **V2**

```csharp
public FVector V2;
```

## Constructors

### **FTwoVectors(FVector, FVector)**

```csharp
FTwoVectors(FVector v1, FVector v2)
```

#### Parameters

`v1` [FVector](./uassetapi.unrealtypes.fvector.md)<br>

`v2` [FVector](./uassetapi.unrealtypes.fvector.md)<br>

### **FTwoVectors(AssetBinaryReader)**

```csharp
FTwoVectors(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Read(AssetBinaryReader)**

```csharp
FTwoVectors Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FTwoVectors](./uassetapi.unrealtypes.ftwovectors.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FTwoVectors FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FTwoVectors](./uassetapi.unrealtypes.ftwovectors.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.funiquenetid.md`:

```md
# FUniqueNetId

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FUniqueNetId
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FUniqueNetId](./uassetapi.unrealtypes.funiquenetid.md)

## Fields

### **Type**

```csharp
public FName Type;
```

### **Contents**

```csharp
public FString Contents;
```

## Constructors

### **FUniqueNetId(FName, FString)**

```csharp
public FUniqueNetId(FName type, FString contents)
```

#### Parameters

`type` [FName](./uassetapi.unrealtypes.fname.md)<br>

`contents` [FString](./uassetapi.unrealtypes.fstring.md)<br>

### **FUniqueNetId(AssetBinaryReader)**

```csharp
public FUniqueNetId(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unrealtypes.fvector.md`:

```md
# FVector

Namespace: UAssetAPI.UnrealTypes

A vector in 3-D space composed of components (X, Y, Z) with floating/double point precision.

```csharp
public struct FVector
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FVector](./uassetapi.unrealtypes.fvector.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FVector&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Properties

### **X**

The vector's X-component.

```csharp
public double X { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **XFloat**

```csharp
public float XFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Y**

The vector's Y-component.

```csharp
public double Y { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **YFloat**

```csharp
public float YFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Z**

The vector's Z-component.

```csharp
public double Z { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **ZFloat**

```csharp
public float ZFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

## Constructors

### **FVector(Double, Double, Double)**

```csharp
FVector(double x, double y, double z)
```

#### Parameters

`x` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`y` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`z` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **FVector(Single, Single, Single)**

```csharp
FVector(float x, float y, float z)
```

#### Parameters

`x` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`y` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`z` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FVector(AssetBinaryReader)**

```csharp
FVector(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FVector Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FVector](./uassetapi.unrealtypes.fvector.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **FromString(String[], UAsset)**

```csharp
FVector FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FVector](./uassetapi.unrealtypes.fvector.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unrealtypes.fvector2d.md`:

```md
# FVector2D

Namespace: UAssetAPI.UnrealTypes

A vector in 2-D space composed of components (X, Y) with floating/double point precision.

```csharp
public struct FVector2D
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FVector2D](./uassetapi.unrealtypes.fvector2d.md)<br>
Implements [IStruct&lt;FVector2D&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Properties

### **X**

The vector's X-component.

```csharp
public double X { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **XFloat**

```csharp
public float XFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Y**

The vector's Y-component.

```csharp
public double Y { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **YFloat**

```csharp
public float YFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

## Constructors

### **FVector2D(Double, Double)**

```csharp
FVector2D(double x, double y)
```

#### Parameters

`x` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`y` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **FVector2D(Single, Single, Single)**

```csharp
FVector2D(float x, float y, float z)
```

#### Parameters

`x` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`y` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`z` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FVector2D(AssetBinaryReader)**

```csharp
FVector2D(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Read(AssetBinaryReader)**

```csharp
FVector2D Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FVector2D](./uassetapi.unrealtypes.fvector2d.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FVector2D FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FVector2D](./uassetapi.unrealtypes.fvector2d.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fvector2f.md`:

```md
# FVector2f

Namespace: UAssetAPI.UnrealTypes

A vector in 2-D space composed of components (X, Y) with floating point precision.

```csharp
public struct FVector2f
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FVector2f](./uassetapi.unrealtypes.fvector2f.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FVector2f&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **X**

```csharp
public float X;
```

### **Y**

```csharp
public float Y;
```

## Constructors

### **FVector2f(Single, Single)**

```csharp
FVector2f(float x, float y)
```

#### Parameters

`x` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`y` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FVector2f(AssetBinaryReader)**

```csharp
FVector2f(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Read(AssetBinaryReader)**

```csharp
FVector2f Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FVector2f](./uassetapi.unrealtypes.fvector2f.md)<br>

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FVector2f FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FVector2f](./uassetapi.unrealtypes.fvector2f.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fvector3f.md`:

```md
# FVector3f

Namespace: UAssetAPI.UnrealTypes

A vector in 3-D space composed of components (X, Y, Z) with floating point precision.

```csharp
public struct FVector3f
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FVector3f](./uassetapi.unrealtypes.fvector3f.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FVector3f&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **X**

```csharp
public float X;
```

### **Y**

```csharp
public float Y;
```

### **Z**

```csharp
public float Z;
```

## Constructors

### **FVector3f(Single, Single, Single)**

```csharp
FVector3f(float x, float y, float z)
```

#### Parameters

`x` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`y` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`z` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FVector3f(AssetBinaryReader)**

```csharp
FVector3f(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Read(AssetBinaryReader)**

```csharp
FVector3f Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FVector3f](./uassetapi.unrealtypes.fvector3f.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FVector3f FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FVector3f](./uassetapi.unrealtypes.fvector3f.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fvector4.md`:

```md
# FVector4

Namespace: UAssetAPI.UnrealTypes

A vector in 4-D space composed of components (X, Y, Z, W) with floating/double point precision.

```csharp
public struct FVector4
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FVector4](./uassetapi.unrealtypes.fvector4.md)<br>
Implements [IStruct&lt;FVector4&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Properties

### **X**

The vector's X-component.

```csharp
public double X { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **XFloat**

```csharp
public float XFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Y**

The vector's Y-component.

```csharp
public double Y { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **YFloat**

```csharp
public float YFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **Z**

The vector's Z-component.

```csharp
public double Z { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **ZFloat**

```csharp
public float ZFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **W**

The vector's W-component.

```csharp
public double W { get; set; }
```

#### Property Value

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **WFloat**

```csharp
public float WFloat { get; }
```

#### Property Value

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

## Constructors

### **FVector4(Double, Double, Double, Double)**

```csharp
FVector4(double x, double y, double z, double w)
```

#### Parameters

`x` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`y` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`z` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

`w` [Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **FVector4(Single, Single, Single, Single)**

```csharp
FVector4(float x, float y, float z, float w)
```

#### Parameters

`x` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`y` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`z` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`w` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FVector4(AssetBinaryReader)**

```csharp
FVector4(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Read(AssetBinaryReader)**

```csharp
FVector4 Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FVector4](./uassetapi.unrealtypes.fvector4.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FVector4 FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FVector4](./uassetapi.unrealtypes.fvector4.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fvector4f.md`:

```md
# FVector4f

Namespace: UAssetAPI.UnrealTypes

A vector in 4-D space composed of components (X, Y, Z, W) with floating point precision.

```csharp
public struct FVector4f
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [FVector4f](./uassetapi.unrealtypes.fvector4f.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FVector4f&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **X**

```csharp
public float X;
```

### **Y**

```csharp
public float Y;
```

### **Z**

```csharp
public float Z;
```

### **W**

```csharp
public float W;
```

## Constructors

### **FVector4f(Single, Single, Single, Single)**

```csharp
FVector4f(float x, float y, float z, float w)
```

#### Parameters

`x` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`y` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`z` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`w` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FVector4f(AssetBinaryReader)**

```csharp
FVector4f(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Read(AssetBinaryReader)**

```csharp
FVector4f Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FVector4f](./uassetapi.unrealtypes.fvector4f.md)<br>

### **ToString()**

```csharp
string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
FVector4f FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FVector4f](./uassetapi.unrealtypes.fvector4f.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fweightedrandomsampler.md`:

```md
# FWeightedRandomSampler

Namespace: UAssetAPI.UnrealTypes

```csharp
public class FWeightedRandomSampler : System.ICloneable, UAssetAPI.PropertyTypes.Objects.IStruct`1[[UAssetAPI.UnrealTypes.FWeightedRandomSampler]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FWeightedRandomSampler](./uassetapi.unrealtypes.fweightedrandomsampler.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable), [IStruct&lt;FWeightedRandomSampler&gt;](./uassetapi.propertytypes.objects.istruct-1.md)

## Fields

### **Prob**

```csharp
public Single[] Prob;
```

### **Alias**

```csharp
public Int32[] Alias;
```

### **TotalWeight**

```csharp
public float TotalWeight;
```

## Constructors

### **FWeightedRandomSampler()**

```csharp
public FWeightedRandomSampler()
```

### **FWeightedRandomSampler(Single[], Int32[], Single)**

```csharp
public FWeightedRandomSampler(Single[] prob, Int32[] alias, float totalWeight)
```

#### Parameters

`prob` [Single[]](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`alias` [Int32[]](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`totalWeight` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **FWeightedRandomSampler(AssetBinaryReader)**

```csharp
public FWeightedRandomSampler(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

## Methods

### **Write(AssetBinaryWriter)**

```csharp
public int Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
public object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **Read(AssetBinaryReader)**

```csharp
public static FWeightedRandomSampler Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

#### Returns

[FWeightedRandomSampler](./uassetapi.unrealtypes.fweightedrandomsampler.md)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **FromString(String[], UAsset)**

```csharp
public static FWeightedRandomSampler FromString(String[] d, UAsset asset)
```

#### Parameters

`d` [String[]](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[FWeightedRandomSampler](./uassetapi.unrealtypes.fweightedrandomsampler.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fworldtileinfo.md`:

```md
# FWorldTileInfo

Namespace: UAssetAPI.UnrealTypes

Tile information used by WorldComposition.
 Defines properties necessary for tile positioning in the world. Stored with package summary

```csharp
public class FWorldTileInfo
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FWorldTileInfo](./uassetapi.unrealtypes.fworldtileinfo.md)

## Fields

### **Position**

Tile position in the world relative to parent

```csharp
public Int32[] Position;
```

### **AbsolutePosition**

Absolute tile position in the world. Calculated in runtime

```csharp
public Int32[] AbsolutePosition;
```

### **Bounds**

Tile bounding box

```csharp
public BoxPropertyData Bounds;
```

### **Layer**

Tile assigned layer

```csharp
public FWorldTileLayer Layer;
```

### **bHideInTileView**

Whether to hide sub-level tile in tile view

```csharp
public bool bHideInTileView;
```

### **ParentTilePackageName**

Parent tile package name

```csharp
public FString ParentTilePackageName;
```

### **LODList**

LOD information

```csharp
public FWorldTileLODInfo[] LODList;
```

### **ZOrder**

Sorting order

```csharp
public int ZOrder;
```

## Constructors

### **FWorldTileInfo(Int32[], Int32[], BoxPropertyData, FWorldTileLayer, Boolean, FString, FWorldTileLODInfo[], Int32)**

```csharp
public FWorldTileInfo(Int32[] position, Int32[] absolutePosition, BoxPropertyData bounds, FWorldTileLayer layer, bool bHideInTileView, FString parentTilePackageName, FWorldTileLODInfo[] lODList, int zOrder)
```

#### Parameters

`position` [Int32[]](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`absolutePosition` [Int32[]](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`bounds` [BoxPropertyData](./uassetapi.propertytypes.structs.boxpropertydata.md)<br>

`layer` [FWorldTileLayer](./uassetapi.unrealtypes.fworldtilelayer.md)<br>

`bHideInTileView` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`parentTilePackageName` [FString](./uassetapi.unrealtypes.fstring.md)<br>

`lODList` [FWorldTileLODInfo[]](./uassetapi.unrealtypes.fworldtilelodinfo.md)<br>

`zOrder` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FWorldTileInfo()**

```csharp
public FWorldTileInfo()
```

## Methods

### **Read(AssetBinaryReader, UAsset)**

```csharp
public void Read(AssetBinaryReader reader, UAsset asset)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter, UAsset)**

```csharp
public void Write(AssetBinaryWriter writer, UAsset asset)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fworldtilelayer.md`:

```md
# FWorldTileLayer

Namespace: UAssetAPI.UnrealTypes

World layer information for tile tagging

```csharp
public class FWorldTileLayer
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FWorldTileLayer](./uassetapi.unrealtypes.fworldtilelayer.md)

## Fields

### **Name**

Human readable name for this layer

```csharp
public FString Name;
```

### **Reserved0**

Reserved for additional options

```csharp
public int Reserved0;
```

### **Reserved1**

Reserved for additional options

```csharp
public IntPointPropertyData Reserved1;
```

### **StreamingDistance**

Distance starting from where tiles belonging to this layer will be streamed in

```csharp
public int StreamingDistance;
```

### **DistanceStreamingEnabled**

```csharp
public bool DistanceStreamingEnabled;
```

## Constructors

### **FWorldTileLayer(FString, Int32, IntPointPropertyData, Int32, Boolean)**

```csharp
public FWorldTileLayer(FString name, int reserved0, IntPointPropertyData reserved1, int streamingDistance, bool distanceStreamingEnabled)
```

#### Parameters

`name` [FString](./uassetapi.unrealtypes.fstring.md)<br>

`reserved0` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`reserved1` [IntPointPropertyData](./uassetapi.propertytypes.structs.intpointpropertydata.md)<br>

`streamingDistance` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`distanceStreamingEnabled` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **FWorldTileLayer()**

```csharp
public FWorldTileLayer()
```

## Methods

### **Read(AssetBinaryReader, UAsset)**

```csharp
public void Read(AssetBinaryReader reader, UAsset asset)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **ResolveAncestries(UAsset, AncestryInfo)**

```csharp
public void ResolveAncestries(UAsset asset, AncestryInfo ancestrySoFar)
```

#### Parameters

`asset` [UAsset](./uassetapi.uasset.md)<br>

`ancestrySoFar` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>

### **Write(AssetBinaryWriter, UAsset)**

```csharp
public void Write(AssetBinaryWriter writer, UAsset asset)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.fworldtilelodinfo.md`:

```md
# FWorldTileLODInfo

Namespace: UAssetAPI.UnrealTypes

Describes LOD entry in a world tile

```csharp
public class FWorldTileLODInfo
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FWorldTileLODInfo](./uassetapi.unrealtypes.fworldtilelodinfo.md)

## Fields

### **RelativeStreamingDistance**

Relative to LOD0 streaming distance, absolute distance = LOD0 + StreamingDistanceDelta

```csharp
public int RelativeStreamingDistance;
```

### **Reserved0**

Reserved for additional options

```csharp
public float Reserved0;
```

### **Reserved1**

Reserved for additional options

```csharp
public float Reserved1;
```

### **Reserved2**

Reserved for additional options

```csharp
public int Reserved2;
```

### **Reserved3**

Reserved for additional options

```csharp
public int Reserved3;
```

## Constructors

### **FWorldTileLODInfo(Int32, Single, Single, Int32, Int32)**

```csharp
public FWorldTileLODInfo(int relativeStreamingDistance, float reserved0, float reserved1, int reserved2, int reserved3)
```

#### Parameters

`relativeStreamingDistance` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`reserved0` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`reserved1` [Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

`reserved2` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`reserved3` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **FWorldTileLODInfo()**

```csharp
public FWorldTileLODInfo()
```

## Methods

### **Read(AssetBinaryReader, UAsset)**

```csharp
public void Read(AssetBinaryReader reader, UAsset asset)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

### **Write(AssetBinaryWriter, UAsset)**

```csharp
public void Write(AssetBinaryWriter writer, UAsset asset)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

```

`docs/src/api/uassetapi.unrealtypes.iordereddictionary-2.md`:

```md
# IOrderedDictionary&lt;TKey, TValue&gt;

Namespace: UAssetAPI.UnrealTypes

```csharp
public interface IOrderedDictionary<TKey, TValue> : , , , System.Collections.IEnumerable, System.Collections.Specialized.IOrderedDictionary, System.Collections.IDictionary, System.Collections.ICollection
```

#### Type Parameters

`TKey`<br>

`TValue`<br>

Implements IDictionary&lt;TKey, TValue&gt;, ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, [IEnumerable](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable), IOrderedDictionary, [IDictionary](https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary), [ICollection](https://docs.microsoft.com/en-us/dotnet/api/system.collections.icollection)

## Properties

### **Item**

```csharp
public abstract TValue Item { get; set; }
```

#### Property Value

TValue<br>

### **Item**

```csharp
public abstract TValue Item { get; set; }
```

#### Property Value

TValue<br>

### **Count**

```csharp
public abstract int Count { get; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Keys**

```csharp
public abstract ICollection<TKey> Keys { get; }
```

#### Property Value

ICollection&lt;TKey&gt;<br>

### **Values**

```csharp
public abstract ICollection<TValue> Values { get; }
```

#### Property Value

ICollection&lt;TValue&gt;<br>

## Methods

### **Add(TKey, TValue)**

```csharp
void Add(TKey key, TValue value)
```

#### Parameters

`key` TKey<br>

`value` TValue<br>

### **Clear()**

```csharp
void Clear()
```

### **Insert(Int32, TKey, TValue)**

```csharp
void Insert(int index, TKey key, TValue value)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`key` TKey<br>

`value` TValue<br>

### **IndexOf(TKey)**

```csharp
int IndexOf(TKey key)
```

#### Parameters

`key` TKey<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ContainsValue(TValue)**

```csharp
bool ContainsValue(TValue value)
```

#### Parameters

`value` TValue<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **ContainsValue(TValue, IEqualityComparer&lt;TValue&gt;)**

```csharp
bool ContainsValue(TValue value, IEqualityComparer<TValue> comparer)
```

#### Parameters

`value` TValue<br>

`comparer` IEqualityComparer&lt;TValue&gt;<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **ContainsKey(TKey)**

```csharp
bool ContainsKey(TKey key)
```

#### Parameters

`key` TKey<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **GetEnumerator()**

```csharp
IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
```

#### Returns

IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;<br>

### **Remove(TKey)**

```csharp
bool Remove(TKey key)
```

#### Parameters

`key` TKey<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **RemoveAt(Int32)**

```csharp
void RemoveAt(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **TryGetValue(TKey, TValue&)**

```csharp
bool TryGetValue(TKey key, TValue& value)
```

#### Parameters

`key` TKey<br>

`value` TValue&<br>

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **GetValue(TKey)**

```csharp
TValue GetValue(TKey key)
```

#### Parameters

`key` TKey<br>

#### Returns

TValue<br>

### **SetValue(TKey, TValue)**

```csharp
void SetValue(TKey key, TValue value)
```

#### Parameters

`key` TKey<br>

`value` TValue<br>

### **GetItem(Int32)**

```csharp
KeyValuePair<TKey, TValue> GetItem(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

KeyValuePair&lt;TKey, TValue&gt;<br>

### **SetItem(Int32, TValue)**

```csharp
void SetItem(int index, TValue value)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`value` TValue<br>

```

`docs/src/api/uassetapi.unrealtypes.linearhelpers.md`:

```md
# LinearHelpers

Namespace: UAssetAPI.UnrealTypes

```csharp
public static class LinearHelpers
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [LinearHelpers](./uassetapi.unrealtypes.linearhelpers.md)

## Methods

### **Convert(FLinearColor)**

```csharp
public static Color Convert(FLinearColor color)
```

#### Parameters

`color` [FLinearColor](./uassetapi.unrealtypes.flinearcolor.md)<br>

#### Returns

Color<br>

```

`docs/src/api/uassetapi.unrealtypes.objectversion.md`:

```md
# ObjectVersion

Namespace: UAssetAPI.UnrealTypes

An enum used to represent the global object version of UE4.

```csharp
public enum ObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ObjectVersion](./uassetapi.unrealtypes.objectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| VER_UE4_BLUEPRINT_VARS_NOT_READ_ONLY | 215 | Removed restriction on blueprint-exposed variables from being read-only |
| VER_UE4_STATIC_MESH_STORE_NAV_COLLISION | 216 | Added manually serialized element to UStaticMesh (precalculated nav collision) |
| VER_UE4_ATMOSPHERIC_FOG_DECAY_NAME_CHANGE | 217 | Changed property name for atmospheric fog |
| VER_UE4_SCENECOMP_TRANSLATION_TO_LOCATION | 218 | Change many properties/functions from Translation to Location |
| VER_UE4_MATERIAL_ATTRIBUTES_REORDERING | 219 | Material attributes reordering |
| VER_UE4_COLLISION_PROFILE_SETTING | 220 | Collision Profile setting has been added, and all components that exists has to be properly upgraded |
| VER_UE4_BLUEPRINT_SKEL_TEMPORARY_TRANSIENT | 221 | Making the blueprint's skeleton class transient |
| VER_UE4_BLUEPRINT_SKEL_SERIALIZED_AGAIN | 222 | Making the blueprint's skeleton class serialized again |
| VER_UE4_BLUEPRINT_SETS_REPLICATION | 223 | Blueprint now controls replication settings again |
| VER_UE4_WORLD_LEVEL_INFO | 224 | Added level info used by World browser |
| VER_UE4_AFTER_CAPSULE_HALF_HEIGHT_CHANGE | 225 | Changed capsule height to capsule half-height (afterwards) |
| VER_UE4_ADDED_NAMESPACE_AND_KEY_DATA_TO_FTEXT | 226 | Added Namepace, GUID (Key) and Flags to FText |
| VER_UE4_ATTENUATION_SHAPES | 227 | Attenuation shapes |
| VER_UE4_LIGHTCOMPONENT_USE_IES_TEXTURE_MULTIPLIER_ON_NON_IES_BRIGHTNESS | 228 | Use IES texture multiplier even when IES brightness is not being used |
| VER_UE4_REMOVE_INPUT_COMPONENTS_FROM_BLUEPRINTS | 229 | Removed InputComponent as a blueprint addable component |
| VER_UE4_VARK2NODE_USE_MEMBERREFSTRUCT | 230 | Use an FMemberReference struct in UK2Node_Variable |
| VER_UE4_REFACTOR_MATERIAL_EXPRESSION_SCENECOLOR_AND_SCENEDEPTH_INPUTS | 231 | Refactored material expression inputs for UMaterialExpressionSceneColor and UMaterialExpressionSceneDepth |
| VER_UE4_SPLINE_MESH_ORIENTATION | 232 | Spline meshes changed from Z forwards to configurable |
| VER_UE4_REVERB_EFFECT_ASSET_TYPE | 233 | Added ReverbEffect asset type |
| VER_UE4_MAX_TEXCOORD_INCREASED | 234 | changed max texcoords from 4 to 8 |
| VER_UE4_SPEEDTREE_STATICMESH | 235 | static meshes changed to support SpeedTrees |
| VER_UE4_LANDSCAPE_COMPONENT_LAZY_REFERENCES | 236 | Landscape component reference between landscape component and collision component |
| VER_UE4_SWITCH_CALL_NODE_TO_USE_MEMBER_REFERENCE | 237 | Refactored UK2Node_CallFunction to use FMemberReference |
| VER_UE4_ADDED_SKELETON_ARCHIVER_REMOVAL | 238 | Added fixup step to remove skeleton class references from blueprint objects |
| VER_UE4_ADDED_SKELETON_ARCHIVER_REMOVAL_SECOND_TIME | 239 | See above, take 2. |
| VER_UE4_BLUEPRINT_SKEL_CLASS_TRANSIENT_AGAIN | 240 | Making the skeleton class on blueprints transient |
| VER_UE4_ADD_COOKED_TO_UCLASS | 241 | UClass knows if it's been cooked |
| VER_UE4_DEPRECATED_STATIC_MESH_THUMBNAIL_PROPERTIES_REMOVED | 242 | Deprecated static mesh thumbnail properties were removed |
| VER_UE4_COLLECTIONS_IN_SHADERMAPID | 243 | Added collections in material shader map ids |
| VER_UE4_REFACTOR_MOVEMENT_COMPONENT_HIERARCHY | 244 | Renamed some Movement Component properties, added PawnMovementComponent |
| VER_UE4_FIX_TERRAIN_LAYER_SWITCH_ORDER | 245 | Swap UMaterialExpressionTerrainLayerSwitch::LayerUsed/LayerNotUsed the correct way round |
| VER_UE4_ALL_PROPS_TO_CONSTRAINTINSTANCE | 246 | Remove URB_ConstraintSetup |
| VER_UE4_LOW_QUALITY_DIRECTIONAL_LIGHTMAPS | 247 | Low quality directional lightmaps |
| VER_UE4_ADDED_NOISE_EMITTER_COMPONENT | 248 | Added NoiseEmitterComponent and removed related Pawn properties. |
| VER_UE4_ADD_TEXT_COMPONENT_VERTICAL_ALIGNMENT | 249 | Add text component vertical alignment |
| VER_UE4_ADDED_FBX_ASSET_IMPORT_DATA | 250 | Added AssetImportData for FBX asset types, deprecating SourceFilePath and SourceFileTimestamp |
| VER_UE4_REMOVE_LEVELBODYSETUP | 251 | Remove LevelBodySetup from ULevel |
| VER_UE4_REFACTOR_CHARACTER_CROUCH | 252 | Refactor character crouching |
| VER_UE4_SMALLER_DEBUG_MATERIALSHADER_UNIFORM_EXPRESSIONS | 253 | Trimmed down material shader debug information. |
| VER_UE4_APEX_CLOTH | 254 | APEX Clothing |
| VER_UE4_SAVE_COLLISIONRESPONSE_PER_CHANNEL | 255 | Change Collision Channel to save only modified ones than all of them. Note!!! Once we pass this CL, we can rename FCollisionResponseContainer enum values. We should rename to match ECollisionChannel |
| VER_UE4_ADDED_LANDSCAPE_SPLINE_EDITOR_MESH | 256 | Added Landscape Spline editor meshes |
| VER_UE4_CHANGED_MATERIAL_REFACTION_TYPE | 257 | Fixup input expressions for reading from refraction material attributes. |
| VER_UE4_REFACTOR_PROJECTILE_MOVEMENT | 258 | Refactor projectile movement, along with some other movement component work. |
| VER_UE4_REMOVE_PHYSICALMATERIALPROPERTY | 259 | Remove PhysicalMaterialProperty and replace with user defined enum |
| VER_UE4_PURGED_FMATERIAL_COMPILE_OUTPUTS | 260 | Removed all compile outputs from FMaterial |
| VER_UE4_ADD_COOKED_TO_LANDSCAPE | 261 | Ability to save cooked PhysX meshes to Landscape |
| VER_UE4_CONSUME_INPUT_PER_BIND | 262 | Change how input component consumption works |
| VER_UE4_SOUND_CLASS_GRAPH_EDITOR | 263 | Added new Graph based SoundClass Editor |
| VER_UE4_FIXUP_TERRAIN_LAYER_NODES | 264 | Fixed terrain layer node guids which was causing artifacts |
| VER_UE4_RETROFIT_CLAMP_EXPRESSIONS_SWAP | 265 | Added clamp min/max swap check to catch older materials |
| VER_UE4_REMOVE_LIGHT_MOBILITY_CLASSES | 266 | Remove static/movable/stationary light classes |
| VER_UE4_REFACTOR_PHYSICS_BLENDING | 267 | Refactor the way physics blending works to allow partial blending |
| VER_UE4_WORLD_LEVEL_INFO_UPDATED | 268 | WorldLevelInfo: Added reference to parent level and streaming distance |
| VER_UE4_STATIC_SKELETAL_MESH_SERIALIZATION_FIX | 269 | Fixed cooking of skeletal/static meshes due to bad serialization logic |
| VER_UE4_REMOVE_STATICMESH_MOBILITY_CLASSES | 270 | Removal of InterpActor and PhysicsActor |
| VER_UE4_REFACTOR_PHYSICS_TRANSFORMS | 271 | Refactor physics transforms |
| VER_UE4_REMOVE_ZERO_TRIANGLE_SECTIONS | 272 | Remove zero triangle sections from static meshes and compact material indices. |
| VER_UE4_CHARACTER_MOVEMENT_DECELERATION | 273 | Add param for deceleration in character movement instead of using acceleration. |
| VER_UE4_CAMERA_ACTOR_USING_CAMERA_COMPONENT | 274 | Made ACameraActor use a UCameraComponent for parameter storage, etc... |
| VER_UE4_CHARACTER_MOVEMENT_DEPRECATE_PITCH_ROLL | 275 | Deprecated some pitch/roll properties in CharacterMovementComponent |
| VER_UE4_REBUILD_TEXTURE_STREAMING_DATA_ON_LOAD | 276 | Rebuild texture streaming data on load for uncooked builds |
| VER_UE4_SUPPORT_32BIT_STATIC_MESH_INDICES | 277 | Add support for 32 bit index buffers for static meshes. |
| VER_UE4_ADDED_CHUNKID_TO_ASSETDATA_AND_UPACKAGE | 278 | Added streaming install ChunkID to AssetData and UPackage |
| VER_UE4_CHARACTER_DEFAULT_MOVEMENT_BINDINGS | 279 | Add flag to control whether Character blueprints receive default movement bindings. |
| VER_UE4_APEX_CLOTH_LOD | 280 | APEX Clothing LOD Info |
| VER_UE4_ATMOSPHERIC_FOG_CACHE_DATA | 281 | Added atmospheric fog texture data to be general |
| VAR_UE4_ARRAY_PROPERTY_INNER_TAGS | 282 | Arrays serialize their inner's tags |
| VER_UE4_KEEP_SKEL_MESH_INDEX_DATA | 283 | Skeletal mesh index data is kept in memory in game to support mesh merging. |
| VER_UE4_BODYSETUP_COLLISION_CONVERSION | 284 | Added compatibility for the body instance collision change |
| VER_UE4_REFLECTION_CAPTURE_COOKING | 285 | Reflection capture cooking |
| VER_UE4_REMOVE_DYNAMIC_VOLUME_CLASSES | 286 | Removal of DynamicTriggerVolume, DynamicBlockingVolume, DynamicPhysicsVolume |
| VER_UE4_STORE_HASCOOKEDDATA_FOR_BODYSETUP | 287 | Store an additional flag in the BodySetup to indicate whether there is any cooked data to load |
| VER_UE4_REFRACTION_BIAS_TO_REFRACTION_DEPTH_BIAS | 288 | Changed name of RefractionBias to RefractionDepthBias. |
| VER_UE4_REMOVE_SKELETALPHYSICSACTOR | 289 | Removal of SkeletalPhysicsActor |
| VER_UE4_PC_ROTATION_INPUT_REFACTOR | 290 | PlayerController rotation input refactor |
| VER_UE4_LANDSCAPE_PLATFORMDATA_COOKING | 291 | Landscape Platform Data cooking |
| VER_UE4_CREATEEXPORTS_CLASS_LINKING_FOR_BLUEPRINTS | 292 | Added call for linking classes in CreateExport to ensure memory is initialized properly |
| VER_UE4_REMOVE_NATIVE_COMPONENTS_FROM_BLUEPRINT_SCS | 293 | Remove native component nodes from the blueprint SimpleConstructionScript |
| VER_UE4_REMOVE_SINGLENODEINSTANCE | 294 | Removal of Single Node Instance |
| VER_UE4_CHARACTER_BRAKING_REFACTOR | 295 | Character movement braking changes |
| VER_UE4_VOLUME_SAMPLE_LOW_QUALITY_SUPPORT | 296 | Supported low quality lightmaps in volume samples |
| VER_UE4_SPLIT_TOUCH_AND_CLICK_ENABLES | 297 | Split bEnableTouchEvents out from bEnableClickEvents |
| VER_UE4_HEALTH_DEATH_REFACTOR | 298 | Health/Death refactor |
| VER_UE4_SOUND_NODE_ENVELOPER_CURVE_CHANGE | 299 | Moving USoundNodeEnveloper from UDistributionFloatConstantCurve to FRichCurve |
| VER_UE4_POINT_LIGHT_SOURCE_RADIUS | 300 | Moved SourceRadius to UPointLightComponent |
| VER_UE4_SCENE_CAPTURE_CAMERA_CHANGE | 301 | Scene capture actors based on camera actors. |
| VER_UE4_MOVE_SKELETALMESH_SHADOWCASTING | 302 | Moving SkeletalMesh shadow casting flag from LoD details to material |
| VER_UE4_CHANGE_SETARRAY_BYTECODE | 303 | Changing bytecode operators for creating arrays |
| VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES | 304 | Material Instances overriding base material properties. |
| VER_UE4_COMBINED_LIGHTMAP_TEXTURES | 305 | Combined top/bottom lightmap textures |
| VER_UE4_BUMPED_MATERIAL_EXPORT_GUIDS | 306 | Forced material lightmass guids to be regenerated |
| VER_UE4_BLUEPRINT_INPUT_BINDING_OVERRIDES | 307 | Allow overriding of parent class input bindings |
| VER_UE4_FIXUP_BODYSETUP_INVALID_CONVEX_TRANSFORM | 308 | Fix up convex invalid transform |
| VER_UE4_FIXUP_STIFFNESS_AND_DAMPING_SCALE | 309 | Fix up scale of physics stiffness and damping value |
| VER_UE4_REFERENCE_SKELETON_REFACTOR | 310 | Convert USkeleton and FBoneContrainer to using FReferenceSkeleton. |
| VER_UE4_K2NODE_REFERENCEGUIDS | 311 | Adding references to variable, function, and macro nodes to be able to update to renamed values |
| VER_UE4_FIXUP_ROOTBONE_PARENT | 312 | Fix up the 0th bone's parent bone index. |
| VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES_PHASE_2 | 314 | Material Instances overriding base material properties #2. |
| VER_UE4_CLASS_NOTPLACEABLE_ADDED | 315 | CLASS_Placeable becomes CLASS_NotPlaceable |
| VER_UE4_WORLD_LEVEL_INFO_LOD_LIST | 316 | Added LOD info list to a world tile description |
| VER_UE4_CHARACTER_MOVEMENT_VARIABLE_RENAMING_1 | 317 | CharacterMovement variable naming refactor |
| VER_UE4_FSLATESOUND_CONVERSION | 318 | FName properties containing sound names converted to FSlateSound properties |
| VER_UE4_WORLD_LEVEL_INFO_ZORDER | 319 | Added ZOrder to a world tile description |
| VER_UE4_PACKAGE_REQUIRES_LOCALIZATION_GATHER_FLAGGING | 320 | Added flagging of localization gather requirement to packages |
| VER_UE4_BP_ACTOR_VARIABLE_DEFAULT_PREVENTING | 321 | Preventing Blueprint Actor variables from having default values |
| VER_UE4_TEST_ANIMCOMP_CHANGE | 322 | Preventing Blueprint Actor variables from having default values |
| VER_UE4_EDITORONLY_BLUEPRINTS | 323 | Class as primary asset, name convention changed |
| VER_UE4_EDGRAPHPINTYPE_SERIALIZATION | 324 | Custom serialization for FEdGraphPinType |
| VER_UE4_NO_MIRROR_BRUSH_MODEL_COLLISION | 325 | Stop generating 'mirrored' cooked mesh for Brush and Model components |
| VER_UE4_CHANGED_CHUNKID_TO_BE_AN_ARRAY_OF_CHUNKIDS | 326 | Changed ChunkID to be an array of IDs. |
| VER_UE4_WORLD_NAMED_AFTER_PACKAGE | 327 | Worlds have been renamed from "TheWorld" to be named after the package containing them |
| VER_UE4_SKY_LIGHT_COMPONENT | 328 | Added sky light component |
| VER_UE4_WORLD_LAYER_ENABLE_DISTANCE_STREAMING | 329 | Added Enable distance streaming flag to FWorldTileLayer |
| VER_UE4_REMOVE_ZONES_FROM_MODEL | 330 | Remove visibility/zone information from UModel |
| VER_UE4_FIX_ANIMATIONBASEPOSE_SERIALIZATION | 331 | Fix base pose serialization |
| VER_UE4_SUPPORT_8_BONE_INFLUENCES_SKELETAL_MESHES | 332 | Support for up to 8 skinning influences per vertex on skeletal meshes (on non-gpu vertices) |
| VER_UE4_ADD_OVERRIDE_GRAVITY_FLAG | 333 | Add explicit bOverrideGravity to world settings |
| VER_UE4_SUPPORT_GPUSKINNING_8_BONE_INFLUENCES | 334 | Support for up to 8 skinning influences per vertex on skeletal meshes (on gpu vertices) |
| VER_UE4_ANIM_SUPPORT_NONUNIFORM_SCALE_ANIMATION | 335 | Supporting nonuniform scale animation |
| VER_UE4_ENGINE_VERSION_OBJECT | 336 | Engine version is stored as a FEngineVersion object rather than changelist number |
| VER_UE4_PUBLIC_WORLDS | 337 | World assets now have RF_Public |
| VER_UE4_SKELETON_GUID_SERIALIZATION | 338 | Skeleton Guid |
| VER_UE4_CHARACTER_MOVEMENT_WALKABLE_FLOOR_REFACTOR | 339 | Character movement WalkableFloor refactor |
| VER_UE4_INVERSE_SQUARED_LIGHTS_DEFAULT | 340 | Lights default to inverse squared |
| VER_UE4_DISABLED_SCRIPT_LIMIT_BYTECODE | 341 | Disabled SCRIPT_LIMIT_BYTECODE_TO_64KB |
| VER_UE4_PRIVATE_REMOTE_ROLE | 342 | Made remote role private, exposed bReplicates |
| VER_UE4_FOLIAGE_STATIC_MOBILITY | 343 | Fix up old foliage components to have static mobility (superseded by VER_UE4_FOLIAGE_MOVABLE_MOBILITY) |
| VER_UE4_BUILD_SCALE_VECTOR | 344 | Change BuildScale from a float to a vector |
| VER_UE4_FOLIAGE_COLLISION | 345 | After implementing foliage collision, need to disable collision on old foliage instances |
| VER_UE4_SKY_BENT_NORMAL | 346 | Added sky bent normal to indirect lighting cache |
| VER_UE4_LANDSCAPE_COLLISION_DATA_COOKING | 347 | Added cooking for landscape collision data |
| VER_UE4_MORPHTARGET_CPU_TANGENTZDELTA_FORMATCHANGE | 348 | Convert CPU tangent Z delta to vector from PackedNormal since we don't get any benefit other than memory we still convert all to FVector in CPU time whenever any calculation |
| VER_UE4_SOFT_CONSTRAINTS_USE_MASS | 349 | Soft constraint limits will implicitly use the mass of the bodies |
| VER_UE4_REFLECTION_DATA_IN_PACKAGES | 350 | Reflection capture data saved in packages |
| VER_UE4_FOLIAGE_MOVABLE_MOBILITY | 351 | Fix up old foliage components to have movable mobility (superseded by VER_UE4_FOLIAGE_STATIC_LIGHTING_SUPPORT) |
| VER_UE4_UNDO_BREAK_MATERIALATTRIBUTES_CHANGE | 352 | Undo BreakMaterialAttributes changes as it broke old content |
| VER_UE4_ADD_CUSTOMPROFILENAME_CHANGE | 353 | Now Default custom profile name isn't NONE anymore due to copy/paste not working properly with it |
| VER_UE4_FLIP_MATERIAL_COORDS | 354 | Permanently flip and scale material expression coordinates |
| VER_UE4_MEMBERREFERENCE_IN_PINTYPE | 355 | PinSubCategoryMemberReference added to FEdGraphPinType |
| VER_UE4_VEHICLES_UNIT_CHANGE | 356 | Vehicles use Nm for Torque instead of cm and RPM instead of rad/s |
| VER_UE4_ANIMATION_REMOVE_NANS | 357 | removes NANs from all animations when loaded now importing should detect NaNs, so we should not have NaNs in source data |
| VER_UE4_SKELETON_ASSET_PROPERTY_TYPE_CHANGE | 358 | Change skeleton preview attached assets property type |
| VER_UE4_FIX_BLUEPRINT_VARIABLE_FLAGS | 359 | Fix some blueprint variables that have the CPF_DisableEditOnTemplate flag set when they shouldn't |
| VER_UE4_VEHICLES_UNIT_CHANGE2 | 360 | Vehicles use Nm for Torque instead of cm and RPM instead of rad/s part two (missed conversion for some variables |
| VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING | 361 | Changed order of interface class serialization |
| VER_UE4_STATIC_MESH_SCREEN_SIZE_LODS | 362 | Change from LOD distances to display factors |
| VER_UE4_FIX_MATERIAL_COORDS | 363 | Requires test of material coords to ensure they're saved correctly |
| VER_UE4_SPEEDTREE_WIND_V7 | 364 | Changed SpeedTree wind presets to v7 |
| VER_UE4_LOAD_FOR_EDITOR_GAME | 365 | NeedsLoadForEditorGame added |
| VER_UE4_SERIALIZE_RICH_CURVE_KEY | 366 | Manual serialization of FRichCurveKey to save space |
| VER_UE4_MOVE_LANDSCAPE_MICS_AND_TEXTURES_WITHIN_LEVEL | 367 | Change the outer of ULandscapeMaterialInstanceConstants and Landscape-related textures to the level in which they reside |
| VER_UE4_FTEXT_HISTORY | 368 | FTexts have creation history data, removed Key, Namespaces, and SourceString |
| VER_UE4_FIX_MATERIAL_COMMENTS | 369 | Shift comments to the left to contain expressions properly |
| VER_UE4_STORE_BONE_EXPORT_NAMES | 370 | Bone names stored as FName means that we can't guarantee the correct case on export, now we store a separate string for export purposes only |
| VER_UE4_MESH_EMITTER_INITIAL_ORIENTATION_DISTRIBUTION | 371 | changed mesh emitter initial orientation to distribution |
| VER_UE4_DISALLOW_FOLIAGE_ON_BLUEPRINTS | 372 | Foliage on blueprints causes crashes |
| VER_UE4_FIXUP_MOTOR_UNITS | 373 | change motors to use revolutions per second instead of rads/second |
| VER_UE4_DEPRECATED_MOVEMENTCOMPONENT_MODIFIED_SPEEDS | 374 | deprecated MovementComponent functions including "ModifiedMaxSpeed" et al |
| VER_UE4_RENAME_CANBECHARACTERBASE | 375 | rename CanBeCharacterBase |
| VER_UE4_GAMEPLAY_TAG_CONTAINER_TAG_TYPE_CHANGE | 376 | Change GameplayTagContainers to have FGameplayTags instead of FNames; Required to fix-up native serialization |
| VER_UE4_FOLIAGE_SETTINGS_TYPE | 377 | Change from UInstancedFoliageSettings to UFoliageType, and change the api from being keyed on UStaticMesh* to UFoliageType* |
| VER_UE4_STATIC_SHADOW_DEPTH_MAPS | 378 | Lights serialize static shadow depth maps |
| VER_UE4_ADD_TRANSACTIONAL_TO_DATA_ASSETS | 379 | Add RF_Transactional to data assets, fixing undo problems when editing them |
| VER_UE4_ADD_LB_WEIGHTBLEND | 380 | Change LB_AlphaBlend to LB_WeightBlend in ELandscapeLayerBlendType |
| VER_UE4_ADD_ROOTCOMPONENT_TO_FOLIAGEACTOR | 381 | Add root component to an foliage actor, all foliage cluster components will be attached to a root |
| VER_UE4_FIX_MATERIAL_PROPERTY_OVERRIDE_SERIALIZE | 382 | FMaterialInstanceBasePropertyOverrides didn't use proper UObject serialize |
| VER_UE4_ADD_LINEAR_COLOR_SAMPLER | 383 | Addition of linear color sampler. color sample type is changed to linear sampler if source texture !sRGB |
| VER_UE4_ADD_STRING_ASSET_REFERENCES_MAP | 384 | Added StringAssetReferencesMap to support renames of FStringAssetReference properties. |
| VER_UE4_BLUEPRINT_USE_SCS_ROOTCOMPONENT_SCALE | 385 | Apply scale from SCS RootComponent details in the Blueprint Editor to new actor instances at construction time |
| VER_UE4_LEVEL_STREAMING_DRAW_COLOR_TYPE_CHANGE | 386 | Changed level streaming to have a linear color since the visualization doesn't gamma correct. |
| VER_UE4_CLEAR_NOTIFY_TRIGGERS | 387 | Cleared end triggers from non-state anim notifies |
| VER_UE4_SKELETON_ADD_SMARTNAMES | 388 | Convert old curve names stored in anim assets into skeleton smartnames |
| VER_UE4_ADDED_CURRENCY_CODE_TO_FTEXT | 389 | Added the currency code field to FTextHistory_AsCurrency |
| VER_UE4_ENUM_CLASS_SUPPORT | 390 | Added support for C++11 enum classes |
| VER_UE4_FIXUP_WIDGET_ANIMATION_CLASS | 391 | Fixup widget animation class |
| VER_UE4_SOUND_COMPRESSION_TYPE_ADDED | 392 | USoundWave objects now contain details about compression scheme used. |
| VER_UE4_AUTO_WELDING | 393 | Bodies will automatically weld when attached |
| VER_UE4_RENAME_CROUCHMOVESCHARACTERDOWN | 394 | Rename UCharacterMovementComponent::bCrouchMovesCharacterDown |
| VER_UE4_LIGHTMAP_MESH_BUILD_SETTINGS | 395 | Lightmap parameters in FMeshBuildSettings |
| VER_UE4_RENAME_SM3_TO_ES3_1 | 396 | Rename SM3 to ES3_1 and updates featurelevel material node selector |
| VER_UE4_DEPRECATE_UMG_STYLE_ASSETS | 397 | Deprecated separate style assets for use in UMG |
| VER_UE4_POST_DUPLICATE_NODE_GUID | 398 | Duplicating Blueprints will regenerate NodeGuids after this version |
| VER_UE4_RENAME_CAMERA_COMPONENT_VIEW_ROTATION | 399 | Rename USpringArmComponent::bUseControllerViewRotation to bUsePawnViewRotation, Rename UCameraComponent::bUseControllerViewRotation to bUsePawnViewRotation (and change the default value) |
| VER_UE4_CASE_PRESERVING_FNAME | 400 | Changed FName to be case preserving |
| VER_UE4_RENAME_CAMERA_COMPONENT_CONTROL_ROTATION | 401 | Rename USpringArmComponent::bUsePawnViewRotation to bUsePawnControlRotation, Rename UCameraComponent::bUsePawnViewRotation to bUsePawnControlRotation |
| VER_UE4_FIX_REFRACTION_INPUT_MASKING | 402 | Fix bad refraction material attribute masks |
| VER_UE4_GLOBAL_EMITTER_SPAWN_RATE_SCALE | 403 | A global spawn rate for emitters. |
| VER_UE4_CLEAN_DESTRUCTIBLE_SETTINGS | 404 | Cleanup destructible mesh settings |
| VER_UE4_CHARACTER_MOVEMENT_UPPER_IMPACT_BEHAVIOR | 405 | CharacterMovementComponent refactor of AdjustUpperHemisphereImpact and deprecation of some associated vars. |
| VER_UE4_BP_MATH_VECTOR_EQUALITY_USES_EPSILON | 406 | Changed Blueprint math equality functions for vectors and rotators to operate as a "nearly" equals rather than "exact" |
| VER_UE4_FOLIAGE_STATIC_LIGHTING_SUPPORT | 407 | Static lighting support was re-added to foliage, and mobility was returned to static |
| VER_UE4_SLATE_COMPOSITE_FONTS | 408 | Added composite fonts to Slate font info |
| VER_UE4_REMOVE_SAVEGAMESUMMARY | 409 | Remove UDEPRECATED_SaveGameSummary, required for UWorld::Serialize |
| VER_UE4_REMOVE_SKELETALMESH_COMPONENT_BODYSETUP_SERIALIZATION | 410 | Remove bodyseutp serialization from skeletal mesh component |
| VER_UE4_SLATE_BULK_FONT_DATA | 411 | Made Slate font data use bulk data to store the embedded font data |
| VER_UE4_ADD_PROJECTILE_FRICTION_BEHAVIOR | 412 | Add new friction behavior in ProjectileMovementComponent. |
| VER_UE4_MOVEMENTCOMPONENT_AXIS_SETTINGS | 413 | Add axis settings enum to MovementComponent. |
| VER_UE4_GRAPH_INTERACTIVE_COMMENTBUBBLES | 414 | Switch to new interactive comments, requires boundry conversion to preserve previous states |
| VER_UE4_LANDSCAPE_SERIALIZE_PHYSICS_MATERIALS | 415 | Landscape serializes physical materials for collision objects |
| VER_UE4_RENAME_WIDGET_VISIBILITY | 416 | Rename Visiblity on widgets to Visibility |
| VER_UE4_ANIMATION_ADD_TRACKCURVES | 417 | add track curves for animation |
| VER_UE4_MONTAGE_BRANCHING_POINT_REMOVAL | 418 | Removed BranchingPoints from AnimMontages and converted them to regular AnimNotifies. |
| VER_UE4_BLUEPRINT_ENFORCE_CONST_IN_FUNCTION_OVERRIDES | 419 | Enforce const-correctness in Blueprint implementations of native C++ const class methods |
| VER_UE4_ADD_PIVOT_TO_WIDGET_COMPONENT | 420 | Added pivot to widget components, need to load old versions as a 0,0 pivot, new default is 0.5,0.5 |
| VER_UE4_PAWN_AUTO_POSSESS_AI | 421 | Added finer control over when AI Pawns are automatically possessed. Also renamed Pawn.AutoPossess to Pawn.AutoPossessPlayer indicate this was a setting for players and not AI. |
| VER_UE4_FTEXT_HISTORY_DATE_TIMEZONE | 422 | Added serialization of timezone to FTextHistory for AsDate operations. |
| VER_UE4_SORT_ACTIVE_BONE_INDICES | 423 | Sort ActiveBoneIndices on lods so that we can avoid doing it at run time |
| VER_UE4_PERFRAME_MATERIAL_UNIFORM_EXPRESSIONS | 424 | Added per-frame material uniform expressions |
| VER_UE4_MIKKTSPACE_IS_DEFAULT | 425 | Make MikkTSpace the default tangent space calculation method for static meshes. |
| VER_UE4_LANDSCAPE_GRASS_COOKING | 426 | Only applies to cooked files, grass cooking support. |
| VER_UE4_FIX_SKEL_VERT_ORIENT_MESH_PARTICLES | 427 | Fixed code for using the bOrientMeshEmitters property. |
| VER_UE4_LANDSCAPE_STATIC_SECTION_OFFSET | 428 | Do not change landscape section offset on load under world composition |
| VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION | 429 | New options for navigation data runtime generation (static, modifiers only, dynamic) |
| VER_UE4_MATERIAL_MASKED_BLENDMODE_TIDY | 430 | Tidied up material's handling of masked blend mode. |
| VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7_DEPRECATED | 431 | Original version of VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7; renumbered to prevent blocking promotion in main. |
| VER_UE4_AFTER_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7_DEPRECATED | 432 | Original version of VER_UE4_AFTER_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7; renumbered to prevent blocking promotion in main. |
| VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7 | 433 | After merging VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION into 4.7 branch |
| VER_UE4_AFTER_MERGING_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7 | 434 | After merging VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION into 4.7 branch |
| VER_UE4_SERIALIZE_LANDSCAPE_GRASS_DATA | 435 | Landscape grass weightmap data is now generated in the editor and serialized. |
| VER_UE4_OPTIONALLY_CLEAR_GPU_EMITTERS_ON_INIT | 436 | New property to optionally prevent gpu emitters clearing existing particles on Init(). |
| VER_UE4_SERIALIZE_LANDSCAPE_GRASS_DATA_MATERIAL_GUID | 437 | Also store the Material guid with the landscape grass data |
| VER_UE4_BLUEPRINT_GENERATED_CLASS_COMPONENT_TEMPLATES_PUBLIC | 438 | Make sure that all template components from blueprint generated classes are flagged as public |
| VER_UE4_ACTOR_COMPONENT_CREATION_METHOD | 439 | Split out creation method on ActorComponents to distinguish between native, instance, and simple or user construction script |
| VER_UE4_K2NODE_EVENT_MEMBER_REFERENCE | 440 | K2Node_Event now uses FMemberReference for handling references |
| VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG | 441 | FPropertyTag stores GUID of struct |
| VER_UE4_REMOVE_UNUSED_UPOLYS_FROM_UMODEL | 442 | Remove unused UPolys from UModel cooked content |
| VER_UE4_REBUILD_HIERARCHICAL_INSTANCE_TREES | 443 | This doesn't do anything except trigger a rebuild on HISMC cluster trees, in this case to get a good "occlusion query" level |
| VER_UE4_PACKAGE_SUMMARY_HAS_COMPATIBLE_ENGINE_VERSION | 444 | Package summary includes an CompatibleWithEngineVersion field, separately to the version it's saved with |
| VER_UE4_TRACK_UCS_MODIFIED_PROPERTIES | 445 | Track UCS modified properties on Actor Components |
| VER_UE4_LANDSCAPE_SPLINE_CROSS_LEVEL_MESHES | 446 | Allowed landscape spline meshes to be stored into landscape streaming levels rather than the spline's level |
| VER_UE4_DEPRECATE_USER_WIDGET_DESIGN_SIZE | 447 | Deprecate the variables used for sizing in the designer on UUserWidget |
| VER_UE4_ADD_EDITOR_VIEWS | 448 | Make the editor views array dynamically sized |
| VER_UE4_FOLIAGE_WITH_ASSET_OR_CLASS | 449 | Updated foliage to work with either FoliageType assets or blueprint classes |
| VER_UE4_BODYINSTANCE_BINARY_SERIALIZATION | 450 | Allows PhysicsSerializer to serialize shapes and actors for faster load times |
| VER_UE4_SERIALIZE_BLUEPRINT_EVENTGRAPH_FASTCALLS_IN_UFUNCTION | 451 | Added fastcall data serialization directly in UFunction |
| VER_UE4_INTERPCURVE_SUPPORTS_LOOPING | 452 | Changes to USplineComponent and FInterpCurve |
| VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES_DITHERED_LOD_TRANSITION | 453 | Material Instances overriding base material LOD transitions |
| VER_UE4_SERIALIZE_LANDSCAPE_ES2_TEXTURES | 454 | Serialize ES2 textures separately rather than overwriting the properties used on other platforms |
| VER_UE4_CONSTRAINT_INSTANCE_MOTOR_FLAGS | 455 | Constraint motor velocity is broken into per-component |
| VER_UE4_SERIALIZE_PINTYPE_CONST | 456 | Serialize bIsConst in FEdGraphPinType |
| VER_UE4_LIBRARY_CATEGORIES_AS_FTEXT | 457 | Change UMaterialFunction::LibraryCategories to LibraryCategoriesText (old assets were saved before auto-conversion of FArrayProperty was possible) |
| VER_UE4_SKIP_DUPLICATE_EXPORTS_ON_SAVE_PACKAGE | 458 | Check for duplicate exports while saving packages. |
| VER_UE4_SERIALIZE_TEXT_IN_PACKAGES | 459 | Pre-gathering of gatherable, localizable text in packages to optimize text gathering operation times |
| VER_UE4_ADD_BLEND_MODE_TO_WIDGET_COMPONENT | 460 | Added pivot to widget components, need to load old versions as a 0,0 pivot, new default is 0.5,0.5 |
| VER_UE4_NEW_LIGHTMASS_PRIMITIVE_SETTING | 461 | Added lightmass primitive setting |
| VER_UE4_REPLACE_SPRING_NOZ_PROPERTY | 462 | Deprecate NoZSpring property on spring nodes to be replaced with TranslateZ property |
| VER_UE4_TIGHTLY_PACKED_ENUMS | 463 | Keep enums tight and serialize their values as pairs of FName and value. Don't insert dummy values. |
| VER_UE4_ASSET_IMPORT_DATA_AS_JSON | 464 | Changed Asset import data to serialize file meta data as JSON |
| VER_UE4_TEXTURE_LEGACY_GAMMA | 465 | Legacy gamma support for textures. |
| VER_UE4_ADDED_NATIVE_SERIALIZATION_FOR_IMMUTABLE_STRUCTURES | 466 | Added WithSerializer for basic native structures like FVector, FColor etc to improve serialization performance |
| VER_UE4_DEPRECATE_UMG_STYLE_OVERRIDES | 467 | Deprecated attributes that override the style on UMG widgets |
| VER_UE4_STATIC_SHADOWMAP_PENUMBRA_SIZE | 468 | Shadowmap penumbra size stored |
| VER_UE4_NIAGARA_DATA_OBJECT_DEV_UI_FIX | 469 | Fix BC on Niagara effects from the data object and dev UI changes. |
| VER_UE4_FIXED_DEFAULT_ORIENTATION_OF_WIDGET_COMPONENT | 470 | Fixed the default orientation of widget component so it faces down +x |
| VER_UE4_REMOVED_MATERIAL_USED_WITH_UI_FLAG | 471 | Removed bUsedWithUI flag from UMaterial and replaced it with a new material domain for UI |
| VER_UE4_CHARACTER_MOVEMENT_ADD_BRAKING_FRICTION | 472 | Added braking friction separate from turning friction. |
| VER_UE4_BSP_UNDO_FIX | 473 | Removed TTransArrays from UModel |
| VER_UE4_DYNAMIC_PARAMETER_DEFAULT_VALUE | 474 | Added default value to dynamic parameter. |
| VER_UE4_STATIC_MESH_EXTENDED_BOUNDS | 475 | Added ExtendedBounds to StaticMesh |
| VER_UE4_ADDED_NON_LINEAR_TRANSITION_BLENDS | 476 | Added non-linear blending to anim transitions, deprecating old types |
| VER_UE4_AO_MATERIAL_MASK | 477 | AO Material Mask texture |
| VER_UE4_NAVIGATION_AGENT_SELECTOR | 478 | Replaced navigation agents selection with single structure |
| VER_UE4_MESH_PARTICLE_COLLISIONS_CONSIDER_PARTICLE_SIZE | 479 | Mesh particle collisions consider particle size. |
| VER_UE4_BUILD_MESH_ADJ_BUFFER_FLAG_EXPOSED | 480 | Adjacency buffer building no longer automatically handled based on triangle count, user-controlled |
| VER_UE4_MAX_ANGULAR_VELOCITY_DEFAULT | 481 | Change the default max angular velocity |
| VER_UE4_APEX_CLOTH_TESSELLATION | 482 | Build Adjacency index buffer for clothing tessellation |
| VER_UE4_DECAL_SIZE | 483 | Added DecalSize member, solved backward compatibility |
| VER_UE4_KEEP_ONLY_PACKAGE_NAMES_IN_STRING_ASSET_REFERENCES_MAP | 484 | Keep only package names in StringAssetReferencesMap |
| VER_UE4_COOKED_ASSETS_IN_EDITOR_SUPPORT | 485 | Support sound cue not saving out editor only data |
| VER_UE4_DIALOGUE_WAVE_NAMESPACE_AND_CONTEXT_CHANGES | 486 | Updated dialogue wave localization gathering logic. |
| VER_UE4_MAKE_ROT_RENAME_AND_REORDER | 487 | Renamed MakeRot MakeRotator and rearranged parameters. |
| VER_UE4_K2NODE_VAR_REFERENCEGUIDS | 488 | K2Node_Variable will properly have the VariableReference Guid set if available |
| VER_UE4_SOUND_CONCURRENCY_PACKAGE | 489 | Added support for sound concurrency settings structure and overrides |
| VER_UE4_USERWIDGET_DEFAULT_FOCUSABLE_FALSE | 490 | Changing the default value for focusable user widgets to false |
| VER_UE4_BLUEPRINT_CUSTOM_EVENT_CONST_INPUT | 491 | Custom event nodes implicitly set 'const' on array and non-array pass-by-reference input params |
| VER_UE4_USE_LOW_PASS_FILTER_FREQ | 492 | Renamed HighFrequencyGain to LowPassFilterFrequency |
| VER_UE4_NO_ANIM_BP_CLASS_IN_GAMEPLAY_CODE | 493 | UAnimBlueprintGeneratedClass can be replaced by a dynamic class. Use TSubclassOf UAnimInstance instead. |
| VER_UE4_SCS_STORES_ALLNODES_ARRAY | 494 | The SCS keeps a list of all nodes in its hierarchy rather than recursively building it each time it is requested |
| VER_UE4_FBX_IMPORT_DATA_RANGE_ENCAPSULATION | 495 | Moved StartRange and EndRange in UFbxAnimSequenceImportData to use FInt32Interval |
| VER_UE4_CAMERA_COMPONENT_ATTACH_TO_ROOT | 496 | Adding a new root scene component to camera component |
| VER_UE4_INSTANCED_STEREO_UNIFORM_UPDATE | 497 | Updating custom material expression nodes for instanced stereo implementation |
| VER_UE4_STREAMABLE_TEXTURE_MIN_MAX_DISTANCE | 498 | Texture streaming min and max distance to handle HLOD |
| VER_UE4_INJECT_BLUEPRINT_STRUCT_PIN_CONVERSION_NODES | 499 | Fixing up invalid struct-to-struct pin connections by injecting available conversion nodes |
| VER_UE4_INNER_ARRAY_TAG_INFO | 500 | Saving tag data for Array Property's inner property |
| VER_UE4_FIX_SLOT_NAME_DUPLICATION | 501 | Fixed duplicating slot node names in skeleton due to skeleton preload on compile |
| VER_UE4_STREAMABLE_TEXTURE_AABB | 502 | Texture streaming using AABBs instead of Spheres |
| VER_UE4_PROPERTY_GUID_IN_PROPERTY_TAG | 503 | FPropertyTag stores GUID of property |
| VER_UE4_NAME_HASHES_SERIALIZED | 504 | Name table hashes are calculated and saved out rather than at load time |
| VER_UE4_INSTANCED_STEREO_UNIFORM_REFACTOR | 505 | Updating custom material expression nodes for instanced stereo implementation refactor |
| VER_UE4_COMPRESSED_SHADER_RESOURCES | 506 | Added compression to the shader resource for memory savings |
| VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS | 507 | Cooked files contain the dependency graph for the event driven loader (the serialization is largely independent of the use of the new loader) |
| VER_UE4_TemplateIndex_IN_COOKED_EXPORTS | 508 | Cooked files contain the TemplateIndex used by the event driven loader (the serialization is largely independent of the use of the new loader, i.e. this will be null if cooking for the old loader) |
| VER_UE4_PROPERTY_TAG_SET_MAP_SUPPORT | 509 | FPropertyTag includes contained type(s) for Set and Map properties |
| VER_UE4_ADDED_SEARCHABLE_NAMES | 510 | Added SearchableNames to the package summary and asset registry |
| VER_UE4_64BIT_EXPORTMAP_SERIALSIZES | 511 | Increased size of SerialSize and SerialOffset in export map entries to 64 bit, allow support for bigger files |
| VER_UE4_SKYLIGHT_MOBILE_IRRADIANCE_MAP | 512 | Sky light stores IrradianceMap for mobile renderer. |
| VER_UE4_ADDED_SWEEP_WHILE_WALKING_FLAG | 513 | Added flag to control sweep behavior while walking in UCharacterMovementComponent. |
| VER_UE4_ADDED_SOFT_OBJECT_PATH | 514 | StringAssetReference changed to SoftObjectPath and swapped to serialize as a name+string instead of a string |
| VER_UE4_POINTLIGHT_SOURCE_ORIENTATION | 515 | Changed the source orientation of point lights to match spot lights (z axis) |
| VER_UE4_ADDED_PACKAGE_SUMMARY_LOCALIZATION_ID | 516 | LocalizationId has been added to the package summary (editor-only) |
| VER_UE4_FIX_WIDE_STRING_CRC | 517 | Fixed case insensitive hashes of wide strings containing character values from 128-255 |
| VER_UE4_ADDED_PACKAGE_OWNER | 518 | Added package owner to allow private references |
| VER_UE4_SKINWEIGHT_PROFILE_DATA_LAYOUT_CHANGES | 519 | Changed the data layout for skin weight profile data |
| VER_UE4_NON_OUTER_PACKAGE_IMPORT | 520 | Added import that can have package different than their outer |
| VER_UE4_ASSETREGISTRY_DEPENDENCYFLAGS | 521 | Added DependencyFlags to AssetRegistry |
| VER_UE4_CORRECT_LICENSEE_FLAG | 522 | Fixed corrupt licensee flag in 4.26 assets |
| VER_UE4_AUTOMATIC_VERSION | 522 | The newest specified version of the Unreal Engine. |

```

`docs/src/api/uassetapi.unrealtypes.objectversionue5.md`:

```md
# ObjectVersionUE5

Namespace: UAssetAPI.UnrealTypes

An enum used to represent the global object version of UE5.

```csharp
public enum ObjectVersionUE5
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ObjectVersionUE5](./uassetapi.unrealtypes.objectversionue5.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.tbox-1.md`:

```md
# TBox&lt;T&gt;

Namespace: UAssetAPI.UnrealTypes

Axis-aligned box collision geometry. Consists of a core AABB with a margin.
 The margin should be considered physically part of the * box - it pads the faces and rounds the corners.

```csharp
public struct TBox<T>
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [TBox&lt;T&gt;](./uassetapi.unrealtypes.tbox-1.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Min**

```csharp
public T Min;
```

### **Max**

```csharp
public T Max;
```

### **IsValid**

```csharp
public byte IsValid;
```

## Constructors

### **TBox(T, T, Byte)**

```csharp
TBox(T min, T max, byte isValid)
```

#### Parameters

`min` T<br>

`max` T<br>

`isValid` [Byte](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **TBox(AssetBinaryReader, Func&lt;T&gt;)**

```csharp
TBox(AssetBinaryReader reader, Func<T> valueReader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`valueReader` Func&lt;T&gt;<br>

## Methods

### **Write(AssetBinaryWriter, Action&lt;T&gt;)**

```csharp
int Write(AssetBinaryWriter writer, Action<T> valueWriter)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`valueWriter` Action&lt;T&gt;<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Clone()**

```csharp
object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

```

`docs/src/api/uassetapi.unrealtypes.tmap-2.md`:

```md
# TMap&lt;TKey, TValue&gt;

Namespace: UAssetAPI.UnrealTypes

A dictionary object that allows rapid hash lookups using keys, but also
 maintains the key insertion order so that values can be retrieved by
 key index.

```csharp
public class TMap<TKey, TValue> : IOrderedDictionary`2, , , , System.Collections.IEnumerable, System.Collections.Specialized.IOrderedDictionary, System.Collections.IDictionary, System.Collections.ICollection
```

#### Type Parameters

`TKey`<br>

`TValue`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [TMap&lt;TKey, TValue&gt;](./uassetapi.unrealtypes.tmap-2.md)<br>
Implements IOrderedDictionary&lt;TKey, TValue&gt;, IDictionary&lt;TKey, TValue&gt;, ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, [IEnumerable](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable), IOrderedDictionary, [IDictionary](https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary), [ICollection](https://docs.microsoft.com/en-us/dotnet/api/system.collections.icollection)

## Properties

### **Item**

```csharp
public TValue Item { get; set; }
```

#### Property Value

TValue<br>

### **Item**

```csharp
public TValue Item { get; set; }
```

#### Property Value

TValue<br>

### **Count**

Gets the number of items in the dictionary

```csharp
public int Count { get; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **Keys**

Gets all the keys in the ordered dictionary in their proper order.

```csharp
public ICollection<TKey> Keys { get; }
```

#### Property Value

ICollection&lt;TKey&gt;<br>

### **Values**

Gets all the values in the ordered dictionary in their proper order.

```csharp
public ICollection<TValue> Values { get; }
```

#### Property Value

ICollection&lt;TValue&gt;<br>

### **Comparer**

Gets the key comparer for this dictionary

```csharp
public IEqualityComparer<TKey> Comparer { get; private set; }
```

#### Property Value

IEqualityComparer&lt;TKey&gt;<br>

## Constructors

### **TMap()**

```csharp
public TMap()
```

### **TMap(IEqualityComparer&lt;TKey&gt;)**

```csharp
public TMap(IEqualityComparer<TKey> comparer)
```

#### Parameters

`comparer` IEqualityComparer&lt;TKey&gt;<br>

### **TMap(IOrderedDictionary&lt;TKey, TValue&gt;)**

```csharp
public TMap(IOrderedDictionary<TKey, TValue> dictionary)
```

#### Parameters

`dictionary` IOrderedDictionary&lt;TKey, TValue&gt;<br>

### **TMap(IOrderedDictionary&lt;TKey, TValue&gt;, IEqualityComparer&lt;TKey&gt;)**

```csharp
public TMap(IOrderedDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey> comparer)
```

#### Parameters

`dictionary` IOrderedDictionary&lt;TKey, TValue&gt;<br>

`comparer` IEqualityComparer&lt;TKey&gt;<br>

### **TMap(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)**

```csharp
public TMap(IEnumerable<KeyValuePair<TKey, TValue>> items)
```

#### Parameters

`items` IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;<br>

### **TMap(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IEqualityComparer&lt;TKey&gt;)**

```csharp
public TMap(IEnumerable<KeyValuePair<TKey, TValue>> items, IEqualityComparer<TKey> comparer)
```

#### Parameters

`items` IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;<br>

`comparer` IEqualityComparer&lt;TKey&gt;<br>

## Methods

### **Add(TKey, TValue)**

Adds the specified key and value to the dictionary.

```csharp
public void Add(TKey key, TValue value)
```

#### Parameters

`key` TKey<br>
The key of the element to add.

`value` TValue<br>
The value of the element to add. The value can be null for reference types.

### **Clear()**

Removes all keys and values from this object.

```csharp
public void Clear()
```

### **Insert(Int32, TKey, TValue)**

Inserts a new key-value pair at the index specified.

```csharp
public void Insert(int index, TKey key, TValue value)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The insertion index. This value must be between 0 and the count of items in this object.

`key` TKey<br>
A unique key for the element to add

`value` TValue<br>
The value of the element to add. Can be null for reference types.

### **IndexOf(TKey)**

Gets the index of the key specified.

```csharp
public int IndexOf(TKey key)
```

#### Parameters

`key` TKey<br>
The key whose index will be located

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
Returns the index of the key specified if found. Returns -1 if the key could not be located.

### **ContainsValue(TValue)**

Determines whether this object contains the specified value.

```csharp
public bool ContainsValue(TValue value)
```

#### Parameters

`value` TValue<br>
The value to locate in this object.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
True if the value is found. False otherwise.

### **ContainsValue(TValue, IEqualityComparer&lt;TValue&gt;)**

Determines whether this object contains the specified value.

```csharp
public bool ContainsValue(TValue value, IEqualityComparer<TValue> comparer)
```

#### Parameters

`value` TValue<br>
The value to locate in this object.

`comparer` IEqualityComparer&lt;TValue&gt;<br>
The equality comparer used to locate the specified value in this object.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
True if the value is found. False otherwise.

### **ContainsKey(TKey)**

Determines whether this object contains the specified key.

```csharp
public bool ContainsKey(TKey key)
```

#### Parameters

`key` TKey<br>
The key to locate in this object.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
True if the key is found. False otherwise.

### **GetItem(Int32)**

Returns the KeyValuePair at the index specified.

```csharp
public KeyValuePair<TKey, TValue> GetItem(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index of the KeyValuePair desired

#### Returns

KeyValuePair&lt;TKey, TValue&gt;<br>

#### Exceptions

[ArgumentOutOfRangeException](https://docs.microsoft.com/en-us/dotnet/api/system.argumentoutofrangeexception)<br>
Thrown when the index specified does not refer to a KeyValuePair in this object

### **SetItem(Int32, TValue)**

Sets the value at the index specified.

```csharp
public void SetItem(int index, TValue value)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index of the value desired

`value` TValue<br>
The value to set

#### Exceptions

[ArgumentOutOfRangeException](https://docs.microsoft.com/en-us/dotnet/api/system.argumentoutofrangeexception)<br>
Thrown when the index specified does not refer to a KeyValuePair in this object

### **GetEnumerator()**

Returns an enumerator that iterates through all the KeyValuePairs in this object.

```csharp
public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
```

#### Returns

IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;<br>

### **Remove(TKey)**

Removes the key-value pair for the specified key.

```csharp
public bool Remove(TKey key)
```

#### Parameters

`key` TKey<br>
The key to remove from the dictionary.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
True if the item specified existed and the removal was successful. False otherwise.

### **RemoveAt(Int32)**

Removes the key-value pair at the specified index.

```csharp
public void RemoveAt(int index)
```

#### Parameters

`index` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The index of the key-value pair to remove from the dictionary.

### **GetValue(TKey)**

Gets the value associated with the specified key.

```csharp
public TValue GetValue(TKey key)
```

#### Parameters

`key` TKey<br>
The key associated with the value to get.

#### Returns

TValue<br>

### **SetValue(TKey, TValue)**

Sets the value associated with the specified key.

```csharp
public void SetValue(TKey key, TValue value)
```

#### Parameters

`key` TKey<br>
The key associated with the value to set.

`value` TValue<br>
The the value to set.

### **TryGetValue(TKey, TValue&)**

Tries to get the value associated with the specified key.

```csharp
public bool TryGetValue(TKey key, TValue& value)
```

#### Parameters

`key` TKey<br>
The key of the desired element.

`value` TValue&<br>
When this method returns, contains the value associated with the specified key if
 that key was found. Otherwise it will contain the default value for parameter's type.
 This parameter should be provided uninitialized.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
True if the value was found. False otherwise.

**Remarks:**



### **SortKeys()**

```csharp
public void SortKeys()
```

### **SortKeys(IComparer&lt;TKey&gt;)**

```csharp
public void SortKeys(IComparer<TKey> comparer)
```

#### Parameters

`comparer` IComparer&lt;TKey&gt;<br>

### **SortKeys(Comparison&lt;TKey&gt;)**

```csharp
public void SortKeys(Comparison<TKey> comparison)
```

#### Parameters

`comparison` Comparison&lt;TKey&gt;<br>

### **SortValues()**

```csharp
public void SortValues()
```

### **SortValues(IComparer&lt;TValue&gt;)**

```csharp
public void SortValues(IComparer<TValue> comparer)
```

#### Parameters

`comparer` IComparer&lt;TValue&gt;<br>

### **SortValues(Comparison&lt;TValue&gt;)**

```csharp
public void SortValues(Comparison<TValue> comparison)
```

#### Parameters

`comparison` Comparison&lt;TValue&gt;<br>

```

`docs/src/api/uassetapi.unrealtypes.tperqualitylevel-1.md`:

```md
# TPerQualityLevel&lt;T&gt;

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct TPerQualityLevel<T>
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [TPerQualityLevel&lt;T&gt;](./uassetapi.unrealtypes.tperqualitylevel-1.md)

## Fields

### **bCooked**

```csharp
public bool bCooked;
```

### **Default**

```csharp
public T Default;
```

### **PerQuality**

```csharp
public Dictionary<int, T> PerQuality;
```

## Constructors

### **TPerQualityLevel(Boolean, T, Dictionary&lt;Int32, T&gt;)**

```csharp
TPerQualityLevel(bool _bCooked, T _default, Dictionary<int, T> perQuality)
```

#### Parameters

`_bCooked` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`_default` T<br>

`perQuality` Dictionary&lt;Int32, T&gt;<br>

### **TPerQualityLevel(AssetBinaryReader, Func&lt;T&gt;)**

```csharp
TPerQualityLevel(AssetBinaryReader reader, Func<T> valueReader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`valueReader` Func&lt;T&gt;<br>

## Methods

### **Write(AssetBinaryWriter, Action&lt;T&gt;)**

```csharp
int Write(AssetBinaryWriter writer, Action<T> valueWriter)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`valueWriter` Action&lt;T&gt;<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unrealtypes.trange-1.md`:

```md
# TRange&lt;T&gt;

Namespace: UAssetAPI.UnrealTypes

```csharp
public struct TRange<T>
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [TRange&lt;T&gt;](./uassetapi.unrealtypes.trange-1.md)

## Fields

### **LowerBound**

```csharp
public TRangeBound<T> LowerBound;
```

### **UpperBound**

```csharp
public TRangeBound<T> UpperBound;
```

## Constructors

### **TRange(TRangeBound&lt;T&gt;, TRangeBound&lt;T&gt;)**

```csharp
TRange(TRangeBound<T> lowerBound, TRangeBound<T> upperBound)
```

#### Parameters

`lowerBound` TRangeBound&lt;T&gt;<br>

`upperBound` TRangeBound&lt;T&gt;<br>

### **TRange(AssetBinaryReader, Func&lt;T&gt;)**

```csharp
TRange(AssetBinaryReader reader, Func<T> valueReader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`valueReader` Func&lt;T&gt;<br>

## Methods

### **Write(AssetBinaryWriter, Action&lt;T&gt;)**

```csharp
void Write(AssetBinaryWriter writer, Action<T> valueWriter)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`valueWriter` Action&lt;T&gt;<br>

```

`docs/src/api/uassetapi.unrealtypes.trangebound-1.md`:

```md
# TRangeBound&lt;T&gt;

Namespace: UAssetAPI.UnrealTypes

Template for range bounds.

```csharp
public struct TRangeBound<T>
```

#### Type Parameters

`T`<br>

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [TRangeBound&lt;T&gt;](./uassetapi.unrealtypes.trangebound-1.md)

## Fields

### **Type**

```csharp
public ERangeBoundTypes Type;
```

### **Value**

```csharp
public T Value;
```

## Constructors

### **TRangeBound()**

```csharp
TRangeBound()
```

### **TRangeBound(ERangeBoundTypes, T)**

```csharp
TRangeBound(ERangeBoundTypes type, T value)
```

#### Parameters

`type` [ERangeBoundTypes](./uassetapi.unrealtypes.erangeboundtypes.md)<br>

`value` T<br>

### **TRangeBound(AssetBinaryReader, Func&lt;T&gt;)**

```csharp
TRangeBound(AssetBinaryReader reader, Func<T> valueReader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`valueReader` Func&lt;T&gt;<br>

## Methods

### **Write(AssetBinaryWriter, Action&lt;T&gt;)**

```csharp
void Write(AssetBinaryWriter writer, Action<T> valueWriter)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`valueWriter` Action&lt;T&gt;<br>

```

`docs/src/api/uassetapi.unrealtypes.ue4versiontoobjectversion.md`:

```md
# UE4VersionToObjectVersion

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum UE4VersionToObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [UE4VersionToObjectVersion](./uassetapi.unrealtypes.ue4versiontoobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.ue5versiontoobjectversion.md`:

```md
# UE5VersionToObjectVersion

Namespace: UAssetAPI.UnrealTypes

```csharp
public enum UE5VersionToObjectVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [UE5VersionToObjectVersion](./uassetapi.unrealtypes.ue5versiontoobjectversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unrealtypes.uniquenetidreplpropertydata.md`:

```md
# UniqueNetIdReplPropertyData

Namespace: UAssetAPI.UnrealTypes

```csharp
public class UniqueNetIdReplPropertyData : UAssetAPI.PropertyTypes.Objects.PropertyData`1[[UAssetAPI.UnrealTypes.FUniqueNetId]], System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;FUniqueNetId&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [UniqueNetIdReplPropertyData](./uassetapi.unrealtypes.uniquenetidreplpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public FUniqueNetId Value { get; set; }
```

#### Property Value

[FUniqueNetId](./uassetapi.unrealtypes.funiquenetid.md)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **UniqueNetIdReplPropertyData(FName)**

```csharp
public UniqueNetIdReplPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **UniqueNetIdReplPropertyData()**

```csharp
public UniqueNetIdReplPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unrealtypes.universalobjectlocatorfragmentpropertydata.md`:

```md
# UniversalObjectLocatorFragmentPropertyData

Namespace: UAssetAPI.UnrealTypes

```csharp
public class UniversalObjectLocatorFragmentPropertyData : UAssetAPI.PropertyTypes.Structs.StructPropertyData, System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [PropertyData](./uassetapi.propertytypes.objects.propertydata.md) → [PropertyData&lt;List&lt;PropertyData&gt;&gt;](./uassetapi.propertytypes.objects.propertydata-1.md) → [StructPropertyData](./uassetapi.propertytypes.structs.structpropertydata.md) → [UniversalObjectLocatorFragmentPropertyData](./uassetapi.unrealtypes.universalobjectlocatorfragmentpropertydata.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **FragmentTypeID**

```csharp
public FName FragmentTypeID;
```

### **StructType**

```csharp
public FName StructType;
```

### **SerializeNone**

```csharp
public bool SerializeNone;
```

### **StructGUID**

```csharp
public Guid StructGUID;
```

### **SerializationControl**

```csharp
public EClassSerializationControlExtension SerializationControl;
```

### **Operation**

```csharp
public EOverriddenPropertyOperation Operation;
```

### **Name**

The name of this property.

```csharp
public FName Name;
```

### **Ancestry**

The ancestry of this property. Contains information about all the classes/structs that this property is contained within. Not serialized.

```csharp
public AncestryInfo Ancestry;
```

### **ArrayIndex**

The array index of this property. Used to distinguish properties with the same name in the same struct.

```csharp
public int ArrayIndex;
```

### **PropertyGuid**

An optional property GUID. Nearly always null.

```csharp
public Nullable<Guid> PropertyGuid;
```

### **IsZero**

Whether or not this property is "zero," meaning that its body can be skipped during unversioned property serialization because it consists solely of null bytes.



This field will always be treated as if it is false if [PropertyData.CanBeZero(UAsset)](./uassetapi.propertytypes.objects.propertydata.md#canbezerouasset) does not return true.

```csharp
public bool IsZero;
```

### **PropertyTagFlags**

```csharp
public EPropertyTagFlags PropertyTagFlags;
```

### **PropertyTypeName**

```csharp
public FPropertyTypeName PropertyTypeName;
```

### **PropertyTagExtensions**

Optional extensions to serialize with this property.

```csharp
public EPropertyTagExtension PropertyTagExtensions;
```

### **OverrideOperation**

```csharp
public EOverriddenPropertyOperation OverrideOperation;
```

### **bExperimentalOverridableLogic**

```csharp
public bool bExperimentalOverridableLogic;
```

### **Offset**

The offset of this property on disk. This is for the user only, and has no bearing in the API itself.

```csharp
public long Offset;
```

### **Tag**

An optional tag which can be set on any property in memory. This is for the user only, and has no bearing in the API itself.

```csharp
public object Tag;
```

## Properties

### **HasCustomStructSerialization**

```csharp
public bool HasCustomStructSerialization { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **PropertyType**

```csharp
public FString PropertyType { get; }
```

#### Property Value

[FString](./uassetapi.unrealtypes.fstring.md)<br>

### **Value**

The "main value" of this property, if such a concept is applicable to the property in question. Properties may contain other values as well, in which case they will be present as other fields in the child class.

```csharp
public List<PropertyData> Value { get; set; }
```

#### Property Value

[List&lt;PropertyData&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **RawValue**

```csharp
public object RawValue { get; set; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ShouldBeRegistered**

Determines whether or not this particular property should be registered in the property registry and automatically used when parsing assets.

```csharp
public bool ShouldBeRegistered { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **DefaultValue**

The default value of this property, used as a fallback when no value is defined. Null by default.

```csharp
public object DefaultValue { get; }
```

#### Property Value

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

## Constructors

### **UniversalObjectLocatorFragmentPropertyData(FName, FName)**

```csharp
public UniversalObjectLocatorFragmentPropertyData(FName name, FName forcedType)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

`forcedType` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **UniversalObjectLocatorFragmentPropertyData(FName)**

```csharp
public UniversalObjectLocatorFragmentPropertyData(FName name)
```

#### Parameters

`name` [FName](./uassetapi.unrealtypes.fname.md)<br>

### **UniversalObjectLocatorFragmentPropertyData()**

```csharp
public UniversalObjectLocatorFragmentPropertyData()
```

## Methods

### **Read(AssetBinaryReader, Boolean, Int64, Int64, PropertySerializationContext)**

```csharp
public void Read(AssetBinaryReader reader, bool includeHeader, long leng1, long leng2, PropertySerializationContext serializationContext)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`leng1` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`leng2` [Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

### **Write(AssetBinaryWriter, Boolean, PropertySerializationContext)**

```csharp
public int Write(AssetBinaryWriter writer, bool includeHeader, PropertySerializationContext serializationContext)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

`includeHeader` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializationContext` [PropertySerializationContext](./uassetapi.propertytypes.objects.propertyserializationcontext.md)<br>

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

```

`docs/src/api/uassetapi.unversioned.ecompressionmethod.md`:

```md
# ECompressionMethod

Namespace: UAssetAPI.Unversioned

```csharp
public enum ECompressionMethod
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECompressionMethod](./uassetapi.unversioned.ecompressionmethod.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unversioned.ecustomversionserializationformat.md`:

```md
# ECustomVersionSerializationFormat

Namespace: UAssetAPI.Unversioned

```csharp
public enum ECustomVersionSerializationFormat
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ECustomVersionSerializationFormat](./uassetapi.unversioned.ecustomversionserializationformat.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unversioned.epropertytype.md`:

```md
# EPropertyType

Namespace: UAssetAPI.Unversioned

```csharp
public enum EPropertyType
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [EPropertyType](./uassetapi.unversioned.epropertytype.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unversioned.esavegamefileversion.md`:

```md
# ESaveGameFileVersion

Namespace: UAssetAPI.Unversioned

```csharp
public enum ESaveGameFileVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [ESaveGameFileVersion](./uassetapi.unversioned.esavegamefileversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unversioned.ffragment.md`:

```md
# FFragment

Namespace: UAssetAPI.Unversioned

Unversioned header fragment.

```csharp
public class FFragment
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FFragment](./uassetapi.unversioned.ffragment.md)

## Fields

### **SkipNum**

Number of properties to skip before values.

```csharp
public int SkipNum;
```

### **ValueNum**

Number of subsequent property values stored.

```csharp
public int ValueNum;
```

### **bIsLast**

Is this the last fragment of the header?

```csharp
public bool bIsLast;
```

### **FirstNum**

```csharp
public int FirstNum;
```

### **bHasAnyZeroes**

```csharp
public bool bHasAnyZeroes;
```

## Properties

### **LastNum**

```csharp
public int LastNum { get; }
```

#### Property Value

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

## Constructors

### **FFragment()**

```csharp
public FFragment()
```

### **FFragment(Int32, Int32, Boolean, Boolean, Int32)**

```csharp
public FFragment(int skipNum, int valueNum, bool bIsLast, bool bHasAnyZeroes, int firstNum)
```

#### Parameters

`skipNum` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`valueNum` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`bIsLast` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`bHasAnyZeroes` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`firstNum` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

## Methods

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **Pack()**

```csharp
public ushort Pack()
```

#### Returns

[UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

### **Unpack(UInt16)**

```csharp
public static FFragment Unpack(ushort Int)
```

#### Parameters

`Int` [UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

#### Returns

[FFragment](./uassetapi.unversioned.ffragment.md)<br>

### **GetFromBounds(Int32, Int32, Int32, Boolean, Boolean)**

```csharp
public static FFragment GetFromBounds(int LastNumBefore, int FirstNum, int LastNum, bool hasAnyZeros, bool isLast)
```

#### Parameters

`LastNumBefore` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`FirstNum` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`LastNum` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`hasAnyZeros` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`isLast` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[FFragment](./uassetapi.unversioned.ffragment.md)<br>

```

`docs/src/api/uassetapi.unversioned.funversionedheader.md`:

```md
# FUnversionedHeader

Namespace: UAssetAPI.Unversioned

List of serialized property indices and which of them are non-zero.
 Serialized as a stream of 16-bit skip-x keep-y fragments and a zero bitmask.

```csharp
public class FUnversionedHeader
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [FUnversionedHeader](./uassetapi.unversioned.funversionedheader.md)

## Fields

### **Fragments**

```csharp
public LinkedList<FFragment> Fragments;
```

### **CurrentFragment**

```csharp
public LinkedListNode<FFragment> CurrentFragment;
```

### **UnversionedPropertyIndex**

```csharp
public int UnversionedPropertyIndex;
```

### **ZeroMaskIndex**

```csharp
public int ZeroMaskIndex;
```

### **ZeroMaskNum**

```csharp
public uint ZeroMaskNum;
```

### **ZeroMask**

```csharp
public BitArray ZeroMask;
```

### **bHasNonZeroValues**

```csharp
public bool bHasNonZeroValues;
```

## Constructors

### **FUnversionedHeader(AssetBinaryReader)**

```csharp
public FUnversionedHeader(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **FUnversionedHeader()**

```csharp
public FUnversionedHeader()
```

## Methods

### **Read(AssetBinaryReader)**

```csharp
public void Read(AssetBinaryReader reader)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

### **LoadZeroMaskData(AssetBinaryReader, UInt32)**

```csharp
public void LoadZeroMaskData(AssetBinaryReader reader, uint NumBits)
```

#### Parameters

`reader` [AssetBinaryReader](./uassetapi.assetbinaryreader.md)<br>

`NumBits` [UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **SaveZeroMaskData()**

```csharp
public Byte[] SaveZeroMaskData()
```

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

### **CheckIfZeroMaskIsAllOnes()**

```csharp
public bool CheckIfZeroMaskIsAllOnes()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **Write(AssetBinaryWriter)**

```csharp
public void Write(AssetBinaryWriter writer)
```

#### Parameters

`writer` [AssetBinaryWriter](./uassetapi.assetbinarywriter.md)<br>

### **HasValues()**

```csharp
public bool HasValues()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **HasNonZeroValues()**

```csharp
public bool HasNonZeroValues()
```

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

```

`docs/src/api/uassetapi.unversioned.oodle.md`:

```md
# Oodle

Namespace: UAssetAPI.Unversioned

```csharp
public class Oodle
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Oodle](./uassetapi.unversioned.oodle.md)

## Fields

### **OODLE_DOWNLOAD_LINK**

```csharp
public static string OODLE_DOWNLOAD_LINK;
```

### **OODLE_DLL_NAME**

```csharp
public static string OODLE_DLL_NAME;
```

## Constructors

### **Oodle()**

```csharp
public Oodle()
```

## Methods

### **Decompress(Byte[], Int32, Int32)**

```csharp
public static Byte[] Decompress(Byte[] buffer, int size, int uncompressedSize)
```

#### Parameters

`buffer` [Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`size` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

`uncompressedSize` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[Byte[]](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

```

`docs/src/api/uassetapi.unversioned.savegame.md`:

```md
# SaveGame

Namespace: UAssetAPI.Unversioned

Represents an Unreal save game file. Parsing is only implemented for engine and custom version data.

```csharp
public class SaveGame
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [SaveGame](./uassetapi.unversioned.savegame.md)

## Fields

### **FilePath**

The path of the file on disk.

```csharp
public string FilePath;
```

### **SaveGameFileVersion**

```csharp
public ESaveGameFileVersion SaveGameFileVersion;
```

### **ObjectVersion**

```csharp
public ObjectVersion ObjectVersion;
```

### **ObjectVersionUE5**

```csharp
public ObjectVersionUE5 ObjectVersionUE5;
```

### **EngineVersion**

```csharp
public FEngineVersion EngineVersion;
```

### **CustomVersionSerializationFormat**

```csharp
public ECustomVersionSerializationFormat CustomVersionSerializationFormat;
```

### **CustomVersionContainer**

All the custom versions stored in the archive.

```csharp
public List<CustomVersion> CustomVersionContainer;
```

### **SAVE_MAGIC**

```csharp
public static Byte[] SAVE_MAGIC;
```

## Constructors

### **SaveGame(String)**

Reads a save game from disk and initializes a new instance of the [SaveGame](./uassetapi.unversioned.savegame.md) class to store its data in memory.



Parsing is only implemented for engine and custom version data.

```csharp
public SaveGame(string path)
```

#### Parameters

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path of the .sav file on disk that this instance will read from.

#### Exceptions

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the asset cannot be parsed correctly.

### **SaveGame()**

Initializes a new instance of the [SaveGame](./uassetapi.unversioned.savegame.md) class. This instance will store no file data and does not represent any file in particular until the [SaveGame.Read(UnrealBinaryReader)](./uassetapi.unversioned.savegame.md#readunrealbinaryreader) method is manually called.

```csharp
public SaveGame()
```

## Methods

### **PathToStream(String)**

Creates a MemoryStream from an asset path.

```csharp
public MemoryStream PathToStream(string p)
```

#### Parameters

`p` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to the input file.

#### Returns

[MemoryStream](https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream)<br>
A new MemoryStream that stores the binary data of the input file.

### **PathToReader(String)**

Creates a BinaryReader from an asset path.

```csharp
public UnrealBinaryReader PathToReader(string p)
```

#### Parameters

`p` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to the input file.

#### Returns

[UnrealBinaryReader](./uassetapi.unrealbinaryreader.md)<br>
A new BinaryReader that stores the binary data of the input file.

### **Read(UnrealBinaryReader)**

Reads a save game from disk.



Parsing is only implemented for engine and custom version data.

```csharp
public void Read(UnrealBinaryReader reader)
```

#### Parameters

`reader` [UnrealBinaryReader](./uassetapi.unrealbinaryreader.md)<br>
The binary reader to use.

### **PatchUsmap(String)**

Patches a .usmap file to contain the versioning info within this save file.

```csharp
public void PatchUsmap(string usmapPath)
```

#### Parameters

`usmapPath` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to the .usmap file to patch.

```

`docs/src/api/uassetapi.unversioned.usmap.md`:

```md
# Usmap

Namespace: UAssetAPI.Unversioned

```csharp
public class Usmap
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [Usmap](./uassetapi.unversioned.usmap.md)

## Fields

### **FilePath**

The path of the file on disk. This does not need to be specified for regular parsing.

```csharp
public string FilePath;
```

### **Version**

.usmap file version

```csharp
public UsmapVersion Version;
```

### **FileVersionUE4**

Game UE4 object version

```csharp
public ObjectVersion FileVersionUE4;
```

### **FileVersionUE5**

Game UE5 object version

```csharp
public ObjectVersionUE5 FileVersionUE5;
```

### **CustomVersionContainer**

All the custom versions stored in the archive.

```csharp
public List<CustomVersion> CustomVersionContainer;
```

### **NetCL**

```csharp
public uint NetCL;
```

### **SkipBlueprintSchemas**

Whether or not to skip blueprint schemas serialized in this mappings file. Only useful for testing.

```csharp
public bool SkipBlueprintSchemas;
```

### **NameMap**

.usmap name map

```csharp
public List<string> NameMap;
```

### **EnumMap**

.usmap enum map

```csharp
public IDictionary<string, UsmapEnum> EnumMap;
```

### **Schemas**

.usmap schema map

```csharp
public IDictionary<string, UsmapSchema> Schemas;
```

### **FailedExtensions**

List of extensions that failed to parse.

```csharp
public List<string> FailedExtensions;
```

### **PathsAlreadyProcessedForSchemas**

```csharp
public ConcurrentDictionary<string, byte> PathsAlreadyProcessedForSchemas;
```

### **USMAP_MAGIC**

Magic number for the .usmap format

```csharp
public static ushort USMAP_MAGIC;
```

## Properties

### **AreFNamesCaseInsensitive**

Whether or not FNames are case insensitive. Modifying this property is an expensive operation, and will re-construct several dictionaries.

```csharp
public bool AreFNamesCaseInsensitive { get; set; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **Usmap(String)**

Reads a .usmap file from disk and initializes a new instance of the [Usmap](./uassetapi.unversioned.usmap.md) class to store its data in memory.

```csharp
public Usmap(string path)
```

#### Parameters

`path` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path of the file file on disk that this instance will read from.

#### Exceptions

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the file cannot be parsed correctly.

### **Usmap(UsmapBinaryReader)**

Reads a .usmap file from a UsmapBinaryReader and initializes a new instance of the [Usmap](./uassetapi.unversioned.usmap.md) class to store its data in memory.

```csharp
public Usmap(UsmapBinaryReader reader)
```

#### Parameters

`reader` [UsmapBinaryReader](./uassetapi.usmapbinaryreader.md)<br>
The file's UsmapBinaryReader that this instance will read from.

#### Exceptions

[FormatException](https://docs.microsoft.com/en-us/dotnet/api/system.formatexception)<br>
Throw when the asset cannot be parsed correctly.

### **Usmap()**

Initializes a new instance of the [Usmap](./uassetapi.unversioned.usmap.md) class. This instance will store no data and does not represent any file in particular until the [Usmap.ReadHeader(UsmapBinaryReader)](./uassetapi.unversioned.usmap.md#readheaderusmapbinaryreader) method is manually called.

```csharp
public Usmap()
```

## Methods

### **SerializeJSON(Formatting)**

Serialize this usmap as JSON. This should only be used for debugging or visualization.



The serialized JSON is lossy and cannot be converted back into a complete .usmap file.

```csharp
public string SerializeJSON(Formatting jsonFormatting)
```

#### Parameters

`jsonFormatting` Formatting<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The serialized JSON as a string.

### **GetSchemaFromStructExport(String, UAsset)**

```csharp
public static UsmapSchema GetSchemaFromStructExport(string exportName, UAsset asset)
```

#### Parameters

`exportName` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

#### Returns

[UsmapSchema](./uassetapi.unversioned.usmapschema.md)<br>

### **GetSchemaFromStructExport(StructExport, Boolean)**

```csharp
public static UsmapSchema GetSchemaFromStructExport(StructExport exp, bool isCaseInsensitive)
```

#### Parameters

`exp` [StructExport](./uassetapi.exporttypes.structexport.md)<br>

`isCaseInsensitive` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[UsmapSchema](./uassetapi.unversioned.usmapschema.md)<br>

### **GetAllProperties(String, String, UAsset)**

Retrieve all the properties that a particular schema can reference.

```csharp
public IList<UsmapProperty> GetAllProperties(string schemaName, string modulePath, UAsset asset)
```

#### Parameters

`schemaName` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The name of the schema of interest.

`modulePath` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
Module path of the schema of interest.

`asset` [UAsset](./uassetapi.uasset.md)<br>
An asset to also search for schemas within.

#### Returns

[IList&lt;UsmapProperty&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ilist-1)<br>
All the properties that the schema can reference.

### **GetAllPropertiesAnnotated(String, UAsset, IDictionary&lt;String, String&gt;, Boolean, String, String)**

Retrieve all the properties that a particular schema can reference as an annotated, human-readable text file.

```csharp
public string GetAllPropertiesAnnotated(string schemaName, UAsset asset, IDictionary<string, string> customAnnotations, bool recursive, string headerPrefix, string headerSuffix)
```

#### Parameters

`schemaName` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The name of the schema of interest.

`asset` [UAsset](./uassetapi.uasset.md)<br>
An asset to also search for schemas within.

`customAnnotations` [IDictionary&lt;String, String&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.idictionary-2)<br>
A map of strings to give custom annotations.

`recursive` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not to dump data for parent schemas as well.

`headerPrefix` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The prefix of the subheader for each relevant schema.

`headerSuffix` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The suffix of the subheader for each relevant schema.

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
An annotated, human-readable text file containing the properties that the schema can reference.

### **GetSchemaFromName(String, UAsset, String, Boolean)**

```csharp
public UsmapSchema GetSchemaFromName(string nm, UAsset asset, string modulePath, bool throwExceptions)
```

#### Parameters

`nm` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`asset` [UAsset](./uassetapi.uasset.md)<br>

`modulePath` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`throwExceptions` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

#### Returns

[UsmapSchema](./uassetapi.unversioned.usmapschema.md)<br>

### **TryGetProperty&lt;T&gt;(FName, AncestryInfo, Int32, UAsset, T&, Int32&)**

Attempts to retrieve the corresponding .usmap property, given its ancestry.

```csharp
public bool TryGetProperty<T>(FName propertyName, AncestryInfo ancestry, int dupIndex, UAsset asset, T& propDat, Int32& idx)
```

#### Type Parameters

`T`<br>
The type of property to output.

#### Parameters

`propertyName` [FName](./uassetapi.unrealtypes.fname.md)<br>
The name of the property to search for.

`ancestry` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>
The ancestry of the property to search for.

`dupIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>
The duplication index of the property to search for. If unknown, set to 0.

`asset` [UAsset](./uassetapi.uasset.md)<br>
An asset to also search for schemas within.

`propDat` T&<br>
The property.

`idx` [Int32&](https://docs.microsoft.com/en-us/dotnet/api/system.int32&)<br>
The index of the property.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not the property was successfully found.

### **TryGetPropertyData&lt;T&gt;(FName, AncestryInfo, UAsset, T&)**

Attempts to retrieve the corresponding .usmap property data corresponding to a specific property, given its ancestry.

```csharp
public bool TryGetPropertyData<T>(FName propertyName, AncestryInfo ancestry, UAsset asset, T& propDat)
```

#### Type Parameters

`T`<br>
The type of property data to output.

#### Parameters

`propertyName` [FName](./uassetapi.unrealtypes.fname.md)<br>
The name of the property to search for.

`ancestry` [AncestryInfo](./uassetapi.propertytypes.objects.ancestryinfo.md)<br>
The ancestry of the property to search for.

`asset` [UAsset](./uassetapi.uasset.md)<br>
An asset to also search for schemas within.

`propDat` T&<br>
The property data.

#### Returns

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>
Whether or not the property data was successfully found.

### **PathToStream(String)**

Creates a MemoryStream from an asset path.

```csharp
public static MemoryStream PathToStream(string p)
```

#### Parameters

`p` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to the input file.

#### Returns

[MemoryStream](https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream)<br>
A new MemoryStream that stores the binary data of the input file.

### **PathToReader(String)**

Creates a BinaryReader from an asset path.

```csharp
public UsmapBinaryReader PathToReader(string p)
```

#### Parameters

`p` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>
The path to the input file.

#### Returns

[UsmapBinaryReader](./uassetapi.usmapbinaryreader.md)<br>
A new BinaryReader that stores the binary data of the input file.

### **ReadHeader(UsmapBinaryReader)**

```csharp
public UsmapBinaryReader ReadHeader(UsmapBinaryReader reader)
```

#### Parameters

`reader` [UsmapBinaryReader](./uassetapi.usmapbinaryreader.md)<br>

#### Returns

[UsmapBinaryReader](./uassetapi.usmapbinaryreader.md)<br>

### **Read(UsmapBinaryReader)**

```csharp
public void Read(UsmapBinaryReader compressedReader)
```

#### Parameters

`compressedReader` [UsmapBinaryReader](./uassetapi.usmapbinaryreader.md)<br>

```

`docs/src/api/uassetapi.unversioned.usmaparraydata.md`:

```md
# UsmapArrayData

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapArrayData : UsmapPropertyData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UsmapPropertyData](./uassetapi.unversioned.usmappropertydata.md) → [UsmapArrayData](./uassetapi.unversioned.usmaparraydata.md)

## Fields

### **InnerType**

```csharp
public UsmapPropertyData InnerType;
```

### **Type**

```csharp
public EPropertyType Type;
```

## Constructors

### **UsmapArrayData(EPropertyType)**

```csharp
public UsmapArrayData(EPropertyType type)
```

#### Parameters

`type` [EPropertyType](./uassetapi.unversioned.epropertytype.md)<br>

## Methods

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unversioned.usmapenum.md`:

```md
# UsmapEnum

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapEnum
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UsmapEnum](./uassetapi.unversioned.usmapenum.md)

## Fields

### **Name**

```csharp
public string Name;
```

### **ModulePath**

```csharp
public string ModulePath;
```

### **EnumFlags**

```csharp
public int EnumFlags;
```

### **Values**

```csharp
public ConcurrentDictionary<long, string> Values;
```

## Constructors

### **UsmapEnum(String, ConcurrentDictionary&lt;Int64, String&gt;)**

```csharp
public UsmapEnum(string name, ConcurrentDictionary<long, string> values)
```

#### Parameters

`name` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`values` ConcurrentDictionary&lt;Int64, String&gt;<br>

### **UsmapEnum()**

```csharp
public UsmapEnum()
```

```

`docs/src/api/uassetapi.unversioned.usmapenumdata.md`:

```md
# UsmapEnumData

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapEnumData : UsmapPropertyData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UsmapPropertyData](./uassetapi.unversioned.usmappropertydata.md) → [UsmapEnumData](./uassetapi.unversioned.usmapenumdata.md)

## Fields

### **InnerType**

```csharp
public UsmapPropertyData InnerType;
```

### **Name**

```csharp
public string Name;
```

### **Values**

```csharp
public List<string> Values;
```

### **Type**

```csharp
public EPropertyType Type;
```

## Constructors

### **UsmapEnumData(String, List&lt;String&gt;)**

```csharp
public UsmapEnumData(string name, List<string> values)
```

#### Parameters

`name` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`values` [List&lt;String&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1)<br>

### **UsmapEnumData()**

```csharp
public UsmapEnumData()
```

## Methods

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unversioned.usmapextensionlayoutversion.md`:

```md
# UsmapExtensionLayoutVersion

Namespace: UAssetAPI.Unversioned

```csharp
public enum UsmapExtensionLayoutVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [UsmapExtensionLayoutVersion](./uassetapi.unversioned.usmapextensionlayoutversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| Initial | 0 | Initial format. |

```

`docs/src/api/uassetapi.unversioned.usmapmapdata.md`:

```md
# UsmapMapData

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapMapData : UsmapPropertyData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UsmapPropertyData](./uassetapi.unversioned.usmappropertydata.md) → [UsmapMapData](./uassetapi.unversioned.usmapmapdata.md)

## Fields

### **InnerType**

```csharp
public UsmapPropertyData InnerType;
```

### **ValueType**

```csharp
public UsmapPropertyData ValueType;
```

### **Type**

```csharp
public EPropertyType Type;
```

## Constructors

### **UsmapMapData()**

```csharp
public UsmapMapData()
```

## Methods

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unversioned.usmapproperty.md`:

```md
# UsmapProperty

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapProperty : System.ICloneable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UsmapProperty](./uassetapi.unversioned.usmapproperty.md)<br>
Implements [ICloneable](https://docs.microsoft.com/en-us/dotnet/api/system.icloneable)

## Fields

### **Name**

```csharp
public string Name;
```

### **SchemaIndex**

```csharp
public ushort SchemaIndex;
```

### **ArrayIndex**

```csharp
public ushort ArrayIndex;
```

### **ArraySize**

```csharp
public byte ArraySize;
```

### **PropertyFlags**

```csharp
public EPropertyFlags PropertyFlags;
```

### **PropertyData**

```csharp
public UsmapPropertyData PropertyData;
```

## Constructors

### **UsmapProperty(String, UInt16, UInt16, Byte, UsmapPropertyData)**

```csharp
public UsmapProperty(string name, ushort schemaIndex, ushort arrayIndex, byte arraySize, UsmapPropertyData propertyData)
```

#### Parameters

`name` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`schemaIndex` [UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

`arrayIndex` [UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

`arraySize` [Byte](https://docs.microsoft.com/en-us/dotnet/api/system.byte)<br>

`propertyData` [UsmapPropertyData](./uassetapi.unversioned.usmappropertydata.md)<br>

## Methods

### **Clone()**

```csharp
public object Clone()
```

#### Returns

[Object](https://docs.microsoft.com/en-us/dotnet/api/system.object)<br>

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unversioned.usmappropertydata.md`:

```md
# UsmapPropertyData

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapPropertyData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UsmapPropertyData](./uassetapi.unversioned.usmappropertydata.md)

## Fields

### **Type**

```csharp
public EPropertyType Type;
```

## Constructors

### **UsmapPropertyData(EPropertyType)**

```csharp
public UsmapPropertyData(EPropertyType type)
```

#### Parameters

`type` [EPropertyType](./uassetapi.unversioned.epropertytype.md)<br>

### **UsmapPropertyData()**

```csharp
public UsmapPropertyData()
```

## Methods

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unversioned.usmapschema.md`:

```md
# UsmapSchema

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapSchema
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UsmapSchema](./uassetapi.unversioned.usmapschema.md)

## Fields

### **Name**

```csharp
public string Name;
```

### **SuperType**

```csharp
public string SuperType;
```

### **SuperTypeModulePath**

```csharp
public string SuperTypeModulePath;
```

### **PropCount**

```csharp
public ushort PropCount;
```

### **ModulePath**

```csharp
public string ModulePath;
```

### **FromAsset**

Whether or not this schema was retrieved from a .uasset file.

```csharp
public bool FromAsset;
```

### **StructKind**

```csharp
public UsmapStructKind StructKind;
```

### **StructOrClassFlags**

```csharp
public int StructOrClassFlags;
```

## Properties

### **Properties**

```csharp
public IReadOnlyDictionary<int, UsmapProperty> Properties { get; }
```

#### Property Value

[IReadOnlyDictionary&lt;Int32, UsmapProperty&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2)<br>

## Constructors

### **UsmapSchema(String, String, UInt16, ConcurrentDictionary&lt;Int32, UsmapProperty&gt;, Boolean, String, Boolean)**

```csharp
public UsmapSchema(string name, string superType, ushort propCount, ConcurrentDictionary<int, UsmapProperty> props, bool isCaseInsensitive, string superTypeModulePath, bool fromAsset)
```

#### Parameters

`name` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`superType` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`propCount` [UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

`props` ConcurrentDictionary&lt;Int32, UsmapProperty&gt;<br>

`isCaseInsensitive` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`superTypeModulePath` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`fromAsset` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **UsmapSchema()**

```csharp
public UsmapSchema()
```

## Methods

### **GetProperty(String, Int32)**

```csharp
public UsmapProperty GetProperty(string key, int dupIndex)
```

#### Parameters

`key` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

`dupIndex` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[UsmapProperty](./uassetapi.unversioned.usmapproperty.md)<br>

### **ConstructPropertiesMap(Boolean)**

```csharp
public void ConstructPropertiesMap(bool isCaseInsensitive)
```

#### Parameters

`isCaseInsensitive` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

```

`docs/src/api/uassetapi.unversioned.usmapschemapropertiesjsonconverter.md`:

```md
# UsmapSchemaPropertiesJsonConverter

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapSchemaPropertiesJsonConverter : Newtonsoft.Json.JsonConverter`1[[System.Collections.Generic.IReadOnlyDictionary`2[[System.Int32],[UAssetAPI.Unversioned.UsmapProperty]]]]
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → JsonConverter → JsonConverter&lt;IReadOnlyDictionary&lt;Int32, UsmapProperty&gt;&gt; → [UsmapSchemaPropertiesJsonConverter](./uassetapi.unversioned.usmapschemapropertiesjsonconverter.md)

## Properties

### **CanRead**

```csharp
public bool CanRead { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

### **CanWrite**

```csharp
public bool CanWrite { get; }
```

#### Property Value

[Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

## Constructors

### **UsmapSchemaPropertiesJsonConverter()**

```csharp
public UsmapSchemaPropertiesJsonConverter()
```

## Methods

### **ReadJson(JsonReader, Type, IReadOnlyDictionary&lt;Int32, UsmapProperty&gt;, Boolean, JsonSerializer)**

```csharp
public IReadOnlyDictionary<int, UsmapProperty> ReadJson(JsonReader reader, Type objectType, IReadOnlyDictionary<int, UsmapProperty> existingValue, bool hasExistingValue, JsonSerializer serializer)
```

#### Parameters

`reader` JsonReader<br>

`objectType` [Type](https://docs.microsoft.com/en-us/dotnet/api/system.type)<br>

`existingValue` [IReadOnlyDictionary&lt;Int32, UsmapProperty&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2)<br>

`hasExistingValue` [Boolean](https://docs.microsoft.com/en-us/dotnet/api/system.boolean)<br>

`serializer` JsonSerializer<br>

#### Returns

[IReadOnlyDictionary&lt;Int32, UsmapProperty&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2)<br>

### **WriteJson(JsonWriter, IReadOnlyDictionary&lt;Int32, UsmapProperty&gt;, JsonSerializer)**

```csharp
public void WriteJson(JsonWriter writer, IReadOnlyDictionary<int, UsmapProperty> value, JsonSerializer serializer)
```

#### Parameters

`writer` JsonWriter<br>

`value` [IReadOnlyDictionary&lt;Int32, UsmapProperty&gt;](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2)<br>

`serializer` JsonSerializer<br>

```

`docs/src/api/uassetapi.unversioned.usmapstructdata.md`:

```md
# UsmapStructData

Namespace: UAssetAPI.Unversioned

```csharp
public class UsmapStructData : UsmapPropertyData
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [UsmapPropertyData](./uassetapi.unversioned.usmappropertydata.md) → [UsmapStructData](./uassetapi.unversioned.usmapstructdata.md)

## Fields

### **StructType**

```csharp
public string StructType;
```

### **Type**

```csharp
public EPropertyType Type;
```

## Constructors

### **UsmapStructData(String)**

```csharp
public UsmapStructData(string structType)
```

#### Parameters

`structType` [String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **UsmapStructData()**

```csharp
public UsmapStructData()
```

## Methods

### **ToString()**

```csharp
public string ToString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/api/uassetapi.unversioned.usmapstructkind.md`:

```md
# UsmapStructKind

Namespace: UAssetAPI.Unversioned

```csharp
public enum UsmapStructKind
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [UsmapStructKind](./uassetapi.unversioned.usmapstructkind.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |

```

`docs/src/api/uassetapi.unversioned.usmapversion.md`:

```md
# UsmapVersion

Namespace: UAssetAPI.Unversioned

```csharp
public enum UsmapVersion
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [ValueType](https://docs.microsoft.com/en-us/dotnet/api/system.valuetype) → [Enum](https://docs.microsoft.com/en-us/dotnet/api/system.enum) → [UsmapVersion](./uassetapi.unversioned.usmapversion.md)<br>
Implements [IComparable](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable), [ISpanFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.ispanformattable), [IFormattable](https://docs.microsoft.com/en-us/dotnet/api/system.iformattable), [IConvertible](https://docs.microsoft.com/en-us/dotnet/api/system.iconvertible)

## Fields

| Name | Value | Description |
| --- | --: | --- |
| Initial | 0 | Initial format. |
| PackageVersioning | 1 | Adds optional asset package versioning |
| LongFName | 2 | 16-bit wide names in name map |
| LargeEnums | 3 | 16-bit enum entry count |
| ExplicitEnumValues | 4 | Adds enum values (instead of assuming ordinal) |

```

`docs/src/api/uassetapi.usmapbinaryreader.md`:

```md
# UsmapBinaryReader

Namespace: UAssetAPI

Reads primitive data types from .usmap files.

```csharp
public class UsmapBinaryReader : System.IO.BinaryReader, System.IDisposable
```

Inheritance [Object](https://docs.microsoft.com/en-us/dotnet/api/system.object) → [BinaryReader](https://docs.microsoft.com/en-us/dotnet/api/system.io.binaryreader) → [UsmapBinaryReader](./uassetapi.usmapbinaryreader.md)<br>
Implements [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable)

## Fields

### **File**

```csharp
public Usmap File;
```

## Properties

### **BaseStream**

```csharp
public Stream BaseStream { get; }
```

#### Property Value

[Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

## Constructors

### **UsmapBinaryReader(Stream, Usmap)**

```csharp
public UsmapBinaryReader(Stream stream, Usmap file)
```

#### Parameters

`stream` [Stream](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream)<br>

`file` [Usmap](./uassetapi.unversioned.usmap.md)<br>

## Methods

### **ReadInt16()**

```csharp
public short ReadInt16()
```

#### Returns

[Int16](https://docs.microsoft.com/en-us/dotnet/api/system.int16)<br>

### **ReadUInt16()**

```csharp
public ushort ReadUInt16()
```

#### Returns

[UInt16](https://docs.microsoft.com/en-us/dotnet/api/system.uint16)<br>

### **ReadInt32()**

```csharp
public int ReadInt32()
```

#### Returns

[Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

### **ReadUInt32()**

```csharp
public uint ReadUInt32()
```

#### Returns

[UInt32](https://docs.microsoft.com/en-us/dotnet/api/system.uint32)<br>

### **ReadInt64()**

```csharp
public long ReadInt64()
```

#### Returns

[Int64](https://docs.microsoft.com/en-us/dotnet/api/system.int64)<br>

### **ReadUInt64()**

```csharp
public ulong ReadUInt64()
```

#### Returns

[UInt64](https://docs.microsoft.com/en-us/dotnet/api/system.uint64)<br>

### **ReadSingle()**

```csharp
public float ReadSingle()
```

#### Returns

[Single](https://docs.microsoft.com/en-us/dotnet/api/system.single)<br>

### **ReadDouble()**

```csharp
public double ReadDouble()
```

#### Returns

[Double](https://docs.microsoft.com/en-us/dotnet/api/system.double)<br>

### **ReadString()**

```csharp
public string ReadString()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **ReadString(Int32)**

```csharp
public string ReadString(int fixedLength)
```

#### Parameters

`fixedLength` [Int32](https://docs.microsoft.com/en-us/dotnet/api/system.int32)<br>

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

### **ReadName()**

```csharp
public string ReadName()
```

#### Returns

[String](https://docs.microsoft.com/en-us/dotnet/api/system.string)<br>

```

`docs/src/guide/basic.md`:

```md
# Basic Usage

### Prerequisites
* Basic C# knowledge
* Visual Studio 2022 or later, with .NET 8.0 SDK
* [A copy of UAssetAPI](./build.md)

### Basic Project Setup
In this short guide, we will go over the very basics of parsing assets through UAssetAPI.

UAssetAPI targets [.NET 8.0](https://dotnet.microsoft.com/en-us/download/dotnet/8.0), which means you will need the .NET 8.0 SDK to use UAssetAPI. We will start off in this specific guide by creating a new C# Console App project in Visual Studio, making sure we specifically target .NET 8.0:

![](./img/basic1.png)
![](./img/basic2.png)
![](./img/basic2_1.png)

Once we have entered Visual Studio, we must add a new reference to our UAssetAPI.dll file. This can be done by right-clicking under "References," clicking "Add Reference," clicking "Browse" in the bottom right of the Reference Manager window, browsing to your UAssetAPI.dll file on disk, and clicking "OK".

![](./img/basic3.png)
![](./img/basic4.png)

Once you've referenced the UAssetAPI assembly in your project, you're ready to start parsing assets!

## Using UAssetAPI with Unreal Assets
### Modifying a specific property

Every Unreal Engine 4 asset parsed with UAssetAPI is represented by the [UAsset](../api/uassetapi.uasset.md#constructors) class. The simplest way to construct a UAsset is to initialize it with the path to the asset on disk (note that if your asset has a paired .uexp file, both files must be located in the same directory, and the path should point to the .uasset file) and an [EngineVersion](../api/uassetapi.unrealtypes.engineversion.html#fields).

I will be analyzing a small asset from the video game [Ace Combat 7](https://www.bandainamcoent.com/games/ace-combat-7) (4.18) for this demonstration, which can be downloaded here:
- [plwp_6aam_a0.uasset](../samples/plwp_6aam_a0.uasset) &rarr; `C:\plwp_6aam_a0.uasset`
- [plwp_6aam_a0.uexp](../samples/plwp_6aam_a0.uexp) &rarr; `C:\plwp_6aam_a0.uasset`

Save these files to those respective locations.

If you are familiar with UAssetGUI or other tools for reverse-engineering Unreal Engine 4 assets, you will likely be aware that there are generally at least five major sections to any asset, each of which can be read and modified through UAssetAPI.

For now, let's simply modify an integer. If we open the asset in UAssetGUI and look under "Export Data," we can see all the exports that we can access; for our demonstration here, we're interested in Export 2, and we'll be modifying the "MaxRotationAngle" float.

![](./img/basic5.png)

Let's start programming! Head to the `Program.cs` file and use the following pre-written code, placed in `static void Main(string[] args)` (feel free to copy and paste):
```cs
// Instantiate the asset with the path and the engine version (4.18).
// This reads the entire asset to memory at once; use a different constructor with an AssetBinaryReader if you don't want that
UAsset myAsset = new UAsset("C:\\plwp_6aam_a0.uasset", EngineVersion.VER_UE4_18);

// We want the 2nd export, so we reference the export at index 1.
// There are many types, but any export that has regular "tagged" data like you see as properties in UAssetGUI can be cast to a NormalExport, like this one.
NormalExport myExport = (NormalExport)myAsset.Exports[1];
// Alternatively, we can reference exports by ObjectName:
// NormalExport myExport = (NormalExport)myAsset.Exports["Default__plwp_6aam_a0_C"];
// we implement the general algorithm used by UAssetAPI here later in the guide

// myExport.Data will give us a List<PropertyData> which you can enumerate if you like, but we can reference a property by name or index with the export directly.
// We know this is a FloatPropertyData because it is serialized as a FloatProperty. BoolPropertyData is a BoolProperty, ObjectPropertyData is an ObjectProperty, etc.
FloatPropertyData myFloat = (FloatPropertyData)myExport["MaxRotationAngle"];
Console.WriteLine(myFloat.Value);

// All we have to do to change this value is to set myFloat.Value, and we'll be ready to re-save the asset.
myFloat.Value = 1337;

// Save the asset back to disk with UAsset.Write and a path.
myAsset.Write("NEW.uasset");

Console.WriteLine("All done!");
Console.ReadLine();
```

The above code is an example on how we can pinpoint and modify a specific asset; running it will output a `NEW.uasset` file in the current working directory (which you can access by right-clicking your project in the Solution Explorer, clicking "Open Folder in File Explorer", and navigating to "bin/Debug") with the modified float. You can verify the change for yourself in UAssetGUI.

### More advanced modification

What if we don't know where the property is? If we don't know the exact contents of the asset before we load it, we may have to perform more advanced modification techniques based on what information we do know.

Let's say we want to modify a specific NameProperty called `InternalVariableName` in an export with the ObjectName `SCS_Node_1` (you can see this in UAssetGUI under the Export Information tab). Using the same file as above, we'll need to iterate through our exports until we find the appropriate property:

```cs
// Instantiate the asset with the path and the engine version (4.18).
// This reads the entire asset to memory at once; use a different constructor with an AssetBinaryReader if you don't want that
UAsset myAsset = new UAsset("C:\\plwp_6aam_a0.uasset", EngineVersion.VER_UE4_18);

// Iterate through all the exports
foreach (Export export in myAsset.Exports)
{
    if (!(export is NormalExport normalExport)) continue; // We know our export is a NormalExport, so if this export isn't one, it's useless to us
    if (export.ObjectName.ToString() == "SCS_Node_1") // Check; do we have the right name?
    {
        // Create a new NamePropertyData with our desired value
        normalExport["InternalVariableName"].RawValue = FName.FromString(myAsset, "Howdy!");
        break;
    }
}

// Save the asset back to disk with UAsset.Write and a path.
myAsset.Write("NEW.uasset");

Console.WriteLine("All done!");
Console.ReadLine();
```

Under the scene, we're actually doing quite a lot here:
- First, we iterate through every export.
- For every export, if it's a NormalExport, we access its ObjectName field, which is an FName object. FName objects consist of two integers, an INDEX and a VALUE. When we convert it to a string, we access the name map with the INDEX to retrieve `SCS_Node`, and suffix it with the VALUE as `_1`.
- We access the InternalVariableName property, and set its `RawValue` property. `RawValue` is a property present on all `PropertyData` objects which simply allows you to access the object's `Value` field as an `object`. We could also do `(NamePropertyData)(normalExport["InternalVariableName"]).Value` here instead.
- We create a new FName object with `FName.FromString`, which performs the inverse operation of `.ToString()`. This method will automatically add an entry at the end of the name map.

At the end of the day, we have made no assumptions about the ordering of the exports or properties, and have still performed the operation.

### Final Notes

UAssetAPI is only one layer of abstraction above the raw binary format, which means that it essentially gives you full access to every single aspect of a .uasset file. This means that performing very complex operations can be quite a challenge, so keep experimenting!

You may find it useful while learning to export assets into JSON through the `.SerializeJSON()` method or through UAssetGUI, as the JSON format very closely mirrors the way that assets are laid out in UAssetAPI. You can also find some more examples for UAssetAPI syntax and usage under the [More Examples](extras.md) page, and even more examples in the [unit tests](https://github.com/atenfyr/UAssetAPI/blob/master/UAssetAPI.Tests/AssetUnitTests.cs).

```

`docs/src/guide/build.md`:

```md
# Build Instructions

### Prerequisites
* Visual Studio 2022 or later, with .NET 8.0 SDK
* Git

### Initial Setup
1. Clone the UAssetAPI repository:

```sh
git clone https://github.com/atenfyr/UAssetAPI.git
```

2. Open the `UAssetAPI.sln` solution file within the newly-created UAssetAPI directory in Visual Studio, right-click on the solution name in the Solution Explorer, and press "Restore Nuget Packages."

3. Press F6 or right-click the solution name in the Solution Explorer and press "Build Solution" to compile UAssetAPI, which will be written as a .dll file to the `bin` directory. Note that this solution does not include UAssetGUI.
```

`docs/src/guide/extras.md`:

```md
# More Examples

This page contains several more examples of UAssetAPI usage for completing specific tasks.

### A simple, complete example
```cs
UAsset myAsset = new UAsset("C:\\plwp_6aam_a0.uasset", EngineVersion.VER_UE4_18);

// Find the export with the name "Default__plwp_6aam_a0_C"
NormalExport cdoExport = (NormalExport)myAsset["Default__plwp_6aam_a0_C"];
// Add/replace a property called SpeedMaximum
cdoExport["SpeedMaximum"] = new FloatPropertyData() { Value = 999999 };
// or, modify it directly
FloatPropertyData SpeedMaximum = (FloatPropertyData)cdoExport["SpeedMaximum"];
SpeedMaximum.Value = 999999;

myAsset.Write("C:\\NEW.uasset");
```

### Finding specific exports
```cs
UAsset myAsset = new UAsset("C:\\plwp_6aam_a0.uasset", EngineVersion.VER_UE4_18);

// We can find specific exports by index:
Export cdo = myAsset.Exports[1]; // Export 2; here, indexing from 0
// or like this:
cdo = new FPackageIndex(2).ToExport(myAsset); // also Export 2; FPackageIndex uses negative numbers for imports, 0 for null, and positive numbers for exports
// or, by ObjectName:
cdo = myAsset["Default__plwp_6aam_a0_C"]; // you can find this string value e.g. in UAssetGUI
cdo = myAsset[new FName(myAsset, "Default__plwp_6aam_a0_C")];
// or, to locate the ClassDefaultObject:
foreach (Export exp in myAsset.Exports)
{
    if (exp.ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject))
    {
        cdo = exp;
        break;
    }
}
// or, based on any property; maybe by SerialSize (length on disk):
long maxSerialSize = -1;
foreach (Export exp in myAsset.Exports)
{
    if (exp.SerialSize > maxSerialSize)
    {
        maxSerialSize = exp.SerialSize;
        cdo = exp;
    }
}
```

### Accessing basic export types and property types
```cs
UAsset myAsset = new UAsset("C:\\plwp_6aam_a0.uasset", EngineVersion.VER_UE4_18);
Export exp = myAsset["Default__plwp_6aam_a0_C"];

// Export contains all fields contained within UAssetGUI's "Export Information"
// to manipulate data under "Export Data," you generally need to cast it to a child type

// NormalExport contains most all "normal" data, i.e. standard tagged properties
if (exp is NormalExport normalExport)
{
    for (int i = 0; i < normalExport.Data.Count; i++)
    {
        PropertyData prop = normalExport.Data[i];
        Console.WriteLine(prop.Name.ToString() + ": " + prop.PropertyType.ToString());

        // you can access prop.Value for many types, but for other types, you can cast to a child type and access other fields
        if (prop is FloatPropertyData floatProp) floatProp.Value = 60; // change all floats to = 60

        // ArrayPropertyData.Value is a PropertyData[] array, entries referenced by index
        // StructPropertyData.Value is a List<PropertyData>, or you can index StructPropertyData directly
        if (prop is ArrayPropertyData arrProp)
        {
            for (int j = 0; j < arrProp.Value.Length; j++)
            {
                PropertyData prop2 = arrProp.Value[j];
                Console.WriteLine(prop2.Name.ToString() + ": " + prop2.PropertyType.ToString());
                // etc.
                // note that arrays and structs can contain arrays and structs too...
            }
        }

        if (prop is StructPropertyData structProp)
        {
            for (int j = 0; j < structProp.Value.Count; j++)
            {
                PropertyData prop2 = structProp.Value[j];
                Console.WriteLine(prop2.Name.ToString() + ": " + prop2.PropertyType.ToString());
                // etc.
                // note that arrays and structs can contain arrays and structs too...
            }

            // or:
            // PropertyData prop2 = structProp["PropertyNameHere"];
        }
    }
}

// DataTableExport is a NormalExport, but also contains entries in DataTables
if (exp is DataTableExport dtExport)
{
    // dtExport.Data exists, but it typically only contains struct type information
    // to access other entries, use:
    List<StructPropertyData> entries = dtExport.Table.Data;

    // etc.
}

// RawExport is an export that failed to parse for some reason, but you can still access and modify its binary data
if (exp is RawExport rawExport)
{
    byte[] rawData = rawExport.Data;

    // etc.
}

// see other examples for more advanced export types!
```

### Duplicating properties
```cs
UAsset myAsset = new UAsset("C:\\plwp_6aam_a0.uasset", EngineVersion.VER_UE4_18);
NormalExport cdoExport = (NormalExport)myAsset["Default__plwp_6aam_a0_C"];

FloatPropertyData targetProp = (FloatPropertyData)cdoExport["SpeedMaximum"];

// if we try something like:

/*
FloatPropertyData newProp = targetProp;
newProp.Value = 999999;
*/

// we'll accidentally change the value of targetProp too!
// we can duplicate this property using .Clone() instead:

FloatPropertyData newProp = (FloatPropertyData)targetProp.Clone();
newProp.Value = 999999;
cdoExport["SpeedMaximum2"] = newProp;

// .Clone() performs a deep copy, so you can e.g. clone a StructProperty and modify child properties freely
// .Clone() on an Export directly, however, is not implemented properly for child export types (e.g. the .Data list of a NormalExport is not cloned)
```

### Read assets that use unversioned properties
```cs
// to read an asset that uses unversioned properties, you must first source a .usmap mappings file for the game the asset is from, e.g. with UE4SS
// you can read a mappings file with the Usmap class, and pass it into the UAsset constructor
Usmap mappings = new Usmap("C:\\MyGame.usmap");
UAsset myAsset = new UAsset("C:\\my_asset.uasset", EngineVersion.VER_UE5_3, mappings);

// then, read and write data as normal
// myAsset.HasUnversionedProperties will return true

// notes for the curious:
// * using the FName constructor adds new entries to the name map, which is often frivolous with unversioned properties; if you care, use FName.DefineDummy instead, but if UAssetAPI tries to write a dummy FName to disk it will throw an exception
// * UAssetAPI only supports reading .usmap files, not writing
// * UAssetAPI supports .usmap versions 0 through 3, uncompressed and zstandard-compressed files, and PPTH/EATR/ENVP extensions
```

### Interface with JSON
```cs
UAsset myAsset = new UAsset("C:\\plwp_6aam_a0.uasset", EngineVersion.VER_UE4_18);

// write asset to JSON
string jsonSerializedAsset = tester.SerializeJson();
File.WriteAllText("C:\\plwp_6aam_a0.json", jsonSerializedAsset);

// read asset back from JSON
UAsset myAsset2 = UAsset.DeserializeJson("C:\\plwp_6aam_a0.json");
// myAsset2 should contain the same information as myAsset

// write asset to binary format
myAsset2.Write("C:\\plwp_6aam_a0_NEW.uasset");
```

### Read and modify blueprint bytecode
```cs
UAsset myAsset = new UAsset("C:\\my_asset.uasset", EngineVersion.VER_UE4_18);

// all StructExport exports can contain blueprint bytecode, let's pretend Export 1 is a StructExport
StructExport myStructExport = (StructExport)myAsset.Exports[0];

KismetExpression[] bytecode = myStructExport.ScriptBytecode;
if (bytecode != null) // bytecode may fail to parse, in which case it will be null and stored raw in ScriptBytecodeRaw
{
    // KismetExpression has many child classes, one child class for each type of instruction
    // as with PropertyData, you can access .RawValue for many instruction types, but you'll need to cast for other kinds of instructions to access specific fields
    foreach (KismetExpression instruction in bytecode)
    {
        Console.WriteLine(instruction.Token.ToString() + ": " + instruction.RawValue.ToString());
    }
}
```
```