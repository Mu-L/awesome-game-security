Project Path: arc_jackpal_Android-Terminal-Emulator_3uar9s1r

Source Tree:

```txt
arc_jackpal_Android-Terminal-Emulator_3uar9s1r
├── LICENSE
├── MODULE_LICENSE_APACHE2
├── NOTICE
├── README.md
├── artwork
│   ├── Feature Graphic.xcf
│   ├── android-terminal-emulator-512.png
│   └── android-terminal-emulator.svg
├── build.gradle
├── docs
│   ├── Building.md
│   ├── UTF-8-SMP-chars-demo.txt
│   ├── UTF-8-demo.txt
│   ├── atari_small_notice.txt
│   ├── notification icon source.png
│   └── releaseChecklist.md
├── emulatorview
│   ├── build.gradle
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── java
│           │   └── jackpal
│           │       └── androidterm
│           │           └── emulatorview
│           │               ├── BaseTextRenderer.java
│           │               ├── Bitmap4x8FontRenderer.java
│           │               ├── ByteQueue.java
│           │               ├── ColorScheme.java
│           │               ├── EmulatorDebug.java
│           │               ├── EmulatorView.java
│           │               ├── GrowableIntArray.java
│           │               ├── PaintRenderer.java
│           │               ├── Screen.java
│           │               ├── StyleRow.java
│           │               ├── TermKeyListener.java
│           │               ├── TermSession.java
│           │               ├── TerminalEmulator.java
│           │               ├── TextRenderer.java
│           │               ├── TextStyle.java
│           │               ├── TranscriptScreen.java
│           │               ├── UnicodeTranscript.java
│           │               ├── UpdateCallback.java
│           │               ├── compat
│           │               │   ├── AndroidCharacterCompat.java
│           │               │   ├── AndroidCompat.java
│           │               │   ├── ClipboardManagerCompat.java
│           │               │   ├── ClipboardManagerCompatFactory.java
│           │               │   ├── ClipboardManagerCompatV1.java
│           │               │   ├── ClipboardManagerCompatV11.java
│           │               │   ├── KeyCharacterMapCompat.java
│           │               │   ├── KeycodeConstants.java
│           │               │   └── Patterns.java
│           │               └── package.html
│           └── res
│               ├── drawable
│               │   └── atari_small.png
│               └── drawable-nodpi
│                   └── atari_small_nodpi.png
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── libtermexec
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       ├── androidTest
│       │   └── java
│       │       └── jackpal
│       │           └── androidterm
│       │               └── libtermexec
│       │                   └── ApplicationTest.java
│       └── main
│           ├── AndroidManifest.xml
│           ├── aidl
│           │   └── jackpal
│           │       └── androidterm
│           │           └── libtermexec
│           │               └── v1
│           │                   └── ITerminal.aidl
│           ├── java
│           │   └── jackpal
│           │       └── androidterm
│           │           └── TermExec.java
│           └── jni
│               ├── process.cpp
│               └── process.h
├── samples
│   ├── intents
│   │   ├── build.gradle
│   │   ├── lint.xml
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── java
│   │           │   └── jackpal
│   │           │       └── androidterm
│   │           │           └── sample
│   │           │               └── intents
│   │           │                   └── IntentSampleActivity.java
│   │           └── res
│   │               ├── layout
│   │               │   └── main.xml
│   │               ├── values
│   │               │   └── strings.xml
│   │               ├── values-ja
│   │               │   └── strings.xml
│   │               └── values-ko
│   │                   └── strings.xml
│   ├── pathbroadcasts
│   │   ├── build.gradle
│   │   └── src
│   │       └── main
│   │           ├── AndroidManifest.xml
│   │           ├── assets
│   │           │   ├── hello
│   │           │   └── ls
│   │           ├── java
│   │           │   └── jackpal
│   │           │       └── androidterm
│   │           │           └── sample
│   │           │               └── pathbroadcasts
│   │           │                   └── PathReceiver.java
│   │           └── res
│   │               └── values
│   │                   └── strings.xml
│   └── telnet
│       ├── build.gradle
│       └── src
│           └── main
│               ├── AndroidManifest.xml
│               ├── java
│               │   └── jackpal
│               │       └── androidterm
│               │           └── sample
│               │               └── telnet
│               │                   ├── LaunchActivity.java
│               │                   ├── TelnetSession.java
│               │                   └── TermActivity.java
│               └── res
│                   ├── layout
│                   │   ├── launch_activity.xml
│                   │   └── term_activity.xml
│                   ├── values
│                   │   └── strings.xml
│                   └── values-ko
│                       └── strings.xml
├── settings.gradle
├── term
│   ├── build.gradle
│   ├── lint.xml
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── java
│           │   └── jackpal
│           │       └── androidterm
│           │           ├── BoundSession.java
│           │           ├── Exec.java
│           │           ├── GenericTermSession.java
│           │           ├── RemoteInterface.java
│           │           ├── RunScript.java
│           │           ├── RunShortcut.java
│           │           ├── ShellTermSession.java
│           │           ├── Term.java
│           │           ├── TermDebug.java
│           │           ├── TermPreferences.java
│           │           ├── TermService.java
│           │           ├── TermView.java
│           │           ├── TermViewFlipper.java
│           │           ├── WindowList.java
│           │           ├── WindowListAdapter.java
│           │           ├── compat
│           │           │   ├── ActionBarCompat.java
│           │           │   ├── ActivityCompat.java
│           │           │   ├── AlertDialogCompat.java
│           │           │   ├── AndroidCompat.java
│           │           │   ├── Base64.java
│           │           │   ├── FileCompat.java
│           │           │   ├── MenuItemCompat.java
│           │           │   ├── PRNGFixes.java
│           │           │   └── ServiceForegroundCompat.java
│           │           ├── shortcuts
│           │           │   ├── AddShortcut.java
│           │           │   ├── ColorValue.java
│           │           │   ├── FSNavigator.java
│           │           │   └── TextIcon.java
│           │           └── util
│           │               ├── SessionList.java
│           │               ├── ShortcutEncryption.java
│           │               └── TermSettings.java
│           ├── jni
│           │   ├── common.cpp
│           │   ├── common.h
│           │   ├── fileCompat.cpp
│           │   ├── fileCompat.h
│           │   ├── termExec.cpp
│           │   └── termExec.h
│           └── res
│               ├── drawable
│               │   ├── btn_close_window.png
│               │   ├── close_background.xml
│               │   ├── ic_folder.png
│               │   ├── ic_folderup.png
│               │   ├── ic_launcher.png
│               │   ├── ic_menu_add.png
│               │   ├── ic_menu_back.png
│               │   ├── ic_menu_close_clear_cancel.png
│               │   ├── ic_menu_forward.png
│               │   ├── ic_menu_preferences.png
│               │   ├── ic_menu_windows.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-hdpi
│               │   ├── btn_close_window.png
│               │   ├── ic_launcher.png
│               │   ├── ic_menu_add.png
│               │   ├── ic_menu_back.png
│               │   ├── ic_menu_close_clear_cancel.png
│               │   ├── ic_menu_forward.png
│               │   ├── ic_menu_preferences.png
│               │   ├── ic_menu_windows.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-hdpi-v11
│               │   ├── ic_menu_add.png
│               │   ├── ic_menu_back.png
│               │   ├── ic_menu_close_clear_cancel.png
│               │   ├── ic_menu_forward.png
│               │   ├── ic_menu_preferences.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-hdpi-v9
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-ldpi
│               │   ├── ic_launcher.png
│               │   ├── ic_menu_add.png
│               │   ├── ic_menu_close_clear_cancel.png
│               │   ├── ic_menu_preferences.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-ldpi-v11
│               │   ├── ic_menu_add.png
│               │   ├── ic_menu_back.png
│               │   ├── ic_menu_close_clear_cancel.png
│               │   ├── ic_menu_forward.png
│               │   ├── ic_menu_preferences.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-ldpi-v9
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-mdpi
│               │   ├── btn_close_window.png
│               │   ├── ic_launcher.png
│               │   ├── ic_menu_add.png
│               │   ├── ic_menu_back.png
│               │   ├── ic_menu_close_clear_cancel.png
│               │   ├── ic_menu_forward.png
│               │   ├── ic_menu_preferences.png
│               │   ├── ic_menu_windows.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-mdpi-v11
│               │   ├── ic_menu_add.png
│               │   ├── ic_menu_back.png
│               │   ├── ic_menu_close_clear_cancel.png
│               │   ├── ic_menu_forward.png
│               │   ├── ic_menu_preferences.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-mdpi-v9
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-xhdpi
│               │   ├── ic_launcher.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-xhdpi-v11
│               │   ├── ic_menu_add.png
│               │   ├── ic_menu_back.png
│               │   ├── ic_menu_close_clear_cancel.png
│               │   ├── ic_menu_forward.png
│               │   ├── ic_menu_preferences.png
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-xhdpi-v9
│               │   └── ic_stat_service_notification_icon.png
│               ├── drawable-xxhdpi
│               │   └── ic_launcher.png
│               ├── drawable-xxxhdpi
│               │   └── ic_launcher.png
│               ├── layout
│               │   ├── term_activity.xml
│               │   ├── window_list_item.xml
│               │   └── window_list_new_window.xml
│               ├── menu
│               │   └── main.xml
│               ├── values
│               │   ├── arrays.xml
│               │   ├── arraysNoLocalize.xml
│               │   ├── attrs.xml
│               │   ├── defaults.xml
│               │   ├── id.xml
│               │   ├── strings.xml
│               │   └── styles.xml
│               ├── values-cs
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-de
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-es
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-eu
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-fr
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-hu
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-it
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-iw
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-ja
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-ka
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-ko
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-nb
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-nl
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-pl
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-pt
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-pt-rPT
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-ro
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-ru
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-sk
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-sr
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-sv
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-tr
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-uk
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-v11
│               │   └── styles.xml
│               ├── values-v21
│               │   ├── colors.xml
│               │   └── styles.xml
│               ├── values-zh-rCN
│               │   ├── arrays.xml
│               │   └── strings.xml
│               ├── values-zh-rTW
│               │   ├── arrays.xml
│               │   └── strings.xml
│               └── xml
│                   └── preferences.xml
├── tests
│   ├── controlSequences
│   │   ├── 256color.txt
│   │   ├── combiningCharReplacement.txt
│   │   ├── combiningChars.txt
│   │   ├── hideCursor.txt
│   │   ├── setTitle.txt
│   │   ├── showCursor.txt
│   │   └── textStyle.txt
│   ├── emulatorview-test
│   │   ├── AndroidManifest.xml
│   │   ├── ant.properties
│   │   ├── proguard-project.txt
│   │   ├── project.properties
│   │   ├── res
│   │   │   ├── drawable-hdpi
│   │   │   │   └── ic_launcher.png
│   │   │   ├── drawable-ldpi
│   │   │   │   └── ic_launcher.png
│   │   │   ├── drawable-mdpi
│   │   │   │   └── ic_launcher.png
│   │   │   ├── drawable-xhdpi
│   │   │   │   └── ic_launcher.png
│   │   │   └── values
│   │   │       └── strings.xml
│   │   └── src
│   │       └── jackpal
│   │           └── androidterm
│   │               └── emulatorview
│   │                   ├── InputConnectionTest.java
│   │                   ├── ModifierKeyTest.java
│   │                   └── TermKeyListenerTest.java
│   ├── fullWidthText
│   ├── issue145
│   │   ├── README.md
│   │   ├── fuzzer.go
│   │   ├── issue145repro-2.txt
│   │   └── issue145repro.txt
│   ├── issue149
│   │   └── colors.go
│   └── wideChars
│       ├── combining-chars.txt
│       ├── last-column-wrapping.txt
│       ├── linkification.txt
│       ├── overwriting1.txt
│       ├── overwriting2.txt
│       ├── overwriting3.txt
│       ├── overwriting4.txt
│       ├── overwriting5.txt
│       └── sip-chars.txt
└── tools
    ├── build-debug
    ├── build-release
    ├── import-icons
    ├── increment-version-number
    ├── install-sdk-packages
    ├── push-and-run-debug
    ├── push-and-run-release
    ├── push-samples-debug
    └── sign-release-build

```

`LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`NOTICE`:

```

   Copyright (c) 2005-2008, The Android Open Source Project

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS


```

`README.md`:

```md
# Terminal Emulator for Android

*Note:* Terminal Emulator for Android development has ended. I am not
accepting pull requests any more.

Terminal Emulator for Android is a terminal emulator for communicating with the
built-in Android shell. It emulates a reasonably large subset of Digital
Equipment Corporation VT-100 terminal codes, so that programs like "vi", "Emacs"
and "NetHack" will display properly.

This application was previously named "Android Terminal Emulator". Same great
application, just with a new name. (The change was made at the request of the
Android trademark owner.)

This code is based on the "Term" application which is included in the Android
Open Source Project. (Which I also wrote. :-) )

[Download the Terminal Emulator for Android from Google Play](https://play.google.com/store/apps/details?id=jackpal.androidterm)

If you are unable to use the Play Store, you can also
[download from GitHub](https://jackpal.github.io/Android-Terminal-Emulator/)

See [Building](docs/Building.md) for build instructions.

Got questions? Please check out the
[FAQ](http://github.com/jackpal/Android-Terminal-Emulator/wiki/Frequently-Asked-Questions). Thanks!

Please see the
[Recent Updates](http://github.com/jackpal/Android-Terminal-Emulator/wiki/Recent-Updates)
page for recent updates.

```

`artwork/android-terminal-emulator.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:osb="http://www.openswatchbook.org/uri/2009/osb"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="192"
   height="192"
   viewBox="0 0 192 192"
   id="svg2"
   version="1.1"
   inkscape:version="0.91 r13725"
   sodipodi:docname="android-terminal-emulator-material.svg"
   inkscape:export-filename="/media/Disk/Dropbox/TNDesigns/graphic/android/icons/android-terminal-emulator/android-terminal-emulator-36.png"
   inkscape:export-xdpi="16.879999"
   inkscape:export-ydpi="16.879999">
  <defs
     id="defs4">
    <linearGradient
       inkscape:collect="always"
       id="linearGradient4675">
      <stop
         style="stop-color:#ffffff;stop-opacity:0.1"
         offset="0"
         id="stop4677" />
      <stop
         style="stop-color:#ffffff;stop-opacity:0"
         offset="1"
         id="stop4679" />
    </linearGradient>
    <linearGradient
       id="linearGradient6127"
       osb:paint="solid">
      <stop
         style="stop-color:#607d8b;stop-opacity:0.16403785;"
         offset="0"
         id="stop6129" />
    </linearGradient>
    <linearGradient
       inkscape:collect="always"
       id="linearGradient9937">
      <stop
         style="stop-color:#eceff1;stop-opacity:1;"
         offset="0"
         id="stop9939" />
      <stop
         style="stop-color:#cfd8dc;stop-opacity:1"
         offset="1"
         id="stop9941" />
    </linearGradient>
    <linearGradient
       inkscape:collect="always"
       xlink:href="#linearGradient9937"
       id="linearGradient9943"
       x1="96"
       y1="4"
       x2="96"
       y2="184"
       gradientUnits="userSpaceOnUse" />
    <radialGradient
       inkscape:collect="always"
       xlink:href="#linearGradient4675"
       id="radialGradient4681"
       cx="7.9580786e-13"
       cy="96"
       fx="7.9580786e-13"
       fy="96"
       r="96"
       gradientUnits="userSpaceOnUse"
       gradientTransform="matrix(0,2,-2,0,192,0)" />
    <filter
       style="color-interpolation-filters:sRGB;"
       inkscape:label="Drop Shadow"
       id="filter3770">
      <feFlood
         flood-opacity="0.470588"
         flood-color="rgb(0,0,0)"
         result="flood"
         id="feFlood3772" />
      <feComposite
         in="flood"
         in2="SourceGraphic"
         operator="out"
         result="composite1"
         id="feComposite3774" />
      <feGaussianBlur
         in="composite1"
         stdDeviation="2"
         result="blur"
         id="feGaussianBlur3776" />
      <feOffset
         dx="0"
         dy="0"
         result="offset"
         id="feOffset3778" />
      <feComposite
         in="offset"
         in2="SourceGraphic"
         operator="atop"
         result="composite2"
         id="feComposite3780" />
    </filter>
    <filter
       style="color-interpolation-filters:sRGB;"
       inkscape:label="Drop Shadow"
       id="filter4884">
      <feFlood
         flood-opacity="0.352941"
         flood-color="rgb(0,0,0)"
         result="flood"
         id="feFlood4886" />
      <feComposite
         in="flood"
         in2="SourceGraphic"
         operator="in"
         result="composite1"
         id="feComposite4888" />
      <feGaussianBlur
         in="composite1"
         stdDeviation="4"
         result="blur"
         id="feGaussianBlur4890" />
      <feOffset
         dx="0"
         dy="0"
         result="offset"
         id="feOffset4892" />
      <feComposite
         in="offset"
         in2="SourceGraphic"
         operator="out"
         result="composite2"
         id="feComposite4894" />
    </filter>
    <filter
       style="color-interpolation-filters:sRGB;"
       inkscape:label="Drop Shadow"
       id="filter4985">
      <feFlood
         flood-opacity="0.352941"
         flood-color="rgb(0,0,0)"
         result="flood"
         id="feFlood4987" />
      <feComposite
         in="flood"
         in2="SourceGraphic"
         operator="in"
         result="composite1"
         id="feComposite4989" />
      <feGaussianBlur
         in="composite1"
         stdDeviation="2"
         result="blur"
         id="feGaussianBlur4991" />
      <feOffset
         dx="0"
         dy="0"
         result="offset"
         id="feOffset4993" />
      <feComposite
         in="offset"
         in2="SourceGraphic"
         operator="out"
         result="composite2"
         id="feComposite4995" />
    </filter>
    <filter
       style="color-interpolation-filters:sRGB;"
       inkscape:label="Drop Shadow"
       id="filter5048">
      <feFlood
         flood-opacity="0.352941"
         flood-color="rgb(0,0,0)"
         result="flood"
         id="feFlood5050" />
      <feComposite
         in="flood"
         in2="SourceGraphic"
         operator="in"
         result="composite1"
         id="feComposite5052" />
      <feGaussianBlur
         in="composite1"
         stdDeviation="2"
         result="blur"
         id="feGaussianBlur5054" />
      <feOffset
         dx="0"
         dy="0"
         result="offset"
         id="feOffset5056" />
      <feComposite
         in="offset"
         in2="SourceGraphic"
         operator="out"
         result="composite2"
         id="feComposite5058" />
    </filter>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="6.1458333"
     inkscape:cx="63.864407"
     inkscape:cy="96"
     inkscape:document-units="px"
     inkscape:current-layer="layer2"
     showgrid="false"
     units="px"
     borderlayer="true"
     showborder="true"
     inkscape:showpageshadow="false"
     inkscape:snap-bbox="true"
     inkscape:bbox-paths="true"
     inkscape:bbox-nodes="true"
     inkscape:snap-bbox-edge-midpoints="true"
     inkscape:snap-bbox-midpoints="true"
     inkscape:object-paths="true"
     inkscape:snap-intersection-paths="true"
     inkscape:object-nodes="true"
     inkscape:snap-smooth-nodes="true"
     inkscape:snap-midpoints="true"
     inkscape:snap-object-midpoints="true"
     inkscape:snap-center="true"
     showguides="true"
     inkscape:guide-bbox="true"
     inkscape:window-width="2160"
     inkscape:window-height="1404"
     inkscape:window-x="0"
     inkscape:window-y="0"
     inkscape:window-maximized="1">
    <inkscape:grid
       type="xygrid"
       id="grid3336"
       empspacing="4" />
    <sodipodi:guide
       position="4,188"
       orientation="1,0"
       id="guide3338" />
    <sodipodi:guide
       position="188,4"
       orientation="1,0"
       id="guide3340" />
    <sodipodi:guide
       position="180,180"
       orientation="0,1"
       id="guide3342" />
    <sodipodi:guide
       position="4,4"
       orientation="0,1"
       id="guide3344" />
    <sodipodi:guide
       position="96,192"
       orientation="1,0"
       id="guide3346"
       inkscape:label=""
       inkscape:color="rgb(0,0,255)" />
    <sodipodi:guide
       position="0,96"
       orientation="0,1"
       id="guide3348"
       inkscape:label=""
       inkscape:color="rgb(0,0,255)" />
    <sodipodi:guide
       position="12,152"
       orientation="1,0"
       id="guide3422" />
    <sodipodi:guide
       position="180,120"
       orientation="1,0"
       id="guide3424" />
    <sodipodi:guide
       position="60,16"
       orientation="0,1"
       id="guide3428" />
    <sodipodi:guide
       position="96,132"
       orientation="0,1"
       id="guide3505" />
  </sodipodi:namedview>
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Guides"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-860.36216)"
     sodipodi:insensitive="true"
     style="display:inline" />
  <g
     inkscape:groupmode="layer"
     id="layer2"
     inkscape:label="Base"
     style="display:inline"
     sodipodi:insensitive="true">
    <rect
       style="fill:#90a4ae;fill-opacity:1;stroke:none;stroke-width:1.35000002;stroke-miterlimit:7;stroke-dasharray:none"
       id="rect3404"
       width="184"
       height="184"
       x="4"
       y="4"
       ry="16" />
    <path
       style="fill:#607d8b;fill-opacity:1;stroke:none;stroke-width:1.35000002;stroke-miterlimit:7;stroke-dasharray:none"
       d="m 20,12 152,0 c 4.432,0 8,3.568 8,8 l 0,132 c 0,4.432 -3.568,8 -8,8 l -152,0 c -4.432,0 -8,-3.568 -8,-8 L 12,20 c 0,-4.432 3.568,-8 8,-8 z"
       id="rect3430"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="sssssssss" />
    <g
       id="g9776"
       style="fill:#ffffff;fill-opacity:1">
      <path
         id="path4259"
         d="M 20,20 20,24.882812 40,32 20,39.117188 20,44 44,36 44,32 44,28 20,20 Z"
         style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:medium;line-height:125%;font-family:Sans;-inkscape-font-specification:'Sans Bold';letter-spacing:0px;word-spacing:0px;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         inkscape:connector-curvature="0" />
      <path
         inkscape:connector-curvature="0"
         id="path4343"
         d="m 48,52 20,0 0,-4 -20,0 z"
         style="fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" />
    </g>
    <path
       style="fill:#a4c639"
       d="m 38.992188,60 c -1.056873,0.0078 -2.126268,0.271426 -3.115235,0.818359 -3.161808,1.753354 -4.305642,5.743219 -2.548828,8.908203 L 47.830078,95.884766 C 32.033549,104.8921 19.513548,118.24662 12,134.08398 L 12,152 c 0,1.108 0.223203,2.16139 0.626953,3.11914 0.40375,0.95775 0.987938,1.81997 1.710938,2.54297 0.723,0.723 1.585218,1.30719 2.542968,1.71094 C 17.838609,159.7768 18.892,160 20,160 l 152,0 c 1.108,0 2.16139,-0.2232 3.11914,-0.62695 0.95775,-0.40375 1.81997,-0.98794 2.54297,-1.71094 0.723,-0.723 1.30719,-1.58522 1.71094,-2.54297 C 179.7768,154.16139 180,153.108 180,152 l 0,-17.91211 c -7.51447,-15.83905 -20.0346,-29.19487 -35.82617,-38.203124 l 14.49414,-26.158204 c 1.76346,-3.164985 0.61887,-7.154849 -2.55274,-8.908203 -3.16497,-1.750188 -7.15363,-0.602484 -8.91015,2.5625 L 132.3457,90.191406 C 121.19488,85.752351 108.91008,83.28125 95.996094,83.28125 c -12.914287,0 -25.198492,2.471392 -36.34961,6.910156 L 44.789062,63.380859 C 43.581054,61.204933 41.317307,59.982811 38.992188,60 Z m 14.654296,62.60547 c 3.791924,0 6.865235,3.07331 6.865235,6.86523 -2.83e-4,3.79221 -3.073602,6.86719 -6.865235,6.86719 -3.791633,0 -6.867187,-3.07527 -6.867187,-6.86719 0,-3.79163 3.075264,-6.86523 6.867187,-6.86523 z m 84.703126,0 c 3.79194,0 6.86719,3.07331 6.86719,6.86523 0,3.79221 -3.07525,6.86719 -6.86719,6.86719 -3.79163,0 -6.86523,-3.07527 -6.86523,-6.86719 0,-3.79163 3.07332,-6.86523 6.86523,-6.86523 z"
       id="path2994"
       inkscape:connector-curvature="0" />
    <path
       style="opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.10000002;stroke-miterlimit:7;stroke-dasharray:none;filter:url(#filter5048)"
       d="M 20,8 C 13.352,8 8,13.352 8,20 l 0,132 c 0,6.648 5.352,12 12,12 l 152,0 c 6.648,0 12,-5.352 12,-12 L 184,20 C 184,13.352 178.648,8 172,8 L 20,8 Z m 0,4 152,0 c 4.432,0 8,3.568 8,8 l 0,132 c 0,4.432 -3.568,8 -8,8 l -152,0 c -4.432,0 -8,-3.568 -8,-8 L 12,20 c 0,-4.432 3.568,-8 8,-8 z"
       id="rect5028"
       inkscape:connector-curvature="0" />
    <path
       style="fill:url(#linearGradient9943);fill-opacity:1;stroke:none;stroke-width:1.35000002;stroke-miterlimit:7;stroke-dasharray:none"
       d="M 20,4 C 11.136,4 4,11.136 4,20 l 0,148 c 0,8.864 7.136,16 16,16 l 152,0 c 8.864,0 16,-7.136 16,-16 L 188,20 C 188,11.136 180.864,4 172,4 L 20,4 Z m 0,8 152,0 c 4.432,0 8,3.568 8,8 l 0,132 c 0,4.432 -3.568,8 -8,8 l -152,0 c -4.432,0 -8,-3.568 -8,-8 L 12,20 c 0,-4.432 3.568,-8 8,-8 z"
       id="rect3404-5"
       inkscape:connector-curvature="0" />
  </g>
  <g
     inkscape:groupmode="layer"
     id="layer3"
     inkscape:label="Finish"
     style="display:inline"
     sodipodi:insensitive="true">
    <rect
       style="fill:url(#radialGradient4681);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1.35000002;stroke-miterlimit:7;stroke-dasharray:none"
       id="rect4673"
       height="192"
       x="0"
       y="0"
       width="192" />
  </g>
</svg>

```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.
task wrapper (type:Wrapper) {
    gradleVersion = '2.2.1'
    distributionUrl = 'https://services.gradle.org/distributions/gradle-2.2.1-all.zip'
}

buildscript {
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.0.0'
        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

subprojects {
    def androidHome

    if ((androidHome = System.env.'ANDROID_HOME')
            && (androidHome = androidHome as File).exists()
            && androidHome.canWrite())
        apply plugin: 'android-sdk-manager'
}
```

`docs/Building.md`:

```md
Building
========

To keep from typing "Terminal Emulator for Android" over and over again, this
document will use the abbreviation "TEA" to stand for "Terminal
Emulator for Android".


Download the Software Needed to Build Terminal Emulator for Android
-------------------------------------------------------------------

TEA is built using:

 + [Android Studio](http://developer.android.com/sdk) 1.0 or newer
 + [Android NDK](http://developer.android.com/tools/sdk/ndk/) r10d or newer


Telling Gradle where to find the Android NDK and SDK
----------------------------------------------------

Android Studio and the gradle build tool need to know where to find the NDK and
SDK on your computer.

Create a file local.properties in the root directiory of the TEA project that
contains this text:

    ndk.dir=path/to/ndk
    sdk.dir=path/to/sdk

On my personal dev machine the file looks like this, but of course it will
be different on your machine, depending upon your OS, user name, directory
tree, and version of the NDK that you have installed.

    ndk.dir=/Users/jack/code/android-ndk-r10d
    sdk.dir=/Users/jack/Library/Android/sdk

In addition, if you are building from the command line, the scripts in the
"tools" directory expect the environment variable ANDROID_SDK_ROOT to be
defined.

On my personal dev machine I have this line in my .profile:

    export ANDROID_SDK_ROOT=/Users/jack/Library/Android/sdk

Installing required SDK Packages
--------------------------------

In order to build, in addition to a current SDK version,
TEA requires the Android 3.0 (API 11) version of the Android SDK
to be installed.

You can install it by running the following command-line script:

    tools/install-sdk-packages

Or you can run Android Studio and choose Configure > SDK Manager, then
choose the "Android 3.0 (API 11) > SDK Platform" package.

Building TEA
------------

You can build TEA two ways:

  1. Using the Android Studio IDE
  2. Using the "gradlew" command line tool

Using Android Studio is convenient for development. Using "gradlew" is
convenient for automated testing and publishing.


Building TEA with Android Studio
--------------------------------

  1. Open Android Studio
  2. Choose "Open an existing Android Studio project" from the "Quick Start"
     wizard.
  3. Choose the top-level TEA directory. (If you installed the source code from
     github, this directory will be named Android-Terminal-Emulator).
  4. Use the Android Studio menu "Run : Run 'term'" to build and run the app.


Building TEA from the command line
----------------------------------

  0. Make sure a file local.properties exists at the root of the TEA source
     tree. Android Studio will create this file automaticaly. If you don't
     want to run Android Studio, you can create this file manually with the
     paths of your local sdk and ndk installations. For my machine that's:

     sdk.dir=/Users/jack/Library/Android/sdk
     ndk.dir=/Users/jack/code/android-ndk-r10d

  1. Open a command line shell window and navigate to the main TEA directory.

  2. Build

      $ ./tools/build-debug

  3. Copy the built executable to a device:

      $ ./tools/push-and-run-debug

```

`docs/UTF-8-SMP-chars-demo.txt`:

```txt
These are some characters in the Supplementary Multilingual Plane:
𝄞 𝄴𝅘𝅥𝅯𝅗𝅥 𝑥𝄽

```

`docs/atari_small_notice.txt`:

```txt
COMMENT  Copyright (c) 1999, Thomas A. Fine
COMMENT
COMMENT  License to copy, modify, and distribute for both commercial and
COMMENT  non-commercial use is herby granted, provided this notice
COMMENT  is preserved.
COMMENT
COMMENT  Email to my last name at head.cfa.harvard.edu
COMMENT  http://hea-www.harvard.edu/~fine/
COMMENT
COMMENT  Produced with bdfedit, a tcl/tk font editing program
COMMENT  written by Thomas A. Fine
```

`docs/releaseChecklist.md`:

```md
## Terminal Emulator for Android Release Checklist

# Test on 1.6 Donut API 4

(Lowest supported level -- will be dropped soon.)

# Test on 2.1 Eclair API 7

# Test on 2.2 Froyo API 8

# Test on 2.3 Gingerbread API 10

(Still popular with cheap phones.)

# Test on 4.3 Jelly Bean API 18

# Test on 4.4 Kit Kat API 19

# Test on 5.1 Lollipop API 22

(Or whatever latest is.)

# Test with Swype

(Has to be on a real device, Swype beta won't run on an emulator.)

# Update ./term/src/main/AndroidManifest.xml version number

    tools/increment-version-number

# Commit changes

    git commit -a -m "Increment version number to v1.0.xx"

# Tag git branch with version number

    git tag v1.0.xx

# Push git to repository

    git push
    git push --tags

# Build release apk

    tools/build-release

(Will only work if you have the signing keys for the app.)

# Publish to the Google Play Store

    open https://play.google.com/apps/publish

The Android Developer Console Publishing UI is error prone:

1) Click on the "Terminal Emulator for Android" link.

2) Click on the APK files tab

3) Upload your new APK.

4) Activate it by clicking on the Activate link

5) Click on the "Save" button.

6) Click on the "Product Details button".

7) Fill in the "Listing Details" for the new version.

8) Click on the "Save" button

9) Visit https://play.google.com/apps/publish and verify that the new version is listed as the current version.

10) Verify that Google Play Store is serving the new version
(check the "What's New" portion.)

https://play.google.com/store/apps/details?id=jackpal.androidterm

(Note, it can take several hours for the app to appear in the store.)

# Update the Terminal Emulator for Android Wiki

    open https://github.com/jackpal/Android-Terminal-Emulator/wiki/Recent-Updates

# Publish a new pre-compiled version of the APK for people who can't access Market.

Github serves pages out of branch gh-pages , directory downloads/Term.apk
Also update the version number in index.html

    cp ./term/build/outputs/apk/Term.apk /tmp
    git checkout gh-pages
    mv /tmp/Term.apk downloads/Term.apk
    git add downloads/Term.apk
    subl index.html
    # Update version save index.html
    git add index.html
    git commit -m "Update to version v1.0.xx"
    git push
    git checkout master

Public URL is http://jackpal.github.com/Android-Terminal-Emulator/downloads/Term.apk



```

`emulatorview/build.gradle`:

```gradle
apply plugin: 'com.android.library'

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"

    defaultConfig {
        minSdkVersion 4
        targetSdkVersion 22
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

```

`emulatorview/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="jackpal.androidterm.emulatorview"
      android:versionCode="43"
      android:versionName="1.0.42">
    <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="11" />
</manifest>

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/BaseTextRenderer.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.RectF;

abstract class BaseTextRenderer implements TextRenderer {
    protected boolean mReverseVideo;

    protected int[] mPalette;

    protected static final int[] sXterm256Paint = {
            // 16 original colors
            // First 8 are dim
            0xff000000,  // black
            0xffcd0000,  // dim red
            0xff00cd00,  // dim green
            0xffcdcd00,  // dim yellow
            0xff0000ee,  // dim blue
            0xffcd00cd,  // dim magenta
            0xff00cdcd,  // dim cyan
            0xffe5e5e5,  // dim white
            // second 8 are bright
            0xff7f7f7f,  // medium grey
            0xffff0000,  // bright red
            0xff00ff00,  // bright green
            0xffffff00,  // bright yellow
            0xff5c5cff,  // light blue
            0xffff00ff,  // bright magenta
            0xff00ffff,  // bright cyan
            0xffffffff,  // bright white

            // 216 color cube, six shades of each color
            0xff000000,
            0xff00005f,
            0xff000087,
            0xff0000af,
            0xff0000d7,
            0xff0000ff,
            0xff005f00,
            0xff005f5f,
            0xff005f87,
            0xff005faf,
            0xff005fd7,
            0xff005fff,
            0xff008700,
            0xff00875f,
            0xff008787,
            0xff0087af,
            0xff0087d7,
            0xff0087ff,
            0xff00af00,
            0xff00af5f,
            0xff00af87,
            0xff00afaf,
            0xff00afd7,
            0xff00afff,
            0xff00d700,
            0xff00d75f,
            0xff00d787,
            0xff00d7af,
            0xff00d7d7,
            0xff00d7ff,
            0xff00ff00,
            0xff00ff5f,
            0xff00ff87,
            0xff00ffaf,
            0xff00ffd7,
            0xff00ffff,
            0xff5f0000,
            0xff5f005f,
            0xff5f0087,
            0xff5f00af,
            0xff5f00d7,
            0xff5f00ff,
            0xff5f5f00,
            0xff5f5f5f,
            0xff5f5f87,
            0xff5f5faf,
            0xff5f5fd7,
            0xff5f5fff,
            0xff5f8700,
            0xff5f875f,
            0xff5f8787,
            0xff5f87af,
            0xff5f87d7,
            0xff5f87ff,
            0xff5faf00,
            0xff5faf5f,
            0xff5faf87,
            0xff5fafaf,
            0xff5fafd7,
            0xff5fafff,
            0xff5fd700,
            0xff5fd75f,
            0xff5fd787,
            0xff5fd7af,
            0xff5fd7d7,
            0xff5fd7ff,
            0xff5fff00,
            0xff5fff5f,
            0xff5fff87,
            0xff5fffaf,
            0xff5fffd7,
            0xff5fffff,
            0xff870000,
            0xff87005f,
            0xff870087,
            0xff8700af,
            0xff8700d7,
            0xff8700ff,
            0xff875f00,
            0xff875f5f,
            0xff875f87,
            0xff875faf,
            0xff875fd7,
            0xff875fff,
            0xff878700,
            0xff87875f,
            0xff878787,
            0xff8787af,
            0xff8787d7,
            0xff8787ff,
            0xff87af00,
            0xff87af5f,
            0xff87af87,
            0xff87afaf,
            0xff87afd7,
            0xff87afff,
            0xff87d700,
            0xff87d75f,
            0xff87d787,
            0xff87d7af,
            0xff87d7d7,
            0xff87d7ff,
            0xff87ff00,
            0xff87ff5f,
            0xff87ff87,
            0xff87ffaf,
            0xff87ffd7,
            0xff87ffff,
            0xffaf0000,
            0xffaf005f,
            0xffaf0087,
            0xffaf00af,
            0xffaf00d7,
            0xffaf00ff,
            0xffaf5f00,
            0xffaf5f5f,
            0xffaf5f87,
            0xffaf5faf,
            0xffaf5fd7,
            0xffaf5fff,
            0xffaf8700,
            0xffaf875f,
            0xffaf8787,
            0xffaf87af,
            0xffaf87d7,
            0xffaf87ff,
            0xffafaf00,
            0xffafaf5f,
            0xffafaf87,
            0xffafafaf,
            0xffafafd7,
            0xffafafff,
            0xffafd700,
            0xffafd75f,
            0xffafd787,
            0xffafd7af,
            0xffafd7d7,
            0xffafd7ff,
            0xffafff00,
            0xffafff5f,
            0xffafff87,
            0xffafffaf,
            0xffafffd7,
            0xffafffff,
            0xffd70000,
            0xffd7005f,
            0xffd70087,
            0xffd700af,
            0xffd700d7,
            0xffd700ff,
            0xffd75f00,
            0xffd75f5f,
            0xffd75f87,
            0xffd75faf,
            0xffd75fd7,
            0xffd75fff,
            0xffd78700,
            0xffd7875f,
            0xffd78787,
            0xffd787af,
            0xffd787d7,
            0xffd787ff,
            0xffd7af00,
            0xffd7af5f,
            0xffd7af87,
            0xffd7afaf,
            0xffd7afd7,
            0xffd7afff,
            0xffd7d700,
            0xffd7d75f,
            0xffd7d787,
            0xffd7d7af,
            0xffd7d7d7,
            0xffd7d7ff,
            0xffd7ff00,
            0xffd7ff5f,
            0xffd7ff87,
            0xffd7ffaf,
            0xffd7ffd7,
            0xffd7ffff,
            0xffff0000,
            0xffff005f,
            0xffff0087,
            0xffff00af,
            0xffff00d7,
            0xffff00ff,
            0xffff5f00,
            0xffff5f5f,
            0xffff5f87,
            0xffff5faf,
            0xffff5fd7,
            0xffff5fff,
            0xffff8700,
            0xffff875f,
            0xffff8787,
            0xffff87af,
            0xffff87d7,
            0xffff87ff,
            0xffffaf00,
            0xffffaf5f,
            0xffffaf87,
            0xffffafaf,
            0xffffafd7,
            0xffffafff,
            0xffffd700,
            0xffffd75f,
            0xffffd787,
            0xffffd7af,
            0xffffd7d7,
            0xffffd7ff,
            0xffffff00,
            0xffffff5f,
            0xffffff87,
            0xffffffaf,
            0xffffffd7,
            0xffffffff,

        // 24 grey scale ramp
            0xff080808,
            0xff121212,
            0xff1c1c1c,
            0xff262626,
            0xff303030,
            0xff3a3a3a,
            0xff444444,
            0xff4e4e4e,
            0xff585858,
            0xff626262,
            0xff6c6c6c,
            0xff767676,
            0xff808080,
            0xff8a8a8a,
            0xff949494,
            0xff9e9e9e,
            0xffa8a8a8,
            0xffb2b2b2,
            0xffbcbcbc,
            0xffc6c6c6,
            0xffd0d0d0,
            0xffdadada,
            0xffe4e4e4,
            0xffeeeeee
    };

    static final ColorScheme defaultColorScheme =
            new ColorScheme(0xffcccccc, 0xff000000);

    private final Paint mCursorScreenPaint;
    private final Paint mCopyRedToAlphaPaint;
    private final Paint mCursorPaint;
    private final Paint mCursorStrokePaint;
    private final Path mShiftCursor;
    private final Path mAltCursor;
    private final Path mCtrlCursor;
    private final Path mFnCursor;
    private RectF mTempSrc;
    private RectF mTempDst;
    private Matrix mScaleMatrix;
    private float mLastCharWidth;
    private float mLastCharHeight;
    private static final Matrix.ScaleToFit mScaleType = Matrix.ScaleToFit.FILL;

    private Bitmap mCursorBitmap;
    private Bitmap mWorkBitmap;
    private int mCursorBitmapCursorMode = -1;

    public BaseTextRenderer(ColorScheme scheme) {
        if (scheme == null) {
            scheme = defaultColorScheme;
        }
        setDefaultColors(scheme);

        mCursorScreenPaint = new Paint();
        mCursorScreenPaint.setColor(scheme.getCursorBackColor());

        // Cursor paint and cursor stroke paint are used to draw a grayscale mask that's converted
        // to an alpha8 texture. Only the red channel's value matters.
        mCursorPaint = new Paint();
        mCursorPaint.setColor(0xff909090); // Opaque lightgray
        mCursorPaint.setAntiAlias(true);

        mCursorStrokePaint = new Paint(mCursorPaint);
        mCursorStrokePaint.setStrokeWidth(0.1f);
        mCursorStrokePaint.setStyle(Paint.Style.STROKE);

        mCopyRedToAlphaPaint = new Paint();
        ColorMatrix cm = new ColorMatrix();
        cm.set(new float[] {
                0, 0, 0, 0, 0,
                0, 0, 0, 0, 0,
                0, 0, 0, 0, 0,
                1, 0, 0, 0, 0 });
        mCopyRedToAlphaPaint.setColorFilter(new ColorMatrixColorFilter(cm));

        mShiftCursor = new Path();
        mShiftCursor.lineTo(0.5f, 0.33f);
        mShiftCursor.lineTo(1.0f, 0.0f);

        mAltCursor = new Path();
        mAltCursor.moveTo(0.0f, 1.0f);
        mAltCursor.lineTo(0.5f, 0.66f);
        mAltCursor.lineTo(1.0f, 1.0f);

        mCtrlCursor = new Path();
        mCtrlCursor.moveTo(0.0f, 0.25f);
        mCtrlCursor.lineTo(1.0f, 0.5f);
        mCtrlCursor.lineTo(0.0f, 0.75f);

        mFnCursor = new Path();
        mFnCursor.moveTo(1.0f, 0.25f);
        mFnCursor.lineTo(0.0f, 0.5f);
        mFnCursor.lineTo(1.0f, 0.75f);

        // For creating the transform when the terminal resizes
        mTempSrc = new RectF();
        mTempSrc.set(0.0f, 0.0f, 1.0f, 1.0f);
        mTempDst = new RectF();
        mScaleMatrix = new Matrix();
    }

    public void setReverseVideo(boolean reverseVideo) {
        mReverseVideo = reverseVideo;
    }

    private void setDefaultColors(ColorScheme scheme) {
        mPalette = cloneDefaultColors();
        mPalette[TextStyle.ciForeground] = scheme.getForeColor();
        mPalette[TextStyle.ciBackground] = scheme.getBackColor();
        mPalette[TextStyle.ciCursorForeground] = scheme.getCursorForeColor();
        mPalette[TextStyle.ciCursorBackground] = scheme.getCursorBackColor();
    }

    private static int[] cloneDefaultColors() {
        int length = sXterm256Paint.length;
        int[] clone = new int[TextStyle.ciColorLength];
        System.arraycopy(sXterm256Paint, 0, clone, 0, length);
        return clone;
    }

    protected void drawCursorImp(Canvas canvas, float x, float y, float charWidth, float charHeight,
            int cursorMode) {
        if (cursorMode == 0) {
            canvas.drawRect(x,  y - charHeight, x + charWidth, y, mCursorScreenPaint);
            return;
        }

        // Fancy cursor. Draw an offscreen cursor shape, then blit it on screen.

        // Has the character size changed?

        if (charWidth != mLastCharWidth || charHeight != mLastCharHeight) {
            mLastCharWidth = charWidth;
            mLastCharHeight = charHeight;
            mTempDst.set(0.0f, 0.0f, charWidth, charHeight);
            mScaleMatrix.setRectToRect(mTempSrc, mTempDst, mScaleType);
            mCursorBitmap = Bitmap.createBitmap((int) charWidth, (int) charHeight,
                    Bitmap.Config.ALPHA_8);
            mWorkBitmap = Bitmap.createBitmap((int) charWidth, (int) charHeight,
                    Bitmap.Config.ARGB_8888);
            mCursorBitmapCursorMode = -1;
        }

        // Has the cursor mode changed ?

        if (cursorMode != mCursorBitmapCursorMode) {
            mCursorBitmapCursorMode = cursorMode;
            mWorkBitmap.eraseColor(0xffffffff);
            Canvas workCanvas = new Canvas(mWorkBitmap);
            workCanvas.concat(mScaleMatrix);
            drawCursorHelper(workCanvas, mShiftCursor, cursorMode, MODE_SHIFT_SHIFT);
            drawCursorHelper(workCanvas, mAltCursor, cursorMode, MODE_ALT_SHIFT);
            drawCursorHelper(workCanvas, mCtrlCursor, cursorMode, MODE_CTRL_SHIFT);
            drawCursorHelper(workCanvas, mFnCursor, cursorMode, MODE_FN_SHIFT);

            mCursorBitmap.eraseColor(0);
            Canvas bitmapCanvas = new Canvas(mCursorBitmap);
            bitmapCanvas.drawBitmap(mWorkBitmap, 0, 0, mCopyRedToAlphaPaint);
        }

        canvas.drawBitmap(mCursorBitmap, x, y - charHeight, mCursorScreenPaint);
    }

    private void drawCursorHelper(Canvas canvas, Path path, int mode, int shift) {
        switch ((mode >> shift) & MODE_MASK) {
        case MODE_ON:
            canvas.drawPath(path, mCursorStrokePaint);
            break;
        case MODE_LOCKED:
            canvas.drawPath(path, mCursorPaint);
            break;
        }
    }
}


```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/Bitmap4x8FontRenderer.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import jackpal.androidterm.emulatorview.compat.AndroidCompat;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Rect;


class Bitmap4x8FontRenderer extends BaseTextRenderer {
    private final static int kCharacterWidth = 4;
    private final static int kCharacterHeight = 8;
    private Bitmap mFont;
    private int mCurrentForeColor;
    private int mCurrentBackColor;
    private float[] mColorMatrix;
    private Paint mPaint;
    private static final float BYTE_SCALE = 1.0f / 255.0f;

    public Bitmap4x8FontRenderer(Resources resources, ColorScheme scheme) {
        super(scheme);
        int fontResource = AndroidCompat.SDK <= 3 ? R.drawable.atari_small
                : R.drawable.atari_small_nodpi;
        mFont = BitmapFactory.decodeResource(resources,fontResource);
        mPaint = new Paint();
        mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
    }

    public float getCharacterWidth() {
        return kCharacterWidth;
    }

    public int getCharacterHeight() {
        return kCharacterHeight;
    }

    public int getTopMargin() {
        return 0;
    }

    public void drawTextRun(Canvas canvas, float x, float y,
            int lineOffset, int runWidth, char[] text, int index, int count,
            boolean selectionStyle, int textStyle,
            int cursorOffset, int cursorIndex, int cursorIncr, int cursorWidth, int cursorMode) {
        int foreColor = TextStyle.decodeForeColor(textStyle);
        int backColor = TextStyle.decodeBackColor(textStyle);
        int effect = TextStyle.decodeEffect(textStyle);

        boolean inverse = mReverseVideo ^
                ((effect & (TextStyle.fxInverse | TextStyle.fxItalic)) != 0);
        if (inverse) {
            int temp = foreColor;
            foreColor = backColor;
            backColor = temp;
        }

        boolean bold = ((effect & TextStyle.fxBold) != 0);
        if (bold && foreColor < 8) {
            // In 16-color mode, bold also implies bright foreground colors
            foreColor += 8;
        }
        boolean blink = ((effect & TextStyle.fxBlink) != 0);
        if (blink && backColor < 8) {
            // In 16-color mode, blink also implies bright background colors
            backColor += 8;
        }

        if (selectionStyle) {
            backColor = TextStyle.ciCursorBackground;
        }

        boolean invisible = (effect & TextStyle.fxInvisible) != 0;

        if (invisible) {
            foreColor = backColor;
        }

        drawTextRunHelper(canvas, x, y, lineOffset, text, index, count, foreColor, backColor);

        // The cursor is too small to show the cursor mode.
        if (lineOffset <= cursorOffset && cursorOffset < (lineOffset + count)) {
          drawTextRunHelper(canvas, x, y, cursorOffset, text, cursorOffset-lineOffset, 1,
                  TextStyle.ciCursorForeground, TextStyle.ciCursorBackground);
        }
    }

    private void drawTextRunHelper(Canvas canvas, float x, float y, int lineOffset, char[] text,
            int index, int count, int foreColor, int backColor) {
        setColorMatrix(mPalette[foreColor], mPalette[backColor]);
        int destX = (int) x + kCharacterWidth * lineOffset;
        int destY = (int) y;
        Rect srcRect = new Rect();
        Rect destRect = new Rect();
        destRect.top = (destY - kCharacterHeight);
        destRect.bottom = destY;
        boolean drawSpaces = mPalette[backColor] != mPalette[TextStyle.ciBackground];
        for (int i = 0; i < count; i++) {
            // XXX No Unicode support in bitmap font
            char c = text[i + index];
            if ((c < 128) && ((c != 32) || drawSpaces)) {
                int cellX = c & 31;
                int cellY = (c >> 5) & 3;
                int srcX = cellX * kCharacterWidth;
                int srcY = cellY * kCharacterHeight;
                srcRect.set(srcX, srcY,
                        srcX + kCharacterWidth, srcY + kCharacterHeight);
                destRect.left = destX;
                destRect.right = destX + kCharacterWidth;
                canvas.drawBitmap(mFont, srcRect, destRect, mPaint);
            }
            destX += kCharacterWidth;
        }
    }

    private void setColorMatrix(int foreColor, int backColor) {
        if ((foreColor != mCurrentForeColor)
                || (backColor != mCurrentBackColor)
                || (mColorMatrix == null)) {
            mCurrentForeColor = foreColor;
            mCurrentBackColor = backColor;
            if (mColorMatrix == null) {
                mColorMatrix = new float[20];
                mColorMatrix[18] = 1.0f; // Just copy Alpha
            }
            for (int component = 0; component < 3; component++) {
                int rightShift = (2 - component) << 3;
                int fore = 0xff & (foreColor >> rightShift);
                int back = 0xff & (backColor >> rightShift);
                int delta = back - fore;
                mColorMatrix[component * 6] = delta * BYTE_SCALE;
                mColorMatrix[component * 5 + 4] = fore;
            }
            mPaint.setColorFilter(new ColorMatrixColorFilter(mColorMatrix));
        }
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/ByteQueue.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

/**
 * A multi-thread-safe produce-consumer byte array.
 * Only allows one producer and one consumer.
 */

class ByteQueue {
    public ByteQueue(int size) {
        mBuffer = new byte[size];
    }

    public int getBytesAvailable() {
        synchronized(this) {
            return mStoredBytes;
        }
    }

    public int read(byte[] buffer, int offset, int length)
        throws InterruptedException {
        if (length + offset > buffer.length) {
            throw
                new IllegalArgumentException("length + offset > buffer.length");
        }
        if (length < 0) {
            throw
            new IllegalArgumentException("length < 0");

        }
        if (length == 0) {
            return 0;
        }
        synchronized(this) {
            while (mStoredBytes == 0) {
                wait();
            }
            int totalRead = 0;
            int bufferLength = mBuffer.length;
            boolean wasFull = bufferLength == mStoredBytes;
            while (length > 0 && mStoredBytes > 0) {
                int oneRun = Math.min(bufferLength - mHead, mStoredBytes);
                int bytesToCopy = Math.min(length, oneRun);
                System.arraycopy(mBuffer, mHead, buffer, offset, bytesToCopy);
                mHead += bytesToCopy;
                if (mHead >= bufferLength) {
                    mHead = 0;
                }
                mStoredBytes -= bytesToCopy;
                length -= bytesToCopy;
                offset += bytesToCopy;
                totalRead += bytesToCopy;
            }
            if (wasFull) {
                notify();
            }
            return totalRead;
        }
    }

    /**
     * Attempt to write the specified portion of the provided buffer to
     * the queue.  Returns the number of bytes actually written to the queue;
     * it is the caller's responsibility to check whether all of the data
     * was written and repeat the call to write() if necessary.
     */
    public int write(byte[] buffer, int offset, int length)
    throws InterruptedException {
        if (length + offset > buffer.length) {
            throw
                new IllegalArgumentException("length + offset > buffer.length");
        }
        if (length < 0) {
            throw
            new IllegalArgumentException("length < 0");

        }
        if (length == 0) {
            return 0;
        }
        synchronized(this) {
            int bufferLength = mBuffer.length;
            boolean wasEmpty = mStoredBytes == 0;
            while(bufferLength == mStoredBytes) {
                wait();
            }
            int tail = mHead + mStoredBytes;
            int oneRun;
            if (tail >= bufferLength) {
                tail = tail - bufferLength;
                oneRun = mHead - tail;
            } else {
                oneRun = bufferLength - tail;
            }
            int bytesToCopy = Math.min(oneRun, length);
            System.arraycopy(buffer, offset, mBuffer, tail, bytesToCopy);
            offset += bytesToCopy;
            mStoredBytes += bytesToCopy;
            if (wasEmpty) {
                notify();
            }
            return bytesToCopy;
        }
    }

    private byte[] mBuffer;
    private int mHead;
    private int mStoredBytes;
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/ColorScheme.java`:

```java
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

/**
 * A class describing a color scheme for an {@link EmulatorView}.
 * <p>
 * <code>EmulatorView</code> supports changing its default foreground,
 * background, and cursor colors.  Passing a <code>ColorScheme</code> to
 * {@link EmulatorView#setColorScheme setColorScheme} will cause the
 * <code>EmulatorView</code> to use the specified colors as its defaults.
 * <p>
 * Cursor colors can be omitted when specifying a color scheme; if no cursor
 * colors are specified, <code>ColorScheme</code> will automatically select
 * suitable cursor colors for you.
 *
 * @see EmulatorView#setColorScheme
 */

public class ColorScheme {
    private int foreColor;
    private int backColor;
    private int cursorForeColor;
    private int cursorBackColor;
    final private static int sDefaultCursorBackColor = 0xff808080;

    private void setDefaultCursorColors() {
        cursorBackColor = sDefaultCursorBackColor;
        // Use the foreColor unless the foreColor is too similar to the cursorBackColor
        int foreDistance = distance(foreColor, cursorBackColor);
        int backDistance = distance(backColor, cursorBackColor);
        if (foreDistance * 2 >= backDistance) {
            cursorForeColor = foreColor;
        } else {
            cursorForeColor = backColor;
        }
    }

    private static int distance(int a, int b) {
        return channelDistance(a, b, 0) * 3 + channelDistance(a, b, 1) * 5
                + channelDistance(a, b, 2);
    }

    private static int channelDistance(int a, int b, int channel) {
        return Math.abs(getChannel(a, channel) - getChannel(b, channel));
    }

    private static int getChannel(int color, int channel) {
        return 0xff & (color >> ((2 - channel) * 8));
    }

    /**
     * Creates a <code>ColorScheme</code> object.
     *
     * @param foreColor The foreground color as an ARGB hex value.
     * @param backColor The background color as an ARGB hex value.
     */
    public ColorScheme(int foreColor, int backColor) {
        this.foreColor = foreColor;
        this.backColor = backColor;
        setDefaultCursorColors();
    }

    /**
     * Creates a <code>ColorScheme</code> object.
     *
     * @param foreColor The foreground color as an ARGB hex value.
     * @param backColor The background color as an ARGB hex value.
     * @param cursorForeColor The cursor foreground color as an ARGB hex value.
     * @param cursorBackColor The cursor foreground color as an ARGB hex value.
     */
    public ColorScheme(int foreColor, int backColor, int cursorForeColor, int cursorBackColor) {
        this.foreColor = foreColor;
        this.backColor = backColor;
        this.cursorForeColor = cursorForeColor;
        this.cursorBackColor = cursorBackColor;
    }

    /**
     * Creates a <code>ColorScheme</code> object from an array.
     *
     * @param scheme An integer array <code>{ foreColor, backColor,
     *               optionalCursorForeColor, optionalCursorBackColor }</code>.
     */
    public ColorScheme(int[] scheme) {
        int schemeLength = scheme.length;
        if (schemeLength != 2 && schemeLength != 4) {
            throw new IllegalArgumentException();
        }
        this.foreColor = scheme[0];
        this.backColor = scheme[1];
        if (schemeLength == 2)  {
            setDefaultCursorColors();
        } else {
            this.cursorForeColor = scheme[2];
            this.cursorBackColor = scheme[3];
        }
    }

    /**
     * @return This <code>ColorScheme</code>'s foreground color as an ARGB
     *         hex value.
     */
    public int getForeColor() {
        return foreColor;
    }

    /**
     * @return This <code>ColorScheme</code>'s background color as an ARGB
     *         hex value.
     */
    public int getBackColor() {
        return backColor;
    }

    /**
     * @return This <code>ColorScheme</code>'s cursor foreground color as an ARGB
     *         hex value.
     */
    public int getCursorForeColor() {
        return cursorForeColor;
    }

    /**
     * @return This <code>ColorScheme</code>'s cursor background color as an ARGB
     *         hex value.
     */
    public int getCursorBackColor() {
        return cursorBackColor;
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/EmulatorDebug.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

/**
 * Debug settings.
 */

class EmulatorDebug {
    /**
     * Set to true to add debugging code and logging.
     */
    public static final boolean DEBUG = false;

    /**
     * Set to true to log IME calls.
     */
    public static final boolean LOG_IME = DEBUG & false;

    /**
     * Set to true to log each character received from the remote process to the
     * android log, which makes it easier to debug some kinds of problems with
     * emulating escape sequences and control codes.
     */
    public static final boolean LOG_CHARACTERS_FLAG = DEBUG & false;

    /**
     * Set to true to log unknown escape sequences.
     */
    public static final boolean LOG_UNKNOWN_ESCAPE_SEQUENCES = DEBUG & false;

    /**
     * The tag we use when logging, so that our messages can be distinguished
     * from other messages in the log. Public because it's used by several
     * classes.
     */
    public static final String LOG_TAG = "EmulatorView";

    public static String bytesToString(byte[] data, int base, int length) {
        StringBuilder buf = new StringBuilder();
        for (int i = 0; i < length; i++) {
            byte b = data[base + i];
            if (b < 32 || b > 126) {
                buf.append(String.format("\\x%02x", b));
            } else {
                buf.append((char)b);
            }
        }
        return buf.toString();
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/EmulatorView.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import jackpal.androidterm.emulatorview.compat.ClipboardManagerCompat;
import jackpal.androidterm.emulatorview.compat.ClipboardManagerCompatFactory;
import jackpal.androidterm.emulatorview.compat.KeycodeConstants;
import jackpal.androidterm.emulatorview.compat.Patterns;

import java.io.IOException;
import java.util.Arrays;
import java.util.Hashtable;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.style.URLSpan;
import android.text.util.Linkify;
import android.text.util.Linkify.MatchFilter;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.GestureDetector;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.inputmethod.BaseInputConnection;
import android.view.inputmethod.CompletionInfo;
import android.view.inputmethod.CorrectionInfo;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.ExtractedText;
import android.view.inputmethod.ExtractedTextRequest;
import android.view.inputmethod.InputConnection;
import android.widget.Scroller;

/**
 * A view on a {@link TermSession}.  Displays the terminal emulator's screen,
 * provides access to its scrollback buffer, and passes input through to the
 * terminal emulator.
 * <p>
 * If this view is inflated from an XML layout, you need to call {@link
 * #attachSession attachSession} and {@link #setDensity setDensity} before using
 * the view.  If creating this view from code, use the {@link
 * #EmulatorView(Context, TermSession, DisplayMetrics)} constructor, which will
 * take care of this for you.
 */
public class EmulatorView extends View implements GestureDetector.OnGestureListener {
    private final static String TAG = "EmulatorView";
    private final static boolean LOG_KEY_EVENTS = false;
    private final static boolean LOG_IME = false;

    /**
     * We defer some initialization until we have been layed out in the view
     * hierarchy. The boolean tracks when we know what our size is.
     */
    private boolean mKnownSize;

    // Set if initialization was deferred because a TermSession wasn't attached
    private boolean mDeferInit = false;

    private int mVisibleWidth;
    private int mVisibleHeight;

    private TermSession mTermSession;

    /**
     * Total width of each character, in pixels
     */
    private float mCharacterWidth;

    /**
     * Total height of each character, in pixels
     */
    private int mCharacterHeight;

    /**
     * Top-of-screen margin
     */
    private int mTopOfScreenMargin;

    /**
     * Used to render text
     */
    private TextRenderer mTextRenderer;

    /**
     * Text size. Zero means 4 x 8 font.
     */
    private int mTextSize = 10;

    private int mCursorBlink;

    /**
     * Color scheme (default foreground/background colors).
     */
    private ColorScheme mColorScheme = BaseTextRenderer.defaultColorScheme;

    private Paint mForegroundPaint;

    private Paint mBackgroundPaint;

    private boolean mUseCookedIme;

    /**
     * Our terminal emulator.
     */
    private TerminalEmulator mEmulator;

    /**
     * The number of rows of text to display.
     */
    private int mRows;

    /**
     * The number of columns of text to display.
     */
    private int mColumns;

    /**
     * The number of columns that are visible on the display.
     */

    private int mVisibleColumns;

    /*
     * The number of rows that are visible on the view
     */
    private int mVisibleRows;

    /**
     * The top row of text to display. Ranges from -activeTranscriptRows to 0
     */
    private int mTopRow;

    private int mLeftColumn;

    private static final int CURSOR_BLINK_PERIOD = 1000;

    private boolean mCursorVisible = true;

    private boolean mIsSelectingText = false;

    private boolean mBackKeySendsCharacter = false;
    private int mControlKeyCode;
    private int mFnKeyCode;
    private boolean mIsControlKeySent = false;
    private boolean mIsFnKeySent = false;

    private boolean mMouseTracking;

    private float mDensity;

    private float mScaledDensity;
    private static final int SELECT_TEXT_OFFSET_Y = -40;
    private int mSelXAnchor = -1;
    private int mSelYAnchor = -1;
    private int mSelX1 = -1;
    private int mSelY1 = -1;
    private int mSelX2 = -1;
    private int mSelY2 = -1;

    /**
     * Routing alt and meta keyCodes away from the IME allows Alt key processing to work on
     * the Asus Transformer TF101.
     * It doesn't seem to harm anything else, but it also doesn't seem to be
     * required on other platforms.
     *
     * This test should be refined as we learn more.
     */
    private final static boolean sTrapAltAndMeta = Build.MODEL.contains("Transformer TF101");

    private Runnable mBlinkCursor = new Runnable() {
        public void run() {
            if (mCursorBlink != 0) {
                mCursorVisible = ! mCursorVisible;
                mHandler.postDelayed(this, CURSOR_BLINK_PERIOD);
            } else {
                mCursorVisible = true;
            }
            // Perhaps just invalidate the character with the cursor.
            invalidate();
        }
    };

    private GestureDetector mGestureDetector;
    private GestureDetector.OnGestureListener mExtGestureListener;
    private Scroller mScroller;
    private Runnable mFlingRunner = new Runnable() {
        public void run() {
            if (mScroller.isFinished()) {
                return;
            }
            // Check whether mouse tracking was turned on during fling.
            if (isMouseTrackingActive()) {
                return;
            }

            boolean more = mScroller.computeScrollOffset();
            int newTopRow = mScroller.getCurrY();
            if (newTopRow != mTopRow) {
                mTopRow = newTopRow;
                invalidate();
            }

            if (more) {
                post(this);
            }

        }
    };

    /**
     *
     * A hash table of underlying URLs to implement clickable links.
     */
    private Hashtable<Integer,URLSpan[]> mLinkLayer = new Hashtable<Integer,URLSpan[]>();

    /**
     * Accept links that start with http[s]:
     */
    private static class HttpMatchFilter implements MatchFilter {
        public boolean acceptMatch(CharSequence s, int start, int end) {
            return startsWith(s, start, end, "http:") ||
                startsWith(s, start, end, "https:");
        }

        private boolean startsWith(CharSequence s, int start, int end,
                String prefix) {
            int prefixLen = prefix.length();
            int fragmentLen = end - start;
            if (prefixLen > fragmentLen) {
                return false;
            }
            for (int i = 0; i < prefixLen; i++) {
                if (s.charAt(start + i) != prefix.charAt(i)) {
                    return false;
                }
            }
            return true;
        }
    }

    private static MatchFilter sHttpMatchFilter = new HttpMatchFilter();

    /**
     * Convert any URLs in the current row into a URLSpan,
     * and store that result in a hash table of URLSpan entries.
     *
     * @param row The number of the row to check for links
     * @return The number of lines in a multi-line-wrap set of links
     */
    private int createLinks(int row)
    {
        TranscriptScreen transcriptScreen = mEmulator.getScreen();
        char [] line = transcriptScreen.getScriptLine(row);
        int lineCount = 1;

        //Nothing to do if there's no text.
        if(line == null)
            return lineCount;

        /* If this is not a basic line, the array returned from getScriptLine()
         * could have arbitrary garbage at the end -- find the point at which
         * the line ends and only include that in the text to linkify.
         *
         * XXX: The fact that the array returned from getScriptLine() on a
         * basic line contains no garbage is an implementation detail -- the
         * documented behavior explicitly allows garbage at the end! */
        int lineLen;
        boolean textIsBasic = transcriptScreen.isBasicLine(row);
        if (textIsBasic) {
            lineLen = line.length;
        } else {
            // The end of the valid data is marked by a NUL character
            for (lineLen = 0; line[lineLen] != 0; ++lineLen);
        }

        SpannableStringBuilder textToLinkify = new SpannableStringBuilder(new String(line, 0, lineLen));

        boolean lineWrap = transcriptScreen.getScriptLineWrap(row);

        //While the current line has a wrap
        while (lineWrap)
        {
            //Get next line
            int nextRow = row + lineCount;
            line = transcriptScreen.getScriptLine(nextRow);

            //If next line is blank, don't try and append
            if(line == null)
                break;

            boolean lineIsBasic = transcriptScreen.isBasicLine(nextRow);
            if (textIsBasic && !lineIsBasic) {
                textIsBasic = lineIsBasic;
            }
            if (lineIsBasic) {
                lineLen = line.length;
            } else {
                // The end of the valid data is marked by a NUL character
                for (lineLen = 0; line[lineLen] != 0; ++lineLen);
            }

            textToLinkify.append(new String(line, 0, lineLen));

            //Check if line after next is wrapped
            lineWrap = transcriptScreen.getScriptLineWrap(nextRow);
            ++lineCount;
        }

        Linkify.addLinks(textToLinkify, Patterns.WEB_URL,
            null, sHttpMatchFilter, null);
        URLSpan [] urls = textToLinkify.getSpans(0, textToLinkify.length(), URLSpan.class);
        if(urls.length > 0)
        {
            int columns = mColumns;

            //re-index row to 0 if it is negative
            int screenRow = row - mTopRow;

            //Create and initialize set of links
            URLSpan [][] linkRows = new URLSpan[lineCount][];
            for(int i=0; i<lineCount; ++i)
            {
                linkRows[i] = new URLSpan[columns];
                Arrays.fill(linkRows[i], null);
            }

            //For each URL:
            for(int urlNum=0; urlNum<urls.length; ++urlNum)
            {
                URLSpan url = urls[urlNum];
                int spanStart = textToLinkify.getSpanStart(url);
                int spanEnd = textToLinkify.getSpanEnd(url);

                // Build accurate indices for links
                int startRow;
                int startCol;
                int endRow;
                int endCol;
                if (textIsBasic) {
                    /* endRow/endCol must be the last character of the link,
                     * not one after -- otherwise endRow might be too large */
                    int spanLastPos = spanEnd - 1;
                    // Basic line -- can assume one char per column
                    startRow = spanStart / mColumns;
                    startCol = spanStart % mColumns;
                    endRow   = spanLastPos / mColumns;
                    endCol   = spanLastPos % mColumns;
                } else {
                    /* Iterate over the line to get starting and ending columns
                     * for this span */
                    startRow = 0;
                    startCol = 0;
                    for (int i = 0; i < spanStart; ++i) {
                        char c = textToLinkify.charAt(i);
                        if (Character.isHighSurrogate(c)) {
                            ++i;
                            startCol += UnicodeTranscript.charWidth(c, textToLinkify.charAt(i));
                        } else {
                            startCol += UnicodeTranscript.charWidth(c);
                        }
                        if (startCol >= columns) {
                            ++startRow;
                            startCol %= columns;
                        }
                    }

                    endRow = startRow;
                    endCol = startCol;
                    for (int i = spanStart; i < spanEnd; ++i) {
                        char c = textToLinkify.charAt(i);
                        if (Character.isHighSurrogate(c)) {
                            ++i;
                            endCol += UnicodeTranscript.charWidth(c, textToLinkify.charAt(i));
                        } else {
                            endCol += UnicodeTranscript.charWidth(c);
                        }
                        if (endCol >= columns) {
                            ++endRow;
                            endCol %= columns;
                        }
                    }
                }

                //Fill linkRows with the URL where appropriate
                for(int i=startRow; i <= endRow; ++i)
                {
                    int runStart = (i == startRow) ? startCol: 0;
                    int runEnd = (i == endRow) ? endCol : mColumns - 1;

                    Arrays.fill(linkRows[i], runStart, runEnd + 1, url);
                }
            }

            //Add links into the link layer for later retrieval
            for(int i=0; i<lineCount; ++i)
                mLinkLayer.put(screenRow + i, linkRows[i]);
        }
        return lineCount;
    }

    /**
     * Sends mouse wheel codes to terminal in response to fling.
     */
    private class MouseTrackingFlingRunner implements Runnable {
        private Scroller mScroller;
        private int mLastY;
        private MotionEvent mMotionEvent;

        public void fling(MotionEvent e, float velocityX, float velocityY) {
            float SCALE = 0.15f;
            mScroller.fling(0, 0,
                    -(int) (velocityX * SCALE), -(int) (velocityY * SCALE),
                    0, 0, -100, 100);
            mLastY = 0;
            mMotionEvent = e;
            post(this);
        }

        public void run() {
            if (mScroller.isFinished()) {
                return;
            }
            // Check whether mouse tracking was turned off during fling.
            if (!isMouseTrackingActive()) {
                return;
            }

            boolean more = mScroller.computeScrollOffset();
            int newY = mScroller.getCurrY();
            for (; mLastY < newY; mLastY++) {
                sendMouseEventCode(mMotionEvent, 65);
            }
            for (; mLastY > newY; mLastY--) {
                sendMouseEventCode(mMotionEvent, 64);
            }

            if (more) {
                post(this);
            }
        }
    };
    private MouseTrackingFlingRunner mMouseTrackingFlingRunner = new MouseTrackingFlingRunner();

    private float mScrollRemainder;
    private TermKeyListener mKeyListener;

    private String mImeBuffer = "";

    /**
     * Our message handler class. Implements a periodic callback.
     */
    private final Handler mHandler = new Handler();

    /**
     * Called by the TermSession when the contents of the view need updating
     */
    private UpdateCallback mUpdateNotify = new UpdateCallback() {
        public void onUpdate() {
            if ( mIsSelectingText ) {
                int rowShift = mEmulator.getScrollCounter();
                mSelY1 -= rowShift;
                mSelY2 -= rowShift;
                mSelYAnchor -= rowShift;
            }
            mEmulator.clearScrollCounter();
            ensureCursorVisible();
            invalidate();
        }
    };

    /**
     * Create an <code>EmulatorView</code> for a {@link TermSession}.
     *
     * @param context The {@link Context} for the view.
     * @param session The {@link TermSession} this view will be displaying.
     * @param metrics The {@link DisplayMetrics} of the screen on which the view
     *                will be displayed.
     */
    public EmulatorView(Context context, TermSession session, DisplayMetrics metrics) {
        super(context);
        attachSession(session);
        setDensity(metrics);
        commonConstructor(context);
    }

    /**
     * Constructor called when inflating this view from XML.
     * <p>
     * You should call {@link #attachSession attachSession} and {@link
     * #setDensity setDensity} before using an <code>EmulatorView</code> created
     * using this constructor.
     */
    public EmulatorView(Context context, AttributeSet attrs) {
        super(context, attrs);
        commonConstructor(context);
    }

    /**
     * Constructor called when inflating this view from XML with a
     * default style set.
     * <p>
     * You should call {@link #attachSession attachSession} and {@link
     * #setDensity setDensity} before using an <code>EmulatorView</code> created
     * using this constructor.
     */
    public EmulatorView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        commonConstructor(context);
    }

    private void commonConstructor(Context context) {
        // TODO: See if we want to use the API level 11 constructor to get new flywheel feature.
        mScroller = new Scroller(context);
        mMouseTrackingFlingRunner.mScroller = new Scroller(context);
    }

    /**
     * Attach a {@link TermSession} to this view.
     *
     * @param session The {@link TermSession} this view will be displaying.
     */
    public void attachSession(TermSession session) {
        mTextRenderer = null;
        mForegroundPaint = new Paint();
        mBackgroundPaint = new Paint();
        mTopRow = 0;
        mLeftColumn = 0;
        mGestureDetector = new GestureDetector(this);
        // mGestureDetector.setIsLongpressEnabled(false);
        setVerticalScrollBarEnabled(true);
        setFocusable(true);
        setFocusableInTouchMode(true);

        mTermSession = session;

        mKeyListener = new TermKeyListener(session);
        session.setKeyListener(mKeyListener);

        // Do init now if it was deferred until a TermSession was attached
        if (mDeferInit) {
            mDeferInit = false;
            mKnownSize = true;
            initialize();
        }
    }

    /**
     * Update the screen density for the screen on which the view is displayed.
     *
     * @param metrics The {@link DisplayMetrics} of the screen.
     */
    public void setDensity(DisplayMetrics metrics) {
        if (mDensity == 0) {
            // First time we've known the screen density, so update font size
            mTextSize = (int) (mTextSize * metrics.density);
        }
        mDensity = metrics.density;
        mScaledDensity = metrics.scaledDensity;
    }

    /**
     * Inform the view that it is now visible on screen.
     */
    public void onResume() {
        updateSize(false);
        if (mCursorBlink != 0) {
            mHandler.postDelayed(mBlinkCursor, CURSOR_BLINK_PERIOD);
        }
        if (mKeyListener != null) {
            mKeyListener.onResume();
        }
    }

    /**
     * Inform the view that it is no longer visible on the screen.
     */
    public void onPause() {
        if (mCursorBlink != 0) {
            mHandler.removeCallbacks(mBlinkCursor);
        }
        if (mKeyListener != null) {
            mKeyListener.onPause();
        }
    }

    /**
     * Set this <code>EmulatorView</code>'s color scheme.
     *
     * @param scheme The {@link ColorScheme} to use (use null for the default
     *               scheme).
     * @see TermSession#setColorScheme
     * @see ColorScheme
     */
    public void setColorScheme(ColorScheme scheme) {
        if (scheme == null) {
            mColorScheme = BaseTextRenderer.defaultColorScheme;
        } else {
            mColorScheme = scheme;
        }
        updateText();
    }

    @Override
    public boolean onCheckIsTextEditor() {
        return true;
    }

    @Override
    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
        outAttrs.inputType = mUseCookedIme ?
                EditorInfo.TYPE_CLASS_TEXT :
                EditorInfo.TYPE_NULL;
        return new BaseInputConnection(this, true) {
            /**
             * Used to handle composing text requests
             */
            private int mCursor;
            private int mComposingTextStart;
            private int mComposingTextEnd;
            private int mSelectedTextStart;
            private int mSelectedTextEnd;

            private void sendText(CharSequence text) {
                int n = text.length();
                char c;
                try {
                    for(int i = 0; i < n; i++) {
                        c = text.charAt(i);
                        if (Character.isHighSurrogate(c)) {
                            int codePoint;
                            if (++i < n) {
                                codePoint = Character.toCodePoint(c, text.charAt(i));
                            } else {
                                // Unicode Replacement Glyph, aka white question mark in black diamond.
                                codePoint = '\ufffd';
                            }
                            mapAndSend(codePoint);
                        } else {
                            mapAndSend(c);
                        }
                    }
                } catch (IOException e) {
                    Log.e(TAG, "error writing ", e);
                }
            }

            private void mapAndSend(int c) throws IOException {
                int result = mKeyListener.mapControlChar(c);
                if (result < TermKeyListener.KEYCODE_OFFSET) {
                    mTermSession.write(result);
                } else {
                    mKeyListener.handleKeyCode(result - TermKeyListener.KEYCODE_OFFSET, null, getKeypadApplicationMode());
                }
                clearSpecialKeyStatus();
            }

            public boolean beginBatchEdit() {
                if (LOG_IME) {
                    Log.w(TAG, "beginBatchEdit");
                }
                setImeBuffer("");
                mCursor = 0;
                mComposingTextStart = 0;
                mComposingTextEnd = 0;
                return true;
            }

            public boolean clearMetaKeyStates(int arg0) {
                if (LOG_IME) {
                    Log.w(TAG, "clearMetaKeyStates " + arg0);
                }
                return false;
            }

            public boolean commitCompletion(CompletionInfo arg0) {
                if (LOG_IME) {
                    Log.w(TAG, "commitCompletion " + arg0);
                }
                return false;
            }

            public boolean endBatchEdit() {
                if (LOG_IME) {
                    Log.w(TAG, "endBatchEdit");
                }
                return true;
            }

            public boolean finishComposingText() {
                if (LOG_IME) {
                    Log.w(TAG, "finishComposingText");
                }
                sendText(mImeBuffer);
                setImeBuffer("");
                mComposingTextStart = 0;
                mComposingTextEnd = 0;
                mCursor = 0;
                return true;
            }

            public int getCursorCapsMode(int reqModes) {
                if (LOG_IME) {
                    Log.w(TAG, "getCursorCapsMode(" + reqModes + ")");
                }
                int mode = 0;
                if ((reqModes & TextUtils.CAP_MODE_CHARACTERS) != 0) {
                    mode |= TextUtils.CAP_MODE_CHARACTERS;
                }
                return mode;
            }

            public ExtractedText getExtractedText(ExtractedTextRequest arg0,
                    int arg1) {
                if (LOG_IME) {
                    Log.w(TAG, "getExtractedText" + arg0 + "," + arg1);
                }
                return null;
            }

            public CharSequence getTextAfterCursor(int n, int flags) {
                if (LOG_IME) {
                    Log.w(TAG, "getTextAfterCursor(" + n + "," + flags + ")");
                }
                int len = Math.min(n, mImeBuffer.length() - mCursor);
                if (len <= 0 || mCursor < 0 || mCursor >= mImeBuffer.length()) {
                    return "";
                }
                return mImeBuffer.substring(mCursor, mCursor + len);
            }

            public CharSequence getTextBeforeCursor(int n, int flags) {
                if (LOG_IME) {
                    Log.w(TAG, "getTextBeforeCursor(" + n + "," + flags + ")");
                }
                int len = Math.min(n, mCursor);
                if (len <= 0 || mCursor < 0 || mCursor >= mImeBuffer.length()) {
                    return "";
                }
                return mImeBuffer.substring(mCursor-len, mCursor);
            }

            public boolean performContextMenuAction(int arg0) {
                if (LOG_IME) {
                    Log.w(TAG, "performContextMenuAction" + arg0);
                }
                return true;
            }

            public boolean performPrivateCommand(String arg0, Bundle arg1) {
                if (LOG_IME) {
                    Log.w(TAG, "performPrivateCommand" + arg0 + "," + arg1);
                }
                return true;
            }

            public boolean reportFullscreenMode(boolean arg0) {
                if (LOG_IME) {
                    Log.w(TAG, "reportFullscreenMode" + arg0);
                }
                return true;
            }

            public boolean commitCorrection (CorrectionInfo correctionInfo) {
                if (LOG_IME) {
                    Log.w(TAG, "commitCorrection");
                }
                return true;
            }

            public boolean commitText(CharSequence text, int newCursorPosition) {
                if (LOG_IME) {
                    Log.w(TAG, "commitText(\"" + text + "\", " + newCursorPosition + ")");
                }
                clearComposingText();
                sendText(text);
                setImeBuffer("");
                mCursor = 0;
                return true;
            }

            private void clearComposingText() {
                int len = mImeBuffer.length();
                if (mComposingTextStart > len || mComposingTextEnd > len) {
                    mComposingTextEnd = mComposingTextStart = 0;
                    return;
                }
                setImeBuffer(mImeBuffer.substring(0, mComposingTextStart) +
                    mImeBuffer.substring(mComposingTextEnd));
                if (mCursor < mComposingTextStart) {
                    // do nothing
                } else if (mCursor < mComposingTextEnd) {
                    mCursor = mComposingTextStart;
                } else {
                    mCursor -= mComposingTextEnd - mComposingTextStart;
                }
                mComposingTextEnd = mComposingTextStart = 0;
            }

            public boolean deleteSurroundingText(int leftLength, int rightLength) {
                if (LOG_IME) {
                    Log.w(TAG, "deleteSurroundingText(" + leftLength +
                            "," + rightLength + ")");
                }
                if (leftLength > 0) {
                    for (int i = 0; i < leftLength; i++) {
                        sendKeyEvent(
                            new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
                    }
                } else if ((leftLength == 0) && (rightLength == 0)) {
                    // Delete key held down / repeating
                    sendKeyEvent(
                        new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
                }
                // TODO: handle forward deletes.
                return true;
            }

            public boolean performEditorAction(int actionCode) {
                if (LOG_IME) {
                    Log.w(TAG, "performEditorAction(" + actionCode + ")");
                }
                if (actionCode == EditorInfo.IME_ACTION_UNSPECIFIED) {
                    // The "return" key has been pressed on the IME.
                    sendText("\r");
                }
                return true;
            }

            public boolean sendKeyEvent(KeyEvent event) {
                if (LOG_IME) {
                    Log.w(TAG, "sendKeyEvent(" + event + ")");
                }
                // Some keys are sent here rather than to commitText.
                // In particular, del and the digit keys are sent here.
                // (And I have reports that the HTC Magic also sends Return here.)
                // As a bit of defensive programming, handle every key.
                dispatchKeyEvent(event);
                return true;
            }

            public boolean setComposingText(CharSequence text, int newCursorPosition) {
                if (LOG_IME) {
                    Log.w(TAG, "setComposingText(\"" + text + "\", " + newCursorPosition + ")");
                }
                int len = mImeBuffer.length();
                if (mComposingTextStart > len || mComposingTextEnd > len) {
                    return false;
                }
                setImeBuffer(mImeBuffer.substring(0, mComposingTextStart) +
                    text + mImeBuffer.substring(mComposingTextEnd));
                mComposingTextEnd = mComposingTextStart + text.length();
                mCursor = newCursorPosition > 0 ? mComposingTextEnd + newCursorPosition - 1
                        : mComposingTextStart - newCursorPosition;
                return true;
            }

            public boolean setSelection(int start, int end) {
                if (LOG_IME) {
                    Log.w(TAG, "setSelection" + start + "," + end);
                }
                int length = mImeBuffer.length();
                if (start == end && start > 0 && start < length) {
                    mSelectedTextStart = mSelectedTextEnd = 0;
                    mCursor = start;
                } else if (start < end && start > 0 && end < length) {
                    mSelectedTextStart = start;
                    mSelectedTextEnd = end;
                    mCursor = start;
                }
                return true;
            }

            public boolean setComposingRegion(int start, int end) {
                if (LOG_IME) {
                    Log.w(TAG, "setComposingRegion " + start + "," + end);
                }
                if (start < end && start > 0 && end < mImeBuffer.length()) {
                    clearComposingText();
                    mComposingTextStart = start;
                    mComposingTextEnd = end;
                }
                return true;
            }

            public CharSequence getSelectedText(int flags) {
                if (LOG_IME) {
                    Log.w(TAG, "getSelectedText " + flags);
                }
                int len = mImeBuffer.length();
                if (mSelectedTextEnd >= len || mSelectedTextStart > mSelectedTextEnd) {
                    return "";
                }
                return mImeBuffer.substring(mSelectedTextStart, mSelectedTextEnd+1);
            }

        };
    }

    private void setImeBuffer(String buffer) {
        if (!buffer.equals(mImeBuffer)) {
            invalidate();
        }
        mImeBuffer = buffer;
    }

    /**
     * Get the terminal emulator's keypad application mode.
     */
    public boolean getKeypadApplicationMode() {
        return mEmulator.getKeypadApplicationMode();
    }

    /**
     * Set a {@link android.view.GestureDetector.OnGestureListener
     * GestureDetector.OnGestureListener} to receive gestures performed on this
     * view.  Can be used to implement additional
     * functionality via touch gestures or override built-in gestures.
     *
     * @param listener The {@link
     *                 android.view.GestureDetector.OnGestureListener
     *                 GestureDetector.OnGestureListener} which will receive
     *                 gestures.
     */
    public void setExtGestureListener(GestureDetector.OnGestureListener listener) {
        mExtGestureListener = listener;
    }

    /**
     * Compute the vertical range that the vertical scrollbar represents.
     */
    @Override
    protected int computeVerticalScrollRange() {
        return mEmulator.getScreen().getActiveRows();
    }

    /**
     * Compute the vertical extent of the horizontal scrollbar's thumb within
     * the vertical range. This value is used to compute the length of the thumb
     * within the scrollbar's track.
     */
    @Override
    protected int computeVerticalScrollExtent() {
        return mRows;
    }

    /**
     * Compute the vertical offset of the vertical scrollbar's thumb within the
     * horizontal range. This value is used to compute the position of the thumb
     * within the scrollbar's track.
     */
    @Override
    protected int computeVerticalScrollOffset() {
        return mEmulator.getScreen().getActiveRows() + mTopRow - mRows;
    }

    /**
     * Call this to initialize the view.
     */
    private void initialize() {
        TermSession session = mTermSession;

        updateText();

        mEmulator = session.getEmulator();
        session.setUpdateCallback(mUpdateNotify);

        requestFocus();
    }

    /**
     * Get the {@link TermSession} corresponding to this view.
     *
     * @return The {@link TermSession} object for this view.
     */
    public TermSession getTermSession() {
        return mTermSession;
    }

    /**
     * Get the width of the visible portion of this view.
     *
     * @return The width of the visible portion of this view, in pixels.
     */
    public int getVisibleWidth() {
        return mVisibleWidth;
    }

    /**
     * Get the height of the visible portion of this view.
     *
     * @return The height of the visible portion of this view, in pixels.
     */
    public int getVisibleHeight() {
        return mVisibleHeight;
    }

    /**
     * Gets the visible number of rows for the view, useful when updating Ptysize with the correct number of rows/columns
     * @return The rows for the visible number of rows, this is calculate in updateSize(int w, int h), please call
     * updateSize(true) if the view changed, to get the correct calculation before calling this.
     */
    public int getVisibleRows()
    {
      return mVisibleRows;
    }

    /**
     * Gets the visible number of columns for the view, again useful to get when updating PTYsize
     * @return the columns for the visisble view, please call updateSize(true) to re-calculate this if the view has changed
     */
    public int getVisibleColumns()
    {
      return mVisibleColumns;
    }


    /**
     * Page the terminal view (scroll it up or down by <code>delta</code>
     * screenfuls).
     *
     * @param delta The number of screens to scroll. Positive means scroll down,
     *        negative means scroll up.
     */
    public void page(int delta) {
        mTopRow =
                Math.min(0, Math.max(-(mEmulator.getScreen()
                        .getActiveTranscriptRows()), mTopRow + mRows * delta));
        invalidate();
    }

    /**
     * Page the terminal view horizontally.
     *
     * @param deltaColumns the number of columns to scroll. Positive scrolls to
     *        the right.
     */
    public void pageHorizontal(int deltaColumns) {
        mLeftColumn =
                Math.max(0, Math.min(mLeftColumn + deltaColumns, mColumns
                        - mVisibleColumns));
        invalidate();
    }

    /**
     * Sets the text size, which in turn sets the number of rows and columns.
     *
     * @param fontSize the new font size, in density-independent pixels.
     */
    public void setTextSize(int fontSize) {
        mTextSize = (int) (fontSize * mDensity);
        updateText();
    }

    /**
     * Sets the IME mode ("cooked" or "raw").
     *
     * @param useCookedIME Whether the IME should be used in cooked mode.
     */
    public void setUseCookedIME(boolean useCookedIME) {
        mUseCookedIme = useCookedIME;
    }

    /**
     * Returns true if mouse events are being sent as escape sequences to the terminal.
     */
    public boolean isMouseTrackingActive() {
        return mEmulator.getMouseTrackingMode() != 0 && mMouseTracking;
    }

    /**
     * Send a single mouse event code to the terminal.
     */
    private void sendMouseEventCode(MotionEvent e, int button_code) {
        int x = (int)(e.getX() / mCharacterWidth) + 1;
        int y = (int)((e.getY()-mTopOfScreenMargin) / mCharacterHeight) + 1;
        // Clip to screen, and clip to the limits of 8-bit data.
        boolean out_of_bounds =
            x < 1 || y < 1 ||
            x > mColumns || y > mRows ||
            x > 255-32 || y > 255-32;
        //Log.d(TAG, "mouse button "+x+","+y+","+button_code+",oob="+out_of_bounds);
        if(button_code < 0 || button_code > 255-32) {
            Log.e(TAG, "mouse button_code out of range: "+button_code);
            return;
        }
        if(!out_of_bounds) {
            byte[] data = {
                '\033', '[', 'M',
                (byte)(32 + button_code),
                (byte)(32 + x),
                (byte)(32 + y) };
            mTermSession.write(data, 0, data.length);
        }
    }

    // Begin GestureDetector.OnGestureListener methods

    public boolean onSingleTapUp(MotionEvent e) {
        if (mExtGestureListener != null && mExtGestureListener.onSingleTapUp(e)) {
            return true;
        }

        if (isMouseTrackingActive()) {
            sendMouseEventCode(e, 0); // BTN1 press
            sendMouseEventCode(e, 3); // release
        }

        requestFocus();
        return true;
    }

    public void onLongPress(MotionEvent e) {
        // XXX hook into external gesture listener
        showContextMenu();
    }

    public boolean onScroll(MotionEvent e1, MotionEvent e2,
            float distanceX, float distanceY) {
        if (mExtGestureListener != null && mExtGestureListener.onScroll(e1, e2, distanceX, distanceY)) {
            return true;
        }

        distanceY += mScrollRemainder;
        int deltaRows = (int) (distanceY / mCharacterHeight);
        mScrollRemainder = distanceY - deltaRows * mCharacterHeight;

        if (isMouseTrackingActive()) {
            // Send mouse wheel events to terminal.
            for (; deltaRows>0; deltaRows--) {
                sendMouseEventCode(e1, 65);
            }
            for (; deltaRows<0; deltaRows++) {
                sendMouseEventCode(e1, 64);
            }
            return true;
        }

        mTopRow =
            Math.min(0, Math.max(-(mEmulator.getScreen()
                    .getActiveTranscriptRows()), mTopRow + deltaRows));
        invalidate();

        return true;
    }

    public void onSingleTapConfirmed(MotionEvent e) {
    }

    public boolean onJumpTapDown(MotionEvent e1, MotionEvent e2) {
       // Scroll to bottom
       mTopRow = 0;
       invalidate();
       return true;
    }

    public boolean onJumpTapUp(MotionEvent e1, MotionEvent e2) {
        // Scroll to top
        mTopRow = -mEmulator.getScreen().getActiveTranscriptRows();
        invalidate();
        return true;
    }

    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
            float velocityY) {
        if (mExtGestureListener != null && mExtGestureListener.onFling(e1, e2, velocityX, velocityY)) {
            return true;
        }

        mScrollRemainder = 0.0f;
        if (isMouseTrackingActive()) {
            mMouseTrackingFlingRunner.fling(e1, velocityX, velocityY);
        } else {
            float SCALE = 0.25f;
            mScroller.fling(0, mTopRow,
                    -(int) (velocityX * SCALE), -(int) (velocityY * SCALE),
                    0, 0,
                    -mEmulator.getScreen().getActiveTranscriptRows(), 0);
            // onScroll(e1, e2, 0.1f * velocityX, -0.1f * velocityY);
            post(mFlingRunner);
        }
        return true;
    }

    public void onShowPress(MotionEvent e) {
        if (mExtGestureListener != null) {
            mExtGestureListener.onShowPress(e);
        }
    }

    public boolean onDown(MotionEvent e) {
        if (mExtGestureListener != null && mExtGestureListener.onDown(e)) {
            return true;
        }
        mScrollRemainder = 0.0f;
        return true;
    }

    // End GestureDetector.OnGestureListener methods

    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        if (mIsSelectingText) {
            return onTouchEventWhileSelectingText(ev);
        } else {
            return mGestureDetector.onTouchEvent(ev);
        }
    }

    private boolean onTouchEventWhileSelectingText(MotionEvent ev) {
        int action = ev.getAction();
        int cx = (int)(ev.getX() / mCharacterWidth);
        int cy = Math.max(0,
                (int)((ev.getY() + SELECT_TEXT_OFFSET_Y * mScaledDensity)
                        / mCharacterHeight) + mTopRow);
        switch (action) {
        case MotionEvent.ACTION_DOWN:
            mSelXAnchor = cx;
            mSelYAnchor = cy;
            mSelX1 = cx;
            mSelY1 = cy;
            mSelX2 = mSelX1;
            mSelY2 = mSelY1;
            break;
        case MotionEvent.ACTION_MOVE:
        case MotionEvent.ACTION_UP:
            int minx = Math.min(mSelXAnchor, cx);
            int maxx = Math.max(mSelXAnchor, cx);
            int miny = Math.min(mSelYAnchor, cy);
            int maxy = Math.max(mSelYAnchor, cy);
            mSelX1 = minx;
            mSelY1 = miny;
            mSelX2 = maxx;
            mSelY2 = maxy;
            if (action == MotionEvent.ACTION_UP) {
                ClipboardManagerCompat clip = ClipboardManagerCompatFactory
                        .getManager(getContext().getApplicationContext());
                clip.setText(getSelectedText().trim());
                toggleSelectingText();
            }
            invalidate();
            break;
        default:
            toggleSelectingText();
            invalidate();
            break;
        }
        return true;
    }

    /**
     * Called when a key is pressed in the view.
     *
     * @param keyCode The keycode of the key which was pressed.
     * @param event A {@link KeyEvent} describing the event.
     * @return Whether the event was handled.
     */
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (LOG_KEY_EVENTS) {
            Log.w(TAG, "onKeyDown " + keyCode);
        }
        if (handleControlKey(keyCode, true)) {
            return true;
        } else if (handleFnKey(keyCode, true)) {
            return true;
        } else if (isSystemKey(keyCode, event)) {
            if (! isInterceptedSystemKey(keyCode) ) {
                // Don't intercept the system keys
                return super.onKeyDown(keyCode, event);
            }
        }

        // Translate the keyCode into an ASCII character.

        try {
            int oldCombiningAccent = mKeyListener.getCombiningAccent();
            int oldCursorMode = mKeyListener.getCursorMode();
            mKeyListener.keyDown(keyCode, event, getKeypadApplicationMode(),
                    TermKeyListener.isEventFromToggleDevice(event));
            if (mKeyListener.getCombiningAccent() != oldCombiningAccent
                    || mKeyListener.getCursorMode() != oldCursorMode) {
                invalidate();
            }
        } catch (IOException e) {
            // Ignore I/O exceptions
        }
        return true;
    }

    /** Do we want to intercept this system key? */
    private boolean isInterceptedSystemKey(int keyCode) {
        return keyCode == KeyEvent.KEYCODE_BACK && mBackKeySendsCharacter;
    }

    /**
     * Called when a key is released in the view.
     *
     * @param keyCode The keycode of the key which was released.
     * @param event A {@link KeyEvent} describing the event.
     * @return Whether the event was handled.
     */
    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        if (LOG_KEY_EVENTS) {
            Log.w(TAG, "onKeyUp " + keyCode);
        }
        if (handleControlKey(keyCode, false)) {
            return true;
        } else if (handleFnKey(keyCode, false)) {
            return true;
        } else if (isSystemKey(keyCode, event)) {
            // Don't intercept the system keys
            if ( ! isInterceptedSystemKey(keyCode) ) {
                return super.onKeyUp(keyCode, event);
            }
        }

        mKeyListener.keyUp(keyCode, event);
        clearSpecialKeyStatus();
        return true;
    }

    @Override
    public boolean onKeyPreIme(int keyCode, KeyEvent event) {
        if (sTrapAltAndMeta) {
            boolean altEsc = mKeyListener.getAltSendsEsc();
            boolean altOn = (event.getMetaState() & KeyEvent.META_ALT_ON) != 0;
            boolean metaOn = (event.getMetaState() & KeyEvent.META_META_ON) != 0;
            boolean altPressed = (keyCode == KeyEvent.KEYCODE_ALT_LEFT)
                    || (keyCode == KeyEvent.KEYCODE_ALT_RIGHT);
            boolean altActive = mKeyListener.isAltActive();
            if (altEsc && (altOn || altPressed || altActive || metaOn)) {
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    return onKeyDown(keyCode, event);
                } else {
                    return onKeyUp(keyCode, event);
                }
            }
        }

        if (handleHardwareControlKey(keyCode, event)) {
            return true;
        }

        if (mKeyListener.isCtrlActive()) {
            if (event.getAction() == KeyEvent.ACTION_DOWN) {
                return onKeyDown(keyCode, event);
            } else {
                return onKeyUp(keyCode, event);
            }
        }

        return super.onKeyPreIme(keyCode, event);
    };

    private boolean handleControlKey(int keyCode, boolean down) {
        if (keyCode == mControlKeyCode) {
            if (LOG_KEY_EVENTS) {
                Log.w(TAG, "handleControlKey " + keyCode);
            }
            mKeyListener.handleControlKey(down);
            invalidate();
            return true;
        }
        return false;
    }

    private boolean handleHardwareControlKey(int keyCode, KeyEvent event) {
        if (keyCode == KeycodeConstants.KEYCODE_CTRL_LEFT ||
            keyCode == KeycodeConstants.KEYCODE_CTRL_RIGHT) {
            if (LOG_KEY_EVENTS) {
                Log.w(TAG, "handleHardwareControlKey " + keyCode);
            }
            boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
            mKeyListener.handleHardwareControlKey(down);
            invalidate();
            return true;
        }
        return false;
    }

    private boolean handleFnKey(int keyCode, boolean down) {
        if (keyCode == mFnKeyCode) {
            if (LOG_KEY_EVENTS) {
                Log.w(TAG, "handleFnKey " + keyCode);
            }
            mKeyListener.handleFnKey(down);
            invalidate();
            return true;
        }
        return false;
    }

    private boolean isSystemKey(int keyCode, KeyEvent event) {
        return event.isSystem();
    }

    private void clearSpecialKeyStatus() {
        if (mIsControlKeySent) {
            mIsControlKeySent = false;
            mKeyListener.handleControlKey(false);
            invalidate();
        }
        if (mIsFnKeySent) {
            mIsFnKeySent = false;
            mKeyListener.handleFnKey(false);
            invalidate();
        }
    }

    private void updateText() {
        ColorScheme scheme = mColorScheme;
        if (mTextSize > 0) {
            mTextRenderer = new PaintRenderer(mTextSize, scheme);
        }
        else {
            mTextRenderer = new Bitmap4x8FontRenderer(getResources(), scheme);
        }

        mForegroundPaint.setColor(scheme.getForeColor());
        mBackgroundPaint.setColor(scheme.getBackColor());
        mCharacterWidth = mTextRenderer.getCharacterWidth();
        mCharacterHeight = mTextRenderer.getCharacterHeight();

        updateSize(true);
    }

    /**
     * This is called during layout when the size of this view has changed. If
     * you were just added to the view hierarchy, you're called with the old
     * values of 0.
     */
    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        if (mTermSession == null) {
            // Not ready, defer until TermSession is attached
            mDeferInit = true;
            return;
        }

        if (!mKnownSize) {
            mKnownSize = true;
            initialize();
        } else {
            updateSize(false);
        }
    }

    private void updateSize(int w, int h) {
        mColumns = Math.max(1, (int) (((float) w) / mCharacterWidth));
        mVisibleColumns = Math.max(1, (int) (((float) mVisibleWidth) / mCharacterWidth));

        mTopOfScreenMargin = mTextRenderer.getTopMargin();
        mRows = Math.max(1, (h - mTopOfScreenMargin) / mCharacterHeight);
        mVisibleRows = Math.max(1, (mVisibleHeight - mTopOfScreenMargin) / mCharacterHeight);
        mTermSession.updateSize(mColumns, mRows);

        // Reset our paging:
        mTopRow = 0;
        mLeftColumn = 0;

        invalidate();
    }

    /**
     * Update the view's idea of its size.
     *
     * @param force Whether a size adjustment should be performed even if the
     *              view's size has not changed.
     */
    public void updateSize(boolean force) {
        //Need to clear saved links on each display refresh
        mLinkLayer.clear();
        if (mKnownSize) {
            int w = getWidth();
            int h = getHeight();
            // Log.w("Term", "(" + w + ", " + h + ")");
            if (force || w != mVisibleWidth || h != mVisibleHeight) {
                mVisibleWidth = w;
                mVisibleHeight = h;
                updateSize(mVisibleWidth, mVisibleHeight);
            }
        }
    }

    /**
     * Draw the view to the provided {@link Canvas}.
     *
     * @param canvas The {@link Canvas} to draw the view to.
     */
    @Override
    protected void onDraw(Canvas canvas) {
        updateSize(false);

        if (mEmulator == null) {
            // Not ready yet
            return;
        }

        int w = getWidth();
        int h = getHeight();

        boolean reverseVideo = mEmulator.getReverseVideo();
        mTextRenderer.setReverseVideo(reverseVideo);

        Paint backgroundPaint =
                reverseVideo ? mForegroundPaint : mBackgroundPaint;
        canvas.drawRect(0, 0, w, h, backgroundPaint);
        float x = -mLeftColumn * mCharacterWidth;
        float y = mCharacterHeight + mTopOfScreenMargin;
        int endLine = mTopRow + mRows;
        int cx = mEmulator.getCursorCol();
        int cy = mEmulator.getCursorRow();
        boolean cursorVisible = mCursorVisible && mEmulator.getShowCursor();
        String effectiveImeBuffer = mImeBuffer;
        int combiningAccent = mKeyListener.getCombiningAccent();
        if (combiningAccent != 0) {
            effectiveImeBuffer += String.valueOf((char) combiningAccent);
        }
        int cursorStyle = mKeyListener.getCursorMode();

        int linkLinesToSkip = 0; //for multi-line links

        for (int i = mTopRow; i < endLine; i++) {
            int cursorX = -1;
            if (i == cy && cursorVisible) {
                cursorX = cx;
            }
            int selx1 = -1;
            int selx2 = -1;
            if ( i >= mSelY1 && i <= mSelY2 ) {
                if ( i == mSelY1 ) {
                    selx1 = mSelX1;
                }
                if ( i == mSelY2 ) {
                    selx2 = mSelX2;
                } else {
                    selx2 = mColumns;
                }
            }
            mEmulator.getScreen().drawText(i, canvas, x, y, mTextRenderer, cursorX, selx1, selx2, effectiveImeBuffer, cursorStyle);
            y += mCharacterHeight;
            //if no lines to skip, create links for the line being drawn
            if(linkLinesToSkip == 0)
                linkLinesToSkip = createLinks(i);

            //createLinks always returns at least 1
            --linkLinesToSkip;
        }
    }

    private void ensureCursorVisible() {
        mTopRow = 0;
        if (mVisibleColumns > 0) {
            int cx = mEmulator.getCursorCol();
            int visibleCursorX = mEmulator.getCursorCol() - mLeftColumn;
            if (visibleCursorX < 0) {
                mLeftColumn = cx;
            } else if (visibleCursorX >= mVisibleColumns) {
                mLeftColumn = (cx - mVisibleColumns) + 1;
            }
        }
    }

    /**
     * Toggle text selection mode in the view.
     */
    public void toggleSelectingText() {
        mIsSelectingText = ! mIsSelectingText;
        setVerticalScrollBarEnabled( ! mIsSelectingText );
        if ( ! mIsSelectingText ) {
            mSelX1 = -1;
            mSelY1 = -1;
            mSelX2 = -1;
            mSelY2 = -1;
        }
    }

    /**
     * Whether the view is currently in text selection mode.
     */
    public boolean getSelectingText() {
        return mIsSelectingText;
    }

    /**
     * Get selected text.
     *
     * @return A {@link String} with the selected text.
     */
    public String getSelectedText() {
        return mEmulator.getSelectedText(mSelX1, mSelY1, mSelX2, mSelY2);
    }

    /**
     * Send a Ctrl key event to the terminal.
     */
    public void sendControlKey() {
        mIsControlKeySent = true;
        mKeyListener.handleControlKey(true);
        invalidate();
    }

    /**
     * Send an Fn key event to the terminal.  The Fn modifier key can be used to
     * generate various special characters and escape codes.
     */
    public void sendFnKey() {
        mIsFnKeySent = true;
        mKeyListener.handleFnKey(true);
        invalidate();
    }

    /**
     * Set the key code to be sent when the Back key is pressed.
     */
    public void setBackKeyCharacter(int keyCode) {
        mKeyListener.setBackKeyCharacter(keyCode);
        mBackKeySendsCharacter = (keyCode != 0);
    }

    /**
     * Set whether to prepend the ESC keycode to the character when when pressing
     * the ALT Key.
     * @param flag
     */
    public void setAltSendsEsc(boolean flag) {
        mKeyListener.setAltSendsEsc(flag);
    }

    /**
     * Set the keycode corresponding to the Ctrl key.
     */
    public void setControlKeyCode(int keyCode) {
        mControlKeyCode = keyCode;
    }

    /**
     * Set the keycode corresponding to the Fn key.
     */
    public void setFnKeyCode(int keyCode) {
        mFnKeyCode = keyCode;
    }

    public void setTermType(String termType) {
         mKeyListener.setTermType(termType);
    }

    /**
     * Set whether mouse events should be sent to the terminal as escape codes.
     */
    public void setMouseTracking(boolean flag) {
        mMouseTracking = flag;
    }


    /**
     * Get the URL for the link displayed at the specified screen coordinates.
     *
     * @param x The x coordinate being queried (from 0 to screen width)
     * @param y The y coordinate being queried (from 0 to screen height)
     * @return The URL for the link at the specified screen coordinates, or
     *         null if no link exists there.
     */
    public String getURLat(float x, float y)
    {
        float w = getWidth();
        float h = getHeight();

        //Check for division by zero
        //If width or height is zero, there are probably no links around, so return null.
        if(w == 0 || h == 0)
            return null;

        //Get fraction of total screen
        float x_pos = x / w;
        float y_pos = y / h;

        //Convert to integer row/column index
        int row = (int)Math.floor(y_pos * mRows);
        int col = (int)Math.floor(x_pos * mColumns);

        //Grab row from link layer
        URLSpan [] linkRow = mLinkLayer.get(row);
        URLSpan link;

        //If row exists, and link exists at column, return it
        if(linkRow != null && (link = linkRow[col]) != null)
            return link.getURL();
        else
            return null;
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/GrowableIntArray.java`:

```java
package jackpal.androidterm.emulatorview;

class GrowableIntArray {
    GrowableIntArray(int initalCapacity) {
        mData = new int[initalCapacity];
        mLength = 0;
    }

    void append(int i) {
        if (mLength + 1 > mData.length) {
            int newLength = Math.max((mData.length * 3) >> 1, 16);
            int[] temp = new int[newLength];
            System.arraycopy(mData, 0, temp, 0, mLength);
            mData = temp;
        }
        mData[mLength++] = i;
    }

    int length() {
        return mLength;
    }

    int at(int index) {
        return mData[index];
    }

    int[] mData;
    int mLength;
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/PaintRenderer.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Typeface;
import android.util.FloatMath;


class PaintRenderer extends BaseTextRenderer {
    public PaintRenderer(int fontSize, ColorScheme scheme) {
        super(scheme);
        mTextPaint = new Paint();
        mTextPaint.setTypeface(Typeface.MONOSPACE);
        mTextPaint.setAntiAlias(true);
        mTextPaint.setTextSize(fontSize);

        mCharHeight = (int) FloatMath.ceil(mTextPaint.getFontSpacing());
        mCharAscent = (int) FloatMath.ceil(mTextPaint.ascent());
        mCharDescent = mCharHeight + mCharAscent;
        mCharWidth = mTextPaint.measureText(EXAMPLE_CHAR, 0, 1);
    }

    public void drawTextRun(Canvas canvas, float x, float y, int lineOffset,
            int runWidth, char[] text, int index, int count,
            boolean selectionStyle, int textStyle,
            int cursorOffset, int cursorIndex, int cursorIncr, int cursorWidth, int cursorMode) {
        int foreColor = TextStyle.decodeForeColor(textStyle);
        int backColor = TextStyle.decodeBackColor(textStyle);
        int effect = TextStyle.decodeEffect(textStyle);

        boolean inverse =  mReverseVideo ^
                (effect & (TextStyle.fxInverse | TextStyle.fxItalic)) != 0;
        if (inverse) {
            int temp = foreColor;
            foreColor = backColor;
            backColor = temp;
        }

        if (selectionStyle) {
            backColor = TextStyle.ciCursorBackground;
        }

        boolean blink = (effect & TextStyle.fxBlink) != 0;
        if (blink && backColor < 8) {
            backColor += 8;
        }
        mTextPaint.setColor(mPalette[backColor]);

        float left = x + lineOffset * mCharWidth;
        canvas.drawRect(left, y + mCharAscent - mCharDescent,
                left + runWidth * mCharWidth, y,
                mTextPaint);

        boolean cursorVisible = lineOffset <= cursorOffset && cursorOffset < (lineOffset + runWidth);
        float cursorX = 0;
        if (cursorVisible) {
            cursorX = x + cursorOffset * mCharWidth;
            drawCursorImp(canvas, (int) cursorX, y, cursorWidth * mCharWidth, mCharHeight, cursorMode);
        }

        boolean invisible = (effect & TextStyle.fxInvisible) != 0;
        if (!invisible) {
            boolean bold = (effect & TextStyle.fxBold) != 0;
            boolean underline = (effect & TextStyle.fxUnderline) != 0;
            if (bold) {
                mTextPaint.setFakeBoldText(true);
            }
            if (underline) {
                mTextPaint.setUnderlineText(true);
            }
            int textPaintColor;
            if (foreColor < 8 && bold) {
                // In 16-color mode, bold also implies bright foreground colors
                textPaintColor = mPalette[foreColor+8];
            } else {
                textPaintColor = mPalette[foreColor];
            }
            mTextPaint.setColor(textPaintColor);

            float textOriginY = y - mCharDescent;

            if (cursorVisible) {
                // Text before cursor
                int countBeforeCursor = cursorIndex - index;
                int countAfterCursor = count - (countBeforeCursor + cursorIncr);
                if (countBeforeCursor > 0){
                    canvas.drawText(text, index, countBeforeCursor, left, textOriginY, mTextPaint);
                }
                // Text at cursor
                mTextPaint.setColor(mPalette[TextStyle.ciCursorForeground]);
                canvas.drawText(text, cursorIndex, cursorIncr, cursorX,
                        textOriginY, mTextPaint);
                // Text after cursor
                if (countAfterCursor > 0) {
                    mTextPaint.setColor(textPaintColor);
                    canvas.drawText(text, cursorIndex + cursorIncr, countAfterCursor,
                            cursorX + cursorWidth * mCharWidth,
                            textOriginY, mTextPaint);
                }
            } else {
                canvas.drawText(text, index, count, left, textOriginY, mTextPaint);
            }
            if (bold) {
                mTextPaint.setFakeBoldText(false);
            }
            if (underline) {
                mTextPaint.setUnderlineText(false);
            }
        }
    }

    public int getCharacterHeight() {
        return mCharHeight;
    }

    public float getCharacterWidth() {
        return mCharWidth;
    }

    public int getTopMargin() {
        return mCharDescent;
    }

    private Paint mTextPaint;
    private float mCharWidth;
    private int mCharHeight;
    private int mCharAscent;
    private int mCharDescent;
    private static final char[] EXAMPLE_CHAR = {'X'};
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/Screen.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

/**
 * An abstract screen interface. A terminal screen stores lines of text. (The
 * reason to abstract it is to allow different implementations, and to hide
 * implementation details from clients.)
 */
interface Screen {

    /**
     * Set line wrap flag for a given row. Affects how lines are logically
     * wrapped when changing screen size or converting to a transcript.
     */
    void setLineWrap(int row);

    /**
     * Store a Unicode code point into the screen at location (x, y)
     *
     * @param x X coordinate (also known as column)
     * @param y Y coordinate (also known as row)
     * @param codePoint Unicode code point to store
     * @param style the text style
     */
    void set(int x, int y, int codePoint, int style);

    /**
     * Store byte b into the screen at location (x, y)
     *
     * @param x X coordinate (also known as column)
     * @param y Y coordinate (also known as row)
     * @param b ASCII character to store
     * @param style the text style
     */
    void set(int x, int y, byte b, int style);

    /**
     * Scroll the screen down one line. To scroll the whole screen of a 24 line
     * screen, the arguments would be (0, 24).
     *
     * @param topMargin First line that is scrolled.
     * @param bottomMargin One line after the last line that is scrolled.
     * @param style the style for the newly exposed line.
     */
    void scroll(int topMargin, int bottomMargin, int style);

    /**
     * Block copy characters from one position in the screen to another. The two
     * positions can overlap. All characters of the source and destination must
     * be within the bounds of the screen, or else an InvalidParemeterException
     * will be thrown.
     *
     * @param sx source X coordinate
     * @param sy source Y coordinate
     * @param w width
     * @param h height
     * @param dx destination X coordinate
     * @param dy destination Y coordinate
     */
    void blockCopy(int sx, int sy, int w, int h, int dx, int dy);

    /**
     * Block set characters. All characters must be within the bounds of the
     * screen, or else and InvalidParemeterException will be thrown. Typically
     * this is called with a "val" argument of 32 to clear a block of
     * characters.
     *
     * @param sx source X
     * @param sy source Y
     * @param w width
     * @param h height
     * @param val value to set.
     * @param style the text style
     */
    void blockSet(int sx, int sy, int w, int h, int val, int style);

    /**
     * Get the contents of the transcript buffer as a text string.
     *
     * @return the contents of the transcript buffer.
     */
    String getTranscriptText();

    /**
     * Get the contents of the transcript buffer as a text string with color
     * information.
     *
     * @param colors A GrowableIntArray which will hold the colors.
     * @return the contents of the transcript buffer.
     */
    String getTranscriptText(GrowableIntArray colors);

    /**
     * Get the selected text inside transcript buffer as a text string.
     * @param x1 Selection start
     * @param y1 Selection start
     * @param x2 Selection end
     * @param y2 Selection end
     * @return the contents of the transcript buffer.
     */
    String getSelectedText(int x1, int y1, int x2, int y2);

    /**
     * Get the selected text inside transcript buffer as a text string with
     * color information.
     *
     * @param colors A StringBuilder which will hold the colors.
     * @param x1 Selection start
     * @param y1 Selection start
     * @param x2 Selection end
     * @param y2 Selection end
     * @return the contents of the transcript buffer.
     */
    String getSelectedText(GrowableIntArray colors, int x1, int y1, int x2, int y2);

    /**
     * Get the number of "active" (in-use) screen rows, including any rows in a
     * scrollback buffer.
     */
    int getActiveRows();

    /**
     * Try to resize the screen without losing its contents.
     *
     * @param columns
     * @param rows
     * @param cursor An int[2] containing the current cursor position
     *               { col, row }.  If the resize succeeds, the array will be
     *               updated to reflect the new location.
     * @return Whether the resize succeeded. If the operation fails, save the
     *         contents of the screen and then use the standard resize.
     */
    boolean fastResize(int columns, int rows, int[] cursor);

    /**
     * Resize the screen
     * @param columns
     * @param rows
     * @param style
     */
    void resize(int columns, int rows, int style);
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/StyleRow.java`:

```java
package jackpal.androidterm.emulatorview;

/**
 * Utility class for dealing with text style lines.
 *
 * We pack color and formatting information for a particular character into an
 * int -- see the TextStyle class for details.  The simplest way of storing
 * that information for a screen row would be to use an array of int -- but
 * given that we only use the lower three bytes of the int to store information,
 * that effectively wastes one byte per character -- nearly 8 KB per 100 lines
 * with an 80-column transcript.
 *
 * Instead, we use an array of bytes and store the bytes of each int
 * consecutively in big-endian order.
 */
final class StyleRow {
    private int mStyle;
    private int mColumns;
    /** Initially null, will be allocated when needed. */
    private byte[] mData;

    StyleRow(int style, int columns) {
        mStyle = style;
        mColumns = columns;
    }

    void set(int column, int style) {
        if (style == mStyle && mData == null) {
            return;
        }
        ensureData();
        setStyle(column, style);
    }

    int get(int column) {
        if (mData == null) {
            return mStyle;
        }
        return getStyle(column);
    }

    boolean isSolidStyle() {
        return mData == null;
    }

    int getSolidStyle() {
        if (mData != null) {
            throw new IllegalArgumentException("Not a solid style");
        }
        return mStyle;
    }

    void copy(int start, StyleRow dst, int offset, int len) {
        // fast case
        if (mData == null && dst.mData == null && start == 0 && offset == 0
                && len == mColumns) {
            dst.mStyle = mStyle;
            return;
        }
        // There are other potentially fast cases, but let's just treat them
        // all the same for simplicity.
        ensureData();
        dst.ensureData();
        System.arraycopy(mData, 3*start, dst.mData, 3*offset, 3*len);

    }

    void ensureData() {
        if (mData == null) {
            allocate();
        }
    }

    private void allocate() {
        mData = new byte[3*mColumns];
        for (int i = 0; i < mColumns; i++) {
            setStyle(i, mStyle);
        }
    }

    private int getStyle(int column) {
        int index = 3 * column;
        byte[] line = mData;
        return line[index] & 0xff | (line[index+1] & 0xff) << 8
                | (line[index+2] & 0xff) << 16;
    }

    private void setStyle(int column, int value) {
        int index = 3 * column;
        byte[] line = mData;
        line[index] = (byte) (value & 0xff);
        line[index+1] = (byte) ((value >> 8) & 0xff);
        line[index+2] = (byte) ((value >> 16) & 0xff);
    }


}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/TermKeyListener.java`:

```java
package jackpal.androidterm.emulatorview;

import jackpal.androidterm.emulatorview.compat.AndroidCompat;
import jackpal.androidterm.emulatorview.compat.KeyCharacterMapCompat;

import java.io.IOException;
import java.util.Map;
import java.util.HashMap;

import android.util.Log;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import static jackpal.androidterm.emulatorview.compat.KeycodeConstants.*;

/**
 * An ASCII key listener. Supports control characters and escape. Keeps track of
 * the current state of the alt, shift, fn, and control keys.
 *
 */
class TermKeyListener {
    private final static String TAG = "TermKeyListener";
    private static final boolean LOG_MISC = false;
    private static final boolean LOG_KEYS = false;
    private static final boolean LOG_COMBINING_ACCENT = false;

    /** Disabled for now because it interferes with ALT processing on phones with physical keyboards. */
    private final static boolean SUPPORT_8_BIT_META = false;

    private static final int KEYMOD_ALT   = 0x80000000;
    private static final int KEYMOD_CTRL  = 0x40000000;
    private static final int KEYMOD_SHIFT = 0x20000000;
    /** Means this maps raw scancode */
    private static final int KEYMOD_SCAN  = 0x10000000;

    private static Map<Integer, String> mKeyMap;

    private String[] mKeyCodes = new String[256];
    private String[] mAppKeyCodes = new String[256];

    private void initKeyCodes() {
        mKeyMap = new HashMap<Integer, String>();
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;2D");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_DPAD_LEFT, "\033[1;3D");
        mKeyMap.put(KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;4D");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_DPAD_LEFT, "\033[1;5D");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;6D");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYCODE_DPAD_LEFT, "\033[1;7D");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;8D");

        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT, "\033[1;2C");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_DPAD_RIGHT, "\033[1;3C");
        mKeyMap.put(KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT, "\033[1;4C");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_DPAD_RIGHT, "\033[1;5C");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT, "\033[1;6C");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYCODE_DPAD_RIGHT, "\033[1;7C");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT, "\033[1;8C");

        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_DPAD_UP, "\033[1;2A");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_DPAD_UP, "\033[1;3A");
        mKeyMap.put(KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_UP, "\033[1;4A");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_DPAD_UP, "\033[1;5A");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_SHIFT | KEYCODE_DPAD_UP, "\033[1;6A");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYCODE_DPAD_UP, "\033[1;7A");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_UP, "\033[1;8A");

        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_DPAD_DOWN, "\033[1;2B");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_DPAD_DOWN, "\033[1;3B");
        mKeyMap.put(KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_DOWN, "\033[1;4B");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_DPAD_DOWN, "\033[1;5B");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_SHIFT | KEYCODE_DPAD_DOWN, "\033[1;6B");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYCODE_DPAD_DOWN, "\033[1;7B");
        mKeyMap.put(KEYMOD_CTRL | KEYMOD_ALT | KEYMOD_SHIFT | KEYCODE_DPAD_DOWN, "\033[1;8B");

        //^[[3~
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_FORWARD_DEL, "\033[3;2~");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_FORWARD_DEL, "\033[3;3~");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_FORWARD_DEL, "\033[3;5~");

        //^[[2~
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_INSERT, "\033[2;2~");
        mKeyMap.put(KEYMOD_ALT | KEYCODE_INSERT, "\033[2;3~");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_INSERT, "\033[2;5~");

        mKeyMap.put(KEYMOD_CTRL | KEYCODE_MOVE_HOME, "\033[1;5H");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_MOVE_END, "\033[1;5F");

        mKeyMap.put(KEYMOD_ALT | KEYCODE_ENTER, "\033\r");
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_ENTER, "\n");
        // Duh, so special...
        mKeyMap.put(KEYMOD_CTRL | KEYCODE_SPACE, "\000");

        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F1, "\033[1;2P");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F2, "\033[1;2Q");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F3, "\033[1;2R");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F4, "\033[1;2S");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F5, "\033[15;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F6, "\033[17;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F7, "\033[18;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F8, "\033[19;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F9, "\033[20;2~");
        mKeyMap.put(KEYMOD_SHIFT | KEYCODE_F10, "\033[21;2~");

        mKeyCodes[KEYCODE_DPAD_CENTER] = "\015";
        mKeyCodes[KEYCODE_DPAD_UP] = "\033[A";
        mKeyCodes[KEYCODE_DPAD_DOWN] = "\033[B";
        mKeyCodes[KEYCODE_DPAD_RIGHT] = "\033[C";
        mKeyCodes[KEYCODE_DPAD_LEFT] = "\033[D";
        setFnKeys("vt100");
        mKeyCodes[KEYCODE_SYSRQ] = "\033[32~"; // Sys Request / Print
        // Is this Scroll lock? mKeyCodes[Cancel] = "\033[33~";
        mKeyCodes[KEYCODE_BREAK] = "\033[34~"; // Pause/Break

        mKeyCodes[KEYCODE_TAB] = "\011";
        mKeyCodes[KEYCODE_ENTER] = "\015";
        mKeyCodes[KEYCODE_ESCAPE] = "\033";

        mKeyCodes[KEYCODE_INSERT] = "\033[2~";
        mKeyCodes[KEYCODE_FORWARD_DEL] = "\033[3~";
        // Home/End keys are set by setFnKeys()
        mKeyCodes[KEYCODE_PAGE_UP] = "\033[5~";
        mKeyCodes[KEYCODE_PAGE_DOWN] = "\033[6~";
        mKeyCodes[KEYCODE_DEL]= "\177";
        mKeyCodes[KEYCODE_NUM_LOCK] = "\033OP";
        mKeyCodes[KEYCODE_NUMPAD_DIVIDE] = "/";
        mKeyCodes[KEYCODE_NUMPAD_MULTIPLY] = "*";
        mKeyCodes[KEYCODE_NUMPAD_SUBTRACT] = "-";
        mKeyCodes[KEYCODE_NUMPAD_ADD] = "+";
        mKeyCodes[KEYCODE_NUMPAD_ENTER] = "\015";
        mKeyCodes[KEYCODE_NUMPAD_EQUALS] = "=";
        mKeyCodes[KEYCODE_NUMPAD_COMMA] = ",";
/*
        mKeyCodes[KEYCODE_NUMPAD_DOT] = ".";
        mKeyCodes[KEYCODE_NUMPAD_0] = "0";
        mKeyCodes[KEYCODE_NUMPAD_1] = "1";
        mKeyCodes[KEYCODE_NUMPAD_2] = "2";
        mKeyCodes[KEYCODE_NUMPAD_3] = "3";
        mKeyCodes[KEYCODE_NUMPAD_4] = "4";
        mKeyCodes[KEYCODE_NUMPAD_5] = "5";
        mKeyCodes[KEYCODE_NUMPAD_6] = "6";
        mKeyCodes[KEYCODE_NUMPAD_7] = "7";
        mKeyCodes[KEYCODE_NUMPAD_8] = "8";
        mKeyCodes[KEYCODE_NUMPAD_9] = "9";
*/
        // Keypad is used for cursor/func keys
        mKeyCodes[KEYCODE_NUMPAD_DOT] = mKeyCodes[KEYCODE_FORWARD_DEL];
        mKeyCodes[KEYCODE_NUMPAD_0] = mKeyCodes[KEYCODE_INSERT];
        mKeyCodes[KEYCODE_NUMPAD_1] = mKeyCodes[KEYCODE_MOVE_END];
        mKeyCodes[KEYCODE_NUMPAD_2] = mKeyCodes[KEYCODE_DPAD_DOWN];
        mKeyCodes[KEYCODE_NUMPAD_3] = mKeyCodes[KEYCODE_PAGE_DOWN];
        mKeyCodes[KEYCODE_NUMPAD_4] = mKeyCodes[KEYCODE_DPAD_LEFT];
        mKeyCodes[KEYCODE_NUMPAD_5] = "5";
        mKeyCodes[KEYCODE_NUMPAD_6] = mKeyCodes[KEYCODE_DPAD_RIGHT];
        mKeyCodes[KEYCODE_NUMPAD_7] = mKeyCodes[KEYCODE_MOVE_HOME];
        mKeyCodes[KEYCODE_NUMPAD_8] = mKeyCodes[KEYCODE_DPAD_UP];
        mKeyCodes[KEYCODE_NUMPAD_9] = mKeyCodes[KEYCODE_PAGE_UP];


//        mAppKeyCodes[KEYCODE_DPAD_UP] = "\033OA";
//        mAppKeyCodes[KEYCODE_DPAD_DOWN] = "\033OB";
//        mAppKeyCodes[KEYCODE_DPAD_RIGHT] = "\033OC";
//        mAppKeyCodes[KEYCODE_DPAD_LEFT] = "\033OD";
        mAppKeyCodes[KEYCODE_NUMPAD_DIVIDE] = "\033Oo";
        mAppKeyCodes[KEYCODE_NUMPAD_MULTIPLY] = "\033Oj";
        mAppKeyCodes[KEYCODE_NUMPAD_SUBTRACT] = "\033Om";
        mAppKeyCodes[KEYCODE_NUMPAD_ADD] = "\033Ok";
        mAppKeyCodes[KEYCODE_NUMPAD_ENTER] = "\033OM";
        mAppKeyCodes[KEYCODE_NUMPAD_EQUALS] = "\033OX";
        mAppKeyCodes[KEYCODE_NUMPAD_DOT] = "\033On";
        mAppKeyCodes[KEYCODE_NUMPAD_COMMA] = "\033Ol";
        mAppKeyCodes[KEYCODE_NUMPAD_0] = "\033Op";
        mAppKeyCodes[KEYCODE_NUMPAD_1] = "\033Oq";
        mAppKeyCodes[KEYCODE_NUMPAD_2] = "\033Or";
        mAppKeyCodes[KEYCODE_NUMPAD_3] = "\033Os";
        mAppKeyCodes[KEYCODE_NUMPAD_4] = "\033Ot";
        mAppKeyCodes[KEYCODE_NUMPAD_5] = "\033Ou";
        mAppKeyCodes[KEYCODE_NUMPAD_6] = "\033Ov";
        mAppKeyCodes[KEYCODE_NUMPAD_7] = "\033Ow";
        mAppKeyCodes[KEYCODE_NUMPAD_8] = "\033Ox";
        mAppKeyCodes[KEYCODE_NUMPAD_9] = "\033Oy";
    }

    public void setCursorKeysApplicationMode(boolean val) {
        if (LOG_MISC) {
            Log.d(EmulatorDebug.LOG_TAG, "CursorKeysApplicationMode=" + val);
        }
        if (val) {
            mKeyCodes[KEYCODE_NUMPAD_8] = mKeyCodes[KEYCODE_DPAD_UP] = "\033OA";
            mKeyCodes[KEYCODE_NUMPAD_2] = mKeyCodes[KEYCODE_DPAD_DOWN] = "\033OB";
            mKeyCodes[KEYCODE_NUMPAD_6] = mKeyCodes[KEYCODE_DPAD_RIGHT] = "\033OC";
            mKeyCodes[KEYCODE_NUMPAD_4] = mKeyCodes[KEYCODE_DPAD_LEFT] = "\033OD";
        } else {
            mKeyCodes[KEYCODE_NUMPAD_8] = mKeyCodes[KEYCODE_DPAD_UP] = "\033[A";
            mKeyCodes[KEYCODE_NUMPAD_2] = mKeyCodes[KEYCODE_DPAD_DOWN] = "\033[B";
            mKeyCodes[KEYCODE_NUMPAD_6] = mKeyCodes[KEYCODE_DPAD_RIGHT] = "\033[C";
            mKeyCodes[KEYCODE_NUMPAD_4] = mKeyCodes[KEYCODE_DPAD_LEFT] = "\033[D";
        }
    }

    /**
     * The state engine for a modifier key. Can be pressed, released, locked,
     * and so on.
     *
     */
    private class ModifierKey {

        private int mState;

        private static final int UNPRESSED = 0;

        private static final int PRESSED = 1;

        private static final int RELEASED = 2;

        private static final int USED = 3;

        private static final int LOCKED = 4;

        /**
         * Construct a modifier key. UNPRESSED by default.
         *
         */
        public ModifierKey() {
            mState = UNPRESSED;
        }

        public void onPress() {
            switch (mState) {
            case PRESSED:
                // This is a repeat before use
                break;
            case RELEASED:
                mState = LOCKED;
                break;
            case USED:
                // This is a repeat after use
                break;
            case LOCKED:
                mState = UNPRESSED;
                break;
            default:
                mState = PRESSED;
                break;
            }
        }

        public void onRelease() {
            switch (mState) {
            case USED:
                mState = UNPRESSED;
                break;
            case PRESSED:
                mState = RELEASED;
                break;
            default:
                // Leave state alone
                break;
            }
        }

        public void adjustAfterKeypress() {
            switch (mState) {
            case PRESSED:
                mState = USED;
                break;
            case RELEASED:
                mState = UNPRESSED;
                break;
            default:
                // Leave state alone
                break;
            }
        }

        public boolean isActive() {
            return mState != UNPRESSED;
        }

        public int getUIMode() {
            switch (mState) {
            default:
            case UNPRESSED:
                return TextRenderer.MODE_OFF;
            case PRESSED:
            case RELEASED:
            case USED:
                return TextRenderer.MODE_ON;
            case LOCKED:
                return TextRenderer.MODE_LOCKED;
            }
        }
    }

    private ModifierKey mAltKey = new ModifierKey();

    private ModifierKey mCapKey = new ModifierKey();

    private ModifierKey mControlKey = new ModifierKey();

    private ModifierKey mFnKey = new ModifierKey();

    private int mCursorMode;

    private boolean mHardwareControlKey;

    private TermSession mTermSession;

    private int mBackKeyCode;
    private boolean mAltSendsEsc;

    private int mCombiningAccent;

    // Map keycodes out of (above) the Unicode code point space.
    static public final int KEYCODE_OFFSET = 0xA00000;

    /**
     * Construct a term key listener.
     *
     */
    public TermKeyListener(TermSession termSession) {
        mTermSession = termSession;
        initKeyCodes();
        updateCursorMode();
    }

    public void setBackKeyCharacter(int code) {
        mBackKeyCode = code;
    }

    public void setAltSendsEsc(boolean flag) {
        mAltSendsEsc = flag;
    }

    public void handleHardwareControlKey(boolean down) {
        mHardwareControlKey = down;
    }

    public void onPause() {
        // Ensure we don't have any left-over modifier state when switching
        // views.
        mHardwareControlKey = false;
    }

    public void onResume() {
        // Nothing special.
    }

    public void handleControlKey(boolean down) {
        if (down) {
            mControlKey.onPress();
        } else {
            mControlKey.onRelease();
        }
        updateCursorMode();
    }

    public void handleFnKey(boolean down) {
        if (down) {
            mFnKey.onPress();
        } else {
            mFnKey.onRelease();
        }
        updateCursorMode();
    }

    public void setTermType(String termType) {
        setFnKeys(termType);
    }

    private void setFnKeys(String termType) {
        // These key assignments taken from the debian squeeze terminfo database.
        if (termType.equals("xterm")) {
            mKeyCodes[KEYCODE_NUMPAD_7] = mKeyCodes[KEYCODE_MOVE_HOME] = "\033OH";
            mKeyCodes[KEYCODE_NUMPAD_1] = mKeyCodes[KEYCODE_MOVE_END] = "\033OF";
        } else {
            mKeyCodes[KEYCODE_NUMPAD_7] = mKeyCodes[KEYCODE_MOVE_HOME] = "\033[1~";
            mKeyCodes[KEYCODE_NUMPAD_1] = mKeyCodes[KEYCODE_MOVE_END] = "\033[4~";
        }
        if (termType.equals("vt100")) {
            mKeyCodes[KEYCODE_F1] = "\033OP"; // VT100 PF1
            mKeyCodes[KEYCODE_F2] = "\033OQ"; // VT100 PF2
            mKeyCodes[KEYCODE_F3] = "\033OR"; // VT100 PF3
            mKeyCodes[KEYCODE_F4] = "\033OS"; // VT100 PF4
            // the following keys are in the database, but aren't on a real vt100.
            mKeyCodes[KEYCODE_F5] = "\033Ot";
            mKeyCodes[KEYCODE_F6] = "\033Ou";
            mKeyCodes[KEYCODE_F7] = "\033Ov";
            mKeyCodes[KEYCODE_F8] = "\033Ol";
            mKeyCodes[KEYCODE_F9] = "\033Ow";
            mKeyCodes[KEYCODE_F10] = "\033Ox";
            // The following keys are not in database.
            mKeyCodes[KEYCODE_F11] = "\033[23~";
            mKeyCodes[KEYCODE_F12] = "\033[24~";
        } else if (termType.startsWith("linux")) {
            mKeyCodes[KEYCODE_F1] = "\033[[A";
            mKeyCodes[KEYCODE_F2] = "\033[[B";
            mKeyCodes[KEYCODE_F3] = "\033[[C";
            mKeyCodes[KEYCODE_F4] = "\033[[D";
            mKeyCodes[KEYCODE_F5] = "\033[[E";
            mKeyCodes[KEYCODE_F6] = "\033[17~";
            mKeyCodes[KEYCODE_F7] = "\033[18~";
            mKeyCodes[KEYCODE_F8] = "\033[19~";
            mKeyCodes[KEYCODE_F9] = "\033[20~";
            mKeyCodes[KEYCODE_F10] = "\033[21~";
            mKeyCodes[KEYCODE_F11] = "\033[23~";
            mKeyCodes[KEYCODE_F12] = "\033[24~";
        } else {
            // default
            // screen, screen-256colors, xterm, anything new
            mKeyCodes[KEYCODE_F1] = "\033OP"; // VT100 PF1
            mKeyCodes[KEYCODE_F2] = "\033OQ"; // VT100 PF2
            mKeyCodes[KEYCODE_F3] = "\033OR"; // VT100 PF3
            mKeyCodes[KEYCODE_F4] = "\033OS"; // VT100 PF4
            mKeyCodes[KEYCODE_F5] = "\033[15~";
            mKeyCodes[KEYCODE_F6] = "\033[17~";
            mKeyCodes[KEYCODE_F7] = "\033[18~";
            mKeyCodes[KEYCODE_F8] = "\033[19~";
            mKeyCodes[KEYCODE_F9] = "\033[20~";
            mKeyCodes[KEYCODE_F10] = "\033[21~";
            mKeyCodes[KEYCODE_F11] = "\033[23~";
            mKeyCodes[KEYCODE_F12] = "\033[24~";
        }
    }

    public int mapControlChar(int ch) {
        return mapControlChar(mHardwareControlKey || mControlKey.isActive(), mFnKey.isActive(), ch);
    }

    public int mapControlChar(boolean control, boolean fn, int ch) {
        int result = ch;
        if (control) {
            // Search is the control key.
            if (result >= 'a' && result <= 'z') {
                result = (char) (result - 'a' + '\001');
            } else if (result >= 'A' && result <= 'Z') {
                result = (char) (result - 'A' + '\001');
            } else if (result == ' ' || result == '2') {
                result = 0;
            } else if (result == '[' || result == '3') {
                result = 27; // ^[ (Esc)
            } else if (result == '\\' || result == '4') {
                result = 28;
            } else if (result == ']' || result == '5') {
                result = 29;
            } else if (result == '^' || result == '6') {
                result = 30; // control-^
            } else if (result == '_' || result == '7') {
                result = 31;
            } else if (result == '8') {
                result = 127; // DEL
            } else if (result == '9') {
                result = KEYCODE_OFFSET + KEYCODE_F11;
            } else if (result == '0') {
                result = KEYCODE_OFFSET + KEYCODE_F12;
            }
        } else if (fn) {
            if (result == 'w' || result == 'W') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_DPAD_UP;
            } else if (result == 'a' || result == 'A') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_DPAD_LEFT;
            } else if (result == 's' || result == 'S') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_DPAD_DOWN;
            } else if (result == 'd' || result == 'D') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_DPAD_RIGHT;
            } else if (result == 'p' || result == 'P') {
                result = KEYCODE_OFFSET + KEYCODE_PAGE_UP;
            } else if (result == 'n' || result == 'N') {
                result = KEYCODE_OFFSET + KEYCODE_PAGE_DOWN;
            } else if (result == 't' || result == 'T') {
                result = KEYCODE_OFFSET + KeyEvent.KEYCODE_TAB;
            } else if (result == 'l' || result == 'L') {
                result = '|';
            } else if (result == 'u' || result == 'U') {
                result = '_';
            } else if (result == 'e' || result == 'E') {
                result = 27; // ^[ (Esc)
            } else if (result == '.') {
                result = 28; // ^\
            } else if (result > '0' && result <= '9') {
                // F1-F9
                result = (char)(result + KEYCODE_OFFSET + KEYCODE_F1 - 1);
            } else if (result == '0') {
                result = KEYCODE_OFFSET + KEYCODE_F10;
            } else if (result == 'i' || result == 'I') {
                result = KEYCODE_OFFSET + KEYCODE_INSERT;
            } else if (result == 'x' || result == 'X') {
                result = KEYCODE_OFFSET + KEYCODE_FORWARD_DEL;
            } else if (result == 'h' || result == 'H') {
                result = KEYCODE_OFFSET + KEYCODE_MOVE_HOME;
            } else if (result == 'f' || result == 'F') {
                result = KEYCODE_OFFSET + KEYCODE_MOVE_END;
            }
        }

        if (result > -1) {
            mAltKey.adjustAfterKeypress();
            mCapKey.adjustAfterKeypress();
            mControlKey.adjustAfterKeypress();
            mFnKey.adjustAfterKeypress();
            updateCursorMode();
        }

        return result;
    }

    /**
     * Handle a keyDown event.
     *
     * @param keyCode the keycode of the keyDown event
     *
     */
    public void keyDown(int keyCode, KeyEvent event, boolean appMode,
            boolean allowToggle) throws IOException {
        if (LOG_KEYS) {
            Log.i(TAG, "keyDown(" + keyCode + "," + event + "," + appMode + "," + allowToggle + ")");
        }
        if (handleKeyCode(keyCode, event, appMode)) {
            return;
        }
        int result = -1;
        boolean chordedCtrl = false;
        boolean setHighBit = false;
        switch (keyCode) {
        case KeyEvent.KEYCODE_ALT_RIGHT:
        case KeyEvent.KEYCODE_ALT_LEFT:
            if (allowToggle) {
                mAltKey.onPress();
                updateCursorMode();
            }
            break;

        case KeyEvent.KEYCODE_SHIFT_LEFT:
        case KeyEvent.KEYCODE_SHIFT_RIGHT:
            if (allowToggle) {
                mCapKey.onPress();
                updateCursorMode();
            }
            break;

        case KEYCODE_CTRL_LEFT:
        case KEYCODE_CTRL_RIGHT:
            // Ignore the control key.
            return;

        case KEYCODE_CAPS_LOCK:
            // Ignore the capslock key.
            return;

        case KEYCODE_FUNCTION:
            // Ignore the function key.
            return;

        case KeyEvent.KEYCODE_BACK:
            result = mBackKeyCode;
            break;

        default: {
            int metaState = event.getMetaState();
            chordedCtrl = ((META_CTRL_ON & metaState) != 0);
            boolean effectiveCaps = allowToggle &&
                    (mCapKey.isActive());
            boolean effectiveAlt = allowToggle && mAltKey.isActive();
            int effectiveMetaState = metaState & (~META_CTRL_MASK);
            if (effectiveCaps) {
                effectiveMetaState |= KeyEvent.META_SHIFT_ON;
            }
            if (!allowToggle && (effectiveMetaState & META_ALT_ON) != 0) {
                effectiveAlt = true;
            }
            if (effectiveAlt) {
                if (mAltSendsEsc) {
                    mTermSession.write(new byte[]{0x1b},0,1);
                    effectiveMetaState &= ~KeyEvent.META_ALT_MASK;
                } else if (SUPPORT_8_BIT_META) {
                    setHighBit = true;
                    effectiveMetaState &= ~KeyEvent.META_ALT_MASK;
                } else {
                    // Legacy behavior: Pass Alt through to allow composing characters.
                    effectiveMetaState |= KeyEvent.META_ALT_ON;
                }
            }

            // Note: The Hacker keyboard IME key labeled Alt actually sends Meta.


            if ((metaState & KeyEvent.META_META_ON) != 0) {
                if (mAltSendsEsc) {
                    mTermSession.write(new byte[]{0x1b},0,1);
                    effectiveMetaState &= ~KeyEvent.META_META_MASK;
                } else {
                    if (SUPPORT_8_BIT_META) {
                        setHighBit = true;
                        effectiveMetaState &= ~KeyEvent.META_META_MASK;
                    }
                }
            }
            result = event.getUnicodeChar(effectiveMetaState);

            if ((result & KeyCharacterMap.COMBINING_ACCENT) != 0) {
                if (LOG_COMBINING_ACCENT) {
                    Log.i(TAG, "Got combining accent " + result);
                }
                mCombiningAccent = result & KeyCharacterMap.COMBINING_ACCENT_MASK;
                return;
            }
            if (mCombiningAccent != 0) {
                int unaccentedChar = result;
                result = KeyCharacterMap.getDeadChar(mCombiningAccent, unaccentedChar);
                if (LOG_COMBINING_ACCENT) {
                    Log.i(TAG, "getDeadChar(" + mCombiningAccent + ", " + unaccentedChar + ") -> " + result);
                }
                mCombiningAccent = 0;
            }

            break;
            }
        }

        boolean effectiveControl = chordedCtrl || mHardwareControlKey || (allowToggle && mControlKey.isActive());
        boolean effectiveFn = allowToggle && mFnKey.isActive();

        result = mapControlChar(effectiveControl, effectiveFn, result);

        if (result >= KEYCODE_OFFSET) {
            handleKeyCode(result - KEYCODE_OFFSET, null, appMode);
        } else if (result >= 0) {
            if (setHighBit) {
                result |= 0x80;
            }
            mTermSession.write(result);
        }
    }

    public int getCombiningAccent() {
        return mCombiningAccent;
    }

    public int getCursorMode() {
        return mCursorMode;
    }

    private void updateCursorMode() {
        mCursorMode = getCursorModeHelper(mCapKey, TextRenderer.MODE_SHIFT_SHIFT)
                | getCursorModeHelper(mAltKey, TextRenderer.MODE_ALT_SHIFT)
                | getCursorModeHelper(mControlKey, TextRenderer.MODE_CTRL_SHIFT)
                | getCursorModeHelper(mFnKey, TextRenderer.MODE_FN_SHIFT);
    }

    private static int getCursorModeHelper(ModifierKey key, int shift) {
        return key.getUIMode() << shift;
    }

    static boolean isEventFromToggleDevice(KeyEvent event) {
        if (AndroidCompat.SDK < 11) {
            return true;
        }
        KeyCharacterMapCompat kcm = KeyCharacterMapCompat.wrap(
                KeyCharacterMap.load(event.getDeviceId()));
        return kcm.getModifierBehaviour() ==
                KeyCharacterMapCompat.MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED;
    }

    public boolean handleKeyCode(int keyCode, KeyEvent event, boolean appMode) throws IOException {
        String code = null;
        if (event != null) {
            int keyMod = 0;
            // META_CTRL_ON was added only in API 11, so don't use it,
            // use our own tracking of Ctrl key instead.
            // (event.getMetaState() & META_CTRL_ON) != 0
            if (mHardwareControlKey || mControlKey.isActive()) {
                keyMod |= KEYMOD_CTRL;
            }
            if ((event.getMetaState() & META_ALT_ON) != 0) {
                keyMod |= KEYMOD_ALT;
            }
            if ((event.getMetaState() & META_SHIFT_ON) != 0) {
                keyMod |= KEYMOD_SHIFT;
            }
            // First try to map scancode
            code = mKeyMap.get(event.getScanCode() | KEYMOD_SCAN | keyMod);
            if (code == null) {
                code = mKeyMap.get(keyCode | keyMod);
            }
        }

        if (code == null && keyCode >= 0 && keyCode < mKeyCodes.length) {
            if (appMode) {
                code = mAppKeyCodes[keyCode];
            }
            if (code == null) {
                code = mKeyCodes[keyCode];
            }
        }

        if (code != null) {
            if (EmulatorDebug.LOG_CHARACTERS_FLAG) {
                byte[] bytes = code.getBytes();
                Log.d(EmulatorDebug.LOG_TAG, "Out: '" + EmulatorDebug.bytesToString(bytes, 0, bytes.length) + "'");
            }
            mTermSession.write(code);
            return true;
        }
        return false;
    }

    /**
     * Handle a keyUp event.
     *
     * @param keyCode the keyCode of the keyUp event
     */
    public void keyUp(int keyCode, KeyEvent event) {
        boolean allowToggle = isEventFromToggleDevice(event);
        switch (keyCode) {
        case KeyEvent.KEYCODE_ALT_LEFT:
        case KeyEvent.KEYCODE_ALT_RIGHT:
            if (allowToggle) {
                mAltKey.onRelease();
                updateCursorMode();
            }
            break;
        case KeyEvent.KEYCODE_SHIFT_LEFT:
        case KeyEvent.KEYCODE_SHIFT_RIGHT:
            if (allowToggle) {
                mCapKey.onRelease();
                updateCursorMode();
            }
            break;

        case KEYCODE_CTRL_LEFT:
        case KEYCODE_CTRL_RIGHT:
            // ignore control keys.
            break;

        default:
            // Ignore other keyUps
            break;
        }
    }

    public boolean getAltSendsEsc() {
        return mAltSendsEsc;
    }

    public boolean isAltActive() {
        return mAltKey.isActive();
    }

    public boolean isCtrlActive() {
        return mControlKey.isActive();
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/TermSession.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CodingErrorAction;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;

/**
 * A terminal session, consisting of a VT100 terminal emulator and its
 * input and output streams.
 * <p>
 * You need to supply an {@link InputStream} and {@link OutputStream} to
 * provide input and output to the terminal.  For a locally running
 * program, these would typically point to a tty; for a telnet program
 * they might point to a network socket.  Reader and writer threads will be
 * spawned to do I/O to these streams.  All other operations, including
 * processing of input and output in {@link #processInput processInput} and
 * {@link #write(byte[], int, int) write}, will be performed on the main thread.
 * <p>
 * Call {@link #setTermIn} and {@link #setTermOut} to connect the input and
 * output streams to the emulator.  When all of your initialization is
 * complete, your initial screen size is known, and you're ready to
 * start VT100 emulation, call {@link #initializeEmulator} or {@link
 * #updateSize} with the number of rows and columns the terminal should
 * initially have.  (If you attach the session to an {@link EmulatorView},
 * the view will take care of setting the screen size and initializing the
 * emulator for you.)
 * <p>
 * When you're done with the session, you should call {@link #finish} on it.
 * This frees emulator data from memory, stops the reader and writer threads,
 * and closes the attached I/O streams.
 */
public class TermSession {
    public void setKeyListener(TermKeyListener l) {
        mKeyListener = l;
    }

    private TermKeyListener mKeyListener;

    private ColorScheme mColorScheme = BaseTextRenderer.defaultColorScheme;
    private UpdateCallback mNotify;

    private OutputStream mTermOut;
    private InputStream mTermIn;

    private String mTitle;

    private TranscriptScreen mTranscriptScreen;
    private TerminalEmulator mEmulator;

    private boolean mDefaultUTF8Mode;

    private Thread mReaderThread;
    private ByteQueue mByteQueue;
    private byte[] mReceiveBuffer;

    private Thread mWriterThread;
    private ByteQueue mWriteQueue;
    private Handler mWriterHandler;

    private CharBuffer mWriteCharBuffer;
    private ByteBuffer mWriteByteBuffer;
    private CharsetEncoder mUTF8Encoder;

    // Number of rows in the transcript
    private static final int TRANSCRIPT_ROWS = 10000;

    private static final int NEW_INPUT = 1;
    private static final int NEW_OUTPUT = 2;
    private static final int FINISH = 3;
    private static final int EOF = 4;

    /**
     * Callback to be invoked when a {@link TermSession} finishes.
     *
     * @see TermSession#setUpdateCallback
     */
    public interface FinishCallback {
        /**
         * Callback function to be invoked when a {@link TermSession} finishes.
         *
         * @param session The <code>TermSession</code> which has finished.
         */
        void onSessionFinish(TermSession session);
    }
    private FinishCallback mFinishCallback;

    private boolean mIsRunning = false;
    private Handler mMsgHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            if (!mIsRunning) {
                return;
            }
            if (msg.what == NEW_INPUT) {
                readFromProcess();
            } else if (msg.what == EOF) {
                new Handler(Looper.getMainLooper()).post(new Runnable() {
                    @Override
                    public void run() {
                        onProcessExit();
                    }
                });
            }
        }
    };

    private UpdateCallback mTitleChangedListener;

    public TermSession() {
        this(false);
    }

    public TermSession(final boolean exitOnEOF) {
        mWriteCharBuffer = CharBuffer.allocate(2);
        mWriteByteBuffer = ByteBuffer.allocate(4);
        mUTF8Encoder = Charset.forName("UTF-8").newEncoder();
        mUTF8Encoder.onMalformedInput(CodingErrorAction.REPLACE);
        mUTF8Encoder.onUnmappableCharacter(CodingErrorAction.REPLACE);

        mReceiveBuffer = new byte[4 * 1024];
        mByteQueue = new ByteQueue(4 * 1024);
        mReaderThread = new Thread() {
            private byte[] mBuffer = new byte[4096];

            @Override
            public void run() {
                try {
                    while(true) {
                        int read = mTermIn.read(mBuffer);
                        if (read == -1) {
                            // EOF -- process exited
                            break;
                        }
                        int offset = 0;
                        while (read > 0) {
                            int written = mByteQueue.write(mBuffer,
                                    offset, read);
                            offset += written;
                            read -= written;
                            mMsgHandler.sendMessage(
                                    mMsgHandler.obtainMessage(NEW_INPUT));
                        }
                    }
                } catch (IOException e) {
                } catch (InterruptedException e) {
                }

                if (exitOnEOF) mMsgHandler.sendMessage(mMsgHandler.obtainMessage(EOF));
            }
        };
        mReaderThread.setName("TermSession input reader");

        mWriteQueue = new ByteQueue(4096);
        mWriterThread = new Thread() {
            private byte[] mBuffer = new byte[4096];

            @Override
            public void run() {
                Looper.prepare();

                mWriterHandler = new Handler() {
                    @Override
                    public void handleMessage(Message msg) {
                        if (msg.what == NEW_OUTPUT) {
                            writeToOutput();
                        } else if (msg.what == FINISH) {
                            Looper.myLooper().quit();
                        }
                    }
                };

                // Drain anything in the queue from before we started
                writeToOutput();

                Looper.loop();
            }

            private void writeToOutput() {
                ByteQueue writeQueue = mWriteQueue;
                byte[] buffer = mBuffer;
                OutputStream termOut = mTermOut;

                int bytesAvailable = writeQueue.getBytesAvailable();
                int bytesToWrite = Math.min(bytesAvailable, buffer.length);

                if (bytesToWrite == 0) {
                    return;
                }

                try {
                    writeQueue.read(buffer, 0, bytesToWrite);
                    termOut.write(buffer, 0, bytesToWrite);
                    termOut.flush();
                } catch (IOException e) {
                    // Ignore exception
                    // We don't really care if the receiver isn't listening.
                    // We just make a best effort to answer the query.
                    e.printStackTrace();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        mWriterThread.setName("TermSession output writer");
    }

    protected void onProcessExit() {
        finish();
    }

    /**
     * Set the terminal emulator's window size and start terminal emulation.
     *
     * @param columns The number of columns in the terminal window.
     * @param rows The number of rows in the terminal window.
     */
    public void initializeEmulator(int columns, int rows) {
        mTranscriptScreen = new TranscriptScreen(columns, TRANSCRIPT_ROWS, rows, mColorScheme);
        mEmulator = new TerminalEmulator(this, mTranscriptScreen, columns, rows, mColorScheme);
        mEmulator.setDefaultUTF8Mode(mDefaultUTF8Mode);
        mEmulator.setKeyListener(mKeyListener);

        mIsRunning = true;
        mReaderThread.start();
        mWriterThread.start();
    }

    /**
     * Write data to the terminal output.  The written data will be consumed by
     * the emulation client as input.
     * <p>
     * <code>write</code> itself runs on the main thread.  The default
     * implementation writes the data into a circular buffer and signals the
     * writer thread to copy it from there to the {@link OutputStream}.
     * <p>
     * Subclasses may override this method to modify the output before writing
     * it to the stream, but implementations in derived classes should call
     * through to this method to do the actual writing.
     *
     * @param data An array of bytes to write to the terminal.
     * @param offset The offset into the array at which the data starts.
     * @param count The number of bytes to be written.
     */
    public void write(byte[] data, int offset, int count) {
        try {
            while (count > 0) {
                int written = mWriteQueue.write(data, offset, count);
                offset += written;
                count -= written;
                notifyNewOutput();
            }
        } catch (InterruptedException e) {
        }
    }

    /**
     * Write the UTF-8 representation of a String to the terminal output.  The
     * written data will be consumed by the emulation client as input.
     * <p>
     * This implementation encodes the String and then calls
     * {@link #write(byte[], int, int)} to do the actual writing.  It should
     * therefore usually be unnecessary to override this method; override
     * {@link #write(byte[], int, int)} instead.
     *
     * @param data The String to write to the terminal.
     */
    public void write(String data) {
        try {
            byte[] bytes = data.getBytes("UTF-8");
            write(bytes, 0, bytes.length);
        } catch (UnsupportedEncodingException e) {
        }
    }

    /**
     * Write the UTF-8 representation of a single Unicode code point to the
     * terminal output.  The written data will be consumed by the emulation
     * client as input.
     * <p>
     * This implementation encodes the code point and then calls
     * {@link #write(byte[], int, int)} to do the actual writing.  It should
     * therefore usually be unnecessary to override this method; override
     * {@link #write(byte[], int, int)} instead.
     *
     * @param codePoint The Unicode code point to write to the terminal.
     */
    public void write(int codePoint) {
        ByteBuffer byteBuf = mWriteByteBuffer;
        if (codePoint < 128) {
            // Fast path for ASCII characters
            byte[] buf = byteBuf.array();
            buf[0] = (byte) codePoint;
            write(buf, 0, 1);
            return;
        }

        CharBuffer charBuf = mWriteCharBuffer;
        CharsetEncoder encoder = mUTF8Encoder;

        charBuf.clear();
        byteBuf.clear();
        Character.toChars(codePoint, charBuf.array(), 0);
        encoder.reset();
        encoder.encode(charBuf, byteBuf, true);
        encoder.flush(byteBuf);
        write(byteBuf.array(), 0, byteBuf.position()-1);
    }

    /* Notify the writer thread that there's new output waiting */
    private void notifyNewOutput() {
        Handler writerHandler = mWriterHandler;
        if (writerHandler == null) {
           /* Writer thread isn't started -- will pick up data once it does */
           return;
        }
        writerHandler.sendEmptyMessage(NEW_OUTPUT);
    }

    /**
     * Get the {@link OutputStream} associated with this session.
     *
     * @return This session's {@link OutputStream}.
     */
    public OutputStream getTermOut() {
        return mTermOut;
    }

    /**
     * Set the {@link OutputStream} associated with this session.
     *
     * @param termOut This session's {@link OutputStream}.
     */
    public void setTermOut(OutputStream termOut) {
        mTermOut = termOut;
    }

    /**
     * Get the {@link InputStream} associated with this session.
     *
     * @return This session's {@link InputStream}.
     */
    public InputStream getTermIn() {
        return mTermIn;
    }

    /**
     * Set the {@link InputStream} associated with this session.
     *
     * @param termIn This session's {@link InputStream}.
     */
    public void setTermIn(InputStream termIn) {
        mTermIn = termIn;
    }

    /**
     * @return Whether the terminal emulation is currently running.
     */
    public boolean isRunning() {
        return mIsRunning;
    }

    TranscriptScreen getTranscriptScreen() {
        return mTranscriptScreen;
    }

    TerminalEmulator getEmulator() {
        return mEmulator;
    }

    /**
     * Set an {@link UpdateCallback} to be invoked when the terminal emulator's
     * screen is changed.
     *
     * @param notify The {@link UpdateCallback} to be invoked on changes.
     */
    public void setUpdateCallback(UpdateCallback notify) {
        mNotify = notify;
    }

    /**
     * Notify the {@link UpdateCallback} registered by {@link
     * #setUpdateCallback setUpdateCallback} that the screen has changed.
     */
    protected void notifyUpdate() {
        if (mNotify != null) {
            mNotify.onUpdate();
        }
    }

    /**
     * Get the terminal session's title (may be null).
     */
    public String getTitle() {
        return mTitle;
    }

    /**
     * Change the terminal session's title.
     */
    public void setTitle(String title) {
        mTitle = title;
        notifyTitleChanged();
    }

    /**
     * Set an {@link UpdateCallback} to be invoked when the terminal emulator's
     * title is changed.
     *
     * @param listener The {@link UpdateCallback} to be invoked on changes.
     */
    public void setTitleChangedListener(UpdateCallback listener) {
        mTitleChangedListener = listener;
    }

    /**
     * Notify the UpdateCallback registered for title changes, if any, that the
     * terminal session's title has changed.
     */
    protected void notifyTitleChanged() {
        UpdateCallback listener = mTitleChangedListener;
        if (listener != null) {
            listener.onUpdate();
        }
    }

    /**
     * Change the terminal's window size.  Will call {@link #initializeEmulator}
     * if the emulator is not yet running.
     * <p>
     * You should override this method if your application needs to be notified
     * when the screen size changes (for example, if you need to issue
     * <code>TIOCSWINSZ</code> to a tty to adjust the window size).  <em>If you
     * do override this method, you must call through to the superclass
     * implementation.</em>
     *
     * @param columns The number of columns in the terminal window.
     * @param rows The number of rows in the terminal window.
     */
    public void updateSize(int columns, int rows) {
        if (mEmulator == null) {
            initializeEmulator(columns, rows);
        } else {
            mEmulator.updateSize(columns, rows);
        }
    }

    /**
     * Retrieve the terminal's screen and scrollback buffer.
     *
     * @return A {@link String} containing the contents of the screen and
     *         scrollback buffer.
     */
    public String getTranscriptText() {
        return mTranscriptScreen.getTranscriptText();
    }

    /**
     * Look for new input from the ptty, send it to the terminal emulator.
     */
    private void readFromProcess() {
        int bytesAvailable = mByteQueue.getBytesAvailable();
        int bytesToRead = Math.min(bytesAvailable, mReceiveBuffer.length);
        int bytesRead = 0;
        try {
            bytesRead = mByteQueue.read(mReceiveBuffer, 0, bytesToRead);
        } catch (InterruptedException e) {
            return;
        }

        // Give subclasses a chance to process the read data
        processInput(mReceiveBuffer, 0, bytesRead);
        notifyUpdate();
    }

    /**
     * Process input and send it to the terminal emulator.  This method is
     * invoked on the main thread whenever new data is read from the
     * InputStream.
     * <p>
     * The default implementation sends the data straight to the terminal
     * emulator without modifying it in any way.  Subclasses can override it to
     * modify the data before giving it to the terminal.
     *
     * @param data A byte array containing the data read.
     * @param offset The offset into the buffer where the read data begins.
     * @param count The number of bytes read.
     */
    protected void processInput(byte[] data, int offset, int count) {
        mEmulator.append(data, offset, count);
    }

    /**
     * Write something directly to the terminal emulator input, bypassing the
     * emulation client, the session's {@link InputStream}, and any processing
     * being done by {@link #processInput processInput}.
     *
     * @param data The data to be written to the terminal.
     * @param offset The starting offset into the buffer of the data.
     * @param count The length of the data to be written.
     */
    protected final void appendToEmulator(byte[] data, int offset, int count) {
        mEmulator.append(data, offset, count);
    }

    /**
     * Set the terminal emulator's color scheme (default colors).
     *
     * @param scheme The {@link ColorScheme} to be used (use null for the
     *               default scheme).
     */
    public void setColorScheme(ColorScheme scheme) {
        if (scheme == null) {
            scheme = BaseTextRenderer.defaultColorScheme;
        }
        mColorScheme = scheme;
        if (mEmulator == null) {
            return;
        }
        mEmulator.setColorScheme(scheme);
    }

    /**
     * Set whether the terminal emulator should be in UTF-8 mode by default.
     * <p>
     * In UTF-8 mode, the terminal will handle UTF-8 sequences, allowing the
     * display of text in most of the world's languages, but applications must
     * encode C1 control characters and graphics drawing characters as the
     * corresponding UTF-8 sequences.
     *
     * @param utf8ByDefault Whether the terminal emulator should be in UTF-8
     *                      mode by default.
     */
    public void setDefaultUTF8Mode(boolean utf8ByDefault) {
        mDefaultUTF8Mode = utf8ByDefault;
        if (mEmulator == null) {
            return;
        }
        mEmulator.setDefaultUTF8Mode(utf8ByDefault);
    }

    /**
     * Get whether the terminal emulator is currently in UTF-8 mode.
     *
     * @return Whether the emulator is currently in UTF-8 mode.
     */
    public boolean getUTF8Mode() {
        if (mEmulator == null) {
            return mDefaultUTF8Mode;
        } else {
            return mEmulator.getUTF8Mode();
        }
    }

    /**
     * Set an {@link UpdateCallback} to be invoked when the terminal emulator
     * goes into or out of UTF-8 mode.
     *
     * @param utf8ModeNotify The {@link UpdateCallback} to be invoked.
     */
    public void setUTF8ModeUpdateCallback(UpdateCallback utf8ModeNotify) {
        if (mEmulator != null) {
            mEmulator.setUTF8ModeUpdateCallback(utf8ModeNotify);
        }
    }

    /**
     * Reset the terminal emulator's state.
     */
    public void reset() {
        mEmulator.reset();
        notifyUpdate();
    }

    /**
     * Set a {@link FinishCallback} to be invoked once this terminal session is
     * finished.
     *
     * @param callback The {@link FinishCallback} to be invoked on finish.
     */
    public void setFinishCallback(FinishCallback callback) {
        mFinishCallback = callback;
    }

    /**
     * Finish this terminal session.  Frees resources used by the terminal
     * emulator and closes the attached <code>InputStream</code> and
     * <code>OutputStream</code>.
     */
    public void finish() {
        mIsRunning = false;
        mEmulator.finish();
        if (mTranscriptScreen != null) {
            mTranscriptScreen.finish();
        }

        // Stop the reader and writer threads, and close the I/O streams
        if (mWriterHandler != null) {
            mWriterHandler.sendEmptyMessage(FINISH);
        }
        try {
            mTermIn.close();
            mTermOut.close();
        } catch (IOException e) {
            // We don't care if this fails
        } catch (NullPointerException e) {
        }

        if (mFinishCallback != null) {
            mFinishCallback.onSessionFinish(this);
        }
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/TerminalEmulator.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;
import java.util.Locale;

import android.util.Log;

/**
 * Renders text into a screen. Contains all the terminal-specific knowledge and
 * state. Emulates a subset of the X Window System xterm terminal, which in turn
 * is an emulator for a subset of the Digital Equipment Corporation vt100
 * terminal. Missing functionality: text attributes (bold, underline, reverse
 * video, color) alternate screen cursor key and keypad escape sequences.
 */
class TerminalEmulator {
    public void setKeyListener(TermKeyListener l) {
        mKeyListener = l;
    }
    private TermKeyListener mKeyListener;
    /**
     * The cursor row. Numbered 0..mRows-1.
     */
    private int mCursorRow;

    /**
     * The cursor column. Numbered 0..mColumns-1.
     */
    private int mCursorCol;

    /**
     * The number of character rows in the terminal screen.
     */
    private int mRows;

    /**
     * The number of character columns in the terminal screen.
     */
    private int mColumns;

    /**
     * Stores the characters that appear on the screen of the emulated terminal.
     */
    private TranscriptScreen mMainBuffer;
    private TranscriptScreen mAltBuffer;
    private TranscriptScreen mScreen;

    /**
     * The terminal session this emulator is bound to.
     */
    private TermSession mSession;

    /**
     * Keeps track of the current argument of the current escape sequence.
     * Ranges from 0 to MAX_ESCAPE_PARAMETERS-1. (Typically just 0 or 1.)
     */
    private int mArgIndex;

    /**
     * The number of parameter arguments. This name comes from the ANSI standard
     * for terminal escape codes.
     */
    private static final int MAX_ESCAPE_PARAMETERS = 16;

    /**
     * Holds the arguments of the current escape sequence.
     */
    private int[] mArgs = new int[MAX_ESCAPE_PARAMETERS];

    /**
     * Holds OSC arguments, which can be strings.
     */
    private byte[] mOSCArg = new byte[MAX_OSC_STRING_LENGTH];

    private int mOSCArgLength;

    private int mOSCArgTokenizerIndex;

    /**
     * Don't know what the actual limit is, this seems OK for now.
     */
    private static final int MAX_OSC_STRING_LENGTH = 512;

    // Escape processing states:

    /**
     * Escape processing state: Not currently in an escape sequence.
     */
    private static final int ESC_NONE = 0;

    /**
     * Escape processing state: Have seen an ESC character
     */
    private static final int ESC = 1;

    /**
     * Escape processing state: Have seen ESC POUND
     */
    private static final int ESC_POUND = 2;

    /**
     * Escape processing state: Have seen ESC and a character-set-select char
     */
    private static final int ESC_SELECT_LEFT_PAREN = 3;

    /**
     * Escape processing state: Have seen ESC and a character-set-select char
     */
    private static final int ESC_SELECT_RIGHT_PAREN = 4;

    /**
     * Escape processing state: ESC [
     */
    private static final int ESC_LEFT_SQUARE_BRACKET = 5;

    /**
     * Escape processing state: ESC [ ?
     */
    private static final int ESC_LEFT_SQUARE_BRACKET_QUESTION_MARK = 6;

    /**
     * Escape processing state: ESC %
     */
    private static final int ESC_PERCENT = 7;

    /**
     * Escape processing state: ESC ] (AKA OSC - Operating System Controls)
     */
    private static final int ESC_RIGHT_SQUARE_BRACKET = 8;

    /**
     * Escape processing state: ESC ] (AKA OSC - Operating System Controls)
     */
    private static final int ESC_RIGHT_SQUARE_BRACKET_ESC = 9;

    /**
     * True if the current escape sequence should continue, false if the current
     * escape sequence should be terminated. Used when parsing a single
     * character.
     */
    private boolean mContinueSequence;

    /**
     * The current state of the escape sequence state machine.
     */
    private int mEscapeState;

    /**
     * Saved state of the cursor row, Used to implement the save/restore cursor
     * position escape sequences.
     */
    private int mSavedCursorRow;

    /**
     * Saved state of the cursor column, Used to implement the save/restore
     * cursor position escape sequences.
     */
    private int mSavedCursorCol;

    private int mSavedEffect;

    private int mSavedDecFlags_DECSC_DECRC;


    // DecSet booleans

    /**
     * This mask indicates 132-column mode is set. (As opposed to 80-column
     * mode.)
     */
    private static final int K_132_COLUMN_MODE_MASK = 1 << 3;

    /**
     * DECSCNM - set means reverse video (light background.)
     */
    private static final int K_REVERSE_VIDEO_MASK = 1 << 5;

    /**
     * This mask indicates that origin mode is set. (Cursor addressing is
     * relative to the absolute screen size, rather than the currently set top
     * and bottom margins.)
     */
    private static final int K_ORIGIN_MODE_MASK = 1 << 6;

    /**
     * This mask indicates that wraparound mode is set. (As opposed to
     * stop-at-right-column mode.)
     */
    private static final int K_WRAPAROUND_MODE_MASK = 1 << 7;

    /**
     * This mask indicates that the cursor should be shown. DECTCEM
     */

    private static final int K_SHOW_CURSOR_MASK = 1 << 25;

    /** This mask is the subset of DecSet bits that are saved / restored by
     * the DECSC / DECRC commands
     */
    private static final int K_DECSC_DECRC_MASK =
            K_ORIGIN_MODE_MASK | K_WRAPAROUND_MODE_MASK;

    /**
     * Holds multiple DECSET flags. The data is stored this way, rather than in
     * separate booleans, to make it easier to implement the save-and-restore
     * semantics. The various k*ModeMask masks can be used to extract and modify
     * the individual flags current states.
     */
    private int mDecFlags;

    /**
     * Saves away a snapshot of the DECSET flags. Used to implement save and
     * restore escape sequences.
     */
    private int mSavedDecFlags;

    /**
     * The current DECSET mouse tracking mode, zero for no mouse tracking.
     */
    private int mMouseTrackingMode;

    // Modes set with Set Mode / Reset Mode

    /**
     * True if insert mode (as opposed to replace mode) is active. In insert
     * mode new characters are inserted, pushing existing text to the right.
     */
    private boolean mInsertMode;

    /**
     * An array of tab stops. mTabStop[i] is true if there is a tab stop set for
     * column i.
     */
    private boolean[] mTabStop;

    // The margins allow portions of the screen to be locked.

    /**
     * The top margin of the screen, for scrolling purposes. Ranges from 0 to
     * mRows-2.
     */
    private int mTopMargin;

    /**
     * The bottom margin of the screen, for scrolling purposes. Ranges from
     * mTopMargin + 2 to mRows. (Defines the first row after the scrolling
     * region.
     */
    private int mBottomMargin;

    /**
     * True if the next character to be emitted will be automatically wrapped to
     * the next line. Used to disambiguate the case where the cursor is
     * positioned on column mColumns-1.
     */
    private boolean mAboutToAutoWrap;

    /**
     * The width of the last emitted spacing character.  Used to place
     * combining characters into the correct column.
     */
    private int mLastEmittedCharWidth = 0;

    /**
     * True if we just auto-wrapped and no character has been emitted on this
     * line yet.  Used to ensure combining characters following a character
     * at the edge of the screen are stored in the proper place.
     */
    private boolean mJustWrapped = false;

    /**
     * Used for debugging, counts how many chars have been processed.
     */
    private int mProcessedCharCount;

    /**
     * Foreground color, 0..255
     */
    private int mForeColor;
    private int mDefaultForeColor;

    /**
     * Background color, 0..255
     */
    private int mBackColor;
    private int mDefaultBackColor;

    /**
     * Current TextStyle effect
     */
    private int mEffect;

    private boolean mbKeypadApplicationMode;

    /** false == G0, true == G1 */
    private boolean mAlternateCharSet;

    private final static int CHAR_SET_UK = 0;
    private final static int CHAR_SET_ASCII = 1;
    private final static int CHAR_SET_SPECIAL_GRAPHICS = 2;
    private final static int CHAR_SET_ALT_STANDARD = 3;
    private final static int CHAR_SET_ALT_SPECIAL_GRAPICS = 4;

    /** What is the current graphics character set. [0] == G0, [1] == G1 */
    private int[] mCharSet = new int[2];

    /** Derived from mAlternateCharSet and mCharSet.
     *  True if we're supposed to be drawing the special graphics.
     */
    private boolean mUseAlternateCharSet;

    /**
     * Special graphics character set
     */
    private static final char[] mSpecialGraphicsCharMap = new char[128];
    static {
        for (char i = 0; i < 128; ++i) {
            mSpecialGraphicsCharMap[i] = i;
        }
        mSpecialGraphicsCharMap['_'] = ' ';	// Blank
        mSpecialGraphicsCharMap['b'] = 0x2409;	// Tab
        mSpecialGraphicsCharMap['c'] = 0x240C;	// Form feed
        mSpecialGraphicsCharMap['d'] = 0x240D;	// Carriage return
        mSpecialGraphicsCharMap['e'] = 0x240A;	// Line feed
        mSpecialGraphicsCharMap['h'] = 0x2424;	// New line
        mSpecialGraphicsCharMap['i'] = 0x240B;	// Vertical tab/"lantern"
        mSpecialGraphicsCharMap['}'] = 0x00A3;	// Pound sterling symbol
        mSpecialGraphicsCharMap['f'] = 0x00B0;	// Degree symbol
        mSpecialGraphicsCharMap['`'] = 0x2B25;	// Diamond
        mSpecialGraphicsCharMap['~'] = 0x2022;	// Bullet point
        mSpecialGraphicsCharMap['y'] = 0x2264;	// Less-than-or-equals sign (<=)
        mSpecialGraphicsCharMap['|'] = 0x2260;	// Not equals sign (!=)
        mSpecialGraphicsCharMap['z'] = 0x2265;	// Greater-than-or-equals sign (>=)
        mSpecialGraphicsCharMap['g'] = 0x00B1;	// Plus-or-minus sign (+/-)
        mSpecialGraphicsCharMap['{'] = 0x03C0;	// Lowercase Greek letter pi
        mSpecialGraphicsCharMap['.'] = 0x25BC;	// Down arrow
        mSpecialGraphicsCharMap[','] = 0x25C0;	// Left arrow
        mSpecialGraphicsCharMap['+'] = 0x25B6;	// Right arrow
        mSpecialGraphicsCharMap['-'] = 0x25B2;	// Up arrow
        mSpecialGraphicsCharMap['h'] = '#';	// Board of squares
        mSpecialGraphicsCharMap['a'] = 0x2592;	// Checkerboard
        mSpecialGraphicsCharMap['0'] = 0x2588;	// Solid block
        mSpecialGraphicsCharMap['q'] = 0x2500;	// Horizontal line (box drawing)
        mSpecialGraphicsCharMap['x'] = 0x2502;	// Vertical line (box drawing)
        mSpecialGraphicsCharMap['m'] = 0x2514;	// Lower left hand corner (box drawing)
        mSpecialGraphicsCharMap['j'] = 0x2518;	// Lower right hand corner (box drawing)
        mSpecialGraphicsCharMap['l'] = 0x250C;	// Upper left hand corner (box drawing)
        mSpecialGraphicsCharMap['k'] = 0x2510;	// Upper right hand corner (box drawing)
        mSpecialGraphicsCharMap['w'] = 0x252C;	// T pointing downwards (box drawing)
        mSpecialGraphicsCharMap['u'] = 0x2524;	// T pointing leftwards (box drawing)
        mSpecialGraphicsCharMap['t'] = 0x251C;	// T pointing rightwards (box drawing)
        mSpecialGraphicsCharMap['v'] = 0x2534;	// T pointing upwards (box drawing)
        mSpecialGraphicsCharMap['n'] = 0x253C;	// Large plus/lines crossing (box drawing)
        mSpecialGraphicsCharMap['o'] = 0x23BA;	// Horizontal scanline 1
        mSpecialGraphicsCharMap['p'] = 0x23BB;	// Horizontal scanline 3
        mSpecialGraphicsCharMap['r'] = 0x23BC;	// Horizontal scanline 7
        mSpecialGraphicsCharMap['s'] = 0x23BD;	// Horizontal scanline 9
    }

    /**
     * Used for moving selection up along with the scrolling text
     */
    private int mScrollCounter = 0;

    /**
     * UTF-8 support
     */
    private static final int UNICODE_REPLACEMENT_CHAR = 0xfffd;
    private boolean mDefaultUTF8Mode = false;
    private boolean mUTF8Mode = false;
    private boolean mUTF8EscapeUsed = false;
    private int mUTF8ToFollow = 0;
    private ByteBuffer mUTF8ByteBuffer;
    private CharBuffer mInputCharBuffer;
    private CharsetDecoder mUTF8Decoder;
    private UpdateCallback mUTF8ModeNotify;

    /** This is not accurate, but it makes the terminal more useful on
     * small screens.
     */
    private final static boolean DEFAULT_TO_AUTOWRAP_ENABLED = true;

    /**
     * Construct a terminal emulator that uses the supplied screen
     *
     * @param session the terminal session the emulator is attached to
     * @param screen the screen to render characters into.
     * @param columns the number of columns to emulate
     * @param rows the number of rows to emulate
     * @param scheme the default color scheme of this emulator
     */
    public TerminalEmulator(TermSession session, TranscriptScreen screen, int columns, int rows, ColorScheme scheme) {
        mSession = session;
        mMainBuffer = screen;
        mScreen = mMainBuffer;
        mAltBuffer = new TranscriptScreen(columns, rows, rows, scheme);
        mRows = rows;
        mColumns = columns;
        mTabStop = new boolean[mColumns];

        setColorScheme(scheme);

        mUTF8ByteBuffer = ByteBuffer.allocate(4);
        mInputCharBuffer = CharBuffer.allocate(2);
        mUTF8Decoder = Charset.forName("UTF-8").newDecoder();
        mUTF8Decoder.onMalformedInput(CodingErrorAction.REPLACE);
        mUTF8Decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);

        reset();
    }

    public TranscriptScreen getScreen() {
        return mScreen;
    }

    public void updateSize(int columns, int rows) {
        if (mRows == rows && mColumns == columns) {
            return;
        }
        if (columns <= 0) {
            throw new IllegalArgumentException("rows:" + columns);
        }

        if (rows <= 0) {
            throw new IllegalArgumentException("rows:" + rows);
        }

        TranscriptScreen screen = mScreen;
        TranscriptScreen altScreen;
        if (screen != mMainBuffer) {
            altScreen = mMainBuffer;
        } else {
            altScreen = mAltBuffer;
        }

        // Try to resize the screen without getting the transcript
        int[] cursor = { mCursorCol, mCursorRow };
        boolean fastResize = screen.fastResize(columns, rows, cursor);

        GrowableIntArray cursorColor = null;
        String charAtCursor = null;
        GrowableIntArray colors = null;
        String transcriptText = null;
        if (!fastResize) {
            /* Save the character at the cursor (if one exists) and store an
             * ASCII ESC character at the cursor's location
             * This is an epic hack that lets us restore the cursor later...
             */
            cursorColor = new GrowableIntArray(1);
            charAtCursor = screen.getSelectedText(cursorColor, mCursorCol, mCursorRow, mCursorCol, mCursorRow);
            screen.set(mCursorCol, mCursorRow, 27, 0);

            colors = new GrowableIntArray(1024);
            transcriptText = screen.getTranscriptText(colors);
            screen.resize(columns, rows, getStyle());
        }

        boolean altFastResize = true;
        GrowableIntArray altColors = null;
        String altTranscriptText = null;
        if (altScreen != null) {
            altFastResize = altScreen.fastResize(columns, rows, null);

            if (!altFastResize) {
                altColors = new GrowableIntArray(1024);
                altTranscriptText = altScreen.getTranscriptText(altColors);
                altScreen.resize(columns, rows, getStyle());
            }
        }

        if (mRows != rows) {
            mRows = rows;
            mTopMargin = 0;
            mBottomMargin = mRows;
        }
        if (mColumns != columns) {
            int oldColumns = mColumns;
            mColumns = columns;
            boolean[] oldTabStop = mTabStop;
            mTabStop = new boolean[mColumns];
            int toTransfer = Math.min(oldColumns, columns);
            System.arraycopy(oldTabStop, 0, mTabStop, 0, toTransfer);
        }

        if (!altFastResize) {
            boolean wasAboutToAutoWrap = mAboutToAutoWrap;

            // Restore the contents of the inactive screen's buffer
            mScreen = altScreen;
            mCursorRow = 0;
            mCursorCol = 0;
            mAboutToAutoWrap = false;

            int end = altTranscriptText.length()-1;
            /* Unlike for the main transcript below, don't trim off trailing
             * newlines -- the alternate transcript lacks a cursor marking, so
             * we might introduce an unwanted vertical shift in the screen
             * contents this way */
            char c, cLow;
            int colorOffset = 0;
            for (int i = 0; i <= end; i++) {
                c = altTranscriptText.charAt(i);
                int style = altColors.at(i-colorOffset);
                if (Character.isHighSurrogate(c)) {
                    cLow = altTranscriptText.charAt(++i);
                    emit(Character.toCodePoint(c, cLow), style);
                    ++colorOffset;
                } else if (c == '\n') {
                    setCursorCol(0);
                    doLinefeed();
                } else {
                    emit(c, style);
                }
            }

            mScreen = screen;
            mAboutToAutoWrap = wasAboutToAutoWrap;
        }

        if (fastResize) {
            // Only need to make sure the cursor is in the right spot
            if (cursor[0] >= 0 && cursor[1] >= 0) {
                mCursorCol = cursor[0];
                mCursorRow = cursor[1];
            } else {
                // Cursor scrolled off screen, reset the cursor to top left
                mCursorCol = 0;
                mCursorRow = 0;
            }

            return;
        }

        mCursorRow = 0;
        mCursorCol = 0;
        mAboutToAutoWrap = false;

        int newCursorRow = -1;
        int newCursorCol = -1;
        int newCursorTranscriptPos = -1;
        int end = transcriptText.length()-1;
        while ((end >= 0) && transcriptText.charAt(end) == '\n') {
            end--;
        }
        char c, cLow;
        int colorOffset = 0;
        for(int i = 0; i <= end; i++) {
            c = transcriptText.charAt(i);
            int style = colors.at(i-colorOffset);
            if (Character.isHighSurrogate(c)) {
                cLow = transcriptText.charAt(++i);
                emit(Character.toCodePoint(c, cLow), style);
                ++colorOffset;
            } else if (c == '\n') {
                setCursorCol(0);
                doLinefeed();
            } else if (c == 27) {
                /* We marked the cursor location with ESC earlier, so this
                   is the place to restore the cursor to */
                newCursorRow = mCursorRow;
                newCursorCol = mCursorCol;
                newCursorTranscriptPos = screen.getActiveRows();
                if (charAtCursor != null && charAtCursor.length() > 0) {
                    // Emit the real character that was in this spot
                    int encodedCursorColor = cursorColor.at(0);
                    emit(charAtCursor.toCharArray(), 0, charAtCursor.length(), encodedCursorColor);
                }
            } else {
                emit(c, style);
            }
        }

        // If we marked a cursor location, move the cursor there now
        if (newCursorRow != -1 && newCursorCol != -1) {
            mCursorRow = newCursorRow;
            mCursorCol = newCursorCol;

            /* Adjust for any scrolling between the time we marked the cursor
               location and now */
            int scrollCount = screen.getActiveRows() - newCursorTranscriptPos;
            if (scrollCount > 0 && scrollCount <= newCursorRow) {
                mCursorRow -= scrollCount;
            } else if (scrollCount > newCursorRow) {
                // Cursor scrolled off screen -- reset to top left corner
                mCursorRow = 0;
                mCursorCol = 0;
            }
        }
    }

    /**
     * Get the cursor's current row.
     *
     * @return the cursor's current row.
     */
    public final int getCursorRow() {
        return mCursorRow;
    }

    /**
     * Get the cursor's current column.
     *
     * @return the cursor's current column.
     */
    public final int getCursorCol() {
        return mCursorCol;
    }

    public final boolean getReverseVideo() {
        return (mDecFlags & K_REVERSE_VIDEO_MASK) != 0;
    }

    public final boolean getShowCursor() {
        return (mDecFlags & K_SHOW_CURSOR_MASK) != 0;
    }

    public final boolean getKeypadApplicationMode() {
        return mbKeypadApplicationMode;
    }

    /**
     * Get the current DECSET mouse tracking mode, zero for no mouse tracking.
     *
     * @return the current DECSET mouse tracking mode.
     */
    public final int getMouseTrackingMode() {
        return mMouseTrackingMode;
    }

    private void setDefaultTabStops() {
        for (int i = 0; i < mColumns; i++) {
            mTabStop[i] = (i & 7) == 0 && i != 0;
        }
    }

    /**
     * Accept bytes (typically from the pseudo-teletype) and process them.
     *
     * @param buffer a byte array containing the bytes to be processed
     * @param base the first index of the array to process
     * @param length the number of bytes in the array to process
     */
    public void append(byte[] buffer, int base, int length) {
        if (EmulatorDebug.LOG_CHARACTERS_FLAG) {
            Log.d(EmulatorDebug.LOG_TAG, "In: '" + EmulatorDebug.bytesToString(buffer, base, length) + "'");
        }
        for (int i = 0; i < length; i++) {
            byte b = buffer[base + i];
            try {
                process(b);
                mProcessedCharCount++;
            } catch (Exception e) {
                Log.e(EmulatorDebug.LOG_TAG, "Exception while processing character "
                        + Integer.toString(mProcessedCharCount) + " code "
                        + Integer.toString(b), e);
            }
        }
    }

    private void process(byte b) {
        process(b, true);
    }

    private void process(byte b, boolean doUTF8) {
        // Let the UTF-8 decoder try to handle it if we're in UTF-8 mode
        if (doUTF8 && mUTF8Mode && handleUTF8Sequence(b)) {
            return;
        }

        // Handle C1 control characters
        if ((b & 0x80) == 0x80 && (b & 0x7f) <= 0x1f) {
            /* ESC ((code & 0x7f) + 0x40) is the two-byte escape sequence
               corresponding to a particular C1 code */
            process((byte) 27, false);
            process((byte) ((b & 0x7f) + 0x40), false);
            return;
        }

        switch (b) {
        case 0: // NUL
            // Do nothing
            break;

        case 7: // BEL
            /* If in an OSC sequence, BEL may terminate a string; otherwise do
             * nothing */
            if (mEscapeState == ESC_RIGHT_SQUARE_BRACKET) {
                doEscRightSquareBracket(b);
            }
            break;

        case 8: // BS
            setCursorCol(Math.max(0, mCursorCol - 1));
            break;

        case 9: // HT
            // Move to next tab stop, but not past edge of screen
            setCursorCol(nextTabStop(mCursorCol));
            break;

        case 13:
            setCursorCol(0);
            break;

        case 10: // CR
        case 11: // VT
        case 12: // LF
            doLinefeed();
            break;

        case 14: // SO:
            setAltCharSet(true);
            break;

        case 15: // SI:
            setAltCharSet(false);
            break;


        case 24: // CAN
        case 26: // SUB
            if (mEscapeState != ESC_NONE) {
                mEscapeState = ESC_NONE;
                emit((byte) 127);
            }
            break;

        case 27: // ESC
            // Starts an escape sequence unless we're parsing a string
            if (mEscapeState != ESC_RIGHT_SQUARE_BRACKET) {
                startEscapeSequence(ESC);
            } else {
                doEscRightSquareBracket(b);
            }
            break;

        default:
            mContinueSequence = false;
            switch (mEscapeState) {
            case ESC_NONE:
                if (b >= 32) {
                    emit(b);
                }
                break;

            case ESC:
                doEsc(b);
                break;

            case ESC_POUND:
                doEscPound(b);
                break;

            case ESC_SELECT_LEFT_PAREN:
                doEscSelectLeftParen(b);
                break;

            case ESC_SELECT_RIGHT_PAREN:
                doEscSelectRightParen(b);
                break;

            case ESC_LEFT_SQUARE_BRACKET:
                doEscLeftSquareBracket(b); // CSI
                break;

            case ESC_LEFT_SQUARE_BRACKET_QUESTION_MARK:
                doEscLSBQuest(b); // CSI ?
                break;

            case ESC_PERCENT:
                doEscPercent(b);
                break;

            case ESC_RIGHT_SQUARE_BRACKET:
                doEscRightSquareBracket(b);
                break;

            case ESC_RIGHT_SQUARE_BRACKET_ESC:
                doEscRightSquareBracketEsc(b);
                break;

            default:
                unknownSequence(b);
                break;
            }
            if (!mContinueSequence) {
                mEscapeState = ESC_NONE;
            }
            break;
        }
    }

    private boolean handleUTF8Sequence(byte b) {
        if (mUTF8ToFollow == 0 && (b & 0x80) == 0) {
            // ASCII character -- we don't need to handle this
            return false;
        }

        if (mUTF8ToFollow > 0) {
            if ((b & 0xc0) != 0x80) {
                /* Not a UTF-8 continuation byte (doesn't begin with 0b10)
                   Replace the entire sequence with the replacement char */
                mUTF8ToFollow = 0;
                mUTF8ByteBuffer.clear();
                emit(UNICODE_REPLACEMENT_CHAR);

                /* The Unicode standard (section 3.9, definition D93) requires
                 * that we now attempt to process this byte as though it were
                 * the beginning of another possibly-valid sequence */
                return handleUTF8Sequence(b);
            }

            mUTF8ByteBuffer.put(b);
            if (--mUTF8ToFollow == 0) {
                // Sequence complete -- decode and emit it
                ByteBuffer byteBuf = mUTF8ByteBuffer;
                CharBuffer charBuf = mInputCharBuffer;
                CharsetDecoder decoder = mUTF8Decoder;

                byteBuf.rewind();
                decoder.reset();
                decoder.decode(byteBuf, charBuf, true);
                decoder.flush(charBuf);

                char[] chars = charBuf.array();
                if (chars[0] >= 0x80 && chars[0] <= 0x9f) {
                    /* Sequence decoded to a C1 control character which needs
                       to be sent through process() again */
                    process((byte) chars[0], false);
                } else {
                    emit(chars);
                }

                byteBuf.clear();
                charBuf.clear();
            }
        } else {
            if ((b & 0xe0) == 0xc0) { // 0b110 -- two-byte sequence
                mUTF8ToFollow = 1;
            } else if ((b & 0xf0) == 0xe0) { // 0b1110 -- three-byte sequence
                mUTF8ToFollow = 2;
            } else if ((b & 0xf8) == 0xf0) { // 0b11110 -- four-byte sequence
                mUTF8ToFollow = 3;
            } else {
                // Not a valid UTF-8 sequence start -- replace this char
                emit(UNICODE_REPLACEMENT_CHAR);
                return true;
            }

            mUTF8ByteBuffer.put(b);
        }

        return true;
    }

    private void setAltCharSet(boolean alternateCharSet) {
        mAlternateCharSet = alternateCharSet;
        computeEffectiveCharSet();
    }

    private void computeEffectiveCharSet() {
        int charSet = mCharSet[mAlternateCharSet ? 1 : 0];
        mUseAlternateCharSet = charSet == CHAR_SET_SPECIAL_GRAPHICS;
    }

    private int nextTabStop(int cursorCol) {
        for (int i = cursorCol + 1; i < mColumns; i++) {
            if (mTabStop[i]) {
                return i;
            }
        }
        return mColumns - 1;
    }

    private int prevTabStop(int cursorCol) {
        for (int i = cursorCol - 1; i >= 0; i--) {
            if (mTabStop[i]) {
                return i;
            }
        }
        return 0;
    }

    private void doEscPercent(byte b) {
        switch (b) {
        case '@': // Esc % @ -- return to ISO 2022 mode
           setUTF8Mode(false);
           mUTF8EscapeUsed = true;
           break;
        case 'G': // Esc % G -- UTF-8 mode
           setUTF8Mode(true);
           mUTF8EscapeUsed = true;
           break;
        default: // unimplemented character set
           break;
        }
    }

    private void doEscLSBQuest(byte b) {
        int arg = getArg0(0);
        int mask = getDecFlagsMask(arg);
        int oldFlags = mDecFlags;
        switch (b) {
        case 'h': // Esc [ ? Pn h - DECSET
            mDecFlags |= mask;
            switch (arg) {
            case 1:
                mKeyListener.setCursorKeysApplicationMode(true);
                break;
            case 47:
            case 1047:
            case 1049:
                if (mAltBuffer != null) {
                    mScreen = mAltBuffer;
                }
                break;
            }
            if (arg >= 1000 && arg <= 1003) {
                mMouseTrackingMode = arg;
            }
            break;

        case 'l': // Esc [ ? Pn l - DECRST
            mDecFlags &= ~mask;
            switch (arg) {
            case 1:
                mKeyListener.setCursorKeysApplicationMode(false);
                break;
            case 47:
            case 1047:
            case 1049:
                mScreen = mMainBuffer;
                break;
            }
            if (arg >= 1000 && arg <= 1003) {
                mMouseTrackingMode = 0;
            }
            break;

        case 'r': // Esc [ ? Pn r - restore
            mDecFlags = (mDecFlags & ~mask) | (mSavedDecFlags & mask);
            break;

        case 's': // Esc [ ? Pn s - save
            mSavedDecFlags = (mSavedDecFlags & ~mask) | (mDecFlags & mask);
            break;

        default:
            parseArg(b);
            break;
        }

        int newlySetFlags = (~oldFlags) & mDecFlags;
        int changedFlags = oldFlags ^ mDecFlags;

        // 132 column mode
        if ((changedFlags & K_132_COLUMN_MODE_MASK) != 0) {
            // We don't actually set/reset 132 cols, but we do want the
            // side effect of clearing the screen and homing the cursor.
            blockClear(0, 0, mColumns, mRows);
            setCursorRowCol(0, 0);
        }

        // origin mode
        if ((newlySetFlags & K_ORIGIN_MODE_MASK) != 0) {
            // Home the cursor.
            setCursorPosition(0, 0);
        }
    }

    private int getDecFlagsMask(int argument) {
        if (argument >= 1 && argument <= 32) {
            return (1 << argument);
        }

        return 0;
    }

    private void startEscapeSequence(int escapeState) {
        mEscapeState = escapeState;
        mArgIndex = 0;
        for (int j = 0; j < MAX_ESCAPE_PARAMETERS; j++) {
            mArgs[j] = -1;
        }
    }

    private void doLinefeed() {
        int newCursorRow = mCursorRow + 1;
        if (newCursorRow >= mBottomMargin) {
            scroll();
            newCursorRow = mBottomMargin - 1;
        }
        setCursorRow(newCursorRow);
    }

    private void continueSequence() {
        mContinueSequence = true;
    }

    private void continueSequence(int state) {
        mEscapeState = state;
        mContinueSequence = true;
    }

    private void doEscSelectLeftParen(byte b) {
        doSelectCharSet(0, b);
    }

    private void doEscSelectRightParen(byte b) {
        doSelectCharSet(1, b);
    }

    private void doSelectCharSet(int charSetIndex, byte b) {
        int charSet;
        switch (b) {
        case 'A': // United Kingdom character set
            charSet = CHAR_SET_UK;
            break;
        case 'B': // ASCII set
            charSet = CHAR_SET_ASCII;
            break;
        case '0': // Special Graphics
            charSet = CHAR_SET_SPECIAL_GRAPHICS;
            break;
        case '1': // Alternate character set
            charSet = CHAR_SET_ALT_STANDARD;
            break;
        case '2':
            charSet = CHAR_SET_ALT_SPECIAL_GRAPICS;
            break;
        default:
            unknownSequence(b);
            return;
        }
        mCharSet[charSetIndex] = charSet;
        computeEffectiveCharSet();
    }

    private void doEscPound(byte b) {
        switch (b) {
        case '8': // Esc # 8 - DECALN alignment test
            mScreen.blockSet(0, 0, mColumns, mRows, 'E',
                    getStyle());
            break;

        default:
            unknownSequence(b);
            break;
        }
    }

    private void doEsc(byte b) {
        switch (b) {
        case '#':
            continueSequence(ESC_POUND);
            break;

        case '(':
            continueSequence(ESC_SELECT_LEFT_PAREN);
            break;

        case ')':
            continueSequence(ESC_SELECT_RIGHT_PAREN);
            break;

        case '7': // DECSC save cursor
            mSavedCursorRow = mCursorRow;
            mSavedCursorCol = mCursorCol;
            mSavedEffect = mEffect;
            mSavedDecFlags_DECSC_DECRC = mDecFlags & K_DECSC_DECRC_MASK;
            break;

        case '8': // DECRC restore cursor
            setCursorRowCol(mSavedCursorRow, mSavedCursorCol);
            mEffect = mSavedEffect;
            mDecFlags = (mDecFlags & ~ K_DECSC_DECRC_MASK)
                    | mSavedDecFlags_DECSC_DECRC;
            break;

        case 'D': // INDEX
            doLinefeed();
            break;

        case 'E': // NEL
            setCursorCol(0);
            doLinefeed();
            break;

        case 'F': // Cursor to lower-left corner of screen
            setCursorRowCol(0, mBottomMargin - 1);
            break;

        case 'H': // Tab set
            mTabStop[mCursorCol] = true;
            break;

        case 'M': // Reverse index
            if (mCursorRow <= mTopMargin) {
                mScreen.blockCopy(0, mTopMargin, mColumns, mBottomMargin
                        - (mTopMargin + 1), 0, mTopMargin + 1);
                blockClear(0, mTopMargin, mColumns);
            } else {
                mCursorRow--;
            }

            break;

        case 'N': // SS2
            unimplementedSequence(b);
            break;

        case '0': // SS3
            unimplementedSequence(b);
            break;

        case 'P': // Device control string
            unimplementedSequence(b);
            break;

        case 'Z': // return terminal ID
            sendDeviceAttributes();
            break;

        case '[':
            continueSequence(ESC_LEFT_SQUARE_BRACKET);
            break;

        case '=': // DECKPAM
            mbKeypadApplicationMode = true;
            break;

        case ']': // OSC
            startCollectingOSCArgs();
            continueSequence(ESC_RIGHT_SQUARE_BRACKET);
            break;

        case '>' : // DECKPNM
            mbKeypadApplicationMode = false;
            break;

        default:
            unknownSequence(b);
            break;
        }
    }

    private void doEscLeftSquareBracket(byte b) {
        // CSI
        switch (b) {
        case '@': // ESC [ Pn @ - ICH Insert Characters
        {
            int charsAfterCursor = mColumns - mCursorCol;
            int charsToInsert = Math.min(getArg0(1), charsAfterCursor);
            int charsToMove = charsAfterCursor - charsToInsert;
            mScreen.blockCopy(mCursorCol, mCursorRow, charsToMove, 1,
                    mCursorCol + charsToInsert, mCursorRow);
            blockClear(mCursorCol, mCursorRow, charsToInsert);
        }
            break;

        case 'A': // ESC [ Pn A - Cursor Up
            setCursorRow(Math.max(mTopMargin, mCursorRow - getArg0(1)));
            break;

        case 'B': // ESC [ Pn B - Cursor Down
            setCursorRow(Math.min(mBottomMargin - 1, mCursorRow + getArg0(1)));
            break;

        case 'C': // ESC [ Pn C - Cursor Right
            setCursorCol(Math.min(mColumns - 1, mCursorCol + getArg0(1)));
            break;

        case 'D': // ESC [ Pn D - Cursor Left
            setCursorCol(Math.max(0, mCursorCol - getArg0(1)));
            break;

        case 'G': // ESC [ Pn G - Cursor Horizontal Absolute
            setCursorCol(Math.min(Math.max(1, getArg0(1)), mColumns) - 1);
            break;

        case 'H': // ESC [ Pn ; H - Cursor Position
            setHorizontalVerticalPosition();
            break;

        case 'J': // ESC [ Pn J - ED - Erase in Display
            // ED ignores the scrolling margins.
            switch (getArg0(0)) {
            case 0: // Clear below
                blockClear(mCursorCol, mCursorRow, mColumns - mCursorCol);
                blockClear(0, mCursorRow + 1, mColumns,
                        mRows - (mCursorRow + 1));
                break;

            case 1: // Erase from the start of the screen to the cursor.
                blockClear(0, 0, mColumns, mCursorRow);
                blockClear(0, mCursorRow, mCursorCol + 1);
                break;

            case 2: // Clear all
                blockClear(0, 0, mColumns, mRows);
                break;

            default:
                unknownSequence(b);
                break;
            }
            break;

        case 'K': // ESC [ Pn K - Erase in Line
            switch (getArg0(0)) {
            case 0: // Clear to right
                blockClear(mCursorCol, mCursorRow, mColumns - mCursorCol);
                break;

            case 1: // Erase start of line to cursor (including cursor)
                blockClear(0, mCursorRow, mCursorCol + 1);
                break;

            case 2: // Clear whole line
                blockClear(0, mCursorRow, mColumns);
                break;

            default:
                unknownSequence(b);
                break;
            }
            break;

        case 'L': // Insert Lines
        {
            int linesAfterCursor = mBottomMargin - mCursorRow;
            int linesToInsert = Math.min(getArg0(1), linesAfterCursor);
            int linesToMove = linesAfterCursor - linesToInsert;
            mScreen.blockCopy(0, mCursorRow, mColumns, linesToMove, 0,
                    mCursorRow + linesToInsert);
            blockClear(0, mCursorRow, mColumns, linesToInsert);
        }
            break;

        case 'M': // Delete Lines
        {
            int linesAfterCursor = mBottomMargin - mCursorRow;
            int linesToDelete = Math.min(getArg0(1), linesAfterCursor);
            int linesToMove = linesAfterCursor - linesToDelete;
            mScreen.blockCopy(0, mCursorRow + linesToDelete, mColumns,
                    linesToMove, 0, mCursorRow);
            blockClear(0, mCursorRow + linesToMove, mColumns, linesToDelete);
        }
            break;

        case 'P': // Delete Characters
        {
            int charsAfterCursor = mColumns - mCursorCol;
            int charsToDelete = Math.min(getArg0(1), charsAfterCursor);
            int charsToMove = charsAfterCursor - charsToDelete;
            mScreen.blockCopy(mCursorCol + charsToDelete, mCursorRow,
                    charsToMove, 1, mCursorCol, mCursorRow);
            blockClear(mCursorCol + charsToMove, mCursorRow, charsToDelete);
        }
            break;

        case 'T': // Mouse tracking
            unimplementedSequence(b);
            break;

        case 'X': // Erase characters
            blockClear(mCursorCol, mCursorRow, getArg0(0));
            break;

        case 'Z': // Back tab
            setCursorCol(prevTabStop(mCursorCol));
            break;

        case '?': // Esc [ ? -- start of a private mode set
            continueSequence(ESC_LEFT_SQUARE_BRACKET_QUESTION_MARK);
            break;

        case 'c': // Send device attributes
            sendDeviceAttributes();
            break;

        case 'd': // ESC [ Pn d - Vert Position Absolute
            setCursorRow(Math.min(Math.max(1, getArg0(1)), mRows) - 1);
            break;

        case 'f': // Horizontal and Vertical Position
            setHorizontalVerticalPosition();
            break;

        case 'g': // Clear tab stop
            switch (getArg0(0)) {
            case 0:
                mTabStop[mCursorCol] = false;
                break;

            case 3:
                for (int i = 0; i < mColumns; i++) {
                    mTabStop[i] = false;
                }
                break;

            default:
                // Specified to have no effect.
                break;
            }
            break;

        case 'h': // Set Mode
            doSetMode(true);
            break;

        case 'l': // Reset Mode
            doSetMode(false);
            break;

        case 'm': // Esc [ Pn m - character attributes.
                  // (can have up to 16 numerical arguments)
            selectGraphicRendition();
            break;

        case 'n': // Esc [ Pn n - ECMA-48 Status Report Commands
            //sendDeviceAttributes()
            switch (getArg0(0)) {
            case 5: // Device status report (DSR):
                    // Answer is ESC [ 0 n (Terminal OK).
                byte[] dsr = { (byte) 27, (byte) '[', (byte) '0', (byte) 'n' };
                mSession.write(dsr, 0, dsr.length);
                break;

            case 6: // Cursor position report (CPR):
                    // Answer is ESC [ y ; x R, where x,y is
                    // the cursor location.
                byte[] cpr = String.format(Locale.US, "\033[%d;%dR",
                                 mCursorRow + 1, mCursorCol + 1).getBytes();
                mSession.write(cpr, 0, cpr.length);
                break;

            default:
                break;
            }
            break;

        case 'r': // Esc [ Pn ; Pn r - set top and bottom margins
        {
            // The top margin defaults to 1, the bottom margin
            // (unusually for arguments) defaults to mRows.
            //
            // The escape sequence numbers top 1..23, but we
            // number top 0..22.
            // The escape sequence numbers bottom 2..24, and
            // so do we (because we use a zero based numbering
            // scheme, but we store the first line below the
            // bottom-most scrolling line.
            // As a result, we adjust the top line by -1, but
            // we leave the bottom line alone.
            //
            // Also require that top + 2 <= bottom

            int top = Math.max(0, Math.min(getArg0(1) - 1, mRows - 2));
            int bottom = Math.max(top + 2, Math.min(getArg1(mRows), mRows));
            mTopMargin = top;
            mBottomMargin = bottom;

            // The cursor is placed in the home position
            setCursorRowCol(mTopMargin, 0);
        }
            break;

        default:
            parseArg(b);
            break;
        }
    }

    private void selectGraphicRendition() {
        // SGR
        for (int i = 0; i <= mArgIndex; i++) {
            int code = mArgs[i];
            if ( code < 0) {
                if (mArgIndex > 0) {
                    continue;
                } else {
                    code = 0;
                }
            }

            // See http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

            if (code == 0) { // reset
                mForeColor = mDefaultForeColor;
                mBackColor = mDefaultBackColor;
                mEffect = TextStyle.fxNormal;
            } else if (code == 1) { // bold
                mEffect |= TextStyle.fxBold;
            } else if (code == 3) { // italics, but rarely used as such; "standout" (inverse colors) with TERM=screen
                mEffect |= TextStyle.fxItalic;
            } else if (code == 4) { // underscore
                mEffect |= TextStyle.fxUnderline;
            } else if (code == 5) { // blink
                mEffect |= TextStyle.fxBlink;
            } else if (code == 7) { // inverse
                mEffect |= TextStyle.fxInverse;
            } else if (code == 8) { // invisible
                mEffect |= TextStyle.fxInvisible;
            } else if (code == 10) { // exit alt charset (TERM=linux)
                setAltCharSet(false);
            } else if (code == 11) { // enter alt charset (TERM=linux)
                setAltCharSet(true);
            } else if (code == 22) { // Normal color or intensity, neither bright, bold nor faint
                //mEffect &= ~(TextStyle.fxBold | TextStyle.fxFaint);
                mEffect &= ~TextStyle.fxBold;
            } else if (code == 23) { // not italic, but rarely used as such; clears standout with TERM=screen
                mEffect &= ~TextStyle.fxItalic;
            } else if (code == 24) { // underline: none
                mEffect &= ~TextStyle.fxUnderline;
            } else if (code == 25) { // blink: none
                mEffect &= ~TextStyle.fxBlink;
            } else if (code == 27) { // image: positive
                mEffect &= ~TextStyle.fxInverse;
            } else if (code == 28) { // invisible
                mEffect &= ~TextStyle.fxInvisible;
            } else if (code >= 30 && code <= 37) { // foreground color
                mForeColor = code - 30;
            } else if (code == 38 && i+2 <= mArgIndex && mArgs[i+1] == 5) { // foreground 256 color
                int color = mArgs[i+2];
                if (checkColor(color)) {
                    mForeColor = color;
                }
                i += 2;
            } else if (code == 39) { // set default text color
                mForeColor = mDefaultForeColor;
            } else if (code >= 40 && code <= 47) { // background color
                mBackColor = code - 40;
            } else if (code == 48 && i+2 <= mArgIndex && mArgs[i+1] == 5) { // background 256 color
                mBackColor = mArgs[i+2];
                int color = mArgs[i+2];
                if (checkColor(color)) {
                    mBackColor = color;
                }
                i += 2;
            } else if (code == 49) { // set default background color
                mBackColor = mDefaultBackColor;
            } else if (code >= 90 && code <= 97) { // bright foreground color
                mForeColor = code - 90 + 8;
            } else if (code >= 100 && code <= 107) { // bright background color
                mBackColor = code - 100 + 8;
            } else {
                if (EmulatorDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
                    Log.w(EmulatorDebug.LOG_TAG, String.format("SGR unknown code %d", code));
                }
            }
        }
    }

    private boolean checkColor(int color) {
        boolean result = isValidColor(color);
        if (!result) {
            if (EmulatorDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
                Log.w(EmulatorDebug.LOG_TAG,
                        String.format("Invalid color %d", color));
            }
        }
        return result;
    }

    private boolean isValidColor(int color) {
        return color >= 0 && color < TextStyle.ciColorLength;
    }

    private void doEscRightSquareBracket(byte b) {
        switch (b) {
        case 0x7:
            doOSC();
            break;
        case 0x1b: // Esc, probably start of Esc \ sequence
            continueSequence(ESC_RIGHT_SQUARE_BRACKET_ESC);
            break;
        default:
            collectOSCArgs(b);
            break;
        }
    }

    private void doEscRightSquareBracketEsc(byte b) {
        switch (b) {
        case '\\':
            doOSC();
            break;

        default:
            // The ESC character was not followed by a \, so insert the ESC and
            // the current character in arg buffer.
            collectOSCArgs((byte) 0x1b);
            collectOSCArgs(b);
            continueSequence(ESC_RIGHT_SQUARE_BRACKET);
            break;
        }
    }

    private void doOSC() { // Operating System Controls
        startTokenizingOSC();
        int ps = nextOSCInt(';');
        switch (ps) {
        case 0: // Change icon name and window title to T
        case 1: // Change icon name to T
        case 2: // Change window title to T
            changeTitle(ps, nextOSCString(-1));
            break;
        default:
            unknownParameter(ps);
            break;
        }
        finishSequence();
    }

    private void changeTitle(int parameter, String title) {
        if (parameter == 0 || parameter == 2) {
            mSession.setTitle(title);
        }
    }

    private void blockClear(int sx, int sy, int w) {
        blockClear(sx, sy, w, 1);
    }

    private void blockClear(int sx, int sy, int w, int h) {
        mScreen.blockSet(sx, sy, w, h, ' ', getStyle());
    }

    private int getForeColor() {
        return mForeColor;
    }

    private int getBackColor() {
        return mBackColor;
    }

    private int getEffect() {
        return mEffect;
    }

    private int getStyle() {
        return TextStyle.encode(getForeColor(), getBackColor(),  getEffect());
    }

    private void doSetMode(boolean newValue) {
        int modeBit = getArg0(0);
        switch (modeBit) {
        case 4:
            mInsertMode = newValue;
            break;

        default:
            unknownParameter(modeBit);
            break;
        }
    }

    private void setHorizontalVerticalPosition() {

        // Parameters are Row ; Column

        setCursorPosition(getArg1(1) - 1, getArg0(1) - 1);
    }

    private void setCursorPosition(int x, int y) {
        int effectiveTopMargin = 0;
        int effectiveBottomMargin = mRows;
        if ((mDecFlags & K_ORIGIN_MODE_MASK) != 0) {
            effectiveTopMargin = mTopMargin;
            effectiveBottomMargin = mBottomMargin;
        }
        int newRow =
                Math.max(effectiveTopMargin, Math.min(effectiveTopMargin + y,
                        effectiveBottomMargin - 1));
        int newCol = Math.max(0, Math.min(x, mColumns - 1));
        setCursorRowCol(newRow, newCol);
    }

    private void sendDeviceAttributes() {
        // This identifies us as a DEC vt100 with advanced
        // video options. This is what the xterm terminal
        // emulator sends.
        byte[] attributes =
                {
                /* VT100 */
                 (byte) 27, (byte) '[', (byte) '?', (byte) '1',
                 (byte) ';', (byte) '2', (byte) 'c'

                /* VT220
                (byte) 27, (byte) '[', (byte) '?', (byte) '6',
                (byte) '0',  (byte) ';',
                (byte) '1',  (byte) ';',
                (byte) '2',  (byte) ';',
                (byte) '6',  (byte) ';',
                (byte) '8',  (byte) ';',
                (byte) '9',  (byte) ';',
                (byte) '1',  (byte) '5', (byte) ';',
                (byte) 'c'
                */
                };

        mSession.write(attributes, 0, attributes.length);
    }

    private void scroll() {
        //System.out.println("Scroll(): mTopMargin " + mTopMargin + " mBottomMargin " + mBottomMargin);
        mScrollCounter ++;
        mScreen.scroll(mTopMargin, mBottomMargin, getStyle());
    }

    /**
     * Process the next ASCII character of a parameter.
     *
     * @param b The next ASCII character of the paramater sequence.
     */
    private void parseArg(byte b) {
        if (b >= '0' && b <= '9') {
            if (mArgIndex < mArgs.length) {
                int oldValue = mArgs[mArgIndex];
                int thisDigit = b - '0';
                int value;
                if (oldValue >= 0) {
                    value = oldValue * 10 + thisDigit;
                } else {
                    value = thisDigit;
                }
                mArgs[mArgIndex] = value;
            }
            continueSequence();
        } else if (b == ';') {
            if (mArgIndex < mArgs.length) {
                mArgIndex++;
            }
            continueSequence();
        } else {
            unknownSequence(b);
        }
    }

    private int getArg0(int defaultValue) {
        return getArg(0, defaultValue, true);
    }

    private int getArg1(int defaultValue) {
        return getArg(1, defaultValue, true);
    }

    private int getArg(int index, int defaultValue,
            boolean treatZeroAsDefault) {
        int result = mArgs[index];
        if (result < 0 || (result == 0 && treatZeroAsDefault)) {
            result = defaultValue;
        }
        return result;
    }

    private void startCollectingOSCArgs() {
        mOSCArgLength = 0;
    }

    private void collectOSCArgs(byte b) {
        if (mOSCArgLength < MAX_OSC_STRING_LENGTH) {
            mOSCArg[mOSCArgLength++] = b;
            continueSequence();
        } else {
            unknownSequence(b);
        }
    }

    private void startTokenizingOSC() {
        mOSCArgTokenizerIndex = 0;
    }

    private String nextOSCString(int delimiter) {
        int start = mOSCArgTokenizerIndex;
        int end = start;
        while (mOSCArgTokenizerIndex < mOSCArgLength) {
            byte b = mOSCArg[mOSCArgTokenizerIndex++];
            if ((int) b == delimiter) {
                break;
            }
            end++;
        }
        if (start == end) {
            return "";
        }
        try {
            return new String(mOSCArg, start, end-start, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return new String(mOSCArg, start, end-start);
        }
    }

    private int nextOSCInt(int delimiter) {
        int value = -1;
        while (mOSCArgTokenizerIndex < mOSCArgLength) {
            byte b = mOSCArg[mOSCArgTokenizerIndex++];
            if ((int) b == delimiter) {
                break;
            } else if (b >= '0' && b <= '9') {
                if (value < 0) {
                    value = 0;
                }
                value = value * 10 + b - '0';
            } else {
                unknownSequence(b);
            }
        }
        return value;
    }

    private void unimplementedSequence(byte b) {
        if (EmulatorDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
            logError("unimplemented", b);
        }
        finishSequence();
    }

    private void unknownSequence(byte b) {
        if (EmulatorDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
            logError("unknown", b);
        }
        finishSequence();
    }

    private void unknownParameter(int parameter) {
        if (EmulatorDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
            StringBuilder buf = new StringBuilder();
            buf.append("Unknown parameter");
            buf.append(parameter);
            logError(buf.toString());
        }
    }

    private void logError(String errorType, byte b) {
        if (EmulatorDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
            StringBuilder buf = new StringBuilder();
            buf.append(errorType);
            buf.append(" sequence ");
            buf.append(" EscapeState: ");
            buf.append(mEscapeState);
            buf.append(" char: '");
            buf.append((char) b);
            buf.append("' (");
            buf.append(b);
            buf.append(")");
            boolean firstArg = true;
            for (int i = 0; i <= mArgIndex; i++) {
                int value = mArgs[i];
                if (value >= 0) {
                    if (firstArg) {
                        firstArg = false;
                        buf.append("args = ");
                    }
                    buf.append(String.format("%d; ", value));
                }
            }
            logError(buf.toString());
        }
    }

    private void logError(String error) {
        if (EmulatorDebug.LOG_UNKNOWN_ESCAPE_SEQUENCES) {
            Log.e(EmulatorDebug.LOG_TAG, error);
        }
        finishSequence();
    }

    private void finishSequence() {
        mEscapeState = ESC_NONE;
    }

    private boolean autoWrapEnabled() {
        return (mDecFlags & K_WRAPAROUND_MODE_MASK) != 0;
    }

    /**
     * Send a Unicode code point to the screen.
     *
     * @param c The code point of the character to display
     * @param foreColor The foreground color of the character
     * @param backColor The background color of the character
     */
    private void emit(int c, int style) {
        boolean autoWrap = autoWrapEnabled();
        int width = UnicodeTranscript.charWidth(c);

        if (autoWrap) {
            if (mCursorCol == mColumns - 1 && (mAboutToAutoWrap || width == 2)) {
                mScreen.setLineWrap(mCursorRow);
                mCursorCol = 0;
                mJustWrapped = true;
                if (mCursorRow + 1 < mBottomMargin) {
                    mCursorRow++;
                } else {
                    scroll();
                }
            }
        }

        if (mInsertMode & width != 0) { // Move character to right one space
            int destCol = mCursorCol + width;
            if (destCol < mColumns) {
                mScreen.blockCopy(mCursorCol, mCursorRow, mColumns - destCol,
                        1, destCol, mCursorRow);
            }
        }

        if (width == 0) {
            // Combining character -- store along with character it modifies
            if (mJustWrapped) {
                mScreen.set(mColumns - mLastEmittedCharWidth, mCursorRow - 1, c, style);
            } else {
                mScreen.set(mCursorCol - mLastEmittedCharWidth, mCursorRow, c, style);
            }
        } else {
            mScreen.set(mCursorCol, mCursorRow, c, style);
            mJustWrapped = false;
        }

        if (autoWrap) {
            mAboutToAutoWrap = (mCursorCol == mColumns - 1);

            //Force line-wrap flag to trigger even for lines being typed
            if(mAboutToAutoWrap)
                mScreen.setLineWrap(mCursorRow);
        }

        mCursorCol = Math.min(mCursorCol + width, mColumns - 1);
        if (width > 0) {
            mLastEmittedCharWidth = width;
        }
    }

    private void emit(int c) {
        emit(c, getStyle());
    }

    private void emit(byte b) {
        if (mUseAlternateCharSet && b < 128) {
            emit((int) mSpecialGraphicsCharMap[b]);
        } else {
            emit((int) b);
        }
    }

    /**
     * Send a UTF-16 char or surrogate pair to the screen.
     *
     * @param c A char[2] containing either a single UTF-16 char or a surrogate pair to be sent to the screen.
     */
    private void emit(char[] c) {
        if (Character.isHighSurrogate(c[0])) {
            emit(Character.toCodePoint(c[0], c[1]));
        } else {
            emit((int) c[0]);
        }
    }

    /**
     * Send an array of UTF-16 chars to the screen.
     *
     * @param c A char[] array whose contents are to be sent to the screen.
     */
    private void emit(char[] c, int offset, int length, int style) {
        for (int i = offset; i < length; ++i) {
            if (c[i] == 0) {
                break;
            }
            if (Character.isHighSurrogate(c[i])) {
                emit(Character.toCodePoint(c[i], c[i+1]), style);
                ++i;
            } else {
                emit((int) c[i], style);
            }
        }
    }

    private void setCursorRow(int row) {
        mCursorRow = row;
        mAboutToAutoWrap = false;
    }

    private void setCursorCol(int col) {
        mCursorCol = col;
        mAboutToAutoWrap = false;
    }

    private void setCursorRowCol(int row, int col) {
        mCursorRow = Math.min(row, mRows-1);
        mCursorCol = Math.min(col, mColumns-1);
        mAboutToAutoWrap = false;
    }

    public int getScrollCounter() {
        return mScrollCounter;
    }

    public void clearScrollCounter() {
        mScrollCounter = 0;
    }

    /**
     * Reset the terminal emulator to its initial state.
     */
    public void reset() {
        mCursorRow = 0;
        mCursorCol = 0;
        mArgIndex = 0;
        mContinueSequence = false;
        mEscapeState = ESC_NONE;
        mSavedCursorRow = 0;
        mSavedCursorCol = 0;
        mSavedEffect = 0;
        mSavedDecFlags_DECSC_DECRC = 0;
        mDecFlags = 0;
        if (DEFAULT_TO_AUTOWRAP_ENABLED) {
            mDecFlags |= K_WRAPAROUND_MODE_MASK;
        }
        mDecFlags |= K_SHOW_CURSOR_MASK;
        mSavedDecFlags = 0;
        mInsertMode = false;
        mTopMargin = 0;
        mBottomMargin = mRows;
        mAboutToAutoWrap = false;
        mForeColor = mDefaultForeColor;
        mBackColor = mDefaultBackColor;
        mbKeypadApplicationMode = false;
        mAlternateCharSet = false;
        mCharSet[0] = CHAR_SET_ASCII;
        mCharSet[1] = CHAR_SET_SPECIAL_GRAPHICS;
        computeEffectiveCharSet();
        // mProcessedCharCount is preserved unchanged.
        setDefaultTabStops();
        blockClear(0, 0, mColumns, mRows);

        setUTF8Mode(mDefaultUTF8Mode);
        mUTF8EscapeUsed = false;
        mUTF8ToFollow = 0;
        mUTF8ByteBuffer.clear();
        mInputCharBuffer.clear();
    }

    public void setDefaultUTF8Mode(boolean defaultToUTF8Mode) {
        mDefaultUTF8Mode = defaultToUTF8Mode;
        if (!mUTF8EscapeUsed) {
            setUTF8Mode(defaultToUTF8Mode);
        }
    }

    public void setUTF8Mode(boolean utf8Mode) {
        if (utf8Mode && !mUTF8Mode) {
            mUTF8ToFollow = 0;
            mUTF8ByteBuffer.clear();
            mInputCharBuffer.clear();
        }
        mUTF8Mode = utf8Mode;
        if (mUTF8ModeNotify != null) {
            mUTF8ModeNotify.onUpdate();
        }
    }

    public boolean getUTF8Mode() {
        return mUTF8Mode;
    }

    public void setUTF8ModeUpdateCallback(UpdateCallback utf8ModeNotify) {
        mUTF8ModeNotify = utf8ModeNotify;
    }

    public void setColorScheme(ColorScheme scheme) {
        mDefaultForeColor = TextStyle.ciForeground;
        mDefaultBackColor = TextStyle.ciBackground;
        mMainBuffer.setColorScheme(scheme);
        if (mAltBuffer != null) {
            mAltBuffer.setColorScheme(scheme);
        }
    }

    public String getSelectedText(int x1, int y1, int x2, int y2) {
        return mScreen.getSelectedText(x1, y1, x2, y2);
    }

    public void finish() {
        if (mAltBuffer != null) {
            mAltBuffer.finish();
            mAltBuffer = null;
        }
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/TextRenderer.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import android.graphics.Canvas;

/**
 * Text renderer interface
 */

interface TextRenderer {
    public static final int MODE_OFF = 0;
    public static final int MODE_ON = 1;
    public static final int MODE_LOCKED = 2;
    public static final int MODE_MASK = 3;

    public static final int MODE_SHIFT_SHIFT = 0;
    public static final int MODE_ALT_SHIFT = 2;
    public static final int MODE_CTRL_SHIFT = 4;
    public static final int MODE_FN_SHIFT = 6;

    void setReverseVideo(boolean reverseVideo);
    float getCharacterWidth();
    int getCharacterHeight();
    /** @return pixels above top row of text to avoid looking cramped. */
    int getTopMargin();
    /**
     * Draw a run of text
     * @param canvas The canvas to draw into.
     * @param x Canvas coordinate of the left edge of the whole line.
     * @param y Canvas coordinate of the bottom edge of the whole line.
     * @param lineOffset The screen character offset of this text run (0..length of line)
     * @param runWidth
     * @param text
     * @param index
     * @param count
     * @param selectionStyle True to draw the text using the "selected" style (for clipboard copy)
     * @param textStyle
     * @param cursorOffset The screen character offset of the cursor (or -1 if not on this line.)
     * @param cursorIndex The index of the cursor in text chars.
     * @param cursorIncr The width of the cursor in text chars. (1 or 2)
     * @param cursorWidth The width of the cursor in screen columns (1 or 2)
     * @param cursorMode The cursor mode (used to show state of shift/control/alt/fn locks.
     */
    void drawTextRun(Canvas canvas, float x, float y,
            int lineOffset, int runWidth, char[] text,
            int index, int count, boolean selectionStyle, int textStyle,
            int cursorOffset, int cursorIndex, int cursorIncr, int cursorWidth, int cursorMode);
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/TextStyle.java`:

```java
package jackpal.androidterm.emulatorview;

final class TextStyle {
    // Effect bitmasks:
    final static int fxNormal = 0;
    final static int fxBold = 1; // Originally Bright
    //final static int fxFaint = 2;
    final static int fxItalic = 1 << 1;
    final static int fxUnderline = 1 << 2;
    final static int fxBlink = 1 << 3;
    final static int fxInverse = 1 << 4;
    final static int fxInvisible = 1 << 5;

    // Special color indices
    final static int ciForeground = 256; // VT100 text foreground color
    final static int ciBackground = 257; // VT100 text background color
    final static int ciCursorForeground = 258;     // VT100 text cursor foreground color
    final static int ciCursorBackground = 259;     // VT100 text cursor background color

    final static int ciColorLength = ciCursorBackground + 1;

    final static int kNormalTextStyle = encode(ciForeground, ciBackground, fxNormal);

    static int encode(int foreColor, int backColor, int effect) {
        return ((effect & 0x3f) << 18) | ((foreColor & 0x1ff) << 9) | (backColor & 0x1ff);
    }

    static int decodeForeColor(int encodedColor) {
        return (encodedColor >> 9) & 0x1ff;
    }

    static int decodeBackColor(int encodedColor) {
        return encodedColor & 0x1ff;
    }

    static int decodeEffect(int encodedColor) {
        return (encodedColor >> 18) & 0x3f;
    }

    private TextStyle() {
        // Prevent instantiation
        throw new UnsupportedOperationException();
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/TranscriptScreen.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import java.util.Arrays;
import android.graphics.Canvas;

/**
 * A TranscriptScreen is a screen that remembers data that's been scrolled. The
 * old data is stored in a ring buffer to minimize the amount of copying that
 * needs to be done. The transcript does its own drawing, to avoid having to
 * expose its internal data structures.
 */
class TranscriptScreen implements Screen {
    /**
     * The width of the transcript, in characters. Fixed at initialization.
     */
    private int mColumns;

    /**
     * The total number of rows in the transcript and the screen. Fixed at
     * initialization.
     */
    private int mTotalRows;

    /**
     * The number of rows in the screen.
     */
    private int mScreenRows;

    private UnicodeTranscript mData;

    /**
     * Create a transcript screen.
     *
     * @param columns the width of the screen in characters.
     * @param totalRows the height of the entire text area, in rows of text.
     * @param screenRows the height of just the screen, not including the
     *        transcript that holds lines that have scrolled off the top of the
     *        screen.
     */
    public TranscriptScreen(int columns, int totalRows, int screenRows,
            ColorScheme scheme) {
        init(columns, totalRows, screenRows, TextStyle.kNormalTextStyle);
    }

    private void init(int columns, int totalRows, int screenRows, int style) {
        mColumns = columns;
        mTotalRows = totalRows;
        mScreenRows = screenRows;

        mData = new UnicodeTranscript(columns, totalRows, screenRows, style);
        mData.blockSet(0, 0, mColumns, mScreenRows, ' ', style);
    }

    public void setColorScheme(ColorScheme scheme) {
        mData.setDefaultStyle(TextStyle.kNormalTextStyle);
    }

    public void finish() {
        /*
         * The Android InputMethodService will sometimes hold a reference to
         * us for a while after the activity closes, which is expensive because
         * it means holding on to the now-useless mData array.  Explicitly
         * get rid of our references to this data to help keep the amount of
         * memory being leaked down.
         */
        mData = null;
    }

    public void setLineWrap(int row) {
        mData.setLineWrap(row);
    }

    /**
     * Store a Unicode code point into the screen at location (x, y)
     *
     * @param x X coordinate (also known as column)
     * @param y Y coordinate (also known as row)
     * @param codePoint Unicode codepoint to store
     * @param foreColor the foreground color
     * @param backColor the background color
     */
    public void set(int x, int y, int codePoint, int style) {
        mData.setChar(x, y, codePoint, style);
    }

    public void set(int x, int y, byte b, int style) {
        mData.setChar(x, y, b, style);
    }

    /**
     * Scroll the screen down one line. To scroll the whole screen of a 24 line
     * screen, the arguments would be (0, 24).
     *
     * @param topMargin First line that is scrolled.
     * @param bottomMargin One line after the last line that is scrolled.
     * @param style the style for the newly exposed line.
     */
    public void scroll(int topMargin, int bottomMargin, int style) {
        mData.scroll(topMargin, bottomMargin, style);
    }

    /**
     * Block copy characters from one position in the screen to another. The two
     * positions can overlap. All characters of the source and destination must
     * be within the bounds of the screen, or else an InvalidParemeterException
     * will be thrown.
     *
     * @param sx source X coordinate
     * @param sy source Y coordinate
     * @param w width
     * @param h height
     * @param dx destination X coordinate
     * @param dy destination Y coordinate
     */
    public void blockCopy(int sx, int sy, int w, int h, int dx, int dy) {
        mData.blockCopy(sx, sy, w, h, dx, dy);
    }

    /**
     * Block set characters. All characters must be within the bounds of the
     * screen, or else and InvalidParemeterException will be thrown. Typically
     * this is called with a "val" argument of 32 to clear a block of
     * characters.
     *
     * @param sx source X
     * @param sy source Y
     * @param w width
     * @param h height
     * @param val value to set.
     */
    public void blockSet(int sx, int sy, int w, int h, int val,
            int style) {
        mData.blockSet(sx, sy, w, h, val, style);
    }

    /**
     * Draw a row of text. Out-of-bounds rows are blank, not errors.
     *
     * @param row The row of text to draw.
     * @param canvas The canvas to draw to.
     * @param x The x coordinate origin of the drawing
     * @param y The y coordinate origin of the drawing
     * @param renderer The renderer to use to draw the text
     * @param cx the cursor X coordinate, -1 means don't draw it
     * @param selx1 the text selection start X coordinate
     * @param selx2 the text selection end X coordinate, if equals to selx1 don't draw selection
     * @param imeText current IME text, to be rendered at cursor
     * @param cursorMode the cursor mode. See TextRenderer.
     */
    public final void drawText(int row, Canvas canvas, float x, float y,
            TextRenderer renderer, int cx, int selx1, int selx2, String imeText, int cursorMode) {
        char[] line;
        StyleRow color;
        int cursorWidth = 1;
        try {
            line = mData.getLine(row);
            color = mData.getLineColor(row);
        } catch (IllegalArgumentException e) {
            // Out-of-bounds rows are blank.
            return;
        } catch (NullPointerException e) {
            // Attempt to draw on a finished transcript
            // XXX Figure out why this happens on Honeycomb
            return;
        }
        int defaultStyle = mData.getDefaultStyle();

        if (line == null) {
            // Line is blank.
            if (selx1 != selx2) {
                // We need to draw a selection
                char[] blank = new char[selx2-selx1];
                Arrays.fill(blank, ' ');
                renderer.drawTextRun(canvas, x, y, selx1, selx2-selx1,
                                blank, 0, 1, true, defaultStyle,
                                cx, 0, 1, 1, cursorMode);
            }
            if (cx != -1) {
                char[] blank = new char[1];
                Arrays.fill(blank, ' ');
                // We need to draw the cursor
                renderer.drawTextRun(canvas, x, y, cx, 1,
                        blank, 0, 1, true, defaultStyle,
                        cx, 0, 1, 1, cursorMode);
            }

            return;
        }

        int columns = mColumns;
        int lineLen = line.length;
        int lastStyle = 0;
        boolean lastSelectionStyle = false;
        int runWidth = 0;
        int lastRunStart = -1;
        int lastRunStartIndex = -1;
        boolean forceFlushRun = false;
        int column = 0;
        int nextColumn = 0;
        int displayCharWidth = 0;
        int index = 0;
        int cursorIndex = 0;
        int cursorIncr = 0;
        while (column < columns && index < lineLen && line[index] != '\0') {
            int incr = 1;
            int width;
            if (Character.isHighSurrogate(line[index])) {
                width = UnicodeTranscript.charWidth(line, index);
                incr++;
            } else {
                width = UnicodeTranscript.charWidth(line[index]);
            }
            if (width > 0) {
                // We've moved on to the next column
                column = nextColumn;
                displayCharWidth = width;
            }
            int style = color.get(column);
            boolean selectionStyle = false;
            if ((column >= selx1 || (displayCharWidth == 2 && column == selx1 - 1)) &&
                    column <= selx2) {
                // Draw selection:
                selectionStyle = true;
            }
            if (style != lastStyle
                    || selectionStyle != lastSelectionStyle
                    || (width > 0 && forceFlushRun)) {
                if (lastRunStart >= 0) {
                    renderer.drawTextRun(canvas, x, y, lastRunStart, runWidth,
                            line,
                            lastRunStartIndex, index - lastRunStartIndex,
                            lastSelectionStyle, lastStyle,
                            cx, cursorIndex, cursorIncr, cursorWidth, cursorMode);
                }
                lastStyle = style;
                lastSelectionStyle = selectionStyle;
                runWidth = 0;
                lastRunStart = column;
                lastRunStartIndex = index;
                forceFlushRun = false;
            }
            if (cx == column) {
                if (width > 0) {
                    cursorIndex = index;
                    cursorIncr = incr;
                    cursorWidth = width;
                } else {
                    // Combining char attaching to the char under the cursor
                    cursorIncr += incr;
                }
            }
            runWidth += width;
            nextColumn += width;
            index += incr;
            if (width > 1) {
                /* We cannot draw two or more East Asian wide characters in the
                   same run, because we need to make each wide character take
                   up two columns, which may not match the font's idea of the
                   character width */
                forceFlushRun = true;
            }
        }
        if (lastRunStart >= 0) {
            renderer.drawTextRun(canvas, x, y, lastRunStart, runWidth,
                    line,
                    lastRunStartIndex, index - lastRunStartIndex,
                    lastSelectionStyle, lastStyle,
                    cx, cursorIndex, cursorIncr, cursorWidth, cursorMode);
        }

        if (cx >= 0 && imeText.length() > 0) {
            int imeLength = Math.min(columns, imeText.length());
            int imeOffset = imeText.length() - imeLength;
            int imePosition = Math.min(cx, columns - imeLength);
            renderer.drawTextRun(canvas, x, y, imePosition, imeLength, imeText.toCharArray(),
                    imeOffset, imeLength, true, TextStyle.encode(0x0f, 0x00, TextStyle.fxNormal),
                    -1, 0, 0, 0, 0);
        }
     }

    /**
     * Get the count of active rows.
     *
     * @return the count of active rows.
     */
    public int getActiveRows() {
        return mData.getActiveRows();
    }

    /**
     * Get the count of active transcript rows.
     *
     * @return the count of active transcript rows.
     */
    public int getActiveTranscriptRows() {
        return mData.getActiveTranscriptRows();
    }

    public String getTranscriptText() {
        return internalGetTranscriptText(null, 0, -mData.getActiveTranscriptRows(), mColumns, mScreenRows);
    }

    public String getTranscriptText(GrowableIntArray colors) {
        return internalGetTranscriptText(colors, 0, -mData.getActiveTranscriptRows(), mColumns, mScreenRows);
    }

    public String getSelectedText(int selX1, int selY1, int selX2, int selY2) {
        return internalGetTranscriptText(null, selX1, selY1, selX2, selY2);
    }

    public String getSelectedText(GrowableIntArray colors, int selX1, int selY1, int selX2, int selY2) {
        return internalGetTranscriptText(colors, selX1, selY1, selX2, selY2);
    }

    private String internalGetTranscriptText(GrowableIntArray colors, int selX1, int selY1, int selX2, int selY2) {
        StringBuilder builder = new StringBuilder();
        UnicodeTranscript data = mData;
        int columns = mColumns;
        char[] line;
        StyleRow rowColorBuffer = null;
        if (selY1 < -data.getActiveTranscriptRows()) {
            selY1 = -data.getActiveTranscriptRows();
        }
        if (selY2 >= mScreenRows) {
            selY2 = mScreenRows - 1;
        }
        for (int row = selY1; row <= selY2; row++) {
            int x1 = 0;
            int x2;
            if ( row == selY1 ) {
                x1 = selX1;
            }
            if ( row == selY2 ) {
                x2 = selX2 + 1;
                if (x2 > columns) {
                    x2 = columns;
                }
            } else {
                x2 = columns;
            }
            line = data.getLine(row, x1, x2);
            if (colors != null) {
                rowColorBuffer = data.getLineColor(row, x1, x2);
            }
            if (line == null) {
                if (!data.getLineWrap(row) && row < selY2 && row < mScreenRows - 1) {
                    builder.append('\n');
                    if (colors != null) {
                        colors.append(0);
                    }
                }
                continue;
            }
            int defaultColor = mData.getDefaultStyle();
            int lastPrintingChar = -1;
            int lineLen = line.length;
            int i;
            int column = 0;
            for (i = 0; i < lineLen; ++i) {
                char c = line[i];
                if (c == 0) {
                    break;
                }
                
                int style = defaultColor;
                try {
                    if (rowColorBuffer != null) {
                        style = rowColorBuffer.get(column);
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    // XXX This probably shouldn't happen ...
                    style = defaultColor;
                }

                if (c != ' ' || style != defaultColor) {
                    lastPrintingChar = i;
                }
                if (!Character.isLowSurrogate(c)) {
                    column += UnicodeTranscript.charWidth(line, i);
                }
            }
            if (data.getLineWrap(row) && lastPrintingChar > -1 && x2 == columns) {
                // If the line was wrapped, we shouldn't lose trailing space
                lastPrintingChar = i - 1;
            }
            builder.append(line, 0, lastPrintingChar + 1);
            if (colors != null) {
                if (rowColorBuffer != null) {
                    column = 0;
                    for (int j = 0; j <= lastPrintingChar; ++j) {
                        colors.append(rowColorBuffer.get(column));
                        column += UnicodeTranscript.charWidth(line, j);
                        if (Character.isHighSurrogate(line[j])) {
                            ++j;
                        }
                    }
                } else {
                    for (int j = 0; j <= lastPrintingChar; ++j) {
                        colors.append(defaultColor);
                        char c = line[j];
                        if (Character.isHighSurrogate(c)) {
                            ++j;
                        }
                    }
                }
            }
            if (!data.getLineWrap(row) && row < selY2 && row < mScreenRows - 1) {
                builder.append('\n');
                if (colors != null) {
                    colors.append((char) 0);
                }
            }
        }
        return builder.toString();
    }

    public boolean fastResize(int columns, int rows, int[] cursor) {
        if (mData == null) {
            // XXX Trying to resize a finished TranscriptScreen?
            return true;
        }
        if (mData.resize(columns, rows, cursor)) {
            mColumns = columns;
            mScreenRows = rows;
            return true;
        } else {
            return false;
        }
    }

    public void resize(int columns, int rows, int style) {
        // Ensure backing store will be large enough to hold the whole screen 
        if (rows > mTotalRows) {
            mTotalRows = rows;
        }
        init(columns, mTotalRows, rows, style);
    }

    /**
     *
     * Return the UnicodeTranscript line at this row index.
     * @param row The row index to be queried
     * @return The line of text at this row index
     */
    char[] getScriptLine(int row)
    {
        try
        {
            return mData.getLine(row);
        }
        catch (IllegalArgumentException e)
        {
            return null;
        }
        catch (NullPointerException e)
        {
            return null;
        }
    }

    /**
     * Get the line wrap status of the row provided.
     * @param row The row to check for line-wrap status
     * @return The line wrap status of the row provided
     */
    boolean getScriptLineWrap(int row)
    {
        return mData.getLineWrap(row);
    }

    /**
     * Get whether the line at this index is "basic" (contains only BMP
     * characters of width 1).
     */
    boolean isBasicLine(int row) {
        if (mData != null) {
            return mData.isBasicLine(row);
        } else {
            return true;
        }
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/UnicodeTranscript.java`:

```java
/*
 * Copyright (C) 2011 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

import android.util.Log;

import jackpal.androidterm.emulatorview.compat.AndroidCharacterCompat;
import jackpal.androidterm.emulatorview.compat.AndroidCompat;

/**
 * A backing store for a TranscriptScreen.
 *
 * The text is stored as a circular buffer of rows.  There are two types of
 * row:
 * - "basic", which is a char[] array used to store lines which consist
 *   entirely of regular-width characters (no combining characters, zero-width
 *   characters, East Asian double-width characters, etc.) in the BMP; and
 * - "full", which is a char[] array with extra trappings which can be used to
 *   store a line containing any valid Unicode sequence.  An array of short[]
 *   is used to store the "offset" at which each column starts; for example,
 *   if column 20 starts at index 23 in the array, then mOffset[20] = 3.
 *
 * Style information is stored in a separate circular buffer of StyleRows.
 *
 * Rows are allocated on demand, when a character is first stored into them.
 * A "basic" row is allocated unless the store which triggers the allocation
 * requires a "full" row.  "Basic" rows are converted to "full" rows when
 * needed.  There is no conversion in the other direction -- a "full" row
 * stays that way even if it contains only regular-width BMP characters.
 */
class UnicodeTranscript {
    private static final String TAG = "UnicodeTranscript";

    private Object[] mLines;
    private StyleRow[] mColor;
    private boolean[] mLineWrap;
    private int mTotalRows;
    private int mScreenRows;
    private int mColumns;
    private int mActiveTranscriptRows = 0;
    private int mDefaultStyle = 0;

    private int mScreenFirstRow = 0;

    private char[] tmpLine;
    private StyleRow tmpColor;

    public UnicodeTranscript(int columns, int totalRows, int screenRows, int defaultStyle) {
        mColumns = columns;
        mTotalRows = totalRows;
        mScreenRows = screenRows;
        mLines = new Object[totalRows];
        mColor = new StyleRow[totalRows];
        mLineWrap = new boolean[totalRows];
        tmpColor = new StyleRow(defaultStyle, mColumns);

        mDefaultStyle = defaultStyle;
    }

    public void setDefaultStyle(int defaultStyle) {
        mDefaultStyle = defaultStyle;
    }

    public int getDefaultStyle() {
        return mDefaultStyle;
    }

    public int getActiveTranscriptRows() {
        return mActiveTranscriptRows;
    }

    public int getActiveRows() {
        return mActiveTranscriptRows + mScreenRows;
    }

    /**
     * Convert a row value from the public external coordinate system to our
     * internal private coordinate system.
     * External coordinate system:
     * -mActiveTranscriptRows to mScreenRows-1, with the screen being
     * 0..mScreenRows-1
     * Internal coordinate system: the mScreenRows lines starting at
     * mScreenFirstRow comprise the screen, while the mActiveTranscriptRows
     * lines ending at mScreenRows-1 form the transcript (as a circular
     * buffer).
     *
     * @param extRow a row in the external coordinate system.
     * @return The row corresponding to the input argument in the private
     *         coordinate system.
     */
    private int externalToInternalRow(int extRow) {
        if (extRow < -mActiveTranscriptRows || extRow > mScreenRows) {
            String errorMessage = "externalToInternalRow "+ extRow +
                " " + mScreenRows + " " + mActiveTranscriptRows;
            Log.e(TAG, errorMessage);
            throw new IllegalArgumentException(errorMessage);
        }

        if (extRow >= 0) {
            return (mScreenFirstRow + extRow) % mTotalRows;
        } else {
            if (-extRow > mScreenFirstRow) {
                return mTotalRows + mScreenFirstRow + extRow;
            } else {
                return mScreenFirstRow + extRow;
            }
        }
    }

    public void setLineWrap(int row) {
        mLineWrap[externalToInternalRow(row)] = true;
    }

    public boolean getLineWrap(int row) {
        return mLineWrap[externalToInternalRow(row)];
    }

    /**
     * Resize the screen which this transcript backs.  Currently, this
     * only works if the number of columns does not change.
     *
     * @param newColumns The number of columns the screen should have.
     * @param newRows The number of rows the screen should have.
     * @param cursor An int[2] containing the current cursor location; if the
     *        resize succeeds, this will be updated with the new cursor
     *        location.  If null, don't do cursor-position-dependent tasks such
     *        as trimming blank lines during the resize.
     * @return Whether or not the resize succeeded.  If the resize failed,
     *         the caller may "resize" the screen by copying out all the data
     *         and placing it into a new transcript of the correct size.
     */
    public boolean resize(int newColumns, int newRows, int[] cursor) {
        if (newColumns != mColumns || newRows > mTotalRows) {
            return false;
        }

        int screenRows = mScreenRows;
        int activeTranscriptRows = mActiveTranscriptRows;
        int shift = screenRows - newRows;
        if (shift < -activeTranscriptRows) {
            // We want to add blank lines at the bottom instead of at the top
            Object[] lines = mLines;
            Object[] color = mColor;
            boolean[] lineWrap = mLineWrap;
            int screenFirstRow = mScreenFirstRow;
            int totalRows = mTotalRows;
            for (int i = 0; i < activeTranscriptRows - shift; ++i) {
                int index = (screenFirstRow + screenRows + i) % totalRows;
                lines[index] = null;
                color[index] = null;
                lineWrap[index] = false;
            }
            shift = -activeTranscriptRows;
        } else if (shift > 0 && cursor != null && cursor[1] != screenRows - 1) {
            /* When shrinking the screen, we want to hide blank lines at the
               bottom in preference to lines at the top of the screen */
            Object[] lines = mLines;
            for (int i = screenRows - 1; i > cursor[1]; --i) {
                int index = externalToInternalRow(i);
                if (lines[index] == null) {
                    // Line is blank
                    --shift;
                    if (shift == 0) {
                        break;
                    } else {
                        continue;
                    }
                }

                char[] line;
                if (lines[index] instanceof char[]) {
                    line = (char[]) lines[index];
                } else {
                    line = ((FullUnicodeLine) lines[index]).getLine();
                }

                int len = line.length;
                int j;
                for (j = 0; j < len; ++j) {
                    if (line[j] == 0) {
                        // We've reached the end of the line
                        j = len;
                        break;
                    } else if (line[j] != ' ') {
                        // Line is not blank
                        break;
                    }
                }

                if (j == len) {
                    // Line is blank
                    --shift;
                    if (shift == 0) {
                        break;
                    } else {
                        continue;
                    }
                } else {
                    // Line not blank -- we keep it and everything above
                    break;
                }
            }
        }

        if (shift > 0 || (shift < 0 && mScreenFirstRow >= -shift)) {
            // All we're doing is moving the top of the screen.
            mScreenFirstRow = (mScreenFirstRow + shift) % mTotalRows;
        } else if (shift < 0) {
            // The new top of the screen wraps around the top of the array.
            mScreenFirstRow = mTotalRows + mScreenFirstRow + shift;
        }

        if (mActiveTranscriptRows + shift < 0) {
            mActiveTranscriptRows = 0;
        } else {
            mActiveTranscriptRows += shift;
        }
        if (cursor != null) {
            cursor[1] -= shift;
        }
        mScreenRows = newRows;

        return true;
    }

    /**
     * Block copy lines and associated metadata from one location to another
     * in the circular buffer, taking wraparound into account.
     *
     * @param src The first line to be copied.
     * @param len The number of lines to be copied.
     * @param shift The offset of the destination from the source.
     */
    private void blockCopyLines(int src, int len, int shift) {
        int totalRows = mTotalRows;

        int dst;
        if (src + shift >= 0) {
            dst = (src + shift) % totalRows;
        } else {
            dst = totalRows + src + shift;
        }

        if (src + len <= totalRows && dst + len <= totalRows) {
            // Fast path -- no wraparound
            System.arraycopy(mLines, src, mLines, dst, len);
            System.arraycopy(mColor, src, mColor, dst, len);
            System.arraycopy(mLineWrap, src, mLineWrap, dst, len);
            return;
        }

        if (shift < 0) {
            // Do the copy from top to bottom
            for (int i = 0; i < len; ++i) {
                mLines[(dst + i) % totalRows] = mLines[(src + i) % totalRows];
                mColor[(dst + i) % totalRows] = mColor[(src + i) % totalRows];
                mLineWrap[(dst + i) % totalRows] = mLineWrap[(src + i) % totalRows];
            }
        } else {
            // Do the copy from bottom to top
            for (int i = len - 1; i >= 0; --i) {
                mLines[(dst + i) % totalRows] = mLines[(src + i) % totalRows];
                mColor[(dst + i) % totalRows] = mColor[(src + i) % totalRows];
                mLineWrap[(dst + i) % totalRows] = mLineWrap[(src + i) % totalRows];
            }
        }
    }

    /**
     * Scroll the screen down one line. To scroll the whole screen of a 24 line
     * screen, the arguments would be (0, 24).
     *
     * @param topMargin First line that is scrolled.
     * @param bottomMargin One line after the last line that is scrolled.
     * @param style the style for the newly exposed line.
     */
    public void scroll(int topMargin, int bottomMargin, int style) {
        // Separate out reasons so that stack crawls help us
        // figure out which condition was violated.
        if (topMargin > bottomMargin - 1) {
            throw new IllegalArgumentException();
        }

        if (topMargin < 0)  {
            throw new IllegalArgumentException();
        }

        if (bottomMargin > mScreenRows) {
            throw new IllegalArgumentException();
        }

        int screenRows = mScreenRows;
        int totalRows = mTotalRows;

        if (topMargin == 0 && bottomMargin == screenRows) {
            // Fast path -- scroll the entire screen
            mScreenFirstRow = (mScreenFirstRow + 1) % totalRows;
            if (mActiveTranscriptRows < totalRows - screenRows) {
                ++mActiveTranscriptRows;
            }

            // Blank the bottom margin
            int blankRow = externalToInternalRow(bottomMargin - 1);
            mLines[blankRow] = null;
            mColor[blankRow] = new StyleRow(style, mColumns);
            mLineWrap[blankRow] = false;

            return;
        }

        int screenFirstRow = mScreenFirstRow;
        int topMarginInt = externalToInternalRow(topMargin);
        int bottomMarginInt = externalToInternalRow(bottomMargin);

        /* Save the scrolled line, move the lines above it on the screen down
           one line, move the lines on screen below the bottom margin down
           one line, then insert the scrolled line into the transcript */
        Object[] lines = mLines;
        StyleRow[] color = mColor;
        boolean[] lineWrap = mLineWrap;
        Object scrollLine = lines[topMarginInt];
        StyleRow scrollColor = color[topMarginInt];
        boolean scrollLineWrap = lineWrap[topMarginInt];
        blockCopyLines(screenFirstRow, topMargin, 1);
        blockCopyLines(bottomMarginInt, screenRows - bottomMargin, 1);
        lines[screenFirstRow] = scrollLine;
        color[screenFirstRow] = scrollColor;
        lineWrap[screenFirstRow] = scrollLineWrap;

        // Update the screen location
        mScreenFirstRow = (screenFirstRow + 1) % totalRows;
        if (mActiveTranscriptRows < totalRows - screenRows) {
            ++mActiveTranscriptRows;
        }

        // Blank the bottom margin
        int blankRow = externalToInternalRow(bottomMargin - 1);
        lines[blankRow] = null;
        color[blankRow] = new StyleRow(style, mColumns);
        lineWrap[blankRow] = false;

        return;
    }

    /**
     * Block copy characters from one position in the screen to another. The two
     * positions can overlap. All characters of the source and destination must
     * be within the bounds of the screen, or else an InvalidParameterException
     * will be thrown.
     *
     * @param sx source X coordinate
     * @param sy source Y coordinate
     * @param w width
     * @param h height
     * @param dx destination X coordinate
     * @param dy destination Y coordinate
     */
    public void blockCopy(int sx, int sy, int w, int h, int dx, int dy) {
        if (sx < 0 || sx + w > mColumns || sy < 0 || sy + h > mScreenRows
                || dx < 0 || dx + w > mColumns || dy < 0
                || dy + h > mScreenRows) {
            throw new IllegalArgumentException();
        }
        Object[] lines = mLines;
        StyleRow[] color = mColor;
        if (sy > dy) {
            // Move in increasing order
            for (int y = 0; y < h; y++) {
                int srcRow = externalToInternalRow(sy + y);
                int dstRow = externalToInternalRow(dy + y);
                if (lines[srcRow] instanceof char[] && lines[dstRow] instanceof char[]) {
                    System.arraycopy(lines[srcRow], sx, lines[dstRow], dx, w);
                } else {
                    // XXX There has to be a faster way to do this ...
                    int extDstRow = dy + y;
                    char[] tmp = getLine(sy + y, sx, sx + w, true);
                    if (tmp == null) {
                        // Source line was blank
                        blockSet(dx, extDstRow, w, 1, ' ', mDefaultStyle);
                        continue;
                    }
                    char cHigh = 0;
                    int x = 0;
                    int columns = mColumns;
                    for (int i = 0; i < tmp.length; ++i) {
                        if (tmp[i] == 0 || dx + x >= columns) {
                            break;
                        }
                        if (Character.isHighSurrogate(tmp[i])) {
                            cHigh = tmp[i];
                            continue;
                        } else if (Character.isLowSurrogate(tmp[i])) {
                            int codePoint = Character.toCodePoint(cHigh, tmp[i]);
                            setChar(dx + x, extDstRow, codePoint);
                            x += charWidth(codePoint);
                        } else {
                            setChar(dx + x, extDstRow, tmp[i]);
                            x += charWidth(tmp[i]);
                        }
                    }
                }
                color[srcRow].copy(sx, color[dstRow], dx, w);
            }
        } else {
            // Move in decreasing order
            for (int y = 0; y < h; y++) {
                int y2 = h - (y + 1);
                int srcRow = externalToInternalRow(sy + y2);
                int dstRow = externalToInternalRow(dy + y2);
                if (lines[srcRow] instanceof char[] && lines[dstRow] instanceof char[]) {
                    System.arraycopy(lines[srcRow], sx, lines[dstRow], dx, w);
                } else {
                    int extDstRow = dy + y2;
                    char[] tmp = getLine(sy + y2, sx, sx + w, true);
                    if (tmp == null) {
                        // Source line was blank
                        blockSet(dx, extDstRow, w, 1, ' ', mDefaultStyle);
                        continue;
                    }
                    char cHigh = 0;
                    int x = 0;
                    int columns = mColumns;
                    for (int i = 0; i < tmp.length; ++i) {
                        if (tmp[i] == 0 || dx + x >= columns) {
                            break;
                        }
                        if (Character.isHighSurrogate(tmp[i])) {
                            cHigh = tmp[i];
                            continue;
                        } else if (Character.isLowSurrogate(tmp[i])) {
                            int codePoint = Character.toCodePoint(cHigh, tmp[i]);
                            setChar(dx + x, extDstRow, codePoint);
                            x += charWidth(codePoint);
                        } else {
                            setChar(dx + x, extDstRow, tmp[i]);
                            x += charWidth(tmp[i]);
                        }
                    }
                }
                color[srcRow].copy(sx, color[dstRow], dx, w);
            }
        }
    }

    /**
     * Block set characters. All characters must be within the bounds of the
     * screen, or else and InvalidParemeterException will be thrown. Typically
     * this is called with a "val" argument of 32 to clear a block of
     * characters.
     *
     * @param sx source X
     * @param sy source Y
     * @param w width
     * @param h height
     * @param val value to set.
     */
    public void blockSet(int sx, int sy, int w, int h, int val, int style) {
        if (sx < 0 || sx + w > mColumns || sy < 0 || sy + h > mScreenRows) {
            Log.e(TAG, "illegal arguments! " + sx + " " + sy + " " + w + " " + h + " " + val + " " + mColumns + " " + mScreenRows);
            throw new IllegalArgumentException();
        }

        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {
                setChar(sx + x, sy + y, val, style);
            }
        }
    }

    /**
     * Minimum API version for which we're willing to let Android try
     * rendering conjoining Hangul jamo as composed syllable blocks.
     *
     * This appears to work on Android 4.1.2, 4.3, and 4.4 (real devices only;
     * the emulator's broken for some reason), but not on 4.0.4 -- hence the
     * choice of API 16 as the minimum.
     */
    static final int HANGUL_CONJOINING_MIN_SDK = 16;

    /**
     * Gives the display width of the code point in a monospace font.
     *
     * Nonspacing combining marks, format characters, and control characters
     * have display width zero.  East Asian fullwidth and wide characters
     * have display width two.  All other characters have display width one.
     *
     * Known issues:
     * - Proper support for East Asian wide characters requires API >= 8.
     * - Assigning all East Asian "ambiguous" characters a width of 1 may not
     *   be correct if Android renders those characters as wide in East Asian
     *   context (as the Unicode standard permits).
     * - Isolated Hangul conjoining medial vowels and final consonants are
     *   treated as combining characters (they should only be combining when
     *   part of a Korean syllable block).
     *
     * @param codePoint A Unicode code point.
     * @return The display width of the Unicode code point.
     */
    public static int charWidth(int codePoint) {
        // Early out for ASCII printable characters
        if (codePoint > 31 && codePoint < 127) {
            return 1;
        }

        /* HACK: We're using ASCII ESC to save the location of the cursor
           across screen resizes, so we need to pretend that it has width 1 */
        if (codePoint == 27) {
            return 1;
        }

        switch (Character.getType(codePoint)) {
        case Character.CONTROL:
        case Character.FORMAT:
        case Character.NON_SPACING_MARK:
        case Character.ENCLOSING_MARK:
            return 0;
        }

        if ((codePoint >= 0x1160 && codePoint <= 0x11FF) ||
            (codePoint >= 0xD7B0 && codePoint <= 0xD7FF)) {
            if (AndroidCompat.SDK >= HANGUL_CONJOINING_MIN_SDK) {
                /* Treat Hangul jamo medial vowels and final consonants as
                 * combining characters with width 0 to make jamo composition
                 * work correctly.
                 *
                 * XXX: This is wrong for medials/finals outside a Korean
                 * syllable block, but there's no easy solution to that
                 * problem, and we may as well at least get the common case
                 * right. */
                return 0;
            } else {
                /* Older versions of Android didn't compose Hangul jamo, but
                 * instead rendered them as individual East Asian wide
                 * characters (despite Unicode defining medial vowels and final
                 * consonants as East Asian neutral/narrow).  Treat them as
                 * width 2 characters to match the rendering. */
                return 2;
            }
        }
        if (Character.charCount(codePoint) == 1) {
            // Android's getEastAsianWidth() only works for BMP characters
            switch (AndroidCharacterCompat.getEastAsianWidth((char) codePoint)) {
            case AndroidCharacterCompat.EAST_ASIAN_WIDTH_FULL_WIDTH:
            case AndroidCharacterCompat.EAST_ASIAN_WIDTH_WIDE:
                return 2;
            }
        } else {
            // Outside the BMP, only the ideographic planes contain wide chars
            switch ((codePoint >> 16) & 0xf) {
            case 2: // Supplementary Ideographic Plane
            case 3: // Tertiary Ideographic Plane
                return 2;
            }
        }

        return 1;
    }

    public static int charWidth(char cHigh, char cLow) {
        return charWidth(Character.toCodePoint(cHigh, cLow));
    }

    /**
     * Gives the display width of a code point in a char array
     * in a monospace font.
     *
     * @param chars The array containing the code point in question.
     * @param index The index into the array at which the code point starts.
     * @return The display width of the Unicode code point.
     */
    public static int charWidth(char[] chars, int index) {
        char c = chars[index];
        if (Character.isHighSurrogate(c)) {
            return charWidth(c, chars[index+1]);
        } else {
            return charWidth(c);
        }
    }

    /**
     * Get the contents of a line (or part of a line) of the transcript.
     *
     * The char[] array returned may be part of the internal representation
     * of the line -- make a copy first if you want to modify it.  The returned
     * array may be longer than the requested portion of the transcript; in
     * this case, the last character requested will be followed by a NUL, and
     * the contents of the rest of the array could potentially be garbage.
     *
     * @param row The row number to get (-mActiveTranscriptRows..mScreenRows-1)
     * @param x1 The first screen position that's wanted
     * @param x2 One after the last screen position that's wanted
     * @return A char[] array containing the requested contents
     */
    public char[] getLine(int row, int x1, int x2) {
        return getLine(row, x1, x2, false);
    }

    /**
     * Get the whole contents of a line of the transcript.
     */
    public char[] getLine(int row) {
        return getLine(row, 0, mColumns, true);
    }

    private char[] getLine(int row, int x1, int x2, boolean strictBounds) {
        if (row < -mActiveTranscriptRows || row > mScreenRows-1) {
            throw new IllegalArgumentException();
        }

        int columns = mColumns;
        row = externalToInternalRow(row);
        if (mLines[row] == null) {
            // Line is blank
            return null;
        }
        if (mLines[row] instanceof char[]) {
            // Line contains only regular-width BMP characters
            if (x1 == 0 && x2 == columns) {
                // Want the whole row? Easy.
                return (char[]) mLines[row];
            } else {
                if (tmpLine == null || tmpLine.length < columns + 1) {
                    tmpLine = new char[columns+1];
                }
                int length = x2 - x1;
                System.arraycopy(mLines[row], x1, tmpLine, 0, length);
                tmpLine[length] = 0;
                return tmpLine;
            }
        }

        // Figure out how long the array needs to be
        FullUnicodeLine line = (FullUnicodeLine) mLines[row];
        char[] rawLine = line.getLine();

        if (x1 == 0 && x2 == columns) {
            /* We can return the raw line after ensuring it's NUL-terminated at
             * the appropriate place */
            int spaceUsed = line.getSpaceUsed();
            if (spaceUsed < rawLine.length) {
                rawLine[spaceUsed] = 0;
            }
            return rawLine;
        }

        x1 = line.findStartOfColumn(x1);
        if (x2 < columns) {
            int endCol = x2;
            x2 = line.findStartOfColumn(endCol);
            if (!strictBounds && endCol > 0 && endCol < columns - 1) {
                /* If the end column is the middle of an East Asian wide
                 * character, include that character in the bounds */
                if (x2 == line.findStartOfColumn(endCol - 1)) {
                    x2 = line.findStartOfColumn(endCol + 1);
                }
            }
        } else {
            x2 = line.getSpaceUsed();
        }
        int length = x2 - x1;

        if (tmpLine == null || tmpLine.length < length + 1) {
            tmpLine = new char[length+1];
        }
        System.arraycopy(rawLine, x1, tmpLine, 0, length);
        tmpLine[length] = 0;
        return tmpLine;
    }

    /**
     * Get color/formatting information for a particular line.
     * The returned object may be a pointer to a temporary buffer, only good
     * until the next call to getLineColor.
     */
    public StyleRow getLineColor(int row, int x1, int x2) {
        return getLineColor(row, x1, x2, false);
    }

    public StyleRow getLineColor(int row) {
        return getLineColor(row, 0, mColumns, true);
    }

    private StyleRow getLineColor(int row, int x1, int x2, boolean strictBounds) {
        if (row < -mActiveTranscriptRows || row > mScreenRows-1) {
            throw new IllegalArgumentException();
        }

        row = externalToInternalRow(row);
        StyleRow color = mColor[row];
        StyleRow tmp = tmpColor;
        if (color != null) {
            int columns = mColumns;
            if (!strictBounds && mLines[row] != null &&
                    mLines[row] instanceof FullUnicodeLine) {
                FullUnicodeLine line = (FullUnicodeLine) mLines[row];
                /* If either the start or the end column is in the middle of
                 * an East Asian wide character, include the appropriate column
                 * of style information */
                if (x1 > 0 && line.findStartOfColumn(x1-1) == line.findStartOfColumn(x1)) {
                    --x1;
                }
                if (x2 < columns - 1 && line.findStartOfColumn(x2+1) == line.findStartOfColumn(x2)) {
                    ++x2;
                }
            }
            if (x1 == 0 && x2 == columns) {
                return color;
            }
            color.copy(x1, tmp, 0, x2-x1);
            return tmp;
        } else {
            return null;
        }
    }

    boolean isBasicLine(int row) {
        if (row < -mActiveTranscriptRows || row > mScreenRows-1) {
            throw new IllegalArgumentException();
        }

        return (mLines[externalToInternalRow(row)] instanceof char[]);
    }

    public boolean getChar(int row, int column) {
        return getChar(row, column, 0);
    }

    public boolean getChar(int row, int column, int charIndex) {
        return getChar(row, column, charIndex, new char[1], 0);
    }

    /**
     * Get a character at a specific position in the transcript.
     *
     * @param row The row of the character to get.
     * @param column The column of the character to get.
     * @param charIndex The index of the character in the column to get
     *  (0 for the first character, 1 for the next, etc.)
     * @param out The char[] array into which the character will be placed.
     * @param offset The offset in the array at which the character will be placed.
     * @return Whether or not there are characters following this one in the column.
     */
    public boolean getChar(int row, int column, int charIndex, char[] out, int offset) {
        if (row < -mActiveTranscriptRows || row > mScreenRows-1) {
            throw new IllegalArgumentException();
        }
        row = externalToInternalRow(row);

        if (mLines[row] instanceof char[]) {
            // Fast path: all regular-width BMP chars in the row
            char[] line = (char[]) mLines[row];
            out[offset] = line[column];
            return false;
        }

        FullUnicodeLine line = (FullUnicodeLine) mLines[row];
        return line.getChar(column, charIndex, out, offset);
    }

    private boolean isBasicChar(int codePoint) {
        return !(charWidth(codePoint) != 1 || Character.charCount(codePoint) != 1);
    }

    private char[] allocateBasicLine(int row, int columns) {
        char[] line = new char[columns];

        // Fill the line with blanks
        for (int i = 0; i < columns; ++i) {
            line[i] = ' ';
        }

        mLines[row] = line;
        if (mColor[row] == null) {
            mColor[row] = new StyleRow(0, columns);
        }
        return line;
    }

    private FullUnicodeLine allocateFullLine(int row, int columns) {
        FullUnicodeLine line = new FullUnicodeLine(columns);

        mLines[row] = line;
        if (mColor[row] == null) {
            mColor[row] = new StyleRow(0, columns);
        }
        return line;
    }

    public boolean setChar(int column, int row, int codePoint, int style) {
        if (!setChar(column, row, codePoint)) {
            return false;
        }

        row = externalToInternalRow(row);
        mColor[row].set(column, style);

        return true;
    }

    public boolean setChar(int column, int row, int codePoint) {
        if (row >= mScreenRows || column >= mColumns) {
            Log.e(TAG, "illegal arguments! " + row + " " + column + " " + mScreenRows + " " + mColumns);
            throw new IllegalArgumentException();
        }
        row = externalToInternalRow(row);

        /*
         * Whether data contains non-BMP or characters with charWidth != 1
         * 0 - false; 1 - true; -1 - undetermined
         */
        int basicMode = -1;

        // Allocate a row on demand
        if (mLines[row] == null) {
            if (isBasicChar(codePoint)) {
                allocateBasicLine(row, mColumns);
                basicMode = 1;
            } else {
                allocateFullLine(row, mColumns);
                basicMode = 0;
            }
        }

        if (mLines[row] instanceof char[]) {
            char[] line = (char[]) mLines[row];

            if (basicMode == -1) {
                if (isBasicChar(codePoint)) {
                    basicMode = 1;
                } else {
                    basicMode = 0;
                }
            }

            if (basicMode == 1) {
                // Fast path -- just put the char in the array
                line[column] = (char) codePoint;
                return true;
            }

            // Need to switch to the full-featured mode
            mLines[row] = new FullUnicodeLine(line);
        }

        FullUnicodeLine line = (FullUnicodeLine) mLines[row];
        line.setChar(column, codePoint);
        return true;
    }
}

/*
 * A representation of a line that's capable of handling non-BMP characters,
 * East Asian wide characters, and combining characters.
 *
 * The text of the line is stored in an array of char[], allowing easy
 * conversion to a String and/or reuse by other string-handling functions.
 * An array of short[] is used to keep track of the difference between a column
 * and the starting index corresponding to its contents in the char[] array (so
 * if column 42 starts at index 45 in the char[] array, the offset stored is 3).
 * Column 0 always starts at index 0 in the char[] array, so we use that
 * element of the array to keep track of how much of the char[] array we're
 * using at the moment.
 */
class FullUnicodeLine {
    private static final float SPARE_CAPACITY_FACTOR = 1.5f;

    private char[] mText;
    private short[] mOffset;
    private int mColumns;

    public FullUnicodeLine(int columns) {
        commonConstructor(columns);
        char[] text = mText;
        // Fill in the line with blanks
        for (int i = 0; i < columns; ++i) {
            text[i] = ' ';
        }
        // Store the space used
        mOffset[0] = (short) columns;
    }

    public FullUnicodeLine(char[] basicLine) {
        commonConstructor(basicLine.length);
        System.arraycopy(basicLine, 0, mText, 0, mColumns);
        // Store the space used
        mOffset[0] = (short) basicLine.length;
    }

    private void commonConstructor(int columns) {
        mColumns = columns;
        mOffset = new short[columns];
        mText = new char[(int)(SPARE_CAPACITY_FACTOR*columns)];
    }

    public int getSpaceUsed() {
        return mOffset[0];
    }

    public char[] getLine() {
        return mText;
    }

    public int findStartOfColumn(int column) {
        if (column == 0) {
            return 0;
        } else {
            return column + mOffset[column];
        }
    }

    public boolean getChar(int column, int charIndex, char[] out, int offset) {
        int pos = findStartOfColumn(column);
        int length;
        if (column + 1 < mColumns) {
            length = findStartOfColumn(column + 1) - pos;
        } else {
            length = getSpaceUsed() - pos;
        }
        if (charIndex >= length) {
            throw new IllegalArgumentException();
        }
        out[offset] = mText[pos + charIndex];
        return (charIndex + 1 < length);
    }

    public void setChar(int column, int codePoint) {
        int columns = mColumns;
        if (column < 0 || column >= columns) {
            throw new IllegalArgumentException();
        }

        char[] text = mText;
        short[] offset = mOffset;
        int spaceUsed = offset[0];

        int pos = findStartOfColumn(column);

        int charWidth = UnicodeTranscript.charWidth(codePoint);
        int oldCharWidth = UnicodeTranscript.charWidth(text, pos);

        if (charWidth == 2 && column == columns - 1) {
            // A width 2 character doesn't fit in the last column.
            codePoint = ' ';
            charWidth = 1;
        }

        boolean wasExtraColForWideChar = false;
        if (oldCharWidth == 2 && column > 0) {
            /* If the previous screen column starts at the same offset in the
             * array as this one, this column must be the second column used
             * by an East Asian wide character */
            wasExtraColForWideChar = (findStartOfColumn(column - 1) == pos);
        }

        // Get the number of elements in the mText array this column uses now
        int oldLen;
        if (wasExtraColForWideChar && column + 1 < columns) {
            oldLen = findStartOfColumn(column + 1) - pos;
        } else if (column + oldCharWidth < columns) {
            oldLen = findStartOfColumn(column+oldCharWidth) - pos;
        } else {
            oldLen = spaceUsed - pos;
        }

        // Find how much space this column will need
        int newLen = Character.charCount(codePoint);
        if (charWidth == 0) {
            /* Combining characters are added to the contents of the column
               instead of overwriting them, so that they modify the existing
               contents */
            newLen += oldLen;
        }
        int shift = newLen - oldLen;

        // Shift the rest of the line right to make room if necessary
        if (shift > 0) {
            if (spaceUsed + shift > text.length) {
                // We need to grow the array
                char[] newText = new char[text.length + columns];
                System.arraycopy(text, 0, newText, 0, pos);
                System.arraycopy(text, pos + oldLen, newText, pos + newLen, spaceUsed - pos - oldLen);
                mText = text = newText;
            } else {
                System.arraycopy(text, pos + oldLen, text, pos + newLen, spaceUsed - pos - oldLen);
            }
        }

        // Store the character
        if (charWidth > 0) {
            Character.toChars(codePoint, text, pos);
        } else {
            /* Store a combining character at the end of the existing contents,
               so that it modifies them */
            Character.toChars(codePoint, text, pos + oldLen);
        }

        // Shift the rest of the line left to eliminate gaps if necessary
        if (shift < 0) {
            System.arraycopy(text, pos + oldLen, text, pos + newLen, spaceUsed - pos - oldLen);
        }

        // Update space used
        if (shift != 0) {
            spaceUsed += shift;
            offset[0] = (short) spaceUsed;
        }

        /*
         * Handle cases where we need to pad with spaces to preserve column
         * alignment
         *
         * width 2 -> width 1: pad with a space before or after the new
         * character, depending on which of the two previously-occupied columns
         * we wrote into
         *
         * inserting width 2 character into the second column of an existing
         * width 2 character: pad with a space before the new character
         */
        if (oldCharWidth == 2 && charWidth == 1 || wasExtraColForWideChar && charWidth == 2) {
            int nextPos = pos + newLen;
            char[] newText = text;
            if (spaceUsed + 1 > text.length) {
                // Array needs growing
                newText = new char[text.length + columns];
                System.arraycopy(text, 0, newText, 0, wasExtraColForWideChar ? pos : nextPos);
            }

            if (wasExtraColForWideChar) {
                // Padding goes before the new character
                System.arraycopy(text, pos, newText, pos + 1, spaceUsed - pos);
                newText[pos] = ' ';
            } else {
                // Padding goes after the new character
                System.arraycopy(text, nextPos, newText, nextPos + 1, spaceUsed - nextPos);
                newText[nextPos] = ' ';
            }

            if (newText != text) {
                // Update mText to point to the newly grown array
                mText = text = newText;
            }

            // Update space used
            spaceUsed = ++offset[0];

            // Correct the offset for the just-modified column to reflect
            // width change
            if (wasExtraColForWideChar) {
                ++offset[column];
                ++pos;
            } else {
                if (column == 0) {
                    offset[1] = (short) (newLen - 1);
                } else if (column + 1 < columns) {
                    offset[column + 1] = (short) (offset[column] + newLen - 1);
                }
                ++column;
            }

            ++shift;
        }
        
        /*
         * Handle cases where we need to clobber the contents of the next
         * column in order to preserve column alignment
         *
         * width 1 -> width 2: should clobber the contents of the next
         * column (if next column contains wide char, need to pad with a space)
         *
         * inserting width 2 character into the second column of an existing
         * width 2 character: same
         */
        if (oldCharWidth == 1 && charWidth == 2 || wasExtraColForWideChar && charWidth == 2) {
            if (column == columns - 2) {
                // Correct offset for the next column to reflect width change
                offset[column + 1] = (short) (offset[column] - 1);

                // Truncate the line after this character.
                offset[0] = (short) (pos + newLen);
                shift = 0;
            } else {
                // Overwrite the contents of the next column.
                int nextPos = pos + newLen;
                int nextWidth = UnicodeTranscript.charWidth(text, nextPos);
                int nextLen;
                if (column + nextWidth + 1 < columns) {
                    nextLen = findStartOfColumn(column + nextWidth + 1) + shift - nextPos;
                } else {
                    nextLen = spaceUsed - nextPos;
                }

                if (nextWidth == 2) {
                    text[nextPos] = ' ';
                    // Shift the array to match
                    if (nextLen > 1) {
                        System.arraycopy(text, nextPos + nextLen, text, nextPos + 1, spaceUsed - nextPos - nextLen);
                        shift -= nextLen - 1;
                        offset[0] -= nextLen - 1;
                    }
                } else {
                    // Shift the array leftwards
                    System.arraycopy(text, nextPos + nextLen, text, nextPos, spaceUsed - nextPos - nextLen);
                    shift -= nextLen;

                    // Truncate the line
                    offset[0] -= nextLen;
                }

                // Correct the offset for the next column to reflect width change
                if (column == 0) {
                    offset[1] = -1;
                } else {
                    offset[column + 1] = (short) (offset[column] - 1);
                }
                ++column;
            }
        }

        // Update offset table
        if (shift != 0) {
            for (int i = column + 1; i < columns; ++i) {
                offset[i] += shift;
            }
        }
    }
}


```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/UpdateCallback.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview;

/**
 * Generic callback to be invoked to notify of updates.
 */
public interface UpdateCallback {
    /**
     * Callback function to be invoked when an update happens.
     */
    void onUpdate();
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/AndroidCharacterCompat.java`:

```java
package jackpal.androidterm.emulatorview.compat;

import android.text.AndroidCharacter;

/**
 * Definitions related to android.text.AndroidCharacter
 */
public class AndroidCharacterCompat {
    public static final int EAST_ASIAN_WIDTH_NEUTRAL = 0;
    public static final int EAST_ASIAN_WIDTH_AMBIGUOUS = 1;
    public static final int EAST_ASIAN_WIDTH_HALF_WIDTH = 2;
    public static final int EAST_ASIAN_WIDTH_FULL_WIDTH = 3;
    public static final int EAST_ASIAN_WIDTH_NARROW = 4;
    public static final int EAST_ASIAN_WIDTH_WIDE = 5;

    private static class Api8OrLater {
        public static int getEastAsianWidth(char c) {
            return AndroidCharacter.getEastAsianWidth(c);
        }
    }

    public static int getEastAsianWidth(char c) {
        if (AndroidCompat.SDK >= 8) {
            return Api8OrLater.getEastAsianWidth(c);
        } else {
            return EAST_ASIAN_WIDTH_NARROW;
        }
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/AndroidCompat.java`:

```java
package jackpal.androidterm.emulatorview.compat;

/**
 * The classes in this package take advantage of the fact that the VM does
 * not attempt to load a class until it's accessed, and the verifier
 * does not run until a class is loaded.  By keeping the methods which
 * are unavailable on older platforms in subclasses which are only ever
 * accessed on platforms where they are available, we can preserve
 * compatibility with older platforms without resorting to reflection.
 *
 * See http://developer.android.com/resources/articles/backward-compatibility.html
 * and http://android-developers.blogspot.com/2010/07/how-to-have-your-cupcake-and-eat-it-too.html
 * for further discussion of this technique.
 */

public class AndroidCompat {
    public final static int SDK = getSDK();

    private final static int getSDK() {
        int result;
        try {
            result = AndroidLevel4PlusCompat.getSDKInt();
        } catch (VerifyError e) {
            // We must be at an SDK level less than 4.
            try {
                result = Integer.valueOf(android.os.Build.VERSION.SDK);
            } catch (NumberFormatException e2) {
                // Couldn't parse string, assume the worst.
                result = 1;
            }
        }
        return result;
    }
}

class AndroidLevel4PlusCompat {
    static int getSDKInt() {
        return android.os.Build.VERSION.SDK_INT;
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/ClipboardManagerCompat.java`:

```java
package jackpal.androidterm.emulatorview.compat;

public interface ClipboardManagerCompat {
	CharSequence getText();

	boolean hasText();

    void setText(CharSequence text);
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/ClipboardManagerCompatFactory.java`:

```java
package jackpal.androidterm.emulatorview.compat;

import android.content.Context;

public class ClipboardManagerCompatFactory {

    private ClipboardManagerCompatFactory() {
        /* singleton */
    }

    public static ClipboardManagerCompat getManager(Context context) {
        if (AndroidCompat.SDK < 11) {
            return new ClipboardManagerCompatV1(context);
        } else {
            return new ClipboardManagerCompatV11(context);
        }
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/ClipboardManagerCompatV1.java`:

```java
package jackpal.androidterm.emulatorview.compat;

import android.content.Context;
import android.text.ClipboardManager;

@SuppressWarnings("deprecation")
public class ClipboardManagerCompatV1 implements ClipboardManagerCompat {
    private final ClipboardManager clip;

    public ClipboardManagerCompatV1(Context context) {
        clip = (ClipboardManager) context.getApplicationContext()
                .getSystemService(Context.CLIPBOARD_SERVICE);
    }

    @Override
    public CharSequence getText() {
        return clip.getText();
    }

    @Override
    public boolean hasText() {
        return clip.hasText();
    }

    @Override
    public void setText(CharSequence text) {
        clip.setText(text);
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/ClipboardManagerCompatV11.java`:

```java
package jackpal.androidterm.emulatorview.compat;

import android.annotation.SuppressLint;
import android.content.ClipData;
import android.content.ClipDescription;
import android.content.Context;
import android.content.ClipboardManager;

@SuppressLint("NewApi")
public class ClipboardManagerCompatV11 implements ClipboardManagerCompat {
    private final ClipboardManager clip;

    public ClipboardManagerCompatV11(Context context) {
        clip = (ClipboardManager) context.getApplicationContext()
                .getSystemService(Context.CLIPBOARD_SERVICE);
    }

    @Override
    public CharSequence getText() {
        ClipData.Item item = clip.getPrimaryClip().getItemAt(0);
        return item.getText();
    }

    @Override
    public boolean hasText() {
        return (clip.hasPrimaryClip() && clip.getPrimaryClipDescription()
                .hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN));
    }

    @Override
    public void setText(CharSequence text) {
        ClipData clipData = ClipData.newPlainText("simple text", text);
        clip.setPrimaryClip(clipData);
    }
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/KeyCharacterMapCompat.java`:

```java
/*
 * Copyright (C) 2011 Jack Palevich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview.compat;

import android.view.KeyCharacterMap;

public abstract class KeyCharacterMapCompat {
    public static final int MODIFIER_BEHAVIOR_CHORDED = 0;
    public static final int MODIFIER_BEHAVIOR_CHORDED_OR_TOGGLED = 1;

    public static KeyCharacterMapCompat wrap(Object map) {
        if (map != null) {
            if (AndroidCompat.SDK >= 11) {
                return new KeyCharacterMapApi11OrLater(map);
            }
        }
        return null;
    }

    private static class KeyCharacterMapApi11OrLater
        extends KeyCharacterMapCompat {
        private KeyCharacterMap mMap;
        public KeyCharacterMapApi11OrLater(Object map) {
            mMap = (KeyCharacterMap) map;
        }
        public int getModifierBehaviour() {
            return mMap.getModifierBehavior();
        }
    }

    public abstract int getModifierBehaviour();
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/KeycodeConstants.java`:

```java
package jackpal.androidterm.emulatorview.compat;

/**
 * Keycode constants and modifier masks for use with keyboard event listeners.
 * 
 * The Meta masks (ctrl, alt, shift, and meta) are used as follows:
 *     KeyEvent keyEvent = ...;
 *     boolean isCtrlPressed = (keyEvent.getMetaState() & META_CTRL_ON) != 0
 *
 * Contains the complete set of Android key codes that were defined as of the 2.3 API.
 * We could pull in the constants from the 2.3 API, but then we would need to raise the
 * SDK minVersion in the manifest. We want to keep compatibility with Android 1.6, 
 * and raising this level could result in the accidental use of a newer API.
 */
public class KeycodeConstants {

    /** Key code constant: Unknown key code. */
    public static final int KEYCODE_UNKNOWN         = 0;
    /** Key code constant: Soft Left key.
     * Usually situated below the display on phones and used as a multi-function
     * feature key for selecting a software defined function shown on the bottom left
     * of the display. */
    public static final int KEYCODE_SOFT_LEFT       = 1;
    /** Key code constant: Soft Right key.
     * Usually situated below the display on phones and used as a multi-function
     * feature key for selecting a software defined function shown on the bottom right
     * of the display. */
    public static final int KEYCODE_SOFT_RIGHT      = 2;
    /** Key code constant: Home key.
     * This key is handled by the framework and is never delivered to applications. */
    public static final int KEYCODE_HOME            = 3;
    /** Key code constant: Back key. */
    public static final int KEYCODE_BACK            = 4;
    /** Key code constant: Call key. */
    public static final int KEYCODE_CALL            = 5;
    /** Key code constant: End Call key. */
    public static final int KEYCODE_ENDCALL         = 6;
    /** Key code constant: '0' key. */
    public static final int KEYCODE_0               = 7;
    /** Key code constant: '1' key. */
    public static final int KEYCODE_1               = 8;
    /** Key code constant: '2' key. */
    public static final int KEYCODE_2               = 9;
    /** Key code constant: '3' key. */
    public static final int KEYCODE_3               = 10;
    /** Key code constant: '4' key. */
    public static final int KEYCODE_4               = 11;
    /** Key code constant: '5' key. */
    public static final int KEYCODE_5               = 12;
    /** Key code constant: '6' key. */
    public static final int KEYCODE_6               = 13;
    /** Key code constant: '7' key. */
    public static final int KEYCODE_7               = 14;
    /** Key code constant: '8' key. */
    public static final int KEYCODE_8               = 15;
    /** Key code constant: '9' key. */
    public static final int KEYCODE_9               = 16;
    /** Key code constant: '*' key. */
    public static final int KEYCODE_STAR            = 17;
    /** Key code constant: '#' key. */
    public static final int KEYCODE_POUND           = 18;
    /** Key code constant: Directional Pad Up key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_UP         = 19;
    /** Key code constant: Directional Pad Down key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_DOWN       = 20;
    /** Key code constant: Directional Pad Left key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_LEFT       = 21;
    /** Key code constant: Directional Pad Right key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_RIGHT      = 22;
    /** Key code constant: Directional Pad Center key.
     * May also be synthesized from trackball motions. */
    public static final int KEYCODE_DPAD_CENTER     = 23;
    /** Key code constant: Volume Up key.
     * Adjusts the speaker volume up. */
    public static final int KEYCODE_VOLUME_UP       = 24;
    /** Key code constant: Volume Down key.
     * Adjusts the speaker volume down. */
    public static final int KEYCODE_VOLUME_DOWN     = 25;
    /** Key code constant: Power key. */
    public static final int KEYCODE_POWER           = 26;
    /** Key code constant: Camera key.
     * Used to launch a camera application or take pictures. */
    public static final int KEYCODE_CAMERA          = 27;
    /** Key code constant: Clear key. */
    public static final int KEYCODE_CLEAR           = 28;
    /** Key code constant: 'A' key. */
    public static final int KEYCODE_A               = 29;
    /** Key code constant: 'B' key. */
    public static final int KEYCODE_B               = 30;
    /** Key code constant: 'C' key. */
    public static final int KEYCODE_C               = 31;
    /** Key code constant: 'D' key. */
    public static final int KEYCODE_D               = 32;
    /** Key code constant: 'E' key. */
    public static final int KEYCODE_E               = 33;
    /** Key code constant: 'F' key. */
    public static final int KEYCODE_F               = 34;
    /** Key code constant: 'G' key. */
    public static final int KEYCODE_G               = 35;
    /** Key code constant: 'H' key. */
    public static final int KEYCODE_H               = 36;
    /** Key code constant: 'I' key. */
    public static final int KEYCODE_I               = 37;
    /** Key code constant: 'J' key. */
    public static final int KEYCODE_J               = 38;
    /** Key code constant: 'K' key. */
    public static final int KEYCODE_K               = 39;
    /** Key code constant: 'L' key. */
    public static final int KEYCODE_L               = 40;
    /** Key code constant: 'M' key. */
    public static final int KEYCODE_M               = 41;
    /** Key code constant: 'N' key. */
    public static final int KEYCODE_N               = 42;
    /** Key code constant: 'O' key. */
    public static final int KEYCODE_O               = 43;
    /** Key code constant: 'P' key. */
    public static final int KEYCODE_P               = 44;
    /** Key code constant: 'Q' key. */
    public static final int KEYCODE_Q               = 45;
    /** Key code constant: 'R' key. */
    public static final int KEYCODE_R               = 46;
    /** Key code constant: 'S' key. */
    public static final int KEYCODE_S               = 47;
    /** Key code constant: 'T' key. */
    public static final int KEYCODE_T               = 48;
    /** Key code constant: 'U' key. */
    public static final int KEYCODE_U               = 49;
    /** Key code constant: 'V' key. */
    public static final int KEYCODE_V               = 50;
    /** Key code constant: 'W' key. */
    public static final int KEYCODE_W               = 51;
    /** Key code constant: 'X' key. */
    public static final int KEYCODE_X               = 52;
    /** Key code constant: 'Y' key. */
    public static final int KEYCODE_Y               = 53;
    /** Key code constant: 'Z' key. */
    public static final int KEYCODE_Z               = 54;
    /** Key code constant: ',' key. */
    public static final int KEYCODE_COMMA           = 55;
    /** Key code constant: '.' key. */
    public static final int KEYCODE_PERIOD          = 56;
    /** Key code constant: Left Alt modifier key. */
    public static final int KEYCODE_ALT_LEFT        = 57;
    /** Key code constant: Right Alt modifier key. */
    public static final int KEYCODE_ALT_RIGHT       = 58;
    /** Key code constant: Left Shift modifier key. */
    public static final int KEYCODE_SHIFT_LEFT      = 59;
    /** Key code constant: Right Shift modifier key. */
    public static final int KEYCODE_SHIFT_RIGHT     = 60;
    /** Key code constant: Tab key. */
    public static final int KEYCODE_TAB             = 61;
    /** Key code constant: Space key. */
    public static final int KEYCODE_SPACE           = 62;
    /** Key code constant: Symbol modifier key.
     * Used to enter alternate symbols. */
    public static final int KEYCODE_SYM             = 63;
    /** Key code constant: Explorer special function key.
     * Used to launch a browser application. */
    public static final int KEYCODE_EXPLORER        = 64;
    /** Key code constant: Envelope special function key.
     * Used to launch a mail application. */
    public static final int KEYCODE_ENVELOPE        = 65;
    /** Key code constant: Enter key. */
    public static final int KEYCODE_ENTER           = 66;
    /** Key code constant: Backspace key.
     * Deletes characters before the insertion point, unlike {@link #KEYCODE_FORWARD_DEL}. */
    public static final int KEYCODE_DEL             = 67;
    /** Key code constant: '`' (backtick) key. */
    public static final int KEYCODE_GRAVE           = 68;
    /** Key code constant: '-'. */
    public static final int KEYCODE_MINUS           = 69;
    /** Key code constant: '=' key. */
    public static final int KEYCODE_EQUALS          = 70;
    /** Key code constant: '[' key. */
    public static final int KEYCODE_LEFT_BRACKET    = 71;
    /** Key code constant: ']' key. */
    public static final int KEYCODE_RIGHT_BRACKET   = 72;
    /** Key code constant: '\' key. */
    public static final int KEYCODE_BACKSLASH       = 73;
    /** Key code constant: ';' key. */
    public static final int KEYCODE_SEMICOLON       = 74;
    /** Key code constant: ''' (apostrophe) key. */
    public static final int KEYCODE_APOSTROPHE      = 75;
    /** Key code constant: '/' key. */
    public static final int KEYCODE_SLASH           = 76;
    /** Key code constant: '@' key. */
    public static final int KEYCODE_AT              = 77;
    /** Key code constant: Number modifier key.
     * Used to enter numeric symbols.
     * This key is not Num Lock; it is more like {@link #KEYCODE_ALT_LEFT} and is
     * interpreted as an ALT key by {@link android.text.method.MetaKeyKeyListener}. */
    public static final int KEYCODE_NUM             = 78;
    /** Key code constant: Headset Hook key.
     * Used to hang up calls and stop media. */
    public static final int KEYCODE_HEADSETHOOK     = 79;
    /** Key code constant: Camera Focus key.
     * Used to focus the camera. */
    public static final int KEYCODE_FOCUS           = 80;   // *Camera* focus
    /** Key code constant: '+' key. */
    public static final int KEYCODE_PLUS            = 81;
    /** Key code constant: Menu key. */
    public static final int KEYCODE_MENU            = 82;
    /** Key code constant: Notification key. */
    public static final int KEYCODE_NOTIFICATION    = 83;
    /** Key code constant: Search key. */
    public static final int KEYCODE_SEARCH          = 84;
    /** Key code constant: Play/Pause media key. */
    public static final int KEYCODE_MEDIA_PLAY_PAUSE= 85;
    /** Key code constant: Stop media key. */
    public static final int KEYCODE_MEDIA_STOP      = 86;
    /** Key code constant: Play Next media key. */
    public static final int KEYCODE_MEDIA_NEXT      = 87;
    /** Key code constant: Play Previous media key. */
    public static final int KEYCODE_MEDIA_PREVIOUS  = 88;
    /** Key code constant: Rewind media key. */
    public static final int KEYCODE_MEDIA_REWIND    = 89;
    /** Key code constant: Fast Forward media key. */
    public static final int KEYCODE_MEDIA_FAST_FORWARD = 90;
    /** Key code constant: Mute key.
     * Mutes the microphone, unlike {@link #KEYCODE_VOLUME_MUTE}. */
    public static final int KEYCODE_MUTE            = 91;
    /** Key code constant: Page Up key. */
    public static final int KEYCODE_PAGE_UP         = 92;
    /** Key code constant: Page Down key. */
    public static final int KEYCODE_PAGE_DOWN       = 93;
    /** Key code constant: Picture Symbols modifier key.
     * Used to switch symbol sets (Emoji, Kao-moji). */
    public static final int KEYCODE_PICTSYMBOLS     = 94;   // switch symbol-sets (Emoji,Kao-moji)
    /** Key code constant: Switch Charset modifier key.
     * Used to switch character sets (Kanji, Katakana). */
    public static final int KEYCODE_SWITCH_CHARSET  = 95;   // switch char-sets (Kanji,Katakana)
    /** Key code constant: A Button key.
     * On a game controller, the A button should be either the button labeled A
     * or the first button on the upper row of controller buttons. */
    public static final int KEYCODE_BUTTON_A        = 96;
    /** Key code constant: B Button key.
     * On a game controller, the B button should be either the button labeled B
     * or the second button on the upper row of controller buttons. */
    public static final int KEYCODE_BUTTON_B        = 97;
    /** Key code constant: C Button key.
     * On a game controller, the C button should be either the button labeled C
     * or the third button on the upper row of controller buttons. */
    public static final int KEYCODE_BUTTON_C        = 98;
    /** Key code constant: X Button key.
     * On a game controller, the X button should be either the button labeled X
     * or the first button on the lower row of controller buttons. */
    public static final int KEYCODE_BUTTON_X        = 99;
    /** Key code constant: Y Button key.
     * On a game controller, the Y button should be either the button labeled Y
     * or the second button on the lower row of controller buttons. */
    public static final int KEYCODE_BUTTON_Y        = 100;
    /** Key code constant: Z Button key.
     * On a game controller, the Z button should be either the button labeled Z
     * or the third button on the lower row of controller buttons. */
    public static final int KEYCODE_BUTTON_Z        = 101;
    /** Key code constant: L1 Button key.
     * On a game controller, the L1 button should be either the button labeled L1 (or L)
     * or the top left trigger button. */
    public static final int KEYCODE_BUTTON_L1       = 102;
    /** Key code constant: R1 Button key.
     * On a game controller, the R1 button should be either the button labeled R1 (or R)
     * or the top right trigger button. */
    public static final int KEYCODE_BUTTON_R1       = 103;
    /** Key code constant: L2 Button key.
     * On a game controller, the L2 button should be either the button labeled L2
     * or the bottom left trigger button. */
    public static final int KEYCODE_BUTTON_L2       = 104;
    /** Key code constant: R2 Button key.
     * On a game controller, the R2 button should be either the button labeled R2
     * or the bottom right trigger button. */
    public static final int KEYCODE_BUTTON_R2       = 105;
    /** Key code constant: Left Thumb Button key.
     * On a game controller, the left thumb button indicates that the left (or only)
     * joystick is pressed. */
    public static final int KEYCODE_BUTTON_THUMBL   = 106;
    /** Key code constant: Right Thumb Button key.
     * On a game controller, the right thumb button indicates that the right
     * joystick is pressed. */
    public static final int KEYCODE_BUTTON_THUMBR   = 107;
    /** Key code constant: Start Button key.
     * On a game controller, the button labeled Start. */
    public static final int KEYCODE_BUTTON_START    = 108;
    /** Key code constant: Select Button key.
     * On a game controller, the button labeled Select. */
    public static final int KEYCODE_BUTTON_SELECT   = 109;
    /** Key code constant: Mode Button key.
     * On a game controller, the button labeled Mode. */
    public static final int KEYCODE_BUTTON_MODE     = 110;
    /** Key code constant: Escape key. */
    public static final int KEYCODE_ESCAPE          = 111;
    /** Key code constant: Forward Delete key.
     * Deletes characters ahead of the insertion point, unlike {@link #KEYCODE_DEL}. */
    public static final int KEYCODE_FORWARD_DEL     = 112;
    /** Key code constant: Left Control modifier key. */
    public static final int KEYCODE_CTRL_LEFT       = 113;
    /** Key code constant: Right Control modifier key. */
    public static final int KEYCODE_CTRL_RIGHT      = 114;
    /** Key code constant: Caps Lock modifier key. */
    public static final int KEYCODE_CAPS_LOCK       = 115;
    /** Key code constant: Scroll Lock key. */
    public static final int KEYCODE_SCROLL_LOCK     = 116;
    /** Key code constant: Left Meta modifier key. */
    public static final int KEYCODE_META_LEFT       = 117;
    /** Key code constant: Right Meta modifier key. */
    public static final int KEYCODE_META_RIGHT      = 118;
    /** Key code constant: Function modifier key. */
    public static final int KEYCODE_FUNCTION        = 119;
    /** Key code constant: System Request / Print Screen key. */
    public static final int KEYCODE_SYSRQ           = 120;
    /** Key code constant: Break / Pause key. */
    public static final int KEYCODE_BREAK           = 121;
    /** Key code constant: Home Movement key.
     * Used for scrolling or moving the cursor around to the start of a line
     * or to the top of a list. */
    public static final int KEYCODE_MOVE_HOME       = 122;
    /** Key code constant: End Movement key.
     * Used for scrolling or moving the cursor around to the end of a line
     * or to the bottom of a list. */
    public static final int KEYCODE_MOVE_END        = 123;
    /** Key code constant: Insert key.
     * Toggles insert / overwrite edit mode. */
    public static final int KEYCODE_INSERT          = 124;
    /** Key code constant: Forward key.
     * Navigates forward in the history stack.  Complement of {@link #KEYCODE_BACK}. */
    public static final int KEYCODE_FORWARD         = 125;
    /** Key code constant: Play media key. */
    public static final int KEYCODE_MEDIA_PLAY      = 126;
    /** Key code constant: Pause media key. */
    public static final int KEYCODE_MEDIA_PAUSE     = 127;
    /** Key code constant: Close media key.
     * May be used to close a CD tray, for example. */
    public static final int KEYCODE_MEDIA_CLOSE     = 128;
    /** Key code constant: Eject media key.
     * May be used to eject a CD tray, for example. */
    public static final int KEYCODE_MEDIA_EJECT     = 129;
    /** Key code constant: Record media key. */
    public static final int KEYCODE_MEDIA_RECORD    = 130;
    /** Key code constant: F1 key. */
    public static final int KEYCODE_F1              = 131;
    /** Key code constant: F2 key. */
    public static final int KEYCODE_F2              = 132;
    /** Key code constant: F3 key. */
    public static final int KEYCODE_F3              = 133;
    /** Key code constant: F4 key. */
    public static final int KEYCODE_F4              = 134;
    /** Key code constant: F5 key. */
    public static final int KEYCODE_F5              = 135;
    /** Key code constant: F6 key. */
    public static final int KEYCODE_F6              = 136;
    /** Key code constant: F7 key. */
    public static final int KEYCODE_F7              = 137;
    /** Key code constant: F8 key. */
    public static final int KEYCODE_F8              = 138;
    /** Key code constant: F9 key. */
    public static final int KEYCODE_F9              = 139;
    /** Key code constant: F10 key. */
    public static final int KEYCODE_F10             = 140;
    /** Key code constant: F11 key. */
    public static final int KEYCODE_F11             = 141;
    /** Key code constant: F12 key. */
    public static final int KEYCODE_F12             = 142;
    /** Key code constant: Num Lock modifier key.
     * This is the Num Lock key; it is different from {@link #KEYCODE_NUM}.
     * This key generally modifies the behavior of other keys on the numeric keypad. */
    public static final int KEYCODE_NUM_LOCK        = 143;
    /** Key code constant: Numeric keypad '0' key. */
    public static final int KEYCODE_NUMPAD_0        = 144;
    /** Key code constant: Numeric keypad '1' key. */
    public static final int KEYCODE_NUMPAD_1        = 145;
    /** Key code constant: Numeric keypad '2' key. */
    public static final int KEYCODE_NUMPAD_2        = 146;
    /** Key code constant: Numeric keypad '3' key. */
    public static final int KEYCODE_NUMPAD_3        = 147;
    /** Key code constant: Numeric keypad '4' key. */
    public static final int KEYCODE_NUMPAD_4        = 148;
    /** Key code constant: Numeric keypad '5' key. */
    public static final int KEYCODE_NUMPAD_5        = 149;
    /** Key code constant: Numeric keypad '6' key. */
    public static final int KEYCODE_NUMPAD_6        = 150;
    /** Key code constant: Numeric keypad '7' key. */
    public static final int KEYCODE_NUMPAD_7        = 151;
    /** Key code constant: Numeric keypad '8' key. */
    public static final int KEYCODE_NUMPAD_8        = 152;
    /** Key code constant: Numeric keypad '9' key. */
    public static final int KEYCODE_NUMPAD_9        = 153;
    /** Key code constant: Numeric keypad '/' key (for division). */
    public static final int KEYCODE_NUMPAD_DIVIDE   = 154;
    /** Key code constant: Numeric keypad '*' key (for multiplication). */
    public static final int KEYCODE_NUMPAD_MULTIPLY = 155;
    /** Key code constant: Numeric keypad '-' key (for subtraction). */
    public static final int KEYCODE_NUMPAD_SUBTRACT = 156;
    /** Key code constant: Numeric keypad '+' key (for addition). */
    public static final int KEYCODE_NUMPAD_ADD      = 157;
    /** Key code constant: Numeric keypad '.' key (for decimals or digit grouping). */
    public static final int KEYCODE_NUMPAD_DOT      = 158;
    /** Key code constant: Numeric keypad ',' key (for decimals or digit grouping). */
    public static final int KEYCODE_NUMPAD_COMMA    = 159;
    /** Key code constant: Numeric keypad Enter key. */
    public static final int KEYCODE_NUMPAD_ENTER    = 160;
    /** Key code constant: Numeric keypad '=' key. */
    public static final int KEYCODE_NUMPAD_EQUALS   = 161;
    /** Key code constant: Numeric keypad '(' key. */
    public static final int KEYCODE_NUMPAD_LEFT_PAREN = 162;
    /** Key code constant: Numeric keypad ')' key. */
    public static final int KEYCODE_NUMPAD_RIGHT_PAREN = 163;
    /** Key code constant: Volume Mute key.
     * Mutes the speaker, unlike {@link #KEYCODE_MUTE}.
     * This key should normally be implemented as a toggle such that the first press
     * mutes the speaker and the second press restores the original volume. */
    public static final int KEYCODE_VOLUME_MUTE     = 164;
    /** Key code constant: Info key.
     * Common on TV remotes to show additional information related to what is
     * currently being viewed. */
    public static final int KEYCODE_INFO            = 165;
    /** Key code constant: Channel up key.
     * On TV remotes, increments the television channel. */
    public static final int KEYCODE_CHANNEL_UP      = 166;
    /** Key code constant: Channel down key.
     * On TV remotes, decrements the television channel. */
    public static final int KEYCODE_CHANNEL_DOWN    = 167;
    /** Key code constant: Zoom in key. */
    public static final int KEYCODE_ZOOM_IN         = 168;
    /** Key code constant: Zoom out key. */
    public static final int KEYCODE_ZOOM_OUT        = 169;
    /** Key code constant: TV key.
     * On TV remotes, switches to viewing live TV. */
    public static final int KEYCODE_TV              = 170;
    /** Key code constant: Window key.
     * On TV remotes, toggles picture-in-picture mode or other windowing functions. */
    public static final int KEYCODE_WINDOW          = 171;
    /** Key code constant: Guide key.
     * On TV remotes, shows a programming guide. */
    public static final int KEYCODE_GUIDE           = 172;
    /** Key code constant: DVR key.
     * On some TV remotes, switches to a DVR mode for recorded shows. */
    public static final int KEYCODE_DVR             = 173;
    /** Key code constant: Bookmark key.
     * On some TV remotes, bookmarks content or web pages. */
    public static final int KEYCODE_BOOKMARK        = 174;
    /** Key code constant: Toggle captions key.
     * Switches the mode for closed-captioning text, for example during television shows. */
    public static final int KEYCODE_CAPTIONS        = 175;
    /** Key code constant: Settings key.
     * Starts the system settings activity. */
    public static final int KEYCODE_SETTINGS        = 176;
    /** Key code constant: TV power key.
     * On TV remotes, toggles the power on a television screen. */
    public static final int KEYCODE_TV_POWER        = 177;
    /** Key code constant: TV input key.
     * On TV remotes, switches the input on a television screen. */
    public static final int KEYCODE_TV_INPUT        = 178;
    /** Key code constant: Set-top-box power key.
     * On TV remotes, toggles the power on an external Set-top-box. */
    public static final int KEYCODE_STB_POWER       = 179;
    /** Key code constant: Set-top-box input key.
     * On TV remotes, switches the input mode on an external Set-top-box. */
    public static final int KEYCODE_STB_INPUT       = 180;
    /** Key code constant: A/V Receiver power key.
     * On TV remotes, toggles the power on an external A/V Receiver. */
    public static final int KEYCODE_AVR_POWER       = 181;
    /** Key code constant: A/V Receiver input key.
     * On TV remotes, switches the input mode on an external A/V Receiver. */
    public static final int KEYCODE_AVR_INPUT       = 182;
    /** Key code constant: Red "programmable" key.
     * On TV remotes, acts as a contextual/programmable key. */
    public static final int KEYCODE_PROG_RED        = 183;
    /** Key code constant: Green "programmable" key.
     * On TV remotes, actsas a contextual/programmable key. */
    public static final int KEYCODE_PROG_GREEN      = 184;
    /** Key code constant: Yellow "programmable" key.
     * On TV remotes, acts as a contextual/programmable key. */
    public static final int KEYCODE_PROG_YELLOW     = 185;
    /** Key code constant: Blue "programmable" key.
     * On TV remotes, acts as a contextual/programmable key. */
    public static final int KEYCODE_PROG_BLUE       = 186;

    public static final int LAST_KEYCODE           = KEYCODE_PROG_BLUE;

    public static final int META_ALT_ON = 2;
    public static final int META_CAPS_LOCK_ON = 0x00100000;
    public static final int META_CTRL_ON = 0x1000;
    public static final int META_SHIFT_ON = 1;
    public static final int META_CTRL_MASK = 0x7000;
    public static final int META_META_ON   = 0x00010000;
    public static final int META_META_MASK = 0x00070000;
}

```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/compat/Patterns.java`:

```java
/*
 * Copyright (C) 2014 Jack Palevich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.emulatorview.compat;

/**
 * Based upon
 *
 * https://android.googlesource.com/platform/frameworks/base/+/android-4.4.2_r2/core/java/android/util/Patterns.java
 *
 */

import java.util.regex.Pattern;

public class Patterns {
	/**
     *  Regular expression to match all IANA top-level domains for WEB_URL.
     *  List accurate as of 2011/07/18.  List taken from:
     *  http://data.iana.org/TLD/tlds-alpha-by-domain.txt
     *  This pattern is auto-generated by frameworks/ex/common/tools/make-iana-tld-pattern.py
     */
    public static final String TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL =
        "(?:"
        + "(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])"
        + "|(?:biz|b[abdefghijmnorstvwyz])"
        + "|(?:cat|com|coop|c[acdfghiklmnoruvxyz])"
        + "|d[ejkmoz]"
        + "|(?:edu|e[cegrstu])"
        + "|f[ijkmor]"
        + "|(?:gov|g[abdefghilmnpqrstuwy])"
        + "|h[kmnrtu]"
        + "|(?:info|int|i[delmnoqrst])"
        + "|(?:jobs|j[emop])"
        + "|k[eghimnprwyz]"
        + "|l[abcikrstuvy]"
        + "|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])"
        + "|(?:name|net|n[acefgilopruz])"
        + "|(?:org|om)"
        + "|(?:pro|p[aefghklmnrstwy])"
        + "|qa"
        + "|r[eosuw]"
        + "|s[abcdeghijklmnortuvyz]"
        + "|(?:tel|travel|t[cdfghjklmnoprtvwz])"
        + "|u[agksyz]"
        + "|v[aceginu]"
        + "|w[fs]"
        + "|(?:\u03b4\u03bf\u03ba\u03b9\u03bc\u03ae|\u0438\u0441\u043f\u044b\u0442\u0430\u043d\u0438\u0435|\u0440\u0444|\u0441\u0440\u0431|\u05d8\u05e2\u05e1\u05d8|\u0622\u0632\u0645\u0627\u06cc\u0634\u06cc|\u0625\u062e\u062a\u0628\u0627\u0631|\u0627\u0644\u0627\u0631\u062f\u0646|\u0627\u0644\u062c\u0632\u0627\u0626\u0631|\u0627\u0644\u0633\u0639\u0648\u062f\u064a\u0629|\u0627\u0644\u0645\u063a\u0631\u0628|\u0627\u0645\u0627\u0631\u0627\u062a|\u0628\u06be\u0627\u0631\u062a|\u062a\u0648\u0646\u0633|\u0633\u0648\u0631\u064a\u0629|\u0641\u0644\u0633\u0637\u064a\u0646|\u0642\u0637\u0631|\u0645\u0635\u0631|\u092a\u0930\u0940\u0915\u094d\u0937\u093e|\u092d\u093e\u0930\u0924|\u09ad\u09be\u09b0\u09a4|\u0a2d\u0a3e\u0a30\u0a24|\u0aad\u0abe\u0ab0\u0aa4|\u0b87\u0ba8\u0bcd\u0ba4\u0bbf\u0baf\u0bbe|\u0b87\u0bb2\u0b99\u0bcd\u0b95\u0bc8|\u0b9a\u0bbf\u0b99\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0bc2\u0bb0\u0bcd|\u0baa\u0bb0\u0bbf\u0b9f\u0bcd\u0b9a\u0bc8|\u0c2d\u0c3e\u0c30\u0c24\u0c4d|\u0dbd\u0d82\u0d9a\u0dcf|\u0e44\u0e17\u0e22|\u30c6\u30b9\u30c8|\u4e2d\u56fd|\u4e2d\u570b|\u53f0\u6e7e|\u53f0\u7063|\u65b0\u52a0\u5761|\u6d4b\u8bd5|\u6e2c\u8a66|\u9999\u6e2f|\ud14c\uc2a4\ud2b8|\ud55c\uad6d|xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-3e0b707e|xn\\-\\-45brj9c|xn\\-\\-80akhbyknj4f|xn\\-\\-90a3ac|xn\\-\\-9t4b11yi5a|xn\\-\\-clchc0ea0b2g2a9gcd|xn\\-\\-deba0ad|xn\\-\\-fiqs8s|xn\\-\\-fiqz9s|xn\\-\\-fpcrj9c3d|xn\\-\\-fzc2c9e2c|xn\\-\\-g6w251d|xn\\-\\-gecrj9c|xn\\-\\-h2brj9c|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-j6w193g|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-kprw13d|xn\\-\\-kpry57d|xn\\-\\-lgbbat1ad8j|xn\\-\\-mgbaam7a8h|xn\\-\\-mgbayh7gpa|xn\\-\\-mgbbh1a71e|xn\\-\\-mgbc0a9azcg|xn\\-\\-mgberp4a5d4ar|xn\\-\\-o3cw4h|xn\\-\\-ogbpf8fl|xn\\-\\-p1ai|xn\\-\\-pgbs0dh|xn\\-\\-s9brj9c|xn\\-\\-wgbh1c|xn\\-\\-wgbl6a|xn\\-\\-xkc2al3hye2a|xn\\-\\-xkc2dl3a5ee0h|xn\\-\\-yfro4i67o|xn\\-\\-ygbi2ammx|xn\\-\\-zckzah|xxx)"
        + "|y[et]"
        + "|z[amw]))";
    /**
     * Good characters for Internationalized Resource Identifiers (IRI).
     * This comprises most common used Unicode characters allowed in IRI
     * as detailed in RFC 3987.
     * Specifically, those two byte Unicode characters are not included.
     */
    public static final String GOOD_IRI_CHAR =
        "a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF";
    /**
     *  Regular expression pattern to match most part of RFC 3987
     *  Internationalized URLs, aka IRIs.  Commonly used Unicode characters are
     *  added.
     */
    public static final Pattern WEB_URL = Pattern.compile(
        "((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
        + "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
        + "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
        + "((?:(?:[" + GOOD_IRI_CHAR + "][" + GOOD_IRI_CHAR + "\\-]{0,64}\\.)+"   // named host
        + TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL
        + "|(?:(?:25[0-5]|2[0-4]" // or ip address
        + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
        + "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
        + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
        + "|[1-9][0-9]|[0-9])))"
        + "(?:\\:\\d{1,5})?)" // plus option port number
        + "(\\/(?:(?:[" + GOOD_IRI_CHAR + "\\;\\/\\?\\:\\@\\&\\=\\#\\~"  // plus option query params
        + "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?"
        + "(?:\\b|$)"); // and finally, a word boundary or end of
                        // input.  This is to stop foo.sure from
                        // matching as foo.su
}
```

`emulatorview/src/main/java/jackpal/androidterm/emulatorview/package.html`:

```html
<html>
<body>
<p>This package provides a fairly complete VT100 terminal emulator {@link
jackpal.androidterm.emulatorview.TermSession TermSession} and a corresponding
Android view {@link jackpal.androidterm.emulatorview.EmulatorView EmulatorView}.

<p>Most users will create a <code>TermSession</code>, connect it to an {@link
java.io.InputStream InputStream} and {@link java.io.OutputStream OutputStream}
from the emulation client, then instantiate the <code>EmulatorView</code> and
add it to an activity's layout.
</body>
</html>

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Wed Apr 10 15:27:10 PDT 2013
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip

```

`gradlew`:

```
#!/usr/bin/env bash

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn ( ) {
    echo "$*"
}

die ( ) {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
esac

# For Cygwin, ensure paths are in UNIX format before anything is touched.
if $cygwin ; then
    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
fi

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >&-
APP_HOME="`pwd -P`"
cd "$SAVED" >&-

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
function splitJvmOpts() {
    JVM_OPTS=("$@")
}
eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"

exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"

```

`gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windowz variants

if not "%OS%" == "Windows_NT" goto win9xME_args
if "%@eval[2+2]" == "4" goto 4NT_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*
goto execute

:4NT_args
@rem Get arguments from the 4NT Shell from JP Software
set CMD_LINE_ARGS=%$

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`libtermexec/build.gradle`:

```gradle
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.0.0'
    }
}
apply plugin: 'com.android.library'

repositories {
    jcenter()
}

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"

    defaultConfig {
        minSdkVersion 4
        targetSdkVersion 22
        versionCode 1
        versionName "1.0"

        ndk {
            moduleName 'libjackpal-termexec2'
            abiFilters 'all'
            ldLibs 'log', 'c'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

// by default recent plugin version does not copy any AIDL files "to avoid publishing too much"
android.libraryVariants.all { variant ->
    Sync packageAidl = project.tasks.create("addPublic${variant.name.capitalize()}Aidl", Sync) { sync ->
        from "$project.projectDir/src/main/aidl/"
        into "$buildDir/intermediates/bundles/${variant.dirName}/aidl/"
    }

    variant.javaCompile.dependsOn packageAidl
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])

    compile 'com.android.support:support-annotations:21.0.0'
}

```

`libtermexec/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /home/uniqa/android-sdk/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

```

`libtermexec/src/androidTest/java/jackpal/androidterm/libtermexec/ApplicationTest.java`:

```java
package jackpal.androidterm.libtermexec;

import android.app.Application;
import android.test.ApplicationTestCase;

/**
 * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
 */
public class ApplicationTest extends ApplicationTestCase<Application> {
    public ApplicationTest() {
        super(Application.class);
    }
}

```

`libtermexec/src/main/AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="jackpal.androidterm.libtermexec">
    <application/>
</manifest>

```

`libtermexec/src/main/aidl/jackpal/androidterm/libtermexec/v1/ITerminal.aidl`:

```aidl
package jackpal.androidterm.libtermexec.v1;

import android.content.IntentSender;
import android.os.ParcelFileDescriptor;
import android.os.ResultReceiver;

// see also:
// the (clumsy) way to handle object inheritance with Binder:
// https://kevinhartman.github.io/blog/2012/07/23/inheritance-through-ipc-using-aidl-in-android/
// some (possibly outdated) notes on preserving backward compatibility:
// https://stackoverflow.com/questions/18197783/android-aidl-interface-parcelables-and-backwards-compatibility
/**
  * An interface for interacting with Terminal implementation.
  *
  * The version of the interface is encoded in Intent action and the AIDL package name. New versions
  * of this interface may be implemented in future. Those versions will be made available
  * in separate packages and older versions will continue to work.
  */
interface ITerminal {
    /**
      * Start a new Terminal session. A session will remain hosted by service, that provides binding,
      * but no gurantees of process pesistence as well as stability of connection are made. You
      * should keep your ParcelFileDescriptor around and allow ServiceConnection to call this method
      * again, when reconnection happens, in case service hosting the session is killed by system.
      *
      * Allows caller to be notified of terminal session events. Multiple calls can happen on each,
      * and new call types can be introduced, so prepare to ignore unknown event codes.
      *
      * So far only notifications about session end (code 0) are supported. This notification is
      * issued after abovementioned file descriptor is closed and the session is ended from
      * Terminal's standpoint.
      *
      * @param pseudoTerminalMultiplexerFd file descriptor, obtained by opening /dev/ptmx.
      * @param a callback
      *
      * @return IntentSender, that can be used to start corresponding Terminal Activity.
      */
    IntentSender startSession(in ParcelFileDescriptor pseudoTerminalMultiplexerFd, in ResultReceiver callback);
}

```

`libtermexec/src/main/java/jackpal/androidterm/TermExec.java`:

```java
package jackpal.androidterm;

import android.annotation.TargetApi;
import android.os.*;
import android.support.annotation.NonNull;
import java.io.FileDescriptor;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.*;

/**
 * Utility methods for creating and managing a subprocess. This class differs from
 * {@link java.lang.ProcessBuilder} in that a pty is used to communicate with the subprocess.
 * <p>
 * Pseudo-terminals are a powerful Unix feature, that allows programs to interact with other programs
 * they start in slightly more human-like way. For example, a pty owner can send ^C (aka SIGINT)
 * to attached shell, even if said shell runs under a different user ID.
 */
public class TermExec {
    // Warning: bump the library revision, when an incompatible change happens
    static {
        System.loadLibrary("jackpal-termexec2");
    }

    public static final String SERVICE_ACTION_V1 = "jackpal.androidterm.action.START_TERM.v1";

    private static Field descriptorField;

    private final List<String> command;
    private final Map<String, String> environment;

    public TermExec(@NonNull String... command) {
        this(new ArrayList<>(Arrays.asList(command)));
    }

    public TermExec(@NonNull List<String> command) {
        this.command = command;
        this.environment = new Hashtable<>(System.getenv());
    }

    public @NonNull List<String> command() {
        return command;
    }

    public @NonNull Map<String, String> environment() {
        return environment;
    }

    public @NonNull TermExec command(@NonNull String... command) {
        return command(new ArrayList<>(Arrays.asList(command)));
    }

    public @NonNull TermExec command(List<String> command) {
        command.clear();
        command.addAll(command);
        return this;
    }

    /**
     * Start the process and attach it to the pty, corresponding to given file descriptor.
     * You have to obtain this file descriptor yourself by calling
     * {@link android.os.ParcelFileDescriptor#open} on special terminal multiplexer
     * device (located at /dev/ptmx).
     * <p>
     * Callers are responsible for closing the descriptor.
     *
     * @return the PID of the started process.
     */
    public int start(@NonNull ParcelFileDescriptor ptmxFd) throws IOException {
        if (Looper.getMainLooper() == Looper.myLooper())
            throw new IllegalStateException("This method must not be called from the main thread!");

        if (command.size() == 0)
            throw new IllegalStateException("Empty command!");

        final String cmd = command.remove(0);
        final String[] cmdArray = command.toArray(new String[command.size()]);
        final String[] envArray = new String[environment.size()];
        int i = 0;
        for (Map.Entry<String, String> entry : environment.entrySet()) {
            envArray[i++] = entry.getKey() + "=" + entry.getValue();
        }

        return createSubprocess(ptmxFd, cmd, cmdArray, envArray);
    }

    /**
     * Causes the calling thread to wait for the process associated with the
     * receiver to finish executing.
     *
     * @return The exit value of the Process being waited on
     */
    public static native int waitFor(int processId);

    /**
     * Send signal via the "kill" system call. Android {@link android.os.Process#sendSignal} does not
     * allow negative numbers (denoting process groups) to be used.
     */
    public static native void sendSignal(int processId, int signal);

    static int createSubprocess(ParcelFileDescriptor masterFd, String cmd, String[] args, String[] envVars) throws IOException
    {
        final int integerFd;

        if (Build.VERSION.SDK_INT >= 12)
            integerFd = FdHelperHoneycomb.getFd(masterFd);
        else {
            try {
                if (descriptorField == null) {
                    descriptorField = FileDescriptor.class.getDeclaredField("descriptor");
                    descriptorField.setAccessible(true);
                }

                integerFd = descriptorField.getInt(masterFd.getFileDescriptor());
            } catch (Exception e) {
                throw new IOException("Unable to obtain file descriptor on this OS version: " + e.getMessage());
            }
        }

        return createSubprocessInternal(cmd, args, envVars, integerFd);
    }

    private static native int createSubprocessInternal(String cmd, String[] args, String[] envVars, int masterFd);
}

// prevents runtime errors on old API versions with ruthless verifier
@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
class FdHelperHoneycomb {
    static int getFd(ParcelFileDescriptor descriptor) {
        return descriptor.getFd();
    }
}

```

`libtermexec/src/main/jni/process.cpp`:

```cpp
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "process.h"

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <termios.h>
#include <signal.h>

typedef unsigned short char16_t;

class String8 {
public:
    String8() {
        mString = 0;
    }

    ~String8() {
        if (mString) {
            free(mString);
        }
    }

    void set(const char16_t* o, size_t numChars) {
        if (mString) {
            free(mString);
        }
        mString = (char*) malloc(numChars + 1);
        if (!mString) {
            return;
        }
        for (size_t i = 0; i < numChars; i++) {
            mString[i] = (char) o[i];
        }
        mString[numChars] = '\0';
    }

    const char* string() {
        return mString;
    }
private:
    char* mString;
};

static int throwOutOfMemoryError(JNIEnv *env, const char *message)
{
    jclass exClass;
    const char *className = "java/lang/OutOfMemoryError";

    exClass = env->FindClass(className);
    return env->ThrowNew(exClass, message);
}

static int throwIOException(JNIEnv *env, int errnum, const char *message)
{
    __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, "%s errno %s(%d)",
        message, strerror(errno), errno);

    if (errnum != 0) {
        const char *s = strerror(errnum);
        if (strcmp(s, "Unknown error") != 0)
            message = s;
    }

    jclass exClass;
    const char *className = "java/io/IOException";

    exClass = env->FindClass(className);
    return env->ThrowNew(exClass, message);
}

static void closeNonstandardFileDescriptors() {
    // Android uses shared memory to communicate between processes. The file descriptor is passed
    // to child processes using the environment variable ANDROID_PROPERTY_WORKSPACE, which is of
    // the form "properties_fd,sizeOfSharedMemory"
    int properties_fd = -1;
    char* properties_fd_string = getenv("ANDROID_PROPERTY_WORKSPACE");
    if (properties_fd_string != NULL) {
        properties_fd = atoi(properties_fd_string);
    }
    DIR *dir = opendir("/proc/self/fd");
    if(dir != NULL) {
        int dir_fd = dirfd(dir);

        while(true) {
            struct dirent *entry = readdir(dir);
            if(entry == NULL) {
                break;
            }

            int fd = atoi(entry->d_name);
            if(fd > STDERR_FILENO && fd != dir_fd && fd != properties_fd) {
                close(fd);
            }
        }

        closedir(dir);
    }
}

static int create_subprocess(JNIEnv *env, const char *cmd, char *const argv[], char *const envp[], int masterFd)
{
    // same size as Android 1.6 libc/unistd/ptsname_r.c
    char devname[64];
    pid_t pid;

    fcntl(masterFd, F_SETFD, FD_CLOEXEC);

    // grantpt is unnecessary, because we already assume devpts by using /dev/ptmx
    if(unlockpt(masterFd)){
        throwIOException(env, errno, "trouble with /dev/ptmx");
        return -1;
    }
    memset(devname, 0, sizeof(devname));
    // Early (Android 1.6) bionic versions of ptsname_r had a bug where they returned the buffer
    // instead of 0 on success.  A compatible way of telling whether ptsname_r
    // succeeded is to zero out errno and check it after the call
    errno = 0;
    int ptsResult = ptsname_r(masterFd, devname, sizeof(devname));
    if (ptsResult && errno) {
        throwIOException(env, errno, "ptsname_r returned error");
        return -1;
    }

    pid = fork();
    if(pid < 0) {
        throwIOException(env, errno, "fork failed");
        return -1;
    }

    if(pid == 0){
        int pts;

        setsid();

        pts = open(devname, O_RDWR);
        if(pts < 0) exit(-1);

        ioctl(pts, TIOCSCTTY, 0);

        dup2(pts, 0);
        dup2(pts, 1);
        dup2(pts, 2);

        closeNonstandardFileDescriptors();

        if (envp) {
            for (; *envp; ++envp) {
                putenv(*envp);
            }
        }

        execv(cmd, argv);
        exit(-1);
    } else {
        return (int) pid;
    }
}

extern "C" {

JNIEXPORT void JNICALL Java_jackpal_androidterm_TermExec_sendSignal(JNIEnv *env, jobject clazz,
    jint procId, jint signal)
{
    kill(procId, signal);
}

JNIEXPORT jint JNICALL Java_jackpal_androidterm_TermExec_waitFor(JNIEnv *env, jclass clazz, jint procId) {
    int status;
    waitpid(procId, &status, 0);
    int result = 0;
    if (WIFEXITED(status)) {
        result = WEXITSTATUS(status);
    }
    return result;
}

JNIEXPORT jint JNICALL Java_jackpal_androidterm_TermExec_createSubprocessInternal(JNIEnv *env, jclass clazz,
    jstring cmd, jobjectArray args, jobjectArray envVars, jint masterFd)
{
    const jchar* str = cmd ? env->GetStringCritical(cmd, 0) : 0;
    String8 cmd_8;
    if (str) {
        cmd_8.set(str, env->GetStringLength(cmd));
        env->ReleaseStringCritical(cmd, str);
    }

    jsize size = args ? env->GetArrayLength(args) : 0;
    char **argv = NULL;
    String8 tmp_8;
    if (size > 0) {
        argv = (char **)malloc((size+1)*sizeof(char *));
        if (!argv) {
            throwOutOfMemoryError(env, "Couldn't allocate argv array");
            return 0;
        }
        for (int i = 0; i < size; ++i) {
            jstring arg = reinterpret_cast<jstring>(env->GetObjectArrayElement(args, i));
            str = env->GetStringCritical(arg, 0);
            if (!str) {
                throwOutOfMemoryError(env, "Couldn't get argument from array");
                return 0;
            }
            tmp_8.set(str, env->GetStringLength(arg));
            env->ReleaseStringCritical(arg, str);
            argv[i] = strdup(tmp_8.string());
        }
        argv[size] = NULL;
    }

    size = envVars ? env->GetArrayLength(envVars) : 0;
    char **envp = NULL;
    if (size > 0) {
        envp = (char **)malloc((size+1)*sizeof(char *));
        if (!envp) {
            throwOutOfMemoryError(env, "Couldn't allocate envp array");
            return 0;
        }
        for (int i = 0; i < size; ++i) {
            jstring var = reinterpret_cast<jstring>(env->GetObjectArrayElement(envVars, i));
            str = env->GetStringCritical(var, 0);
            if (!str) {
                throwOutOfMemoryError(env, "Couldn't get env var from array");
                return 0;
            }
            tmp_8.set(str, env->GetStringLength(var));
            env->ReleaseStringCritical(var, str);
            envp[i] = strdup(tmp_8.string());
        }
        envp[size] = NULL;
    }

    int ptm = create_subprocess(env, cmd_8.string(), argv, envp, masterFd);

    if (argv) {
        for (char **tmp = argv; *tmp; ++tmp) {
            free(*tmp);
        }
        free(argv);
    }
    if (envp) {
        for (char **tmp = envp; *tmp; ++tmp) {
            free(*tmp);
        }
        free(envp);
    }

    return ptm;
}

}

```

`libtermexec/src/main/jni/process.h`:

```h
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef _JACKPAL_PROCESS_H
#define _JACKPAL_PROCESS_H 1

#include <stddef.h>
#include "jni.h"
#include <android/log.h>

#define LOG_TAG "jackpal-termexec"

extern "C" {
JNIEXPORT jint JNICALL Java_jackpal_androidterm_TermExec_createSubprocessInternal
      (JNIEnv *, jclass, jstring, jobjectArray, jobjectArray, jint);

    JNIEXPORT jint JNICALL Java_jackpal_androidterm_TermExec_waitFor
      (JNIEnv *, jclass, jint);
}

#endif	/* !defined(_JACKPAL_PROCESS_H) */

```

`samples/intents/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"

    defaultConfig {
        applicationId "jackpal.androidterm.sample.intents"
        minSdkVersion 4
        targetSdkVersion 22
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

```

`samples/intents/lint.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<lint>
    <issue id="MissingTranslation" severity="ignore" />
    <issue id="UseSparseArrays" severity="ignore" />
</lint>

```

`samples/intents/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="jackpal.androidterm.sample.intents"
      android:versionCode="1"
      android:versionName="1.0">
    <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="11" />
    <uses-permission android:name="jackpal.androidterm.permission.RUN_SCRIPT" />
    <application android:label="@string/app_name" >
        <activity android:name="IntentSampleActivity"
                  android:label="@string/app_name">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>

```

`samples/intents/src/main/java/jackpal/androidterm/sample/intents/IntentSampleActivity.java`:

```java
package jackpal.androidterm.sample.intents;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;

public class IntentSampleActivity extends Activity
{
    private String mHandle;
    private static final int REQUEST_WINDOW_HANDLE = 1;

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        addClickListener(R.id.openNewWindow, new OnClickListener() {
            public void onClick(View v) {
                // Intent for opening a new window without providing script
                Intent intent =
                        new Intent("jackpal.androidterm.OPEN_NEW_WINDOW");
                intent.addCategory(Intent.CATEGORY_DEFAULT);
                startActivity(intent);
            }});

        final EditText script = (EditText) findViewById(R.id.script);
        script.setText(getString(R.string.default_script));
        addClickListener(R.id.runScript, new OnClickListener() {
            public void onClick(View v) {
                /* Intent for opening a new window and running the provided
                   script -- you must declare the permission
                   jackpal.androidterm.permission.RUN_SCRIPT in your manifest
                   to use */
                Intent intent =
                        new Intent("jackpal.androidterm.RUN_SCRIPT");
                intent.addCategory(Intent.CATEGORY_DEFAULT);
                String command = script.getText().toString();
                intent.putExtra("jackpal.androidterm.iInitialCommand", command);
                startActivity(intent);
            }});
        addClickListener(R.id.runScriptSaveWindow, new OnClickListener() {
            public void onClick(View v) {
                /* Intent for running a script in a previously opened window,
                   if it still exists
                   This will open another window if it doesn't find a match */
                Intent intent =
                        new Intent("jackpal.androidterm.RUN_SCRIPT");
                intent.addCategory(Intent.CATEGORY_DEFAULT);
                String command = script.getText().toString();
                intent.putExtra("jackpal.androidterm.iInitialCommand", command);
                if (mHandle != null) {
                    // Identify the targeted window by its handle
                    intent.putExtra("jackpal.androidterm.window_handle",
                            mHandle);
                }
                /* The handle for the targeted window -- whether newly opened
                   or reused -- is returned to us via onActivityResult()
                   You can compare it against an existing saved handle to
                   determine whether or not a new window was opened */
                startActivityForResult(intent, REQUEST_WINDOW_HANDLE);
            }});
    }

    private void addClickListener(int buttonId, OnClickListener onClickListener) {
        ((Button) findViewById(buttonId)).setOnClickListener(onClickListener);
    }

    protected void onActivityResult(int request, int result, Intent data) {
        if (result != RESULT_OK) {
            return;
        }

        if (request == REQUEST_WINDOW_HANDLE && data != null) {
            mHandle = data.getStringExtra("jackpal.androidterm.window_handle");
            ((Button) findViewById(R.id.runScriptSaveWindow)).setText(
                    R.string.run_script_existing_window);
        }
    }
}

```

`samples/intents/src/main/res/layout/main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical" >

    <TextView
        android:id="@+id/help"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/help" />

    <Button
        android:id="@+id/openNewWindow"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/open_new_window" />

    <TextView
        android:id="@+id/scriptLabel"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/script_label" />

    <EditText
        android:id="@+id/script"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content" />

    <Button
        android:id="@+id/runScript"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/run_script" />

    <Button
        android:id="@+id/runScriptSaveWindow"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/run_script_save_window" />

</LinearLayout>

```

`samples/intents/src/main/res/values-ja/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">ATE Intent サンプル</string>
    <string name="open_new_window">新しいウインドウを開く</string>
    <string name="script_label">スクリプト:</string>
    <string name="run_script">スクリプト実行</string>
    <string name="run_script_save_window">スクリプトを実行しウインドウを保存</string>
    <string name="run_script_existing_window">保存されたウインドウでスクリプトを実行</string>
    <string name="help">このサンプルは Android端末エミュレータへインテントを送る方法を示しています．</string>

    <!-- Do not translate: -->
    <string name="default_script">echo \'Hello, world!\'</string>
</resources>

```

`samples/intents/src/main/res/values-ko/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">ATE Intent 예제</string>
    <string name="open_new_window">새로운 창 열기</string>
    <string name="script_label">스크립트 : </string>
    <string name="run_script">스크립트 실행</string>
    <string name="run_script_save_window">스크립트 실행 및 명령창 상태 저장</string>
    <string name="run_script_existing_window">저장된 명령창에서 스크립트 실행</string>
    <string name="help">이 예제는 터미널 에뮬레이터에서 어떻게 Intent를 전송하는지 보여줍니다.</string>
</resources>

```

`samples/intents/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">TEA Intent Sample</string>
    <string name="open_new_window">Open New Window</string>
    <string name="script_label">Script:</string>
    <string name="run_script">Run Script</string>
    <string name="run_script_save_window">Run Script and Save Window</string>
    <string name="run_script_existing_window">Run Script in Saved Window</string>
    <string name="help">This sample shows how to send intents to Android Terminal Emulator.</string>

    <!-- Do not translate: -->
    <string name="default_script">echo \'Hello, world!\'</string>
</resources>

```

`samples/pathbroadcasts/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"

    defaultConfig {
        applicationId "jackpal.androidterm.sample.pathbroadcasts"
        minSdkVersion 4
        targetSdkVersion 22

        ndk {
            moduleName "libjackpal-androidterm4"
            ldLibs "log"
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

dependencies {
    compile project(':emulatorview')
}

```

`samples/pathbroadcasts/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="jackpal.androidterm.sample.pathbroadcasts"
      android:versionCode="1"
      android:versionName="1.0">
    <uses-permission android:name="jackpal.androidterm.permission.APPEND_TO_PATH" />
    <!-- Declare this if you want to receive PATH prepend broadcasts -->
    <uses-permission android:name="jackpal.androidterm.permission.PREPEND_TO_PATH" />

    <application android:label="@string/app_name" >
        <receiver android:name=".PathReceiver">
            <intent-filter>
                <action android:name="jackpal.androidterm.broadcast.APPEND_TO_PATH" />
            </intent-filter>
            <intent-filter>
                <action android:name="jackpal.androidterm.broadcast.PREPEND_TO_PATH" />
            </intent-filter>
        </receiver>
    </application>
</manifest>

```

`samples/pathbroadcasts/src/main/assets/hello`:

```
#!/system/bin/sh

echo "Hello, world!"
exit 0

```

`samples/pathbroadcasts/src/main/assets/ls`:

```
#!/system/bin/sh

echo "Hello, I'm pretending to be ls!"
exec /system/bin/ls "$@"

```

`samples/pathbroadcasts/src/main/java/jackpal/androidterm/sample/pathbroadcasts/PathReceiver.java`:

```java
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.sample.pathbroadcasts;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.ProcessBuilder;

public class PathReceiver extends BroadcastReceiver {
    /**
     * Called when a broadcast matching the declared intent filters is
     * received.
     */
    @Override
    public void onReceive(Context context, Intent intent) {
        /* Unpack our sample bin/ and sbin/ if not already done */
        File binDir = setupBinDir(context);
        File sbinDir = setupSbinDir(context);

        String packageName = context.getPackageName();

        String action = intent.getAction();

        /**
         * You need to declare the permission
         * jackpal.androidterm.permission.APPEND_TO_PATH
         * to receive this broadcast.
         */
        if (action.equals("jackpal.androidterm.broadcast.APPEND_TO_PATH")) {
            /* The directory we want appended goes into the result extras */
            Bundle result = getResultExtras(true);

            /**
             * By convention, entries are indexed by package name.
             *
             * If you need to impose an ordering constraint for some reason,
             * you may prepend a number to your package name -- for example,
             * 50-com.example.awesomebin or 00-net.busybox.android.
             */
            result.putString(packageName, binDir.getAbsolutePath());

            setResultCode(Activity.RESULT_OK);
        }

        /**
         * You need to declare the permission
         * jackpal.androidterm.permission.PREPEND_TO_PATH
         * to receive this broadcast.
         *
         * This is intended for packages like BusyBox installers which need
         * to override existing system commands; otherwise, you should listen
         * for the APPEND_TO_PATH broadcast instead.
         */
        if (action.equals("jackpal.androidterm.broadcast.PREPEND_TO_PATH")) {
            /* The directory we want prepended goes into the result extras */
            Bundle result = getResultExtras(true);
            result.putString(packageName, sbinDir.getAbsolutePath());
            setResultCode(Activity.RESULT_OK);
        }
    }

    private File setupBinDir(Context context) {
        String dataDir = getDataDir(context);
        File binDir = new File(dataDir, "bin");
        if (!binDir.exists()) {
            try {
                binDir.mkdir();
                chmod("755", binDir.getAbsolutePath());
            } catch (Exception e) {
            }
        }

        File hello = new File(binDir, "hello");
        if (!hello.exists()) {
            try {
                InputStream src = context.getAssets().open("hello");
                FileOutputStream dst = new FileOutputStream(hello);
                copyStream(dst, src);
                chmod("755", hello.getAbsolutePath());
            } catch (Exception e) {
            }
        }

        return binDir;
    }

    private File setupSbinDir(Context context) {
        String dataDir = getDataDir(context);
        File sbinDir = new File(dataDir, "sbin");
        if (!sbinDir.exists()) {
            try {
                sbinDir.mkdir();
                chmod("755", sbinDir.getAbsolutePath());
            } catch (Exception e) {
            }
        }

        File ls = new File(sbinDir, "ls");
        if (!ls.exists()) {
            try {
                InputStream src = context.getAssets().open("ls");
                FileOutputStream dst = new FileOutputStream(ls);
                copyStream(dst, src);
                chmod("755", ls.getAbsolutePath());
            } catch (Exception e) {
            }
        }

        return sbinDir;
    }

    private String getDataDir(Context context) {
        /* On API 4 and later, you can just do this */
        // return context.getApplicationInfo().dataDir;

        String packageName = context.getPackageName();
        PackageManager pm = context.getPackageManager();
        String dataDir = null;
        try {
            dataDir = pm.getApplicationInfo(packageName, 0).dataDir;
        } catch (Exception e) {
            // Won't happen -- we know we're installed
        }
        return dataDir;
    }

    private void copyStream(OutputStream dst, InputStream src) throws IOException {
        byte[] buffer = new byte[4096];
        int bytesRead = 0;
        while ((bytesRead = src.read(buffer)) >= 0) {
            dst.write(buffer, 0, bytesRead);
        }
        dst.close();
    }

    private void chmod(String... args) throws IOException {
        String[] cmdline = new String[args.length + 1];
        cmdline[0] = "/system/bin/chmod";
        System.arraycopy(args, 0, cmdline, 1, args.length);
        new ProcessBuilder(cmdline).start();
    }
}

```

`samples/pathbroadcasts/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">TEA Path Broadcast Sample</string>
</resources>

```

`samples/telnet/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"

    defaultConfig {
        applicationId "jackpal.androidterm.sample.telnet"
        minSdkVersion 4
        targetSdkVersion 22

        ndk {
            moduleName "libjackpal-androidterm4"
            ldLibs "log"
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

dependencies {
    compile project(':emulatorview')
}

```

`samples/telnet/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="jackpal.androidterm.sample.telnet"
      android:versionCode="1"
      android:versionName="1.0">
    <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="11" />
    <uses-permission android:name="android.permission.INTERNET" />
    <application android:label="@string/app_name" >
        <activity android:name="LaunchActivity"
                  android:label="@string/app_name">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity android:name="TermActivity"
                  android:label="@string/app_name"
                  android:configChanges="keyboard|keyboardHidden|orientation"
                  android:windowSoftInputMode="adjustResize" />
    </application>
</manifest>

```

`samples/telnet/src/main/java/jackpal/androidterm/sample/telnet/LaunchActivity.java`:

```java
package jackpal.androidterm.sample.telnet;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;

/**
 * Provides a UI to launch the terminal emulator activity, connected to
 * either a local shell or a Telnet server.
 */
public class LaunchActivity extends Activity
{
    private static final String TAG = "TelnetLaunchActivity";

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.launch_activity);
        final Context context = this;
        addClickListener(R.id.launchLocal, new OnClickListener() {
            public void onClick(View v) {
                Intent intent = new Intent(context, TermActivity.class);
                intent.putExtra("type", "local");
                startActivity(intent);
            }});

        final EditText hostEdit = (EditText) findViewById(R.id.hostname);
        addClickListener(R.id.launchTelnet, new OnClickListener() {
            public void onClick(View v) {
                Intent intent = new Intent(context, TermActivity.class);
                intent.putExtra("type", "telnet");
                String hostname = hostEdit.getText().toString();
                intent.putExtra("host", hostname);
                startActivity(intent);
            }});
    }

    private void addClickListener(int buttonId, OnClickListener onClickListener) {
        ((Button) findViewById(buttonId)).setOnClickListener(onClickListener);
    }
}

```

`samples/telnet/src/main/java/jackpal/androidterm/sample/telnet/TelnetSession.java`:

```java
package jackpal.androidterm.sample.telnet;

import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;

import android.util.Log;

import jackpal.androidterm.emulatorview.TermSession;

/**
 * A rudimentary Telnet client implemented as a subclass of TermSession.
 *
 * Telnet, as specified in RFC 854, is a fairly simple protocol: for the
 * most part, we send and receive streams of bytes which can be fed directly
 * into the terminal emulator.  However, there are a handful of complications:
 *
 * - The standard says that CR (ASCII carriage return) must either be
 *   translated into the network standard newline sequence CR LF, or be
 *   followed immediately by NUL.
 * - (byte) 255, called IAC in the standard, introduces Telnet command
 *   sequences which can be used to negotiate options, perform certain
 *   actions on the "Network Virtual Terminal" which the standard defines,
 *   or do flow control.
 * - By default, the protocol spoken is designed to accommodate a half-duplex
 *   terminal on either end, so we should be able to buffer output and
 *   send it on a trigger (the sequence IAC GA).
 * - By default, we're expected to be able to echo local keyboard input into
 *   our own output.
 *
 * To solve these problems, we filter the input from the network to catch
 * and implement Telnet commands via the processInput() method.  Similarly, we
 * filter the output from TermSession by overriding write() to modify CR as
 * required by the standard, and pass a buffer with manually controllable
 * flushing to the TermSession to use as its output stream.
 *
 * In addition to the base Telnet protocol, we implement two options:
 * the ECHO option (RFC 857) for enabling echoing of input across the network,
 * and the SUPPRESS-GO-AHEAD option (RFC 858) for omitting half-duplex flow
 * control.  Both of these are commonly available from servers, and make our
 * lives easier.
 */
public class TelnetSession extends TermSession
{
    private static final String TAG = "TelnetSession";
    private static final boolean DEBUG = false;

    public static final int IAC = 255;

    public static final int CMD_SE = 240;	// SE -- end of parameters
    public static final int CMD_NOP = 241;	// NOP
    public static final int CMD_MARK = 242;	// data mark
    public static final int CMD_BRK = 243;	// send BREAK to terminal
    public static final int CMD_IP = 244;	// Interrupt Process
    public static final int CMD_AO = 245;	// Abort Output
    public static final int CMD_AYT = 246;	// Are You There
    public static final int CMD_EC = 247;	// Erase Character
    public static final int CMD_EL = 248;	// Erase Line
    public static final int CMD_GA = 249;	// Go Ahead (clear to send)
    public static final int CMD_SB = 250;	// SB -- begin parameters
    public static final int CMD_WILL = 251;	// used in option negotiation
    public static final int CMD_WONT = 252;	// used in option negotiation
    public static final int CMD_DO = 253;	// used in option negotiation
    public static final int CMD_DONT = 254;	// used in option negotiation

    public static final int OPTION_ECHO = 1; // see RFC 857
    public static final int OPTION_SUPPRESS_GO_AHEAD = 3; // see RFC 858
    public static final int OPTION_RANDOMLY_LOSE = 256; // see RFC 748 :)

    // Whether we believe the remote end implements the telnet protocol
    private boolean peerIsTelnetd = false;

    private boolean peerEchoesInput = false;
    /* RFC 854 says false is the default, but that makes the client effectively
       useless for connecting to random non-Telnet servers for debugging */
    private boolean peerSuppressedGoAhead = true;

    private boolean echoInput = false;
    /* RFC 854 says false is the default, but that makes the client effectively
       useless for connecting to random non-Telnet servers for debugging */
    private boolean suppressGoAhead = true;
    private boolean doSuppressGaRequested = false;
    private boolean willSuppressGaRequested = false;

    /* Telnet command processor state */
    private boolean mInTelnetCommand = false;
    private int mTelnetCommand = 0;
    private boolean mMultipleParameters = false;
    private int mLastInputByteProcessed = 0;

    /**
     * Create a TelnetSession to handle the telnet protocol and terminal
     * emulation, using an existing InputStream and OutputStream.
     */
    public TelnetSession(InputStream termIn, OutputStream termOut) {
        setTermIn(termIn);
        setTermOut(termOut);
    }

    /**
     * Process data before sending it to the server.
     * We replace all occurrences of \r with \r\n, as required by the
     * Telnet protocol (CR meant to be a newline should be sent as CR LF,
     * and all other CRs must be sent as CR NUL).
     */
    @Override
    public void write(byte[] bytes, int offset, int count) {
        // Count the number of CRs
        int numCRs = 0;
        for (int i = offset; i < offset + count; ++i) {
            if (bytes[i] == '\r') {
                ++numCRs;
            }
        }

        if (numCRs == 0) {
            // No CRs -- just send data as-is
            doWrite(bytes, offset, count);

            if (isRunning() && !peerEchoesInput) {
                doLocalEcho(bytes);
            }
            return;
        }

        // Convert CRs into CRLFs
        byte[] translated = new byte[count + numCRs];
        int j = 0;
        for (int i = offset; i < offset + count; ++i) {
            if (bytes[i] == '\r') {
                translated[j++] = '\r';
                translated[j++] = '\n';
            } else {
                translated[j++] = bytes[i];
            }
        }

        // Send the data
        doWrite(translated, 0, translated.length);

        // If server echo is off, echo the entered characters locally
        if (isRunning() && !peerEchoesInput) {
            doLocalEcho(translated);
        }
    }

    private byte[] mWriteBuf = new byte[4096];
    private int mWriteBufLen = 0;

    /* Send data to the server, buffering it first if necessary */
    private void doWrite(byte[] data, int offset, int count) {
        if (peerSuppressedGoAhead) {
           // No need to buffer -- send it straight to the server
           super.write(data, offset, count);
           return;
        }

        /* Flush the buffer if it's full ... not strictly correct, but better
           than the alternatives */
        byte[] buffer = mWriteBuf;
        int bufLen = mWriteBufLen;
        if (bufLen + count > buffer.length) {
            flushWriteBuf();
            bufLen = 0;
        }

        // Queue the data to be sent at the next server GA
        System.arraycopy(data, offset, buffer, bufLen, count);
        mWriteBufLen += count;
    }

    /* Flush the buffer of data to be written to the server */
    private void flushWriteBuf() {
        super.write(mWriteBuf, 0, mWriteBufLen);
        mWriteBufLen = 0;
    }

    /* Echoes local input from the emulator back to the emulator screen. */
    private void doLocalEcho(byte[] data) {
        if (DEBUG) {
            Log.d(TAG, "echoing " +
                    Arrays.toString(data) + " back to terminal");
        }
        appendToEmulator(data, 0, data.length);
        notifyUpdate();
    }

    /**
     * Input filter which handles Telnet commands and copies data to the
     * terminal emulator.
     */
    @Override
    public void processInput(byte[] buffer, int offset, int count) {
        int lastByte = mLastInputByteProcessed;
        for (int i = offset; i < offset + count; ++i) {
            // need to interpret the byte as unsigned -- thanks Java!
            int curByte = ((int) buffer[i]) & 0xff;

            if (DEBUG) {
                Log.d(TAG, "input byte " + curByte);
            }

            if (mInTelnetCommand) {
                // Previous byte was part of a command sequence
                doTelnetCommand(curByte);
                lastByte = curByte;
                continue;
            }

            switch (curByte) {
            case IAC: // Telnet command prefix
                mInTelnetCommand = true;
                /* Assume we're talking to a real Telnet server */
                if (!peerIsTelnetd) {
                    doTelnetInit();
                }
                break;
            case CMD_GA: // GA -- clear to send
                /**
                 * If we're in half-duplex flow control, we've been given
                 * permission to send data; flush our output buffers.
                 *
                 * Note that it's not strictly correct to send the other
                 * side a GA at this point, but since we're not actually
                 * attached to a half-duplex terminal, we don't have a signal
                 * to indicate when the other side should logically begin
                 * to send again.
                 *
                 * In full-duplex operation (option SUPPRESS-GO-AHEAD enabled),
                 * does nothing.
                 */
                byte[] cmdGa = { (byte) IAC, (byte) CMD_GA };
                if (!peerSuppressedGoAhead) {
                    if (!suppressGoAhead) {
                        doWrite(cmdGa, 0, cmdGa.length);
                    }
                    flushWriteBuf();
                }
                break;
            case 0: // NUL -- should be ignored following a CR
                if (lastByte == '\r') {
                    if (echoInput) {
                        // We do need to echo it back to the server, though
                        doEchoInput(0);
                    }
                    break;
                }
            default:
                /* Send the data to the terminal emulator, and echo it back
                   across the network if the other end wants us to do so. */
                super.processInput(buffer, i, 1);
                if (echoInput) {
                    doEchoInput(buffer[i]);
                }
            }
            lastByte = curByte;
        }

        // Save the last byte processed -- we may need it
        mLastInputByteProcessed = lastByte;
    }

    byte[] mOneByte = new byte[1];
    private void doEchoInput(int input) {
        if (DEBUG) {
            Log.d(TAG, "echoing " + input + " to remote end");
        }
        byte[] oneByte = mOneByte;
        oneByte[0] = (byte) input;
        super.write(oneByte, 0, 1);
    }

    /**
     * Interpreter for Telnet commands.
     */
    private void doTelnetCommand(int curByte) {
        /* Handle parameter lists */
        if (mMultipleParameters) {
            switch (curByte) {
            case CMD_SE: // SE -- end of parameters
                doMultiParamCommand();
                finishTelnetCommand();
                return;
            default:
                addMultiParam(curByte);
                return;
            }
        }

        /* Handle option negotiation */
        switch (mTelnetCommand) {
        case CMD_WILL:
            handleWillOption(curByte);
            return;
        case CMD_WONT:
            handleWontOption(curByte);
            return;
        case CMD_DO:
            handleDoOption(curByte);
            return;
        case CMD_DONT:
            handleDontOption(curByte);
            return;
        }

        /* Telnet commands */
        switch (curByte) {
        case CMD_EC: // EC -- erase character
            // ESC [ D (VT100 cursor left)
            byte[] cmdLeft = { (byte) 27, (byte) '[', (byte) 'D' };
            // ESC [ P (VT100 erase char at cursor)
            byte[] cmdErase = { (byte) 27, (byte) '[', (byte) 'P' };
            super.processInput(cmdLeft, 0, cmdLeft.length);
            super.processInput(cmdErase, 0, cmdErase.length);
            break;
        case CMD_EL: // EL -- erase line
            // ESC [ 2 K (VT100 clear whole line)
            byte[] cmdEl = { (byte) 27, (byte) '[', (byte) '2', (byte) 'K' };
            super.processInput(cmdEl, 0, cmdEl.length);
            break;
        case IAC: // send the IAC character to terminal
            byte[] iac = { (byte) IAC };
            super.processInput(iac, 0, iac.length);
            break;
        case CMD_SB: // SB -- more parameters follow option
            mMultipleParameters = true;
            return;
        case CMD_WILL: // WILL
        case CMD_WONT: // WON'T
        case CMD_DO: // DO
        case CMD_DONT: // DON'T
            // Option negotiation -- save the command and wait for the option
            mTelnetCommand = curByte;
            return;
        case CMD_AYT: // AYT -- Are You There
            /**
             * RFC 854 says we should send back "some visible (i.e., printable)
             * evidence that the AYT was received" ... this is as good as
             * anything else
             */
            byte[] msg = "yes, I'm here\r\n".getBytes();
            super.write(msg, 0, msg.length);
            break;
        // The following are unimplemented
        case CMD_MARK:	// data mark
        case CMD_BRK:	// send a break to the terminal
        case CMD_IP:	// IP -- interrupt process
        case CMD_AO:	// AO -- abort output
        case CMD_NOP:	// NOP
        default:
            break;
        }

        finishTelnetCommand();
    }

    // end of command, process next byte normally
    private void finishTelnetCommand() {
        mTelnetCommand = 0;
        mInTelnetCommand = false;
        mMultipleParameters = false;
    }

    private void addMultiParam(int curByte) {
        // unimplemented
    }

    private void doMultiParamCommand() {
        // unimplemented
    }

    /**
     * Telnet option negotiation code.
     *
     * Because the Telnet protocol is defined to be mostly symmetric with
     * respect to the client and server roles, option negotiation can be
     * somewhat confusing.  The same commands are used to initiate and
     * respond to negotiation requests, and their exact meaning depends on
     * whether they were sent as an initial request or as a response:
     *
     * - WILL:  If sent as a request, indicates that we wish to enable the
     *          option on our end.  If sent as a response, indicates that we
     *          have enabled the specified option on our end.
     * - WON'T: If sent as a request, indicates that we insist on disabling the
     *          option on our end.  If sent as a response, indicates that we
     *          refuse to enable the specified option on our end.
     * - DO:    If sent as a request, indicates that we wish the peer to enable
     *          this option on the remote end.  If sent as a response, indicates
     *          that we accept the peer's request to enable the option on the
     *          remote end.
     * - DON'T: If sent as a request, indicates that we demand the peer disable
     *          this option on the remote end.  If sent as a response, indicates
     *          that we refuse to allow the peer to enable this option on the
     *          remote end.
     *
     * All options are off by default (options have to be explicitly requested).
     * In order to prevent negotiation loops, we are not supposed to reply to
     * requests which do not change the state of an option (e.g. if the server
     * sends DON'T ECHO and we're not echoing back what the server sends us, we
     * should not reply with WON'T ECHO).
     *
     * Examples:
     *
     * - server sends WILL ECHO, we reply DO ECHO: the server asks, and we
     *   agree, that the server echo the input we send to it back to us over
     *   the network.
     * - we send WON'T ECHO, server replies DON'T ECHO: we ask, and the server
     *   agrees, that we not echo the input we receive from the server back to
     *   the server over the network.
     * - we send DO SUPPRESS-GO-AHEAD, server replies WILL SUPPRESS-GO-AHEAD:
     *   we ask, and the server agrees, that the server not send GA to indicate
     *   when it's ready to take data (in other words, we can freely send data
     *   to the server).
     * - server sends DO ECHO, we reply WON'T ECHO: the server asks us to
     *   echo the input we receive from it back over the network, but we refuse
     *   to do so.
     */
    private void handleWillOption(int curByte) {
        switch (curByte) {
        case OPTION_ECHO: // WILL ECHO
            // We don't ever request DO ECHO, so this must be a request
            if (!peerEchoesInput) {
                sendOption(CMD_DO, OPTION_ECHO);
            }
            peerEchoesInput = true;
            break;
        case OPTION_SUPPRESS_GO_AHEAD: // WILL SUPPRESS-GO-AHEAD
            if (!doSuppressGaRequested && !peerSuppressedGoAhead) {
                // This is a request which changes our state, send a reply
                sendOption(CMD_DO, OPTION_SUPPRESS_GO_AHEAD);
            }
            peerSuppressedGoAhead = true;
            doSuppressGaRequested = false;
            // Flush unwritten data in the output buffer
            flushWriteBuf();
            break;
        default: // unrecognized option
            // refuse to let other end enable unknown options
            sendOption(CMD_DONT, curByte);
            break;
        }

        finishTelnetCommand();
    }

    private void handleWontOption(int curByte) {
        switch (curByte) {
        case OPTION_ECHO: // WON'T ECHO
            // We don't ever request DO ECHO, so this must be a request
            if (peerEchoesInput) {
                sendOption(CMD_DONT, OPTION_ECHO);
            }
            peerEchoesInput = false;
            break;
        case OPTION_SUPPRESS_GO_AHEAD: // WON'T SUPPRESS-GO-AHEAD
            if (!doSuppressGaRequested && peerSuppressedGoAhead) {
                // This is a request which changes our state, send a reply
                sendOption(CMD_DONT, OPTION_SUPPRESS_GO_AHEAD);
            }
            peerSuppressedGoAhead = false;
            doSuppressGaRequested = false;
            break;
        default: // unrecognized option
            // WON'T is the default for any option, so we shouldn't reply
            break;
        }

        finishTelnetCommand();
    }

    private void handleDoOption(int curByte) {
        switch (curByte) {
        case OPTION_ECHO: // DO ECHO
            /* Other Telnet clients like netkit-telnet refuse this request when
               they receive it, since it doesn't make much sense */
            sendOption(CMD_WONT, OPTION_ECHO);
            /**
            // We don't ever request WILL ECHO, so this must be a request
            if (!echoInput) {
                sendOption(CMD_WILL, OPTION_ECHO);
            }
            echoInput = true;
             */
            break;
        case OPTION_SUPPRESS_GO_AHEAD: // DO SUPPRESS-GO-AHEAD
            if (!willSuppressGaRequested && !suppressGoAhead) {
                // This is a request which changes our state, send a reply
                sendOption(CMD_WILL, OPTION_SUPPRESS_GO_AHEAD);
            }
            suppressGoAhead = true;
            willSuppressGaRequested = false;
            break;
        default: // unrecognized option
            // refuse to enable unknown options
            sendOption(CMD_WONT, curByte);
            break;
        }

        finishTelnetCommand();
    }

    private void handleDontOption(int curByte) {
        switch (curByte) {
        case OPTION_ECHO: // DON'T ECHO
            // We don't ever request DON'T ECHO, so this must be a request
            if (echoInput) {
                sendOption(CMD_WONT, OPTION_ECHO);
            }
            echoInput = false;
            break;
        case OPTION_SUPPRESS_GO_AHEAD: // DON'T SUPPRESS-GO-AHEAD
            if (!willSuppressGaRequested && suppressGoAhead) {
                // This is a request which changes our state, send a reply
                sendOption(CMD_WONT, curByte);
            }
            suppressGoAhead = false;
            willSuppressGaRequested = false;
            break;
        default: // unrecognized option
            // DON'T is the default for any option, so we shouldn't reply
            break;
        }

        finishTelnetCommand();
    }

    /* Send an option negotiation command */
    private void sendOption(int command, int opt) {
        if (DEBUG) {
            Log.d(TAG, "sending command: " + command + " " + opt);
        }
        // option negotiation needs to bypass the write buffer
        byte[] buffer = { (byte) IAC, (byte) command, (byte) opt };
        super.write(buffer, 0, buffer.length);
    }

    private void requestDoSuppressGoAhead() {
        doSuppressGaRequested = true;
        // send IAC DO SUPPRESS-GO-AHEAD
        sendOption(CMD_DO, OPTION_SUPPRESS_GO_AHEAD);
    }

    private void requestWillSuppressGoAhead() {
        willSuppressGaRequested = true;
        // send IAC WILL SUPPRESS-GO-AHEAD
        sendOption(CMD_WILL, OPTION_SUPPRESS_GO_AHEAD);
    }

    /**
     * Called the first time processInput() encounters IAC in the input stream,
     * which is a reasonably good heuristic to determine that the other end is
     * a true Telnet server and not some SMTP/POP/IMAP/whatever server.
     *
     * When called, disables the SUPPRESS-GO-AHEAD option for both directions
     * (required by the standard, but very inconvenient when talking to
     * non-Telnet servers) and sends requests to reenable it in both directions
     * (because it's much easier for us when it's on).
     */
    private void doTelnetInit() {
        peerSuppressedGoAhead = false;
        suppressGoAhead = false;

        requestDoSuppressGoAhead();
        requestWillSuppressGoAhead();

        peerIsTelnetd = true;
    }
}

```

`samples/telnet/src/main/java/jackpal/androidterm/sample/telnet/TermActivity.java`:

```java
package jackpal.androidterm.sample.telnet;

import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.text.Editable;
import android.text.method.TextKeyListener;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import jackpal.androidterm.emulatorview.EmulatorView;
import jackpal.androidterm.emulatorview.TermSession;

/**
 * This sample activity demonstrates the use of EmulatorView.
 *
 * This activity also demonstrates how to set up a simple TermSession connected
 * to a local program.  The Telnet connection demonstrates a more complex case;
 * see the TelnetSession class for more details.
 */
public class TermActivity extends Activity
{
    final private static String TAG = "TermActivity";
    private EditText mEntry;
    private EmulatorView mEmulatorView;
    private TermSession mSession;

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.term_activity);

        /* Text entry box at the bottom of the activity.  Note that you can
           also send input (whether from a hardware device or soft keyboard)
           directly to the EmulatorView. */
        mEntry = (EditText) findViewById(R.id.term_entry);
        mEntry.setOnEditorActionListener(new TextView.OnEditorActionListener() {
            public boolean onEditorAction(TextView v, int action, KeyEvent ev) {
                // Ignore enter-key-up events
                if (ev != null && ev.getAction() == KeyEvent.ACTION_UP) {
                    return false;
                }
                // Don't try to send something if we're not connected yet
                TermSession session = mSession;
                if (mSession == null) {
                    return true;
                }

                Editable e = (Editable) v.getText();
                // Write to the terminal session
                session.write(e.toString());
                session.write('\r');
                TextKeyListener.clear(e);
                return true;
            }
        });

        /* Sends the content of the text entry box to the terminal, without
           sending a carriage return afterwards */
        Button sendButton = (Button) findViewById(R.id.term_entry_send);
        sendButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                // Don't try to send something if we're not connected yet
                TermSession session = mSession;
                if (mSession == null) {
                    return;
                }
                Editable e = (Editable) mEntry.getText();
                session.write(e.toString());
                TextKeyListener.clear(e);
            }
        });

        /**
         * EmulatorView setup.
         */
        EmulatorView view = (EmulatorView) findViewById(R.id.emulatorView);
        mEmulatorView = view;

        /* Let the EmulatorView know the screen's density. */
        DisplayMetrics metrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(metrics);
        view.setDensity(metrics);

        /* Create a TermSession. */
        Intent myIntent = getIntent();
        String sessionType = myIntent.getStringExtra("type");
        TermSession session;

        if (sessionType != null && sessionType.equals("telnet")) {
            /* Telnet connection: we need to do the network connect on a
               separate thread, so kick that off and wait for it to finish. */
            connectToTelnet(myIntent.getStringExtra("host"));
            return;
        } else {
            // Create a local shell session.
            session = createLocalTermSession();
            if (session == null) {
                finish();
                return;
            }
            mSession = session;
        }

        /* Attach the TermSession to the EmulatorView. */
        view.attachSession(session);

        /* That's all you have to do!  The EmulatorView will call the attached
           TermSession's initializeEmulator() automatically, once it can
           calculate the appropriate screen size for the terminal emulator. */
    }

    @Override
    protected void onResume() {
        super.onResume();

        /* You should call this to let EmulatorView know that it's visible
           on screen. */
        mEmulatorView.onResume();

        mEntry.requestFocus();
    }

    @Override
    protected void onPause() {
        /* You should call this to let EmulatorView know that it's no longer
           visible on screen. */
        mEmulatorView.onPause();

        super.onPause();
    }

    @Override
    protected void onDestroy() {
        /**
         * Finish the TermSession when we're destroyed.  This will free
         * resources, stop I/O threads, and close the I/O streams attached
         * to the session.
         *
         * For the local session, closing the streams will kill the shell; for
         * the Telnet session, it closes the network connection.
         */
        if (mSession != null) {
            mSession.finish();
        }

        super.onDestroy();
    }

    /**
     * Create a TermSession connected to a local shell.
     */
    private TermSession createLocalTermSession() {
        /* Instantiate the TermSession ... */
        TermSession session = new TermSession();

        /* ... create a process ... */
        /* TODO:Make local session work without execpty.
        String execPath = LaunchActivity.getDataDir(this) + "/bin/execpty";
        ProcessBuilder execBuild =
                new ProcessBuilder(execPath, "/system/bin/sh", "-");
        */
        ProcessBuilder execBuild =
                new ProcessBuilder("/system/bin/sh", "-");
        execBuild.redirectErrorStream(true);
        Process exec = null;
        try {
            exec = execBuild.start();
        } catch (Exception e) {
            Log.e(TAG, "Could not start terminal process.", e);
            return null;
        }

        /* ... and connect the process's I/O streams to the TermSession. */
        session.setTermIn(exec.getInputStream());
        session.setTermOut(exec.getOutputStream());

        /* You're done! */
        return session;

        /**
         * NB: You can invoke a program without using execpty or a native code
         * method, but the results may not be what you expect, because the
         * process will be connected to a pipe, not a tty device.  tty devices
         * provide services such as flow control and input/output translation
         * which many programs expect.
         *
         * If you do connect a program directly to a TermSession without using
         * a tty, you should probably at a minimum translate '\r' (sent by the
         * Enter key) to '\n' (which most programs expect as their newline
         * input) in write(), and translate '\n' (sent by most programs to
         * indicate a newline) to '\r\n' (which the terminal emulator needs to
         * actually start a new line without overdrawing text or "staircase
         * effect") in processInput(), before sending it to the terminal
         * emulator.
         *
         * For an example of how to obtain and use a tty device in native code,
         * see assets-src/execpty.c.
         */
    }

    /**
     * Connect to the Telnet server.
     */
    public void connectToTelnet(String server) {
        String[] telnetServer = server.split(":", 2);
        final String hostname = telnetServer[0];
        int port = 23;
        if (telnetServer.length == 2) {
            port = Integer.parseInt(telnetServer[1]);
        }
        final int portNum = port;

        /* On Android API >= 11 (Honeycomb and later), network operations
           must be done off the main thread, so kick off a new thread to
           perform the connect. */
        new Thread() {
            public void run() {
                // Connect to the server
                try {
                    Socket socket = new Socket(hostname, portNum);
                    mSocket = socket;
                } catch (IOException e) {
                    Log.e(TAG, "Could not create socket", e);
                    return;
                }

                // Notify the main thread of the connection
                mHandler.sendEmptyMessage(MSG_CONNECTED);
            }
        }.start();
    }

    /**
     * Handler which will receive the message from the Telnet connect thread
     * that the connection has been established.
     */
    Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            if (msg.what == MSG_CONNECTED) {
                createTelnetSession();
            }
        }
    };
    Socket mSocket;
    private static final int MSG_CONNECTED = 1;

    /* Create the TermSession which will handle the Telnet protocol and
       terminal emulation. */
    private void createTelnetSession() {
        Socket socket = mSocket;

        // Get the socket's input and output streams
        InputStream termIn;
        OutputStream termOut;
        try {
            termIn = socket.getInputStream();
            termOut = socket.getOutputStream();
        } catch (IOException e) {
            // Handle exception here
            return;
        }

        /* Create the TermSession and attach it to the view.  See the
           TelnetSession class for details. */
        TermSession session = new TelnetSession(termIn, termOut);
        mEmulatorView.attachSession(session);
        mSession = session;
    }
}

```

`samples/telnet/src/main/res/layout/launch_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical" >

    <TextView
        android:id="@+id/help"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/help" />

    <Button
        android:id="@+id/launchLocal"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/launch_local_session" />

    <TextView
        android:id="@+id/hostLabel"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/host_label" />

    <EditText
        android:id="@+id/hostname"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/default_telnet_hostname" />

    <Button
        android:id="@+id/launchTelnet"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/launch_telnet_session" />

</LinearLayout>

```

`samples/telnet/src/main/res/layout/term_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical" >

    <jackpal.androidterm.emulatorview.EmulatorView
        android:id="@+id/emulatorView"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:focusable="true"
        android:focusableInTouchMode="true" />

    <LinearLayout
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_weight="0"
        android:orientation="horizontal" >

        <EditText
            android:id="@+id/term_entry"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:singleLine="true"
            android:imeOptions="actionNone|flagNoExtractUi"
            android:inputType="text|textImeMultiLine" />

        <Button
            android:id="@+id/term_entry_send"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="0"
            android:text="@string/entry_send" />

    </LinearLayout>

</LinearLayout>

```

`samples/telnet/src/main/res/values-ko/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">텔넷</string>
    <string name="launch_local_session">쉘 열기</string>
    <string name="launch_telnet_session">연결</string>
    <string name="host_label">텔넷 경로 : </string>
    <string name="entry_send">전송</string>
    <string name="help">이 예제는 EmulatorView 위젯과 TermSession 클래스를 통해 텔넷이 어떻게 작동하는지 보여줍니다.</string>

    <!-- This is a better demo, but towel.blinkenlights.nl is more fun :) -->
    <string name="default_telnet_hostname">telehack.com</string>
</resources>

```

`samples/telnet/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">TEA Telet Sample</string>
    <string name="launch_local_session">Open shell</string>
    <string name="launch_telnet_session">Connect</string>
    <string name="host_label">Telnet to:</string>
    <string name="entry_send">Send</string>
    <string name="help">This example Telnet client demonstrates the use of the EmulatorView widget and the TermSession class.</string>

    <!-- This is a better demo, but towel.blinkenlights.nl is more fun :) -->
    <string name="default_telnet_hostname">telehack.com</string>
</resources>

```

`settings.gradle`:

```gradle
include ':emulatorview', ':libtermexec'
include ':term'
include ':samples:intents'
include ':samples:pathbroadcasts'
include ':samples:telnet'

```

`term/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 22
    buildToolsVersion "22.0.1"

    defaultConfig {
        applicationId "jackpal.androidterm"
        minSdkVersion 4
        targetSdkVersion 22

        ndk {
            moduleName "libjackpal-androidterm5"
            abiFilters 'armeabi', 'mips', 'x86'
            ldLibs "log"
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

dependencies {
    compile project(':emulatorview')
    compile project(':libtermexec')
}

```

`term/lint.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<lint>
    <issue id="MissingTranslation" severity="ignore" />
    <issue id="UseSparseArrays" severity="ignore" />
</lint>

```

`term/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="jackpal.androidterm"
      android:versionName="1.0.70"
      android:versionCode="71"
      android:installLocation="auto">
    <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.ACCESS_SUPERUSER" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <permission android:name="jackpal.androidterm.permission.RUN_SCRIPT"
                android:label="@string/perm_run_script"
                android:description="@string/permdesc_run_script"
                android:permissionGroup="android.permission-group.SYSTEM_TOOLS"
                android:protectionLevel="dangerous" />
    <permission android:name="jackpal.androidterm.permission.APPEND_TO_PATH"
                android:label="@string/perm_append_to_path"
                android:description="@string/permdesc_append_to_path"
                android:permissionGroup="android.permission-group.SYSTEM_TOOLS"
                android:protectionLevel="dangerous" />
    <permission android:name="jackpal.androidterm.permission.PREPEND_TO_PATH"
                android:label="@string/perm_prepend_to_path"
                android:description="@string/permdesc_prepend_to_path"
                android:permissionGroup="android.permission-group.SYSTEM_TOOLS"
                android:protectionLevel="dangerous" />
    <application android:icon="@drawable/ic_launcher"
                android:label="@string/application_terminal"
                android:hardwareAccelerated="true"
                android:theme="@style/Theme">
        <activity android:name="Term"
                android:launchMode="singleTask"
                android:configChanges="keyboard|keyboardHidden|orientation"
                android:windowSoftInputMode="adjustResize|stateAlwaysVisible">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
                <category android:name="android.intent.category.MULTIWINDOW_LAUNCHER" />
            </intent-filter>
        </activity>
        <activity-alias android:name="TermInternal"
                android:targetActivity="Term"
                android:exported="false">
            <intent-filter>
                <action android:name="jackpal.androidterm.private.OPEN_NEW_WINDOW" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
            <intent-filter>
                <action android:name="jackpal.androidterm.private.SWITCH_WINDOW" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity-alias>
        <activity android:name="RemoteInterface"
                android:excludeFromRecents="true">
            <intent-filter>
                <action android:name="jackpal.androidterm.OPEN_NEW_WINDOW" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        <activity-alias
                android:name="TermHere"
                android:label="@string/activity_term_here_title"
                android:targetActivity="RemoteInterface"
                android:exported="true"
        >
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <data android:mimeType="*/*" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity-alias>
        <activity android:name="RunScript"
                android:excludeFromRecents="true"
                android:permission="jackpal.androidterm.permission.RUN_SCRIPT">
            <intent-filter>
                <action android:name="jackpal.androidterm.RUN_SCRIPT" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        <activity android:name="RunShortcut"
                android:excludeFromRecents="true">
            <intent-filter>
                <action android:name="jackpal.androidterm.RUN_SHORTCUT" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        <activity android:name="TermPreferences"
                android:label="@string/preferences"/>
        <activity android:name="WindowList"
                android:label="@string/window_list" />
        <service android:name="TermService" >
            <intent-filter>
                <action android:name="jackpal.androidterm.action.START_TERM.v1"/>
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </service>
    <activity
      android:label="@string/activity_shortcut_create"
      android:name="jackpal.androidterm.shortcuts.AddShortcut"
      android:launchMode="singleTop"
      android:theme="@android:style/Theme.Translucent.NoTitleBar"
      android:configChanges="orientation|keyboard|keyboardHidden"
    >
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
      </intent-filter>
      <intent-filter>
        <action android:name="android.intent.action.CREATE_SHORTCUT" />
      </intent-filter>
      <intent-filter>
        <category android:name="android.intent.category.DEFAULT" />
        <data     android:mimeType="text/*" />
      </intent-filter>
    </activity>
    <activity
      android:name="jackpal.androidterm.shortcuts.FSNavigator"
      android:label="@string/addshortcut_button_find_command"
      android:launchMode="singleTop"
      android:configChanges="orientation|keyboardHidden"
      android:exported="true"
    >
      <intent-filter>
        <action android:name="android.intent.action.PICK" />
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>
      <intent-filter>
        <action android:name="android.intent.action.GET_CONTENT" />
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="android.intent.category.OPENABLE"/>
        <data android:mimeType="*/*" />
      </intent-filter>
    </activity>
    <meta-data
      android:name="com.sec.android.support.multiwindow"
      android:value="true">
        </meta-data>
    </application>
</manifest>

```

`term/src/main/java/jackpal/androidterm/BoundSession.java`:

```java
package jackpal.androidterm;

import android.os.ParcelFileDescriptor;
import android.text.TextUtils;
import jackpal.androidterm.util.TermSettings;

class BoundSession extends GenericTermSession {
    private final String issuerTitle;

    private boolean fullyInitialized;

    BoundSession(ParcelFileDescriptor ptmxFd, TermSettings settings, String issuerTitle) {
        super(ptmxFd, settings, true);

        this.issuerTitle = issuerTitle;

        setTermIn(new ParcelFileDescriptor.AutoCloseInputStream(ptmxFd));
        setTermOut(new ParcelFileDescriptor.AutoCloseOutputStream(ptmxFd));
    }

    @Override
    public String getTitle() {
        final String extraTitle = super.getTitle();

        return TextUtils.isEmpty(extraTitle)
               ? issuerTitle
               : issuerTitle + " — " + extraTitle;
    }

    @Override
    public void initializeEmulator(int columns, int rows) {
        super.initializeEmulator(columns, rows);

        fullyInitialized = true;
    }

    @Override
    boolean isFailFast() {
        return !fullyInitialized;
    }
}

```

`term/src/main/java/jackpal/androidterm/Exec.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;
import android.os.Build;
import android.os.ParcelFileDescriptor;
import android.util.Log;

import java.io.File;
import java.io.FileDescriptor;
import java.io.IOException;
import java.lang.IllegalStateException;
import java.lang.Process;
import java.lang.reflect.Field;

/**
 * Utility methods for managing a pty file descriptor.
 */
public class Exec
{
    // Warning: bump the library revision, when an incompatible change happens
    static {
        System.loadLibrary("jackpal-androidterm5");
    }

    static native void setPtyWindowSizeInternal(int fd, int row, int col, int xpixel, int ypixel) throws IOException;

    static native void setPtyUTF8ModeInternal(int fd, boolean utf8Mode) throws IOException;
}


```

`term/src/main/java/jackpal/androidterm/GenericTermSession.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import java.io.*;
import java.lang.reflect.Field;
import java.util.ArrayList;

import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.os.ParcelFileDescriptor;
import android.util.Log;

import jackpal.androidterm.emulatorview.ColorScheme;
import jackpal.androidterm.emulatorview.TermSession;
import jackpal.androidterm.emulatorview.UpdateCallback;

import jackpal.androidterm.compat.FileCompat;
import jackpal.androidterm.util.TermSettings;

/**
 * A terminal session, consisting of a TerminalEmulator, a TranscriptScreen,
 * and the I/O streams used to talk to the process.
 */
class GenericTermSession extends TermSession {
    //** Set to true to force into 80 x 24 for testing with vttest. */
    private static final boolean VTTEST_MODE = false;

    private static Field descriptorField;

    private final long createdAt;

    // A cookie which uniquely identifies this session.
    private String mHandle;

    final ParcelFileDescriptor mTermFd;

    TermSettings mSettings;

    public static final int PROCESS_EXIT_FINISHES_SESSION = 0;
    public static final int PROCESS_EXIT_DISPLAYS_MESSAGE = 1;

    private String mProcessExitMessage;

    private UpdateCallback mUTF8ModeNotify = new UpdateCallback() {
        public void onUpdate() {
            setPtyUTF8Mode(getUTF8Mode());
        }
    };

    GenericTermSession(ParcelFileDescriptor mTermFd, TermSettings settings, boolean exitOnEOF) {
        super(exitOnEOF);

        this.mTermFd = mTermFd;

        this.createdAt = System.currentTimeMillis();

        updatePrefs(settings);
    }

    public void updatePrefs(TermSettings settings) {
        mSettings = settings;
        setColorScheme(new ColorScheme(settings.getColorScheme()));
        setDefaultUTF8Mode(settings.defaultToUTF8Mode());
    }

    @Override
    public void initializeEmulator(int columns, int rows) {
        if (VTTEST_MODE) {
            columns = 80;
            rows = 24;
        }
        super.initializeEmulator(columns, rows);

        setPtyUTF8Mode(getUTF8Mode());
        setUTF8ModeUpdateCallback(mUTF8ModeNotify);
    }

    @Override
    public void updateSize(int columns, int rows) {
        if (VTTEST_MODE) {
            columns = 80;
            rows = 24;
        }
        // Inform the attached pty of our new size:
        setPtyWindowSize(rows, columns, 0, 0);
        super.updateSize(columns, rows);
    }

    /* XXX We should really get this ourselves from the resource bundle, but
       we cannot hold a context */
    public void setProcessExitMessage(String message) {
        mProcessExitMessage = message;
    }

    @Override
    protected void onProcessExit() {
        if (mSettings.closeWindowOnProcessExit()) {
            finish();
        } else if (mProcessExitMessage != null) {
            try {
                byte[] msg = ("\r\n[" + mProcessExitMessage + "]").getBytes("UTF-8");
                appendToEmulator(msg, 0, msg.length);
                notifyUpdate();
            } catch (UnsupportedEncodingException e) {
                // Never happens
            }
        }
    }

    @Override
    public void finish() {
        try {
            mTermFd.close();
        } catch (IOException e) {
            // ok
        }

        super.finish();
    }

    /**
     * Gets the terminal session's title.  Unlike the superclass's getTitle(),
     * if the title is null or an empty string, the provided default title will
     * be returned instead.
     *
     * @param defaultTitle The default title to use if this session's title is
     *     unset or an empty string.
     */
    public String getTitle(String defaultTitle) {
        String title = getTitle();
        if (title != null && title.length() > 0) {
            return title;
        } else {
            return defaultTitle;
        }
    }

    public void setHandle(String handle) {
        if (mHandle != null) {
            throw new IllegalStateException("Cannot change handle once set");
        }
        mHandle = handle;
    }

    public String getHandle() {
        return mHandle;
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + '(' + createdAt + ',' + mHandle + ')';
    }

    /**
     * Set the widow size for a given pty. Allows programs
     * connected to the pty learn how large their screen is.
     */
    void setPtyWindowSize(int row, int col, int xpixel, int ypixel) {
        // If the tty goes away too quickly, this may get called after it's descriptor is closed
        if (!mTermFd.getFileDescriptor().valid())
            return;

        try {
            Exec.setPtyWindowSizeInternal(getIntFd(mTermFd), row, col, xpixel, ypixel);
        } catch (IOException e) {
            Log.e("exec", "Failed to set window size: " + e.getMessage());

            if (isFailFast())
                throw new IllegalStateException(e);
        }
    }

    /**
     * Set or clear UTF-8 mode for a given pty.  Used by the terminal driver
     * to implement correct erase behavior in cooked mode (Linux >= 2.6.4).
     */
    void setPtyUTF8Mode(boolean utf8Mode) {
        // If the tty goes away too quickly, this may get called after it's descriptor is closed
        if (!mTermFd.getFileDescriptor().valid())
            return;

        try {
            Exec.setPtyUTF8ModeInternal(getIntFd(mTermFd), utf8Mode);
        } catch (IOException e) {
            Log.e("exec", "Failed to set UTF mode: " + e.getMessage());

            if (isFailFast())
                throw new IllegalStateException(e);
        }
    }

    /**
     * @return true, if failing to operate on file descriptor deserves an exception (never the case for ATE own shell)
     */
    boolean isFailFast() {
        return false;
    }

    private static void cacheDescField() throws NoSuchFieldException {
        if (descriptorField != null)
            return;

        descriptorField = FileDescriptor.class.getDeclaredField("descriptor");
        descriptorField.setAccessible(true);
    }

    private static int getIntFd(ParcelFileDescriptor parcelFd) throws IOException {
        if (Build.VERSION.SDK_INT >= 12)
            return FdHelperHoneycomb.getFd(parcelFd);
        else {
            try {
                cacheDescField();

                return descriptorField.getInt(parcelFd.getFileDescriptor());
            } catch (Exception e) {
                throw new IOException("Unable to obtain file descriptor on this OS version: " + e.getMessage());
            }
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/RemoteInterface.java`:

```java
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import java.io.File;
import java.io.IOException;
import java.util.UUID;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Bundle;
import android.os.IBinder;
import android.preference.PreferenceManager;
import android.util.Log;

import jackpal.androidterm.emulatorview.TermSession;

import jackpal.androidterm.util.SessionList;
import jackpal.androidterm.util.TermSettings;

public class RemoteInterface extends Activity {
    protected static final String PRIVACT_OPEN_NEW_WINDOW = "jackpal.androidterm.private.OPEN_NEW_WINDOW";
    protected static final String PRIVACT_SWITCH_WINDOW = "jackpal.androidterm.private.SWITCH_WINDOW";

    protected static final String PRIVEXTRA_TARGET_WINDOW = "jackpal.androidterm.private.target_window";

    protected static final String PRIVACT_ACTIVITY_ALIAS = "jackpal.androidterm.TermInternal";

    private TermSettings mSettings;

    private TermService mTermService;
    private Intent mTSIntent;
    private ServiceConnection mTSConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className, IBinder service) {
            TermService.TSBinder binder = (TermService.TSBinder) service;
            mTermService = binder.getService();
            handleIntent();
        }

        public void onServiceDisconnected(ComponentName className) {
            mTermService = null;
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        mSettings = new TermSettings(getResources(), prefs);

        Intent TSIntent = new Intent(this, TermService.class);
        mTSIntent = TSIntent;
        startService(TSIntent);
        if (!bindService(TSIntent, mTSConnection, BIND_AUTO_CREATE)) {
            Log.e(TermDebug.LOG_TAG, "bind to service failed!");
            finish();
        }
    }

    @Override
    public void finish() {
        ServiceConnection conn = mTSConnection;
        if (conn != null) {
            unbindService(conn);

            // Stop the service if no terminal sessions are running
            TermService service = mTermService;
            if (service != null) {
                SessionList sessions = service.getSessions();
                if (sessions == null || sessions.size() == 0) {
                    stopService(mTSIntent);
                }
            }

            mTSConnection = null;
            mTermService = null;
        }
        super.finish();
    }

    protected TermService getTermService() {
        return mTermService;
    }

    protected void handleIntent() {
        TermService service = getTermService();
        if (service == null) {
            finish();
            return;
        }

        Intent myIntent = getIntent();
        String action = myIntent.getAction();
        if (action.equals(Intent.ACTION_SEND)
                && myIntent.hasExtra(Intent.EXTRA_STREAM)) {
          /* "permission.RUN_SCRIPT" not required as this is merely opening a new window. */
            Object extraStream = myIntent.getExtras().get(Intent.EXTRA_STREAM);
            if (extraStream instanceof Uri) {
                String path = ((Uri) extraStream).getPath();
                File file = new File(path);
                String dirPath = file.isDirectory() ? path : file.getParent();
                openNewWindow("cd " + quoteForBash(dirPath));
            }
        } else {
            // Intent sender may not have permissions, ignore any extras
            openNewWindow(null);
        }

        finish();
    }

    /**
     *  Quote a string so it can be used as a parameter in bash and similar shells.
     */
    public static String quoteForBash(String s) {
        StringBuilder builder = new StringBuilder();
        String specialChars = "\"\\$`!";
        builder.append('"');
        int length = s.length();
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            if (specialChars.indexOf(c) >= 0) {
                builder.append('\\');
            }
            builder.append(c);
        }
        builder.append('"');
        return builder.toString();
    }

    protected String openNewWindow(String iInitialCommand) {
        TermService service = getTermService();

        String initialCommand = mSettings.getInitialCommand();
        if (iInitialCommand != null) {
            if (initialCommand != null) {
                initialCommand += "\r" + iInitialCommand;
            } else {
                initialCommand = iInitialCommand;
            }
        }

        try {
            TermSession session = Term.createTermSession(this, mSettings, initialCommand);

            session.setFinishCallback(service);
            service.getSessions().add(session);

            String handle = UUID.randomUUID().toString();
            ((GenericTermSession) session).setHandle(handle);

            Intent intent = new Intent(PRIVACT_OPEN_NEW_WINDOW);
            intent.addCategory(Intent.CATEGORY_DEFAULT);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(intent);

            return handle;
        } catch (IOException e) {
            return null;
        }
    }

    protected String appendToWindow(String handle, String iInitialCommand) {
        TermService service = getTermService();

        // Find the target window
        SessionList sessions = service.getSessions();
        GenericTermSession target = null;
        int index;
        for (index = 0; index < sessions.size(); ++index) {
            GenericTermSession session = (GenericTermSession) sessions.get(index);
            String h = session.getHandle();
            if (h != null && h.equals(handle)) {
                target = session;
                break;
            }
        }

        if (target == null) {
            // Target window not found, open a new one
            return openNewWindow(iInitialCommand);
        }

        if (iInitialCommand != null) {
            target.write(iInitialCommand);
            target.write('\r');
        }

        Intent intent = new Intent(PRIVACT_SWITCH_WINDOW);
        intent.addCategory(Intent.CATEGORY_DEFAULT);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(PRIVEXTRA_TARGET_WINDOW, index);
        startActivity(intent);

        return handle;
    }
}

```

`term/src/main/java/jackpal/androidterm/RunScript.java`:

```java
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import android.content.Intent;
import android.net.Uri;
import android.util.Log;

/*
 * New procedure for launching a command in ATE.
 * Build the path and arguments into a Uri and set that into Intent.data.
 * intent.data(new Uri.Builder().setScheme("file").setPath(path).setFragment(arguments))
 *
 * The old procedure of using Intent.Extra is still available but is discouraged.
 */
public final class RunScript extends RemoteInterface {
    private static final String ACTION_RUN_SCRIPT = "jackpal.androidterm.RUN_SCRIPT";

    private static final String EXTRA_WINDOW_HANDLE = "jackpal.androidterm.window_handle";
    private static final String EXTRA_INITIAL_COMMAND = "jackpal.androidterm.iInitialCommand";

    @Override
    protected void handleIntent() {
        TermService service = getTermService();
        if (service == null) {
            finish();
            return;
        }

        Intent myIntent = getIntent();
        String action = myIntent.getAction();
        if (action.equals(ACTION_RUN_SCRIPT)) {
            /* Someone with the appropriate permissions has asked us to
               run a script */
            String handle = myIntent.getStringExtra(EXTRA_WINDOW_HANDLE);
            String command=null;
            /*
             * First look in Intent.data for the path; if not there, revert to
             * the EXTRA_INITIAL_COMMAND location.
             */
            Uri uri=myIntent.getData();
            if(uri!=null) // scheme[path][arguments]
            {
              String s=uri.getScheme();
              if(s!=null && s.toLowerCase().equals("file"))
              {
                command=uri.getPath();
                // Allow for the command to be contained within the arguments string.
                if(command==null) command="";
                if(!command.equals("")) command=quoteForBash(command);
                // Append any arguments.
                if(null!=(s=uri.getFragment())) command+=" "+s;
              }
            }
            // If Intent.data not used then fall back to old method.
            if(command==null) command=myIntent.getStringExtra(EXTRA_INITIAL_COMMAND);
            if (handle != null) {
                // Target the request at an existing window if open
                handle = appendToWindow(handle, command);
            } else {
                // Open a new window
                handle = openNewWindow(command);
            }
            Intent result = new Intent();
            result.putExtra(EXTRA_WINDOW_HANDLE, handle);
            setResult(RESULT_OK, result);

            finish();
        } else {
            super.handleIntent();
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/RunShortcut.java`:

```java
/*
 * Copyright (C) 2015 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import jackpal.androidterm.util.ShortcutEncryption;

import java.security.GeneralSecurityException;

import android.content.Intent;
import android.util.Log;

public final class RunShortcut extends RemoteInterface {
    public static final String ACTION_RUN_SHORTCUT = "jackpal.androidterm.RUN_SHORTCUT";

    public static final String EXTRA_WINDOW_HANDLE = "jackpal.androidterm.window_handle";
    public static final String EXTRA_SHORTCUT_COMMAND = "jackpal.androidterm.iShortcutCommand";

    @Override
    protected void handleIntent() {
        TermService service = getTermService();
        if (service == null) {
            finish();
            return;
        }

        Intent myIntent = getIntent();
        String action = myIntent.getAction();
        if (action.equals(ACTION_RUN_SHORTCUT)) {
            String encCommand = myIntent.getStringExtra(EXTRA_SHORTCUT_COMMAND);
            if (encCommand == null) {
                Log.e(TermDebug.LOG_TAG, "No command provided in shortcut!");
                finish();
                return;
            }

            // Decrypt and verify the command
            ShortcutEncryption.Keys keys = ShortcutEncryption.getKeys(this);
            if (keys == null) {
                // No keys -- no valid shortcuts can exist
                Log.e(TermDebug.LOG_TAG, "No shortcut encryption keys found!");
                finish();
                return;
            }
            String command;
            try {
                command = ShortcutEncryption.decrypt(encCommand, keys);
            } catch (GeneralSecurityException e) {
                Log.e(TermDebug.LOG_TAG, "Invalid shortcut: " + e.toString());
                finish();
                return;
            }

            String handle = myIntent.getStringExtra(EXTRA_WINDOW_HANDLE);
            if (handle != null) {
                // Target the request at an existing window if open
                handle = appendToWindow(handle, command);
            } else {
                // Open a new window
                handle = openNewWindow(command);
            }
            Intent result = new Intent();
            result.putExtra(EXTRA_WINDOW_HANDLE, handle);
            setResult(RESULT_OK, result);
        }

        finish();
    }
}

```

`term/src/main/java/jackpal/androidterm/ShellTermSession.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import android.os.Handler;
import android.os.Message;
import android.os.ParcelFileDescriptor;
import android.util.Log;
import jackpal.androidterm.compat.FileCompat;
import jackpal.androidterm.util.TermSettings;

import java.io.*;
import java.util.ArrayList;

/**
 * A terminal session, controlling the process attached to the session (usually
 * a shell). It keeps track of process PID and destroys it's process group
 * upon stopping.
 */
public class ShellTermSession extends GenericTermSession {
    private int mProcId;
    private Thread mWatcherThread;

    private String mInitialCommand;

    private static final int PROCESS_EXITED = 1;
    private Handler mMsgHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            if (!isRunning()) {
                return;
            }
            if (msg.what == PROCESS_EXITED) {
                onProcessExit((Integer) msg.obj);
            }
        }
    };

    public ShellTermSession(TermSettings settings, String initialCommand) throws IOException {
        super(ParcelFileDescriptor.open(new File("/dev/ptmx"), ParcelFileDescriptor.MODE_READ_WRITE),
                settings, false);

        initializeSession();

        setTermOut(new ParcelFileDescriptor.AutoCloseOutputStream(mTermFd));
        setTermIn(new ParcelFileDescriptor.AutoCloseInputStream(mTermFd));

        mInitialCommand = initialCommand;

        mWatcherThread = new Thread() {
            @Override
            public void run() {
                Log.i(TermDebug.LOG_TAG, "waiting for: " + mProcId);
                int result = TermExec.waitFor(mProcId);
                Log.i(TermDebug.LOG_TAG, "Subprocess exited: " + result);
                mMsgHandler.sendMessage(mMsgHandler.obtainMessage(PROCESS_EXITED, result));
            }
        };
        mWatcherThread.setName("Process watcher");
    }

    private void initializeSession() throws IOException {
        TermSettings settings = mSettings;

        String path = System.getenv("PATH");
        if (settings.doPathExtensions()) {
            String appendPath = settings.getAppendPath();
            if (appendPath != null && appendPath.length() > 0) {
                path = path + ":" + appendPath;
            }

            if (settings.allowPathPrepend()) {
                String prependPath = settings.getPrependPath();
                if (prependPath != null && prependPath.length() > 0) {
                    path = prependPath + ":" + path;
                }
            }
        }
        if (settings.verifyPath()) {
            path = checkPath(path);
        }
        String[] env = new String[3];
        env[0] = "TERM=" + settings.getTermType();
        env[1] = "PATH=" + path;
        env[2] = "HOME=" + settings.getHomePath();

        mProcId = createSubprocess(settings.getShell(), env);
    }

    private String checkPath(String path) {
        String[] dirs = path.split(":");
        StringBuilder checkedPath = new StringBuilder(path.length());
        for (String dirname : dirs) {
            File dir = new File(dirname);
            if (dir.isDirectory() && FileCompat.canExecute(dir)) {
                checkedPath.append(dirname);
                checkedPath.append(":");
            }
        }
        return checkedPath.substring(0, checkedPath.length()-1);
    }

    @Override
    public void initializeEmulator(int columns, int rows) {
        super.initializeEmulator(columns, rows);

        mWatcherThread.start();
        sendInitialCommand(mInitialCommand);
    }

    private void sendInitialCommand(String initialCommand) {
        if (initialCommand.length() > 0) {
            write(initialCommand + '\r');
        }
    }

    private int createSubprocess(String shell, String[] env) throws IOException {
        ArrayList<String> argList = parse(shell);
        String arg0;
        String[] args;

        try {
            arg0 = argList.get(0);
            File file = new File(arg0);
            if (!file.exists()) {
                Log.e(TermDebug.LOG_TAG, "Shell " + arg0 + " not found!");
                throw new FileNotFoundException(arg0);
            } else if (!FileCompat.canExecute(file)) {
                Log.e(TermDebug.LOG_TAG, "Shell " + arg0 + " not executable!");
                throw new FileNotFoundException(arg0);
            }
            args = argList.toArray(new String[1]);
        } catch (Exception e) {
            argList = parse(mSettings.getFailsafeShell());
            arg0 = argList.get(0);
            args = argList.toArray(new String[1]);
        }

        return TermExec.createSubprocess(mTermFd, arg0, args, env);
    }

    private ArrayList<String> parse(String cmd) {
        final int PLAIN = 0;
        final int WHITESPACE = 1;
        final int INQUOTE = 2;
        int state = WHITESPACE;
        ArrayList<String> result =  new ArrayList<String>();
        int cmdLen = cmd.length();
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < cmdLen; i++) {
            char c = cmd.charAt(i);
            if (state == PLAIN) {
                if (Character.isWhitespace(c)) {
                    result.add(builder.toString());
                    builder.delete(0,builder.length());
                    state = WHITESPACE;
                } else if (c == '"') {
                    state = INQUOTE;
                } else {
                    builder.append(c);
                }
            } else if (state == WHITESPACE) {
                if (Character.isWhitespace(c)) {
                    // do nothing
                } else if (c == '"') {
                    state = INQUOTE;
                } else {
                    state = PLAIN;
                    builder.append(c);
                }
            } else if (state == INQUOTE) {
                if (c == '\\') {
                    if (i + 1 < cmdLen) {
                        i += 1;
                        builder.append(cmd.charAt(i));
                    }
                } else if (c == '"') {
                    state = PLAIN;
                } else {
                    builder.append(c);
                }
            }
        }
        if (builder.length() > 0) {
            result.add(builder.toString());
        }
        return result;
    }

    private void onProcessExit(int result) {
        onProcessExit();
    }

    @Override
    public void finish() {
        hangupProcessGroup();
        super.finish();
    }

    /**
     * Send SIGHUP to a process group, SIGHUP notifies a terminal client, that the terminal have been disconnected,
     * and usually results in client's death, unless it's process is a daemon or have been somehow else detached
     * from the terminal (for example, by the "nohup" utility).
     */
    void hangupProcessGroup() {
        TermExec.sendSignal(-mProcId, 1);
    }
}

```

`term/src/main/java/jackpal/androidterm/Term.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import android.text.TextUtils;
import jackpal.androidterm.compat.ActionBarCompat;
import jackpal.androidterm.compat.ActivityCompat;
import jackpal.androidterm.compat.AndroidCompat;
import jackpal.androidterm.compat.MenuItemCompat;
import jackpal.androidterm.emulatorview.EmulatorView;
import jackpal.androidterm.emulatorview.TermSession;
import jackpal.androidterm.emulatorview.UpdateCallback;
import jackpal.androidterm.emulatorview.compat.ClipboardManagerCompat;
import jackpal.androidterm.emulatorview.compat.ClipboardManagerCompatFactory;
import jackpal.androidterm.emulatorview.compat.KeycodeConstants;
import jackpal.androidterm.util.SessionList;
import jackpal.androidterm.util.TermSettings;

import java.io.IOException;
import java.text.Collator;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.net.Uri;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.PowerManager;
import android.preference.PreferenceManager;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.TextView;
import android.widget.Toast;

/**
 * A terminal emulator activity.
 */

public class Term extends Activity implements UpdateCallback, SharedPreferences.OnSharedPreferenceChangeListener {
    /**
     * The ViewFlipper which holds the collection of EmulatorView widgets.
     */
    private TermViewFlipper mViewFlipper;

    /**
     * The name of the ViewFlipper in the resources.
     */
    private static final int VIEW_FLIPPER = R.id.view_flipper;

    private SessionList mTermSessions;

    private TermSettings mSettings;

    private final static int SELECT_TEXT_ID = 0;
    private final static int COPY_ALL_ID = 1;
    private final static int PASTE_ID = 2;
    private final static int SEND_CONTROL_KEY_ID = 3;
    private final static int SEND_FN_KEY_ID = 4;

    private boolean mAlreadyStarted = false;
    private boolean mStopServiceOnFinish = false;

    private Intent TSIntent;

    public static final int REQUEST_CHOOSE_WINDOW = 1;
    public static final String EXTRA_WINDOW_ID = "jackpal.androidterm.window_id";
    private int onResumeSelectWindow = -1;
    private ComponentName mPrivateAlias;

    private PowerManager.WakeLock mWakeLock;
    private WifiManager.WifiLock mWifiLock;
    // Available on API 12 and later
    private static final int WIFI_MODE_FULL_HIGH_PERF = 3;

    private boolean mBackKeyPressed;

    private static final String ACTION_PATH_BROADCAST = "jackpal.androidterm.broadcast.APPEND_TO_PATH";
    private static final String ACTION_PATH_PREPEND_BROADCAST = "jackpal.androidterm.broadcast.PREPEND_TO_PATH";
    private static final String PERMISSION_PATH_BROADCAST = "jackpal.androidterm.permission.APPEND_TO_PATH";
    private static final String PERMISSION_PATH_PREPEND_BROADCAST = "jackpal.androidterm.permission.PREPEND_TO_PATH";
    private int mPendingPathBroadcasts = 0;
    private BroadcastReceiver mPathReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String path = makePathFromBundle(getResultExtras(false));
            if (intent.getAction().equals(ACTION_PATH_PREPEND_BROADCAST)) {
                mSettings.setPrependPath(path);
            } else {
                mSettings.setAppendPath(path);
            }
            mPendingPathBroadcasts--;

            if (mPendingPathBroadcasts <= 0 && mTermService != null) {
                populateViewFlipper();
                populateWindowList();
            }
        }
    };
    // Available on API 12 and later
    private static final int FLAG_INCLUDE_STOPPED_PACKAGES = 0x20;

    private TermService mTermService;
    private ServiceConnection mTSConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className, IBinder service) {
            Log.i(TermDebug.LOG_TAG, "Bound to TermService");
            TermService.TSBinder binder = (TermService.TSBinder) service;
            mTermService = binder.getService();
            if (mPendingPathBroadcasts <= 0) {
                populateViewFlipper();
                populateWindowList();
            }
        }

        public void onServiceDisconnected(ComponentName arg0) {
            mTermService = null;
        }
    };

    private ActionBarCompat mActionBar;
    private int mActionBarMode = TermSettings.ACTION_BAR_MODE_NONE;

    private WindowListAdapter mWinListAdapter;

    @Override
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String s) {
        mSettings.readPrefs(sharedPreferences);
    }

    private class WindowListActionBarAdapter extends WindowListAdapter implements UpdateCallback {
        // From android.R.style in API 13
        private static final int TextAppearance_Holo_Widget_ActionBar_Title = 0x01030112;

        public WindowListActionBarAdapter(SessionList sessions) {
            super(sessions);
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            TextView label = new TextView(Term.this);
            String title = getSessionTitle(position, getString(R.string.window_title, position + 1));
            label.setText(title);
            if (AndroidCompat.SDK >= 13) {
                label.setTextAppearance(Term.this, TextAppearance_Holo_Widget_ActionBar_Title);
            } else {
                label.setTextAppearance(Term.this, android.R.style.TextAppearance_Medium);
            }
            return label;
        }

        @Override
        public View getDropDownView(int position, View convertView, ViewGroup parent) {
            return super.getView(position, convertView, parent);
        }

        public void onUpdate() {
            notifyDataSetChanged();
            mActionBar.setSelectedNavigationItem(mViewFlipper.getDisplayedChild());
        }
    }

    private ActionBarCompat.OnNavigationListener mWinListItemSelected = new ActionBarCompat.OnNavigationListener() {
        public boolean onNavigationItemSelected(int position, long id) {
            int oldPosition = mViewFlipper.getDisplayedChild();
            if (position != oldPosition) {
                if (position >= mViewFlipper.getChildCount()) {
                    mViewFlipper.addView(createEmulatorView(mTermSessions.get(position)));
                }
                mViewFlipper.setDisplayedChild(position);
                if (mActionBarMode == TermSettings.ACTION_BAR_MODE_HIDES) {
                    mActionBar.hide();
                }
            }
            return true;
        }
    };

    private boolean mHaveFullHwKeyboard = false;

    private class EmulatorViewGestureListener extends SimpleOnGestureListener {
        private EmulatorView view;

        public EmulatorViewGestureListener(EmulatorView view) {
            this.view = view;
        }

        @Override
        public boolean onSingleTapUp(MotionEvent e) {
            // Let the EmulatorView handle taps if mouse tracking is active
            if (view.isMouseTrackingActive()) return false;

            //Check for link at tap location
            String link = view.getURLat(e.getX(), e.getY());
            if(link != null)
                execURL(link);
            else
                doUIToggle((int) e.getX(), (int) e.getY(), view.getVisibleWidth(), view.getVisibleHeight());
            return true;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            float absVelocityX = Math.abs(velocityX);
            float absVelocityY = Math.abs(velocityY);
            if (absVelocityX > Math.max(1000.0f, 2.0 * absVelocityY)) {
                // Assume user wanted side to side movement
                if (velocityX > 0) {
                    // Left to right swipe -- previous window
                    mViewFlipper.showPrevious();
                } else {
                    // Right to left swipe -- next window
                    mViewFlipper.showNext();
                }
                return true;
            } else {
                return false;
            }
        }
    }

    /**
     * Should we use keyboard shortcuts?
     */
    private boolean mUseKeyboardShortcuts;

    /**
     * Intercepts keys before the view/terminal gets it.
     */
    private View.OnKeyListener mKeyListener = new View.OnKeyListener() {
        public boolean onKey(View v, int keyCode, KeyEvent event) {
            return backkeyInterceptor(keyCode, event) || keyboardShortcuts(keyCode, event);
        }

        /**
         * Keyboard shortcuts (tab management, paste)
         */
        private boolean keyboardShortcuts(int keyCode, KeyEvent event) {
            if (event.getAction() != KeyEvent.ACTION_DOWN) {
                return false;
            }
            if (!mUseKeyboardShortcuts) {
                return false;
            }
            boolean isCtrlPressed = (event.getMetaState() & KeycodeConstants.META_CTRL_ON) != 0;
            boolean isShiftPressed = (event.getMetaState() & KeycodeConstants.META_SHIFT_ON) != 0;

            if (keyCode == KeycodeConstants.KEYCODE_TAB && isCtrlPressed) {
                if (isShiftPressed) {
                    mViewFlipper.showPrevious();
                } else {
                    mViewFlipper.showNext();
                }

                return true;
            } else if (keyCode == KeycodeConstants.KEYCODE_N && isCtrlPressed && isShiftPressed) {
                doCreateNewWindow();

                return true;
            } else if (keyCode == KeycodeConstants.KEYCODE_V && isCtrlPressed && isShiftPressed) {
                doPaste();

                return true;
            } else {
                return false;
            }
        }

        /**
         * Make sure the back button always leaves the application.
         */
        private boolean backkeyInterceptor(int keyCode, KeyEvent event) {
            if (keyCode == KeyEvent.KEYCODE_BACK && mActionBarMode == TermSettings.ACTION_BAR_MODE_HIDES && mActionBar != null && mActionBar.isShowing()) {
                /* We need to intercept the key event before the view sees it,
                   otherwise the view will handle it before we get it */
                onKeyUp(keyCode, event);
                return true;
            } else {
                return false;
            }
        }
    };

    private Handler mHandler = new Handler();

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        Log.v(TermDebug.LOG_TAG, "onCreate");

        mPrivateAlias = new ComponentName(this, RemoteInterface.PRIVACT_ACTIVITY_ALIAS);

        if (icicle == null)
            onNewIntent(getIntent());

        final SharedPreferences mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        mSettings = new TermSettings(getResources(), mPrefs);
        mPrefs.registerOnSharedPreferenceChangeListener(this);

        Intent broadcast = new Intent(ACTION_PATH_BROADCAST);
        if (AndroidCompat.SDK >= 12) {
            broadcast.addFlags(FLAG_INCLUDE_STOPPED_PACKAGES);
        }
        mPendingPathBroadcasts++;
        sendOrderedBroadcast(broadcast, PERMISSION_PATH_BROADCAST, mPathReceiver, null, RESULT_OK, null, null);

        broadcast = new Intent(broadcast);
        broadcast.setAction(ACTION_PATH_PREPEND_BROADCAST);
        mPendingPathBroadcasts++;
        sendOrderedBroadcast(broadcast, PERMISSION_PATH_PREPEND_BROADCAST, mPathReceiver, null, RESULT_OK, null, null);

        TSIntent = new Intent(this, TermService.class);
        startService(TSIntent);

        if (AndroidCompat.SDK >= 11) {
            int actionBarMode = mSettings.actionBarMode();
            mActionBarMode = actionBarMode;
            if (AndroidCompat.V11ToV20) {
                switch (actionBarMode) {
                case TermSettings.ACTION_BAR_MODE_ALWAYS_VISIBLE:
                    setTheme(R.style.Theme_Holo);
                    break;
                case TermSettings.ACTION_BAR_MODE_HIDES:
                    setTheme(R.style.Theme_Holo_ActionBarOverlay);
                    break;
                }
            }
        } else {
            mActionBarMode = TermSettings.ACTION_BAR_MODE_ALWAYS_VISIBLE;
        }

        setContentView(R.layout.term_activity);
        mViewFlipper = (TermViewFlipper) findViewById(VIEW_FLIPPER);

        PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);
        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TermDebug.LOG_TAG);
        WifiManager wm = (WifiManager)getSystemService(Context.WIFI_SERVICE);
        int wifiLockMode = WifiManager.WIFI_MODE_FULL;
        if (AndroidCompat.SDK >= 12) {
            wifiLockMode = WIFI_MODE_FULL_HIGH_PERF;
        }
        mWifiLock = wm.createWifiLock(wifiLockMode, TermDebug.LOG_TAG);

        ActionBarCompat actionBar = ActivityCompat.getActionBar(this);
        if (actionBar != null) {
            mActionBar = actionBar;
            actionBar.setNavigationMode(ActionBarCompat.NAVIGATION_MODE_LIST);
            actionBar.setDisplayOptions(0, ActionBarCompat.DISPLAY_SHOW_TITLE);
            if (mActionBarMode == TermSettings.ACTION_BAR_MODE_HIDES) {
                actionBar.hide();
            }
        }

        mHaveFullHwKeyboard = checkHaveFullHwKeyboard(getResources().getConfiguration());

        updatePrefs();
        mAlreadyStarted = true;
    }

    private String makePathFromBundle(Bundle extras) {
        if (extras == null || extras.size() == 0) {
            return "";
        }

        String[] keys = new String[extras.size()];
        keys = extras.keySet().toArray(keys);
        Collator collator = Collator.getInstance(Locale.US);
        Arrays.sort(keys, collator);

        StringBuilder path = new StringBuilder();
        for (String key : keys) {
            String dir = extras.getString(key);
            if (dir != null && !dir.equals("")) {
                path.append(dir);
                path.append(":");
            }
        }

        return path.substring(0, path.length()-1);
    }

    @Override
    protected void onStart() {
        super.onStart();

        if (!bindService(TSIntent, mTSConnection, BIND_AUTO_CREATE)) {
            throw new IllegalStateException("Failed to bind to TermService!");
        }
    }

    private void populateViewFlipper() {
        if (mTermService != null) {
            mTermSessions = mTermService.getSessions();

            if (mTermSessions.size() == 0) {
                try {
                    mTermSessions.add(createTermSession());
                } catch (IOException e) {
                    Toast.makeText(this, "Failed to start terminal session", Toast.LENGTH_LONG).show();
                    finish();
                    return;
                }
            }

            mTermSessions.addCallback(this);

            for (TermSession session : mTermSessions) {
                EmulatorView view = createEmulatorView(session);
                mViewFlipper.addView(view);
            }

            updatePrefs();

            if (onResumeSelectWindow >= 0) {
                mViewFlipper.setDisplayedChild(onResumeSelectWindow);
                onResumeSelectWindow = -1;
            }
            mViewFlipper.onResume();
        }
    }

    private void populateWindowList() {
        if (mActionBar == null) {
            // Not needed
            return;
        }
        if (mTermSessions != null) {
            int position = mViewFlipper.getDisplayedChild();
            if (mWinListAdapter == null) {
                mWinListAdapter = new WindowListActionBarAdapter(mTermSessions);

                mActionBar.setListNavigationCallbacks(mWinListAdapter, mWinListItemSelected);
            } else {
                mWinListAdapter.setSessions(mTermSessions);
            }
            mViewFlipper.addCallback(mWinListAdapter);

            mActionBar.setSelectedNavigationItem(position);
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        PreferenceManager.getDefaultSharedPreferences(this)
                .unregisterOnSharedPreferenceChangeListener(this);

        if (mStopServiceOnFinish) {
            stopService(TSIntent);
        }
        mTermService = null;
        mTSConnection = null;
        if (mWakeLock.isHeld()) {
            mWakeLock.release();
        }
        if (mWifiLock.isHeld()) {
            mWifiLock.release();
        }
    }

    private void restart() {
        startActivity(getIntent());
        finish();
    }

    protected static TermSession createTermSession(Context context, TermSettings settings, String initialCommand) throws IOException {
        GenericTermSession session = new ShellTermSession(settings, initialCommand);
        // XXX We should really be able to fetch this from within TermSession
        session.setProcessExitMessage(context.getString(R.string.process_exit_message));

        return session;
    }

    private TermSession createTermSession() throws IOException {
        TermSettings settings = mSettings;
        TermSession session = createTermSession(this, settings, settings.getInitialCommand());
        session.setFinishCallback(mTermService);
        return session;
    }

    private TermView createEmulatorView(TermSession session) {
        DisplayMetrics metrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(metrics);
        TermView emulatorView = new TermView(this, session, metrics);

        emulatorView.setExtGestureListener(new EmulatorViewGestureListener(emulatorView));
        emulatorView.setOnKeyListener(mKeyListener);
        registerForContextMenu(emulatorView);

        return emulatorView;
    }

    private TermSession getCurrentTermSession() {
        SessionList sessions = mTermSessions;
        if (sessions == null) {
            return null;
        } else {
            return sessions.get(mViewFlipper.getDisplayedChild());
        }
    }

    private EmulatorView getCurrentEmulatorView() {
        return (EmulatorView) mViewFlipper.getCurrentView();
    }

    private void updatePrefs() {
        mUseKeyboardShortcuts = mSettings.getUseKeyboardShortcutsFlag();

        DisplayMetrics metrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(metrics);

        mViewFlipper.updatePrefs(mSettings);

        for (View v : mViewFlipper) {
            ((EmulatorView) v).setDensity(metrics);
            ((TermView) v).updatePrefs(mSettings);
        }

        if (mTermSessions != null) {
            for (TermSession session : mTermSessions) {
                ((GenericTermSession) session).updatePrefs(mSettings);
            }
        }

        {
            Window win = getWindow();
            WindowManager.LayoutParams params = win.getAttributes();
            final int FULLSCREEN = WindowManager.LayoutParams.FLAG_FULLSCREEN;
            int desiredFlag = mSettings.showStatusBar() ? 0 : FULLSCREEN;
            if (desiredFlag != (params.flags & FULLSCREEN) || (AndroidCompat.SDK >= 11 && mActionBarMode != mSettings.actionBarMode())) {
                if (mAlreadyStarted) {
                    // Can't switch to/from fullscreen after
                    // starting the activity.
                    restart();
                } else {
                    win.setFlags(desiredFlag, FULLSCREEN);
                    if (mActionBarMode == TermSettings.ACTION_BAR_MODE_HIDES) {
                        if (mActionBar != null) {
                            mActionBar.hide();
                        }
                    }
                }
            }
        }

        int orientation = mSettings.getScreenOrientation();
        int o = 0;
        if (orientation == 0) {
            o = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
        } else if (orientation == 1) {
            o = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
        } else if (orientation == 2) {
            o = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
        } else {
            /* Shouldn't be happened. */
        }
        setRequestedOrientation(o);
    }

    @Override
    public void onPause() {
        super.onPause();

        if (AndroidCompat.SDK < 5) {
            /* If we lose focus between a back key down and a back key up,
               we shouldn't respond to the next back key up event unless
               we get another key down first */
            mBackKeyPressed = false;
        }

        /* Explicitly close the input method
           Otherwise, the soft keyboard could cover up whatever activity takes
           our place */
        final IBinder token = mViewFlipper.getWindowToken();
        new Thread() {
            @Override
            public void run() {
                InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
                imm.hideSoftInputFromWindow(token, 0);
            }
        }.start();
    }

    @Override
    protected void onStop() {
        mViewFlipper.onPause();
        if (mTermSessions != null) {
            mTermSessions.removeCallback(this);

            if (mWinListAdapter != null) {
                mTermSessions.removeCallback(mWinListAdapter);
                mTermSessions.removeTitleChangedListener(mWinListAdapter);
                mViewFlipper.removeCallback(mWinListAdapter);
            }
        }

        mViewFlipper.removeAllViews();

        unbindService(mTSConnection);

        super.onStop();
    }

    private boolean checkHaveFullHwKeyboard(Configuration c) {
        return (c.keyboard == Configuration.KEYBOARD_QWERTY) &&
            (c.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);

        mHaveFullHwKeyboard = checkHaveFullHwKeyboard(newConfig);

        EmulatorView v = (EmulatorView) mViewFlipper.getCurrentView();
        if (v != null) {
            v.updateSize(false);
        }

        if (mWinListAdapter != null) {
            // Force Android to redraw the label in the navigation dropdown
            mWinListAdapter.notifyDataSetChanged();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main, menu);
        MenuItemCompat.setShowAsAction(menu.findItem(R.id.menu_new_window), MenuItemCompat.SHOW_AS_ACTION_ALWAYS);
        MenuItemCompat.setShowAsAction(menu.findItem(R.id.menu_close_window), MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        if (id == R.id.menu_preferences) {
            doPreferences();
        } else if (id == R.id.menu_new_window) {
            doCreateNewWindow();
        } else if (id == R.id.menu_close_window) {
            confirmCloseWindow();
        } else if (id == R.id.menu_window_list) {
            startActivityForResult(new Intent(this, WindowList.class), REQUEST_CHOOSE_WINDOW);
        } else if (id == R.id.menu_reset) {
            doResetTerminal();
            Toast toast = Toast.makeText(this,R.string.reset_toast_notification,Toast.LENGTH_LONG);
            toast.setGravity(Gravity.CENTER, 0, 0);
            toast.show();
        } else if (id == R.id.menu_send_email) {
            doEmailTranscript();
        } else if (id == R.id.menu_special_keys) {
            doDocumentKeys();
        } else if (id == R.id.menu_toggle_soft_keyboard) {
            doToggleSoftKeyboard();
        } else if (id == R.id.menu_toggle_wakelock) {
            doToggleWakeLock();
        } else if (id == R.id.menu_toggle_wifilock) {
            doToggleWifiLock();
        } else if  (id == R.id.action_help) {
                Intent openHelp = new Intent(Intent.ACTION_VIEW,
                Uri.parse(getString(R.string.help_url)));
                startActivity(openHelp);
        }
        // Hide the action bar if appropriate
        if (mActionBarMode == TermSettings.ACTION_BAR_MODE_HIDES) {
            mActionBar.hide();
        }
        return super.onOptionsItemSelected(item);
    }

    private void doCreateNewWindow() {
        if (mTermSessions == null) {
            Log.w(TermDebug.LOG_TAG, "Couldn't create new window because mTermSessions == null");
            return;
        }

        try {
            TermSession session = createTermSession();

            mTermSessions.add(session);

            TermView view = createEmulatorView(session);
            view.updatePrefs(mSettings);

            mViewFlipper.addView(view);
            mViewFlipper.setDisplayedChild(mViewFlipper.getChildCount()-1);
        } catch (IOException e) {
            Toast.makeText(this, "Failed to create a session", Toast.LENGTH_SHORT).show();
        }
    }

    private void confirmCloseWindow() {
        final AlertDialog.Builder b = new AlertDialog.Builder(this);
        b.setIcon(android.R.drawable.ic_dialog_alert);
        b.setMessage(R.string.confirm_window_close_message);
        final Runnable closeWindow = new Runnable() {
            public void run() {
                doCloseWindow();
            }
        };
        b.setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
           public void onClick(DialogInterface dialog, int id) {
               dialog.dismiss();
               mHandler.post(closeWindow);
           }
        });
        b.setNegativeButton(android.R.string.no, null);
        b.show();
    }

    private void doCloseWindow() {
        if (mTermSessions == null) {
            return;
        }

        EmulatorView view = getCurrentEmulatorView();
        if (view == null) {
            return;
        }
        TermSession session = mTermSessions.remove(mViewFlipper.getDisplayedChild());
        view.onPause();
        session.finish();
        mViewFlipper.removeView(view);
        if (mTermSessions.size() != 0) {
            mViewFlipper.showNext();
        }
    }

    @Override
    protected void onActivityResult(int request, int result, Intent data) {
        switch (request) {
        case REQUEST_CHOOSE_WINDOW:
            if (result == RESULT_OK && data != null) {
                int position = data.getIntExtra(EXTRA_WINDOW_ID, -2);
                if (position >= 0) {
                    // Switch windows after session list is in sync, not here
                    onResumeSelectWindow = position;
                } else if (position == -1) {
                    doCreateNewWindow();
                    onResumeSelectWindow = mTermSessions.size() - 1;
                }
            } else {
                // Close the activity if user closed all sessions
                // TODO the left path will be invoked when nothing happened, but this Activity was destroyed!
                if (mTermSessions == null || mTermSessions.size() == 0) {
                    mStopServiceOnFinish = true;
                    finish();
                }
            }
            break;
        }
    }

    @Override
    protected void onNewIntent(Intent intent) {
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) != 0) {
            // Don't repeat action if intent comes from history
            return;
        }

        String action = intent.getAction();
        if (TextUtils.isEmpty(action) || !mPrivateAlias.equals(intent.getComponent())) {
            return;
        }

        // huge number simply opens new window
        // TODO: add a way to restrict max number of windows per caller (possibly via reusing BoundSession)
        switch (action) {
            case RemoteInterface.PRIVACT_OPEN_NEW_WINDOW:
                onResumeSelectWindow = Integer.MAX_VALUE;
                break;
            case RemoteInterface.PRIVACT_SWITCH_WINDOW:
                int target = intent.getIntExtra(RemoteInterface.PRIVEXTRA_TARGET_WINDOW, -1);
                if (target >= 0) {
                    onResumeSelectWindow = target;
                }
                break;
        }
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        MenuItem wakeLockItem = menu.findItem(R.id.menu_toggle_wakelock);
        MenuItem wifiLockItem = menu.findItem(R.id.menu_toggle_wifilock);
        if (mWakeLock.isHeld()) {
            wakeLockItem.setTitle(R.string.disable_wakelock);
        } else {
            wakeLockItem.setTitle(R.string.enable_wakelock);
        }
        if (mWifiLock.isHeld()) {
            wifiLockItem.setTitle(R.string.disable_wifilock);
        } else {
            wifiLockItem.setTitle(R.string.enable_wifilock);
        }
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
            ContextMenuInfo menuInfo) {
      super.onCreateContextMenu(menu, v, menuInfo);
      menu.setHeaderTitle(R.string.edit_text);
      menu.add(0, SELECT_TEXT_ID, 0, R.string.select_text);
      menu.add(0, COPY_ALL_ID, 0, R.string.copy_all);
      menu.add(0, PASTE_ID, 0, R.string.paste);
      menu.add(0, SEND_CONTROL_KEY_ID, 0, R.string.send_control_key);
      menu.add(0, SEND_FN_KEY_ID, 0, R.string.send_fn_key);
      if (!canPaste()) {
          menu.getItem(PASTE_ID).setEnabled(false);
      }
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
          switch (item.getItemId()) {
          case SELECT_TEXT_ID:
            getCurrentEmulatorView().toggleSelectingText();
            return true;
          case COPY_ALL_ID:
            doCopyAll();
            return true;
          case PASTE_ID:
            doPaste();
            return true;
          case SEND_CONTROL_KEY_ID:
            doSendControlKey();
            return true;
          case SEND_FN_KEY_ID:
            doSendFnKey();
            return true;
          default:
            return super.onContextItemSelected(item);
          }
        }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        /* The pre-Eclair default implementation of onKeyDown() would prevent
           our handling of the Back key in onKeyUp() from taking effect, so
           ignore it here */
        if (AndroidCompat.SDK < 5 && keyCode == KeyEvent.KEYCODE_BACK) {
            /* Android pre-Eclair has no key event tracking, and a back key
               down event delivered to an activity above us in the back stack
               could be succeeded by a back key up event to us, so we need to
               keep track of our own back key presses */
            mBackKeyPressed = true;
            return true;
        } else {
            return super.onKeyDown(keyCode, event);
        }
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        switch (keyCode) {
        case KeyEvent.KEYCODE_BACK:
            if (AndroidCompat.SDK < 5) {
                if (!mBackKeyPressed) {
                    /* This key up event might correspond to a key down
                       delivered to another activity -- ignore */
                    return false;
                }
                mBackKeyPressed = false;
            }
            if (mActionBarMode == TermSettings.ACTION_BAR_MODE_HIDES && mActionBar != null && mActionBar.isShowing()) {
                mActionBar.hide();
                return true;
            }
            switch (mSettings.getBackKeyAction()) {
            case TermSettings.BACK_KEY_STOPS_SERVICE:
                mStopServiceOnFinish = true;
            case TermSettings.BACK_KEY_CLOSES_ACTIVITY:
                finish();
                return true;
            case TermSettings.BACK_KEY_CLOSES_WINDOW:
                doCloseWindow();
                return true;
            default:
                return false;
            }
        case KeyEvent.KEYCODE_MENU:
            if (mActionBar != null && !mActionBar.isShowing()) {
                mActionBar.show();
                return true;
            } else {
                return super.onKeyUp(keyCode, event);
            }
        default:
            return super.onKeyUp(keyCode, event);
        }
    }

    // Called when the list of sessions changes
    public void onUpdate() {
        SessionList sessions = mTermSessions;
        if (sessions == null) {
            return;
        }

        if (sessions.size() == 0) {
            mStopServiceOnFinish = true;
            finish();
        } else if (sessions.size() < mViewFlipper.getChildCount()) {
            for (int i = 0; i < mViewFlipper.getChildCount(); ++i) {
                EmulatorView v = (EmulatorView) mViewFlipper.getChildAt(i);
                if (!sessions.contains(v.getTermSession())) {
                    v.onPause();
                    mViewFlipper.removeView(v);
                    --i;
                }
            }
        }
    }

    private boolean canPaste() {
        ClipboardManagerCompat clip = ClipboardManagerCompatFactory
                .getManager(getApplicationContext());
        if (clip.hasText()) {
            return true;
        }
        return false;
    }

    private void doPreferences() {
        startActivity(new Intent(this, TermPreferences.class));
    }

    private void doResetTerminal() {
        TermSession session = getCurrentTermSession();
        if (session != null) {
            session.reset();
        }
    }

    private void doEmailTranscript() {
        TermSession session = getCurrentTermSession();
        if (session != null) {
            // Don't really want to supply an address, but
            // currently it's required, otherwise nobody
            // wants to handle the intent.
            String addr = "user@example.com";
            Intent intent =
                    new Intent(Intent.ACTION_SENDTO, Uri.parse("mailto:"
                            + addr));

            String subject = getString(R.string.email_transcript_subject);
            String title = session.getTitle();
            if (title != null) {
                subject = subject + " - " + title;
            }
            intent.putExtra(Intent.EXTRA_SUBJECT, subject);
            intent.putExtra(Intent.EXTRA_TEXT,
                    session.getTranscriptText().trim());
            try {
                startActivity(Intent.createChooser(intent,
                        getString(R.string.email_transcript_chooser_title)));
            } catch (ActivityNotFoundException e) {
                Toast.makeText(this,
                        R.string.email_transcript_no_email_activity_found,
                        Toast.LENGTH_LONG).show();
            }
        }
    }

    private void doCopyAll() {
        ClipboardManagerCompat clip = ClipboardManagerCompatFactory
                .getManager(getApplicationContext());
        clip.setText(getCurrentTermSession().getTranscriptText().trim());
    }

    private void doPaste() {
        if (!canPaste()) {
            return;
        }
        ClipboardManagerCompat clip = ClipboardManagerCompatFactory
                .getManager(getApplicationContext());
        CharSequence paste = clip.getText();
        getCurrentTermSession().write(paste.toString());
    }

    private void doSendControlKey() {
        getCurrentEmulatorView().sendControlKey();
    }

    private void doSendFnKey() {
        getCurrentEmulatorView().sendFnKey();
    }

    private void doDocumentKeys() {
        AlertDialog.Builder dialog = new AlertDialog.Builder(this);
        Resources r = getResources();
        dialog.setTitle(r.getString(R.string.control_key_dialog_title));
        dialog.setMessage(
            formatMessage(mSettings.getControlKeyId(), TermSettings.CONTROL_KEY_ID_NONE,
                r, R.array.control_keys_short_names,
                R.string.control_key_dialog_control_text,
                R.string.control_key_dialog_control_disabled_text, "CTRLKEY")
            + "\n\n" +
            formatMessage(mSettings.getFnKeyId(), TermSettings.FN_KEY_ID_NONE,
                r, R.array.fn_keys_short_names,
                R.string.control_key_dialog_fn_text,
                R.string.control_key_dialog_fn_disabled_text, "FNKEY"));
         dialog.show();
     }

     private String formatMessage(int keyId, int disabledKeyId,
         Resources r, int arrayId,
         int enabledId,
         int disabledId, String regex) {
         if (keyId == disabledKeyId) {
             return r.getString(disabledId);
         }
         String[] keyNames = r.getStringArray(arrayId);
         String keyName = keyNames[keyId];
         String template = r.getString(enabledId);
         String result = template.replaceAll(regex, keyName);
         return result;
    }

    private void doToggleSoftKeyboard() {
        InputMethodManager imm = (InputMethodManager)
            getSystemService(Context.INPUT_METHOD_SERVICE);
        imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);

    }

    private void doToggleWakeLock() {
        if (mWakeLock.isHeld()) {
            mWakeLock.release();
        } else {
            mWakeLock.acquire();
        }
        ActivityCompat.invalidateOptionsMenu(this);
    }

    private void doToggleWifiLock() {
        if (mWifiLock.isHeld()) {
            mWifiLock.release();
        } else {
            mWifiLock.acquire();
        }
        ActivityCompat.invalidateOptionsMenu(this);
    }

    private void doToggleActionBar() {
        ActionBarCompat bar = mActionBar;
        if (bar == null) {
            return;
        }
        if (bar.isShowing()) {
            bar.hide();
        } else {
            bar.show();
        }
    }

    private void doUIToggle(int x, int y, int width, int height) {
        switch (mActionBarMode) {
        case TermSettings.ACTION_BAR_MODE_NONE:
            if (AndroidCompat.SDK >= 11 && (mHaveFullHwKeyboard || y < height / 2)) {
                openOptionsMenu();
                return;
            } else {
                doToggleSoftKeyboard();
            }
            break;
        case TermSettings.ACTION_BAR_MODE_ALWAYS_VISIBLE:
            if (!mHaveFullHwKeyboard) {
                doToggleSoftKeyboard();
            }
            break;
        case TermSettings.ACTION_BAR_MODE_HIDES:
            if (mHaveFullHwKeyboard || y < height / 2) {
                doToggleActionBar();
                return;
            } else {
                doToggleSoftKeyboard();
            }
            break;
        }
        getCurrentEmulatorView().requestFocus();
    }

    /**
     *
     * Send a URL up to Android to be handled by a browser.
     * @param link The URL to be opened.
     */
    private void execURL(String link)
    {
        Uri webLink = Uri.parse(link);
        Intent openLink = new Intent(Intent.ACTION_VIEW, webLink);
        PackageManager pm = getPackageManager();
        List<ResolveInfo> handlers = pm.queryIntentActivities(openLink, 0);
        if(handlers.size() > 0)
            startActivity(openLink);
    }
}

```

`term/src/main/java/jackpal/androidterm/TermDebug.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

/**
 * Debug settings.
 */

public class TermDebug {
    /**
     * Set to true to add debugging code and logging.
     */
    public static final boolean DEBUG = false;

    /**
     * The tag we use when logging, so that our messages can be distinguished
     * from other messages in the log. Public because it's used by several
     * classes.
     */
    public static final String LOG_TAG = "Term";
}

```

`term/src/main/java/jackpal/androidterm/TermPreferences.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import jackpal.androidterm.compat.ActionBarCompat;
import jackpal.androidterm.compat.ActivityCompat;
import jackpal.androidterm.compat.AndroidCompat;
import android.os.Bundle;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.preference.PreferenceCategory;
import android.view.MenuItem;

public class TermPreferences extends PreferenceActivity {
    private static final String ACTIONBAR_KEY = "actionbar";
    private static final String CATEGORY_SCREEN_KEY = "screen";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Load the preferences from an XML resource
        addPreferencesFromResource(R.xml.preferences);

        // Remove the action bar pref on older platforms without an action bar
        if (AndroidCompat.SDK < 11) {
            Preference actionBarPref = findPreference(ACTIONBAR_KEY);
             PreferenceCategory screenCategory =
                    (PreferenceCategory) findPreference(CATEGORY_SCREEN_KEY);
             if ((actionBarPref != null) && (screenCategory != null)) {
                 screenCategory.removePreference(actionBarPref);
             }
        }

        // Display up indicator on action bar home button
        if (AndroidCompat.V11ToV20) {
            ActionBarCompat bar = ActivityCompat.getActionBar(this);
            if (bar != null) {
                bar.setDisplayOptions(ActionBarCompat.DISPLAY_HOME_AS_UP, ActionBarCompat.DISPLAY_HOME_AS_UP);
            }
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case ActionBarCompat.ID_HOME:
            // Action bar home button selected
            finish();
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/TermService.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import android.app.Service;
import android.content.IntentSender;
import android.content.SharedPreferences;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.*;
import android.content.Intent;
import android.preference.PreferenceManager;
import android.text.TextUtils;
import android.util.Log;
import android.app.Notification;
import android.app.PendingIntent;

import jackpal.androidterm.emulatorview.TermSession;

import jackpal.androidterm.compat.ServiceForegroundCompat;
import jackpal.androidterm.libtermexec.v1.*;
import jackpal.androidterm.util.SessionList;
import jackpal.androidterm.util.TermSettings;

import java.util.UUID;

public class TermService extends Service implements TermSession.FinishCallback
{
    /* Parallels the value of START_STICKY on API Level >= 5 */
    private static final int COMPAT_START_STICKY = 1;

    private static final int RUNNING_NOTIFICATION = 1;
    private ServiceForegroundCompat compat;

    private SessionList mTermSessions;

    public class TSBinder extends Binder {
        TermService getService() {
            Log.i("TermService", "Activity binding to service");
            return TermService.this;
        }
    }
    private final IBinder mTSBinder = new TSBinder();

    @Override
    public void onStart(Intent intent, int flags) {
    }

    /* This should be @Override if building with API Level >=5 */
    public int onStartCommand(Intent intent, int flags, int startId) {
        return COMPAT_START_STICKY;
    }

    @Override
    public IBinder onBind(Intent intent) {
        if (TermExec.SERVICE_ACTION_V1.equals(intent.getAction())) {
            Log.i("TermService", "Outside process called onBind()");

            return new RBinder();
        } else {
            Log.i("TermService", "Activity called onBind()");

            return mTSBinder;
        }
    }

    @Override
    public void onCreate() {
        // should really belong to the Application class, but we don't use one...
        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
        SharedPreferences.Editor editor = prefs.edit();
        String defValue = getDir("HOME", MODE_PRIVATE).getAbsolutePath();
        String homePath = prefs.getString("home_path", defValue);
        editor.putString("home_path", homePath);
        editor.commit();

        compat = new ServiceForegroundCompat(this);
        mTermSessions = new SessionList();

        /* Put the service in the foreground. */
        Notification notification = new Notification(R.drawable.ic_stat_service_notification_icon, getText(R.string.service_notify_text), System.currentTimeMillis());
        notification.flags |= Notification.FLAG_ONGOING_EVENT;
        Intent notifyIntent = new Intent(this, Term.class);
        notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);
        notification.setLatestEventInfo(this, getText(R.string.application_terminal), getText(R.string.service_notify_text), pendingIntent);
        compat.startForeground(RUNNING_NOTIFICATION, notification);

        Log.d(TermDebug.LOG_TAG, "TermService started");
        return;
    }

    @Override
    public void onDestroy() {
        compat.stopForeground(true);
        for (TermSession session : mTermSessions) {
            /* Don't automatically remove from list of sessions -- we clear the
             * list below anyway and we could trigger
             * ConcurrentModificationException if we do */
            session.setFinishCallback(null);
            session.finish();
        }
        mTermSessions.clear();
        return;
    }

    public SessionList getSessions() {
        return mTermSessions;
    }

    public void onSessionFinish(TermSession session) {
        mTermSessions.remove(session);
    }

    private final class RBinder extends ITerminal.Stub {
        @Override
        public IntentSender startSession(final ParcelFileDescriptor pseudoTerminalMultiplexerFd,
                                         final ResultReceiver callback) {
            final String sessionHandle = UUID.randomUUID().toString();

            // distinct Intent Uri and PendingIntent requestCode must be sufficient to avoid collisions
            final Intent switchIntent = new Intent(RemoteInterface.PRIVACT_OPEN_NEW_WINDOW)
                    .setData(Uri.parse(sessionHandle))
                    .addCategory(Intent.CATEGORY_DEFAULT)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    .putExtra(RemoteInterface.PRIVEXTRA_TARGET_WINDOW, sessionHandle);

            final PendingIntent result = PendingIntent.getActivity(getApplicationContext(), sessionHandle.hashCode(),
                    switchIntent, 0);

            final PackageManager pm = getPackageManager();
            final String[] pkgs = pm.getPackagesForUid(getCallingUid());
            if (pkgs == null || pkgs.length == 0)
                return null;

            for (String packageName:pkgs) {
                try {
                    final PackageInfo pkgInfo = pm.getPackageInfo(packageName, 0);

                    final ApplicationInfo appInfo = pkgInfo.applicationInfo;
                    if (appInfo == null)
                        continue;

                    final CharSequence label = pm.getApplicationLabel(appInfo);

                    if (!TextUtils.isEmpty(label)) {
                        final String niceName = label.toString();

                        new Handler(Looper.getMainLooper()).post(new Runnable() {
                            @Override
                            public void run() {
                                GenericTermSession session = null;
                                try {
                                    final TermSettings settings = new TermSettings(getResources(),
                                            PreferenceManager.getDefaultSharedPreferences(getApplicationContext()));

                                    session = new BoundSession(pseudoTerminalMultiplexerFd, settings, niceName);

                                    mTermSessions.add(session);

                                    session.setHandle(sessionHandle);
                                    session.setFinishCallback(new RBinderCleanupCallback(result, callback));
                                    session.setTitle("");

                                    session.initializeEmulator(80, 24);
                                } catch (Exception whatWentWrong) {
                                    Log.e("TermService", "Failed to bootstrap AIDL session: "
                                            + whatWentWrong.getMessage());

                                    if (session != null)
                                        session.finish();
                                }
                            }
                        });

                        return result.getIntentSender();
                    }
                } catch (PackageManager.NameNotFoundException ignore) {}
            }

            return null;
        }
    }

    private final class RBinderCleanupCallback implements TermSession.FinishCallback {
        private final PendingIntent result;
        private final ResultReceiver callback;

        public RBinderCleanupCallback(PendingIntent result, ResultReceiver callback) {
            this.result = result;
            this.callback = callback;
        }

        @Override
        public void onSessionFinish(TermSession session) {
            result.cancel();

            callback.send(0, new Bundle());

            mTermSessions.remove(session);
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/TermView.java`:

```java
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import android.content.Context;
import android.util.DisplayMetrics;

import jackpal.androidterm.emulatorview.ColorScheme;
import jackpal.androidterm.emulatorview.EmulatorView;
import jackpal.androidterm.emulatorview.TermSession;

import jackpal.androidterm.util.TermSettings;

public class TermView extends EmulatorView {
    public TermView(Context context, TermSession session, DisplayMetrics metrics) {
        super(context, session, metrics);
    }

    public void updatePrefs(TermSettings settings, ColorScheme scheme) {
        if (scheme == null) {
            scheme = new ColorScheme(settings.getColorScheme());
        }

        setTextSize(settings.getFontSize());
        setUseCookedIME(settings.useCookedIME());
        setColorScheme(scheme);
        setBackKeyCharacter(settings.getBackKeyCharacter());
        setAltSendsEsc(settings.getAltSendsEscFlag());
        setControlKeyCode(settings.getControlKeyCode());
        setFnKeyCode(settings.getFnKeyCode());
        setTermType(settings.getTermType());
        setMouseTracking(settings.getMouseTrackingFlag());
    }

    public void updatePrefs(TermSettings settings) {
        updatePrefs(settings, null);
    }

    @Override
    public String toString() {
        return getClass().toString() + '(' + getTermSession() + ')';
    }
}

```

`term/src/main/java/jackpal/androidterm/TermViewFlipper.java`:

```java
/*
 * Copyright (C) 2011 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import java.util.Iterator;
import java.util.LinkedList;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.os.Handler;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.widget.Toast;
import android.widget.ViewFlipper;

import jackpal.androidterm.emulatorview.EmulatorView;
import jackpal.androidterm.emulatorview.TermSession;
import jackpal.androidterm.emulatorview.UpdateCallback;

import jackpal.androidterm.compat.AndroidCompat;
import jackpal.androidterm.util.TermSettings;

public class TermViewFlipper extends ViewFlipper implements Iterable<View> {
    private Context context;
    private Toast mToast;
    private LinkedList<UpdateCallback> callbacks;
    private boolean mStatusBarVisible = false;

    private int mCurWidth;
    private int mCurHeight;
    private Rect mVisibleRect = new Rect();
    private Rect mWindowRect = new Rect();
    private LayoutParams mChildParams = null;
    private boolean mRedoLayout = false;

    /**
     * True if we must poll to discover if the view has changed size.
     * This is the only known way to detect the view changing size due to
     * the IME being shown or hidden in API level <= 7.
     */
    private final boolean mbPollForWindowSizeChange = (AndroidCompat.SDK < 8);
    private static final int SCREEN_CHECK_PERIOD = 1000;
    private final Handler mHandler = new Handler();
    private Runnable mCheckSize = new Runnable() {
            public void run() {
                adjustChildSize();
                mHandler.postDelayed(this, SCREEN_CHECK_PERIOD);
            }
        };

    class ViewFlipperIterator implements Iterator<View> {
        int pos = 0;

        public boolean hasNext() {
            return (pos < getChildCount());
        }

        public View next() {
            return getChildAt(pos++);
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    public TermViewFlipper(Context context) {
        super(context);
        commonConstructor(context);
    }

    public TermViewFlipper(Context context, AttributeSet attrs) {
        super(context, attrs);
        commonConstructor(context);
    }

    private void commonConstructor(Context context) {
        this.context = context;
        callbacks = new LinkedList<UpdateCallback>();

        updateVisibleRect();
        Rect visible = mVisibleRect;
        mChildParams = new LayoutParams(visible.width(), visible.height(),
            Gravity.TOP|Gravity.LEFT);
    }

    public void updatePrefs(TermSettings settings) {
        boolean statusBarVisible = settings.showStatusBar();
        int[] colorScheme = settings.getColorScheme();
        setBackgroundColor(colorScheme[1]);
        mStatusBarVisible = statusBarVisible;
    }

    public Iterator<View> iterator() {
        return new ViewFlipperIterator();
    }

    public void addCallback(UpdateCallback callback) {
        callbacks.add(callback);
    }

    public void removeCallback(UpdateCallback callback) {
        callbacks.remove(callback);
    }

    private void notifyChange() {
        for (UpdateCallback callback : callbacks) {
            callback.onUpdate();
        }
    }

    public void onPause() {
        if (mbPollForWindowSizeChange) {
            mHandler.removeCallbacks(mCheckSize);
        }
        pauseCurrentView();
    }

    public void onResume() {
        if (mbPollForWindowSizeChange) {
            mCheckSize.run();
        }
        resumeCurrentView();
    }

    public void pauseCurrentView() {
        EmulatorView view = (EmulatorView) getCurrentView();
        if (view == null) {
            return;
        }
        view.onPause();
    }

    public void resumeCurrentView() {
        EmulatorView view = (EmulatorView) getCurrentView();
        if (view == null) {
            return;
        }
        view.onResume();
        view.requestFocus();
    }

    private void showTitle() {
        if (getChildCount() == 0) {
            return;
        }

        EmulatorView view = (EmulatorView) getCurrentView();
        if (view == null) {
            return;
        }
        TermSession session = view.getTermSession();
        if (session == null) {
            return;
        }

        String title = context.getString(R.string.window_title,getDisplayedChild()+1);
        if (session instanceof GenericTermSession) {
            title = ((GenericTermSession) session).getTitle(title);
        }

        if (mToast == null) {
            mToast = Toast.makeText(context, title, Toast.LENGTH_SHORT);
            mToast.setGravity(Gravity.CENTER, 0, 0);
        } else {
            mToast.setText(title);
        }
        mToast.show();
    }

    @Override
    public void showPrevious() {
        pauseCurrentView();
        super.showPrevious();
        showTitle();
        resumeCurrentView();
        notifyChange();
    }

    @Override
    public void showNext() {
        pauseCurrentView();
        super.showNext();
        showTitle();
        resumeCurrentView();
        notifyChange();
    }

    @Override
    public void setDisplayedChild(int position) {
        pauseCurrentView();
        super.setDisplayedChild(position);
        showTitle();
        resumeCurrentView();
        notifyChange();
    }

    @Override
    public void addView(View v, int index) {
        super.addView(v, index, mChildParams);
    }

    @Override
    public void addView(View v) {
        super.addView(v, mChildParams);
    }

    private void updateVisibleRect() {
        Rect visible = mVisibleRect;
        Rect window = mWindowRect;

        /* Get rectangle representing visible area of this view, as seen by
           the activity (takes other views in the layout into account, but
           not space used by the IME) */
        getGlobalVisibleRect(visible);

        /* Get rectangle representing visible area of this window (takes
           IME into account, but not other views in the layout) */
        getWindowVisibleDisplayFrame(window);
        /* Work around bug in getWindowVisibleDisplayFrame on API < 10, and
           avoid a distracting height change as status bar hides otherwise */
        if (!mStatusBarVisible) {
            window.top = 0;
        }

        // Clip visible rectangle's top to the visible portion of the window
        if (visible.width() == 0 && visible.height() == 0) {
            visible.left = window.left;
            visible.top = window.top;
        } else {
            if (visible.left < window.left) {
                visible.left = window.left;
            }
            if (visible.top < window.top) {
                visible.top = window.top;
            }
        }
        // Always set the bottom of the rectangle to the window bottom
        /* XXX This breaks with a split action bar, but if we don't do this,
           it's possible that the view won't resize correctly on IME hide */
        visible.right = window.right;
        visible.bottom = window.bottom;
    }

    private void adjustChildSize() {
        updateVisibleRect();
        Rect visible = mVisibleRect;
        int width = visible.width();
        int height = visible.height();

        if (mCurWidth != width || mCurHeight != height) {
            mCurWidth = width;
            mCurHeight = height;

            LayoutParams params = mChildParams;
            params.width = width;
            params.height = height;
            for (View v : this) {
                updateViewLayout(v, params);
            }
            mRedoLayout = true;

            EmulatorView currentView = (EmulatorView) getCurrentView();
            if (currentView != null) {
                currentView.updateSize(false);
            }
        }
    }

    /**
     * Called when the view changes size.
     * (Note: Not always called on Android < 2.2)
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        adjustChildSize();
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (mRedoLayout) {
            requestLayout();
            mRedoLayout = false;
        }
        super.onDraw(canvas);
    }
}

```

`term/src/main/java/jackpal/androidterm/WindowList.java`:

```java
/*
 * Copyright (C) 2011 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import android.app.ListActivity;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MenuItem;
import android.view.View;
import android.widget.ImageView;
import android.widget.ListView;

import jackpal.androidterm.compat.ActionBarCompat;
import jackpal.androidterm.compat.ActivityCompat;
import jackpal.androidterm.compat.AndroidCompat;
import jackpal.androidterm.util.SessionList;

public class WindowList extends ListActivity {
    private SessionList sessions;
    private WindowListAdapter mWindowListAdapter;
    private TermService mTermService;

    /**
     * View which isn't automatically in the pressed state if its parent is
     * pressed.  This allows the window's entry to be pressed without the close
     * button being triggered.
     * Idea and code shamelessly borrowed from the Android browser's tabs list.
     *
     * Used by layout xml.
     */
    public static class CloseButton extends ImageView {
        public CloseButton(Context context) {
            super(context);
        }

        public CloseButton(Context context, AttributeSet attrs) {
            super(context, attrs);
        }

        public CloseButton(Context context, AttributeSet attrs, int style) {
            super(context, attrs, style);
        }

        @Override
        public void setPressed(boolean pressed) {
            if (pressed && ((View) getParent()).isPressed()) {
                return;
            }
            super.setPressed(pressed);
        }
    }

    private ServiceConnection mTSConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className, IBinder service) {
            TermService.TSBinder binder = (TermService.TSBinder) service;
            mTermService = binder.getService();
            populateList();
        }

        public void onServiceDisconnected(ComponentName arg0) {
            mTermService = null;
        }
    };

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        ListView listView = getListView();
        View newWindow = getLayoutInflater().inflate(R.layout.window_list_new_window, listView, false);
        listView.addHeaderView(newWindow, null, true);

        setResult(RESULT_CANCELED);

        // Display up indicator on action bar home button
        if (AndroidCompat.SDK >= 11) {
            ActionBarCompat bar = ActivityCompat.getActionBar(this);
            if (bar != null) {
                bar.setDisplayOptions(ActionBarCompat.DISPLAY_HOME_AS_UP, ActionBarCompat.DISPLAY_HOME_AS_UP);
            }
        }
    }

    @Override
    protected void onResume() {
        super.onResume();

        Intent TSIntent = new Intent(this, TermService.class);
        if (!bindService(TSIntent, mTSConnection, BIND_AUTO_CREATE)) {
            Log.w(TermDebug.LOG_TAG, "bind to service failed!");
        }
    }

    @Override
    protected void onPause() {
        super.onPause();

        WindowListAdapter adapter = mWindowListAdapter;
        if (sessions != null) {
            sessions.removeCallback(adapter);
            sessions.removeTitleChangedListener(adapter);
        }
        if (adapter != null) {
            adapter.setSessions(null);
        }
        unbindService(mTSConnection);
    }

    private void populateList() {
        sessions = mTermService.getSessions();
        WindowListAdapter adapter = mWindowListAdapter;

        if (adapter == null) {
            adapter = new WindowListAdapter(sessions);
            setListAdapter(adapter);
            mWindowListAdapter = adapter;
        } else {
            adapter.setSessions(sessions);
        }
        sessions.addCallback(adapter);
        sessions.addTitleChangedListener(adapter);
    }

    @Override
    protected void onListItemClick(ListView l, View v, int position, long id) {
        Intent data = new Intent();
        data.putExtra(Term.EXTRA_WINDOW_ID, position-1);
        setResult(RESULT_OK, data);
        finish();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case ActionBarCompat.ID_HOME:
            // Action bar home button selected
            finish();
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/WindowListAdapter.java`:

```java
/*
 * Copyright (C) 2011 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm;

import android.app.Activity;
import android.content.Context;
import android.content.ContextWrapper;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.TextView;

import jackpal.androidterm.emulatorview.TermSession;
import jackpal.androidterm.emulatorview.UpdateCallback;

import jackpal.androidterm.util.SessionList;

public class WindowListAdapter extends BaseAdapter implements UpdateCallback {
    private SessionList mSessions;

    public WindowListAdapter(SessionList sessions) {
        setSessions(sessions);
    }

    public void setSessions(SessionList sessions) {
        mSessions = sessions;

        if (sessions != null) {
            sessions.addCallback(this);
            sessions.addTitleChangedListener(this);
        } else {
            onUpdate();
        }
    }

    public int getCount() {
        if (mSessions != null) {
            return mSessions.size();
        } else {
            return 0;
        }
    }

    public Object getItem(int position) {
        return mSessions.get(position);
    }

    public long getItemId(int position) {
        return position;
    }

    protected String getSessionTitle(int position, String defaultTitle) {
        TermSession session = mSessions.get(position);
        if (session != null && session instanceof GenericTermSession) {
            return ((GenericTermSession) session).getTitle(defaultTitle);
        } else {
            return defaultTitle;
        }
    }

    public View getView(int position, View convertView, ViewGroup parent) {
        Activity act = findActivityFromContext(parent.getContext());
        View child = act.getLayoutInflater().inflate(R.layout.window_list_item, parent, false);
        View close = child.findViewById(R.id.window_list_close);

        TextView label = (TextView) child.findViewById(R.id.window_list_label);
        String defaultTitle = act.getString(R.string.window_title, position+1);
        label.setText(getSessionTitle(position, defaultTitle));

        final SessionList sessions = mSessions;
        final int closePosition = position;
        close.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                TermSession session = sessions.remove(closePosition);
                if (session != null) {
                    session.finish();
                    notifyDataSetChanged();
                }
            }
        });

        return child;
    }

    public void onUpdate() {
        notifyDataSetChanged();
    }

    private static Activity findActivityFromContext(Context context) {
        if (context == null) {
            return null;
        } else if (context instanceof Activity) {
            return (Activity) context;
        } else if (context instanceof ContextWrapper) {
            ContextWrapper cw = (ContextWrapper) context;
            return findActivityFromContext(cw.getBaseContext());
        }
        return null;
    }
}

```

`term/src/main/java/jackpal/androidterm/compat/ActionBarCompat.java`:

```java
/*
 * Copyright (C) 2011 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.compat;

import android.app.ActionBar;
import android.widget.SpinnerAdapter;

/**
 * Provides ActionBar APIs.
 */
public abstract class ActionBarCompat {
    public static final int NAVIGATION_MODE_STANDARD = 0;
    public static final int NAVIGATION_MODE_LIST = 1;
    public static final int NAVIGATION_MODE_TABS = 2;
    public static final int DISPLAY_USE_LOGO = 1;
    public static final int DISPLAY_SHOW_HOME = 2;
    public static final int DISPLAY_HOME_AS_UP = 4;
    public static final int DISPLAY_SHOW_TITLE = 8;
    public static final int DISPLAY_SHOW_CUSTOM = 16;

    // Provides android.R.id.home from API 11 and up
    public static final int ID_HOME = 0x0102002c;

    public interface OnNavigationListener {
        public abstract boolean onNavigationItemSelected(int position, long id);
    }

    public static ActionBarCompat wrap(Object actionBar) {
        if (actionBar != null) {
            if (AndroidCompat.SDK >= 11) {
                return new ActionBarApi11OrLater(actionBar);
            }
        }
        return null;
    }

    public abstract int getDisplayOptions();
    public abstract int getHeight();
    public abstract int getNavigationItemCount();
    public abstract int getNavigationMode();
    public abstract int getSelectedNavigationIndex();
    public abstract CharSequence getTitle();
    public abstract void hide();
    public abstract boolean isShowing();
    public abstract void setDisplayOptions(int options);
    public abstract void setDisplayOptions(int options, int mask);
    public abstract void setListNavigationCallbacks(SpinnerAdapter adapter, OnNavigationListener callback);
    public abstract void setNavigationMode(int mode);
    public abstract void setSelectedNavigationItem(int position);
    public abstract void setTitle(int resId);
    public abstract void setTitle(CharSequence title);
    public abstract void show();
}

class ActionBarApi11OrLater extends ActionBarCompat {
    private ActionBar bar;

    ActionBarApi11OrLater(Object bar) {
        this.bar = (ActionBar) bar;
    }

    private ActionBar.OnNavigationListener wrapOnNavigationCallback(OnNavigationListener callback) {
        final OnNavigationListener cb = callback;
        return new ActionBar.OnNavigationListener() {
            public boolean onNavigationItemSelected(int position, long id) {
                return cb.onNavigationItemSelected(position, id);
            }
        };
    }

    public int getDisplayOptions() {
        return bar.getDisplayOptions();
    }

    public int getHeight() {
        return bar.getHeight();
    }

    public int getNavigationItemCount() {
        return bar.getNavigationItemCount();
    }

    public int getNavigationMode() {
        return bar.getNavigationMode();
    }

    public int getSelectedNavigationIndex() {
        return bar.getSelectedNavigationIndex();
    }

    public CharSequence getTitle() {
        return bar.getTitle();
    }

    public void hide() {
        bar.hide();
    }

    public boolean isShowing() {
        return bar.isShowing();
    }

    public void setDisplayOptions(int options) {
        bar.setDisplayOptions(options);
    }

    public void setDisplayOptions(int options, int mask) {
        bar.setDisplayOptions(options, mask);
    }

    public void setListNavigationCallbacks(SpinnerAdapter adapter, OnNavigationListener callback) {
        bar.setListNavigationCallbacks(adapter, wrapOnNavigationCallback(callback));
    }

    public void setNavigationMode(int mode) {
        bar.setNavigationMode(mode);
    }

    public void setSelectedNavigationItem(int position) {
        bar.setSelectedNavigationItem(position);
    }

    public void setTitle(int resId) {
        bar.setTitle(resId);
    }

    public void setTitle(CharSequence title) {
        bar.setTitle(title);
    }

    public void show() {
        bar.show();
    }
}

```

`term/src/main/java/jackpal/androidterm/compat/ActivityCompat.java`:

```java
/*
 * Copyright (C) 2011 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.compat;

import android.app.Activity;

/**
 * Compatibility class for android.app.Activity
 */
public class ActivityCompat {
    private static class Api11OrLater {
        public static void invalidateOptionsMenu(Activity activity) {
            activity.invalidateOptionsMenu();
        }

        public static Object getActionBar(Activity activity) {
            return activity.getActionBar();
        }
    }

    public static void invalidateOptionsMenu(Activity activity) {
        if (AndroidCompat.SDK >= 11) {
            Api11OrLater.invalidateOptionsMenu(activity);
        }
    }

    public static ActionBarCompat getActionBar(Activity activity) {
        if (AndroidCompat.SDK < 11) {
            return null;
        }
        return ActionBarCompat.wrap(Api11OrLater.getActionBar(activity));
    }
}

```

`term/src/main/java/jackpal/androidterm/compat/AlertDialogCompat.java`:

```java
package jackpal.androidterm.compat;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;

public class AlertDialogCompat extends AlertDialog
{
  // API 11
  public static int THEME_HOLO_TRADITIONAL=      1;
  public static int THEME_HOLO_DARK=             2;
  public static int THEME_HOLO_LIGHT=            3;
  // API 14
  public static int THEME_DEVICE_DEFAULT_DARK=   4;
  public static int THEME_DEVICE_DEFAULT_LIGHT=  5;
  ////////////////////////////////////////////////////////////
  private AlertDialogCompat(Context context)
  {
    super(context);
  }
  private AlertDialogCompat(Context context, boolean cancelable, DialogInterface.OnCancelListener cancelListener)
  {
    super(context, cancelable, cancelListener);
  }
  ////////////////////////////////////////////////////////////
  private static class Api11OrLater extends AlertDialog
  {
    public Api11OrLater(Context context, int theme)
    {
      super(context, theme);
    }
    public Api11OrLater(Context context, boolean cancelable, DialogInterface.OnCancelListener cancelListener)
    {
      super(context, cancelable, cancelListener);
    }
  }
  ////////////////////////////////////////////////////////////
  private static class Api14OrLater extends AlertDialog
  {
    public Api14OrLater(Context context, int theme)
    {
      super(context, theme);
    }
    public Api14OrLater(Context context, boolean cancelable, DialogInterface.OnCancelListener cancelListener)
    {
      super(context, cancelable, cancelListener);
    }
  }
  ////////////////////////////////////////////////////////////
  public static AlertDialog newInstance(Context context)
  {
    return(new AlertDialogCompat(context));
  }
  ////////////////////////////////////////////////////////////
  public static AlertDialog newInstance(Context context, int theme)
  {
    if(AndroidCompat.SDK >= 14)
    {
      return(new Api14OrLater(context, theme));
    }
    if(AndroidCompat.SDK >= 11)
    {
      return(new Api11OrLater(context, theme));
    }
    return(new AlertDialogCompat(context));
  }
  ////////////////////////////////////////////////////////////
  public static AlertDialog newInstance(Context context, boolean cancelable, DialogInterface.OnCancelListener cancelListener)
  {
    return(new AlertDialogCompat(context, cancelable, cancelListener));
  }
  ////////////////////////////////////////////////////////////

  public static AlertDialog.Builder newInstanceBuilder(Context context, int theme) {
    if (AndroidCompat.SDK >= 11) {
      return new Api11OrLaterBuilder(context, theme);
    } else {
      return new AlertDialog.Builder(context);
    }
  }
  private static class Api11OrLaterBuilder extends AlertDialog.Builder {
    public Api11OrLaterBuilder(Context context) {
      super(context);
    }
    public Api11OrLaterBuilder(Context context, int theme) {
      super(context, theme);
    }
  }
}

```

`term/src/main/java/jackpal/androidterm/compat/AndroidCompat.java`:

```java
package jackpal.androidterm.compat;

/**
 * The classes in this package take advantage of the fact that the VM does
 * not attempt to load a class until it's accessed, and the verifier
 * does not run until a class is loaded.  By keeping the methods which
 * are unavailable on older platforms in subclasses which are only ever
 * accessed on platforms where they are available, we can preserve
 * compatibility with older platforms without resorting to reflection.
 *
 * See http://developer.android.com/resources/articles/backward-compatibility.html
 * and http://android-developers.blogspot.com/2010/07/how-to-have-your-cupcake-and-eat-it-too.html
 * for further discussion of this technique.
 */

public class AndroidCompat {
    public final static int SDK = getSDK();

    // The era of Holo Design
    public final static boolean V11ToV20;

    static {
        V11ToV20 = (SDK >= 11) && (SDK <= 20);
    }

    private final static int getSDK() {
        int result;
        try {
            result = AndroidLevel4PlusCompat.getSDKInt();
        } catch (VerifyError e) {
            // We must be at an SDK level less than 4.
            try {
                result = Integer.valueOf(android.os.Build.VERSION.SDK);
            } catch (NumberFormatException e2) {
                // Couldn't parse string, assume the worst.
                result = 1;
            }
        }
        return result;
    }
}

class AndroidLevel4PlusCompat {
    static int getSDKInt() {
        return android.os.Build.VERSION.SDK_INT;
    }
}

```

`term/src/main/java/jackpal/androidterm/compat/Base64.java`:

```java
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.compat;

/**
 * Copied from
 *
 * https://android.googlesource.com/platform/frameworks/base/+/android-5.0.0_r6/core/java/android/util/Base64.java
 *
 * to provide a Base64 implementation on Android API < 8 (where Base64 is not
 * a part of the public API).
 */

import java.io.UnsupportedEncodingException;

/**
 * Utilities for encoding and decoding the Base64 representation of
 * binary data.  See RFCs <a
 * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
 * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
 */
public class Base64 {
    /**
     * Default values for encoder/decoder flags.
     */
    public static final int DEFAULT = 0;

    /**
     * Encoder flag bit to omit the padding '=' characters at the end
     * of the output (if any).
     */
    public static final int NO_PADDING = 1;

    /**
     * Encoder flag bit to omit all line terminators (i.e., the output
     * will be on one long line).
     */
    public static final int NO_WRAP = 2;

    /**
     * Encoder flag bit to indicate lines should be terminated with a
     * CRLF pair instead of just an LF.  Has no effect if {@code
     * NO_WRAP} is specified as well.
     */
    public static final int CRLF = 4;

    /**
     * Encoder/decoder flag bit to indicate using the "URL and
     * filename safe" variant of Base64 (see RFC 3548 section 4) where
     * {@code -} and {@code _} are used in place of {@code +} and
     * {@code /}.
     */
    public static final int URL_SAFE = 8;

    /**
     * Flag to pass to {@link Base64OutputStream} to indicate that it
     * should not close the output stream it is wrapping when it
     * itself is closed.
     */
    public static final int NO_CLOSE = 16;

    //  --------------------------------------------------------
    //  shared code
    //  --------------------------------------------------------

    /* package */ static abstract class Coder {
        public byte[] output;
        public int op;

        /**
         * Encode/decode another block of input data.  this.output is
         * provided by the caller, and must be big enough to hold all
         * the coded data.  On exit, this.opwill be set to the length
         * of the coded data.
         *
         * @param finish true if this is the final call to process for
         *        this object.  Will finalize the coder state and
         *        include any final bytes in the output.
         *
         * @return true if the input so far is good; false if some
         *         error has been detected in the input stream..
         */
        public abstract boolean process(byte[] input, int offset, int len, boolean finish);

        /**
         * @return the maximum number of bytes a call to process()
         * could produce for the given number of input bytes.  This may
         * be an overestimate.
         */
        public abstract int maxOutputSize(int len);
    }

    //  --------------------------------------------------------
    //  decoding
    //  --------------------------------------------------------

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param str    the input String to decode, which is converted to
     *               bytes using the default charset
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(String str, int flags) {
        return decode(str.getBytes(), flags);
    }

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param input the input array to decode
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(byte[] input, int flags) {
        return decode(input, 0, input.length, flags);
    }

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     *
     * <p>The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param input  the data to decode
     * @param offset the position within the input array at which to start
     * @param len    the number of bytes of input to decode
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     *
     * @throws IllegalArgumentException if the input contains
     * incorrect padding
     */
    public static byte[] decode(byte[] input, int offset, int len, int flags) {
        // Allocate space for the most data the input could represent.
        // (It could contain less if it contains whitespace, etc.)
        Decoder decoder = new Decoder(flags, new byte[len*3/4]);

        if (!decoder.process(input, offset, len, true)) {
            throw new IllegalArgumentException("bad base-64");
        }

        // Maybe we got lucky and allocated exactly enough output space.
        if (decoder.op == decoder.output.length) {
            return decoder.output;
        }

        // Need to shorten the array, so allocate a new one of the
        // right size and copy.
        byte[] temp = new byte[decoder.op];
        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);
        return temp;
    }

    /* package */ static class Decoder extends Coder {
        /**
         * Lookup table for turning bytes into their position in the
         * Base64 alphabet.
         */
        private static final int DECODE[] = {
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        /**
         * Decode lookup table for the "web safe" variant (RFC 3548
         * sec. 4) where - and _ replace + and /.
         */
        private static final int DECODE_WEBSAFE[] = {
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        /** Non-data values in the DECODE arrays. */
        private static final int SKIP = -1;
        private static final int EQUALS = -2;

        /**
         * States 0-3 are reading through the next input tuple.
         * State 4 is having read one '=' and expecting exactly
         * one more.
         * State 5 is expecting no more data or padding characters
         * in the input.
         * State 6 is the error state; an error has been detected
         * in the input and no future input can "fix" it.
         */
        private int state;   // state number (0 to 6)
        private int value;

        final private int[] alphabet;

        public Decoder(int flags, byte[] output) {
            this.output = output;

            alphabet = ((flags & URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;
            state = 0;
            value = 0;
        }

        /**
         * @return an overestimate for the number of bytes {@code
         * len} bytes could decode to.
         */
        public int maxOutputSize(int len) {
            return len * 3/4 + 10;
        }

        /**
         * Decode another block of input data.
         *
         * @return true if the state machine is still healthy.  false if
         *         bad base-64 data has been detected in the input stream.
         */
        public boolean process(byte[] input, int offset, int len, boolean finish) {
            if (this.state == 6) return false;

            int p = offset;
            len += offset;

            // Using local variables makes the decoder about 12%
            // faster than if we manipulate the member variables in
            // the loop.  (Even alphabet makes a measurable
            // difference, which is somewhat surprising to me since
            // the member variable is final.)
            int state = this.state;
            int value = this.value;
            int op = 0;
            final byte[] output = this.output;
            final int[] alphabet = this.alphabet;

            while (p < len) {
                // Try the fast path:  we're starting a new tuple and the
                // next four bytes of the input stream are all data
                // bytes.  This corresponds to going through states
                // 0-1-2-3-0.  We expect to use this method for most of
                // the data.
                //
                // If any of the next four bytes of input are non-data
                // (whitespace, etc.), value will end up negative.  (All
                // the non-data values in decode are small negative
                // numbers, so shifting any of them up and or'ing them
                // together will result in a value with its top bit set.)
                //
                // You can remove this whole block and the output should
                // be the same, just slower.
                if (state == 0) {
                    while (p+4 <= len &&
                           (value = ((alphabet[input[p] & 0xff] << 18) |
                                     (alphabet[input[p+1] & 0xff] << 12) |
                                     (alphabet[input[p+2] & 0xff] << 6) |
                                     (alphabet[input[p+3] & 0xff]))) >= 0) {
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        p += 4;
                    }
                    if (p >= len) break;
                }

                // The fast path isn't available -- either we've read a
                // partial tuple, or the next four input bytes aren't all
                // data, or whatever.  Fall back to the slower state
                // machine implementation.

                int d = alphabet[input[p++] & 0xff];

                switch (state) {
                case 0:
                    if (d >= 0) {
                        value = d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 1:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 2:
                    if (d >= 0) {
                        value = (value << 6) | d;
                        ++state;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect exactly one more padding character.
                        output[op++] = (byte) (value >> 4);
                        state = 4;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 3:
                    if (d >= 0) {
                        // Emit the output triple and return to state 0.
                        value = (value << 6) | d;
                        output[op+2] = (byte) value;
                        output[op+1] = (byte) (value >> 8);
                        output[op] = (byte) (value >> 16);
                        op += 3;
                        state = 0;
                    } else if (d == EQUALS) {
                        // Emit the last (partial) output tuple;
                        // expect no further data or padding characters.
                        output[op+1] = (byte) (value >> 2);
                        output[op] = (byte) (value >> 10);
                        op += 2;
                        state = 5;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 4:
                    if (d == EQUALS) {
                        ++state;
                    } else if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;

                case 5:
                    if (d != SKIP) {
                        this.state = 6;
                        return false;
                    }
                    break;
                }
            }

            if (!finish) {
                // We're out of input, but a future call could provide
                // more.
                this.state = state;
                this.value = value;
                this.op = op;
                return true;
            }

            // Done reading input.  Now figure out where we are left in
            // the state machine and finish up.

            switch (state) {
            case 0:
                // Output length is a multiple of three.  Fine.
                break;
            case 1:
                // Read one extra input byte, which isn't enough to
                // make another output byte.  Illegal.
                this.state = 6;
                return false;
            case 2:
                // Read two extra input bytes, enough to emit 1 more
                // output byte.  Fine.
                output[op++] = (byte) (value >> 4);
                break;
            case 3:
                // Read three extra input bytes, enough to emit 2 more
                // output bytes.  Fine.
                output[op++] = (byte) (value >> 10);
                output[op++] = (byte) (value >> 2);
                break;
            case 4:
                // Read one padding '=' when we expected 2.  Illegal.
                this.state = 6;
                return false;
            case 5:
                // Read all the padding '='s we expected and no more.
                // Fine.
                break;
            }

            this.state = state;
            this.op = op;
            return true;
        }
    }

    //  --------------------------------------------------------
    //  encoding
    //  --------------------------------------------------------

    /**
     * Base64-encode the given data and return a newly allocated
     * String with the result.
     *
     * @param input  the data to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static String encodeToString(byte[] input, int flags) {
        try {
            return new String(encode(input, flags), "US-ASCII");
        } catch (UnsupportedEncodingException e) {
            // US-ASCII is guaranteed to be available.
            throw new AssertionError(e);
        }
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * String with the result.
     *
     * @param input  the data to encode
     * @param offset the position within the input array at which to
     *               start
     * @param len    the number of bytes of input to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static String encodeToString(byte[] input, int offset, int len, int flags) {
        try {
            return new String(encode(input, offset, len, flags), "US-ASCII");
        } catch (UnsupportedEncodingException e) {
            // US-ASCII is guaranteed to be available.
            throw new AssertionError(e);
        }
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * byte[] with the result.
     *
     * @param input  the data to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static byte[] encode(byte[] input, int flags) {
        return encode(input, 0, input.length, flags);
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * byte[] with the result.
     *
     * @param input  the data to encode
     * @param offset the position within the input array at which to
     *               start
     * @param len    the number of bytes of input to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static byte[] encode(byte[] input, int offset, int len, int flags) {
        Encoder encoder = new Encoder(flags, null);

        // Compute the exact length of the array we will produce.
        int output_len = len / 3 * 4;

        // Account for the tail of the data and the padding bytes, if any.
        if (encoder.do_padding) {
            if (len % 3 > 0) {
                output_len += 4;
            }
        } else {
            switch (len % 3) {
                case 0: break;
                case 1: output_len += 2; break;
                case 2: output_len += 3; break;
            }
        }

        // Account for the newlines, if any.
        if (encoder.do_newline && len > 0) {
            output_len += (((len-1) / (3 * Encoder.LINE_GROUPS)) + 1) *
                (encoder.do_cr ? 2 : 1);
        }

        encoder.output = new byte[output_len];
        encoder.process(input, offset, len, true);

        assert encoder.op == output_len;

        return encoder.output;
    }

    /* package */ static class Encoder extends Coder {
        /**
         * Emit a new line every this many output tuples.  Corresponds to
         * a 76-character line length (the maximum allowable according to
         * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>).
         */
        public static final int LINE_GROUPS = 19;

        /**
         * Lookup table for turning Base64 alphabet positions (6 bits)
         * into output bytes.
         */
        private static final byte ENCODE[] = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
        };

        /**
         * Lookup table for turning Base64 alphabet positions (6 bits)
         * into output bytes.
         */
        private static final byte ENCODE_WEBSAFE[] = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
        };

        final private byte[] tail;
        /* package */ int tailLen;
        private int count;

        final public boolean do_padding;
        final public boolean do_newline;
        final public boolean do_cr;
        final private byte[] alphabet;

        public Encoder(int flags, byte[] output) {
            this.output = output;

            do_padding = (flags & NO_PADDING) == 0;
            do_newline = (flags & NO_WRAP) == 0;
            do_cr = (flags & CRLF) != 0;
            alphabet = ((flags & URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;

            tail = new byte[2];
            tailLen = 0;

            count = do_newline ? LINE_GROUPS : -1;
        }

        /**
         * @return an overestimate for the number of bytes {@code
         * len} bytes could encode to.
         */
        public int maxOutputSize(int len) {
            return len * 8/5 + 10;
        }

        public boolean process(byte[] input, int offset, int len, boolean finish) {
            // Using local variables makes the encoder about 9% faster.
            final byte[] alphabet = this.alphabet;
            final byte[] output = this.output;
            int op = 0;
            int count = this.count;

            int p = offset;
            len += offset;
            int v = -1;

            // First we need to concatenate the tail of the previous call
            // with any input bytes available now and see if we can empty
            // the tail.

            switch (tailLen) {
                case 0:
                    // There was no tail.
                    break;

                case 1:
                    if (p+2 <= len) {
                        // A 1-byte tail with at least 2 bytes of
                        // input available now.
                        v = ((tail[0] & 0xff) << 16) |
                            ((input[p++] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    };
                    break;

                case 2:
                    if (p+1 <= len) {
                        // A 2-byte tail with at least 1 byte of input.
                        v = ((tail[0] & 0xff) << 16) |
                            ((tail[1] & 0xff) << 8) |
                            (input[p++] & 0xff);
                        tailLen = 0;
                    }
                    break;
            }

            if (v != -1) {
                output[op++] = alphabet[(v >> 18) & 0x3f];
                output[op++] = alphabet[(v >> 12) & 0x3f];
                output[op++] = alphabet[(v >> 6) & 0x3f];
                output[op++] = alphabet[v & 0x3f];
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            // At this point either there is no tail, or there are fewer
            // than 3 bytes of input available.

            // The main loop, turning 3 input bytes into 4 output bytes on
            // each iteration.
            while (p+3 <= len) {
                v = ((input[p] & 0xff) << 16) |
                    ((input[p+1] & 0xff) << 8) |
                    (input[p+2] & 0xff);
                output[op] = alphabet[(v >> 18) & 0x3f];
                output[op+1] = alphabet[(v >> 12) & 0x3f];
                output[op+2] = alphabet[(v >> 6) & 0x3f];
                output[op+3] = alphabet[v & 0x3f];
                p += 3;
                op += 4;
                if (--count == 0) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                    count = LINE_GROUPS;
                }
            }

            if (finish) {
                // Finish up the tail of the input.  Note that we need to
                // consume any bytes in tail before any bytes
                // remaining in input; there should be at most two bytes
                // total.

                if (p-tailLen == len-1) {
                    int t = 0;
                    v = ((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 4;
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (p-tailLen == len-2) {
                    int t = 0;
                    v = (((tailLen > 1 ? tail[t++] : input[p++]) & 0xff) << 10) |
                        (((tailLen > 0 ? tail[t++] : input[p++]) & 0xff) << 2);
                    tailLen -= t;
                    output[op++] = alphabet[(v >> 12) & 0x3f];
                    output[op++] = alphabet[(v >> 6) & 0x3f];
                    output[op++] = alphabet[v & 0x3f];
                    if (do_padding) {
                        output[op++] = '=';
                    }
                    if (do_newline) {
                        if (do_cr) output[op++] = '\r';
                        output[op++] = '\n';
                    }
                } else if (do_newline && op > 0 && count != LINE_GROUPS) {
                    if (do_cr) output[op++] = '\r';
                    output[op++] = '\n';
                }

                assert tailLen == 0;
                assert p == len;
            } else {
                // Save the leftovers in tail to be consumed on the next
                // call to encodeInternal.

                if (p == len-1) {
                    tail[tailLen++] = input[p];
                } else if (p == len-2) {
                    tail[tailLen++] = input[p];
                    tail[tailLen++] = input[p+1];
                }
            }

            this.op = op;
            this.count = count;

            return true;
        }
    }

    private Base64() { }   // don't instantiate
}

```

`term/src/main/java/jackpal/androidterm/compat/FileCompat.java`:

```java
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.compat;

import java.io.File;

/**
 * Compatibility class for java.io.File
 */
public class FileCompat {
    private static class Api9OrLater {
        public static boolean canExecute(File file) {
            return file.canExecute();
        }
    }

    private static class Api8OrEarlier {
        static {
            System.loadLibrary("jackpal-androidterm5");
        }

        public static boolean canExecute(File file) {
            return testExecute(file.getAbsolutePath());
        }

        private static native boolean testExecute(String pathname);
    }

    public static boolean canExecute(File file) {
        if (AndroidCompat.SDK < 9) {
            return Api8OrEarlier.canExecute(file);
        } else {
            return Api9OrLater.canExecute(file);
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/compat/MenuItemCompat.java`:

```java
package jackpal.androidterm.compat;

import android.view.MenuItem;

/**
 * Definitions related to android.view.MenuItem
 */
public class MenuItemCompat {
    public static final int SHOW_AS_ACTION_NEVER = 0;
    public static final int SHOW_AS_ACTION_IF_ROOM = 1;
    public static final int SHOW_AS_ACTION_ALWAYS = 2;
    public static final int SHOW_AS_ACTION_WITH_TEXT = 4;

    private static class Api11OrLater {
        public static void setShowAsAction(MenuItem item, int actionEnum) {
            item.setShowAsAction(actionEnum);
        }
    }

    public static void setShowAsAction(MenuItem item, int actionEnum) {
        if (AndroidCompat.SDK >= 11) {
            Api11OrLater.setShowAsAction(item, actionEnum);
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/compat/PRNGFixes.java`:

```java
/*
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will Google be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, as long as the origin is not misrepresented.
 */

package jackpal.androidterm.compat;

/**
 * Copied from
 *
 * http://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html
 *
 * to work around entropy-quality problems with Android's SecureRandom
 * implementations before 4.4.
 */

import android.os.Build;
import android.os.Process;
import android.util.Log;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.SecureRandomSpi;
import java.security.Security;

/**
 * Fixes for the output of the default PRNG having low entropy.
 *
 * The fixes need to be applied via {@link #apply()} before any use of Java
 * Cryptography Architecture primitives. A good place to invoke them is in the
 * application's {@code onCreate}.
 */
public final class PRNGFixes {

    private static final int VERSION_CODE_JELLY_BEAN = 16;
    private static final int VERSION_CODE_JELLY_BEAN_MR2 = 18;
    private static final byte[] BUILD_FINGERPRINT_AND_DEVICE_SERIAL =
        getBuildFingerprintAndDeviceSerial();

    /** Hidden constructor to prevent instantiation. */
    private PRNGFixes() {}

    /**
     * Applies all fixes.
     *
     * @throws SecurityException if a fix is needed but could not be applied.
     */
    public static void apply() {
        applyOpenSSLFix();
        installLinuxPRNGSecureRandom();
    }

    /**
     * Applies the fix for OpenSSL PRNG having low entropy. Does nothing if the
     * fix is not needed.
     *
     * @throws SecurityException if the fix is needed but could not be applied.
     */
    private static void applyOpenSSLFix() throws SecurityException {
        if ((AndroidCompat.SDK < VERSION_CODE_JELLY_BEAN)
                || (AndroidCompat.SDK > VERSION_CODE_JELLY_BEAN_MR2)) {
            // No need to apply the fix
            return;
        }

        try {
            // Mix in the device- and invocation-specific seed.
            Class.forName("org.apache.harmony.xnet.provider.jsse.NativeCrypto")
                    .getMethod("RAND_seed", byte[].class)
                    .invoke(null, generateSeed());

            // Mix output of Linux PRNG into OpenSSL's PRNG
            int bytesRead = (Integer) Class.forName(
                    "org.apache.harmony.xnet.provider.jsse.NativeCrypto")
                    .getMethod("RAND_load_file", String.class, long.class)
                    .invoke(null, "/dev/urandom", 1024);
            if (bytesRead != 1024) {
                throw new IOException(
                        "Unexpected number of bytes read from Linux PRNG: "
                                + bytesRead);
            }
        } catch (Exception e) {
            throw new SecurityException("Failed to seed OpenSSL PRNG", e);
        }
    }

    /**
     * Installs a Linux PRNG-backed {@code SecureRandom} implementation as the
     * default. Does nothing if the implementation is already the default or if
     * there is not need to install the implementation.
     *
     * @throws SecurityException if the fix is needed but could not be applied.
     */
    private static void installLinuxPRNGSecureRandom()
            throws SecurityException {
        if (AndroidCompat.SDK > VERSION_CODE_JELLY_BEAN_MR2) {
            // No need to apply the fix
            return;
        }

        // Install a Linux PRNG-based SecureRandom implementation as the
        // default, if not yet installed.
        Provider[] secureRandomProviders =
                Security.getProviders("SecureRandom.SHA1PRNG");
        if ((secureRandomProviders == null)
                || (secureRandomProviders.length < 1)
                || (!LinuxPRNGSecureRandomProvider.class.equals(
                        secureRandomProviders[0].getClass()))) {
            Security.insertProviderAt(new LinuxPRNGSecureRandomProvider(), 1);
        }

        // Assert that new SecureRandom() and
        // SecureRandom.getInstance("SHA1PRNG") return a SecureRandom backed
        // by the Linux PRNG-based SecureRandom implementation.
        SecureRandom rng1 = new SecureRandom();
        if (!LinuxPRNGSecureRandomProvider.class.equals(
                rng1.getProvider().getClass())) {
            throw new SecurityException(
                    "new SecureRandom() backed by wrong Provider: "
                            + rng1.getProvider().getClass());
        }

        SecureRandom rng2;
        try {
            rng2 = SecureRandom.getInstance("SHA1PRNG");
        } catch (NoSuchAlgorithmException e) {
            throw new SecurityException("SHA1PRNG not available", e);
        }
        if (!LinuxPRNGSecureRandomProvider.class.equals(
                rng2.getProvider().getClass())) {
            throw new SecurityException(
                    "SecureRandom.getInstance(\"SHA1PRNG\") backed by wrong"
                    + " Provider: " + rng2.getProvider().getClass());
        }
    }

    /**
     * {@code Provider} of {@code SecureRandom} engines which pass through
     * all requests to the Linux PRNG.
     */
    private static class LinuxPRNGSecureRandomProvider extends Provider {

        public LinuxPRNGSecureRandomProvider() {
            super("LinuxPRNG",
                    1.0,
                    "A Linux-specific random number provider that uses"
                        + " /dev/urandom");
            // Although /dev/urandom is not a SHA-1 PRNG, some apps
            // explicitly request a SHA1PRNG SecureRandom and we thus need to
            // prevent them from getting the default implementation whose output
            // may have low entropy.
            put("SecureRandom.SHA1PRNG", LinuxPRNGSecureRandom.class.getName());
            put("SecureRandom.SHA1PRNG ImplementedIn", "Software");
        }
    }

    /**
     * {@link SecureRandomSpi} which passes all requests to the Linux PRNG
     * ({@code /dev/urandom}).
     */
    public static class LinuxPRNGSecureRandom extends SecureRandomSpi {

        /*
         * IMPLEMENTATION NOTE: Requests to generate bytes and to mix in a seed
         * are passed through to the Linux PRNG (/dev/urandom). Instances of
         * this class seed themselves by mixing in the current time, PID, UID,
         * build fingerprint, and hardware serial number (where available) into
         * Linux PRNG.
         *
         * Concurrency: Read requests to the underlying Linux PRNG are
         * serialized (on sLock) to ensure that multiple threads do not get
         * duplicated PRNG output.
         */

        private static final File URANDOM_FILE = new File("/dev/urandom");

        private static final Object sLock = new Object();

        /**
         * Input stream for reading from Linux PRNG or {@code null} if not yet
         * opened.
         *
         * @GuardedBy("sLock")
         */
        private static DataInputStream sUrandomIn;

        /**
         * Output stream for writing to Linux PRNG or {@code null} if not yet
         * opened.
         *
         * @GuardedBy("sLock")
         */
        private static OutputStream sUrandomOut;

        /**
         * Whether this engine instance has been seeded. This is needed because
         * each instance needs to seed itself if the client does not explicitly
         * seed it.
         */
        private boolean mSeeded;

        @Override
        protected void engineSetSeed(byte[] bytes) {
            try {
                OutputStream out;
                synchronized (sLock) {
                    out = getUrandomOutputStream();
                }
                out.write(bytes);
                out.flush();
            } catch (IOException e) {
                // On a small fraction of devices /dev/urandom is not writable.
                // Log and ignore.
                Log.w(PRNGFixes.class.getSimpleName(),
                        "Failed to mix seed into " + URANDOM_FILE);
            } finally {
                mSeeded = true;
            }
        }

        @Override
        protected void engineNextBytes(byte[] bytes) {
            if (!mSeeded) {
                // Mix in the device- and invocation-specific seed.
                engineSetSeed(generateSeed());
            }

            try {
                DataInputStream in;
                synchronized (sLock) {
                    in = getUrandomInputStream();
                }
                synchronized (in) {
                    in.readFully(bytes);
                }
            } catch (IOException e) {
                throw new SecurityException(
                        "Failed to read from " + URANDOM_FILE, e);
            }
        }

        @Override
        protected byte[] engineGenerateSeed(int size) {
            byte[] seed = new byte[size];
            engineNextBytes(seed);
            return seed;
        }

        private DataInputStream getUrandomInputStream() {
            synchronized (sLock) {
                if (sUrandomIn == null) {
                    // NOTE: Consider inserting a BufferedInputStream between
                    // DataInputStream and FileInputStream if you need higher
                    // PRNG output performance and can live with future PRNG
                    // output being pulled into this process prematurely.
                    try {
                        sUrandomIn = new DataInputStream(
                                new FileInputStream(URANDOM_FILE));
                    } catch (IOException e) {
                        throw new SecurityException("Failed to open "
                                + URANDOM_FILE + " for reading", e);
                    }
                }
                return sUrandomIn;
            }
        }

        private OutputStream getUrandomOutputStream() throws IOException {
            synchronized (sLock) {
                if (sUrandomOut == null) {
                    sUrandomOut = new FileOutputStream(URANDOM_FILE);
                }
                return sUrandomOut;
            }
        }
    }

    /**
     * Generates a device- and invocation-specific seed to be mixed into the
     * Linux PRNG.
     */
    private static byte[] generateSeed() {
        try {
            ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream();
            DataOutputStream seedBufferOut =
                    new DataOutputStream(seedBuffer);
            seedBufferOut.writeLong(System.currentTimeMillis());
            seedBufferOut.writeLong(System.nanoTime());
            seedBufferOut.writeInt(Process.myPid());
            seedBufferOut.writeInt(Process.myUid());
            seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL);
            seedBufferOut.close();
            return seedBuffer.toByteArray();
        } catch (IOException e) {
            throw new SecurityException("Failed to generate seed", e);
        }
    }

    /**
     * Gets the hardware serial number of this device.
     *
     * @return serial number or {@code null} if not available.
     */
    private static String getDeviceSerialNumber() {
        // We're using the Reflection API because Build.SERIAL is only available
        // since API Level 9 (Gingerbread, Android 2.3).
        try {
            return (String) Build.class.getField("SERIAL").get(null);
        } catch (Exception ignored) {
            return null;
        }
    }

    private static byte[] getBuildFingerprintAndDeviceSerial() {
        StringBuilder result = new StringBuilder();
        String fingerprint = Build.FINGERPRINT;
        if (fingerprint != null) {
            result.append(fingerprint);
        }
        String serial = getDeviceSerialNumber();
        if (serial != null) {
            result.append(serial);
        }
        try {
            return result.toString().getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("UTF-8 encoding not supported");
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/compat/ServiceForegroundCompat.java`:

```java
/*
 * Copyright (C) 2011 Steven Luo
 * Copyright (C) 2011 Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.compat;

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import android.app.Service;
import android.util.Log;
import android.app.Notification;
import android.app.NotificationManager;
import android.content.Context;

/* Provide startForeground() and stopForeground() compatibility, using the
   current interfaces where available and the deprecated setForeground()
   interface where necessary
   The idea for the implementation comes from an example in the documentation of
   android.app.Service */
public class ServiceForegroundCompat {
    private static Class<?>[] mSetForegroundSig = new Class[] {
        boolean.class };
    private static Class<?>[] mStartForegroundSig = new Class[] {
        int.class, Notification.class };
    private static Class<?>[] mStopForegroundSig = new Class[] {
        boolean.class };

    private Service service;
    private NotificationManager mNM;
    private Method mSetForeground;
    private Method mStartForeground;
    private Method mStopForeground;
    private int notifyId;

    private void invokeMethod(Object receiver, Method method, Object... args) {
        try {
            method.invoke(receiver, args);
        } catch (IllegalAccessException e) {
            // Shouldn't happen, but we have to catch this
            Log.w("ServiceCompat", "Unable to invoke method", e);
        } catch (InvocationTargetException e) {
            /* The methods we call don't throw exceptions -- in general,
               we should throw e.getCause() */
            Log.w("ServiceCompat", "Method threw exception", e.getCause());
        }
    }

    public void startForeground(int id, Notification notification) {
        if (mStartForeground != null) {
            invokeMethod(service, mStartForeground, id, notification);
            return;
        }

        invokeMethod(service, mSetForeground, Boolean.TRUE);
        mNM.notify(id, notification);
        notifyId = id;
    }

    public void stopForeground(boolean removeNotify) {
        if (mStopForeground != null) {
            invokeMethod(service, mStopForeground, removeNotify);
            return;
        }

        if (removeNotify) {
            mNM.cancel(notifyId);
        }
        invokeMethod(service, mSetForeground, Boolean.FALSE);
    }

    public ServiceForegroundCompat(Service service) {
        this.service = service;
        mNM = (NotificationManager)service.getSystemService(Context.NOTIFICATION_SERVICE);

        Class<?> clazz = service.getClass();

        try {
            mStartForeground = clazz.getMethod("startForeground", mStartForegroundSig);
            mStopForeground = clazz.getMethod("stopForeground", mStopForegroundSig);
        } catch (NoSuchMethodException e) {
            mStartForeground = mStopForeground = null;
        }

        try {
            mSetForeground = clazz.getMethod("setForeground", mSetForegroundSig);
        } catch (NoSuchMethodException e) {
            mSetForeground = null;
        }

        if (mStartForeground == null && mSetForeground == null) {
            throw new IllegalStateException("Neither startForeground() or setForeground() present!");
        }
    }
}

```

`term/src/main/java/jackpal/androidterm/shortcuts/AddShortcut.java`:

```java
//From the desk of Frank P. Westlake; public domain.
package jackpal.androidterm.shortcuts;

import android.content.    Context;
import android.content.    DialogInterface;
import android.content.    Intent;
import android.content.    SharedPreferences;
import android.graphics.   Typeface;
import android.net.        Uri;
import android.os.         Bundle;
import android.os.         Environment;
import android.preference. PreferenceManager;
import android.util.       Log;
import android.view.       Gravity;
import android.view.       View;
import android.view.       View.OnFocusChangeListener;
import android.widget.     Button;
import android.widget.     ImageView;
import android.widget.     LinearLayout;
import android.widget.     ScrollView;
import android.widget.     TextView;
import android.widget.     EditText;
import jackpal.androidterm.R;
import jackpal.androidterm.RemoteInterface;
import jackpal.androidterm.RunShortcut;
import jackpal.androidterm.TermDebug;
import jackpal.androidterm.compat.AlertDialogCompat;
import jackpal.androidterm.compat.PRNGFixes;
import jackpal.androidterm.util.ShortcutEncryption;

import java.io.            File;
import java.security.      GeneralSecurityException;

public class      AddShortcut
       extends    android.app.Activity
{
  private final int                    OP_MAKE_SHORTCUT=            1;
  private final Context                context=                     this;
  private       SharedPreferences      SP;
  private       int                    ix=                          0;
  private final int                    PATH=                        ix++
  ,                                    ARGS=                        ix++
  ,                                    NAME=                        ix++;
  private final EditText               et[]=                        new EditText[5];
  private       String                 path;
  private       String                 name="";
  private       String                 iconText[]=                  {"", null};

  //////////////////////////////////////////////////////////////////////
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    SP=PreferenceManager.getDefaultSharedPreferences(context);
    String action=getIntent().getAction();
    if(action!=null && action.equals("android.intent.action.CREATE_SHORTCUT")) makeShortcut();
    else finish();
  }
  //////////////////////////////////////////////////////////////////////
  void makeShortcut()
  {
    if(path==null) path="";
    final AlertDialogCompat.Builder alert =
        AlertDialogCompat.newInstanceBuilder(context, AlertDialogCompat.THEME_HOLO_DARK);
    LinearLayout   lv=new LinearLayout(context);
                   lv.setOrientation(LinearLayout.VERTICAL);
    for(int i=0, n=et.length; i<n; i++) {et[i]=new EditText(context); et[i].setSingleLine(true);}
    if(!path.equals("")) et[0].setText(path);
    et[PATH].setHint(getString(R.string.addshortcut_command_hint));//"command");
    et[NAME].setText(name);
    et[ARGS].setHint(getString(R.string.addshortcut_example_hint));//"--example=\"a\"");
    et[ARGS].setOnFocusChangeListener(
      new OnFocusChangeListener()
      {
        public void onFocusChange(View view, boolean focus)
        {
          if(!focus)
          {
            String s;
            if(
              et[NAME].getText().toString().equals("")
            && !(s=et[ARGS].getText().toString()).equals("")
            )
              et[NAME].setText(s.split("\\s")[0]);
          }
        }
      }
    );

    Button  btn_path=new Button(context);
            btn_path.setText(getString(R.string.addshortcut_button_find_command));//"Find command");
            btn_path.setOnClickListener(
              new View.OnClickListener()
              {
                public void onClick(View p1)
                {
                  String lastPath=SP.getString("lastPath", null);
                  File get= (lastPath==null)
                            ?Environment.getExternalStorageDirectory()
                            :new File(lastPath).getParentFile();
                    Intent pickerIntent=new Intent();
                    if(SP.getBoolean("useInternalScriptFinder", false))
                    {
                      pickerIntent.setClass(getApplicationContext(), jackpal.androidterm.shortcuts.FSNavigator.class)
                      .setData(Uri.fromFile(get))
                      .putExtra("title", getString(R.string.addshortcut_navigator_title));//"SELECT SHORTCUT TARGET")
                    }
                    else
                    {
                      pickerIntent
                      .putExtra("CONTENT_TYPE", "*/*")
                      .setAction(Intent.ACTION_PICK);
                    }
                    startActivityForResult(pickerIntent, OP_MAKE_SHORTCUT);
                }
              }
            );
    lv.addView(
      layoutTextViewH(
        getString(R.string.addshortcut_command_window_instructions)//"Command window requires full path, no arguments. For other commands use Arguments window (ex: cd /sdcard)."
      , null
      , false
      )
    );
    lv.addView(layoutViewViewH(btn_path,          et[PATH]));
    lv.addView(layoutTextViewH(getString(R.string.addshortcut_arguments_label), et[ARGS]));
    lv.addView(layoutTextViewH(getString(R.string.addshortcut_shortcut_label),  et[NAME]));

    final ImageView img=new ImageView(context);
                    img.setImageResource(jackpal.androidterm.R.drawable.ic_launcher);
                    img.setMaxHeight(100);
                    img.setTag(0xFFFFFFFF);
                    img.setMaxWidth(100);
                    img.setAdjustViewBounds(true);
                    img.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
    final Button    btn_color=new Button(context);
                    btn_color.setText(getString(R.string.addshortcut_button_text_icon));//"Text icon");
                    btn_color.setOnClickListener(
                      new View.OnClickListener()
                      {
                        public void onClick(View p1)
                        {
                          new ColorValue(context, img, iconText);
                        }
                      }
                    );
    lv.addView(
      layoutTextViewH(
          getString(R.string.addshortcut_text_icon_instructions)//"Optionally create a text icon:"
      , null
      , false
      )
    );
    lv.addView(layoutViewViewH(btn_color, img));
    final ScrollView sv=new ScrollView(context);
                     sv.setFillViewport(true);
                     sv.addView(lv);

    alert.setView(sv);
    alert.setTitle(getString(R.string.addshortcut_title));//"Term Shortcut");
    alert.setPositiveButton(
      android.R.string.yes
    , new DialogInterface.OnClickListener()
      {
        public void onClick(DialogInterface dialog, int which)
        {
          buildShortcut(
            path
          , et[ARGS].getText().toString()
          , et[NAME].getText().toString()
          , iconText[1]
          , (Integer)img.getTag()
          );
        }
      }
    );
    alert.setNegativeButton(
      android.R.string.cancel
    , new DialogInterface.OnClickListener()
      {
        public void onClick(DialogInterface dialog, int which)
        {
          finish();
        }
      }
    );
    alert.show();
  }
  //////////////////////////////////////////////////////////////////////
  LinearLayout layoutTextViewH(String text, View vw)
  {
    return(layoutTextViewH(text, vw, true));
  }
  LinearLayout layoutTextViewH(String text, View vw, boolean attributes)
  {
      LinearLayout.LayoutParams lp=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
      TextView                  tv=new TextView(context);
                                tv.setText(text);
      if(attributes)            tv.setTypeface(Typeface.DEFAULT_BOLD);
      if(attributes)            tv.setGravity(Gravity.RIGHT|Gravity.CENTER_VERTICAL);
                                tv.setPadding(10, tv.getPaddingTop(), 10, tv.getPaddingBottom());
      LinearLayout              lh=new LinearLayout(context);
                                lh.setOrientation(LinearLayout.HORIZONTAL);
                                lh.addView(tv, lp);
      if(vw!=null)              lh.addView(vw, lp);
      return(lh);
  }
  //////////////////////////////////////////////////////////////////////
  LinearLayout layoutViewViewH(View vw1, View vw2)
  {
      LinearLayout.LayoutParams lp=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
      LinearLayout  lh=new LinearLayout(context);
                    lh.setOrientation(LinearLayout.HORIZONTAL);
                    lh.addView(vw1, lp);
      if(vw2!=null) lh.addView(vw2, lp);
      return(lh);
  }
  //////////////////////////////////////////////////////////////////////
  void buildShortcut(
      String path
    , String arguments
    , String shortcutName
    , String shortcutText
    , int    shortcutColor
    )
    {
      // Apply workarounds for SecureRandom bugs in Android < 4.4
      PRNGFixes.apply();
      ShortcutEncryption.Keys keys=ShortcutEncryption.getKeys(context);
      if(keys==null)
      {
        try
        {
          keys=ShortcutEncryption.generateKeys();
        }
        catch (GeneralSecurityException e)
        {
          Log.e(TermDebug.LOG_TAG, "Generating shortcut encryption keys failed: " + e.toString());
          throw new RuntimeException(e);
        }
        ShortcutEncryption.saveKeys(context, keys);
      }
      StringBuilder cmd=new StringBuilder();
      if(path!=null      && !path.equals(""))      cmd.append(RemoteInterface.quoteForBash(path));
      if(arguments!=null && !arguments.equals("")) cmd.append(" " + arguments);
      String cmdStr=cmd.toString();
      String cmdEnc=null;
      try
      {
        cmdEnc=ShortcutEncryption.encrypt(cmdStr, keys);
      }
      catch (GeneralSecurityException e)
      {
        Log.e(TermDebug.LOG_TAG, "Shortcut encryption failed: " + e.toString());
        throw new RuntimeException(e);
      }
      Intent target=  new Intent().setClass(context, RunShortcut.class);
             target.setAction(RunShortcut.ACTION_RUN_SHORTCUT);
             target.putExtra(RunShortcut.EXTRA_SHORTCUT_COMMAND, cmdEnc);
             target.putExtra(RunShortcut.EXTRA_WINDOW_HANDLE, shortcutName);
             target.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      Intent wrapper= new Intent();
             wrapper.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
             wrapper.putExtra(Intent.EXTRA_SHORTCUT_INTENT, target);
             if(shortcutName!=null && !shortcutName.equals(""))
             {
               wrapper.putExtra(Intent.EXTRA_SHORTCUT_NAME, shortcutName);
             }
             if(shortcutText!=null && !shortcutText.equals(""))
             {
               wrapper.putExtra(
                 Intent.EXTRA_SHORTCUT_ICON
               , TextIcon.getTextIcon(
                   shortcutText
                 , shortcutColor
                 , 96
                 , 96
                 )
               );
             }
             else
             {
               wrapper.putExtra(
                 Intent.EXTRA_SHORTCUT_ICON_RESOURCE
               , Intent.ShortcutIconResource.fromContext(context, jackpal.androidterm.R.drawable.ic_launcher)
               );
             }
      setResult(RESULT_OK, wrapper);
      finish();
    }
  //////////////////////////////////////////////////////////////////////
  protected void onActivityResult(int requestCode, int resultCode, Intent data)
  {
    super.onActivityResult(requestCode, resultCode, data);
    Uri    uri=  null;
    path= null;
    switch(requestCode)
    {
      case OP_MAKE_SHORTCUT:
        if(data!=null && (uri=data.getData())!=null && (path=uri.getPath())!=null)
        {
          SP.edit().putString("lastPath", path).commit();
          et[PATH].setText(path);
          name=path.replaceAll(".*/", "");
          if(et[NAME].getText().toString().equals("")) et[NAME].setText(name);
          if(iconText[0]!=null && iconText[0].equals("")) iconText[0]=name;
        }
        else finish();
        break;
    }
  }
  //////////////////////////////////////////////////////////////////////
}

```

`term/src/main/java/jackpal/androidterm/shortcuts/ColorValue.java`:

```java
//From the desk of Frank P. Westlake; public domain.
package jackpal.androidterm.shortcuts;

import jackpal.androidterm.R;
import jackpal.androidterm.compat.AlertDialogCompat;
import android.app.        AlertDialog;
import android.content.    Context;
import android.content.    DialogInterface;
import android.graphics.   Typeface;
import android.view.       Gravity;
import android.widget.     CheckBox;
import android.widget.     CompoundButton;
import android.widget.     ImageView;
import android.widget.     LinearLayout;
import android.widget.     ScrollView;
import android.widget.     SeekBar;
import android.widget.     TextView;
import android.widget.     EditText;

//////////////////////////////////////////////////////////////////////
public class      ColorValue
       implements CompoundButton.OnCheckedChangeListener
{
  private final Context             context;
  private       EditText            value;
  private final int[]               color=      {0xFF, 0, 0, 0};
  private       boolean             started=    false;
  private       AlertDialogCompat.Builder builder;
  private       boolean             barLock=    false;
  private final boolean[]           locks=      {false, false, false, false};
  private final int                 FP=         LinearLayout.LayoutParams.FILL_PARENT;
  private final int                 WC=         LinearLayout.LayoutParams.WRAP_CONTENT;
  private final ImageView           imgview;
  private final String              result[];
  private       String              imgtext="";

  ////////////////////////////////////////////////////////////
  public ColorValue(Context context, final ImageView imgview, final String result[])
  {
    this.context=context;
    this.imgtext=result[0];
    this.imgview=imgview;
    this.result=result;
    colorValue();
  }
  public void colorValue()
  {
    final int     arraySizes=  4;
    builder=      AlertDialogCompat.newInstanceBuilder(context, AlertDialogCompat.THEME_HOLO_DARK);
    LinearLayout  lv=new LinearLayout(context);
                  lv.setOrientation(LinearLayout.VERTICAL);
    String  lab[]={
      context.getString(R.string.colorvalue_letter_alpha) +" " //"α "
    , context.getString(R.string.colorvalue_letter_red)   +" " //"R "
    , context.getString(R.string.colorvalue_letter_green) +" " //"G "
    , context.getString(R.string.colorvalue_letter_blue)  +" " //"B "
    };
    int     clr[]={0xFFFFFFFF, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF};
    for(int i=0, n=(Integer)imgview.getTag(); i<arraySizes; i++)  color[i]=(n>>(24-i*8))&0xFF;
    TextView  lt=new TextView(context);
              lt.setText(context.getString(R.string.colorvalue_label_lock_button_column));//"LOCK");
              lt.setPadding(lt.getPaddingLeft(), lt.getPaddingTop(), 5, lt.getPaddingBottom());
              lt.setGravity(Gravity.RIGHT);
    value=new EditText(context);
    value.setText(imgtext);
    value.setSingleLine(false);
    value.setGravity(Gravity.CENTER);
    value.setTextColor((Integer)imgview.getTag());
    value.setBackgroundColor((0xFF<<24)|0x007799);
    LinearLayout  vh=new LinearLayout(context);
                  vh.setOrientation(LinearLayout.HORIZONTAL);
                  vh.setGravity(Gravity.CENTER_HORIZONTAL);
                  vh.addView(value);
                  value.setHint(context.getString(R.string.colorvalue_icon_text_entry_hint));//"Enter icon text");
    lv.addView(vh);
    lv.addView(lt);
    final SeekBar     sb[]=        new SeekBar[arraySizes+1];
    final CheckBox    lk[]=        new CheckBox[arraySizes];
    final TextView    hexWindow[]= new TextView[arraySizes];
    for(int i=0; i<arraySizes; i++)
    {
      LinearLayout    lh=new LinearLayout(context);
                      lh.setGravity(Gravity.CENTER_VERTICAL);
      final TextView  tv=new TextView(context);
                      tv.setTypeface(Typeface.MONOSPACE);
                      tv.setText(lab[i]);
                      tv.setTextColor(clr[i]);
      sb[i]=new SeekBar(context);
      sb[i].setMax(0xFF);
      sb[i].setProgress(color[i]);
      sb[i].setSecondaryProgress(color[i]);
      sb[i].setTag(i);
      sb[i].setBackgroundColor(0xFF<<24|(color[i]<<(24-i*8)));
      sb[i].setLayoutParams(new LinearLayout.LayoutParams(WC, WC, 1));
      sb[i].setOnSeekBarChangeListener(
        new SeekBar.OnSeekBarChangeListener()
        {
          public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser)
          {
            doProgressChanged(seekBar, progress, fromUser);
          }
          private void doProgressChanged(SeekBar seekBar, int progress, boolean fromUser)
          {
            if(fromUser && started)
            {
              int  me=(Integer)seekBar.getTag();
              int  k=(color[0]<<24)|(color[1]<<16)|(color[2]<<8)|color[3];
              value.setTextColor(k);
              int  start, end;
              if(barLock && locks[me])  {start=0;  end=arraySizes-1;}
              else  start=end=(Integer)seekBar.getTag();
              for(int  i=start; i<=end; i++)
              {
                if(i==me || (barLock && locks[i]))
                {
                  color[i]=progress;
                  toHexWindow(hexWindow[i], color[i]);
                  sb[i].setBackgroundColor(0xFF<<24|(progress<<(24-i*8)));
                  sb[i].setProgress(progress);
                }
              }
            }
          }
          public void onStartTrackingTouch(SeekBar seekBar)
          {
            doProgressChanged(seekBar, seekBar.getProgress(), true);
          }
          public void  onStopTrackingTouch(SeekBar seekBar)
          {
            doProgressChanged(seekBar, seekBar.getProgress(), true);
          }
        }
      );
      lk[i]=new CheckBox(context);
      lk[i].setLayoutParams(new LinearLayout.LayoutParams(WC, WC, 0));
      lk[i].setOnCheckedChangeListener(this);
      lk[i].setTag(i);
      lh.addView(tv);
      lh.addView(sb[i]);
      lh.addView(lk[i]);
      lv.addView(lh, FP, WC);
    }
{//Evaluating hex windows.
  LinearLayout    lh=new LinearLayout(context);
  lh.setGravity(Gravity.CENTER);
  for(int i=0; i<arraySizes; i++)
  {
    hexWindow[i]=new TextView(context);
    toHexWindow(hexWindow[i], color[i]);
    lh.addView(hexWindow[i]);
  }
  lv.addView(lh);
}//Evaluating hex windows.
    ScrollView    sv=new ScrollView(context);
                  sv.addView(lv);
    builder.setView(sv);
    DialogInterface.OnClickListener ocl=new DialogInterface.OnClickListener()
    {
      public void onClick(DialogInterface dialog, int which)
      {
        buttonHit(which, (color[0]<<24)|(color[1]<<16)|(color[2]<<8)|color[3]);
      }
    };
    String Title = context.getString(R.string.addshortcut_make_text_icon);
    builder.setTitle(Title);
    builder.setPositiveButton(android.R.string.yes,    ocl);
    builder.setNegativeButton(android.R.string.cancel, ocl);
    builder.show();
    started=true;
  }
  //////////////////////////////////////////////////////////////////////
  public void toHexWindow(TextView tv, int k)
  {
    String  HEX="0123456789ABCDEF";
    String  s="";
    int   n=8;
    k&=(1L<<8)-1L;
    for(n-=4; n>=0; n-=4) s+=HEX.charAt((k>>n)&0xF);
    tv.setText(s);
  }
  ////////////////////////////////////////////////////////////
  public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
  {
    int  view=(Integer)buttonView.getTag();
    locks[view]=isChecked;
    barLock=false;
    for(int i=0; i<locks.length; i++)  if(locks[i])  barLock=true;
  }
  ////////////////////////////////////////////////////////////
  private void buttonHit(int hit, int color)
  {
    switch(hit)
    {
      case AlertDialog.BUTTON_NEGATIVE:  //  CANCEL
        return;
      case AlertDialog.BUTTON_POSITIVE:  //  OK == set
        imgtext=value.getText().toString();
        result[1]=imgtext;
        imgview.setTag(color);
        if(!imgtext.equals(""))
        {
          imgview.setImageBitmap(
            TextIcon.getTextIcon(
              imgtext
            , color
            , 96
            , 96
            )
          );
        }
        return;
    }
  }
  ////////////////////////////////////////////////////////////
}

```

`term/src/main/java/jackpal/androidterm/shortcuts/FSNavigator.java`:

```java
//From the desk of Frank P. Westlake; public domain.
package jackpal.androidterm.shortcuts;

import android.content.             Intent;
import android.content.             SharedPreferences;
import android.graphics.            Typeface;
import android.net.                 Uri;
import android.os.                  Environment;
import android.preference.          PreferenceManager;
import android.view.                Gravity;
import android.view.                KeyEvent;
import android.view.                Menu;
import android.view.                MenuItem;
import android.view.                View;
import android.widget.              EditText;
import android.widget.              HorizontalScrollView;
import android.widget.              ImageView;
import android.widget.              LinearLayout;
import android.widget.              ScrollView;
import android.widget.              TextView;
import android.widget.              Toast;
import java.io.                     File;
import java.io.                     IOException;
import java.util.                   HashMap;
import jackpal.androidterm.         R;

public class      FSNavigator
       extends    android.app.Activity
{
  private final int                      ACTION_THEME_SWAP=           0x00000100;
  private final int                      BUTTON_SIZE=                 150;
  private android.content.Context        context=                     this;
  private float                          textLg=                      24;
  private int                            theme=                       android.R.style.Theme;
  private SharedPreferences              SP;
  private File                           cd;
  private File                           extSdCardFile;
  private String                         extSdCard;
  private HashMap<Integer, LinearLayout> cachedFileView;
  private HashMap<Integer, LinearLayout> cachedDirectoryView;
  private HashMap<Integer, TextView>     cachedDividerView;
  private int                            countFileView;
  private int                            countDirectoryView;
  private int                            countDividerView;
  private LinearLayout                   contentView;
  private LinearLayout                   titleView;
  private LinearLayout                   pathEntryView;

  ////////////////////////////////////////////////////////////
  public void onCreate(android.os.Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    setTitle(getString(R.string.fsnavigator_title));//"File Selector");
    SP=PreferenceManager.getDefaultSharedPreferences(context);
    theme=SP.getInt("theme", theme);
    setTheme(theme);
    getWindow().setSoftInputMode(android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);

    Intent intent= getIntent();
    extSdCardFile=Environment.getExternalStorageDirectory();
    extSdCard=getCanonicalPath(extSdCardFile);
    Uri    uri=intent.getData();
    String path=uri==null?null:uri.getPath();
    if(null == path || null==(chdir(path))) chdir(extSdCard);
    if(intent.hasExtra("title"))           setTitle(intent.getStringExtra("title"));

    titleView=           directoryEntry("..");
    pathEntryView=       fileEntry(null);
    contentView=         makeContentView();
    cachedDirectoryView= new HashMap<Integer, LinearLayout>();
    cachedFileView=      new HashMap<Integer, LinearLayout>();
    cachedDividerView=   new HashMap<Integer, TextView>();
  }
  ////////////////////////////////////////////////////////////
  public void onPause()
  {
    super.onPause();
    doPause();
  }
  ////////////////////////////////////////////////////////////
  private void doPause()
  {
    SP.edit().putString("lastDirectory", getCanonicalPath(cd)).commit();
  }
  ////////////////////////////////////////////////////////////
  public void onResume()
  {
    super.onResume();
    doResume();
  }
  ////////////////////////////////////////////////////////////
  private void doResume()
  {
    makeView();
  }
  ////////////////////////////////////////////////////////////
  private void swapTheme()
  {
    switch(theme)
    {
      case android.R.style.Theme:       theme=android.R.style.Theme_Light; break;
      case android.R.style.Theme_Light: theme=android.R.style.Theme;       break;
      default: return;
    }
    SP.edit().putInt("theme", theme).commit();
    startActivityForResult(getIntent().addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT), -1);
    finish();
  }
  ////////////////////////////////////////////////////////////
  private String ifAvailable(String goTo)
  {
    if(goTo.startsWith(extSdCard))
    {
      String s=Environment.getExternalStorageState();
      if(s.equals(Environment.MEDIA_MOUNTED)
      || s.equals(Environment.MEDIA_MOUNTED_READ_ONLY)
      )
      {
        return(goTo);
      }
      toast(getString(R.string.fsnavigator_no_external_storage), 1);//"External storage not available", 1);
      return(extSdCard);
    }
    return(goTo);
  }
  ////////////////////////////////////////////////////////////
  private File chdir(File file)
  {
    String path=ifAvailable(getCanonicalPath(file));
    System.setProperty("user.dir", path);
    return(cd=new File(path));
  }
  private File chdir(String path)
  {
    return(chdir(new File(path)));
  }
  ////////////////////////////////////////////////////////////
  private TextView entryDividerH()
  {
    TextView tv;
    if(countDividerView<cachedDividerView.size())
    {
      tv=cachedDividerView.get(countDividerView);
    }
    else
    {
      tv=new TextView(context);
      tv.setLayoutParams(
        new LinearLayout.LayoutParams(
          LinearLayout.LayoutParams.FILL_PARENT
        , 1
        , 1
        )
      );
      cachedDividerView.put(countDividerView, tv);
    }
    ++countDividerView;
    return(tv);
  }
  ////////////////////////////////////////////////////////////
  View.OnClickListener fileListener=new View.OnClickListener()
  {
    public void onClick(View view)
    {
      String path=(String)view.getTag();
      if(path!=null)
      {
        setResult(RESULT_OK, getIntent().setData(Uri.fromFile(new File(cd, path))));
        finish();
      }
    }
  };
  ////////////////////////////////////////////////////////////
  private LinearLayout fileView(boolean entryWindow)
  {
    LinearLayout  ll=new LinearLayout(context);
                  ll.setLayoutParams(
                    new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.FILL_PARENT
                    , LinearLayout.LayoutParams.WRAP_CONTENT
                    , 1
                    )
                  );
                  ll.setOrientation(LinearLayout.HORIZONTAL);
                  ll.setGravity(android.view.Gravity.FILL);
    final TextView tv;
    if(entryWindow)
    {
      tv=new EditText(context);
      tv.setHint(getString(R.string.fsnavigator_optional_enter_path));
      tv.setLayoutParams(
        new LinearLayout.LayoutParams(
          LinearLayout.LayoutParams.FILL_PARENT
        , LinearLayout.LayoutParams.FILL_PARENT
        , 2
        )
      );
      tv.setOnKeyListener(
        new EditText.OnKeyListener()
        {
          public boolean onKey(View v, int keyCode, KeyEvent event)
          {
            if(keyCode==KeyEvent.KEYCODE_ENTER)
            {
              String path=tv.getText().toString();
              File file=new File(getCanonicalPath(path));
              chdir(file.getParentFile()==null?file:file.getParentFile());
              if(file.isFile())
              {
                setResult(RESULT_OK, getIntent().setData(Uri.fromFile(file)));
                finish();
              }
              else
              {
                chdir(file);
                makeView();
              }
              return(true);
            }
            return(false);
          }
        }
      );
      ll.addView(tv);
    }
    else
    {
      tv=new TextView(context);
      tv.setClickable(true);
      tv.setLongClickable(true);
      tv.setOnClickListener(fileListener);
      tv.setLayoutParams(
        new LinearLayout.LayoutParams(
          LinearLayout.LayoutParams.FILL_PARENT
        , LinearLayout.LayoutParams.FILL_PARENT
        , 1
        )
      );
      HorizontalScrollView hv=new HorizontalScrollView(context);
      hv.setFillViewport(true);
      hv.setLayoutParams(
        new LinearLayout.LayoutParams(
          LinearLayout.LayoutParams.FILL_PARENT
        , BUTTON_SIZE
        , 7
        )
      );
      hv.addView(tv);
      ll.addView(hv);
    }
    tv.setFocusable(true);
    tv.setSingleLine();
    tv.setTextSize(textLg);
    tv.setTypeface(Typeface.SERIF, Typeface.BOLD);
    tv.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
    tv.setPadding(10, 5, 10, 5);
    tv.setId(R.id.textview);//1);

    return(ll);
  }
  ////////////////////////////////////////////////////////////
  private LinearLayout fileEntry(final String entry)
  {
    LinearLayout ll;
    if(entry==null)                           ll=fileView(entry==null);
    else
    {
      if(countFileView<cachedFileView.size()) ll=cachedFileView.get(countFileView);
      else                                    cachedFileView.put(countFileView, ll=fileView(entry==null));
      ++countFileView;
    }
    TextView     tv=(TextView)ll.findViewById(R.id.textview);
                 tv.setText(entry==null?"":entry);
                 tv.setTag(entry==null?"":entry);
    return(ll);
  }
  ////////////////////////////////////////////////////////////
  private ImageView imageViewFolder(boolean up)
  {
    ImageView b1=new ImageView(context);
              b1.setClickable(true);
              b1.setFocusable(true);
              b1.setId(R.id.imageview);
              b1.setLayoutParams(
                new LinearLayout.LayoutParams(
                  120
                , 120
                , 1
                )
              );
              b1.setImageResource(up?R.drawable.ic_folderup:R.drawable.ic_folder);
              b1.setOnClickListener(directoryListener);
              b1.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
    return(b1);
  }
  ////////////////////////////////////////////////////////////
  View.OnClickListener directoryListener=new View.OnClickListener()
  {
    public void onClick(View view)
    {
      String path=(String)view.getTag();
      if(path!=null)
      {
        File file=new File(path);
        if(file.isFile())
        {
          setResult(RESULT_OK, getIntent().setData(Uri.fromFile(file)));
          finish();
        }
        else chdir(file);
        makeView();
      }
    }
  };
  ////////////////////////////////////////////////////////////
  private LinearLayout directoryView(boolean up)
  {
    ImageView             b1=imageViewFolder(up);
    TextView              tv=new TextView(context);
    if(up)                tv.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);//Gravity.CENTER);
    else                  tv.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
                          tv.setClickable(true);
                          tv.setLongClickable(true);
                          tv.setFocusable(true);
                          tv.setOnClickListener(directoryListener);
                          tv.setMaxLines(1);
                          tv.setTextSize(textLg);
                          tv.setPadding(10, 5, 10, 5);
                          tv.setId(R.id.textview);
                          tv.setLayoutParams(
                            new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.FILL_PARENT
                            , BUTTON_SIZE
                            , 1
                            )
                          );
    HorizontalScrollView  hv=new HorizontalScrollView(context);
                          hv.addView(tv);
                          hv.setFillViewport(true);
                          hv.setFocusable(true);
                          hv.setOnClickListener(directoryListener);
                          hv.setLayoutParams(
                            new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.FILL_PARENT
                            , BUTTON_SIZE
                            , 7
                            )
                          );
    LinearLayout          ll=new LinearLayout(context);
                          ll.setLayoutParams(
                            new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.FILL_PARENT
                            , BUTTON_SIZE
                            , 2
                            )
                          );
                          ll.setOrientation(LinearLayout.HORIZONTAL);
                          ll.setGravity(android.view.Gravity.FILL);
                          ll.setOnClickListener(directoryListener);
                          ll.addView(b1);
                          ll.addView(hv);

    return(ll);
  }
  ////////////////////////////////////////////////////////////
  private LinearLayout directoryEntry(final String name)
  {
    boolean up=name.equals("..");
    LinearLayout ll;
    if(up)                                              {ll=directoryView(up);}
    else
    {
      if(countDirectoryView<cachedDirectoryView.size()) {ll=                   cachedDirectoryView.get(countDirectoryView);}
      else                                              {ll=directoryView(up); cachedDirectoryView.put(countDirectoryView, ll);}
      ++countDirectoryView;
    }

    TextView     tv=((TextView)ll.findViewById(R.id.textview));
                 tv.setTag(name);
                 tv.setText(up  ? "["+cd.getPath()+"]"
                                : name
                 );
    ((ImageView)ll.findViewById(R.id.imageview)).setTag(name);
    return(ll);
  }
  ////////////////////////////////////////////////////////////
  public boolean onKeyUp(int keyCode, KeyEvent event)
  {
    if((keyCode == KeyEvent.KEYCODE_BACK)) {finish(); return(true);}
    else return(super.onKeyUp(keyCode, event));
  }
  ////////////////////////////////////////////////////////////
  private LinearLayout makeContentView()
  {
    final LinearLayout  ll=new LinearLayout(context);
                        ll.setLayoutParams(
                          new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.FILL_PARENT
                          , LinearLayout.LayoutParams.WRAP_CONTENT
                          , 1
                          )
                        );
                        ll.setId(R.id.mainview);
                        ll.setOrientation(LinearLayout.VERTICAL);
                        ll.setGravity(android.view.Gravity.FILL);
    final ScrollView    sv=new ScrollView(context);
                        sv.setId(R.id.scrollview);
                        sv.setLayoutParams(
                          new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.FILL_PARENT
                          , LinearLayout.LayoutParams.WRAP_CONTENT
                          , 1
                          )
                        );
                        sv.addView(ll);
    final LinearLayout  bg=new LinearLayout(context);
                        bg.setLayoutParams(
                          new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.FILL_PARENT
                          , LinearLayout.LayoutParams.WRAP_CONTENT
                          , 1
                          )
                        );
                        bg.setOrientation(LinearLayout.VERTICAL);
                        bg.setGravity(android.view.Gravity.FILL);
                        bg.setTag(ll);
                        bg.addView(
                          titleView
                        , android.view.ViewGroup.LayoutParams.FILL_PARENT, android.view.ViewGroup.LayoutParams.WRAP_CONTENT
                        );
                        bg.addView(sv);
                        bg.addView(
                          pathEntryView
                        , android.view.ViewGroup.LayoutParams.FILL_PARENT, android.view.ViewGroup.LayoutParams.WRAP_CONTENT
                        );
    return(bg);
  }
  ////////////////////////////////////////////////////////////
  private void makeView()
  {
    countDirectoryView=countFileView=0;
    ScrollView   sv=(ScrollView)contentView.findViewById(R.id.scrollview);
    LinearLayout ll=(LinearLayout)sv.findViewById(R.id.mainview);
                 ll.removeAllViews();
    if(cd == null) chdir("/");
    String path=getCanonicalPath(cd);

    if(path.equals("")) {chdir(path="/");}
    if(path.equals("/"))
    {
      titleView.setVisibility(View.GONE);
    }
    else
    {
      titleView.setVisibility(View.VISIBLE);
      titleView.requestLayout();
      ((TextView)titleView.findViewById(R.id.textview)).setText("["+cd.getPath()+"]");
    }

    String zd[]=cd.list(new java.io.FilenameFilter(){public boolean accept(File file, String name){return(  new File(file, name).isDirectory() );}});
    if(zd!=null)
    {
      java.util.Arrays.sort(zd, 0, zd.length, stringSortComparator);
      for(int i=0, n=zd.length; i<n; i++)
      {
        if(zd[i].equals("."))  continue;
        ll.addView(directoryEntry(zd[i]));
        ll.addView(entryDividerH());
      }
    }
    String zf[]=cd.list(new java.io.FilenameFilter(){public boolean accept(File file, String name){return(!(new File(file, name).isDirectory()));}});
    if(zf!=null)
    {
      java.util.Arrays.sort(zf, 0, zf.length, stringSortComparator);
      for(int i=0, n=zf.length; i<n; i++)
      {
        ll.addView(fileEntry(zf[i]));
        ll.addView(entryDividerH());
      }
    }
    ((TextView)pathEntryView.findViewById(R.id.textview)).setText("");
    sv.scrollTo(0, 0);
//    titleView.setSelected(true);
    setContentView(contentView);
  }
  //////////////////////////////////////////////////////////////////////
  java.util.Comparator<String> stringSortComparator=new java.util.Comparator<String>()
  {
    public int compare(String a, String b) {return(a.toLowerCase().compareTo(b.toLowerCase()));}
  };
  //////////////////////////////////////////////////////////////////////
  String getCanonicalPath(String path)
  {
    return(getCanonicalPath(new File(path)));
  }
  String getCanonicalPath(File file)
  {
    try{return(file.getCanonicalPath());}catch(IOException e){return(file.getPath());}
  }
  //////////////////////////////////////////////////////////////////////
  public boolean onCreateOptionsMenu(Menu menu)
//  public boolean onPrepareOptionsMenu(Menu menu)
  {
    super.onCreateOptionsMenu(menu);
//    super.onPrepareOptionsMenu(menu);    menu.clear();
    menu.add(0, ACTION_THEME_SWAP,  0,  getString(R.string.fsnavigator_change_theme));//"Change theme");
    return(true);
  }
  //////////////////////////////////////////////////////////////////////
  public boolean onOptionsItemSelected(MenuItem item)
  {
    super.onOptionsItemSelected(item);
    return(doOptionsItem(item.getItemId()));
  }
  //////////////////////////////////////////////////////////////////////
  private boolean doOptionsItem(int itemId)
  {
    switch(itemId)
    {
      case ACTION_THEME_SWAP: swapTheme();  return(true);
    }
    return(false);
  }
  //////////////////////////////////////////////////////////////////////
//  private void toast(final String message){toast(message, 0);}
  private void toast(final String message, final int duration)
  {
    runOnUiThread(
      new Runnable()
      {
        public void run()
        {
          Toast.makeText(context, message, duration == 0 ?Toast.LENGTH_SHORT: Toast.LENGTH_LONG).show();
        }
      }
    );
  }
  //////////////////////////////////////////////////////////////////////
}

```

`term/src/main/java/jackpal/androidterm/shortcuts/TextIcon.java`:

```java
package jackpal.androidterm.shortcuts;

import android.graphics.  Bitmap;
import android.graphics.  Bitmap.Config;
import android.graphics.  Canvas;
import android.graphics.  Paint;
import android.graphics.  Paint.Align;
import android.graphics.  Rect;
import android.util.      FloatMath;
import java.lang.         Float;

public class TextIcon
{
  ////////////////////////////////////////////////////////////
  public static Bitmap getTextIcon(String text, int color, int width, int height)
  {
    text=   text.    trim();
    String  lines[]= text.split("\\s*\n\\s*");
    int     nLines=  lines.length;
    Rect    R=       new Rect();
    Paint   p=       new Paint(Paint.ANTI_ALIAS_FLAG);
            p.       setShadowLayer(2, 10, 10, 0xFF000000);
            p.       setColor(color);
            p.       setSubpixelText(true);
            p.       setTextSize(256);
            p.       setTextAlign(Align.CENTER);
    float   HH[]=    new float[nLines];
    float   H=       0f;
    float   W=       0f;
    for(int i=0; i<nLines; ++i)
    {
            p.       getTextBounds(lines[i], 0, lines[i].length(), R);
      float h=       Float.valueOf(Math.abs(R.top-R.bottom));
      float w=       Float.valueOf(Math.abs(R.right-R.left));
      if(nLines>1)   h+=0.1f*h; // Add space between lines.
      HH[i]=         h;
      H+=            h;
      if(w>W)        W=w;
    }
    float   f=       ((float)width)*H/((float)height);
    int     hBitmap= (int)H;
    int     wBitmap= (int)W;
    if(W<f) {wBitmap=(int)FloatMath.ceil(f); hBitmap=(int)FloatMath.ceil(H);}
    else    {wBitmap=(int)FloatMath.ceil(W); hBitmap=(int)FloatMath.ceil(height*wBitmap/width);}

    Bitmap  b=       Bitmap.createBitmap(wBitmap, hBitmap, Config.ARGB_8888);
            b.       setDensity(Bitmap.DENSITY_NONE);
    Canvas  c=       new Canvas(b);

    W=wBitmap/2f;
    float top=    hBitmap/2f-H/2f+HH[0]/2f;
    for(int i=0; i<nLines; ++i)
    {
      top+= HH[i]/2f;
      c.    drawText(lines[i], W, top, p);
      top+= HH[i]/2f;
    }
    return(
      Bitmap.createScaledBitmap(
        b
      , width
      , height
      , true
      )
    );
  }
  ////////////////////////////////////////////////////////////
}

```

`term/src/main/java/jackpal/androidterm/util/SessionList.java`:

```java
/*
 * Copyright (C) 2011 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.util;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Collection;

import jackpal.androidterm.emulatorview.TermSession;
import jackpal.androidterm.emulatorview.UpdateCallback;

/**
 * An ArrayList of TermSessions which allows users to register callbacks in
 * order to be notified when the list is changed.
 */
@SuppressWarnings("serial")
public class SessionList extends ArrayList<TermSession>
{
    LinkedList<UpdateCallback> callbacks = new LinkedList<UpdateCallback>();
    LinkedList<UpdateCallback> titleChangedListeners = new LinkedList<UpdateCallback>();
    UpdateCallback mTitleChangedListener = new UpdateCallback() {
        public void onUpdate() {
            notifyTitleChanged();
        }
    };

    public SessionList() {
        super();
    }

    public SessionList(int capacity) {
        super(capacity);
    }

    public void addCallback(UpdateCallback callback) {
        callbacks.add(callback);
        callback.onUpdate();
    }

    public boolean removeCallback(UpdateCallback callback) {
        return callbacks.remove(callback);
    }

    private void notifyChange() {
        for (UpdateCallback callback : callbacks) {
            callback.onUpdate();
        }
    }

    public void addTitleChangedListener(UpdateCallback listener) {
        titleChangedListeners.add(listener);
        listener.onUpdate();
    }

    public boolean removeTitleChangedListener(UpdateCallback listener) {
        return titleChangedListeners.remove(listener);
    }

    private void notifyTitleChanged() {
        for (UpdateCallback listener : titleChangedListeners) {
            listener.onUpdate();
        }
    }

    @Override
    public boolean add(TermSession object) {
        boolean result = super.add(object);
        object.setTitleChangedListener(mTitleChangedListener);
        notifyChange();
        return result;
    }

    @Override
    public void add(int index, TermSession object) {
        super.add(index, object);
        object.setTitleChangedListener(mTitleChangedListener);
        notifyChange();
    }

    @Override
    public boolean addAll(Collection <? extends TermSession> collection) {
        boolean result = super.addAll(collection);
        for (TermSession session : collection) {
            session.setTitleChangedListener(mTitleChangedListener);
        }
        notifyChange();
        return result;
    }

    @Override
    public boolean addAll(int index, Collection <? extends TermSession> collection) {
        boolean result = super.addAll(index, collection);
        for (TermSession session : collection) {
            session.setTitleChangedListener(mTitleChangedListener);
        }
        notifyChange();
        return result;
    }

    @Override
    public void clear() {
        for (TermSession session : this) {
            session.setTitleChangedListener(null);
        }
        super.clear();
        notifyChange();
    }

    @Override
    public TermSession remove(int index) {
        TermSession object = super.remove(index);
        if (object != null) {
            object.setTitleChangedListener(null);
            notifyChange();
        }
        return object;
    }

    @Override
    public boolean remove(Object object) {
        boolean result = super.remove(object);
        if (result && object instanceof TermSession) {
            ((TermSession) object).setTitleChangedListener(null);
            notifyChange();
        }
        return result;
    }

    @Override
    public TermSession set(int index, TermSession object) {
        TermSession old = super.set(index, object);
        object.setTitleChangedListener(mTitleChangedListener);
        if (old != null) {
            old.setTitleChangedListener(null);
        }
        notifyChange();
        return old;
    }
}

```

`term/src/main/java/jackpal/androidterm/util/ShortcutEncryption.java`:

```java
/*
 * Copyright (C) 2015 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.util;

import jackpal.androidterm.compat.Base64;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CodingErrorAction;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.util.regex.Pattern;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Implementation of a simple authenticated encryption scheme suitable for
 * TEA shortcuts.
 *
 * The goals of the encryption are as follows:
 *
 *   (1) An unauthorized actor must not be able to create a valid text with
 *       contents of his choice;
 *   (2) An unauthorized actor must not be able to modify an existing text to
 *       change its contents in any way;
 *   (3) An unauthorized actor must not be able to discover the contents of
 *       an existing text.
 *
 * Conditions (1) and (2) ensure that an attacker cannot send commands of his
 * choosing to TEA via the shortcut mechanism, while condition (3) ensures that
 * an attacker cannot learn what commands are being sent via shortcuts even if
 * he can read saved shortcuts or sniff Android intents.
 *
 * We ensure these conditions using two cryptographic building blocks:
 *
 *   * a symmetric cipher (currently AES in CBC mode using PKCS#5 padding),
 *     which prevents someone without the encryption key from reading the
 *     contents of the shortcut; and
 *   * a message authentication code (currently HMAC-SHA256), which proves that
 *     the shortcut was created by someone with the MAC key.
 *
 * The security of these depends on the security of the keys, which must be
 * kept secret.  In this application, the keys are randomly generated and stored
 * in the application's private shared preferences.
 *
 * The encrypted string output by this scheme is of the form:
 *
 *     mac + ":" + iv + ":" cipherText
 *
 * where:
 *
 *   * cipherText is the Base64-encoded result of encrypting the data
 *     using the encryption key;
 *   * iv is a Base64-encoded, non-secret random number used as an
 *     initialization vector for the encryption algorithm;
 *   * mac is the Base64 encoding of MAC(MAC-key, iv + ":" + cipherText).
 */
public final class ShortcutEncryption {
    public static final String ENC_ALGORITHM = "AES";
    public static final String ENC_SYSTEM = ENC_ALGORITHM + "/CBC/PKCS5Padding";
    public static final int ENC_BLOCKSIZE = 16;
    public static final String MAC_ALGORITHM = "HmacSHA256";
    public static final int KEYLEN = 128;
    public static final int BASE64_DFLAGS = Base64.DEFAULT;
    public static final int BASE64_EFLAGS = Base64.NO_PADDING | Base64.NO_WRAP;

    private static final String SHORTCUT_KEYS_PREF = "shortcut_keys";

    private static final Pattern COLON = Pattern.compile(":");

    public static final class Keys {
        private final SecretKey encKey;
        private final SecretKey macKey;

        public Keys(SecretKey encKey, SecretKey macKey) {
            this.encKey = encKey;
            this.macKey = macKey;
        }

        public SecretKey getEncKey() {
            return encKey;
        }

        public SecretKey getMacKey() {
            return macKey;
        }

        /**
         * Outputs the keys as a string of the form
         *
         *     encKey + ":" + macKey
         *
         * where encKey and macKey are the Base64-encoded encryption and MAC
         * keys.
         */
        public String encode() {
            return encodeToBase64(encKey.getEncoded()) + ":" + encodeToBase64(macKey.getEncoded());
        }

        /**
         * Creates a new Keys object by decoding a string of the form output
         * from encode().
         */
        public static Keys decode(String encodedKeys) {
            String[] keys = COLON.split(encodedKeys);
            if (keys.length != 2) {
                throw new IllegalArgumentException("Invalid encoded keys!");
            }

            SecretKey encKey = new SecretKeySpec(decodeBase64(keys[0]), ENC_ALGORITHM);
            SecretKey macKey = new SecretKeySpec(decodeBase64(keys[1]), MAC_ALGORITHM);
            return new Keys(encKey, macKey);
        }
    }

    /**
     * Retrieves the shortcut encryption keys from preferences.
     */
    public static Keys getKeys(Context ctx) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        String keyEnc = prefs.getString(SHORTCUT_KEYS_PREF, null);
        if (keyEnc == null) {
            return null;
        }

        try {
            return Keys.decode(keyEnc);
        } catch (IllegalArgumentException e) {
            return null;
        }
    }

    /**
     * Saves shortcut encryption keys to preferences.
     */
    public static void saveKeys(Context ctx, Keys keys) {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);

        SharedPreferences.Editor edit = prefs.edit();
        edit.putString(SHORTCUT_KEYS_PREF, keys.encode());
        edit.commit();
    }

    /**
     * Generates new secret keys suitable for the encryption scheme described
     * above.
     *
     * @throws GeneralSecurityException if an error occurs during key generation.
     */
    public static Keys generateKeys() throws GeneralSecurityException {
        KeyGenerator gen = KeyGenerator.getInstance(ENC_ALGORITHM);
        gen.init(KEYLEN);
        SecretKey encKey = gen.generateKey();

        /* XXX: It's probably unnecessary to create a different keygen for the
         * MAC, but JCA's API design suggests we should just in case ... */
        gen = KeyGenerator.getInstance(MAC_ALGORITHM);
        gen.init(KEYLEN);
        SecretKey macKey = gen.generateKey();

        return new Keys(encKey, macKey);
    }

    /**
     * Decrypts a string encrypted using this algorithm and verifies that the
     * contents have not been tampered with.
     *
     * @param encrypted The string to decrypt, in the format described above.
     * @param keys The keys to verify and decrypt with.
     * @return The decrypted data.
     *
     * @throws GeneralSecurityException if the data is invalid, verification fails, or an error occurs during decryption.
     */
    public static String decrypt(String encrypted, Keys keys) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(ENC_SYSTEM);
        String[] data = COLON.split(encrypted);
        if (data.length != 3) {
            throw new GeneralSecurityException("Invalid encrypted data!");
        }
        String mac = data[0];
        String iv = data[1];
        String cipherText = data[2];

        // Verify that the ciphertext and IV haven't been tampered with first
        String dataToAuth = iv + ":" + cipherText;
        if (!computeMac(dataToAuth, keys.getMacKey()).equals(mac)) {
            throw new GeneralSecurityException("Incorrect MAC!");
        }

        // Decrypt the ciphertext
        byte[] ivBytes = decodeBase64(iv);
        cipher.init(Cipher.DECRYPT_MODE, keys.getEncKey(), new IvParameterSpec(ivBytes));
        byte[] bytes = cipher.doFinal(decodeBase64(cipherText));

        // Decode the plaintext bytes into a String
        CharsetDecoder decoder = Charset.defaultCharset().newDecoder();
        decoder.onMalformedInput(CodingErrorAction.REPORT);
        decoder.onUnmappableCharacter(CodingErrorAction.REPORT);
        /*
         * We are coding UTF-8 (guaranteed to be the default charset on
         * Android) to Java chars (UTF-16, 2 bytes per char).  For valid UTF-8
         * sequences, then:
         *     1 byte in UTF-8 (US-ASCII) -> 1 char in UTF-16
         *     2-3 bytes in UTF-8 (BMP)   -> 1 char in UTF-16
         *     4 bytes in UTF-8 (non-BMP) -> 2 chars in UTF-16 (surrogate pair)
         * The decoded output is therefore guaranteed to fit into a char
         * array the same length as the input byte array.
         */
        CharBuffer out = CharBuffer.allocate(bytes.length);
        CoderResult result = decoder.decode(ByteBuffer.wrap(bytes), out, true);
        if (result.isError()) {
            /* The input was supposed to be the result of encrypting a String,
             * so something is very wrong if it cannot be decoded into one! */
            throw new GeneralSecurityException("Corrupt decrypted data!");
        }
        decoder.flush(out);
        return out.flip().toString();
    }

    /**
     * Encrypts and authenticates a string using the algorithm described above.
     *
     * @param data The string containing the data to encrypt.
     * @param keys The keys to encrypt and authenticate with.
     * @return The encrypted data.
     *
     * @throws GeneralSecurityException if an error occurs during encryption.
     */
    public static String encrypt(String data, Keys keys) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(ENC_SYSTEM);

        // Generate a random IV
        SecureRandom rng = new SecureRandom();
        byte[] ivBytes = new byte[ENC_BLOCKSIZE];
        rng.nextBytes(ivBytes);
        String iv = encodeToBase64(ivBytes);

        // Encrypt
        cipher.init(Cipher.ENCRYPT_MODE, keys.getEncKey(), new IvParameterSpec(ivBytes));
        byte[] bytes = data.getBytes();
        String cipherText = encodeToBase64(cipher.doFinal(bytes));

        // Calculate the MAC for the ciphertext and IV
        String dataToAuth = iv + ":" + cipherText;
        String mac = computeMac(dataToAuth, keys.getMacKey());

        return mac + ":" + dataToAuth;
    }

    /**
     * Computes the Base64-encoded Message Authentication Code for the
     * data using the provided key.
     *
     * @throws GeneralSecurityException if an error occurs during MAC computation.
     */
    private static String computeMac(String data, SecretKey key) throws GeneralSecurityException {
        Mac mac = Mac.getInstance(MAC_ALGORITHM);
        mac.init(key);
        byte[] macBytes = mac.doFinal(data.getBytes());
        return encodeToBase64(macBytes);
    }

    /**
     * Encodes binary data to Base64 using the settings specified by
     * BASE64_EFLAGS.
     *
     * @return A String with the Base64-encoded data.
     */
    private static String encodeToBase64(byte[] data) {
        return Base64.encodeToString(data, BASE64_EFLAGS);
    }

    /**
     * Decodes Base64-encoded binary data using the settings specified by
     * BASE64_DFLAGS.
     *
     * @param data A String with the Base64-encoded data.
     * @return A newly-allocated byte[] array with the decoded data.
     */
    private static byte[] decodeBase64(String data) {
        return Base64.decode(data, BASE64_DFLAGS);
    }

    // Prevent instantiation
    private ShortcutEncryption() {
        throw new UnsupportedOperationException();
    }
}

```

`term/src/main/java/jackpal/androidterm/util/TermSettings.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jackpal.androidterm.util;

import jackpal.androidterm.R;
import jackpal.androidterm.compat.AndroidCompat;

import android.content.SharedPreferences;
import android.content.res.Resources;
import android.view.KeyEvent;

/**
 * Terminal emulator settings
 */
public class TermSettings {
    private SharedPreferences mPrefs;

    private int mStatusBar;
    private int mActionBarMode;
    private int mOrientation;
    private int mCursorStyle;
    private int mCursorBlink;
    private int mFontSize;
    private int mColorId;
    private boolean mUTF8ByDefault;
    private int mBackKeyAction;
    private int mControlKeyId;
    private int mFnKeyId;
    private int mUseCookedIME;
    private String mShell;
    private String mFailsafeShell;
    private String mInitialCommand;
    private String mTermType;
    private boolean mCloseOnExit;
    private boolean mVerifyPath;
    private boolean mDoPathExtensions;
    private boolean mAllowPathPrepend;
    private String mHomePath;

    private String mPrependPath = null;
    private String mAppendPath = null;

    private boolean mAltSendsEsc;

    private boolean mMouseTracking;

    private boolean mUseKeyboardShortcuts;

    private static final String STATUSBAR_KEY = "statusbar";
    private static final String ACTIONBAR_KEY = "actionbar";
    private static final String ORIENTATION_KEY = "orientation";
    private static final String FONTSIZE_KEY = "fontsize";
    private static final String COLOR_KEY = "color";
    private static final String UTF8_KEY = "utf8_by_default";
    private static final String BACKACTION_KEY = "backaction";
    private static final String CONTROLKEY_KEY = "controlkey";
    private static final String FNKEY_KEY = "fnkey";
    private static final String IME_KEY = "ime";
    private static final String SHELL_KEY = "shell";
    private static final String INITIALCOMMAND_KEY = "initialcommand";
    private static final String TERMTYPE_KEY = "termtype";
    private static final String CLOSEONEXIT_KEY = "close_window_on_process_exit";
    private static final String VERIFYPATH_KEY = "verify_path";
    private static final String PATHEXTENSIONS_KEY = "do_path_extensions";
    private static final String PATHPREPEND_KEY = "allow_prepend_path";
    private static final String HOMEPATH_KEY = "home_path";
    private static final String ALT_SENDS_ESC = "alt_sends_esc";
    private static final String MOUSE_TRACKING = "mouse_tracking";
    private static final String USE_KEYBOARD_SHORTCUTS = "use_keyboard_shortcuts";

    public static final int WHITE               = 0xffffffff;
    public static final int BLACK               = 0xff000000;
    public static final int BLUE                = 0xff344ebd;
    public static final int GREEN               = 0xff00ff00;
    public static final int AMBER               = 0xffffb651;
    public static final int RED                 = 0xffff0113;
    public static final int HOLO_BLUE           = 0xff33b5e5;
    public static final int SOLARIZED_FG        = 0xff657b83;
    public static final int SOLARIZED_BG        = 0xfffdf6e3;
    public static final int SOLARIZED_DARK_FG   = 0xff839496;
    public static final int SOLARIZED_DARK_BG   = 0xff002b36;
    public static final int LINUX_CONSOLE_WHITE = 0xffaaaaaa;

    // foreground color, background color
    public static final int[][] COLOR_SCHEMES = {
        {BLACK,             WHITE},
        {WHITE,             BLACK},
        {WHITE,             BLUE},
        {GREEN,             BLACK},
        {AMBER,             BLACK},
        {RED,               BLACK},
        {HOLO_BLUE,         BLACK},
        {SOLARIZED_FG,      SOLARIZED_BG},
        {SOLARIZED_DARK_FG, SOLARIZED_DARK_BG},
        {LINUX_CONSOLE_WHITE, BLACK}
    };

    public static final int ACTION_BAR_MODE_NONE = 0;
    public static final int ACTION_BAR_MODE_ALWAYS_VISIBLE = 1;
    public static final int ACTION_BAR_MODE_HIDES = 2;
    private static final int ACTION_BAR_MODE_MAX = 2;

    public static final int ORIENTATION_UNSPECIFIED = 0;
    public static final int ORIENTATION_LANDSCAPE = 1;
    public static final int ORIENTATION_PORTRAIT = 2;

    /** An integer not in the range of real key codes. */
    public static final int KEYCODE_NONE = -1;

    public static final int CONTROL_KEY_ID_NONE = 7;
    public static final int[] CONTROL_KEY_SCHEMES = {
        KeyEvent.KEYCODE_DPAD_CENTER,
        KeyEvent.KEYCODE_AT,
        KeyEvent.KEYCODE_ALT_LEFT,
        KeyEvent.KEYCODE_ALT_RIGHT,
        KeyEvent.KEYCODE_VOLUME_UP,
        KeyEvent.KEYCODE_VOLUME_DOWN,
        KeyEvent.KEYCODE_CAMERA,
        KEYCODE_NONE
    };

    public static final int FN_KEY_ID_NONE = 7;
    public static final int[] FN_KEY_SCHEMES = {
        KeyEvent.KEYCODE_DPAD_CENTER,
        KeyEvent.KEYCODE_AT,
        KeyEvent.KEYCODE_ALT_LEFT,
        KeyEvent.KEYCODE_ALT_RIGHT,
        KeyEvent.KEYCODE_VOLUME_UP,
        KeyEvent.KEYCODE_VOLUME_DOWN,
        KeyEvent.KEYCODE_CAMERA,
        KEYCODE_NONE
    };

    public static final int BACK_KEY_STOPS_SERVICE = 0;
    public static final int BACK_KEY_CLOSES_WINDOW = 1;
    public static final int BACK_KEY_CLOSES_ACTIVITY = 2;
    public static final int BACK_KEY_SENDS_ESC = 3;
    public static final int BACK_KEY_SENDS_TAB = 4;
    private static final int BACK_KEY_MAX = 4;

    public TermSettings(Resources res, SharedPreferences prefs) {
        readDefaultPrefs(res);
        readPrefs(prefs);
    }

    private void readDefaultPrefs(Resources res) {
        mStatusBar = Integer.parseInt(res.getString(R.string.pref_statusbar_default));
        mActionBarMode = res.getInteger(R.integer.pref_actionbar_default);
        mOrientation = res.getInteger(R.integer.pref_orientation_default);
        mCursorStyle = Integer.parseInt(res.getString(R.string.pref_cursorstyle_default));
        mCursorBlink = Integer.parseInt(res.getString(R.string.pref_cursorblink_default));
        mFontSize = Integer.parseInt(res.getString(R.string.pref_fontsize_default));
        mColorId = Integer.parseInt(res.getString(R.string.pref_color_default));
        mUTF8ByDefault = res.getBoolean(R.bool.pref_utf8_by_default_default);
        mBackKeyAction = Integer.parseInt(res.getString(R.string.pref_backaction_default));
        mControlKeyId = Integer.parseInt(res.getString(R.string.pref_controlkey_default));
        mFnKeyId = Integer.parseInt(res.getString(R.string.pref_fnkey_default));
        mUseCookedIME = Integer.parseInt(res.getString(R.string.pref_ime_default));
        mFailsafeShell = res.getString(R.string.pref_shell_default);
        mShell = mFailsafeShell;
        mInitialCommand = res.getString(R.string.pref_initialcommand_default);
        mTermType = res.getString(R.string.pref_termtype_default);
        mCloseOnExit = res.getBoolean(R.bool.pref_close_window_on_process_exit_default);
        mVerifyPath = res.getBoolean(R.bool.pref_verify_path_default);
        mDoPathExtensions = res.getBoolean(R.bool.pref_do_path_extensions_default);
        mAllowPathPrepend = res.getBoolean(R.bool.pref_allow_prepend_path_default);
        // the mHomePath default is set dynamically in readPrefs()
        mAltSendsEsc = res.getBoolean(R.bool.pref_alt_sends_esc_default);
        mMouseTracking = res.getBoolean(R.bool.pref_mouse_tracking_default);
        mUseKeyboardShortcuts = res.getBoolean(R.bool.pref_use_keyboard_shortcuts_default);
    }

    public void readPrefs(SharedPreferences prefs) {
        mPrefs = prefs;
        mStatusBar = readIntPref(STATUSBAR_KEY, mStatusBar, 1);
        mActionBarMode = readIntPref(ACTIONBAR_KEY, mActionBarMode, ACTION_BAR_MODE_MAX);
        mOrientation = readIntPref(ORIENTATION_KEY, mOrientation, 2);
        // mCursorStyle = readIntPref(CURSORSTYLE_KEY, mCursorStyle, 2);
        // mCursorBlink = readIntPref(CURSORBLINK_KEY, mCursorBlink, 1);
        mFontSize = readIntPref(FONTSIZE_KEY, mFontSize, 288);
        mColorId = readIntPref(COLOR_KEY, mColorId, COLOR_SCHEMES.length - 1);
        mUTF8ByDefault = readBooleanPref(UTF8_KEY, mUTF8ByDefault);
        mBackKeyAction = readIntPref(BACKACTION_KEY, mBackKeyAction, BACK_KEY_MAX);
        mControlKeyId = readIntPref(CONTROLKEY_KEY, mControlKeyId,
                CONTROL_KEY_SCHEMES.length - 1);
        mFnKeyId = readIntPref(FNKEY_KEY, mFnKeyId,
                FN_KEY_SCHEMES.length - 1);
        mUseCookedIME = readIntPref(IME_KEY, mUseCookedIME, 1);
        mShell = readStringPref(SHELL_KEY, mShell);
        mInitialCommand = readStringPref(INITIALCOMMAND_KEY, mInitialCommand);
        mTermType = readStringPref(TERMTYPE_KEY, mTermType);
        mCloseOnExit = readBooleanPref(CLOSEONEXIT_KEY, mCloseOnExit);
        mVerifyPath = readBooleanPref(VERIFYPATH_KEY, mVerifyPath);
        mDoPathExtensions = readBooleanPref(PATHEXTENSIONS_KEY, mDoPathExtensions);
        mAllowPathPrepend = readBooleanPref(PATHPREPEND_KEY, mAllowPathPrepend);
        mHomePath = readStringPref(HOMEPATH_KEY, mHomePath);
        mAltSendsEsc = readBooleanPref(ALT_SENDS_ESC, mAltSendsEsc);
        mMouseTracking = readBooleanPref(MOUSE_TRACKING, mMouseTracking);
        mUseKeyboardShortcuts = readBooleanPref(USE_KEYBOARD_SHORTCUTS,
                mUseKeyboardShortcuts);
        mPrefs = null;  // we leak a Context if we hold on to this
    }

    private int readIntPref(String key, int defaultValue, int maxValue) {
        int val;
        try {
            val = Integer.parseInt(
                mPrefs.getString(key, Integer.toString(defaultValue)));
        } catch (NumberFormatException e) {
            val = defaultValue;
        }
        val = Math.max(0, Math.min(val, maxValue));
        return val;
    }

    private String readStringPref(String key, String defaultValue) {
        return mPrefs.getString(key, defaultValue);
    }

    private boolean readBooleanPref(String key, boolean defaultValue) {
        return mPrefs.getBoolean(key, defaultValue);
    }

    public boolean showStatusBar() {
        return (mStatusBar != 0);
    }

    public int actionBarMode() {
        return mActionBarMode;
    }

    public int getScreenOrientation() {
        return mOrientation;
    }

    public int getCursorStyle() {
        return mCursorStyle;
    }

    public int getCursorBlink() {
        return mCursorBlink;
    }

    public int getFontSize() {
        return mFontSize;
    }

    public int[] getColorScheme() {
        return COLOR_SCHEMES[mColorId];
    }

    public boolean defaultToUTF8Mode() {
        return mUTF8ByDefault;
    }

    public int getBackKeyAction() {
        return mBackKeyAction;
    }

    public boolean backKeySendsCharacter() {
        return mBackKeyAction >= BACK_KEY_SENDS_ESC;
    }

    public boolean getAltSendsEscFlag() {
        return mAltSendsEsc;
    }

    public boolean getMouseTrackingFlag() {
        return mMouseTracking;
    }

    public boolean getUseKeyboardShortcutsFlag() {
        return mUseKeyboardShortcuts;
    }

    public int getBackKeyCharacter() {
        switch (mBackKeyAction) {
            case BACK_KEY_SENDS_ESC: return 27;
            case BACK_KEY_SENDS_TAB: return 9;
            default: return 0;
        }
    }

    public int getControlKeyId() {
        return mControlKeyId;
    }

    public int getFnKeyId() {
        return mFnKeyId;
    }

    public int getControlKeyCode() {
        return CONTROL_KEY_SCHEMES[mControlKeyId];
    }

    public int getFnKeyCode() {
        return FN_KEY_SCHEMES[mFnKeyId];
    }

    public boolean useCookedIME() {
        return (mUseCookedIME != 0);
    }

    public String getShell() {
        return mShell;
    }

    public String getFailsafeShell() {
        return mFailsafeShell;
    }

    public String getInitialCommand() {
        return mInitialCommand;
    }

    public String getTermType() {
        return mTermType;
    }

    public boolean closeWindowOnProcessExit() {
        return mCloseOnExit;
    }

    public boolean verifyPath() {
        return mVerifyPath;
    }

    public boolean doPathExtensions() {
        return mDoPathExtensions;
    }

    public boolean allowPathPrepend() {
        return mAllowPathPrepend;
    }

    public void setPrependPath(String prependPath) {
        mPrependPath = prependPath;
    }

    public String getPrependPath() {
        return mPrependPath;
    }

    public void setAppendPath(String appendPath) {
        mAppendPath = appendPath;
    }

    public String getAppendPath() {
        return mAppendPath;
    }

    public void setHomePath(String homePath) {
        mHomePath = homePath;
    }

    public String getHomePath() {
        return mHomePath;
    }
}

```

`term/src/main/jni/common.cpp`:

```cpp
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "common.h"
#include "termExec.h"
#include "fileCompat.h"

#define LOG_TAG "libjackpal-androidterm"

/*
 * Register several native methods for one class.
 */
int registerNativeMethods(JNIEnv* env, const char* className,
    JNINativeMethod* gMethods, int numMethods)
{
    jclass clazz;

    clazz = env->FindClass(className);
    if (clazz == NULL) {
        LOGE("Native registration unable to find class '%s'", className);
        return JNI_FALSE;
    }
    if (env->RegisterNatives(clazz, gMethods, numMethods) < 0) {
        LOGE("RegisterNatives failed for '%s'", className);
        return JNI_FALSE;
    }

    return JNI_TRUE;
}

// ----------------------------------------------------------------------------

/*
 * This is called by the VM when the shared library is first loaded.
 */

typedef union {
    JNIEnv* env;
    void* venv;
} UnionJNIEnvToVoid;

jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    UnionJNIEnvToVoid uenv;
    uenv.venv = NULL;
    jint result = -1;
    JNIEnv* env = NULL;

    LOGI("JNI_OnLoad");

    if (vm->GetEnv(&uenv.venv, JNI_VERSION_1_4) != JNI_OK) {
        LOGE("ERROR: GetEnv failed");
        goto bail;
    }
    env = uenv.env;

    if (init_Exec(env) != JNI_TRUE) {
        LOGE("ERROR: init of Exec failed");
        goto bail;
    }

    if (init_FileCompat(env) != JNI_TRUE) {
        LOGE("ERROR: init of Exec failed");
        goto bail;
    }

    result = JNI_VERSION_1_4;

bail:
    return result;
}

```

`term/src/main/jni/common.h`:

```h
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef _COMMON_H
#define _COMMON_H 1

#include <stddef.h>

#include "jni.h"
#include <android/log.h>

#define LOGI(...) do { __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__); } while(0)
#define LOGW(...) do { __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__); } while(0)
#define LOGE(...) do { __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__); } while(0)

int registerNativeMethods(JNIEnv* env, const char* className,
    JNINativeMethod* gMethods, int numMethods);

#endif

```

`term/src/main/jni/fileCompat.cpp`:

```cpp
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "common.h"

#define LOG_TAG "FileCompat"

#include <unistd.h>

#include "fileCompat.h"

static jboolean testExecute(JNIEnv *env, jobject clazz, jstring jPathString)
{
    const char *pathname = NULL;
    int result;

    /* XXX We should convert CESU-8 to UTF-8 to deal with potential non-BMP
       chars in pathname */
    pathname = env->GetStringUTFChars(jPathString, NULL);

    result = access(pathname, X_OK);

    env->ReleaseStringUTFChars(jPathString, pathname);
    return (result == 0);
}

static const char *classPathName = "jackpal/androidterm/compat/FileCompat$Api8OrEarlier";
static JNINativeMethod method_table[] = {
    { "testExecute", "(Ljava/lang/String;)Z", (void *) testExecute },
};

int init_FileCompat(JNIEnv *env) {
    if (!registerNativeMethods(env, classPathName, method_table,
                 sizeof(method_table) / sizeof(method_table[0]))) {
        return JNI_FALSE;
    }

    return JNI_TRUE;
}

```

`term/src/main/jni/fileCompat.h`:

```h
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef _FILECOMPAT_H
#define _FILECOMPAT_H 1

#include "jni.h"

int init_FileCompat(JNIEnv *env);

#endif	/* !defined(_FILECOMPAT_H) */

```

`term/src/main/jni/termExec.cpp`:

```cpp
/*
 * Copyright (C) 2007, 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "common.h"

#define LOG_TAG "Exec"

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <termios.h>
#include <signal.h>

#include "termExec.h"

static void android_os_Exec_setPtyWindowSize(JNIEnv *env, jobject clazz,
    jint fd, jint row, jint col, jint xpixel, jint ypixel)
{
    struct winsize sz;

    sz.ws_row = row;
    sz.ws_col = col;
    sz.ws_xpixel = xpixel;
    sz.ws_ypixel = ypixel;

    // TODO: handle the situation, when the file descriptor is incompatible with TIOCSWINSZ (e.g. not from /dev/ptmx)
    if (ioctl(fd, TIOCSWINSZ, &sz) == -1)
        env->ThrowNew(env->FindClass("java/io/IOException"), "Failed to issue TIOCSWINSZ ioctl");
}

// tcgetattr /tcsetattr are not part of Bionic at API level 4. Here's a compatible version.

static __inline__ int my_tcgetattr(int fd, struct termios *s)
{
    return ioctl(fd, TCGETS, s);
}

static __inline__ int my_tcsetattr(int fd, const struct termios *s)
{
    return ioctl(fd, TCSETS, (void *)s);
}

static void android_os_Exec_setPtyUTF8Mode(JNIEnv *env, jobject clazz, jint fd, jboolean utf8Mode)
{
    struct termios tios;

    if (my_tcgetattr(fd, &tios) != 0)
        env->ThrowNew(env->FindClass("java/io/IOException"), "Failed to get terminal attributes");

    if (utf8Mode) {
        tios.c_iflag |= IUTF8;
    } else {
        tios.c_iflag &= ~IUTF8;
    }

    if (my_tcsetattr(fd, &tios) != 0)
        env->ThrowNew(env->FindClass("java/io/IOException"), "Failed to set terminal UTF-8 mode");
}

static const char *classPathName = "jackpal/androidterm/Exec";
static JNINativeMethod method_table[] = {
    { "setPtyWindowSizeInternal", "(IIIII)V",
        (void*) android_os_Exec_setPtyWindowSize},
    { "setPtyUTF8ModeInternal", "(IZ)V",
        (void*) android_os_Exec_setPtyUTF8Mode}
};

int init_Exec(JNIEnv *env) {
    if (!registerNativeMethods(env, classPathName, method_table,
                 sizeof(method_table) / sizeof(method_table[0]))) {
        return JNI_FALSE;
    }

    return JNI_TRUE;
}

```

`term/src/main/jni/termExec.h`:

```h
/*
 * Copyright (C) 2012 Steven Luo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef _TERMEXEC_H
#define _TERMEXEC_H 1

#include "jni.h"

int init_Exec(JNIEnv *env);

#endif	/* !defined(_TERMEXEC_H) */

```

`term/src/main/res/drawable/close_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2009 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->

<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true" android:drawable="@android:color/white" />
    <item android:drawable="@android:color/transparent"/>
</selector>

```

`term/src/main/res/layout/term_activity.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
/* Copyright 2007, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the "License"); 
** you may not use this file except in compliance with the License. 
** You may obtain a copy of the License at 
**
**     http://www.apache.org/licenses/LICENSE-2.0 
**
** Unless required by applicable law or agreed to in writing, software 
** distributed under the License is distributed on an "AS IS" BASIS, 
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
** See the License for the specific language governing permissions and 
** limitations under the License.
*/
-->

<jackpal.androidterm.TermViewFlipper xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/view_flipper"
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent"
    android:background="@android:color/black"
    />

```

`term/src/main/res/layout/window_list_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
/* Copyright 2007, The Android Open Source Project
** Copyright 2011 Steven Luo
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/
-->

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="horizontal">
    <TextView android:id="@+id/window_list_label"
        android:layout_width="wrap_content"
        android:layout_height="fill_parent"
        android:layout_weight="1"
        android:padding="15dp"
        android:maxLines="1"
        android:singleLine="true"
        android:textAppearance="?android:attr/textAppearanceLarge" />
    <View android:id="@+id/window_list_separator"
        android:background="#ff313431"
        android:layout_width="1dp"
        android:layout_height="fill_parent"
        android:layout_marginLeft="8dp"
        android:layout_marginTop="5dp"
        android:layout_marginBottom="5dp" />
    <view class="jackpal.androidterm.WindowList$CloseButton" android:id="@+id/window_list_close"
        android:layout_width="wrap_content"
        android:layout_height="fill_parent"
        android:paddingLeft="15dp"
        android:paddingRight="15dp"
        android:background="@drawable/close_background"
        android:src="@drawable/btn_close_window"
        android:scaleType="center" />
</LinearLayout>

```

`term/src/main/res/layout/window_list_new_window.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
/* Copyright 2007, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the "License"); 
** you may not use this file except in compliance with the License. 
** You may obtain a copy of the License at 
**
**     http://www.apache.org/licenses/LICENSE-2.0 
**
** Unless required by applicable law or agreed to in writing, software 
** distributed under the License is distributed on an "AS IS" BASIS, 
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
** See the License for the specific language governing permissions and 
** limitations under the License.
*/
-->

<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:padding="15dp"
    android:maxLines="1"
    android:singleLine="true"
    android:textAppearance="?android:attr/textAppearanceLarge"
    android:text="@string/new_window"
/>

```

`term/src/main/res/menu/main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->

<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@+id/menu_new_window"
        android:title="@string/new_window"
        android:icon="@drawable/ic_menu_add" />
    <item android:id="@+id/menu_close_window"
        android:title="@string/close_window"
        android:icon="@drawable/ic_menu_close_clear_cancel" />
    <item android:id="@+id/menu_window_list"
        android:title="@string/window_list"
        android:icon="@drawable/ic_menu_windows" />
    <item android:id="@+id/menu_toggle_soft_keyboard"
        android:title="@string/toggle_soft_keyboard" />
    <item android:id="@+id/menu_special_keys"
        android:title="@string/special_keys" />
    <item android:id="@+id/menu_preferences"
        android:title="@string/preferences"
        android:icon="@drawable/ic_menu_preferences" />
    <item android:id="@+id/menu_reset"
        android:title="@string/reset" />
    <item android:id="@+id/menu_send_email"
        android:title="@string/send_email" />
    <item android:id="@+id/menu_toggle_wakelock"
        android:title="@string/enable_wakelock" />
    <item android:id="@+id/menu_toggle_wifilock"
        android:title="@string/enable_wifilock" />
    <item android:id="@+id/action_help"
        android:title="@string/help" />
</menu>

```

`term/src/main/res/values-cs/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Zobrazovat stavový řádek</item>
        <item>Nebrazovat stavový řádek</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>Vždy zobrazovat panel akcí</item>
        <item>Skrývat panel akcí (zobrazit dotykem v horní části obrazovky, nebo tlačítkem menu)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Neblikající kurzor \:\)</item>
        <item>Blikající kurzor</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Obdelník</item>
        <item>Podtržítko</item>
        <item>Svislá čára</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 pixelů</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Černý text na bílém podkladu</item>
        <item>Bílý text na černém podkladu</item>
        <item>Bílý text na modrém podkladu</item>
        <item>Zelený text na černém podkladu</item>
        <item>Žlutý text na černém podkladu</item>
        <item>Červený text na černém podkladu</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Zavřít všechna terminálová okna</item>
        <item>Zavřít pouze toto terminálové okno</item>
        <item>Zavřít terminál, ale dál poběží na pozadí</item>
        <item>Poslat klávesu ESC do terminálu</item>
        <item>Poslat klávesu TAB do terminálu</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Pohybové tlačítko</item>
        <item>Tlačítko \@</item>
        <item>Levá klávesa ALT</item>
        <item>Pravá klávesa ALT</item>
        <item>Tlačítko hlasitosti dolů</item>
        <item>Tlačítko hlasitosti nahoru</item>
        <item>Tlačítko kamery</item>
        <item>Žádné</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Pohybové tlačítko</item>
        <item>Tlačítko \@</item>
        <item>Levá klávesa ALT</item>
        <item>Pravá klávesa ALT</item>
        <item>Tlačítko hlasitosti dolů</item>
        <item>Tlačítko hlasitosti nahoru</item>
        <item>Tlačítko kamery</item>
        <item>Žádné</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Zadávání po znacích</item>
        <item>Zadávání po slovech</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Kulička</item>
        <item>\@</item>
        <item>Levý Alt</item>
        <item>Pravý Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Kamera</item>
        <item>Žádné</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Kulička</item>
        <item>\@</item>
        <item>Levý Alt</item>
        <item>Pravý Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Kamera</item>
        <item>Žádné</item>
    </string-array>

</resources>

```

`term/src/main/res/values-cs/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal Emulator</string>
   <string name="preferences">Nastavení</string>
   <string name="new_window">Nové okno</string>
   <string name="close_window">Zavřít okno</string>
   <string name="window_list">Okna</string>
   <string name="prev_window">Predešlé okno</string>
   <string name="next_window">Další okno</string>
   <string name="reset">Reset terminálu</string>
   <string name="send_email">Napiš email</string>
   <string name="special_keys">Speciální znaky</string>
   <string name="toggle_soft_keyboard">Přepnout soft. klávesnici</string>
   
   <string name="reset_toast_notification">Toto terminálové okno bylo restartováno.</string>

   <string name="enable_wakelock">Zabránit uspání</string>
   <string name="disable_wakelock">Povolit uspání</string>
   <string name="enable_wifilock">Zabránit odpojení wifi</string>
   <string name="disable_wifilock">Povolit odpojení wifi</string>

   <string name="edit_text">Práce s textem</string>
   <string name="select_text">Vybrat text</string>
   <string name="copy_all">Kopírovat vše</string>
   <string name="paste">Vložit</string>
   <string name="send_control_key">Pošli klávesu control</string>
   <string name="send_fn_key">Pošli klávesu fn</string>

   <string name="window_title">Okno %1$d</string>

   <string name="service_notify_text">Terminál je spuštěný</string>

   <string name="process_exit_message">Terminál je ukončen</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Obrazovka</string>

   <string name="title_statusbar_preference">Stavový řádek</string>
   <string name="summary_statusbar_preference">Zobrazit/skrýt stavový řádek.</string>
   <string name="dialog_title_statusbar_preference">Stavový řádek</string>

   <string name="title_actionbar_preference">Panel akcí</string>
   <string name="summary_actionbar_preference">Vyberte chování panelu akcí (Android 3.0 a novější).</string>
   <string name="dialog_title_actionbar_preference">Chování panelu akcí</string>

   <string name="title_cursorstyle_preference">Styl kurzoru</string>
   <string name="summary_cursorstyle_preference">Vyberte styl kurzoru.</string>
   <string name="dialog_title_cursorstyle_preference">Styl kurzoru</string>

   <string name="title_cursorblink_preference">Blikání kurzoru</string>
   <string name="summary_cursorblink_preference">Vyberte chování kurzoru.</string>
   <string name="dialog_title_cursorblink_preference">Blikání kurzoru</string>

   <string name="text_preferences">Text</string>

   <string name="title_utf8_by_default_preference">Výchozí formát UTF-8</string>
   <string name="summary_utf8_by_default_preference">Nastavte formátování UTF-8 jako výchozí.</string>

   <string name="title_fontsize_preference">Velikost písma</string>
   <string name="summary_fontsize_preference">Vyberte velikost písma.</string>
   <string name="dialog_title_fontsize_preference">Velikost písma</string>

   <string name="title_color_preference">Barvy</string>
   <string name="summary_color_preference">Vyberte barevné schéma terminálu.</string>
   <string name="dialog_title_color_preference">Barva textu</string>

   <string name="keyboard_preferences">Klávesnice</string>

   <string name="title_backaction_preference">Chování tlačítka zpět</string>
   <string name="summary_backaction_preference">Vyberte chování tlačítka zpět.</string>
   <string name="dialog_title_backaction_preference">Chování tlačítka zpět</string>

   <string name="title_controlkey_preference">Klávesa control</string>
   <string name="summary_controlkey_preference">Vyberte tlačítko pro klávesu control.</string>
   <string name="dialog_title_controlkey_preference">Klávesa control</string>

   <string name="title_fnkey_preference">Klávesa Fn</string>
   <string name="summary_fnkey_preference">Vyberte tlačítko pro klávesu Fn.</string>
   <string name="dialog_title_fnkey_preference">Klávesa Fn</string>

   <string name="title_ime_preference">Vstupní metoda</string>
   <string name="summary_ime_preference">Vyberte vstupní metodu pro soft. klávesnici.</string>
   <string name="dialog_title_ime_preference">Vstupní metoda</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Příkazový řádek</string>
   <string name="summary_shell_preference">Nastavte příkazový řádek.</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Počáteční příkaz</string>
   <string name="summary_initialcommand_preference">Nastavte počáteční příkaz po spuštění terminálu.</string>
   <string name="dialog_title_initialcommand_preference">Počáteční příkaz</string>

   <string name="title_termtype_preference">Typ terminálu</string>
   <string name="summary_termtype_preference">Vyberte typ terminálu pro interpretaci příkazů.</string>
   <string name="dialog_title_termtype_preference">Typ terminálu</string>

   <string name="title_close_window_on_process_exit_preference">Zavřít okno při ukončení</string>
   <string name="summary_close_window_on_process_exit_preference">Nastavte, zda má být okno zavřeno po ukončení shellu.</string>

   <string name="control_key_dialog_title">Funkční klávesy a klávesa control</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Space : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Není nastaveno žádné tlačitko pro control.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Up\nFNKEY A : Left\nFNKEY S : Down\nFNKEY D : Right\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Není nastaveno žádné tlačitko pro funkční klávesu.</string>

  <string name="confirm_window_close_message">Zavřít okno?</string>
</resources>
```

`term/src/main/res/values-de/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
   * Copyright (C) 2007 The Android Open Source Project
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
  -->

<resources>
  <string-array name="entries_statusbar_preference">
    <item>Statuszeile zeigen</item>
    <item>Statuszeile verbergen</item>
  </string-array>

  <string-array name="entries_cursorblink_preference">
    <item>Permanenter Cursor</item>
    <item>Blinkender Cursor</item>
  </string-array>

    <string-array name="entries_orientation_preference">
        <item>Automatisch</item>
        <item>Querformat (Landscape)</item>
        <item>Hochformat (Portrait)</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>Aktionsleiste immer anzeigen</item>
        <item>Aktionsleiste verstecken (zum Anzeigen Bildschirm oben berühren oder Menü-Taste drücken)</item>
    </string-array>

  <string-array name="entries_cursorstyle_preference">
    <item>Rechteck</item>
    <item>Unterstrichen</item>
    <item>Vertikaler Balken</item>
  </string-array>

  <string-array name="entries_fontsize_preference">
    <item>4x8 Pixel</item>
    <item>6 Punkte</item>
    <item>7 Punkte</item>
    <item>8 Punkte</item>
    <item>9 Punkte</item>
    <item>10 Punkte</item>
    <item>12 Punkte</item>
    <item>14 Punkte</item>
    <item>16 Punkte</item>
    <item>20 Punkte</item>
    <item>24 Punkte</item>
    <item>28 Punkte</item>
    <item>32 Punkte</item>
    <item>36 Punkte</item>
    <item>42 Punkte</item>
    <item>48 Punkte</item>
    <item>64 Punkte</item>
    <item>72 Punkte</item>
    <item>96 Punkte</item>
    <item>144 Punkte</item>
    <item>288 Punkte</item>
  </string-array>

  <string-array name="entries_color_preference">
    <item>Schwarzer Text auf weiß</item>
    <item>Weißer Text auf schwarz</item>
    <item>Weißer Text auf blau</item>
    <item>Grüner Text auf schwarz</item>
    <item>Oranger Text auf schwarz</item>
    <item>Roter Text auf schwarz</item>
    <item>Solarized Light</item>
    <item>Solarized Dark</item>
    <item>Linux Console</item>
  </string-array>

  <string-array name="entries_backaction_preference">
    <item>Schließt alle Terminalfenster</item>
    <item>Schließt das aktuelle Terminalfenster</item>
    <item>Aktivität schließen, Sessions erhalten lassen</item>
    <item>Sendet ESC zum Terminal</item>
    <item>Sendet TAB zum Terminal</item>
  </string-array>

  <string-array name="entries_controlkey_preference">
    <item>Trackball</item>
    <item>\@ Taste</item>
    <item>Linke Alt-Taste</item>
    <item>Rechte Alt-Taste</item>
    <item>Lauter</item>
    <item>Leiser</item>
    <item>Kamera-Taste</item>
    <item>Keine</item>
  </string-array>

  <string-array name="entries_fnkey_preference">
    <item>Trackball</item>
    <item>\@ Taste</item>
    <item>Linke Alt-Taste</item>
    <item>Rechte Alt-Taste</item>
    <item>Lauter</item>
    <item>Leiser</item>
    <item>Kamera-Taste</item>
    <item>Keine</item>
  </string-array>

  <string-array name="entries_ime_preference">
    <item>Zeichen-basiert</item>
    <item>Wort-basiert</item>
  </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
       <item>Trackball</item>
       <item>\@ Taste</item>
       <item>Linke Alt-Taste</item>
       <item>Rechte Alt-Taste</item>
       <item>Lauter</item>
       <item>Leiser</item>
       <item>Kamera-Taste</item>
       <item>Keine</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
       <item>Trackball</item>
       <item>\@ Taste</item>
       <item>Linke Alt-Taste</item>
       <item>Rechte Alt-Taste</item>
       <item>Lauter</item>
       <item>Leiser</item>
       <item>Kamera-Taste</item>
       <item>Keine</item>
    </string-array>
</resources>

```

`term/src/main/res/values-de/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal Emulator</string>
   <string name="preferences">Einstellungen</string>
   <string name="new_window">Neues Fenster</string>
   <string name="close_window">Fenster schließen</string>
   <string name="window_list">Fenster</string>
   <string name="prev_window">Vorh. Fenster</string>
   <string name="next_window">Nächst. Fenster</string>
   <string name="reset">Zurücksetzen</string>
    <string name="special_keys">Spezialtasten</string>
   <string name="toggle_soft_keyboard">Tastatur an/aus</string>

   <string name="reset_toast_notification">Der Status dieses Terminalfensters wurde zurückgesetzt.</string>

   <string name="enable_wakelock">Bildschirm immer anlassen</string>
   <string name="disable_wakelock">Bildschirm ist immer an</string>
   <string name="enable_wifilock">WLAN immer anlassen</string>
   <string name="disable_wifilock">WLAN ist immer an</string>

   <string name="edit_text">Text bearbeiten</string>
   <string name="select_text">Text auswählen</string>
   <string name="copy_all">Alles kopieren</string>
   <string name="paste">Einfügen</string>

   <string name="service_notify_text">Terminalsitzung wird ausgeführt</string>

   <string name="window_title">Fenster %1$d</string>

   <string name="process_exit_message">Terminalsitzung beendet</string>
   <!-- Preference dialog -->
   <string name="screen_preferences">Bildschirm</string>

   <string name="title_statusbar_preference">Statuszeile</string>
   <string name="summary_statusbar_preference">Die Statuszeile anzeigen/verbergen.</string>
   <string name="dialog_title_statusbar_preference">Statuszeile</string>

   <string name="title_actionbar_preference">Aktionsleiste</string>
   <string name="summary_actionbar_preference">Wählen sie das Verhalten der Aktionsleiste (ab Android 3.0).</string>
   <string name="dialog_title_actionbar_preference">Verhalten der Aktionsleiste</string>

   <string name="title_cursorstyle_preference">Aussehen des Cursor</string>
   <string name="summary_cursorstyle_preference">Das Aussehen des Cursors auswählen.</string>
   <string name="dialog_title_cursorstyle_preference">Aussehen des Cursor</string>

   <string name="title_cursorblink_preference">Cursor-Blinken</string>
   <string name="summary_cursorblink_preference">Die Art auswählen, wie der Cursor blinken soll.</string>
   <string name="dialog_title_cursorblink_preference">Cursor-Blinken</string>

   <string name="text_preferences">Text</string>

   <string name="title_utf8_by_default_preference">UTF-8 als Standard definieren</string>
   <string name="summary_utf8_by_default_preference">Ist der UTF-8 Modus standartmäßig aktiv?</string>

   <string name="title_fontsize_preference">Schriftgröße</string>
   <string name="summary_fontsize_preference">Die Schriftgröße in Punkten auswählen.</string>
   <string name="dialog_title_fontsize_preference">Schriftgröße</string>

   <string name="title_color_preference">Farben</string>
   <string name="summary_color_preference">Die Text- und Hintergrundfarbe auswählen.</string>
   <string name="dialog_title_color_preference">Textfarbe</string>

   <string name="keyboard_preferences">Tastatur</string>

   <string name="title_backaction_preference">Zurück-Knopf</string>
   <string name="summary_backaction_preference">Festlegen der Aktion bei Drücken des Zurück-Knopfes.</string>
   <string name="dialog_title_backaction_preference">Zurück-Knopf</string>

   <string name="title_controlkey_preference">Steuerungstaste (Strg)</string>
   <string name="summary_controlkey_preference">Die Steuerungstaste auswählen.</string>
   <string name="dialog_title_controlkey_preference">Steuerungstaste (Strg)</string>

   <string name="title_fnkey_preference">Funktionstaste (Fn)</string>
   <string name="summary_fnkey_preference">Die Funktionstaste auswählen.</string>
   <string name="dialog_title_fnkey_preference">Funktionstaste (Fn)</string>

   <string name="title_ime_preference">Eingabemethode</string>
   <string name="summary_ime_preference">Die Eingabemethode für die Bildschirmtastatur auswählen.</string>
   <string name="dialog_title_ime_preference">Eingabemethode</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Shell</string>
   <string name="summary_shell_preference">Die zu verwendene Shell festlegen.</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Startbefehl</string>
   <string name="summary_initialcommand_preference">Befehl eingeben, der beim Start an die Shell gesendet wird.</string>
   <string name="dialog_title_initialcommand_preference">Startbefehl</string>
   <!-- BOYA -->
   <string name="title_termtype_preference">Terminal-Typ</string>
   <string name="summary_termtype_preference">Welchen Terminal-Typ soll die Shell ausführen?</string>
   <string name="dialog_title_termtype_preference">Terminal-Typ</string>

   <string name="title_close_window_on_process_exit_preference">Fenster mit Shell beenden</string>
   <string name="summary_close_window_on_process_exit_preference">Soll das Fenster geschlossen werden, wenn die Shell beendet wird?</string>

   <string name="control_key_dialog_title">Steuerungs- und Funktionstasten</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY + Leertaste: Strg-@ (NUL)\nCTRLKEY + A..Z: Strg-A..Z\nCTRLKEY + 5: Strg-]\nCTRLKEY + 6: Strg-^\nCTRLKEY + 7: Strg-_\nCTRLKEY + 9: F11\nCTRLKEY + 0: F12</string>
  <string name="control_key_dialog_control_disabled_text">Keine Steuerungstaste festgelegt.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY + 1..9: F1-F9\nFNKEY + 0: F10\nFNKEY + W: ↑\nFNKEY + A: ←\nFNKEY + S: ↓\nFNKEY + D: →\nFNKEY + P: Bild↑\nFNKEY + N: Bild↓\nFNKEY + T: Tab\nFNKEY + L : | (pipe)\nFNKEY + U: _ (Unterstrich)\nFNKEY + E: Strg-[ (ESC)\nFNKEY + X: Entfernen\nFNKEY + I: Einfügen\nFNKEY + H: Pos1\nFNKEY + F: Ende\nFNKEY + .: Strg-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Keine Funktionstaste fergelegt.</string>

  <string name="confirm_window_close_message">Dieses Fenster schließen?</string>

  <string name="perm_run_script">Beliebige Scripte im Terminal Emulator ausführen</string>
  <string name="permdesc_run_script">Erlaubt Anwendungen, neue Fenster im Terminal Emulator for Android zu öffnen und in diesen Befehle auszuführen. Dies schließt alle Berechtigungen von Terminal Emulator for Android ein, inklusive Internetzugang und Schreib-/Leserechte auf der SD-Karte.</string>
    <string name="activity_term_here_title">Terminal hier</string>
    <string name="activity_shortcut_create">"Terminal Verknüpfung"</string>
    <string name="addshortcut_arguments_label">Argumente\:</string>
    <string name="alt_sends_esc">Alt Taste sendet ESC</string>
    <string name="alt_sends_esc_summary_on">Alt Taste sendet ESC.</string>
    <string name="alt_sends_esc_summary_off">Alt Taste sendet ESC nicht.</string>
    <string name="colorvalue_letter_blue">B</string>
    <string name="colorvalue_letter_green">G</string>
    <string name="colorvalue_letter_red">R</string>
    <string name="dialog_title_orientation_preference">Bildschirmausrichtung</string>
    <string name="email_transcript_no_email_activity_found">Konnte keine App zum Verschicken der E-Mail finden</string>
    <string name="email_transcript_chooser_title">E-Mail Verschicken mit:</string>
    <string name="email_transcript_subject">Auszug von Terminal Emulator for Android</string>
    <string name="fsnavigator_change_theme">Theme ändern</string>
    <string name="fsnavigator_no_external_storage">Externer Speicher nicht verfügbar</string>
    <string name="fsnavigator_optional_enter_path">Oder hier einen Pfad eingeben.</string>
    <string name="fsnavigator_title">DATEI AUSWÄHLEN</string>
    <string name="help">Hife</string>
    <string name="perm_append_to_path">Befehle zum Terminal Emulator hinzufügen</string>
    <string name="perm_prepend_to_path">Befehle im Terminal Emulator Überschreiben</string>
    <string name="permdesc_append_to_path">Erlaubt es Applikationen dem Terminal Emulator für Android zusätzliche Befehle zur Verfügung zu stellen (fügt Verzeichnisse an die PATH Valriable an).</string>
    <string name="permdesc_prepend_to_path">Erlaubt es Applikationen im Terminal Emulator für Android existierende Befehle mit eigenen Versionen zu überschreiben (Fügt Verzeichnisse am Anfang der PATH Variable ein).</string>
    <string name="use_keyboard_shortcuts_summary_off">Tastenkombinationen deaktiviert.</string>
    <string name="title_verify_path_preference">Überprüfe PATH Einträge</string>
    <string name="title_use_keyboard_shortcuts">Nutze Tastenkombinationen</string>
    <string name="title_orientation_preference">Bildschirmausrichtung</string>
    <string name="title_mouse_tracking_preference">Sende Maus-Ereignisse</string>
    <string name="title_home_path_preference">HOME Verzeichniss</string>
    <string name="title_do_path_extensions_preference">Erlaube PATH Erweiterungen</string>
    <string name="summary_verify_path_preference">Sollen Verzeichnisse, auf welche nicht zugegriffen werden kann, vom PATH entfernt werden?</string>
    <string name="summary_orientation_preference">Wähle die Bilschirmausrichtung</string>
    <string name="summary_mouse_tracking_preference">Sollen Tipp- und Scroll-Ereignisse als Escape-Sequenzen ans Terminal gesendet werden?</string>
    <string name="summary_home_path_preference">Pfad zu einem beschreibbaren Verzeichniss welches als HOME genutzt werden soll.</string>
    <string name="summary_do_path_extensions_preference">Soll es anderen Apps erlaubt sein zusätliche Befehle zur Verfügung zu stellen? (An PATH anfügen)</string>
    <string name="summary_allow_prepend_path_preference">Soll es anderen Apps erlaubt sein, existierende Befehle zu überschreiben (Vor PATH einfügen).</string>
    <string name="send_fn_key">Sende FN-Taste</string>
    <string name="send_email">Teilen per E-Mail</string>
    <string name="send_control_key">Sende Strg-Taste</string>
</resources>

```

`term/src/main/res/values-es/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Mostrar</item>
        <item>Ocultar</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>Mostrar</item>
        <item>Ocultar (Pulsa MENÚ para mostrarla)</item>
    </string-array>

    <string-array name="entries_orientation_preference">
        <item>Automática</item>
        <item>Horizontal</item>
        <item>Vertical</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Cursor no-parpadeante</item>
        <item>Cursor parpadeante</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Rectángulo</item>
        <item>Subrayado</item>
        <item>Barra vertical</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 píxeles</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Negro en fondo blanco</item>
        <item>Blanco en fondo negro</item>
        <item>Blanco en fondo azul</item>
        <item>Verde en fondo negro</item>
        <item>Ámbar en fondo negro</item>
        <item>Rojo en fondo negro</item>
        <item>Azul en fondo negro</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Cierra todas las ventanas</item>
        <item>Cierra sólo la ventana actual</item>
        <item>Sale del terminal, dejándolo en segundo plano</item>
        <item>Envía ESC al terminal</item>
        <item>Envía TAB al terminal</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Track ball</item>
        <item>Tecla \@</item>
        <item>Tecla Alt izquierda</item>
        <item>Tecla Alt derecha</item>
        <item>Tecla de subir volumen</item>
        <item>Tecla de bajar volumen</item>
        <item>Tecla de la cámara</item>
        <item>Ninguna</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Track ball</item>
        <item>Tecla \@</item>
        <item>Tecla Alt izquierda</item>
        <item>Tecla Alt derecha</item>
        <item>Tecla de subir volumen</item>
        <item>Tecla de bajar volumen</item>
        <item>Tecla de la cámara</item>
        <item>Ninguna</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Basada en carácteres</item>
        <item>Basada en palabras</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>T.Ball</item>
        <item>\@</item>
        <item>Alt.Izq.</item>
        <item>Alt.Dcha.</item>
        <item>Vol.Subir</item>
        <item>Vol.Bajar</item>
        <item>Cámara</item>
        <item>Ninguna</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>T.Ball</item>
        <item>\@</item>
        <item>Alt.Izq.</item>
        <item>Alt.Dcha.</item>
        <item>Vol.Subir</item>
        <item>Vol.Bajar</item>
        <item>Cámara</item>
        <item>Ninguna</item>
    </string-array>
</resources>

```

`term/src/main/res/values-es/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal</string>
   <string name="preferences">Preferencias</string>
   <string name="new_window">Nueva ventana</string>
   <string name="close_window">Cerrar ventana</string>
   <string name="window_list">Ventanas</string>
   <string name="prev_window">Ventana anterior</string>
   <string name="next_window">Ventana posterior</string>
   <string name="reset">Reiniciar consola</string>
   <string name="send_email">Enviar email</string>
   <string name="special_keys">Teclas especiales</string>
   <string name="toggle_soft_keyboard">Ver/ocultar teclado</string>

   <string name="reset_toast_notification">Ventana de terminal reiniciada.</string>

   <string name="enable_wakelock">Activar WakeLock</string>
   <string name="disable_wakelock">Desactivar WakeLock</string>
   <string name="enable_wifilock">Activar WifiLock</string>
   <string name="disable_wifilock">Desactivar WifiLock</string>

   <string name="edit_text">Editar texto</string>
   <string name="select_text">Seleccionar texto</string>
   <string name="copy_all">Copiar todo</string>
   <string name="paste">Pegar</string>
   <string name="send_control_key">Tecla asignada a Ctrl</string>
   <string name="send_fn_key">Tecla asignada a FN</string>

   <string name="window_title">Ventana %1$d</string>

   <string name="service_notify_text">Sesión de terminal en ejecución</string>

   <string name="process_exit_message">Sesión de Terminal finalizada</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Pantalla</string>

   <string name="title_statusbar_preference">Barra de estado</string>
   <string name="summary_statusbar_preference">Ver/ocultar barra de estado.</string>
   <string name="dialog_title_statusbar_preference">Barra de estado</string>

   <string name="title_actionbar_preference">Barra de tareas</string>
   <string name="summary_actionbar_preference">Elije el comportamiente de la barra de tareas (Android 3.0+).</string>
   <string name="dialog_title_actionbar_preference">Barra de tareas</string>

   <string name="title_orientation_preference">Orientación de pantalla</string>
   <string name="summary_orientation_preference">Elije el comportamiento de la orientación de pantalla.</string>
   <string name="dialog_title_orientation_preference">Comportamiento de orientación de pantalla</string>

   <string name="title_cursorstyle_preference">Diseño del cursor</string>
   <string name="summary_cursorstyle_preference">Selecciona el diseño del cursor.</string>
   <string name="dialog_title_cursorstyle_preference">Diseño del cursor</string>

   <string name="title_cursorblink_preference">Parpadeo del cursor</string>
   <string name="summary_cursorblink_preference">Elije el parpadeo del cursor.</string>
   <string name="dialog_title_cursorblink_preference">Parpadeo del cursor</string>

   <string name="text_preferences">Texto</string>

   <string name="title_utf8_by_default_preference">UTF-8 por defecto</string>
   <string name="summary_utf8_by_default_preference">Activa por defecto la codificación UTF-8</string>

   <string name="title_fontsize_preference">Tamaño de fuente</string>
   <string name="summary_fontsize_preference">Elije el tamaño de la fuente.</string>
   <string name="dialog_title_fontsize_preference">Tamaño de fuente</string>

   <string name="title_color_preference">Colores</string>
   <string name="summary_color_preference">Elije el color del texto.</string>
   <string name="dialog_title_color_preference">Color del texto</string>

   <string name="keyboard_preferences">Teclado</string>

   <string name="title_backaction_preference">Acción del botón ATRÁS</string>
   <string name="summary_backaction_preference">Selecciona la acción al pulsar el botón ATRÁS.</string>
   <string name="dialog_title_backaction_preference">Acción del botón ATRÁS</string>

   <string name="title_controlkey_preference">Tecla Ctrl</string>
   <string name="summary_controlkey_preference">Elije la tecla Ctrl.</string>
   <string name="dialog_title_controlkey_preference">Tecla Ctrl</string>

   <string name="title_fnkey_preference">Tecla FN</string>
   <string name="summary_fnkey_preference">Elije la tecla FN.</string>
   <string name="dialog_title_fnkey_preference">Tecla FN</string>

   <string name="title_ime_preference">Método de introducción</string>
   <string name="summary_ime_preference">Elige el método de introducción.</string>
   <string name="dialog_title_ime_preference">Método de introducción</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Lineas de comandos</string>
   <string name="summary_shell_preference">Especifique el shell para la línea de comandos.</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Comando inicial</string>
   <string name="summary_initialcommand_preference">Comando que se envía a la consola al iniciarla.</string>
   <string name="dialog_title_initialcommand_preference">Comando inicial</string>

   <string name="title_termtype_preference">Tipo de terminal</string>
   <string name="summary_termtype_preference">Que tipo de terminal se indica al shell.</string>
   <string name="dialog_title_termtype_preference">Tipo de terminal</string>

   <string name="title_close_window_on_process_exit_preference">Cerrar ventana al salir</string>
   <string name="summary_close_window_on_process_exit_preference">Elegir si la ventana se cerrará al salir de ella.</string>

   <string name="title_verify_path_preference">Verificar entradas de PATH</string>
   <string name="summary_verify_path_preference">Los directorios inaccesibles serán eliminados de PATH.</string>

   <string name="title_do_path_extensions_preference">Permitir adiciones</string>
   <string name="summary_do_path_extensions_preference">Se permite a otras aplicaciones añadir entradas al PATH.</string>

   <string name="title_allow_prepend_path_preference">Permitir anteponer adiciones</string>
   <string name="summary_allow_prepend_path_preference">Otras aplicaciones pueden sobreescribir entradas ya existentes del PATH</string>

   <string name="title_home_path_preference">Carpeta HOME</string>
   <string name="summary_home_path_preference">Ruta a una carpeta con permisos de escritura para usar como HOME.</string>

   <string name="control_key_dialog_title">Teclas FN y Ctrl</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Espacio : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
   <string name="control_key_dialog_control_disabled_text">No hay tecla definida para Ctrl.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Up\nFNKEY A : Left\nFNKEY S : Down\nFNKEY D : Right\nFNKEY P : AvPágina\nFNKEY N : RetPágina\nFNKEY T : Tab\nFNKEY L : | (tubería)\nFNKEY U : _ (subrayado)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Suprimir\nFNKEY I : Insertar\nFNKEY H : Inicio\nFNKEY F : Fin\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">No hay tecla definida para FN.</string>

  <string name="confirm_window_close_message">¿Cerrar esta ventana?</string>

  <string name="perm_run_script">Permitir que la aplicación ejecute comandos arbitrarios</string>
  <string name="permdesc_run_script">Permitir a las aplicaciones abrir nuevas ventanas de terminal con todos los permisos concedidos, incluso los de acceso a Internet y a la tarjeta SD.</string>
  <string name="perm_append_to_path">Añadir comandos al Terminal</string>
  <string name="permdesc_append_to_path">Otras aplicaciones pueden añadir nuevos comandos al PATH.</string>
  <string name="perm_prepend_to_path">Sobreescribir comandos del Terminal</string>
  <string name="permdesc_prepend_to_path">Otras aplicaciones pueden sobreescribir comandos ya existentes del PATH.</string>

  <string name="email_transcript_subject">Enviar correo electrónico sobre Terminal</string>
  <string name="email_transcript_chooser_title">Enviar correo usando:</string>
  <string name="email_transcript_no_email_activity_found">No hay aplicaciones de email disponibles.</string>

  <string name="alt_sends_esc">Tecla Alt como ESC</string>
  <string name="alt_sends_esc_summary_on">La tecla Alt funciona como ESC.</string>
  <string name="alt_sends_esc_summary_off">La tecla Alt no funciona como ESC.</string>

  <string name="title_mouse_tracking_preference">Enviar eventos de ratón</string>
  <string name="summary_mouse_tracking_preference">Cuando los eventos de pulsación y desplazamiento deben mandarse como secuencias de escape al terminal.</string>

  <string name="title_use_keyboard_shortcuts">Usar Atajos de Teclado</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: cambiar ventana, Ctrl-Shift-N: nueva ventana, Ctrl-Shift-V: pegar.</string>
  <string name="use_keyboard_shortcuts_summary_off">Atajos de teclado desactivados.</string>

  <string name="help">Ayuda</string>
    <string name="activity_term_here_title">Terminal aquí</string>
  
  <!-- BEGIN SHORTCUT RELATED STRINGS -->
  <!-- AndroidManifest.xml -->
  <string name="activity_shortcut_create">"Terminal (acceso directo)"</string>
  <!-- FSNavigator.java -->
  <string name="fsnavigator_title">EXPLORADOR DE ARCHIVOS</string>
  <string name="fsnavigator_no_external_storage">Almacenamiento externo no disponible</string>
  <string name="fsnavigator_optional_enter_path">O intruduce ruta aquí.</string>
  <string name="fsnavigator_change_theme">Cambiar tema</string>
  <!-- AddShortcut.java -->
  <string name="addshortcut_command_hint">comando</string>
  <string name="addshortcut_example_hint">--ejemplo=\""a\"</string>
  <string name="addshortcut_button_find_command">Encontrar comando</string>
  <string name="addshortcut_navigator_title">ELIJE DESTINO DEL ACCESO DIRECTO</string>
  <string name="addshortcut_command_window_instructions">La ventana de comandos necesita la ruta completa, sin argumentos. Para otros comandos usa la ventana de Argumentos (ej: cd /sdcard).</string>
  <string name="addshortcut_arguments_label">Argumentos\:</string>
  <string name="addshortcut_shortcut_label">Etiqueta acceso directo\:</string>
  <string name="addshortcut_button_text_icon">Texto del icono</string>
  <string name="addshortcut_make_text_icon">HACER ICONO DE TEXTO</string>
  <string name="addshortcut_title">Acceso directo a terminal</string>
  <!-- ColorValue.java -->
  <string name="colorvalue_letter_alpha">α</string>
  <string name="colorvalue_letter_red">R</string>
  <string name="colorvalue_letter_green">G</string>
  <string name="colorvalue_letter_blue">B</string>
  <string name="colorvalue_label_lock_button_column">BLOQUEAR</string>
  <string name="colorvalue_icon_text_entry_hint">Introduce texto del icono</string>

    <!-- END SHORTCUT RELATED STRINGS -->
</resources>

```

`term/src/main/res/values-eu/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Erakutsi egoera-barra</item>
        <item>Ezkutatu egoera-barra</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>Beti erakutsi ekintza-barra</item>
        <item>Ezkutatu ekintza-barra (erakusteko ukitu pantailaren goialdea edo Menu tekla)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Kurtsore ez-keinukaria</item>
        <item>Kurtsore keinukaria</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Laukizuzena</item>
        <item>Azpimarra</item>
        <item>Barra bertikala</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 pixel</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Testu beltza zuriaren gainean</item>
        <item>Testu zuria beltzaren gainean</item>
        <item>Testu zuria urdinaren gainean</item>
        <item>Testu berdea beltzaren gainean</item>
        <item>Testu anbarra beltzaren gainean</item>
        <item>Testu gorria beltzaren gainean</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Terminal leiho guztiak ixten ditu</item>
        <item>Soilik terminal leiho hau ixten du</item>
        <item>Jarduera ixten du, saioak martxan utziz</item>
        <item>ESC bidaltzen du terminalera</item>
        <item>TAB bidaltzen du terminalera</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Jog bola</item>
        <item>\@ tekla</item>
        <item>Ezker Alt tekla</item>
        <item>Eskuin Alt tekla</item>
        <item>Bol Igo tekla</item>
        <item>Bol Jaitsi tekla</item>
        <item>Kamera tekla</item>
        <item>Bat ere ez</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Jog bola</item>
        <item>\@ tekla</item>
        <item>Ezker Alt tekla</item>
        <item>Eskuin Alt tekla</item>
        <item>Bol Igo tekla</item>
        <item>Bol Jaitsi tekla</item>
        <item>Kamera tekla</item>
        <item>Bat ere ez</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Karaktereetan oinarritua</item>
        <item>Hitzetan oinarritua</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Bola</item>
        <item>\@</item>
        <item>Ezker-Alt</item>
        <item>Eskuin-Alt</item>
        <item>Bol-Igo</item>
        <item>Bol-Jaitsi</item>
        <item>Kamera</item>
        <item>Bat ere ez</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Bola</item>
        <item>\@</item>
        <item>Ezker-Alt</item>
        <item>Eskuin-Alt</item>
        <item>Bol-Igo</item>
        <item>Bol-Jaitsi</item>
        <item>Kamera</item>
        <item>Bat ere ez</item>
    </string-array>

</resources>


```

`term/src/main/res/values-eu/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal Emulatzailea</string>
   <string name="preferences">Hobespenak</string>
   <string name="new_window">Leiho berria</string>
   <string name="close_window">Leihoa itxi</string>
   <string name="window_list">Leihoak</string>
   <string name="prev_window">Aurreko leihoa</string>
   <string name="next_window">Hurrengo leihoa</string>
   <string name="reset">Berrezarri terminala</string>
   <string name="send_email">Bidali eposta ...(r)i</string>
   <string name="special_keys">Tekla bereziak</string>
   <string name="toggle_soft_keyboard">Txandakatu soft teklatua</string>

   <string name="reset_toast_notification">-Terminal leiho honen egoera berrezarri da.</string>

   <string name="enable_wakelock">Gaitu WakeLock</string>
   <string name="disable_wakelock">Desgaitu WakeLock</string>
   <string name="enable_wifilock">Gaitu WifiLock</string>
   <string name="disable_wifilock">Desgaitu WifiLock</string>

   <string name="edit_text">Editatu testua</string>
   <string name="select_text">Hautatu testua</string>
   <string name="copy_all">Kopiatu guztia</string>
   <string name="paste">Itsatsi</string>
   <string name="send_control_key">Bidali kontrol tekla</string>
   <string name="send_fn_key">Bidali fn tekla</string>

   <string name="window_title">%1$d leihoa</string>

   <string name="service_notify_text">Terminal saioa martxan dago</string>

   <string name="process_exit_message">Terminal saioa amaituta</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Pantaila</string>

   <string name="title_statusbar_preference">Egoera-barra</string>
   <string name="summary_statusbar_preference">Erakutsi/ezkutatu egoera-barra.</string>
   <string name="dialog_title_statusbar_preference">Egoera-barra</string>

   <string name="title_actionbar_preference">Ekintza-barra</string>
   <string name="summary_actionbar_preference">Aukeratu ekintza-barraren portaera (Android 3.0tik aurrera).</string>
   <string name="dialog_title_actionbar_preference">Ekintza-barraren portaera</string>

   <string name="title_cursorstyle_preference">Kurtsore-estiloa</string>
   <string name="summary_cursorstyle_preference">Hautatu kurtsore-estiloa.</string>
   <string name="dialog_title_cursorstyle_preference">Kurtsore-estiloa</string>

   <string name="title_cursorblink_preference">Kurtsore-keinua</string>
   <string name="summary_cursorblink_preference">Hautatu kurtsore-keinua.</string>
   <string name="dialog_title_cursorblink_preference">Kurtsore-keinua</string>

   <string name="text_preferences">Testua</string>

   <string name="title_utf8_by_default_preference">Lehenetsi UTF-8</string>
   <string name="summary_utf8_by_default_preference">UTF-8 modu lehenetsian gaitzen den ala ez.</string>

   <string name="title_fontsize_preference">Letra-tamaina</string>
   <string name="summary_fontsize_preference">Hautatu karaktereen tamaina puntutan.</string>
   <string name="dialog_title_fontsize_preference">Letra-tamaina</string>

   <string name="title_color_preference">Koloreak</string>
   <string name="summary_color_preference">Hautatu testuaren kolorea.</string>
   <string name="dialog_title_color_preference">Testuaren kolorea</string>

   <string name="keyboard_preferences">Teklatua</string>

   <string name="title_backaction_preference">Atzera botoiaren portaera</string>
   <string name="summary_backaction_preference">Aukeratu atzera botoia sakatzeak zer egiten duen.</string>
   <string name="dialog_title_backaction_preference">Atzera botoiaren portaera</string>
   
   <string name="title_controlkey_preference">Kontrol tekla</string>
   <string name="summary_controlkey_preference">Hautatu kontrol tekla.</string>
   <string name="dialog_title_controlkey_preference">Kontrol tekla</string>

   <string name="title_fnkey_preference">Fn tekla</string>
   <string name="summary_fnkey_preference">Hautatu Fn tekla.</string>
   <string name="dialog_title_fnkey_preference">Fn tekla</string>

   <string name="title_ime_preference">Sarrera-metodoa</string>
   <string name="summary_ime_preference">Hautatu sarrera-metodoa soft teklatuarentzat.</string>
   <string name="dialog_title_ime_preference">Sarrera-metodoa</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Komando lerroa</string>
   <string name="summary_shell_preference">Zehaztu shell komando lerroa.</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Hasierako komandoa</string>
   <string name="summary_initialcommand_preference">Bidali shell-era abiarazten denean.</string>
   <string name="dialog_title_initialcommand_preference">Hasierako Komandoa</string>

   <string name="title_termtype_preference">Terminal mota</string>
   <string name="summary_termtype_preference">Terminal motaren berri eman shell-ari.</string>
   <string name="dialog_title_termtype_preference">Terminal mota</string>

   <string name="title_close_window_on_process_exit_preference">Itxi leihoa irtetean</string>
   <string name="summary_close_window_on_process_exit_preference">Bere shell-a irtetean leiho bat itxi behar litzatekeen ala ez.</string>

   <string name="control_key_dialog_title">Kontrol and Funtzio Teklak</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Zuriunea : Kontrol-@ (NUL)\nCTRLKEY A..Z : Kontrol-A..Z\nCTRLKEY 5 : Kontrol-]\nCTRLKEY 6 : Kontrol-^\nCTRLKEY 7 : Kontrol-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Ez da kontrol teklarik ezarri.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Gora\nFNKEY A : Ezkerra\nFNKEY S : Behera\nFNKEY D : Eskuina\nFNKEY P : Hurrengo-orria\nFNKEY N : Aurreko-orria\nFNKEY T : Tabulatzailea\nFNKEY L : | (kanalizazioa)\nFNKEY U : _ (azpimarra)\nFNKEY E : Kontrol-[ (ESC)\nFNKEY X : Ezabatu\nFNKEY I : Txertatu\nFNKEY H : Etxea\nFNKEY F : Bukaera\nFNKEY . : Kontrol-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Ez da funtzio teklarik ezarri.</string>

  <string name="confirm_window_close_message">Leiho hau itxi?</string>

  <string name="perm_run_script">Exekutatu hautazko komandoak Terminal Emulatzailean</string>
  <string name="permdesc_run_script">Aplikazioari baimena ematen dio Android Terminal Emulatzailean leiho berriak irekitzeko eta leiho hauetan komandoak exekutatzeko Android Terminal Emulatzailearen baimen guztiekin, Interneterako eta zure SD txartelerako sarbidea barne.</string>
</resources>


```

`term/src/main/res/values-fr/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Afficher la barre de statut</item>
        <item>Masquer la barre de statut</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Désactiver la barre d\'actions</item> -->
        <item>Toujours afficher la barre d\'actions</item>
        <item>Cacher la barre d\'actions (Touche Haut de l\'écran ou la touche Menu de l\'appareil pour afficher)</item>
    </string-array>
    
    <string-array name="entries_orientation_preference">
        <item>Automatique</item>
        <item>Paysage</item>
        <item>Portrait</item>
    </string-array>
    
    <string-array name="entries_cursorblink_preference">
        <item>Curseur non clignotant</item>
        <item>Curseur clignotant</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Rectangle</item>
        <item>Souligné</item>
        <item>Barre verticale</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Texte noir sur blanc</item>
        <item>Texte blanc sur noir</item>
        <item>Texte blanc sur bleu</item>
        <item>Texte vert sur noir</item>
        <item>Texte orange sur noir</item>
        <item>Texte rouge sur noir</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Console Linux</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Fermer toutes les fenêtres</item>
        <item>Fermer la fenêtre en cours</item>
        <item>Quitter en laissant les sessions activées</item>
        <item>Simuler la touche ESC</item>
        <item>Simuler la touche TAB</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Trackball</item>
        <item>Touche \@</item>
        <item>Touche Alt gauche</item>
        <item>Touche Alt droite</item>
        <item>Touche Vol Haut</item>
        <item>Touche Vol Bas</item>
        <item>Touche Camera</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Trackball</item>
        <item>Touche \@</item>
        <item>Touche Alt gauche</item>
        <item>Touche Alt droite</item>
        <item>Touche Vol Haut</item>
        <item>Touche Vol Bas</item>
        <item>Touche Camera</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Par caractère</item>
        <item>Par mot</item>
    </string-array>
    
    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>
</resources>

```

`term/src/main/res/values-fr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <!-- == Interface == -->
   <string name="application_terminal">Terminal Emulator</string>
   <string name="preferences">Paramètres</string>
   <string name="new_window">Nouvelle fenêtre</string>
   <string name="close_window">Fermer fenêtre</string>
   <string name="window_list">Fenêtres</string>
   <string name="prev_window">Fenêtre Préc.</string>
   <string name="next_window">Fenêtre Suiv.</string>
   <string name="reset">Terminal par défaut</string>
   <string name="send_email">Envoyer un e-mail</string>
   <string name="special_keys">Touches spéciales</string>
   <string name="toggle_soft_keyboard">Afficher/Masquer clavier</string>

   <string name="reset_toast_notification">État de cette fenêtre par défaut.</string>

   <string name="enable_wakelock">Bloquer la mise en veille</string>
   <string name="disable_wakelock">Débloquer la mise en veille</string>
   <string name="enable_wifilock">Bloquer le WiFi</string>
   <string name="disable_wifilock">Débloquer le WiFi</string>

   <string name="edit_text">Modifier le texte</string>
   <string name="select_text">Sélectionner le texte</string>
   <string name="copy_all">Tout copier</string>
   <string name="paste">Coller</string>
   <string name="send_control_key">Touche Control</string>
   <string name="send_fn_key">Touche Fonction</string>

   <string name="window_title">Fenêtre %1$d</string>

   <string name="service_notify_text">Session terminal en cours d\'exécution</string>

   <string name="process_exit_message">Session terminal terminée</string>

   <string name="confirm_window_close_message">Fermer cette fenêtre ?</string>

   <!-- == Préférences == -->
   <string name="screen_preferences">Écran</string>

   <string name="title_statusbar_preference">Barre de statut</string>
   <string name="summary_statusbar_preference">Afficher/Masquer la barre de statut</string>
   <string name="dialog_title_statusbar_preference">Barre de statut</string>

   <string name="title_actionbar_preference">Barre d\'actions</string>
   <string name="summary_actionbar_preference">Choisir le comportement de la barre d\'actions (à partir d\'Android 3.0)</string>
   <string name="dialog_title_actionbar_preference">Barre d\'actions</string>

   <string name="title_cursorstyle_preference">Style du curseur</string>
   <string name="summary_cursorstyle_preference">Choisir le style du curseur</string>
   <string name="dialog_title_cursorstyle_preference">Style du curseur</string>

   <string name="title_cursorblink_preference">Clignotement curseur</string>
   <string name="summary_cursorblink_preference">Choisir si le curseur doit clignoter</string>
   <string name="dialog_title_cursorblink_preference">Clignotement curseur</string>

   <string name="text_preferences">Texte</string>

   <string name="title_utf8_by_default_preference">UTF-8 par défaut</string>
   <string name="summary_utf8_by_default_preference">Activer le mode UTF-8 par défaut</string>

   <string name="title_fontsize_preference">Taille police</string>
   <string name="summary_fontsize_preference">Choisir la taille de la police de caractères en points</string>
   <string name="dialog_title_fontsize_preference">Taille de la police</string>

   <string name="title_color_preference">Couleurs</string>
   <string name="summary_color_preference">Choisir la couleur du texte</string>
   <string name="dialog_title_color_preference">Couleur du texte</string>

   <string name="keyboard_preferences">Clavier</string>

   <string name="title_backaction_preference">Bouton retour</string>
   <string name="summary_backaction_preference">Choisir l\'action du bouton retour quand il est cliqué</string>
   <string name="dialog_title_backaction_preference">Bouton retour</string>

   <string name="title_controlkey_preference">Touche CTRL</string>
   <string name="summary_controlkey_preference">Choisir quelle touche utiliser pour Control (CTRL)</string>
   <string name="dialog_title_controlkey_preference">Touche CTRL</string>

   <string name="title_fnkey_preference">Touche Fn</string>
   <string name="summary_fnkey_preference">Choisir quelle touche utiliser pour Fonction (Fn)</string>
   <string name="dialog_title_fnkey_preference">Touche Fn</string>

   <string name="title_ime_preference">Méthode d\'entrée</string>
   <string name="summary_ime_preference">Choisir la méthode d\'entrée du clavier virtuel</string>
   <string name="dialog_title_ime_preference">Méthode d\'entrée</string>

   <string name="alt_sends_esc">Touche Alt</string>
   <string name="alt_sends_esc_summary_on">Alt simule la touche Echap</string>
   <string name="alt_sends_esc_summary_off">Alt ne simule pas la touche Echap</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Ligne de commande</string>
   <string name="summary_shell_preference">Régler la ligne de commande du shell</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Commande initiale</string>
   <string name="summary_initialcommand_preference">Choisir une commande au démarrage du shell</string>
   <string name="dialog_title_initialcommand_preference">Commande initiale</string>

   <string name="title_termtype_preference">Type de terminal</string>
   <string name="summary_termtype_preference">Type de terminal à reporter au shell</string>
   <string name="dialog_title_termtype_preference">Type de terminal</string>

   <string name="title_close_window_on_process_exit_preference">Quitter avec exit</string>
   <string name="summary_close_window_on_process_exit_preference">Quitter la fenêtre en cours en exécutant la commande exit</string>

   <string name="title_verify_path_preference">Vérifier le PATH</string>
   <string name="summary_verify_path_preference">Les répertoires inaccessibles seront retirés de PATH</string>

   <string name="title_do_path_extensions_preference">Extensions de PATH</string>
   <string name="summary_do_path_extensions_preference">D\'autres applications sont autorisées à fournir des commandes supplémentaires (à ajouter au PATH)</string>

   <string name="title_allow_prepend_path_preference">Préfixe de PATH</string>
   <string name="summary_allow_prepend_path_preference">D\'autres applications sont autorisées à remplacer les commandes existantes (à ajouter au début de PATH)</string>

   <string name="title_home_path_preference">Dossier HOME</string>
   <string name="summary_home_path_preference">Chemin à un dossier accessible en écriture pour être utilisé comme HOME.</string>

   <string name="control_key_dialog_title">Touches Control et Fonction</string>
   <!-- Le mot CTRLKEY ne doit pas être traduit. Il sera remplacé par la touche CTRL renseignée dans les paramètres -->
   <string name="control_key_dialog_control_text">CTRLKEY Space : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
   <string name="control_key_dialog_control_disabled_text">Touche Control non paramètrée.</string>
   <!-- Le mot FNKEY ne doit pas être traduit. Il sera remplacé par la touche Fn renseignée dans les paramètres -->
   <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Haut\nFNKEY A : Gauche\nFNKEY S : Bas\nFNKEY D : Droite\nFNKEY P : PageHaut\nFNKEY N : PageBas\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Suppr.\nFNKEY I : Inser.\nFNKEY H : Début\nFNKEY F : Fin\nFNKEY . : Control-\\\n</string>
   <string name="control_key_dialog_fn_disabled_text">Touche fonction non paramètrée.</string>

   <string name="email_transcript_subject">Transcription depuis Terminal Emulator</string>
   <string name="email_transcript_chooser_title">La transcription par email utilise :</string>
   <string name="email_transcript_no_email_activity_found">Impossible de choisir une activité de messagerie pour envoyer la transcription</string>

   <string name="perm_run_script">Lancer des commandes tierces</string>
   <string name="permdesc_run_script">Permettre à une application d\'ouvrir une nouvelle fenêtre dans Terminal Emulator en exécutant des commandes avec les permissions de l\'application comme l\'accès à Internet et à votre carte SD</string>
   <string name="perm_append_to_path">Ajouter des commandes</string>
   <string name="permdesc_append_to_path">Permettre à une application de fournir des commandes supplémentaires (ajouter le répertoire au PATH) pour Terminal Emulator</string>
   <string name="perm_prepend_to_path">Remplacer des commandes</string>
   <string name="permdesc_prepend_to_path">Permettre à une application de remplacer des commandes existantes avec ses versions (répertoire à ajouter en préfixe au PATH) dans Terminal Emulator</string>

  <string name="title_mouse_tracking_preference">Envoyer des événements de souris</string>
  <string name="summary_mouse_tracking_preference">Aussi bien les événements d\'appui et de scroll doivent être envoyés sous forme de séquences d\'échappement au terminal.</string>

   <string name="title_use_keyboard_shortcuts">Utiliser les raccourcis clavier</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: cycle window, Ctrl-Shift-N: nouvelle fenêtre, Ctrl-Shift-V: coller.</string>
  <string name="use_keyboard_shortcuts_summary_off">Raccourcis clavier désactivés.</string>

  <string name="help">Aide</string>
  <!--<string name="help_url">http://jackpal.github.com/Android-Terminal-Emulator/help/index.html</string>-->
</resources>

```

`term/src/main/res/values-hu/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Megjelenítés</item>
        <item>Elrejtés</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Akciósáv letiltva</item> -->
        <item>Mindig jelenjen meg</item>
        <item>Elrejtés (a megjelenítéshez érintsd meg a képernyő tetejét vagy a menü gombot)</item>
    </string-array>

    <string-array name="entries_orientation_preference">
        <item>Automatikus</item>
        <item>Fekvő</item>
        <item>Álló</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Statikus kurzor</item>
        <item>Villogó kurzor</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Téglalap</item>
        <item>Aláhúzás</item>
        <item>Függőleges</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 képpont</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Fekete szöveg, fehér háttér</item>
        <item>Fehér szöveg, fekete háttér</item>
        <item>Fehér szöveg, kék háttér</item>
        <item>Zöld szöveg, fekete háttér</item>
        <item>Sárga szöveg, fekete háttér</item>
        <item>Piros szöveg, fekete háttér</item>
        <item>Holo kék szöveg, fekete háttér</item>
        <item>Solarized világos</item>
        <item>Solarized sötét</item>
        <item>Linux konzol</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Bezárja az összes terminál ablakot</item>
        <item>Bezárja az aktív terminál ablakot</item>
        <item>Kilép a programból, de a munkamenetből nem</item>
        <item>ESC-et küld a terminálra</item>
        <item>TAB-ot küld a terminálra</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Görgő</item>
        <item>\@ billentyű</item>
        <item>Bal Alt billentyű</item>
        <item>Jobb Alt billentyű</item>
        <item>Hangerő fel gomb</item>
        <item>Hangerő le gomb</item>
        <item>Kamera gomb</item>
        <item>Nincs</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Görgő</item>
        <item>\@ billentyű</item>
        <item>Bal Alt billentyű</item>
        <item>Jobb Alt billentyű</item>
        <item>Hangerő fel gomb</item>
        <item>Hangerő le gomb</item>
        <item>Kamera gomb</item>
        <item>Nincs</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Karakterenkénti bevitel</item>
        <item>Szavankénti bevitel</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Görgő</item>
        <item>\@</item>
        <item>Bal-Alt</item>
        <item>Jobb-Alt</item>
        <item>Hangerő-fel</item>
        <item>Hangerő-le</item>
        <item>Kamera</item>
        <item>Nincs</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Görgő</item>
        <item>\@</item>
        <item>Bal-Alt</item>
        <item>Jobb-Alt</item>
        <item>Hangerő-fel</item>
        <item>Hangerő-le</item>
        <item>Kamera</item>
        <item>Nincs</item>
    </string-array>

</resources>

```

`term/src/main/res/values-hu/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminál Emulátor</string>
   <string name="preferences">Beállítások</string>
   <string name="new_window">Új ablak</string>
   <string name="close_window">Ablak bezárása</string>
   <string name="window_list">Ablakok</string>
   <string name="prev_window">Előző ablak</string>
   <string name="next_window">Következő ablak</string>
   <string name="reset">Alaphelyzet</string>
   <string name="send_email">Küldés emailben</string>
   <string name="special_keys">Speciális billentyűk</string>
   <string name="toggle_soft_keyboard">Billentyűzet ki/be</string>

   <string name="reset_toast_notification">A terminál ablak alaphelyzetbe állítva.</string>

   <string name="enable_wakelock">Alvás megakadályozása</string>
   <string name="disable_wakelock">Alvás engedélyezése</string>
   <string name="enable_wifilock">Wi-Fi-alvás megakadályozása</string>
   <string name="disable_wifilock">Wi-Fi-alvás engedélyezése</string>

   <string name="edit_text">Szöveg szerkesztése</string>
   <string name="select_text">Szöveg kijelölése</string>
   <string name="copy_all">Az összes másolása</string>
   <string name="paste">Beillesztés</string>
   <string name="send_control_key">Control billentyű küldése</string>
   <string name="send_fn_key">Fn billentyű küldése</string>

   <string name="window_title">Ablak %1$d</string>

   <string name="service_notify_text">Aktív munkamenet</string>

   <string name="process_exit_message">A munkamenet befejeződött</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Képernyő</string>

   <string name="title_statusbar_preference">Értesítési sáv</string>
   <string name="summary_statusbar_preference">Értesítési sáv megjelenítése/elrejtése.</string>
   <string name="dialog_title_statusbar_preference">Értesítési sáv</string>

   <string name="title_actionbar_preference">Akciósáv</string>
   <string name="summary_actionbar_preference">Válassza ki az akciósáv viselkedési módját (csak Android 3.0-tól).</string>
   <string name="dialog_title_actionbar_preference">Akciósáv viselkedése</string>

   <string name="title_orientation_preference">Kijelző tájolása</string>
   <string name="summary_orientation_preference">Válassza ki a képernyő tájolásának módját.</string>
   <string name="dialog_title_orientation_preference">Kijelző tájolása</string>

   <string name="title_cursorstyle_preference">Kurzor stílusa</string>
   <string name="summary_cursorstyle_preference">Válassza ki a kurzor stílusát.</string>
   <string name="dialog_title_cursorstyle_preference">Kurzor stílusa</string>

   <string name="title_cursorblink_preference">Kurzor villogás</string>
   <string name="summary_cursorblink_preference">Állítsa be a kurzor villogását.</string>
   <string name="dialog_title_cursorblink_preference">Kurzor villogás</string>

   <string name="text_preferences">Szöveg</string>

   <string name="title_utf8_by_default_preference">UTF-8 alapértelmezett</string>
   <string name="summary_utf8_by_default_preference">UTF-8 mód engedélyezése alapértelmezésként.</string>

   <string name="title_fontsize_preference">Betűméret</string>
   <string name="summary_fontsize_preference">Karakterek magasságának megadása pontokban.</string>
   <string name="dialog_title_fontsize_preference">Betűméret</string>

   <string name="title_color_preference">Színek</string>
   <string name="summary_color_preference">Válassza ki a szöveg és a háttér színét.</string>
   <string name="dialog_title_color_preference">Színek</string>

   <string name="keyboard_preferences">Billentyűzet</string>

   <string name="title_backaction_preference">Vissza gomb viselkedése</string>
   <string name="summary_backaction_preference">Válassza ki, mi történjen a Vissza gomb megnyomásakor.</string>
   <string name="dialog_title_backaction_preference">Vissza gomb viselkedése</string>

   <string name="title_controlkey_preference">Control billentyű</string>
   <string name="summary_controlkey_preference">Válassza ki a Control billentyűleütést kiváltó gombot.</string>
   <string name="dialog_title_controlkey_preference">Control billentyű</string>

   <string name="title_fnkey_preference">Funkció billentyű</string>
   <string name="summary_fnkey_preference">Válassza ki a funkció billentyűket kiváltó gombot.</string>
   <string name="dialog_title_fnkey_preference">Funkció billentyű</string>

   <string name="title_ime_preference">Beviteli mód</string>
   <string name="summary_ime_preference">Beviteli mód kiválasztása a szoftveres billentyűzethez.</string>
   <string name="dialog_title_ime_preference">Beviteli mód</string>

   <string name="shell_preferences">Konzol</string>
   <string name="title_shell_preference">Parancssor</string>
   <string name="summary_shell_preference">Adja meg a konzolt elindító parancsot.</string>
   <string name="dialog_title_shell_preference">Konzol</string>

   <string name="title_initialcommand_preference">Indító parancs</string>
   <string name="summary_initialcommand_preference">Induláskor lefuttatja a konzol.</string>
   <string name="dialog_title_initialcommand_preference">Indító parancs</string>

   <string name="title_termtype_preference">Terminál típusa</string>
   <string name="summary_termtype_preference">Milyen terminál típust jelentsen a konzolnak.</string>
   <string name="dialog_title_termtype_preference">Terminál típusa</string>

   <string name="title_close_window_on_process_exit_preference">Ablak bezárása kilépéskor</string>
   <string name="summary_close_window_on_process_exit_preference">Terminál ablak bezárása, ha a konzol is bezáródik.</string>

   <string name="title_verify_path_preference">PATH bejegyzések ellenőrzése</string>
   <string name="summary_verify_path_preference">A nem hozzáférhető útvonalak eltávolítása a PATH változóból.</string>

   <string name="title_do_path_extensions_preference">PATH kiterjesztésének engedélyezése</string>
   <string name="summary_do_path_extensions_preference">Az alkalmazások felvehetnek új parancsokat (hozzáfűzhetnek a PATH változóhoz).</string>

   <string name="title_allow_prepend_path_preference">PATH felülírásának engedélyezése</string>
   <string name="summary_allow_prepend_path_preference">Az alkalmazások felülírhatják a meglévő parancsokat (hozzáfűzhetnek a PATH változó elejéhez).</string>

   <string name="title_home_path_preference">HOME könyvtár</string>
   <string name="summary_home_path_preference">Egy írható könyvtár útvonala, amely HOME-ként szolgál.</string>

   <string name="control_key_dialog_title">Control és funkció billentyűk</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Szóköz : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Nincs beállítva Control billentyű.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Fel\nFNKEY A : Balra\nFNKEY S : Le\nFNKEY D : Jobbra\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (aláhúzás)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Nincs beállítva funkció billentyű.</string>

  <string name="confirm_window_close_message">Bezárja ezt az ablakot?</string>

  <string name="perm_run_script">Tetszőleges parancsok futtatása a Terminál Emulátorban</string>
  <string name="permdesc_run_script">Lehetővé teszi az alkalmazások számára új ablakok megnyitását az Android Terminál Emulátorban és a megnyitott ablakokban tetszőleges parancsokat futtathatnak az Android Terminál Emulátor összes jogosultságával, beleértve a teljes hozzáférést az Internethez és az SD-kártyához.</string>
  <string name="perm_append_to_path">Parancsok hozzáadása a Terminál Emulátorhoz</string>
  <string name="permdesc_append_to_path">Az alkalmazások felvehetnek új parancsokat (hozzáfűzhetnek a PATH változóhoz) az Android Terminál Emulátorban.</string>
  <string name="perm_prepend_to_path">Parancsok felülírása a Terminál Emulátorban</string>
  <string name="permdesc_prepend_to_path">Az alkalmazások felülírhatják a meglévő parancsokat (hozzáfűzhetnek a PATH változó elejéhez) az Android Terminál Emulátorban.</string>

  <string name="email_transcript_subject">Android Terminal Emulátor terminál másolat</string>
  <string name="email_transcript_chooser_title">Terminál küldése:</string>
  <string name="email_transcript_no_email_activity_found">Nem sikerült kiválasztani az email alkalmazást.</string>

  <string name="alt_sends_esc">Az Alt billentyű ESC-et küld</string>
  <string name="alt_sends_esc_summary_on">Az Alt billentyű ESC-et küld.</string>
  <string name="alt_sends_esc_summary_off">Az Alt billentyű nem ESC-et küld.</string>

  <string name="title_mouse_tracking_preference">Egér események küldése</string>
  <string name="summary_mouse_tracking_preference">Érintés és görgetés események küldése a terminálra escape szekvenciaként.</string>

  <string name="title_use_keyboard_shortcuts">Billentyű-parancsok használata</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: váltás az ablakok között, Ctrl-Shift-N: új ablak, Ctrl-Shift-V: beillesztés.</string>
  <string name="use_keyboard_shortcuts_summary_off">Billentyű-parancsok letiltva.</string>

  <string name="help">Súgó</string>
  <!-- BEGIN SHORTCUT RELATED STRINGS -->
  <!-- AndroidManifest.xml -->
  <string name="activity_shortcut_create">"Terminál parancsikon"</string>
  <!-- FSNavigator.java -->
  <string name="fsnavigator_title">FÁJL MEGNYITÁSA</string>
  <string name="fsnavigator_no_external_storage">Külső tároló nem elérhető</string>
  <string name="fsnavigator_optional_enter_path">vagy adja meg az útvonalat</string>
  <string name="fsnavigator_change_theme">Téma váltása</string>
  <!-- AddShortcut.java -->
  <string name="addshortcut_command_hint">parancs</string>
  <string name="addshortcut_example_hint">--példa=\""a\"</string>
  <string name="addshortcut_button_find_command">Parancs keresése</string>
  <string name="addshortcut_navigator_title">PARANCS KERESÉSE</string>
  <string name="addshortcut_command_window_instructions">A parancs mezőbe teljes útvonalat kell megadni, paraméterek nélkül. A parancs paramétereit a Paraméterek mezőben lehet megadni (pl.: cd /sdcard).</string>
  <string name="addshortcut_arguments_label">Paraméterek\:</string>
  <string name="addshortcut_shortcut_label">Ikon címkéje\:</string>
  <string name="addshortcut_button_text_icon">Szöveges ikon</string>
  <string name="addshortcut_make_text_icon">SZÖVEGES IKON LÉTREHOZÁSA</string>
  <string name="addshortcut_title">Terminál parancsikon</string>
  <!-- ColorValue.java -->
  <string name="colorvalue_letter_alpha">α</string>
  <string name="colorvalue_letter_red">R</string>
  <string name="colorvalue_letter_green">G</string>
  <string name="colorvalue_letter_blue">B</string>
  <string name="colorvalue_label_lock_button_column">RÖGZÍT</string>
  <string name="colorvalue_icon_text_entry_hint">Adjon meg szöveget az ikonhoz</string>
  <!-- END SHORTCUT RELATED STRINGS -->
</resources>

```

`term/src/main/res/values-it/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Mostra barra di stato</item>
        <item>Nascondi barra di stato</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Barra di azione disabilitata</item> -->
        <item>Mostra sempre barra di azione</item>
        <item>Nascondi barra di azione (tocca cima dello schermo o tasto Menu per mostrarla)</item>
    </string-array>

    <string-array name="entries_orientation_preference">
        <item>Automatico</item>
        <item>Orizzontale</item>
        <item>Verticale</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Cursore fisso</item>
        <item>Cursore lampeggiante</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Rettangolo</item>
        <item>Sottolineatura</item>
        <item>Barra verticale</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 pixels</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Testo nero su bianco</item>
        <item>Testo bianco su nero</item>
        <item>Testo bianco su blu</item>
        <item>Testo verde su nero</item>
        <item>Testo ambra su nero</item>
        <item>Testo rosso su nero</item>
        <item>Testo blu brillante su nero</item>
        <item>Solarizzato Chiaro</item>
        <item>Solarizzato Scuro</item>
        <item>Console Linux</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Chiude tutte le finestre terminale</item>
        <item>Chiude solo questa finestra terminale</item>
        <item>Chiude l\'attività, lasciando attive le sessioni</item>
        <item>Invia ESC al terminale</item>
        <item>Invia TAB al terminale</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Trackball</item>
        <item>\@</item>
        <item>Alt sinistro</item>
        <item>Alt destro</item>
        <item>Volume +</item>
        <item>Volume -</item>
        <item>Fotocamera</item>
        <item>Nessuno</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Trackball</item>
        <item>\@</item>
        <item>Alt sinistro</item>
        <item>Alt destro</item>
        <item>Volume +</item>
        <item>Volume -</item>
        <item>Fotocamera</item>
        <item>Nessuno</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Basato su carattere</item>
        <item>Basato su parola</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>T.ball</item>
        <item>\@</item>
        <item>AltSX</item>
        <item>AltDX</item>
        <item>Vol+</item>
        <item>Vol-</item>
        <item>Camera</item>
        <item>Ness.</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>T.ball</item>
        <item>\@</item>
        <item>AltSX</item>
        <item>AltDX</item>
        <item>Vol+</item>
        <item>Vol-</item>
        <item>Camera</item>
        <item>Ness.</item>
    </string-array>
</resources>

```

`term/src/main/res/values-it/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Emulatore terminale</string>
   <string name="preferences">Impostazioni</string>
   <string name="new_window">Nuova finestra</string>
   <string name="close_window">Chiudi finestra</string>
   <string name="window_list">Finestre</string>
   <string name="prev_window">Fin. successiva</string>
   <string name="next_window">Fin. precedente</string>
   <string name="reset">Reset terminale</string>
   <string name="send_email">Invia email</string>
   <string name="special_keys">Tasti speciali</string>
   <string name="toggle_soft_keyboard">Mostra/nascondi tastiera</string>

   <string name="reset_toast_notification">Lo stato di questa finestra terminale è stato resettato.</string>

   <string name="enable_wakelock">Attiva WakeLock</string>
   <string name="disable_wakelock">Disattiva WakeLock</string>
   <string name="enable_wifilock">Attiva WifiLock</string>
   <string name="disable_wifilock">Disattiva WifiLock</string>

   <string name="edit_text">Modifica testo</string>
   <string name="select_text">Seleziona testo</string>
   <string name="copy_all">Copia tutto</string>
   <string name="paste">Incolla</string>
   <string name="send_control_key">Invia tasto control</string>
   <string name="send_fn_key">Invia tasto fn</string>

   <string name="window_title">Finestra %1$d</string>

   <string name="service_notify_text">Terminale in esecuzione</string>

   <string name="process_exit_message">Terminale arrestato</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Schermo</string>

   <string name="title_statusbar_preference">Barra di stato</string>
   <string name="summary_statusbar_preference">Mostra o nascondi la barra di stato.</string>
   <string name="dialog_title_statusbar_preference">Barra di stato</string>

   <string name="title_actionbar_preference">Barra di azione</string>
   <string name="summary_actionbar_preference">Scegli il comportamento della barra di azione (da Android 3.0 in su).</string>
   <string name="dialog_title_actionbar_preference">Comportamento barra di azione</string>

   <string name="title_orientation_preference">Orientamento schermo</string>
   <string name="summary_orientation_preference">Scegli l\'orientamento dello schermo.</string>
   <string name="dialog_title_orientation_preference">Orientamento schermo</string>

   <string name="title_cursorstyle_preference">Stile cursore</string>
   <string name="summary_cursorstyle_preference">Scegli lo stile del cursore.</string>
   <string name="dialog_title_cursorstyle_preference">Stile cursore</string>

   <string name="title_cursorblink_preference">Lampeggio cursore</string>
   <string name="summary_cursorblink_preference">Scegli il lampeggio del cursore.</string>
   <string name="dialog_title_cursorblink_preference">Lampeggio cursore</string>

   <string name="text_preferences">Testo</string>

   <string name="title_utf8_by_default_preference">UTF-8 predefinito</string>
   <string name="summary_utf8_by_default_preference">Attivazione predefinita della modalità UTF-8.</string>

   <string name="title_fontsize_preference">Dimensione carattere</string>
   <string name="summary_fontsize_preference">Scegli l\'altezza dei caratteri in punti.</string>
   <string name="dialog_title_fontsize_preference">Dimensione carattere</string>

   <string name="title_color_preference">Colori</string>
   <string name="summary_color_preference">Scegli il colore del testo.</string>
   <string name="dialog_title_color_preference">Colore testo</string>

   <string name="keyboard_preferences">Tastiera</string>

   <string name="title_backaction_preference">Tasto Indietro</string>
   <string name="summary_backaction_preference">Scegli cosa fa la pressione del tasto Indietro.</string>
   <string name="dialog_title_backaction_preference">Comportamento tasto Indietro</string>

   <string name="title_controlkey_preference">Tasto Control</string>
   <string name="summary_controlkey_preference">Scegli il tasto Control.</string>
   <string name="dialog_title_controlkey_preference">Tasto Control</string>

   <string name="title_fnkey_preference">Tasto Fn</string>
   <string name="summary_fnkey_preference">Scegli il tasto Fn.</string>
   <string name="dialog_title_fnkey_preference">Tasto Fn</string>

   <string name="title_ime_preference">Metodo inserimento</string>
   <string name="summary_ime_preference">Scegli il metodo di inserimento per la tastiera.</string>
   <string name="dialog_title_ime_preference">Metodo inserimento</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Linea di comando</string>
   <string name="summary_shell_preference">Specifica la shell da usare.</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Comando iniziale</string>
   <string name="summary_initialcommand_preference">Inviato alla shell all\'avvio.</string>
   <string name="dialog_title_initialcommand_preference">Comando iniziale</string>

   <string name="title_termtype_preference">Tipo terminale</string>
   <string name="summary_termtype_preference">Quale tipo di terminale da riportare sulla shell.</string>
   <string name="dialog_title_termtype_preference">Tipo terminale</string>

   <string name="title_close_window_on_process_exit_preference">Chiudi finestra all\'uscita</string>
   <string name="summary_close_window_on_process_exit_preference">Chiusura della finestra quando la sua shell termina.</string>

   <string name="title_verify_path_preference">Verifica voci PATH</string>
   <string name="summary_verify_path_preference">Rimuovi cartelle inaccessibili da PATH.</string>

   <string name="title_do_path_extensions_preference">Estensioni PATH</string>
   <string name="summary_do_path_extensions_preference">Permetti ad altre applicazioni di fornire comandi aggiuntivi (aggiungi a PATH).</string>

   <string name="title_allow_prepend_path_preference">Anteposizione PATH</string>
   <string name="summary_allow_prepend_path_preference">Permetti ad altre applicazioni di sovrascrivere comandi esistenti (aggiungi all\'inizio di PATH).</string>

   <string name="title_home_path_preference">Cartella HOME</string>
   <string name="summary_home_path_preference">Inserisci il percorso di una cartella scrivibile da usare come HOME.</string>

   <string name="control_key_dialog_title">Tasti Control e Fn</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY spazio : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
   <string name="control_key_dialog_control_disabled_text">Nessun tasto Control impostato.</string>
   <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
   <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Su\nFNKEY A : Sinistra\nFNKEY S : Giù\nFNKEY D : Destra\nFNKEY P : Pag. Su\nFNKEY N : Pag. Giù\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Canc\nFNKEY I : Ins (Insert)\nFNKEY H : Home\nFNKEY F : Fine (End)\nFNKEY . : Control-\\\n</string>
   <string name="control_key_dialog_fn_disabled_text">Nessun tasto Fn impostato.</string>

   <string name="confirm_window_close_message">Chiudi questa finestra?</string>

  <string name="perm_run_script">Esegui comandi arbitrari nell\'Emulatore terminale</string>
  <string name="permdesc_run_script">Permette all\'applicazione di aprire nuove finestre nell\'Emulatore terminale ed eseguire comandi in quelle finestre con tutti i permessi dell\'Emulatore, incluso l\'accesso ad internet e alla tua SD Card.</string>
  <string name="perm_append_to_path">Aggiungi comandi all\'Emulatore terminale</string>
  <string name="permdesc_append_to_path">Permette all\'applicazione di fornire comandi aggiuntivi (aggiungi cartelle a PATH) per l\'Emulatore terminale.</string>
  <string name="perm_prepend_to_path">Sovrascrivi comandi nell\'Emulatore terminale</string>
  <string name="permdesc_prepend_to_path">Permette all\'applicazione di sovrascrivere comandi esistenti con le proprie versioni (anteponi cartelle a PATH) nell\'Emulatore terminale.</string>

  <string name="email_transcript_subject">Trascrivi dall\'Emulatore terminale</string>
  <string name="email_transcript_chooser_title">Trascrizione email usando:</string>
  <string name="email_transcript_no_email_activity_found">Impossibile scegliere un\'attività email da inviare in trascrizione.</string>

  <string name="alt_sends_esc">Tasto Alt invia ESC</string>
  <string name="alt_sends_esc_summary_on">Il tasto Alt invia ESC.</string>
  <string name="alt_sends_esc_summary_off">Il tasto Alt non invia ESC.</string>

  <string name="title_mouse_tracking_preference">Invia eventi mouse</string>
  <string name="summary_mouse_tracking_preference">Click e scorrimento vengono inviati al terminale come sequenze di escape.</string>

  <string name="title_use_keyboard_shortcuts">Usa scorciatoie da tastiera</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: scorri finestre, Ctrl-Shift-N: nuova finestra, Ctrl-Shift-V: incolla.</string>
  <string name="use_keyboard_shortcuts_summary_off">Scorciatoie da tastiera disabilitate.</string>

</resources>

```

`term/src/main/res/values-iw/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
  <string-array name="entries_statusbar_preference">
    <item>הצג שורת המצב</item>
    <item>הסתר שורת מצב</item>
  </string-array>
  <string-array name="entries_actionbar_preference">
    <item>הצג תמיד שורת מצב</item>
    <item>הסתר בר פעולות (הקש בחלק עליון של המסך או על כפתור תפריט כדי להציג)</item>
  </string-array>
  <string-array name="entries_orientation_preference">
    <item>אוטומטי</item>
    <item>שוכב</item>
    <item>עומד</item>
  </string-array>
  <string-array name="entries_cursorblink_preference">
    <item>סמן לא מהבהב</item>
    <item>סמן מהבהב</item>
  </string-array>
  <string-array name="entries_cursorstyle_preference">
    <item>מלבן</item>
    <item>קו תחתון</item>
    <item>קו ניצב</item>
  </string-array>
  <string-array name="entries_fontsize_preference">
    <item>4 * 8 פיקסלים</item>
    <item>6 נק\'</item>
    <item>7 נק\'</item>
    <item>8 נק\'</item>
    <item>9 נק\'</item>
    <item>10 נק\'</item>
    <item>12 נק\'</item>
    <item>14 נק\'</item>
    <item>16 נק\'</item>
    <item>20 נק\'</item>
    <item>24 נק\'</item>
    <item>28 נק\'</item>
    <item>32 נק\'</item>
    <item>36 נק\'</item>
    <item>42 נק\'</item>
    <item>48 נק\'</item>
    <item>64 נק\'</item>
    <item>72 נק\'</item>
    <item>96 נק\'</item>
    <item>144 נק\'</item>
    <item>288 נק\'</item>
  </string-array>
  <string-array name="entries_color_preference">
    <item>טקסט שחור על לבן</item>
    <item>טקסט לבן על שחור</item>
    <item>טקסט לבן על כחול</item>
    <item>טקסט ירוק על שחור</item>
    <item>טקסט אמבר על שחור</item>
    <item>טקסט אדום על שחור</item>
    <item>טקסט כחול הולו על שחור</item>
    <item>Solarized Light</item>
    <item>Solarized Dark</item>
    <item>מסוף לינוקס</item>
  </string-array>
  <string-array name="entries_backaction_preference">
    <item>סוגר את חלונות מסוף</item>
    <item>סוגר את חלון המסוף הנוכחי בלבד</item>
    <item>סוגר פעילות, ומשאיר הפעלות רצות</item>
    <item>שולח ESC למסוף</item>
    <item>שולח TAB למסוף</item>
  </string-array>
  <string-array name="entries_controlkey_preference">
    <item>רענון הכדור</item>
    <item>\@ מפתח</item>
    <item>מקש ALT שמאלי</item>
    <item>מקש ALT ימני</item>
    <item>מקש קול עליון</item>
    <item>מקש קוך תחתון</item>
    <item>לחצן מצלמה</item>
    <item>ריק</item>
  </string-array>
  <string-array name="entries_fnkey_preference">
    <item>רענון הכדור</item>
    <item>\@ מפתח</item>
    <item>מקש ALT שמאלי</item>
    <item>מקש ALT ימני</item>
    <item>מקש קול עליון</item>
    <item>מקש קוך תחתון</item>
    <item>לחצן מצלמה</item>
    <item>ריק</item>
  </string-array>
  <string-array name="entries_ime_preference">
    <item>מבוסס תווים</item>
    <item>מבוסס מילים</item>
  </string-array>
  <string-array name="control_keys_short_names">
    <item>כדור</item>
    <item>\@</item>
    <item>ALT-שמאלי</item>
    <item>ALT-ימני</item>
    <item>קול עליון</item>
    <item>קול תחתון</item>
    <item>מצלמה</item>
    <item>ריק</item>
  </string-array>
  <string-array name="fn_keys_short_names">
    <item>כדור</item>
    <item>\@</item>
    <item>ALT-שמאלי</item>
    <item>ALT-ימני</item>
    <item>קול עליון</item>
    <item>קול תחתון</item>
    <item>מצלמה</item>
    <item>ריק</item>
  </string-array>
</resources>

```

`term/src/main/res/values-iw/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
  <string name="application_terminal">אמולטור מסוף</string>
  <string name="preferences">העדפות</string>
  <string name="new_window">חלון חדש</string>
  <string name="close_window">סגור חלון</string>
  <string name="window_list">חלונות</string>
  <string name="prev_window">החלון הקודם</string>
  <string name="next_window">החלון הבא</string>
  <string name="reset">איפוס המונח</string>
  <string name="send_email">דואר אלקטרוני ל</string>
  <string name="special_keys">מקשים מיוחדים</string>
  <string name="toggle_soft_keyboard">מתג מקלדת מסך</string>
  <string name="reset_toast_notification">מצב חלון המסוף אופס.</string>
  <string name="enable_wakelock">אל תכבה מסך</string>
  <string name="disable_wakelock">אפשר כיבוי מסך</string>
  <string name="enable_wifilock">אל תכבה WiFi</string>
  <string name="disable_wifilock">אפשר כיבוי WiFi</string>
  <string name="edit_text">ערוך טקסט</string>
  <string name="select_text">בחר טקסט</string>
  <string name="copy_all">העתק הכל</string>
  <string name="paste">הדבק</string>
  <string name="send_control_key">שלח CTRL</string>
  <string name="send_fn_key">שלח FN</string>
  <string name="window_title">חלון %1$d</string>
  <string name="service_notify_text">מסוף פועל</string>
  <string name="process_exit_message">מסוף הסתיים</string>
  <string name="screen_preferences">מסך</string>
  <string name="title_statusbar_preference">שורת מצב</string>
  <string name="summary_statusbar_preference">הצגת/הסתרת שורת מצב.</string>
  <string name="dialog_title_statusbar_preference">שורת מצב</string>
  <string name="title_actionbar_preference">בר הפעלות</string>
  <string name="summary_actionbar_preference">בחר התנהגות של בר הפעלה (אנרואיד 3.0 ומעלה).</string>
  <string name="dialog_title_actionbar_preference">התנהגות בר הפעלה</string>
  <string name="title_orientation_preference">כיוון מסך</string>
  <string name="summary_orientation_preference">בחר פעולה בשינוי כיוון מסך.</string>
  <string name="dialog_title_orientation_preference">התנהגות כיוון מסך</string>
  <string name="title_cursorstyle_preference">סגנון הסמן</string>
  <string name="summary_cursorstyle_preference">בחר סגנון לסמן.</string>
  <string name="dialog_title_cursorstyle_preference">סגנון הסמן</string>
  <string name="title_cursorblink_preference">הבהוב הסמן</string>
  <string name="summary_cursorblink_preference">בחר הבהוב הסמן.</string>
  <string name="dialog_title_cursorblink_preference">הבהוב הסמן</string>
  <string name="text_preferences">טקסט</string>
  <string name="title_utf8_by_default_preference">ברירת מחדל UTF-8</string>
  <string name="summary_utf8_by_default_preference">האם UTF-8 מופעל כברירת מחדל.</string>
  <string name="title_fontsize_preference">גודל גופן</string>
  <string name="summary_fontsize_preference">בחר גובה תווים בנקודות.</string>
  <string name="dialog_title_fontsize_preference">גודל גופן</string>
  <string name="title_color_preference">צבעים</string>
  <string name="summary_color_preference">בחר בצע טקסט.</string>
  <string name="dialog_title_color_preference">צבע טקסט</string>
  <string name="keyboard_preferences">מקלדת</string>
  <string name="title_backaction_preference">אופן הפעולה של לחצן החזרה</string>
  <string name="summary_backaction_preference">בחר פעולה בעת לחיצה על לחצן חזור.</string>
  <string name="dialog_title_backaction_preference">אופן הפעולה של לחצן החזרה</string>
  <string name="title_controlkey_preference">מקש CTRL</string>
  <string name="summary_controlkey_preference">בחר מקש CTRL.</string>
  <string name="dialog_title_controlkey_preference">מקש CTRL</string>
  <string name="title_fnkey_preference">מקש FN</string>
  <string name="summary_fnkey_preference">בחר מקש FN.</string>
  <string name="dialog_title_fnkey_preference">מקש FN</string>
  <string name="title_ime_preference">שיטת קלט</string>
  <string name="summary_ime_preference">בחר בשיטת הקלט עבור מקלדת מסך.</string>
  <string name="dialog_title_ime_preference">שיטת קלט</string>
  <string name="shell_preferences">מעטפת</string>
  <string name="title_shell_preference">שורת הפקודה</string>
  <string name="summary_shell_preference">ציין את שורת הפקודה.</string>
  <string name="dialog_title_shell_preference">מעטפת</string>
  <string name="title_initialcommand_preference">פקודה ראשונית</string>
  <string name="summary_initialcommand_preference">נשלח בעת הפעלת shell.</string>
  <string name="dialog_title_initialcommand_preference">פקודה ראשונית</string>
  <string name="title_termtype_preference">סוג המסוף</string>
  <string name="summary_termtype_preference">איזה סוג מסוף לדווח ל-shell.</string>
  <string name="dialog_title_termtype_preference">סוג המסוף</string>
  <string name="title_close_window_on_process_exit_preference">סגור חלון ביציאה</string>
  <string name="summary_close_window_on_process_exit_preference">האם בסגירת shell חלון ייסגר.</string>
  <string name="title_verify_path_preference">אמת ערך PATH</string>
  <string name="summary_verify_path_preference">האם תיקיות בלתי נגישות צריכות לרדת מ-PATH.</string>
  <string name="title_do_path_extensions_preference">אפשר הרחבות PATH</string>
  <string name="summary_do_path_extensions_preference">האם יישומים אחרים יקבלו גישה להוסיף פקודות (להוסיף ל-PATH).</string>
  <string name="title_allow_prepend_path_preference">אפשר שינוי נתיב PATH</string>
  <string name="summary_allow_prepend_path_preference">האם יישומים אחרים יוכלו לשנות פקודות קיימות (להוסיף לתחילת PATH).</string>
  <string name="title_home_path_preference">תיקיית HOME</string>
  <string name="summary_home_path_preference">נתיב לתיקייה שתשומש כתיקיית HOME.</string>
  <string name="control_key_dialog_title">מקשי CTRL ו-FN</string>
  <string name="control_key_dialog_control_disabled_text">לא הוגדר מקש CTRL.</string>
  <string name="control_key_dialog_fn_disabled_text">לא הוגדר מקש FN.</string>
  <string name="confirm_window_close_message">לסגור חלון זה?</string>
  <string name="perm_run_script">הפעל פקודות שרירותיות במסוף</string>
  <string name="perm_append_to_path">הוסף פקודות למסוף</string>
  <string name="perm_prepend_to_path">דרוס פקודות ב-Terminal Emulator</string>
  <string name="email_transcript_subject">תעתיק של אימולטור מסוף באנדרואיד</string>
  <string name="email_transcript_chooser_title">תעתיק מייל באמצעות:</string>
  <string name="email_transcript_no_email_activity_found">לא הצליחתי למצוא לקוח מייל כדי לשלוח תעתיק.</string>
  <string name="alt_sends_esc">ALT שולח ESC</string>
  <string name="alt_sends_esc_summary_on">ALT שולח ESC.</string>
  <string name="alt_sends_esc_summary_off">מקש ALT לא שולח ESC.</string>
  <string name="title_mouse_tracking_preference">שלח אירועי עכבר</string>
  <string name="title_use_keyboard_shortcuts">השתמש בקיצורי מקלדת</string>
  <string name="use_keyboard_shortcuts_summary_off">קיצורי מקלדת מושבתים.</string>
</resources>

```

`term/src/main/res/values-ja/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>ステータスバーを表示する</item>
        <item>ステータスバーを隠す</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>常にアクションバーを表示する</item>
        <item>アクションバーを隠す (スクリーンの上部へのタッチかメニューキーで表示)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>点滅しないカーソル</item>
        <item>点滅するカーソル</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>四角</item>
        <item>下線</item>
        <item>縦線</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8ピクセル</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>白背景に黒字</item>
        <item>黒背景に白字</item>
        <item>青背景に白字</item>
        <item>黒背景に緑字</item>
        <item>黒背景にアンバー字</item>
        <item>黒背景に赤字</item>
        <item>黒背景にホロブルー字</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>すべてのターミナルウインドウを閉じる</item>
        <item>このターミナルウインドウだけを閉じる</item>
        <item>アクティビティを閉じ，セッションは実行を継続</item>
        <item>ターミナルにESCを送出</item>
        <item>ターミナルにTABを送出</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>トラックボール</item>
        <item>\@キー</item>
        <item>左Altキー</item>
        <item>右Altキー</item>
        <item>ボリュームアップ</item>
        <item>ボリュームダウン</item>
        <item>カメラキー</item>
        <item>なし</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>トラックボール</item>
        <item>\@キー</item>
        <item>左Altキー</item>
        <item>右Altキー</item>
        <item>ボリュームアップ</item>
        <item>ボリュームダウン</item>
        <item>カメラキー</item>
        <item>なし</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>文字ベース</item>
        <item>単語ベース</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>ボール</item>
        <item>\@</item>
        <item>左Alt</item>
        <item>右Alt</item>
        <item>ボリュームアップ</item>
        <item>ボリュームダウン</item>
        <item>カメラ</item>
        <item>なし</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>ボール</item>
        <item>\@</item>
        <item>左Alt</item>
        <item>右Alt</item>
        <item>ボリュームアップ</item>
        <item>ボリュームダウン</item>
        <item>カメラ</item>
        <item>なし</item>
    </string-array>
</resources>

```

`term/src/main/res/values-ja/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">端末エミュレータ</string>
   <string name="preferences">設定</string>
   <string name="new_window">新規ウインドウ</string>
   <string name="close_window">ウインドウを閉じる</string>
   <string name="window_list">ウインドウ一覧</string>
   <string name="prev_window">前のウインドウ</string>
   <string name="next_window">次のウインドウ</string>
   <string name="reset">端末をリセット</string>
   <string name="send_email">メール送信</string>
   <string name="special_keys">特殊キー</string>
   <string name="toggle_soft_keyboard">ソフトキーボード</string>

   <string name="reset_toast_notification">このウインドウのターミナル状態はリセットされました.</string>

   <string name="enable_wakelock">WakeLockを取得</string>
   <string name="disable_wakelock">WakeLockを解除</string>
   <string name="enable_wifilock">WifiLockを取得</string>
   <string name="disable_wifilock">WifiLockを解除</string>

   <string name="edit_text">テキスト編集</string>
   <string name="select_text">テキスト選択</string>
   <string name="copy_all">すべてコピー</string>
   <string name="paste">貼付け</string>
   <string name="send_control_key">コントールキー送信</string>
   <string name="send_fn_key">fnキー送信</string>

   <string name="window_title">ウインドウ %1$d</string>

   <string name="service_notify_text">ターミナルセッション実行中</string>

   <string name="process_exit_message">ターミナルセッション終了</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">スクリーン</string>

   <string name="title_statusbar_preference">ステータスバー</string>
   <string name="summary_statusbar_preference">ステータスバーの表示/非表示</string>
   <string name="dialog_title_statusbar_preference">ステータスバー</string>

   <string name="title_actionbar_preference">アクションバー</string>
   <string name="summary_actionbar_preference">アクションバーの振舞いを選択する. (Android 3.0 以降).</string>
   <string name="dialog_title_actionbar_preference">アクションバーの振舞い</string>

   <string name="title_cursorstyle_preference">カーソルのスタイル</string>
   <string name="summary_cursorstyle_preference">カーソルスタイルの選択</string>
   <string name="dialog_title_cursorstyle_preference">カーソルスタイル</string>

   <string name="title_cursorblink_preference">カーソルの点滅</string>
   <string name="summary_cursorblink_preference">カーソルの点滅を選択</string>
   <string name="dialog_title_cursorblink_preference">カーソルの点滅</string>

   <string name="text_preferences">テキスト</string>

   <string name="title_utf8_by_default_preference">デフォルトをUTF-8にする</string>
   <string name="summary_utf8_by_default_preference">デフォルトでUTF-8モードを可能にするか否か.</string>

   <string name="title_fontsize_preference">フォントサイズ</string>
   <string name="summary_fontsize_preference">文字の高さと大きさを選択</string>
   <string name="dialog_title_fontsize_preference">フォントサイズ</string>

   <string name="title_color_preference">色</string>
   <string name="summary_color_preference">文字の色を選択</string>
   <string name="dialog_title_color_preference">文字の色</string>

   <string name="keyboard_preferences">キーボード</string>

   <string name="title_backaction_preference">Backボタンの振舞い</string>
   <string name="summary_backaction_preference">Backボタンの振る舞いを選択</string>
   <string name="dialog_title_backaction_preference">Backボタンの振舞い</string>

   <string name="title_controlkey_preference">コントロールキー</string>
   <string name="summary_controlkey_preference">コントロールキーを選択</string>
   <string name="dialog_title_controlkey_preference">コントロールキー</string>

   <string name="title_fnkey_preference">Fnキー</string>
   <string name="summary_fnkey_preference">Fnキーを選択</string>
   <string name="dialog_title_fnkey_preference">Fnキー</string>

   <string name="title_ime_preference">インプットメソッド</string>
   <string name="summary_ime_preference">ソフトキーボードのインプットメソッドを選択</string>
   <string name="dialog_title_ime_preference">インプットメソッド</string>

   <string name="shell_preferences">シェル</string>
   <string name="title_shell_preference">コマンドライン</string>
   <string name="summary_shell_preference">コマンドラインシェルを指定</string>
   <string name="dialog_title_shell_preference">シェル</string>

   <string name="title_initialcommand_preference">初期コマンド</string>
   <string name="summary_initialcommand_preference">開始時、シェルにコマンドを送信</string>
   <string name="dialog_title_initialcommand_preference">初期コマンド</string>

   <string name="title_termtype_preference">ターミナルタイプ</string>
   <string name="summary_termtype_preference">シェルに報告するターミナルタイプ</string>
   <string name="dialog_title_termtype_preference">ターミナルタイプ</string>

   <string name="title_close_window_on_process_exit_preference">終了時にウインドウを閉じる</string>
   <string name="summary_close_window_on_process_exit_preference">シェル終了時にウインドウを閉じるか否か.</string>

   <string name="title_verify_path_preference">PATHエントリを照合</string>
   <string name="summary_verify_path_preference">アクセス不可ディレクトリをPATHから取り除くべきか否か.</string>

   <string name="title_do_path_extensions_preference">PATH拡張の許可</string>
   <string name="summary_do_path_extensions_preference">他のアプリから追加のコマンドの提供を許可するか否か (PATHへの追加).</string>

   <string name="title_allow_prepend_path_preference">PATHへのプリペンドの許可</string>
   <string name="summary_allow_prepend_path_preference">他のアプリから既存のコマンドの上書きを許可するか否か (PATHの先頭に追加).</string>

   <string name="control_key_dialog_title">コントロールキーとファンクションキー</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Space : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">No control key set.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Up\nFNKEY A : Left\nFNKEY S : Down\nFNKEY D : Right\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">ファンクションキーの設定がありません.</string>

  <string name="confirm_window_close_message">このウインドウを閉じますか?</string>

  <string name="perm_run_script">端末エミュレータで任意のコマンドを実行</string>
  <string name="permdesc_run_script">アプリケーションに対して，端末エミュレータに新規ウインドウを開かせ，インターネットやSDカードへのアクセスを含む，端末エミュレータが持つすべてのパーミッションでコマンドを実行することを許可する.</string>
  <string name="perm_append_to_path">端末エミュレータへのコマンド追加</string>
  <string name="permdesc_append_to_path">アプリケーションに対して，端末エミュレータのコマンドを追加する(PATHにディレクトリを追加する)ことを許可する.</string>
  <string name="perm_prepend_to_path">端末エミュレータのコマンドを上書きする</string>
  <string name="permdesc_prepend_to_path">アプリケーションに対して，端末エミュレータが持つ既存のコマンドを，アプリケーション独自のバージョンに置き換える(PATHの先頭にディレクトリを追加する)ことを許可する.</string>

  <string name="email_transcript_subject">Transcript from Terminal Emulator for Android</string>
  <string name="email_transcript_chooser_title">メール転写の選択:</string>
  <string name="email_transcript_no_email_activity_found">転写を送信するEメール用アクティビティが選択できませんでした.</string>

  <string name="alt_sends_esc">AltキーでESCを送出</string>
  <string name="alt_sends_esc_summary_on">Alt keyでESCを送出する.</string>
  <string name="alt_sends_esc_summary_off">Alt keyでESCを送出しない.</string>

</resources>

```

`term/src/main/res/values-ka/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>სტატუსის ხაზის ჩვენება</item>
        <item>სტატუსის ხაზის დამალვა</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>სტატუსის ხაზის მიმაგრება ეკრანზე</item>
        <item>სტატუსის ხაზის დამალვა(საჩვენებლად შეეხეთ ეკრანის ზედა ნაწილს ან მენიუს ღილაკს)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>არა-მოციმციმე კურსორი</item>
        <item>მოციმციმე კურსორი</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>ოთხკუთხედი</item>
        <item>ქვედა ტირე</item>
        <item>ვერტიკალური ხაზი</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 პიქსელი</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>შავი თეთრზე</item>
        <item>თეთრი შავზე</item>
        <item>თეთრი ლურჯზე</item>
        <item>მწვანე შავზე</item>
        <item>ქარვისფერი შავზე</item>
        <item>წითელი შავზე</item>
        <item>ღია ლურჯი შავზე</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>ტერმინალის ყველა ფანჯრის დახურვა</item>
        <item>ტერმინალის მონიშნული ფანჯრის დახურვა</item>
        <item>ფანჯრის დახურვა სესიების გაშვებულ მდგომარეობაში დატოვებით</item>
        <item>ტერმინალისათვის ESC-ის გაგზავნა</item>
        <item>ტერმინალისათვის TAB-ის გაგზავნა</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Jog ball</item>
        <item>\@ ღილაკი</item>
        <item>მარცხენა Alt ღილაკი</item>
        <item>მარჯვენა Alt ღილაკი</item>
        <item>ხმის აწევის ღილაკი</item>
        <item>ხმის დაწევის ღილაკი</item>
        <item>კამერის ღილაკი</item>
        <item>არცერთი</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Jog ball</item>
        <item>\@ ღილაკი</item>
        <item>მარცხენა Alt ღილაკი</item>
        <item>მარჯვენა Alt ღილაკი</item>
        <item>ხმის აწევის ღილაკი</item>
        <item>ხმის დაწევის ღილაკი</item>
        <item>ამერის ღილაკი</item>
        <item>არცერთი</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>სიმბოლოებზე დამოკიდებული</item>
        <item>სიტყვებზე დამოკიდებული</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>ბურთი</item>
        <item>\@</item>
        <item>მარცხ.-Alt</item>
        <item>მარჯვ.-Alt</item>
        <item>ხმა-ზემოთ</item>
        <item>ხმა-ქვემოთ</item>
        <item>კამერა</item>
        <item>არცერთი</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>ბურთი</item>
        <item>\@</item>
        <item>მარცხ.-Alt</item>
        <item>მარჯვ.-Alt</item>
        <item>ხმა-ზემოთ</item>
        <item>ხმა-ქვემოთ</item>
        <item>კამერა</item>
        <item>არცერთი</item>
    </string-array>
</resources>

```

`term/src/main/res/values-ka/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal Emulator</string>
   <string name="preferences">გამართვა</string>
   <string name="new_window">ახალი ფანჯარა</string>
   <string name="close_window">ფანჯრის დახურვა</string>
   <string name="window_list">ფანჯრები</string>
   <string name="prev_window">წინა ფანჯარა</string>
   <string name="next_window">შემდეგი ფანჯარა</string>
   <string name="reset">ტერმინალის რესტარტი</string>
   <string name="send_email">ელ-ფოსტის გაგზავნა</string>
   <string name="special_keys">სპეციალური ღილაკები</string>
   <string name="toggle_soft_keyboard">პროგრამული კლავიატურის ჩართ./გამორთ.</string>

   <string name="reset_toast_notification">ამ ტერმინალის მდგომარეობა საწყისზე დაბრუნდა.</string>

   <string name="enable_wakelock">WakeLock-ის ჩართვა</string>
   <string name="disable_wakelock">WakeLock-ის გამორთვა</string>
   <string name="enable_wifilock">WifiLock-ის ჩართვა</string>
   <string name="disable_wifilock">WifiLock-ის გამორთვა</string>

   <string name="edit_text">ტექსტის ჩასწორება</string>
   <string name="select_text">ტექსტის მონიშვნა</string>
   <string name="copy_all">ასლი</string>
   <string name="paste">ჩასმა</string>
   <string name="send_control_key">საკონტროლო ღილაკის გაგზავნა</string>
   <string name="send_fn_key">fn ღილაკის გაგზავნა</string>

   <string name="window_title">ფანჯარა %1$d</string>

   <string name="service_notify_text">ტერმინალის სესია გაშვებულია</string>

   <string name="process_exit_message">ტერმინალის სესია დასრულდა</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">ეკრანი</string>

   <string name="title_statusbar_preference">მდგომარეობის ხაზი</string>
   <string name="summary_statusbar_preference">მდგომარეობის ხაზის ჩართვა/გამორთვა.</string>
   <string name="dialog_title_statusbar_preference">მდგომარეობის ხაზი</string>

   <string name="title_actionbar_preference">მოქმედების ხაზი</string>
   <string name="summary_actionbar_preference">აირჩიეთ მოქმედების ხაზის ქცევის პარამეტრები(Android 3.0 და ზემოთ).</string>
   <string name="dialog_title_actionbar_preference">მოქმედების ხაზის ქცევა</string>

   <string name="title_cursorstyle_preference">კურსორის სტილი</string>
   <string name="summary_cursorstyle_preference">აირჩიეთ კურსორის სტილი.</string>
   <string name="dialog_title_cursorstyle_preference">კურსორის სტილი</string>

   <string name="title_cursorblink_preference">კურსორის ციმციმი</string>
   <string name="summary_cursorblink_preference">აირჩიეთ კურსორის ციმციმის ტიპი.</string>
   <string name="dialog_title_cursorblink_preference">კურსორის ციმციმი</string>

   <string name="text_preferences">ტექსტი</string>

   <string name="title_utf8_by_default_preference">UTF-8-ის გამოყენება</string>
   <string name="summary_utf8_by_default_preference">როდესაც UTF-8 გამოიყენება ნაგულისხმევად.</string>

   <string name="title_fontsize_preference">ფონტის ზომა</string>
   <string name="summary_fontsize_preference">აირჩიეთ სიმბოლოს სიმაღლე წერტილებში.</string>
   <string name="dialog_title_fontsize_preference">ფონტის ზომა</string>

   <string name="title_color_preference">ფერები</string>
   <string name="summary_color_preference">აირჩიეთ ტექსტის ფერი.</string>
   <string name="dialog_title_color_preference">ტექსტის ფერი</string>

   <string name="keyboard_preferences">კლავიატურა</string>

   <string name="title_backaction_preference">ღილაკ Back-ის ქცევა</string>
   <string name="summary_backaction_preference">აირჩიეთ რას აკეთებს ღილაკი back.</string>
   <string name="dialog_title_backaction_preference">ღილაკ Back-ის ქცევა</string>

   <string name="title_controlkey_preference">ღილაკი Control</string>
   <string name="summary_controlkey_preference">აირჩიეთ ღილაკი control.</string>
   <string name="dialog_title_controlkey_preference">ღილაკი Control</string>

   <string name="title_fnkey_preference">ღილაკი Fn</string>
   <string name="summary_fnkey_preference">აირჩიეთ ღილაკი Fn.</string>
   <string name="dialog_title_fnkey_preference">ღილაკი Fn</string>

   <string name="title_ime_preference">შეყვანის მეთოდი</string>
   <string name="summary_ime_preference">აირჩიეთ შეყვანის მეთოდი პროგრამული კლავიატურისათვის.</string>
   <string name="dialog_title_ime_preference">შეყვანის მეთოდი</string>

   <string name="shell_preferences">გარსი</string>
   <string name="title_shell_preference">ბრძანების ხაზი</string>
   <string name="summary_shell_preference">აირჩიეთ გარსის ბრძანების ხაზი.</string>
   <string name="dialog_title_shell_preference">გარსი</string>

   <string name="title_initialcommand_preference">საწყისი ბრძანება</string>
   <string name="summary_initialcommand_preference">გაეგზავნოს გარსს მისი გაშვებისას.</string>
   <string name="dialog_title_initialcommand_preference">საწყისი ბრძანება</string>

   <string name="title_termtype_preference">ტერმინალის ტიპი</string>
   <string name="summary_termtype_preference">ტერმინალის რომელი ტიპი იქნება მიწოდებული გარსისათვის.</string>
   <string name="dialog_title_termtype_preference">ტერმინალის ტიპი</string>

   <string name="title_close_window_on_process_exit_preference">ფანჯრის დახურვა გასვლისას</string>
   <string name="summary_close_window_on_process_exit_preference">უნდა დაიხუროს თუ არა ფანჯარა გარსიდან გამოსვლის დროს.</string>

   <string name="title_verify_path_preference">გარსის ცვლად PATH-ის გადამოწმება</string>
   <string name="summary_verify_path_preference">უნდა იყოს თუ არა ამოღებული PATH-დან მიუწვდომელი დასტები.</string>

   <string name="title_do_path_extensions_preference">PATH-ის გავრცობის ნების დართვა</string>
   <string name="summary_do_path_extensions_preference">უნდა იყვნენ თუ არა აპლიკაციები ნებადართული, რომ შეცვალონ გარსის ცვლადი PATH.</string>

   <string name="title_allow_prepend_path_preference">PATH-ის დასაწყისში ჩამატება</string>
   <string name="summary_allow_prepend_path_preference">უნდა იყვნენ თუ არა აპლიკაციები ნებადართული, რომ შეცვალონ გარსის ცვლადი PATH მის დასაწყისში დასტების ჩამატებით.</string>

   <string name="control_key_dialog_title">Control და Function ღილაკები</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Space : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">ღილაკი Control მითითებული არაა.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Up\nFNKEY A : Left\nFNKEY S : Down\nFNKEY D : Right\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">ღილაკი Function მითითებული არაა.</string>

  <string name="confirm_window_close_message">გნებავთ ფანჯრის დახურვა?</string>

  <string name="perm_run_script">ტერმინალში სასურველი ბრძანებების გაშვება</string>
  <string name="permdesc_run_script">Allows application to open new windows in Terminal Emulator for Android and run commands in those windows with all of Terminal Emulator for Android\'s permissions, including access to the Internet and your SD Card.</string>
  <string name="perm_append_to_path">Terminal Emulator-სათვის ბრძანებების დამატება</string>
  <string name="permdesc_append_to_path">Allows application to provide additional commands (add directories to the PATH) for Terminal Emulator for Android.</string>
  <string name="perm_prepend_to_path">Terminal Emulator-ის ბრძანებების უგულებელყოფა</string>
  <string name="permdesc_prepend_to_path">Allows application to override existing commands with its own versions (prepend directories to the PATH) in Terminal Emulator for Android.</string>
</resources>

```

`term/src/main/res/values-ko/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>상단바 보이기</item>
        <item>상단바 숨기기</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>액션바 보이기</item>
        <item>액션바 숨기기 (화면 상단을 누르거나 메뉴키를 누르면 반투명하게 표시됩니다.)</item>
    </string-array>

    <string-array name="entries_orientation_preference">
        <item>자동</item>
        <item>가로</item>
        <item>세로</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>깜박이지 않음</item>
        <item>깜박임</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>직사각형</item>
        <item>밑줄</item>
        <item>세로줄</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 픽셀</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>하얀 배경에 검은색 글자</item>
        <item>검은 배경에 하얀 글자</item>
        <item>파란 배경에 하얀 글자</item>
        <item>검은 배경에 초록색 글자</item>
        <item>검은 배경에 황색 글자</item>
        <item>검은 배경에 빨간 글자</item>
        <item>검은 배경에 Holo Blue 글자</item>
        <item>밝은 솔라리스</item>
        <item>어두운 솔라리스</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>모든 터미널 창 닫기</item>
        <item>현재 터미널 창만 닫기</item>
        <item>어플리케이션 및 세션 종료</item>
        <item>ESC키 입력</item>
        <item>TAB키 입력</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>트랙볼</item>
        <item>\@ 키</item>
        <item>왼쪽 Alt 버튼</item>
        <item>오른쪽 Alt 버튼</item>
        <item>볼륨 상 버튼</item>
        <item>볼륨 하 버튼</item>
        <item>카메라 버튼</item>
        <item>없음</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>트랙볼</item>
        <item>\@ 키</item>
        <item>왼쪽 Alt 버튼</item>
        <item>오른쪽 Alt 버튼</item>
        <item>볼륨 상 버튼</item>
        <item>볼륨 하 버튼</item>
        <item>카메라 버튼</item>
        <item>없음</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>문자 기반</item>
        <item>단어 기반</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>트랙볼</item>
        <item>\@키</item>
        <item>왼쪽 Alt</item>
        <item>오른쪽 Alt</item>
        <item>볼륨 상</item>
        <item>볼륨 하</item>
        <item>카메라 키</item>
        <item>없음</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>트랙볼</item>
        <item>\@키</item>
        <item>왼쪽 Alt</item>
        <item>오른쪽 Alt</item>
        <item>볼륨 상</item>
        <item>볼륨 하</item>
        <item>카메라 키</item>
        <item>없음</item>
    </string-array>
</resources>

```

`term/src/main/res/values-ko/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">터미널 에뮬레이터</string>
   <string name="preferences">환경 설정</string>
   <string name="new_window">새로운 창</string>
   <string name="close_window">창 닫기</string>
   <string name="window_list">창 목록</string>
   <string name="prev_window">이전 창</string>
   <string name="next_window">다음 창</string>
   <string name="reset">터미널 초기화</string>
   <string name="send_email">이메일 보내기</string>
   <string name="special_keys">특수 키</string>
   <string name="toggle_soft_keyboard">가상 키보드 전환</string>

   <string name="reset_toast_notification">이 창의 터미널 상태를 초기화하였습니다.</string>

   <string name="enable_wakelock">WakeLock 활성화</string>
   <string name="disable_wakelock">WakeLock 해제</string>
   <string name="enable_wifilock">Wi-Fi 잠금 활성화</string>
   <string name="disable_wifilock">Wi-Fi 잠금 해제</string>

   <string name="edit_text">수정</string>
   <string name="select_text">선택</string>
   <string name="copy_all">모두 복사</string>
   <string name="paste">붙여넣기</string>
   <string name="send_control_key">Ctrl키 입력</string>
   <string name="send_fn_key">Fn키 입력</string>

   <string name="window_title">명령창 %1$d</string>

   <string name="service_notify_text">터미널 세션이 실행중입니다.</string>

   <string name="process_exit_message">터미널 세션을 마쳤습니다.</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">화면</string>

   <string name="title_statusbar_preference">상단바</string>
   <string name="summary_statusbar_preference">상단바를 숨기거나 보입니다.</string>
   <string name="dialog_title_statusbar_preference">상단바 설정</string>

   <string name="title_actionbar_preference">액션바</string>
   <string name="summary_actionbar_preference">액션바의 상태를 설정합니다.</string>
   <string name="dialog_title_actionbar_preference">액션바 상태</string>

      <string name="title_orientation_preference">화면 회전</string>
   <string name="summary_orientation_preference">터미널 창의 회전 상태를 설정합니다.</string>
   <string name="dialog_title_orientation_preference">화면 회전 상태</string>

   <string name="title_cursorstyle_preference">커서 모양</string>
   <string name="summary_cursorstyle_preference">커서의 모양을 설정합니다.</string>
   <string name="dialog_title_cursorstyle_preference">커서 모양</string>

   <string name="title_cursorblink_preference">커서 깜박임</string>
   <string name="summary_cursorblink_preference">커서의 깜박임을 설정합니다.</string>
   <string name="dialog_title_cursorblink_preference">커서 깜빡임</string>

   <string name="text_preferences">글자</string>

   <string name="title_utf8_by_default_preference">UTF-8 인코딩 사용</string>
   <string name="summary_utf8_by_default_preference">UTF-8 인코딩을 기본으로 사용할지 설정합니다.</string>

   <string name="title_fontsize_preference">글자 크기</string>
   <string name="summary_fontsize_preference">글자의 크기를 설정합니다.</string>
   <string name="dialog_title_fontsize_preference">글자 크기 선택</string>

   <string name="title_color_preference">글자 색깔</string>
   <string name="summary_color_preference">글자 색깔을 설정합니다.</string>
   <string name="dialog_title_color_preference">글자 색깔</string>

   <string name="keyboard_preferences">키보드</string>

   <string name="title_backaction_preference">뒤로가기 버튼 행동</string>
   <string name="summary_backaction_preference">뒤로가기 버튼을 눌렀을 때 행동을 설정합니다.</string>
   <string name="dialog_title_backaction_preference">뒤로가기 버튼 행동</string>

   <string name="title_controlkey_preference">Ctrl키 (컨트롤키)</string>
   <string name="summary_controlkey_preference">컨트롤키를 설정합니다.</string>
   <string name="dialog_title_controlkey_preference">Ctrl키 설정</string>

   <string name="title_fnkey_preference">Fn키 (Function키)</string>
   <string name="summary_fnkey_preference">Fn키를 설정합니다.</string>
   <string name="dialog_title_fnkey_preference">Fn키</string>

   <string name="title_ime_preference">입력 방식</string>
   <string name="summary_ime_preference">가상 키보드의 입력 방식을 설정합니다.</string>
   <string name="dialog_title_ime_preference">입력 방식</string>

   <string name="shell_preferences">명령줄</string>
   <string name="title_shell_preference">명령줄</string>
   <string name="summary_shell_preference">사용자 지정 명령줄을 설정합니다.</string>
   <string name="dialog_title_shell_preference">명령줄</string>

   <string name="title_initialcommand_preference">초기 명령어</string>
   <string name="summary_initialcommand_preference">터미널이 실행될 때 실행될 명령어를 선택합니다.</string>
   <string name="dialog_title_initialcommand_preference">초기 명령어</string>

   <string name="title_termtype_preference">터미널 종류</string>
   <string name="summary_termtype_preference">터미널의 종류를 선택합니다.</string>
   <string name="dialog_title_termtype_preference">타미널 종류</string>

   <string name="title_close_window_on_process_exit_preference">종료 시에 창 닫기</string>
   <string name="summary_close_window_on_process_exit_preference">터미널 프로세스가 종료되면 활성화된 창을 닫습니다.</string>

   <string name="title_verify_path_preference">PATH 경로 확인</string>
   <string name="summary_verify_path_preference">액세스할 수 없는 경로가 PATH에서 제거되어야할지 확인합니다.</string>

   <string name="title_do_path_extensions_preference">PATH 확장 허용</string>
   <string name="summary_do_path_extensions_preference">다른 어플리케이션에서 추가적인 경로를 PATH에 생성할 수 있는지 설정합니다.</string>

   <string name="title_allow_prepend_path_preference">PATH 경로 덮어쓰기 허용</string>
   <string name="summary_allow_prepend_path_preference">다른 어플리케이션에서 이미 존재하는 경로를 덮어씌울 수 있는지 설정합니다.</string>

   <string name="title_home_path_preference">HOME 경로</string>
   <string name="summary_home_path_preference">HOME으로 설정 가능한 경로 (쓰기 가능한 경로)를 설정합니다.</string>

   <string name="control_key_dialog_title">Ctrl키와 Fn키</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY 스페이스바 : Control-@ (공백 (NULL))\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Ctrl키가 설정되지 않았습니다.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : 위쪽 버튼 (↑)\nFNKEY A : 왼쪽 버튼 (←)\nFNKEY S : 아래쪽 버튼 (↓)\nFNKEY D : 오른쪽 버튼 (→)\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : 탭\nFNKEY L : | (세로줄)\nFNKEY U : _ (밑줄)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Fn키가 설정되지 않았습니다.</string>

  <string name="confirm_window_close_message">이 창을 닫으시겠습니까?</string>

  <string name="perm_run_script">터미널 에뮬레이터에서 명령어 실행</string>
  <string name="permdesc_run_script">어플리케이션이 터미널 에뮬레이터에서 새로운 창을 열 수 있게 허용하고, 터미널 에뮬레이터의 모든 권한을 이용하여 명령을 실행할 수 있습니다. 예를 들어, SD카드나 인터넷에 액세스할 수 있습니다.</string>
  <string name="perm_append_to_path">터미널 에뮬레이터에서 명령어 추가</string>
  <string name="permdesc_append_to_path">어플리케이션이 터미널 에뮬레이터에서 사용할 수 있는 명령어를 만들고, 그 명령어를 관리할 수 있게 합니다.</string>
  <string name="perm_prepend_to_path">터미널 에뮬레이터에서 명령어 덮어쓰기</string>
  <string name="permdesc_prepend_to_path">어플리케이션이 터미널 에뮬레이터의 명령어를 덮어씌울 수 있습니다.</string>

  <string name="email_transcript_subject">터미널 에뮬레이터로 이메일 보내기</string>
  <string name="email_transcript_chooser_title">이메일 보내기 : </string>
  <string name="email_transcript_no_email_activity_found">이메일을 보낼 수 있는 어플리케이션이 존재하지 않습니다.</string>

  <string name="alt_sends_esc">Alt 키로 ESC 키를 입력</string>
  <string name="alt_sends_esc_summary_on">Alt 키가 ESC 키를 입력합니다.</string>
  <string name="alt_sends_esc_summary_off">Alt 키는 ESC 키를 입력하지 않습니다.</string>

</resources>

```

`term/src/main/res/values-nb/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
   * Copyright (C) 2007 The Android Open Source Project
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
  -->

<resources>
  <string-array name="entries_statusbar_preference">
    <item>Vis statuslinje</item>
    <item>Skjul statuslinje</item>
  </string-array>

  <string-array name="entries_actionbar_preference">
      <!-- <item>Action bar disabled</item> -->
      <item>Alltid vis handlingslinjen</item>
      <item>Skjul handlingslinjen (Trykk på toppen av skjermen for å vise den)</item>
  </string-array>

    <string-array name="entries_orientation_preference">
        <item>Automatisk</item>
        <item>Landskap</item>
        <item>Portrett</item>
    </string-array>

  <string-array name="entries_cursorblink_preference">
    <item>Ikke-blinkende peker</item>
    <item>Blinkende peker</item>
  </string-array>

  <string-array name="entries_cursorstyle_preference">
    <item>Rektangulær</item>
    <item>Understreket</item>
    <item>Vertikal linje</item>
  </string-array>

  <string-array name="entries_fontsize_preference">
    <item>4x8 Piksler</item>
    <item>6 Punkter</item>
    <item>7 Punkter</item>
    <item>8 Punkter</item>
    <item>9 Punkter</item>
    <item>10 Punkter</item>
    <item>12 Punkter</item>
    <item>14 Punkter</item>
    <item>16 Punkter</item>
    <item>20 Punkter</item>
    <item>24 Punkter</item>
    <item>28 Punkter</item>
    <item>32 Punkter</item>
    <item>36 Punkter</item>
    <item>42 Punkter</item>
    <item>48 Punkter</item>
    <item>64 Punkter</item>
    <item>72 Punkter</item>
    <item>96 Punkter</item>
    <item>144 Punkter</item>
    <item>288 Punkter</item>
  </string-array>

  <string-array name="entries_color_preference">
    <item>Sort tekst på hvit</item>
    <item>Hvit tekst på sort</item>
    <item>Hvit tekst på blå</item>
    <item>Grønn tekst på sort</item>
    <item>Orange tekst på sort</item>
    <item>Rød tekst på sort</item>
    <item>Holo blå på sort</item>
    <item>Solarized Lys</item>
    <item>Solarized Mørk</item>
    <item>Linux konsoll</item>
  </string-array>

  <string-array name="entries_backaction_preference">
      <item>Lukker alle terminalvinduer</item>
      <item>Lukker kun dette terminalviduet</item>
      <item>Lukker aktiviteten, men lar økten kjøre</item>
      <item>Sender ESC til terminalen</item>
      <item>Sender TAB til terminalen</item>
  </string-array>

  <string-array name="entries_controlkey_preference">
    <item>Trackball</item>
    <item>\@-tast</item>
    <item>Venstre Alt-tast</item>
    <item>Høyre Alt-tast</item>
    <item>Vol opp</item>
    <item>Vol ned</item>
    <item>Kamera-tast</item>
    <item>Ingen</item>
  </string-array>

  <string-array name="entries_fnkey_preference">
    <item>Trackball</item>
    <item>\@-tast</item>
    <item>Venstre Alt-tast</item>
    <item>Høyre Alt-tast</item>
    <item>Vol opp</item>
    <item>Vol ned</item>
    <item>Kamera-tast</item>
    <item>Ingen</item>
  </string-array>

  <string-array name="entries_ime_preference">
    <item>Tegnbasert</item>
    <item>Ordbasert</item>
  </string-array>

  <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
  <string-array name="control_keys_short_names">
      <item>Ball</item>
      <item>\@</item>
      <item>Venstre-Alt</item>
      <item>Høyre-Alt</item>
      <item>Vol-Opp</item>
      <item>Vol-Ned</item>
      <item>Kamera</item>
      <item>Ingen</item>
  </string-array>

  <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
  <string-array name="fn_keys_short_names">
      <item>Ball</item>
      <item>\@</item>
      <item>Venstre-Alt</item>
      <item>Høyre-Alt</item>
      <item>Vol-Opp</item>
      <item>Vol-Ned</item>
      <item>Kamera</item>
      <item>Ingen</item>
  </string-array>
</resources>

```

`term/src/main/res/values-nb/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminalemulator</string>
   <string name="preferences">Innstillinger</string>
   <string name="new_window">Nytt vindu</string>
   <string name="close_window">Lukk vindu</string>
   <string name="window_list">Vinduer</string>
   <string name="prev_window">Forrige vindu</string>
   <string name="next_window">Neste vindu</string>
   <string name="reset">Tilbakestill terminal</string>
   <string name="send_email">Send epost til</string>
   <string name="special_keys">Spesielle tegn</string>
   <string name="toggle_soft_keyboard">Veksle virtuelt tastatur</string>

   <string name="reset_toast_notification">Terminalen i dette vinduet ble tilbakestilt.</string>

   <string name="enable_wakelock">Ta WakeLock</string>
   <string name="disable_wakelock">Dropp WakeLock</string>
   <string name="enable_wifilock">Ta WifiLock</string>
   <string name="disable_wifilock">Dropp WifiLock</string>

   <string name="edit_text">Rediger tekst</string>
   <string name="select_text">Marker tekst</string>
   <string name="copy_all">Kopier alt</string>
   <string name="paste">Lim inn</string>
   <string name="send_control_key">Send ctrl-tast</string>
   <string name="send_fn_key">Send fn-ast</string>

   <string name="window_title">Vindu %1$d</string>

   <string name="service_notify_text">Terminaløkt kjører</string>

   <string name="process_exit_message">Terminaløkt ferdig</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Skjerm</string>

   <string name="title_statusbar_preference">Statuslinje</string>
   <string name="summary_statusbar_preference">Vis/Skjul statuslinje</string>
   <string name="dialog_title_statusbar_preference">Statuslinje</string>

   <string name="title_actionbar_preference">Handlingslinje</string>
   <string name="summary_actionbar_preference">Velg hvordan handlingslinjen (ActionBar) skal oppføre seg (Android 3.0 og oppover).</string>
   <string name="dialog_title_actionbar_preference">Handlingslinje</string>

   <string name="title_orientation_preference">Rotasjon</string>
   <string name="summary_orientation_preference">Velg hvordan rotasjon av skjermen skal håndteres.</string>
   <string name="dialog_title_orientation_preference">Rotasjon</string>

   <string name="title_cursorstyle_preference">Pekertype</string>
   <string name="summary_cursorstyle_preference">Velg pekertype.</string>
   <string name="dialog_title_cursorstyle_preference">Pekertype</string>

   <string name="title_cursorblink_preference">Blinkende peker</string>
   <string name="summary_cursorblink_preference">Velg blinkende peker</string>
   <string name="dialog_title_cursorblink_preference">Blinkende peker</string>

   <string name="text_preferences">Tekst</string>

   <string name="title_utf8_by_default_preference">Aktiver UTF-8</string>
   <string name="summary_utf8_by_default_preference">Velg om UTF-8 skal være aktivert som standard.</string>

   <string name="title_fontsize_preference">Skriftstørrelse</string>
   <string name="summary_fontsize_preference">Velg tegnhøyde i antall punkter.</string>
   <string name="dialog_title_fontsize_preference">Skriftstørrelse</string>

   <string name="title_color_preference">Farger</string>
   <string name="summary_color_preference">Velg tekstfarge.</string>
   <string name="dialog_title_color_preference">Tekstfarge</string>

   <string name="keyboard_preferences">Tastatur</string>

   <string name="title_backaction_preference">Tilbaketast</string>
   <string name="summary_backaction_preference">Velg hva som skal skje når det trykkes på tilbaketasten.</string>
   <string name="dialog_title_backaction_preference">Tilbaketast</string>

   <string name="title_controlkey_preference">Ctrl-tast</string>
   <string name="summary_controlkey_preference">Velg Ctrl-tast</string>
   <string name="dialog_title_controlkey_preference">Ctrl-tast</string>

   <string name="title_fnkey_preference">Fn-tast</string>
   <string name="summary_fnkey_preference">Velg Fn-tast.</string>
   <string name="dialog_title_fnkey_preference">Fn-tast</string>

   <string name="title_ime_preference">Inndatametode</string>
   <string name="summary_ime_preference">Velg inndatametode for virtuelt tastatur.</string>
   <string name="dialog_title_ime_preference">Inndatametode</string>

   <string name="shell_preferences">Skall</string>
   <string name="title_shell_preference">Kommandolinje</string>
   <string name="summary_shell_preference">Velg kommandolinjeskall.</string>
   <string name="dialog_title_shell_preference">Skall</string>

   <string name="title_initialcommand_preference">Innledende kommando</string>
   <string name="summary_initialcommand_preference">Sendes til skallet når det starter.</string>
   <string name="dialog_title_initialcommand_preference">Innledende kommando</string>

   <string name="title_termtype_preference">Terminaltype</string>
   <string name="summary_termtype_preference">Velg terminaltype.</string>
   <string name="dialog_title_termtype_preference">Terminaltype</string>

   <string name="title_close_window_on_process_exit_preference">Lukk vinduet ved avslutning</string>
   <string name="summary_close_window_on_process_exit_preference">Velg om vinduet skal lukkes når skallet avsluttes.</string>

   <string name="title_verify_path_preference">Kontroller oppføringer i PATH</string>
   <string name="summary_verify_path_preference">Velg om utilgjengelige mapper skal fjernes fra PATH.</string>

   <string name="title_do_path_extensions_preference">Tillat utvidelse av PATH</string>
   <string name="summary_do_path_extensions_preference">Velg om andre apper skal kunne tilby flere kommandoer (legge til i PATH).</string>

   <string name="title_allow_prepend_path_preference">Tillat overstyring av PATH</string>
   <string name="summary_allow_prepend_path_preference">Velg om andre apper skal kunne overstyre eksisterende kommandoer (legge til i begynnelsen av PATH).</string>

   <string name="title_home_path_preference">HOME-mappe</string>
   <string name="summary_home_path_preference">Sti til en skrivbar mappe som skal brukes som HOME.</string>

   <string name="control_key_dialog_title">Ctrl og fn-tast</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Mellomrom : Ctrl-@ (NUL)\nCTRLKEY A..Z : Ctrl-A..Z\nCTRLKEY 5 : Ctrl-]\nCTRLKEY 6 : Ctrl-^\nCTRLKEY 7 : Ctrl-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Ingen ctrl-tast valgt</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Opp\nFNKEY A : Venstre\nFNKEY S : Ned\nFNKEY D : Høyre\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (understrek)\nFNKEY E : Ctrl-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Ctrl-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Ingen fn-tast valgt</string>

  <string name="confirm_window_close_message">Lukk dette vinduet?</string>

  <string name="perm_run_script">Kjøre forskjellige kommandoer i Terminalemulatoren</string>
  <string name="permdesc_run_script">Lar appen åpne nye vinduer i Terminalemulatoren, samt kjøre kommandoer i disse. Appen vil da kunne kjøre kommandoer med alle tillatelsene som Terminalemulatoren har, inkludert tilgang til Internett og SD-kortet. </string>
  <string name="perm_append_to_path">Legge til kommandoer i Terminalemulatoren</string>
  <string name="permdesc_append_to_path">Lar appen tilby flere kommandoer (Legge til i PATH) til Terminalemulatoren.</string>
  <string name="perm_prepend_to_path">Overstyr kommandoer i Terminalemulatoren</string>
  <string name="permdesc_prepend_to_path">Lar appen overstyre eksisterende kommandoer med sine egene versjoner (legge til i begynnelsen av PATH) i Terminalemulatoren</string>

  <string name="email_transcript_subject">Transcript fra Android Terminalemulator</string>
  <string name="email_transcript_chooser_title">Mail transcript med:</string>
  <string name="email_transcript_no_email_activity_found">Kunne ikke velge aktivitet for å sende transcript.</string>

  <string name="alt_sends_esc">Alt-tasten sender ESC</string>
  <string name="alt_sends_esc_summary_on">Alt-tasten sender ESC.</string>
  <string name="alt_sends_esc_summary_off">Alt-tasten sender ikke ESC.</string>

  <string name="title_mouse_tracking_preference">Send musebevegelser</string>
  <string name="summary_mouse_tracking_preference">Velg om trykk og scroll-sekvenser skal bli sendt som escape-sekvenser til terminalen.</string>
</resources>

```

`term/src/main/res/values-nl/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--  Copyright (C) 2007 The Android Open Source Project
      Copyright (C) 2012 The CyanogenMod Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Statusbalk tonen</item>
        <item>Statusbalk verbergen</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <item>Menubalk altijd tonen</item>
        <item>Menubalk verbergen (op bovenkant scherm of menuknop tikken om te tonen)</item>
    </string-array>

    <string-array name="entries_orientation_preference">
        <item>Automatisch</item>
        <item>Liggend</item>
        <item>Staand</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Geen knipperende cursor</item>
        <item>Knipperende cursor</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Rechthoek</item>
        <item>Onderlijnd</item>
        <item>Verticale balk</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 pixels</item>
        <item>6 pnt.</item>
        <item>7 pnt.</item>
        <item>8 pnt.</item>
        <item>9 pnt.</item>
        <item>10 pnt.</item>
        <item>12 pnt.</item>
        <item>14 pnt.</item>
        <item>16 pnt.</item>
        <item>20 pnt.</item>
        <item>24 pnt.</item>
        <item>28 pnt.</item>
        <item>32 pnt.</item>
        <item>36 pnt.</item>
        <item>42 pnt.</item>
        <item>48 pnt.</item>
        <item>64 pnt.</item>
        <item>72 pnt.</item>
        <item>96 pnt.</item>
        <item>144 pnt.</item>
        <item>288 pnt.</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Zwarte tekst op wit</item>
        <item>Witte tekst op zwart</item>
        <item>Witte tekst op blauw</item>
        <item>Groene tekst op zwart</item>
        <item>Oranje tekst op zwart</item>
        <item>Rode tekst op zwart</item>
        <item>Holo-blauwe tekst op zwart</item>
        <item>Gesolariseerd licht</item>
        <item>Gesolariseerd donker</item>
        <item>Linux console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Alle terminalvensters sluiten</item>
        <item>Alleen huidige terminalvensters sluiten</item>
        <item>App sluiten, sessies open laten</item>
        <item>ESC naar terminal sturen</item>
        <item>TAB naar terminal sturen</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Trackball</item>
        <item>\@-knop</item>
        <item>Linker Alt-knop</item>
        <item>Rechter Alt-knop</item>
        <item>Volume omhoog-knop</item>
        <item>Volume omlaag-knop</item>
        <item>Cameraknop</item>
        <item>Geen</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Trackball</item>
        <item>\@-knop</item>
        <item>Linker Alt-knop</item>
        <item>Rechter Alt-knop</item>
        <item>Volume omhoog-knop</item>
        <item>Volume omlaag-knop</item>
        <item>Cameraknop</item>
        <item>Geen</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Karaktergebaseerd</item>
        <item>Woordgebaseerd</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Alt-links</item>
        <item>Alt-rechts</item>
        <item>Volume+</item>
        <item>Volume-</item>
        <item>Camera</item>
        <item>Geen</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Alt-links</item>
        <item>Alt-rechts</item>
        <item>Volume+</item>
        <item>Volume-</item>
        <item>Camera</item>
        <item>Geen</item>
    </string-array>
</resources>

```

`term/src/main/res/values-nl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal</string>
   <string name="preferences">Instellingen</string>
   <string name="new_window">Nieuw venster</string>
   <string name="close_window">Venster sluiten</string>
   <string name="window_list">Vensters</string>
   <string name="prev_window">Vorig venster</string>
   <string name="next_window">Volgend venster</string>
   <string name="reset">Herstellen</string>
   <string name="send_email">E-mail sturen naar</string>
   <string name="special_keys">Speciale knoppen</string>
   <string name="toggle_soft_keyboard">Toetsenbord aan/uit</string>

   <string name="enable_wakelock">Slaapblokkering aan</string>
   <string name="disable_wakelock">Slaapblokkering uit</string>
   <string name="enable_wifilock">Wifi-blokkering aan</string>
   <string name="disable_wifilock">Wifi-blokkering uit</string>

   <string name="edit_text">Tekst wijzigen</string>
   <string name="select_text">Selecteer tekst</string>
   <string name="copy_all">Alles kopiëren</string>
   <string name="paste">Plakken</string>

   <string name="service_notify_text">Terminalsessie is actief</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Scherm</string>

   <string name="title_statusbar_preference">Statusbalk</string>
   <string name="summary_statusbar_preference">Statusbalk tonen/verbergen</string>
   <string name="dialog_title_statusbar_preference">Statusbalk</string>

   <string name="title_actionbar_preference">Menubalk</string>
   <string name="summary_actionbar_preference">Gedrag van menubalk kiezen (Android 3.0 en hoger)</string>
   <string name="dialog_title_actionbar_preference">Gedrag menubalk</string>

   <string name="title_orientation_preference">Oriëntatie van het scherm</string>
   <string name="summary_orientation_preference">Oriëntatie van het scherm kiezen</string>
   <string name="dialog_title_orientation_preference">Oriëntatie van het scherm</string>

   <string name="title_cursorstyle_preference">Cursorstijl</string>
   <string name="summary_cursorstyle_preference">Cursorstijl kiezen</string>
   <string name="dialog_title_cursorstyle_preference">Cursorstijl</string>

   <string name="title_cursorblink_preference">Cursorblink</string>
   <string name="summary_cursorblink_preference">Cursorblink kiezen</string>
   <string name="dialog_title_cursorblink_preference">Cursorblink</string>

   <string name="text_preferences">Tekst</string>

   <string name="title_utf8_by_default_preference">UTF-8</string>
   <string name="summary_utf8_by_default_preference">UTF-8 standaard inschakelen</string>

   <string name="title_fontsize_preference">Lettergrootte</string>
   <string name="summary_fontsize_preference">Karakterhoogte in punten kiezen</string>
   <string name="dialog_title_fontsize_preference">Lettergrootte</string>

   <string name="title_color_preference">Kleuren</string>
   <string name="summary_color_preference">Tekstkleur kiezen</string>
   <string name="dialog_title_color_preference">Tekstkleur</string>

   <string name="keyboard_preferences">Toetsenbord</string>

   <string name="title_backaction_preference">Terugknop</string>
   <string name="summary_backaction_preference">Bepalen wat de terugknop doet</string>
   <string name="dialog_title_backaction_preference">Gedrag terugknop</string>

   <string name="title_controlkey_preference">Control-knop</string>
   <string name="summary_controlkey_preference">Control-knop kiezen</string>
   <string name="dialog_title_controlkey_preference">Control-knop</string>

   <string name="title_fnkey_preference">Fn-knop</string>
   <string name="summary_fnkey_preference">Functieknop kiezen</string>
   <string name="dialog_title_fnkey_preference">Fn-knop</string>

   <string name="title_ime_preference">Invoermethode</string>
   <string name="summary_ime_preference">Invoermethode voor toetsenbord kiezen</string>
   <string name="dialog_title_ime_preference">Invoermethode</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Opdrachtregel</string>
   <string name="summary_shell_preference">Opdrachtregel-shell opgeven</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Beginopdracht</string>
   <string name="summary_initialcommand_preference">Wordt naar de shell verzonden bij opstarten</string>
   <string name="dialog_title_initialcommand_preference">Beginopdracht</string>

   <string name="title_termtype_preference">Soort terminal</string>
   <string name="summary_termtype_preference">Welk soort terminal te melden aan de shell</string>
   <string name="dialog_title_termtype_preference">Soort terminal</string>

   <string name="title_close_window_on_process_exit_preference">Venster sluiten bij exit</string>
   <string name="summary_close_window_on_process_exit_preference">Venster sluiten als de shell afgesloten wordt</string>

   <string name="title_verify_path_preference">PATH entries controleren</string>
   <string name="summary_verify_path_preference">Controleren of ontoegankelijk directories verwijderd moeten worden uit het PATH</string>

   <string name="title_do_path_extensions_preference">PATH-extensies toestaan</string>
   <string name="summary_do_path_extensions_preference">Andere apps toestaan om extra opdrachten te verstrekken (aan PATH toevoegen)</string>

   <string name="title_allow_prepend_path_preference">PATH prepend toestaan</string>
   <string name="summary_allow_prepend_path_preference">Andere apps toestaan om bestaande opdrachten te overschrijven (voor PATH invoegen).</string>

   <string name="title_home_path_preference">HOME folder</string>
   <string name="summary_home_path_preference">Pad naar een beschrijfbare map te gebruiken als HOME</string>

   <string name="control_key_dialog_title">Control- en functieknoppen</string>

   <string name="control_key_dialog_control_text">CTRLKEY spatie : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
   <string name="control_key_dialog_control_disabled_text">Geen controlknop ingesteld</string>

  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Omhoog\nFNKEY A : Links\nFNKEY S : Omlaag\nFNKEY D : Rechts\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pijpje)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Geen functieknop ingesteld</string>

  <string name="confirm_window_close_message">Dit venster sluiten?</string>

  <string name="email_transcript_subject">Gegevens uit Terminal Emulator for Android</string>
  <string name="email_transcript_chooser_title">Gegevens e-mailen via:</string>
  <string name="email_transcript_no_email_activity_found">Kon geen e-mail activity kiezen om gegevens te sturen</string>

  <string name="alt_sends_esc">Alt-knop stuurt ESC</string>
  <string name="alt_sends_esc_summary_on">Alt-knop stuurt ESC</string>
  <string name="alt_sends_esc_summary_off">Alt-knop stuurt geen ESC</string>

  <string name="title_mouse_tracking_preference">Muisgebeurtenissen sturen</string>
  <string name="summary_mouse_tracking_preference">Tikken en scrollen naar de terminal sturen als \'escape sequences\'</string>

  <string name="title_use_keyboard_shortcuts">Sneltoesten gebruiken</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: venster wisselen, Ctrl-Shift-N: nieuw venster, Ctrl-Shift-V: plakken</string>
  <string name="use_keyboard_shortcuts_summary_off">Sneltoesten zijn uitgeschakeld</string>

  <string name="activity_term_here_title">Terminal</string>

  <string name="activity_shortcut_create">"Terminal snelkoppeling"</string>

  <string name="fsnavigator_title">BESTANDSKIEZER</string>
  <string name="fsnavigator_no_external_storage">Externe opslag niet beschikbaar</string>
  <string name="fsnavigator_optional_enter_path">Of voer hier pad in</string>
  <string name="fsnavigator_change_theme">Thema veranderen</string>

  <string name="addshortcut_command_hint">opdracht</string>
  <string name="addshortcut_example_hint">--voorbeeld=\""a\"</string>
  <string name="addshortcut_button_find_command">Opdracht vinden</string>
  <string name="addshortcut_navigator_title">DOEL SNELKOPPELING KIEZEN</string>
  <string name="addshortcut_command_window_instructions">Opdrachtvenster vereist volledig pad, zonder toevoegingen. Voor extra opdrachten, gebruikt het veld \'Toevoeging\' (bijv: cd /sdcard).</string>
  <string name="addshortcut_arguments_label">Toevoeging\:</string>
  <string name="addshortcut_shortcut_label">Naam snelkoppeling\:</string>
  <string name="addshortcut_button_text_icon">Tekstpictogram</string>
  <string name="addshortcut_make_text_icon">TEKSTPICTOGRAM MAKEN</string>
  <string name="addshortcut_title">Terminal snelkoppeling</string>

  <string name="colorvalue_label_lock_button_column">VAST</string>
  <string name="colorvalue_icon_text_entry_hint">Pictogramtekst</string>
</resources>

```

`term/src/main/res/values-pl/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Pokaż pasek stanu</item>
        <item>Ukryj pasek stanu</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Pasek narzędziowy wyłączony</item> -->
        <item>Zawsze pokazuj pasek narzędziowy</item>
        <item>Ukryj pasek narzędzi (dotknij góry ekranu lub przycisk Menu, aby wyświetlić)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Niemigający kursor</item>
        <item>Migający kursor</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Prostokąt</item>
        <item>Podkreślenie</item>
        <item>Poziomy pasek</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 pixeli</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Czarny tekst na białym tle</item>
        <item>Biały tekst na czarnym tle</item>
        <item>Biały tekst na niebieskim tle</item>
        <item>Zielony tekst na czarnym tle</item>
        <item>Bursztynowy tekst na czarnym tle</item>
        <item>Czerwony tekst na czarnym tle</item>
        <item>Błękitny tekst na czarnym tle</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Zamyka wszystkie okna terminala</item>
        <item>Zamyka tylko aktualne okno terminala</item>
        <item>Ukrywa program, pozostawiając sesję w tle</item>
        <item>Wysyła klawisz ESC do terminala</item>
        <item>Wysyła klawisz TAB do terminala</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Kulka/tackball</item>
        <item>Przycisk \@</item>
        <item>Lewy Alt</item>
        <item>Prawy Alt</item>
        <item>Przycisk zwiększania głośności</item>
        <item>Przycisk zmniejszania głośności</item>
        <item>Przycisk aparatu</item>
        <item>Żaden</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Kulka/tackball</item>
        <item>Przycisk \@</item>
        <item>Lewy Alt</item>
        <item>Prawy Alt</item>
        <item>Przycisk zwiększania głośności</item>
        <item>Przycisk zmniejszania głośności</item>
        <item>Przycisk aparatu</item>
        <item>Żaden</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Oparta o litery</item>
        <item>Oparta o słowa</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Kulka</item>
        <item>\@</item>
        <item>Lewy Alt</item>
        <item>Prawy Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Aparat</item>
        <item>Żaden</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Kulka</item>
        <item>\@</item>
        <item>Lewy Alt</item>
        <item>Prawy</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Aparat</item>
        <item>Żaden</item>
    </string-array>
</resources>

```

`term/src/main/res/values-pl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal Emulator</string>
   <string name="preferences">Ustawienia</string>
   <string name="new_window">Nowe okno</string>
   <string name="close_window">Zamknij okno</string>
   <string name="window_list">Okna</string>
   <string name="prev_window">Poprzednie okno</string>
   <string name="next_window">Następne okno</string>
   <string name="reset">Wyczyść terminal</string>
   <string name="send_email">Wyślij e-mail</string>
   <string name="special_keys">Przyciski specjalne</string>
   <string name="toggle_soft_keyboard">Pokaż klawiaturę</string>

   <string name="reset_toast_notification">Stan tego okna terminala został zresetowany</string>

   <string name="enable_wakelock">Weź WakeLock</string>
   <string name="disable_wakelock">Zwolnij WakeLock</string>
   <string name="enable_wifilock">Weź WifiLock</string>
   <string name="disable_wifilock">Zwolnij WifiLock</string>

   <string name="edit_text">Edytuj tekst</string>
   <string name="select_text">Wybierz tekst</string>
   <string name="copy_all">Kopiuj wszystko</string>
   <string name="paste">Wklej</string>
   <string name="send_control_key">Wyślij przycisk control</string>
   <string name="send_fn_key">Wyślij przycisk fn</string>

   <string name="window_title">Okno %1$d</string>

   <string name="service_notify_text">Sesja Terminala jest włączona</string>

   <string name="process_exit_message">Sesja Terminala została zakończona</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Ekran</string>

   <string name="title_statusbar_preference">Pasek stanu</string>
   <string name="summary_statusbar_preference">Pokaż/ukryj pasek stanu.</string>
   <string name="dialog_title_statusbar_preference">Pasek stanu</string>

   <string name="title_actionbar_preference">Pasek akcji</string>
   <string name="summary_actionbar_preference">Wybierz zachowanie paska akcji (Android 3.0 i nowsze).</string>
   <string name="dialog_title_actionbar_preference">Zachowanie paska akcji</string>

   <string name="title_cursorstyle_preference">Styl kursora</string>
   <string name="summary_cursorstyle_preference">Wybierz styl kursora.</string>
   <string name="dialog_title_cursorstyle_preference">Styl kursora</string>

   <string name="title_cursorblink_preference">Miganie kursora</string>
   <string name="summary_cursorblink_preference">Wybierz miganie kursora.</string>
   <string name="dialog_title_cursorblink_preference">Miganie kursora</string>

   <string name="text_preferences">Tekst</string>

   <string name="title_utf8_by_default_preference">Domyślnie do UTF-8</string>
   <string name="summary_utf8_by_default_preference">Czy tryb UTF-8 jest włączony domyślnie.</string>

   <string name="title_fontsize_preference">Rozmiar czcionki</string>
   <string name="summary_fontsize_preference">Wybierz wielkość liter.</string>
   <string name="dialog_title_fontsize_preference">Rozmiar czcionki</string>

   <string name="title_color_preference">Kolory</string>
   <string name="summary_color_preference">Wybierz kolor tekstu.</string>
   <string name="dialog_title_color_preference">Kolor tekstu</string>

   <string name="keyboard_preferences">Klawiatura</string>

   <string name="title_backaction_preference">Zachowanie przycisku wstecz</string>
   <string name="summary_backaction_preference">Wybierz co ma robić wciśniecie przycisku wstecz.</string>
   <string name="dialog_title_backaction_preference">Zachowanie przycisku wstecz</string>

   <string name="title_controlkey_preference">Przycisk control</string>
   <string name="summary_controlkey_preference">Wybierz przycisk control.</string>
   <string name="dialog_title_controlkey_preference">Przycisk control</string>

   <string name="title_fnkey_preference">Przycisk Fn</string>
   <string name="summary_fnkey_preference">Wybierz przycisk Fn.</string>
   <string name="dialog_title_fnkey_preference">Przycisk Fn</string>

   <string name="title_ime_preference">Metoda wprowadzania</string>
   <string name="summary_ime_preference">Wybierz metodę wprowadzania.</string>
   <string name="dialog_title_ime_preference">Metoda wprowadzania</string>

   <string name="shell_preferences">Powłoka</string>
   <string name="title_shell_preference">Linia poleceń</string>
   <string name="summary_shell_preference">Określ linię powłokę.</string>
   <string name="dialog_title_shell_preference">Powłoka</string>

   <string name="title_initialcommand_preference">Komenda początkowa</string>
   <string name="summary_initialcommand_preference">Wysyłana do powłoki podczas startu.</string>
   <string name="dialog_title_initialcommand_preference">Komenda początkowa</string>

   <string name="title_termtype_preference">Typ Terminala</string>
   <string name="summary_termtype_preference">Jaki typ terminala zgłosić do shella.</string>
   <string name="dialog_title_termtype_preference">Typ Terminala</string>

   <string name="title_close_window_on_process_exit_preference">Zamknij okno przy wyjściu</string>
   <string name="summary_close_window_on_process_exit_preference">Czy okno powinno się zamknąć gdy jego shell się zamyka.</string>

   <string name="title_verify_path_preference">Weryfikuj ścieżki PATH</string>
   <string name="summary_verify_path_preference">Czy niedostępne katalogi powinny być usunięte z PATH.</string>

   <string name="title_do_path_extensions_preference">Zezwól na rozszerzanie PATH</string>
   <string name="summary_do_path_extensions_preference">Czy inne aplikacje powinny mieć możliwość dostarczania dodatkowych komend (dodawanie do PATH).</string>

   <string name="title_allow_prepend_path_preference">Zazwól na dodawanie na początku PATH</string>
   <string name="summary_allow_prepend_path_preference">Czy inne aplikacje powinny mieć możliwość nadpisywania istniejących komend (dodawanie na początku PATH).</string>

   <string name="control_key_dialog_title">Przyciski Control i Fn</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Spacja : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Brak ustawionego przycisku Control.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Góra\nFNKEY A : Lewo\nFNKEY S : Dół\nFNKEY D : Prawo\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Brak ustawionego przycisku Fn.</string>

  <string name="confirm_window_close_message">Zamknąć to okno?</string>

  <string name="perm_run_script">Uruchamiaj komendy w Terminal Emulator</string>
  <string name="permdesc_run_script">Pozwalaj na otwieranie okien w Terminal Emulator for Android i wykonywanie komend w tych oknach z wszystkimi prawami Terminal Emulator for Android, wliczając dostęp do internetu i karty SD.</string>
  <string name="perm_append_to_path">Dodawanie komend w Terminal Emulator</string>
  <string name="permdesc_append_to_path">Pozwól aplikacjom na dodawanie dodatkowych komend (odawanie katalogów do PATH) w Terminal Emulator for Android.</string>
  <string name="perm_prepend_to_path">Nadpisuj komendy Terminal Emulator</string>
  <string name="permdesc_prepend_to_path">Pozwól aplikacjom na nadpisywanie istniejących komend ich własnymi wersjami (dodawanie katalogów na początku PATH) w Terminal Emulator for Android.</string>

  <string name="email_transcript_subject">Transkrypt z Terminal Emulator for Android</string>
  <string name="email_transcript_chooser_title">Wyślij transkrypt używając:</string>
  <string name="email_transcript_no_email_activity_found">Nie można wybrać aktywności e-mail żeby wysłać transkrypt.</string>

  <string name="alt_sends_esc">Przycisk Alt wysyła ESC</string>
  <string name="alt_sends_esc_summary_on">Przycisk Alt wysyła ESC.</string>
  <string name="alt_sends_esc_summary_off">Przycisk Alt nie wysyła ESC.</string>

</resources>

```

`term/src/main/res/values-pt-rPT/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Mostrar barra de notificações</item>
        <item>Esconder barra de notificações</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Barra de ação</item> -->
        <item>Mostrar barra de ação</item>
        <item>Ocultar barra de ação (tocar no topo de ecrã ou na tecla Menu para mostrar)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Cursor fixo</item>
        <item>Cursor a piscar</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Rectangular</item>
        <item>Sublinhado</item>
        <item>Barra vertical</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 píxeis</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Texto preto em fundo branco</item>
        <item>Texto branco em fundo preto</item>
        <item>Texto branco em fundo azul</item>
        <item>Texto verde em fundo preto</item>
        <item>Texto âmbar em fundo preto</item>
        <item>Texto vermelho em fundo preto</item>
        <item>Texto azul em fundo preto</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Fechar todas as janelas</item>
        <item>Fechar esta janela</item>
        <item>Fechar atividades e manter sessão</item>
        <item>Envia ESC ao terminal</item>
        <item>Envia TAB ao terminal</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Trackball</item>
        <item>Tecla \@</item>
        <item>Tecla Alt esquerda</item>
        <item>Tecla Alt direita</item>
        <item>Aum. volume</item>
        <item>Dim. volume</item>
        <item>Tecla da câmara</item>
        <item>Nenhuma</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
       <item>Trackball</item>
        <item>Tecla \@</item>
        <item>Tecla Alt esquerda</item>
        <item>Tecla Alt direita</item>
        <item>Aum. volume</item>
        <item>Dim. volume</item>
        <item>Tecla da câmara</item>
        <item>Nenhuma</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Baseado em caracteres</item>
        <item>Baseado em palavras</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Alt esq.</item>
        <item>Alt dir.</item>
        <item>Aum. vol.</item>
        <item>Dim vol.</item>
        <item>Câmara</item>
        <item>Nenhuma</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Alt esq.</item>
        <item>Alt dir.</item>
        <item>Aum. vol.</item>
        <item>Dim. vol.</item>
        <item>Câmara</item>
        <item>Nenhuma</item>
    </string-array>

</resources>

```

`term/src/main/res/values-pt-rPT/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal Emulator</string>
   <string name="preferences">Preferências</string>
   <string name="reset">Reset terminal</string>
   <string name="send_email">Email para</string>
   <string name="special_keys">Teclas especiais</string>
   <string name="toggle_soft_keyboard">Abrir teclado</string>

   <string name="edit_text">Editar texto</string>
   <string name="select_text">Seleccionar texto</string>
   <string name="copy_all">Copiar tudo</string>
   <string name="paste">Colar</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Ecrã</string>

   <string name="title_statusbar_preference">Barra de notificações</string>
   <string name="summary_statusbar_preference">Mostrar/esconder barra de notificações</string>
   <string name="dialog_title_statusbar_preference">Barra de notificações</string>

   <string name="title_cursorstyle_preference">Estilo do cursor</string>
   <string name="summary_cursorstyle_preference">Escolha o estilo do cursor</string>
   <string name="dialog_title_cursorstyle_preference">Estilo do cursor</string>

   <string name="title_cursorblink_preference">Piscar do cursor</string>
   <string name="summary_cursorblink_preference">Escolher piscar do cursor</string>
   <string name="dialog_title_cursorblink_preference">Piscar do cursor</string>

   <string name="text_preferences">Texto</string>

   <string name="title_fontsize_preference">Tamanho do texto</string>
   <string name="summary_fontsize_preference">Escolher a altura dos caracteres em pontos</string>
   <string name="dialog_title_fontsize_preference">Tamanho do texto</string>

   <string name="title_color_preference">Côres</string>
   <string name="summary_color_preference">Escolher côr do texto</string>
   <string name="dialog_title_color_preference">Côr do texto</string>

   <string name="keyboard_preferences">Teclado</string>

   <string name="title_controlkey_preference">Tecla control</string>
   <string name="summary_controlkey_preference">Escolher tecla control</string>
   <string name="dialog_title_controlkey_preference">Tecla control</string>

   <string name="title_ime_preference">Método de entrada</string>
   <string name="summary_ime_preference">Escolher método de entrada</string>
   <string name="dialog_title_ime_preference">Método de entrada</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Linha de comandos</string>
   <string name="summary_shell_preference">Especificar a linha de comando do shell</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Comando inicial</string>
   <string name="summary_initialcommand_preference">Enviar para o shell no arranque</string>
   <string name="dialog_title_initialcommand_preference">Comando inicial</string>

</resources>

```

`term/src/main/res/values-pt/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Mostrar barra de estado</item>
        <item>Ocultar barra de estado</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Barra de ação</item> -->
        <item>Mostrar barra de ação</item>
        <item>Ocultar barra de ação (tocar no topo de ecrã ou na tecla Menu para mostrar)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Cursor não intermitente</item>
        <item>Cursor intermitente</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Retângulo</item>
        <item>Sublinhado</item>
        <item>Barra vertical</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 pixeis</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Texto preto em branco</item>
        <item>Texto branco em preto</item>
        <item>Texto branco em azul</item>
        <item>Texto verde em preto</item>
        <item>Texto âmbar em preto</item>
        <item>Texto vermelho em preto</item>
        <item>Texto azul em preto</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Fechar todas as janelas</item>
        <item>Fechar esta janela</item>
        <item>Fechar atividades e manter sessão</item>
        <item>Envia ESC ao terminal</item>
        <item>Envia TAB ao terminal</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Trackball</item>
        <item>Tecla \@</item>
        <item>Tecla Alt esquerda</item>
        <item>Tecla Alt direita</item>
        <item>Aum. volume</item>
        <item>Dim. volume</item>
        <item>Tecla da câmara</item>
        <item>Nenhuma</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
       <item>Trackball</item>
        <item>Tecla \@</item>
        <item>Tecla Alt esquerda</item>
        <item>Tecla Alt direita</item>
        <item>Aum. volume</item>
        <item>Dim. volume</item>
        <item>Tecla da câmara</item>
        <item>Nenhuma</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Caracteres</item>
        <item>Palavra</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Alt esq.</item>
        <item>Alt dir.</item>
        <item>Aum. vol.</item>
        <item>Dim vol.</item>
        <item>Câmara</item>
        <item>Nenhuma</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Alt esq.</item>
        <item>Alt dir.</item>
        <item>Aum. vol.</item>
        <item>Dim. vol.</item>
        <item>Câmara</item>
        <item>Nenhuma</item>
    </string-array>

</resources>

```

`term/src/main/res/values-pt/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Emulador de Terminal</string>
   <string name="preferences">Preferências</string>
   <string name="new_window">Nova janela</string>
   <string name="close_window">Fechar janela</string>
   <string name="window_list">Janelas</string>
   <string name="prev_window">Anterior</string>
   <string name="next_window">Seguinte</string>
   <string name="reset">Repor terminal</string>
   <string name="send_email">Enviar mensagem para</string>
   <string name="special_keys">Teclas especiais</string>
   <string name="toggle_soft_keyboard">Mostrar/ocultar teclado</string>

   <string name="reset_toast_notification">O estado desta janela foi restaurado.</string>

   <string name="enable_wakelock">Obter WakeLock</string>
   <string name="disable_wakelock">Largar WakeLock</string>
   <string name="enable_wifilock">Obter WifiLock</string>
   <string name="disable_wifilock">Largar WifiLock</string>

   <string name="edit_text">Editar texto</string>
   <string name="select_text">Selecionar texto</string>
   <string name="copy_all">Copiar tudo</string>
   <string name="paste">Colar</string>
   <string name="send_control_key">Enviar tecla control</string>
   <string name="send_fn_key">Enviar tecla fn</string>

   <string name="window_title">Janela %1$d</string>

   <string name="service_notify_text">A sessão do Terminal está em execução</string>

   <string name="process_exit_message">A sessão do Terminal terminou</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Ecrã</string>

   <string name="title_statusbar_preference">Barra de estado</string>
   <string name="summary_statusbar_preference">Mostrar/ocultar barra de estado.</string>
   <string name="dialog_title_statusbar_preference">Barra de estado</string>

   <string name="title_actionbar_preference">Barra de ação</string>
   <string name="summary_actionbar_preference">Escolha o comportamento da barra de ação (Android 3.0 ou superior).</string>
   <string name="dialog_title_actionbar_preference">Comportamento da barra de ação</string>

   <string name="title_cursorstyle_preference">Estilo do cursor</string>
   <string name="summary_cursorstyle_preference">Escolha o estilo do cursor.</string>
   <string name="dialog_title_cursorstyle_preference">Estilo do cursor</string>

   <string name="title_cursorblink_preference">Intermitência</string>
   <string name="summary_cursorblink_preference">Escolha a intermitência do cursor.</string>
   <string name="dialog_title_cursorblink_preference">Intermitência</string>

   <string name="text_preferences">Texto</string>

   <string name="title_utf8_by_default_preference">UTF-8 por definição</string>
   <string name="summary_utf8_by_default_preference">Se o modo UTF-8 está ativo por definição.</string>

   <string name="title_fontsize_preference">Tamanho da letra</string>
   <string name="summary_fontsize_preference">Escolha a altura das letras (em pontos).</string>
   <string name="dialog_title_fontsize_preference">Tamanho da letra</string>

   <string name="title_color_preference">Cores</string>
   <string name="summary_color_preference">Escolha a cor do texto.</string>
   <string name="dialog_title_color_preference">Cor do texto</string>

   <string name="keyboard_preferences">Teclado</string>

   <string name="title_backaction_preference">Comportamento do botão Voltar</string>
   <string name="summary_backaction_preference">Escolha a ação do botão Voltar.</string>
   <string name="dialog_title_backaction_preference">Comportamento do botão Voltar</string>

   <string name="title_controlkey_preference">Tecla Control</string>
   <string name="summary_controlkey_preference">Escolha a tecla control.</string>
   <string name="dialog_title_controlkey_preference">Tecla Control</string>

   <string name="title_fnkey_preference">Tecla Fn</string>
   <string name="summary_fnkey_preference">Escolha a tecla Fn.</string>
   <string name="dialog_title_fnkey_preference">Tecla Fn</string>

   <string name="title_ime_preference">Método de inserção</string>
   <string name="summary_ime_preference">Escolha o método de inserção do teclado.</string>
   <string name="dialog_title_ime_preference">Método de inserção</string>

   <string name="shell_preferences">Consola</string>
   <string name="title_shell_preference">Linha de comandos</string>
   <string name="summary_shell_preference">Indique a linha de comandos da consola.</string>
   <string name="dialog_title_shell_preference">Consola</string>

   <string name="title_initialcommand_preference">Comando inicial</string>
   <string name="summary_initialcommand_preference">O comando inicial da consola.</string>
   <string name="dialog_title_initialcommand_preference">Comando inicial</string>

   <string name="title_termtype_preference">Tipo de Terminal</string>
   <string name="summary_termtype_preference">O tipo de terminal a reportar à consola.</string>
   <string name="dialog_title_termtype_preference">Tipo de Terminal</string>

   <string name="title_close_window_on_process_exit_preference">Fechar janela ao sair</string>
   <string name="summary_close_window_on_process_exit_preference">Se a janela deve ser fechada ao fechar a consola.</string>

   <string name="title_verify_path_preference">Verificar as entradas PATH</string>
   <string name="summary_verify_path_preference">Se os diretórios inacessíveis devem ser removidos do PATH.</string>

   <string name="title_do_path_extensions_preference">Permitir extensões PATH</string>
   <string name="summary_do_path_extensions_preference">Se outras aplicações podem enviar comandos adicionais (adicionar a PATH).</string>

   <string name="title_allow_prepend_path_preference">Permitir preceder PATH</string>
   <string name="summary_allow_prepend_path_preference">Se outras aplicações podem substituir os comandos existentes (anteceder a PATH).</string>

   <string name="control_key_dialog_title">Teclas Control e Fn</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY espaço : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Nenhuma tecla definida.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Cima\nFNKEY A : Esquerda\nFNKEY S : Baixo\nFNKEY D : Direita\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Nenhuma tecla definida.</string>

  <string name="confirm_window_close_message">Fechar janela?</string>

  <string name="perm_run_script">Executar comandos aleatórios no emulador de terminal</string>
  <string name="permdesc_run_script">Permite que a aplicação abra janelas no emulador de terminal e executar comandos nessas janelas com todas as permissões, incluido o acesso à Internet e aos cartão SD.</string>
  <string name="perm_append_to_path">Adicionar comandos ao emulador de terminal</string>
  <string name="permdesc_append_to_path">Permite a disponibilização de comandos adicionais (adicionar diretórios em PATH) no emulador de terminal Android.</string>
  <string name="perm_prepend_to_path">Substituir comandos do emulador de terminal</string>
  <string name="permdesc_prepend_to_path">Permite que a aplicação substitua os comandos existentes pelos seus (anteceder diretórios em PATH) no emulador de terminal Android.</string>
</resources>

```

`term/src/main/res/values-ro/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Arătaţi bara de stare</item>
        <item>Ascundeţi bara de stare</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Bara de acţiune dezactivată</item> -->
        <item>Arătaţi mereu bara de acţiune</item>
        <item>Ascundeţi bara de acţiune (atingeţi partea de sus a ecranului sau tasta de Meniu pentru a arăta)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Cursorul nu clipeşte</item>
        <item>Cursorul clipeşte</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Dreptunghi</item>
        <item>Subliniat</item>
        <item>Bară verticală</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 pixeli</item>
        <item>6 puncte</item>
        <item>7 puncte</item>
        <item>8 puncte</item>
        <item>9 puncte</item>
        <item>10 puncte</item>
        <item>12 puncte</item>
        <item>14 puncte</item>
        <item>16 puncte</item>
        <item>20 puncte</item>
        <item>24 puncte</item>
        <item>28 puncte</item>
        <item>32 puncte</item>
        <item>36 puncte</item>
        <item>42 puncte</item>
        <item>48 puncte</item>
        <item>64 puncte</item>
        <item>72 puncte</item>
        <item>96 puncte</item>
        <item>144 puncte</item>
        <item>288 puncte</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Text negru pe alb</item>
        <item>Text alb pe negru</item>
        <item>Text alb pe albastru</item>
        <item>Text verde pe negru</item>
        <item>Text galben pe negru</item>
        <item>Text roşu pe negru</item>
        <item>Text holo albastru pe negru</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Închide toate ferestrele</item>
        <item>Se închide această fereastră numai</item>
        <item>Se închide activitatea, lăsând sesiunea să funcţioneze</item>
        <item>Trimite ESC spre terminal</item>
        <item>Trimite TAB spre terminal</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Balon Jog</item>
        <item>Tasta \@</item>
        <item>Tasta Alt stângă</item>
        <item>Tasta Alt dreaptă</item>
        <item>Tasta Volum mărire</item>
        <item>Tasta Volum micşorare</item>
        <item>Tasta Cameră foto</item>
        <item>Niciuna</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Balon Jog</item>
        <item>Tasta \@</item>
        <item>Tasta Alt stângă</item>
        <item>Tasta Alt dreaptă</item>
        <item>Tasta Volum mărire</item>
        <item>Tasta Volum micşorare</item>
        <item>Tasta Cameră foto</item>
        <item>Niciuna</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Bazat pe caracter</item>
        <item>Bazat pe cuvânt</item>
    </string-array>

    <string-array name="control_keys_short_names">
        <item>Balon</item>
        <item>\@</item>
        <item>Alt stânga</item>
        <item>Alt dreapta</item>
        <item>Volum mărire</item>
        <item>Volum micşorare</item>
        <item>Cameră foto</item>
        <item>Niciunul</item>
    </string-array>

    <string-array name="fn_keys_short_names">
        <item>Balon</item>
        <item>\@</item>
        <item>Alt stânga</item>
        <item>Alt dreapta</item>
        <item>Volum mărire</item>
        <item>Volum micşorare</item>
        <item>Cameră foto</item>
        <item>Niciunul</item>
    </string-array>
</resources>

```

`term/src/main/res/values-ro/strings.xml`:

```xml
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
--><resources>
   <string name="application_terminal">"Emulator Terminal"</string>
   <string name="preferences">"Preferinţe"</string>
   <string name="new_window">"Fereastră nouă"</string>
   <string name="close_window">"Închideţi fereastra"</string>
   <string name="window_list">"Ferestre"</string>
   <string name="prev_window">"Fereastra anterioră"</string>
   <string name="next_window">"Fereastra următoare"</string>
   <string name="reset">"Resetaţi "</string>
   <string name="send_email">"E-mail"</string>
   <string name="special_keys">"Taste speciale"</string>
   <string name="toggle_soft_keyboard">"Comutați tastatura"</string>

   <string name="reset_toast_notification">"Această fereastră a fost resetată."</string>

   <string name="edit_text">"Editare text"</string>
   <string name="select_text">"Selectaţi textul"</string>
   <string name="copy_all">"Copiați tot"</string>
   <string name="paste">"Lipeşte"</string>
   <string name="send_control_key">"Trimiteţi tasta Control"</string>
   <string name="send_fn_key">"Trimiteţi tasta Fn"</string>

   <string name="window_title">"Fereastră"</string>

   <string name="service_notify_text">"Sesiune de terminal se execută"</string>

   <string name="process_exit_message">"Sesiune de terminal finisată"</string>

   <string name="screen_preferences">"Ecran"</string>

   <string name="title_statusbar_preference">"Bara de stare"</string>
   <string name="summary_statusbar_preference">"Arătaţi/ascundeţi bara de stare."</string>
   <string name="dialog_title_statusbar_preference">"Bara de stare"</string>

   <string name="title_actionbar_preference">"Bara de acţiuni"</string>
   <string name="summary_actionbar_preference">"Alegeți comportamentul barei de acțiuni (Android 3.0 și mai sus)."</string>
   <string name="dialog_title_actionbar_preference">"Comportament bară de acţiune"</string>

   <string name="title_cursorstyle_preference">"Stil cursor"</string>
   <string name="summary_cursorstyle_preference">"Alegeţi stilul cursorului."</string>
   <string name="dialog_title_cursorstyle_preference">"Stil cursor"</string>

   <string name="title_cursorblink_preference">"Clipirea cursorului"</string>
   <string name="summary_cursorblink_preference">"Alegeţi clipirea cursorului."</string>
   <string name="dialog_title_cursorblink_preference">"Clipire cursor"</string>

   <string name="text_preferences">"Text"</string>

   <string name="title_utf8_by_default_preference">"Implicit UTF-8"</string>
   <string name="summary_utf8_by_default_preference">"Dacă modul UTF-8 este activat în mod implicit."</string>

   <string name="title_fontsize_preference">"Dimensiunea fontului"</string>
   <string name="summary_fontsize_preference">"Alegeţi înălțimea caracterelor în puncte."</string>
   <string name="dialog_title_fontsize_preference">"Dimensiunea fontului"</string>

   <string name="title_color_preference">"Culori"</string>
   <string name="summary_color_preference">"Alegeţi culoarea textului."</string>
   <string name="dialog_title_color_preference">"Culoare text"</string>

   <string name="keyboard_preferences">"Tastatură"</string>

   <string name="title_backaction_preference">"Comportamentul butonulul Înapoi"</string>
   <string name="summary_backaction_preference">"Alegeţi ce execută apăsarea butonului Înapoi."</string>
   <string name="dialog_title_backaction_preference">"Comportamentul butonului Înapoi"</string>

   <string name="title_controlkey_preference">"Tasta control"</string>
   <string name="summary_controlkey_preference">"Alegeţi tasta control."</string>
   <string name="dialog_title_controlkey_preference">"Tasta control"</string>

   <string name="title_fnkey_preference">"Tasta Fn"</string>
   <string name="summary_fnkey_preference">"Alegeţi tasta Fn."</string>
   <string name="dialog_title_fnkey_preference">"Tasta Fn"</string>

   <string name="title_ime_preference">"Metoda de intrare"</string>
   <string name="summary_ime_preference">"Alegeți metoda de intrare pentru tastatură."</string>
   <string name="dialog_title_ime_preference">"Metoda de intrare"</string>

   <string name="title_shell_preference">"Linie de comandă"</string>

   <string name="title_initialcommand_preference">"Comandă inițială"</string>
   <string name="dialog_title_initialcommand_preference">"Comandă inițială"</string>

   <string name="title_termtype_preference">"Tip terminal"</string>
   <string name="dialog_title_termtype_preference">"Tip terminal"</string>

   <string name="title_close_window_on_process_exit_preference">"Închideți fereastra la ieșire"</string>

   <string name="title_verify_path_preference">"Verificați intrările PATH"</string>
   <string name="summary_verify_path_preference">"Dacă directoare inaccesibile ar trebui să fie eliminate din PATH."</string>

   <string name="title_do_path_extensions_preference">"Permiteți extensii PATH"</string>
   <string name="summary_do_path_extensions_preference">"Dacă altor aplicații ar trebui să li se permită să furnizeze comenzi suplimentare."</string>

   <string name="title_allow_prepend_path_preference">"Permiteți prefix PATH"</string>
   <string name="summary_allow_prepend_path_preference">"Dacă altor aplicații ar trebui să li se permită să suprascrie comenzile existente."</string>

   <string name="control_key_dialog_title">"Tastele control şi funcționale"</string>
   <string name="control_key_dialog_control_disabled_text">"Nici o tastă control setată."</string>
  <string name="control_key_dialog_fn_disabled_text">"Nici o tastă funcţie setată."</string>

  <string name="confirm_window_close_message">"închideţi această fereastră?"</string>

  <string name="perm_run_script">"Executare comenzi arbitrare în Emulator Terminal"</string>
  <string name="perm_append_to_path">"Adaugaţi comenzi în Emulatorul Terminal"</string>
  <string name="permdesc_append_to_path">"Permiteţi aplicației să furnizeze comenzi suplimentare pentru Emulatorul Terminal Android."</string>
  <string name="perm_prepend_to_path">"Suprascriere comenzi în Emulatorul Terminal"</string>
  <string name="permdesc_prepend_to_path">"Permiteţi aplicației să suprascrie comenzile existente, cu versiunile sale proprii în Emulatorul Terminal Android."</string>

  <string name="alt_sends_esc">"Tasta Alt trimite ESC"</string>
  <string name="alt_sends_esc_summary_on">"Tasta Alt trimite ESC."</string>
  <string name="alt_sends_esc_summary_off">"Tasta Alt nu trimite ESC."</string>
</resources>
```

`term/src/main/res/values-ru/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="control_keys_short_names">
        <item>Трекбол</item>
        <item>\@</item>
        <item>LAlt</item>
        <item>RAlt</item>
        <item>Vol+</item>
        <item>Vol-</item>
        <item>Камера</item>
        <item>Нет</item>
    </string-array>
    <string-array name="entries_actionbar_preference">
        <item>Всегда показывать</item>
        <item>Скрывать панель действий (коснитесь верха экрана или клавиши «Меню», чтобы её показать)</item>
    </string-array>
    <string-array name="entries_backaction_preference">
        <item>Закрыть все окна терминала</item>
        <item>Закрыть текущее окно терминала</item>
        <item>Закрывает приложение, но оставляет запущенным терминал</item>
        <item>Посылает ESC в терминал</item>
        <item>Посылает TAB в терминал</item>
    </string-array>
    <string-array name="entries_color_preference">
        <item>Чёрный на белом</item>
        <item>Белый на чёрном</item>
        <item>Белый на синем</item>
        <item>Зелёный на чёрном</item>
        <item>Жёлтый на чёрном</item>
        <item>Красный на чёрном</item>
        <item>Голубой на чёрном</item>
        <item>Соляризованный светлый</item>
        <item>Соляризованный тёмный</item>
        <item>Консоль Linux</item>
    </string-array>
    <string-array name="entries_controlkey_preference">
        <item>Трекбол</item>
        <item>Клавиша @</item>
        <item>Левый Alt</item>
        <item>Правый Alt</item>
        <item>Громкость вверх</item>
        <item>Громкость вниз</item>
        <item>Клавиша камеры</item>
        <item>Нет</item>
    </string-array>
    <string-array name="entries_cursorblink_preference">
        <item>Немигающий курсор</item>
        <item>Мигающий курсор</item>
    </string-array>
    <string-array name="entries_cursorstyle_preference">
        <item>Прямоугольник</item>
        <item>Подчеркивание</item>
        <item>Вертикальная черта</item>
    </string-array>
    <string-array name="entries_fnkey_preference">
        <item>Трекбол</item>
        <item>Клавиша @</item>
        <item>Левый Alt</item>
        <item>Правый Alt</item>
        <item>Громкость вверх</item>
        <item>Громкость вниз</item>
        <item>Клавиша камеры</item>
        <item>Нет</item>
    </string-array>
    <string-array name="entries_fontsize_preference">
        <item>4 x 8 пикселей</item>
        <item>6 пунктов</item>
        <item>7 пунктов</item>
        <item>8 пунктов</item>
        <item>9 пунктов</item>
        <item>10 пунктов</item>
        <item>12 пунктов</item>
        <item>14 пунктов</item>
        <item>16 пунктов</item>
        <item>20 пунктов</item>
        <item>24 пункта</item>
        <item>28 пунктов</item>
        <item>32 пункта</item>
        <item>36 пунктов</item>
        <item>42 пункта</item>
        <item>48 пунктов</item>
        <item>64 пункта</item>
        <item>72 пункта</item>
        <item>96 пунктов</item>
        <item>144 пункта</item>
        <item>288 пунктов</item>
    </string-array>
    <string-array name="entries_ime_preference">
        <item>По символам</item>
        <item>По словам</item>
    </string-array>
    <string-array name="entries_orientation_preference">
        <item>Автоматически</item>
        <item>Альбомная</item>
        <item>Портретная</item>
    </string-array>
    <string-array name="entries_statusbar_preference">
        <item>Показывать</item>
        <item>Скрывать</item>
    </string-array>
    <string-array name="fn_keys_short_names">
        <item>Трекбол</item>
        <item>\@</item>
        <item>LAlt</item>
        <item>RAlt</item>
        <item>Vol+</item>
        <item>Vol-</item>
        <item>Камера</item>
        <item>Нет</item>
    </string-array>
</resources>

```

`term/src/main/res/values-ru/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="activity_shortcut_create">Ярлык терминала</string>
  <string name="activity_term_here_title">Терминал здесь</string>
  <string name="addshortcut_arguments_label">Аргументы</string>
  <string name="addshortcut_button_find_command">Поиск команды</string>
  <string name="addshortcut_button_text_icon">Текст значок</string>
  <string name="addshortcut_command_hint">command</string>
  <string name="addshortcut_command_window_instructions">Командное окно требует полный путь без аргументов. Для других команд использовать окно Аргументы (пример: CD/SD-карта).</string>
  <string name="addshortcut_example_hint">--пример=\"a\"</string>
  <string name="addshortcut_make_text_icon">СОЗДАТЬ ЗНАЧОК ТЕКСТА</string>
  <string name="addshortcut_navigator_title">ВЫБЕРИТЕ ЦЕЛЬ ЯРЛЫКА</string>
  <string name="addshortcut_shortcut_label">Метка ярлыка</string>
  <string name="addshortcut_title">Ярлык терминала</string>
  <string name="alt_sends_esc">Клавиша Alt посылает ESC</string>
  <string name="alt_sends_esc_summary_off">Клавиша Alt не посылает ESC</string>
  <string name="alt_sends_esc_summary_on">Клавиша Alt посылает ESC</string>
  <string name="application_terminal">Терминал</string>
  <string name="close_window">Закрыть окно</string>
  <string name="colorvalue_icon_text_entry_hint">Введите текст для значка</string>
  <string name="colorvalue_label_lock_button_column">LOCK</string>
  <string name="confirm_window_close_message">Закрыть это окно?</string>
  <string name="control_key_dialog_control_disabled_text">Управляющие клавиши отключены</string>
  <string name="control_key_dialog_control_text">"CTRLKEY + Пробел: Control-@ (NUL)
 CTRLKEY + A..Z: Control-A..Z
 CTRLKEY + 5: Control-]
 CTRLKEY + 6: Control-^
 CTRLKEY + 7: Control-_
 CTRLKEY + 9: F11
 CTRLKEY + 0: F12"</string>
  <string name="control_key_dialog_fn_disabled_text">Функциональные клавиши отключены</string>
  <string name="control_key_dialog_fn_text">"FNKEY 1..9 : F1-F9
 FNKEY + 0: F10
 FNKEY + W: Вверх
 FNKEY + A: Влево
 FNKEY + S: Вниз
 FNKEY + D: Вправо
 FNKEY + P: PageUp
 FNKEY + N: PageDown
 FNKEY + T: Tab
 FNKEY + L: | (вертикальная черта)
 FNKEY + U: _ (подчёркивание)
 FNKEY + E: Control-[ (ESC)
 FNKEY + X: Delete
 FNKEY + I: Insert
 FNKEY + H: Home
 FNKEY + F: End
 FNKEY + .: Control-\\
"</string>
  <string name="control_key_dialog_title">Управляющие и функциональные клавиши</string>
  <string name="copy_all">Копировать всё</string>
  <string name="dialog_title_actionbar_preference">Поведение панели действий</string>
  <string name="dialog_title_backaction_preference">Поведение кнопки «Назад»</string>
  <string name="dialog_title_color_preference">Цвет текста</string>
  <string name="dialog_title_controlkey_preference">Клавиша Control</string>
  <string name="dialog_title_cursorblink_preference">Мигание курсора</string>
  <string name="dialog_title_cursorstyle_preference">Вид курсора</string>
  <string name="dialog_title_fnkey_preference">Клавиша Fn</string>
  <string name="dialog_title_fontsize_preference">Размер шрифта</string>
  <string name="dialog_title_ime_preference">Способ ввода</string>
  <string name="dialog_title_initialcommand_preference">Команды запуска</string>
  <string name="dialog_title_orientation_preference">Поворот экрана</string>
  <string name="dialog_title_shell_preference">Оболочка</string>
  <string name="dialog_title_statusbar_preference">Строка состояния</string>
  <string name="dialog_title_termtype_preference">Тип терминала</string>
  <string name="disable_wakelock">Выключить WakeLock</string>
  <string name="disable_wifilock">Выключить WifiLock</string>
  <string name="edit_text">Изменить</string>
  <string name="email_transcript_chooser_title">Отправить текст из терминала с помощью:</string>
  <string name="email_transcript_no_email_activity_found">Не найдено приложения для отправки текста</string>
  <string name="email_transcript_subject">Вывод терминала Android</string>
  <string name="enable_wakelock">Включить WakeLock</string>
  <string name="enable_wifilock">Включить WifiLock</string>
  <string name="fsnavigator_change_theme">Изменить тему</string>
  <string name="fsnavigator_no_external_storage">Внешние хранилища недоступно</string>
  <string name="fsnavigator_optional_enter_path">Или введите путь здесь</string>
  <string name="fsnavigator_title">ВЫБОР ФАЙЛОВ</string>
  <string name="help">Помощь</string>
  <string name="keyboard_preferences">Клавиатура</string>
  <string name="new_window">Новое окно</string>
  <string name="next_window">Следующее окно</string>
  <string name="paste">Вставить</string>
  <string name="perm_append_to_path">Добавление команд в терминала</string>
  <string name="perm_prepend_to_path">Переопределение команд в терминале</string>
  <string name="perm_run_script">Выполнение произвольных команд в терминале</string>
  <string name="permdesc_append_to_path">Приложение сможет обеспечить дополнительные команды (добавить каталоги в PATH) для терминала.</string>
  <string name="permdesc_prepend_to_path">Позволяет приложению переопределить существующие команды своими (перезаписывать PATH) в терминале.</string>
  <string name="permdesc_run_script">Позволяет приложению открытие новых окон в терминале Android и запуск команд в этих окнах со всеми разрешениями терминала, в том числе доступ к Интернету и SD-карте.</string>
  <string name="preferences">Настройки</string>
  <string name="prev_window">Предыдущее окно</string>
  <string name="process_exit_message">Терминальный сеанс завершён</string>
  <string name="reset">Перезапустить терминал</string>
  <string name="reset_toast_notification">Терминал перезапущен</string>
  <string name="screen_preferences">Экран</string>
  <string name="select_text">Выбрать текст</string>
  <string name="send_control_key">Передать кнопку Control</string>
  <string name="send_email">Отправить по эл.почте</string>
  <string name="send_fn_key">Передать кнопку Fn</string>
  <string name="service_notify_text">Запущен терминальный сеанс</string>
  <string name="shell_preferences">Командная оболочка</string>
  <string name="special_keys">Сочетания клавиш</string>
  <string name="summary_actionbar_preference">Настройка поведения панели действий (Android 3.0 и выше)</string>
  <string name="summary_allow_prepend_path_preference">Разрешить другим приложениям изменять существующие команды (добавление к началу PATH)</string>
  <string name="summary_backaction_preference">Выбор действия при нажатии кнопки «Назад»</string>
  <string name="summary_close_window_on_process_exit_preference">Окно закроется, если выйти из оболочки</string>
  <string name="summary_color_preference">Выбор цветовой гаммы</string>
  <string name="summary_controlkey_preference">Выбор аналога клавиши Control</string>
  <string name="summary_cursorblink_preference">Выберите параметры мигания курсора</string>
  <string name="summary_cursorstyle_preference">Выберите стиль курсора</string>
  <string name="summary_do_path_extensions_preference">Разрешить другим приложениям обеспечивать дополнительные команды (добавление к PATH)</string>
  <string name="summary_fnkey_preference">Выбор аналога клавиши Fn</string>
  <string name="summary_fontsize_preference">Выбор размера шрифта</string>
  <string name="summary_home_path_preference">Установка пути к папке, которая будет использована в качестве домашней (должны быть права записи)</string>
  <string name="summary_ime_preference">Выберите способ ввода для экранной клавиатуры</string>
  <string name="summary_initialcommand_preference">Передаются облочке при запуске терминала</string>
  <string name="summary_mouse_tracking_preference">Определяет, будут ли события касания и прокрутки передаваться в терминал как Escape-последовательности</string>
  <string name="summary_orientation_preference">Выбор ориентации экрана</string>
  <string name="summary_shell_preference">Укажите строку обращения к командной оболочке</string>
  <string name="summary_statusbar_preference">Показывать или скрывать строку состояния</string>
  <string name="summary_termtype_preference">Выбор типа терминала для использования в оболочке</string>
  <string name="summary_utf8_by_default_preference">Применить режим UTF-8 по умолчанию</string>
  <string name="summary_verify_path_preference">Удалять недоступные каталоги из PATH</string>
  <string name="text_preferences">Текст</string>
  <string name="title_actionbar_preference">Панель действий</string>
  <string name="title_allow_prepend_path_preference">Разрешить перезапись PATH</string>
  <string name="title_backaction_preference">Поведение кнопки «Назад»</string>
  <string name="title_close_window_on_process_exit_preference">Закрытие окна при выходе</string>
  <string name="title_color_preference">Цветовая схема</string>
  <string name="title_controlkey_preference">Клавиша Control</string>
  <string name="title_cursorblink_preference">Мигание курсора</string>
  <string name="title_cursorstyle_preference">Вид курсора</string>
  <string name="title_do_path_extensions_preference">Включить расширения PATH</string>
  <string name="title_fnkey_preference">Клавиша Fn</string>
  <string name="title_fontsize_preference">Размер шрифта</string>
  <string name="title_home_path_preference">Домашняя папка</string>
  <string name="title_ime_preference">Способ ввода</string>
  <string name="title_initialcommand_preference">Команды запуска</string>
  <string name="title_mouse_tracking_preference">Передавать события мыши</string>
  <string name="title_orientation_preference">Поворот экрана</string>
  <string name="title_shell_preference">Обработчик команд</string>
  <string name="title_statusbar_preference">Строка состояния</string>
  <string name="title_termtype_preference">Тип терминала</string>
  <string name="title_use_keyboard_shortcuts">Использовать сочетания клавиш</string>
  <string name="title_utf8_by_default_preference">По умолчанию UTF-8</string>
  <string name="title_verify_path_preference">Проверять пути в PATH</string>
  <string name="toggle_soft_keyboard">Экранная клавиатура</string>
  <string name="use_keyboard_shortcuts_summary_off">Сочетания клавиш отключены</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: переключение окон, Ctrl-Shift-N: новое окно, Ctrl-Shift-V: вставить</string>
  <string name="window_list">Окна</string>
  <string name="window_title">Окно %1$d</string>
</resources>

```

`term/src/main/res/values-sk/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
  <string-array name="entries_statusbar_preference">
    <item>Zobraziť stavový riadok</item>
    <item>Skryť stavový riadok</item>
  </string-array>

  <string-array name="entries_actionbar_preference">
      <item>Vždy zobraziť panel akcií</item>
      <item>Skryť panel akcií (pre zobrazenie sa dotknite vrchu obrazovky alebo tlačidla Ponuka)</item>
  </string-array>

  <string-array name="entries_cursorblink_preference">
    <item>Neblikajúci kurzor</item>
    <item>Blikajúci kurzor</item>
  </string-array>
  
  <string-array name="entries_orientation_preference">
        <item>Automatická</item>
        <item>Na šírku</item>
        <item>Na výšku</item>
  </string-array>

  <string-array name="entries_cursorstyle_preference">
    <item>Obdĺžnikový</item>
    <item>Podčiarknutý</item>
    <item>Zvislá čiara</item>
  </string-array>

  <string-array name="entries_fontsize_preference">
    <item>4 x 8 pixelov</item>
    <item>6 bodov</item>
    <item>7 bodov</item>
    <item>8 bodov</item>
    <item>9 bodov</item>
    <item>10 bodov</item>
    <item>12 bodov</item>
    <item>14 bodov</item>
    <item>16 bodov</item>
    <item>20 bodov</item>
    <item>24 bodov</item>
    <item>28 bodov</item>
    <item>32 bodov</item>
    <item>36 bodov</item>
    <item>42 bodov</item>
    <item>48 bodov</item>
    <item>64 bodov</item>
    <item>72 bodov</item>
    <item>96 bodov</item>
    <item>144 bodov</item>
    <item>288 bodov</item>
  </string-array>

  <string-array name="entries_color_preference">
    <item>Čierny text na bbielom</item>
    <item>Biely text na čiernom</item>
    <item>Biely text na modrom</item>
    <item>Zelený text na čiernom</item>
    <item>Jantárový text na čiernom</item>
    <item>Červený text na čiernom</item>
    <item>Holo modrý text na čiernom</item>
    <item>Solarizovaná svetlá</item>
    <item>Solarizovaná tmavá</item>
    <item>Linuxová konzola</item>
  </string-array>

  <string-array name="entries_backaction_preference">
      <item>Zavrieť všetky okná terminálu</item>
      <item>Zavrieť iba aktuálne okno terminálu</item>
      <item>Zavrieť aktivitu, ponechať reláciu bežiacou</item>
      <item>Odoslať ESC do terminálu</item>
      <item>Odoslať TAB do terminálu</item>
  </string-array>

  <string-array name="entries_controlkey_preference">
    <item>Gulička</item>
    <item>Kláves \@</item>
    <item>Kláves Ľavý Alt</item>
    <item>Kláves Pravý Alt</item>
    <item>Kláves Hlasitosť+</item>
    <item>Kláves Hlasitosť-</item>
    <item>Kláves Fotoaparát</item>
    <item>Žiadny</item>
  </string-array>

  <string-array name="entries_fnkey_preference">
    <item>Gulička</item>
    <item>Kláves \@</item>
    <item>Kláves Ľavý Alt</item>
    <item>Kláves Pravý Alt</item>
    <item>Kláves Hlasitosť+</item>
    <item>Kláves Hlasitosť-</item>
    <item>Kláves Fotoaparát</item>
    <item>Žiadny</item>
  </string-array>

  <string-array name="entries_ime_preference">
    <item>Po znakoch</item>
    <item>Po slovách</item>
  </string-array>

  <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
  <string-array name="control_keys_short_names">
    <item>Gulička</item>
    <item>\@</item>
    <item>Ľavý Alt</item>
    <item>Pravý Alt</item>
    <item>Hlasitosť+</item>
    <item>Hlasitosť-</item>
    <item>Fotoaparát</item>
    <item>Žiadny</item>
  </string-array>

  <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
  <string-array name="fn_keys_short_names">
    <item>Gulička</item>
    <item>\@</item>
    <item>Ľavý Alt</item>
    <item>Pravý Alt</item>
    <item>Hlasitosť+</item>
    <item>Hlasitosť-</item>
    <item>Fotoaparát</item>
    <item>Žiadny</item>
  </string-array>
</resources>

```

`term/src/main/res/values-sk/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
  <string name="application_terminal">Emulátor terminálu</string>
  <string name="preferences">Nastavenia</string>
  <string name="new_window">Nové okno</string>
  <string name="close_window">Zavrieť okno</string>
  <string name="window_list">Okná</string>
  <string name="prev_window">Dalšie okno</string>
  <string name="next_window">Predchádzajúce okno</string>
  <string name="reset">Obnoviť terminál</string>
  <string name="send_email">Poslať e-mailom</string>
  <string name="special_keys">Špeciálne klávesy</string>
  <string name="toggle_soft_keyboard">Prepnúť softvérovú klávesnicu</string>
  
  <string name="reset_toast_notification">Stav terminálu pre toto okno bol obnovený.</string>

  <string name="enable_wakelock">Zabrániť uspaniu</string>
  <string name="disable_wakelock">Povoliť uspanie</string>
  <string name="enable_wifilock">Zabrániť odpojeniu Wi-Fi</string>
  <string name="disable_wifilock">Povoliť odpojenie Wi-Fi</string>

  <string name="edit_text">Upraviť text</string>
  <string name="select_text">Vybrať text</string>
  <string name="copy_all">Kopírovať všetko</string>
  <string name="paste">Prilepiť</string>
  <string name="send_control_key">Poslať ovládací kláves</string>
  <string name="send_fn_key">Poslať funkčný kláves</string>

  <string name="window_title">Okno %1$d</string>

  <string name="service_notify_text">Terminálová relácia je spustená</string>
  
  <string name="process_exit_message">Terminálová relácia bola ukončená</string>

  <!-- Preference dialog -->
  <string name="screen_preferences">Obrazovka</string>

  <string name="title_statusbar_preference">Stavový riadok</string>
  <string name="summary_statusbar_preference">Zobraziť/skryť stavový riadok.</string>
  <string name="dialog_title_statusbar_preference">Stavový riadok</string>
  
  <string name="title_actionbar_preference">Panel akcií</string>
  <string name="summary_actionbar_preference">Vybrať správanie panela akcií (Android 3.0 a vyšší).</string>
  <string name="dialog_title_actionbar_preference">Správanie panela akcií</string>

  <string name="title_orientation_preference">Orientácia obrazovky</string>
  <string name="summary_orientation_preference">Vybrať správanie orientácie obrazovky.</string>
  <string name="dialog_title_orientation_preference">Správanie orientácie obrazovky</string>

  <string name="title_cursorstyle_preference">Štýl kurzoru</string>
  <string name="summary_cursorstyle_preference">Vybrať štýl kurzoru.</string>
  <string name="dialog_title_cursorstyle_preference">Štýl kurzoru</string>
  
  <string name="title_cursorblink_preference">Blikanie kurzoru</string>
  <string name="summary_cursorblink_preference">Vybrať blikanie kurzoru.</string>
  <string name="dialog_title_cursorblink_preference">Blikanie kurzoru</string>

  <string name="text_preferences">Text</string>
  
  <string name="title_utf8_by_default_preference">Predvolene do UTF-8</string>
  <string name="summary_utf8_by_default_preference">Režim UTF-8 je predvolene povolený.</string>

  <string name="title_fontsize_preference">Veľkosť písma</string>
  <string name="summary_fontsize_preference">Vybrať výšku znaku v bodoch.</string>
  <string name="dialog_title_fontsize_preference">Veľkosť fontu</string>

  <string name="title_color_preference">Farby</string>
  <string name="summary_color_preference">Vybrať farbu textu.</string>
  <string name="dialog_title_color_preference">Farba textu</string>

  <string name="keyboard_preferences">Klávesnica</string>
  
  <string name="title_backaction_preference">Správanie tlačidla Späť</string>
  <string name="summary_backaction_preference">Vybrať správanie tlačidla Späť.</string>
  <string name="dialog_title_backaction_preference">Správanie tlačidla Späť</string>

  <string name="title_controlkey_preference">Ovládací kláves</string>
  <string name="summary_controlkey_preference">Vybrať ovládací kláves.</string>
  <string name="dialog_title_controlkey_preference">Ovládací kláves</string>

  <string name="title_fnkey_preference">Funkčný kláves</string>
  <string name="summary_fnkey_preference">Vybrať funkčný kláves.</string>
  <string name="dialog_title_fnkey_preference">Funkčný kláves</string>

  <string name="title_ime_preference">Metóda vstupu</string>
  <string name="summary_ime_preference">Vybrať metódu zadávania pre softvérovú klávesnicu.</string>
  <string name="dialog_title_ime_preference">Metóda vstupu</string>

  <string name="shell_preferences">Konzola</string>
  <string name="title_shell_preference">Príkazový riadok</string>
  <string name="summary_shell_preference">Vybrať príkaz pre konzolu.</string>
  <string name="dialog_title_shell_preference">Konzola</string>

  <string name="title_initialcommand_preference">Počiatočný príkaz</string>
  <string name="summary_initialcommand_preference">Poslať do konzoly po spustení.</string>
  <string name="dialog_title_initialcommand_preference">Počiatočný príkaz</string>
  
  <string name="title_termtype_preference">Typ terminálu</string>
  <string name="summary_termtype_preference">Typ terminálu pre nahlásenie do konzoly.</string>
  <string name="dialog_title_termtype_preference">Typ terminálu</string>
   
  <string name="title_close_window_on_process_exit_preference">Zavrieť okno po ukončení</string>
  <string name="summary_close_window_on_process_exit_preference">Po ukončení konzoly zavrieť okno.</string>
  
  <string name="title_verify_path_preference">Overiť položky v PATH</string>
  <string name="summary_verify_path_preference">Odstrániť neprístupné priečinky z PATH.</string>

  <string name="title_do_path_extensions_preference">Povoliť rozšírenia PATH</string>
  <string name="summary_do_path_extensions_preference">Umožniť ostatným aplikáciám poskytnúť ďalšie príkazy (pridať do PATH).</string>

  <string name="title_allow_prepend_path_preference">Povoliť podradenie PATH</string>
  <string name="summary_allow_prepend_path_preference">Umožniť ostatným aplikáciám prepísať existujúce príkazy (pridať na začiatok PATH).</string>

  <string name="title_home_path_preference">Domovský priečinok</string>
  <string name="summary_home_path_preference">Umiestnenie zapisovateľného priečinka, ktorý bude použitý ako domovský.</string>
  
  <string name="control_key_dialog_title">Ovládacie a funkčné klávesy</string>
  <string name="control_key_dialog_control_text">CTRLKEY medzera : Ctrl-@ (NUL)\nCTRLKEY A..Z : Ctrl-A..Z\nCTRLKEY 5 : Ctrl-]\nCTRLKEY 6 : Ctrl-^\nCTRLKEY 7 : Ctrl-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Ovládacie klávesy nie sú nastavené.</string>
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : hore\nFNKEY A : vľavo\nFNKEY S : dole\nFNKEY D : vpravo\nFNKEY P : stránka hore\nFNKEY N : stránka dole\nFNKEY T : tabulátor\nFNKEY L : | (zvislá čiara)\nFNKEY U : _ (podčiarkovník)\nFNKEY E : Ctrl-[ (ESC)\nFNKEY X : vymazať\nFNKEY I : vložiť\nFNKEY H : domov\nFNKEY F : koniec\nFNKEY . : Ctrl-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Funkčné klávesy nie sú nastavené.</string>
  
  <string name="confirm_window_close_message">Zavrieť toto okno?</string>
 
  <string name="perm_run_script">Spustiť ľubovoľné príkazy</string>
  <string name="permdesc_run_script">Umožniť aplikáciám otvoriť nové okno v Emulátori terminálu pre Android a spustiť príkazy v tomto okne so všetkými povoleniami terminálu a to vrátane prístupu na Internet a ku karte SD.</string>
  <string name="perm_append_to_path">Pridať príkazy do Emulátora terminálu Android</string>
  <string name="permdesc_append_to_path">Umožňuje aplikáciám poskytnúť ďalšie príkazy (pridať priečinky do PATH) v Emulátori terminálu pre Android.</string>
  <string name="perm_prepend_to_path">Prepísať príkazy v Emulátori terminálu Android</string>
  <string name="permdesc_prepend_to_path">Umožňuje aplikáciám prepísať existujúce príkazy so svojimi vlastnými verziami (podradiť priečinky v PATH) v Emulátori terminálu pre Android.</string>
  
  <string name="email_transcript_subject">Prepis z Emulátora terminálu pre Android</string>
  <string name="email_transcript_chooser_title">Poslať prepis prostredníctvom</string>
  <string name="email_transcript_no_email_activity_found">Nie je možné vybrať e-mailovú aktivitu na poslanie prepisu.</string>

  <string name="alt_sends_esc">Posielať ESC pomocou klávesu Alt</string>
  <string name="alt_sends_esc_summary_on">Kláves Alt posiela ESC.</string>
  <string name="alt_sends_esc_summary_off">Kláves Alt neposiela ESC.</string>

  <string name="title_mouse_tracking_preference">Posielať udalosti myši</string>
  <string name="summary_mouse_tracking_preference">Posielať udalosti kliknutia a posunu ako sekvencie ESCAPE do terminálu.</string>

  <string name="title_use_keyboard_shortcuts">Používať klávesové skratky</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: prepnúť okno, Ctrl-Shift-N: nové okno, Ctrl-Shift-V: prilepiť.</string>
  <string name="use_keyboard_shortcuts_summary_off">Klávesové skratky sú zakázané.</string>
  
  <string name="help">Pomocník</string>
    <string name="activity_term_here_title">Otvoriť terminál</string>
  
  <string name="activity_shortcut_create">Skratka terminálu</string>
  <string name="fsnavigator_title">VYBERTE SÚBOR</string>
  <string name="fsnavigator_no_external_storage">Nedostupný externý ukladací priestor</string>
  <string name="fsnavigator_optional_enter_path">Alebo zadajte umiestnenie sem.</string>
  <string name="fsnavigator_change_theme">Zmeniť tému</string>
  
  <string name="addshortcut_command_hint">príkaz</string>
  <string name="addshortcut_example_hint">--príklad=\""a\"</string>
  <string name="addshortcut_button_find_command">Nájsť príkaz</string>
  <string name="addshortcut_navigator_title">VYBERTE CIEĽ SKRATKY</string>
  <string name="addshortcut_command_window_instructions">Príkazové okno vyžaduje celé umiestnenie, žiadne argumenty. Pre ostatné príkazy použite okno pre argumenty (napríklad: cd /sdcard).</string>
  <string name="addshortcut_arguments_label">Argumenty\:</string>
  <string name="addshortcut_shortcut_label">Názov skratky\:</string>
  <string name="addshortcut_button_text_icon">Text ikony</string>
  <string name="addshortcut_make_text_icon">Vytvoriť text ikony</string>
  <string name="addshortcut_title">Skratka terminálu</string>
  
  <string name="colorvalue_letter_alpha">α</string>
  <string name="colorvalue_letter_red">Č</string>
  <string name="colorvalue_letter_green">Z</string>
  <string name="colorvalue_letter_blue">M</string>
  <string name="colorvalue_label_lock_button_column">Zamknúť</string>
  <string name="colorvalue_icon_text_entry_hint">Zadajte text ikony</string>
</resources>

```

`term/src/main/res/values-sr/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Прикажи траку стања</item>
        <item>Сакриј траку стања</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Трака радњи онемогућена</item> -->
        <item>Увек прикажи траку радњи</item>
        <item>Сакриј траку радњи (за приказ додирните врх екрана или Мени тастер)</item>
    </string-array>

    <string-array name="entries_orientation_preference">
        <item>Аутоматски</item>
        <item>Пејзаж</item>
        <item>Портрет</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Статични курсор</item>
        <item>Трепћући курсор</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Правоугаоник</item>
        <item>Подвлака</item>
        <item>Вертикална трака</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 px</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Црни текст на белом</item>
        <item>Бели текст на црном</item>
        <item>Бели текст на плавом</item>
        <item>Зелени текст на црном</item>
        <item>Јантарни текст на црном</item>
        <item>Црвени текст на црном</item>
        <item>Холо плави текст на црном</item>
        <item>Светла соларизована</item>
        <item>Тамна соларизована</item>
        <item>Линукс конзола</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Затвара све прозоре терминала</item>
        <item>Затвара само овај прозор терминала</item>
        <item>Затвара активност, оставља сесије покренуте</item>
        <item>Шаље ESC терминалу</item>
        <item>Шаље TAB терминалу</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Џог куглица</item>
        <item>\@ тастер</item>
        <item>Леви Алт тастер</item>
        <item>Десни Алт тастер</item>
        <item>Звук Горе тастер</item>
        <item>Звук Доле тастер</item>
        <item>Камера тастер</item>
        <item>Ниједан</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Џог куглица</item>
        <item>\@ тастер</item>
        <item>Леви Алт тастер</item>
        <item>Десни Алт тастер</item>
        <item>Звук Горе тастер</item>
        <item>Звук Доле тастер</item>
        <item>Камера тастер</item>
        <item>Ниједан</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Заснована на знаковима</item>
        <item>Заснована на речима</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Куглица</item>
        <item>\@</item>
        <item>Леви-Алт</item>
        <item>Десни-Алт</item>
        <item>Звук-Горе</item>
        <item>Звук-Доле</item>
        <item>Камера</item>
        <item>Ниједан</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Куглица</item>
        <item>\@</item>
        <item>Леви-Алт</item>
        <item>Десни-Алт</item>
        <item>Звук-Горе</item>
        <item>Звук-Доле</item>
        <item>Камера</item>
        <item>Ниједан</item>
    </string-array>
</resources>

```

`term/src/main/res/values-sr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Емулатор терминала</string>
   <string name="preferences">Поставке</string>
   <string name="new_window">Нови прозор</string>
   <string name="close_window">Затвори прозор</string>
   <string name="window_list">Прозори</string>
   <string name="prev_window">Прет. прозор</string>
   <string name="next_window">След. прозор</string>
   <string name="reset">Поново постави терм</string>
   <string name="send_email">Пошаљи е-поштом</string>
   <string name="special_keys">Посебни тастери</string>
   <string name="toggle_soft_keyboard">Пребаци софтверску тастатуру</string>

   <string name="reset_toast_notification">Стање терминала овог прозора је поново постављено.</string>

   <string name="enable_wakelock">Узми блокаду буђења</string>
   <string name="disable_wakelock">Отпусти блокаду буђења</string>
   <string name="enable_wifilock">Узми блокаду бежичног</string>
   <string name="disable_wifilock">Отпусти блокаду бежичног</string>

   <string name="edit_text">Уреди текст</string>
   <string name="select_text">Изабери текст</string>
   <string name="copy_all">Копирај све</string>
   <string name="paste">Налепи</string>
   <string name="send_control_key">Пошаљи Цтрл унос</string>
   <string name="send_fn_key">Пошаљи Фн унос</string>

   <string name="window_title">Прозор %1$d</string>

   <string name="service_notify_text">Сесија терминала је у току</string>

   <string name="process_exit_message">Сесија терминала је завршена</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Екран</string>

   <string name="title_statusbar_preference">Трака стања</string>
   <string name="summary_statusbar_preference">Прикажи/сакриј траку стања.</string>
   <string name="dialog_title_statusbar_preference">Трака стања</string>

   <string name="title_actionbar_preference">Трака радњи</string>
   <string name="summary_actionbar_preference">Одредите понашање траке радњи (Андроид 3.0 и новији).</string>
   <string name="dialog_title_actionbar_preference">Понашање траке радњи</string>

   <string name="title_orientation_preference">Оријентација екрана</string>
   <string name="summary_orientation_preference">Одредите понашање оријентације екрана.</string>
   <string name="dialog_title_orientation_preference">Оријентација екрана</string>

   <string name="title_cursorstyle_preference">Стил курсора</string>
   <string name="summary_cursorstyle_preference">Изаберите стил курсора.</string>
   <string name="dialog_title_cursorstyle_preference">Стил курсора</string>

   <string name="title_cursorblink_preference">Трептање курсора</string>
   <string name="summary_cursorblink_preference">Одредите трептање курсора.</string>
   <string name="dialog_title_cursorblink_preference">Трептање курсора</string>

   <string name="text_preferences">Текст</string>

   <string name="title_utf8_by_default_preference">Подразумевај УТФ-8</string>
   <string name="summary_utf8_by_default_preference">Да ли је УТФ-8 режим подразумевано омогућен.</string>

   <string name="title_fontsize_preference">Величина фонта</string>
   <string name="summary_fontsize_preference">Одредите величину фонта у тачкама.</string>
   <string name="dialog_title_fontsize_preference">Величина фонта</string>

   <string name="title_color_preference">Боје</string>
   <string name="summary_color_preference">Изаберите боју текста.</string>
   <string name="dialog_title_color_preference">Боја текста</string>

   <string name="keyboard_preferences">Тастатура</string>

   <string name="title_backaction_preference">Понашање дугмета за назад</string>
   <string name="summary_backaction_preference">Шта ће да деси притиском на дугме за назад.</string>
   <string name="dialog_title_backaction_preference">Понашање дугмета за назад</string>

   <string name="title_controlkey_preference">Контрол тастер</string>
   <string name="summary_controlkey_preference">Изаберите контрол (Цтрл) тастер.</string>
   <string name="dialog_title_controlkey_preference">Контрол тастер</string>

   <string name="title_fnkey_preference">Фн тастер</string>
   <string name="summary_fnkey_preference">Изаберите функцијски (Фн) тастер.</string>
   <string name="dialog_title_fnkey_preference">Фн тастер</string>

   <string name="title_ime_preference">Метода уноса</string>
   <string name="summary_ime_preference">Изаберите методу уноса за софтверску тастатуру.</string>
   <string name="dialog_title_ime_preference">Метода уноса</string>

   <string name="shell_preferences">Шкољка</string>
   <string name="title_shell_preference">Командна линија</string>
   <string name="summary_shell_preference">Одредите командну линију шкољке.</string>
   <string name="dialog_title_shell_preference">Шкољка</string>

   <string name="title_initialcommand_preference">Почетна наредба</string>
   <string name="summary_initialcommand_preference">Наредба послата шкољки по покретању.</string>
   <string name="dialog_title_initialcommand_preference">Почетна наредба</string>

   <string name="title_termtype_preference">Тип терминала</string>
   <string name="summary_termtype_preference">Који тип терминала да буде пријављен шкољки.</string>
   <string name="dialog_title_termtype_preference">Тип терминала</string>

   <string name="title_close_window_on_process_exit_preference">Затвори прозор по излазу</string>
   <string name="summary_close_window_on_process_exit_preference">Да ли да прозор буде затворен по излазу из његове шкољке.</string>

   <string name="title_verify_path_preference">Овери PATH уносе</string>
   <string name="summary_verify_path_preference">Да ли да недоступни директоријуми буду уклољени из PATH.</string>

   <string name="title_do_path_extensions_preference">Дозволи PATH проширења</string>
   <string name="summary_do_path_extensions_preference">Да ли осталим апликацијама дозволити додавање додатне наредбе (да додају у PATH).</string>

   <string name="title_allow_prepend_path_preference">Дозволи PATH префиксе</string>
   <string name="summary_allow_prepend_path_preference">Да ли осталим апликацијама дозволити премошћавање постојеће наредбе (да додају на почетку PATH).</string>

   <string name="title_home_path_preference">Домаћа фасцикла</string>
   <string name="summary_home_path_preference">Путања до уписиве фасцикле која ће бити коришћена као HOME.</string>

   <string name="control_key_dialog_title">Контролни и функцијски тастери</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Размак : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">Контролни тастер није постављен.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Горе\nFNKEY A : Лево\nFNKEY S : Доле\nFNKEY D : Десно\nFNKEY P : СтрГоре\nFNKEY N : СтрДоле\nFNKEY T : Таб\nFNKEY L : | (цев)\nFNKEY U : _ (подвлака)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Обриши\nFNKEY I : Уметни\nFNKEY H : Почетак\nFNKEY F : Крај\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">Функцијски тастер није постављен.</string>

  <string name="confirm_window_close_message">Затворити овај прозор?</string>

  <string name="perm_run_script">Покретање произвољних наредби у Емулатору Терминала</string>
  <string name="permdesc_run_script">Омогућава апликацији да отвара нове прозоре у Емулатору Терминала за Андроид и покреће наредбе у тим прозорима са свим дозволама Емулатора Терминала, укључујући приступ интернету и вашој СД картици.</string>
  <string name="perm_append_to_path">Додавање наредби у Емулатор Терминала</string>
  <string name="permdesc_append_to_path">Дозвољава апликацији да пружи додатне наредбе (додавање директоријума у PATH) за Емулатор Терминала за Андроид.</string>
  <string name="perm_prepend_to_path">Премошћавање наредби у Емулатору Терминала</string>
  <string name="permdesc_prepend_to_path">Дозвољава апликацији да премости постојеће наредбе својим (префиксује директоријуме у PATH) у Емулатору Терминала за Андроид.</string>

  <string name="email_transcript_subject">Препис са Емулатора Терминала за Андроид</string>
  <string name="email_transcript_chooser_title">Пошаљи препис користећи:</string>
  <string name="email_transcript_no_email_activity_found">Не могу да изаберем активност е-поште за слање преписа.</string>

  <string name="alt_sends_esc">Алт тастер шаље ESC</string>
  <string name="alt_sends_esc_summary_on">Алт тастер шаље ESC.</string>
  <string name="alt_sends_esc_summary_off">Алт тастер не шаље ESC.</string>

  <string name="title_mouse_tracking_preference">Шаљи догађаје миша</string>
  <string name="summary_mouse_tracking_preference">Слање додира и клизања терминалу као секвенце излаза.</string>

  <string name="title_use_keyboard_shortcuts">Користи пречице тастатуре</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: пребаци прозор, Ctrl-Shift-N: нови прозор, Ctrl-Shift-V: налепи.</string>
  <string name="use_keyboard_shortcuts_summary_off">Пречице тастатуре су онемогућене.</string>

  <string name="help">Помоћ</string>
    <string name="activity_term_here_title">Терминал овде</string>
  <!-- BEGIN SHORTCUT RELATED STRINGS -->
  <!-- AndroidManifest.xml -->
  <string name="activity_shortcut_create">"Терминалска пречица"</string>
  <!-- FSNavigator.java -->
  <string name="fsnavigator_title">ИЗБОР ФАЈЛА</string>
  <string name="fsnavigator_no_external_storage">Спољашње складиште није доступно</string>
  <string name="fsnavigator_optional_enter_path">Или унесите путању овде.</string>
  <string name="fsnavigator_change_theme">Промени тему</string>
  <!-- AddShortcut.java -->
  <string name="addshortcut_command_hint">наредба</string>
  <string name="addshortcut_example_hint">--пример=\""a\"</string>
  <string name="addshortcut_button_find_command">Нађи наредбу</string>
  <string name="addshortcut_navigator_title">ИЗБОР МЕТЕ ПРЕЧИЦЕ</string>
  <string name="addshortcut_command_window_instructions">Окно наредбе захтева пуну путању, без аргумената. За остале наредбе користите окно аргумената (нпр: cd /sdcard).</string>
  <string name="addshortcut_arguments_label">Аргументи\:</string>
  <string name="addshortcut_shortcut_label">Етикета пречице\:</string>
  <string name="addshortcut_button_text_icon">Текстуална икона</string>
  <string name="addshortcut_make_text_icon">ТЕКСТУАЛНА ИКОНА</string>
  <string name="addshortcut_title">Пречица терминала</string>
  <!-- ColorValue.java -->
  <string name="colorvalue_letter_alpha">α</string>
  <string name="colorvalue_letter_red">Р</string>
  <string name="colorvalue_letter_green">Г</string>
  <string name="colorvalue_letter_blue">Б</string>
  <string name="colorvalue_label_lock_button_column">ЗАКЉУЧАЈ</string>
  <string name="colorvalue_icon_text_entry_hint">Унесите текст иконе</string>
  <!-- END SHORTCUT RELATED STRINGS -->
</resources>

```

`term/src/main/res/values-sv/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Visa statusfältet</item>
        <item>Dölj statusfältet</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>Always show action bar</item>
        <item>Hide action bar (touch top of screen or Menu key to show)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Icke-blinkande markör</item>
        <item>Blinkande markör</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Rektangel</item>
        <item>Understruken</item>
        <item>Vertikalt streck</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4x8 Pixlar</item>
        <item>6 Punkter</item>
        <item>7 Punkter</item>
        <item>8 Punkter</item>
        <item>9 Punkter</item>
        <item>10 Punkter</item>
        <item>12 Punkter</item>
        <item>14 Punkter</item>
        <item>16 Punkter</item>
        <item>20 Punkter</item>
        <item>24 Punkter</item>
        <item>28 Punkter</item>
        <item>32 Punkter</item>
        <item>36 Punkter</item>
        <item>42 Punkter</item>
        <item>48 Punkter</item>
        <item>64 Punkter</item>
        <item>72 Punkter</item>
        <item>96 Punkter</item>
        <item>144 Punkter</item>
        <item>288 Punkter</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Svart text på vit</item>
        <item>Vit text på svart</item>
        <item>Vit text på blå</item>
        <item>Grön text på svart</item>
        <item>Orange text på svart</item>
        <item>Röd text på svart</item>
        <item>Blå text på svart</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Closes all terminal windows</item>
        <item>Closes this terminal window only</item>
        <item>Closes activity, leaving sessions running</item>
        <item>Sends ESC to terminal</item>
        <item>Sends TAB to terminal</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Trackball</item>
        <item>\@-tangent</item>
        <item>Vänster Alt-tangent</item>
        <item>Höger Alt-tangent</item>
        <item>Volym upp</item>
        <item>Volym ner</item>
        <item>Kamera-tangent</item>
        <item>None</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Trackball</item>
        <item>\@-tangent</item>
        <item>Vänster Alt-tangent</item>
        <item>Höger Alt-tangent</item>
        <item>Volym upp</item>
        <item>Volym ner</item>
        <item>Kamera-tangent</item>
        <item>None</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Teckenbaserade</item>
        <item>Ordbaserade</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>
</resources>

```

`term/src/main/res/values-sv/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="application_terminal">Terminalemulator</string>
    <string name="preferences">Inställningar</string>
    <string name="reset">Återställ terminal</string>
    <string name="send_email">E-posta till</string>
    <string name="special_keys">Special tangenter</string>
    <string name="toggle_soft_keyboard">Växla till virtuellt tangentbord</string>
    <string name="enable_wakelock">Aktivera VäckningsLås</string>
    <string name="disable_wakelock">Inaktivera VäckningsLås</string>
    <string name="enable_wifilock">Aktivera WifiLås</string>
    <string name="disable_wifilock">Inaktivera WifiLås</string>
    <string name="edit_text">Redigera text</string>
    <string name="select_text">Markera text</string>
    <string name="copy_all">Kopiera allt</string>
    <string name="paste">Klistra in</string>
    <string name="service_notify_text">Terminalsessionen är igång</string>
    <string name="screen_preferences">Skärm</string>
    <string name="title_statusbar_preference">Statusfält</string>
    <string name="summary_statusbar_preference">Visa/Dölj statusfält</string>
    <string name="dialog_title_statusbar_preference">Statusfält</string>
    <string name="title_cursorstyle_preference">Markörstil</string>
    <string name="summary_cursorstyle_preference">Välj markörstil.</string>
    <string name="dialog_title_cursorstyle_preference">Markörstil</string>
    <string name="title_cursorblink_preference">Blinkande markör</string>
    <string name="summary_cursorblink_preference">Välj blinkande markör</string>
    <string name="dialog_title_cursorblink_preference">Blinkande markör</string>
    <string name="text_preferences">Text</string>
    <string name="title_fontsize_preference">Teckenstorlek</string>
    <string name="summary_fontsize_preference">Välj teckenhöjd i punkter.</string>
    <string name="dialog_title_fontsize_preference">Teckenstorlek</string>
    <string name="title_color_preference">Färger</string>
    <string name="summary_color_preference">Välj textfärg.</string>
    <string name="dialog_title_color_preference">Textfärg</string>
    <string name="keyboard_preferences">Tangentbord</string>
    <string name="title_controlkey_preference">Ctrl-tangent</string>
    <string name="summary_controlkey_preference">Välj Ctrl-tangent</string>
    <string name="dialog_title_controlkey_preference">Ctrl-tangent</string>
    <string name="title_fnkey_preference">Fn-tangent</string>
    <string name="summary_fnkey_preference">Välj Fn-tangent.</string>
    <string name="dialog_title_fnkey_preference">Fn-tangent</string>
    <string name="title_ime_preference">Inmatningsmetod</string>
    <string name="summary_ime_preference">Välj inmatningsmetod för virtuellt tangentbord.</string>
    <string name="dialog_title_ime_preference">Inmatningsmetod</string>
    <string name="shell_preferences">Skal</string>
    <string name="title_shell_preference">Kommandorad</string>
    <string name="summary_shell_preference">Ange skalkommandorad.</string>
    <string name="dialog_title_shell_preference">Skal</string>
    <string name="title_initialcommand_preference">Inledande kommando</string>
    <string name="summary_initialcommand_preference">Skickas till skalet när det börjar.</string>
    <string name="dialog_title_initialcommand_preference">Inledande kommando</string>
</resources>

```

`term/src/main/res/values-tr/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Uyarı çubuğunu göster</item>
        <item>Uyarı çubuğunu sakla</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Non-blinking cursor</item>
        <item>Blinking cursor</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Rectangle</item>
        <item>Underline</item>
        <item>Vertical bar</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 piksel</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Beyaz arkaplan üzerinde siyah metin</item>
        <item>Siyah arkaplan üzerinde beyaz metin</item>
        <item>Mavi arkaplan üzerinde beyaz metin</item>
        <item>Siyah arkaplan üzerinde yeşil metin</item>
        <item>Siyah arkaplan üzerinde turuncu metin</item>
        <item>Siyah arkaplan üzerinde kırmızı metin</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Jog ball</item>
        <item>\@ Tuşu</item>
        <item>Sol Alt Tuşu</item>
        <item>Sağ Alt Tuşu</item>
        <item>Ses Arttırma Tuşu</item>
        <item>Ses Kısma Tuşu</item>
        <item>Kamera Tuşu</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Harf tabanlı</item>
        <item>Kelime tabanlı</item>
    </string-array>

</resources>

```

`term/src/main/res/values-tr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal Emülatörü</string>
   <string name="preferences">Tercihler</string>
   <string name="reset">Terminali yeniden başlat</string>
   <string name="send_email">Email olarak yolla</string>
   <string name="special_keys">Özel tuşlar</string>
   <string name="toggle_soft_keyboard">Ekran klavyesine geç</string>

   <string name="edit_text">Metni düzenle</string>
   <string name="select_text">Metni seç</string>
   <string name="copy_all">Hepsini kopyala</string>
   <string name="paste">Yapıştır</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Ekran</string>

   <string name="title_statusbar_preference">Uyarı çubuğu</string>
   <string name="summary_statusbar_preference">Uyarı çubuğunu göster/gizle.</string>
   <string name="dialog_title_statusbar_preference">Uyarı çubuğu</string>

   <string name="title_cursorstyle_preference">İmleç stili</string>
   <string name="summary_cursorstyle_preference">İmleç stili seçin.</string>
   <string name="dialog_title_cursorstyle_preference">İmleç stili</string>

   <string name="title_cursorblink_preference">Cursor blink</string>
   <string name="summary_cursorblink_preference">Choose cursor blink.</string>
   <string name="dialog_title_cursorblink_preference">Cursor blink</string>

   <string name="text_preferences">Metin</string>

   <string name="title_fontsize_preference">Karakter boyutu</string>
   <string name="summary_fontsize_preference">Karakter büyüklüğü seçin.</string>
   <string name="dialog_title_fontsize_preference">Karakter boyutu</string>

   <string name="title_color_preference">Renkler</string>
   <string name="summary_color_preference">Metin rengini seçin.</string>
   <string name="dialog_title_color_preference">Metin rengi</string>

   <string name="keyboard_preferences">Klavye</string>

   <string name="title_controlkey_preference">Kontrol tuşu</string>
   <string name="summary_controlkey_preference">Kontrol tuşunu seçin.</string>
   <string name="dialog_title_controlkey_preference">Kontrol tuşu</string>

   <string name="title_ime_preference">Giriş yöntemi</string>
   <string name="summary_ime_preference">Ekran klavyesi için giriş yöntemi seçin.</string>
   <string name="dialog_title_ime_preference">Giriş yöntemi</string>

   <string name="shell_preferences">Kabuk</string>
   <string name="title_shell_preference">Komut satırı</string>
   <string name="summary_shell_preference">Kabukta kullanılacak komut satırını belirtin.</string>
   <string name="dialog_title_shell_preference">Kabuk</string>

   <string name="title_initialcommand_preference">Başlangıç komutu</string>
   <string name="summary_initialcommand_preference">Başlangıçta kabukta çalıştır.</string>
   <string name="dialog_title_initialcommand_preference">Başlangıç komutu</string>
</resources>

```

`term/src/main/res/values-uk/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="entries_statusbar_preference">
        <item>Показувати</item>
        <item>Приховувати</item>
    </string-array>
    <string-array name="entries_actionbar_preference">
        <item>Завжди показувати бар дії</item>
        <item>Сховати дії бару (торкніться верху екрану або клавіші Меню, щоб показати)</item>
    </string-array>
    <string-array name="entries_cursorblink_preference">
        <item>Не-миготливий курсор</item>
        <item>Миготливий курсор</item>
    </string-array>
    <string-array name="entries_cursorstyle_preference">
        <item>Прямокутник</item>
        <item>Підкреслення</item>
        <item>Вертикальний бар</item>
    </string-array>
    <string-array name="entries_fontsize_preference">
        <item>4 x 8 пікселів</item>
        <item>6 пікселів</item>
        <item>7 пікселів</item>
        <item>8 пікселів</item>
        <item>9 пікселів</item>
        <item>10 пікселів</item>
        <item>12 пікселів</item>
        <item>14 пікселів</item>
        <item>16 пікселів</item>
        <item>20 пікселів</item>
        <item>24 пікселів</item>
        <item>28 пікселів</item>
        <item>32 пікселів</item>
        <item>36 пікселів</item>
        <item>42 пікселів</item>
        <item>48 пікселів</item>
        <item>64 пікселів</item>
        <item>72 пікселів</item>
        <item>96 пікселів</item>
        <item>144 пікселів</item>
        <item>288 пікселів</item>
    </string-array>
    <string-array name="entries_color_preference">
        <item>Чорний на білому</item>
        <item>Білий на чорному</item>
        <item>Білий на синьому</item>
        <item>Зелений на чорному</item>
        <item>Жовтий на чорному</item>
        <item>Червоний на чорному</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>
    <string-array name="entries_backaction_preference">
        <item>Закрити всі вікна терміналу</item>
        <item>Закрити тільки це вікно терміналу</item>
        <item>Активне закриття, решти запущених сеансів</item>
        <item>Послати ESC в термінал</item>
        <item>Послати TAB в термінал</item>
    </string-array>
    <string-array name="entries_controlkey_preference">
        <item>Куля Jog</item>
        <item>Клавіша @</item>
        <item>Лівий Alt</item>
        <item>Правий Alt</item>
        <item>Гучність вверх</item>
        <item>Гучність вниз</item>
        <item>Клавіша камери</item>
        <item>Нема</item>
    </string-array>
    <string-array name="entries_fnkey_preference">
        <item>Куля Jog</item>
        <item>Клавіша @</item>
        <item>Лівий Alt</item>
        <item>Правий Alt</item>
        <item>Гучність вверх</item>
        <item>Гучність вниз</item>
        <item>Клавіша камери</item>
        <item>Нема</item>
    </string-array>
    <string-array name="entries_ime_preference">
        <item>За знаками</item>
        <item>За словами</item>
    </string-array>
    <string-array name="control_keys_short_names">
        <item>Куля Jog</item>
        <item>Клавіша @</item>
        <item>Лівий Alt</item>
        <item>Правий Alt</item>
        <item>Гучність вверх</item>
        <item>Гучність вниз</item>
        <item>Клавіша камери</item>
        <item>Нема</item>
    </string-array>
    <string-array name="fn_keys_short_names">
        <item>Куля Jog</item>
        <item>Клавіша @</item>
        <item>Лівий Alt</item>
        <item>Правий Alt</item>
        <item>Гучність вверх</item>
        <item>Гучність вниз</item>
        <item>Клавіша камери</item>
        <item>Нема</item>
    </string-array>
</resources>

```

`term/src/main/res/values-uk/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="application_terminal">Емулятор Терміналу</string>
    <string name="preferences">Налаштування</string>
    <string name="new_window">Нове вікно</string>
    <string name="close_window">Закрити вікно</string>
    <string name="window_list">Вікна</string>
    <string name="prev_window">Попереднє вікно</string>
    <string name="next_window">Наступне вікно</string>
    <string name="reset">Скинути термінал</string>
    <string name="send_email">Відіслати Email</string>
    <string name="special_keys">Спеціальні клавіші</string>
    <string name="toggle_soft_keyboard">Екранна клавіатура</string>
    <string name="reset_toast_notification">"Термінальний стан цього вікна було скинуто."</string>
    <string name="enable_wakelock">Ввімкнути WakeLock</string>
    <string name="disable_wakelock">Вимкнути WakeLock</string>
    <string name="enable_wifilock">Ввімкнути WifiLock</string>
    <string name="disable_wifilock">Вимкнути WifiLock</string>
    <string name="edit_text">Змінити</string>
    <string name="select_text">Вибрати текст</string>
    <string name="copy_all">Копіювати все</string>
    <string name="paste">Вставити</string>
    <string name="send_control_key">Відіслати кнопкою Control</string>
    <string name="send_fn_key">Відіслати кнопкою Fn</string>
    <string name="window_title">Вікно %1$d</string>
    <string name="service_notify_text">Термінальний сеанс запущений</string>
    <string name="process_exit_message">Термінальний сеанс завершений</string>
    <string name="screen_preferences">Екран</string>
    <string name="title_statusbar_preference">Статус бар</string>
    <string name="summary_statusbar_preference">Показати/Приховати статус бар.</string>
    <string name="dialog_title_statusbar_preference">Статус бар</string>
    <string name="title_actionbar_preference">Бар дії</string>
    <string name="summary_actionbar_preference">Виберіть поведінку бару дії (Android 3.0 і вище).</string>
    <string name="dialog_title_actionbar_preference">Поведінка бару дії</string>
    <string name="text_preferences">Текст</string>
    <string name="title_utf8_by_default_preference">За замовчуванням UTF-8</string>
    <string name="summary_utf8_by_default_preference">Застосувати режим UTF-8 за замовчуванням.</string>
    <string name="title_fontsize_preference">Розмір шрифту</string>
    <string name="summary_fontsize_preference">Виберіть розмір шрифту.</string>
    <string name="dialog_title_fontsize_preference">Розмір шрифту</string>
    <string name="title_color_preference">Кольори</string>
    <string name="summary_color_preference">Виберіть колір тексту.</string>
    <string name="dialog_title_color_preference">Колір тексту</string>
    <string name="keyboard_preferences">Клавіатура</string>
    <string name="title_backaction_preference">Поведінка кнопки Назад</string>
    <string name="summary_backaction_preference">Вибір дії при натисканні кнопки назад.</string>
    <string name="dialog_title_backaction_preference">Поведінка кнопки Назад</string>
    <string name="title_controlkey_preference">Клавіша Control</string>
    <string name="summary_controlkey_preference">Виберіть що буде клавішею Control.</string>
    <string name="dialog_title_controlkey_preference">Клавіша Control</string>
    <string name="title_fnkey_preference">Клавіша Fn</string>
    <string name="summary_fnkey_preference">Виберіть що буде клавішею Fn.</string>
    <string name="dialog_title_fnkey_preference">Клавіша Fn</string>
    <string name="title_ime_preference">Спосіб введення</string>
    <string name="summary_ime_preference">Виберіть спосіб введення для екранної клавіатури.</string>
    <string name="dialog_title_ime_preference">Спосіб введення</string>
    <string name="shell_preferences">Командна оболонка</string>
    <string name="title_shell_preference">Командний рядок</string>
    <string name="summary_shell_preference">Вкажіть рядок звернення до командної оболонки.</string>
    <string name="dialog_title_shell_preference">Оболонка</string>
    <string name="title_initialcommand_preference">Команди запуску</string>
    <string name="summary_initialcommand_preference">Передаються облонці при запуску терміналу.</string>
    <string name="dialog_title_initialcommand_preference">Команди запуску</string>
    <string name="title_termtype_preference">Тип терміналу</string>
    <string name="summary_termtype_preference">Вибір типу терміналу, для використання в оболонці.</string>
    <string name="dialog_title_termtype_preference">Тип терміналу</string>
    <string name="title_close_window_on_process_exit_preference">Закриття вікна при виході</string>
    <string name="summary_close_window_on_process_exit_preference">Вікно закриється якщо вийти з оболонки.</string>
    <string name="title_verify_path_preference">Перевіряти ШЛЯХ даних</string>
    <string name="summary_verify_path_preference">Видаляти недоступні директорії з ШЛЯХУ.</string>
    <string name="title_do_path_extensions_preference">Допустимі дозволи ШЛЯХУ</string>
    <string name="summary_do_path_extensions_preference">Дозволити іншим програмам забезпечувати додаткові команди (додавання до ШЛЯХУ).</string>
    <string name="title_allow_prepend_path_preference">Допускати ШЛЯХ додавання</string>
    <string name="summary_allow_prepend_path_preference">Дозволити іншим програмам анулювати існуючі команди (додавання до початку ШЛЯХУ).</string>
    <string name="control_key_dialog_title">Керуючі та Функціональні Клавіші</string>
    <string name="control_key_dialog_control_text">CTRLKEY Space : Control-@ (NUL)
CTRLKEY A..Z : Control-A..Z
CTRLKEY 5 : Control-]
CTRLKEY 6 : Control-^
CTRLKEY 7 : Control-_
CTRLKEY 9 : F11
CTRLKEY 0 : F12</string>
    <string name="control_key_dialog_control_disabled_text">Нема установок керуючих клавіш.</string>
    <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9
FNKEY 0 : F10
FNKEY W : Up
FNKEY A : Left
FNKEY S : Down
FNKEY D : Right
FNKEY P : PageUp
FNKEY N : PageDown
FNKEY T : Tab
FNKEY L : | (pipe)
FNKEY U : _ (underscore)
FNKEY E : Control-[ (ESC)
FNKEY X : Delete
FNKEY I : Insert
FNKEY H : Home
FNKEY F : End
FNKEY . : Control-\\
</string>
    <string name="control_key_dialog_fn_disabled_text">Нема установок функціональних клавіш.</string>
    <string name="confirm_window_close_message">Закрити це вікно?</string>
    <string name="perm_run_script">Виконання довільних команд в Емуляторі Терміналу</string>
    <string name="permdesc_run_script">Дозволяє програмі відкриття нових вікон в Емуляторі Терміналу Android та запуск команд в цих вікнах з усіма дозволами Емулятора Терміналу Android, в тому числі доступ до Інтернету та SD-карти.</string>
    <string name="perm_append_to_path">Додавання команд в Емулятор Терміналу</string>
    <string name="permdesc_append_to_path">Програма зможе забезпечити додаткові команди (додати каталоги в ШЛЯХ) для емулятора терміналу Android.</string>
    <string name="perm_prepend_to_path">Перевизначення команд в Емуляторі Терміналу</string>
    <string name="permdesc_prepend_to_path">Дозволяє програмі перевизначити існуючі команди з власною версією (додайте на початку каталогів ШЛЯХ) в Емуляторі Терміналу Android.</string>
    <string name="email_transcript_subject">Розшифрування для Емулятора Терміналу Android</string>
    <string name="email_transcript_chooser_title">Поштове розшифрування за допомогою:</string>
    <string name="email_transcript_no_email_activity_found">Не можу вибрати поштову діяльність для відправки розшифрування.</string>
    <string name="alt_sends_esc">Клавіша Alt посилає ESC</string>
    <string name="alt_sends_esc_summary_on">Клавіша Alt посилає ESC.</string>
    <string name="alt_sends_esc_summary_off">Клавіша Alt не посилає ESC.</string>
</resources>

```

`term/src/main/res/values-v11/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!-- The Holo-era theme. This theme is only used for API level 11..20.
 -->

<resources>
    <!-- This style is used for all activities except the main terminal
         window. (Example: preferences.)
     -->
    <style name="Theme" parent="@android:style/Theme.Holo">
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowFrame">@null</item>
        <item name="android:windowContentOverlay">@null</item>
    </style>
    <!-- This style is used for the main terminal window when the action bar
         is visible. It is set programmatically at run time.
     -->
    <style name="Theme.Holo" parent="@android:style/Theme.Holo">
        <item name="android:windowFrame">@null</item>
        <item name="android:windowContentOverlay">@null</item>
    </style>
    <!-- This style is used for the main terminal window when the action bar
         is hidden. It is set programmatically at run time.
     -->
    <style name="Theme.Holo.ActionBarOverlay" parent="@style/Theme.Holo">
        <item name="android:windowActionBarOverlay">true</item>
        <item name="android:actionBarStyle">@style/Widget.ActionBarOverlay</item>
    </style>
    <style name="Widget.ActionBarOverlay" parent="@android:style/Widget.Holo.ActionBar">
        <item name="android:background">#a0000000</item>
    </style>
</resources>


```

`term/src/main/res/values-v21/colors.xml`:

```xml
<resources>
  <color name="primary">#607D8B</color>
  <color name="primary_dark">#455A64</color>
  <color name="accent">#8BC34A</color>
</resources>

```

`term/src/main/res/values-v21/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!-- The Material Design theme. This theme is only used for API level 21...
 -->

<resources>
    <!-- This style is used for all activities.
     -->
    <style name="Theme" parent="@android:style/Theme.DeviceDefault">
        <item name="android:windowFrame">@null</item>
        <item name="android:windowContentOverlay">@null</item>
        <!-- Main theme colors -->
        <!--   your app branding color for the app bar -->
        <item name="android:colorPrimary">@color/primary</item>
        <!--   darker variant for the status bar and contextual app bars -->
        <item name="android:colorPrimaryDark">@color/primary_dark</item>
        <!--   theme UI controls like checkboxes and text fields -->
        <item name="android:colorAccent">@color/accent</item>
    </style>
</resources>


```

`term/src/main/res/values-zh-rCN/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>显示状态栏</item>
        <item>隐藏状态栏</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>显示操作栏</item>
        <item>隐藏操作栏 (点击屏幕上方或按菜单键显示)</item>
    </string-array>

    <string-array name="entries_orientation_preference">
        <item>自动</item>
        <item>横屏</item>
        <item>竖屏</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>非闪烁光标</item>
        <item>闪烁光标</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>方块</item>
        <item>下划线</item>
        <item>竖线</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 像素</item>
        <item>6 磅</item>
        <item>7 磅</item>
        <item>8 磅</item>
        <item>9 磅</item>
        <item>10 磅</item>
        <item>12 磅</item>
        <item>14 磅</item>
        <item>16 磅</item>
        <item>20 磅</item>
        <item>24 磅</item>
        <item>28 磅</item>
        <item>32 磅</item>
        <item>36 磅</item>
        <item>42 磅</item>
        <item>48 磅</item>
        <item>64 磅</item>
        <item>72 磅</item>
        <item>96 磅</item>
        <item>144 磅</item>
        <item>288 磅</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>白底黑字</item>
        <item>黑底白字</item>
        <item>蓝底白字</item>
        <item>黑底绿字</item>
        <item>黑底黄字</item>
        <item>黑底红字</item>
        <item>Holo 风格</item>
        <item>爆光过度</item>
        <item>爆光不足</item>
        <item>Linux 终端</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>关闭所有窗口</item>
        <item>关闭当前窗口</item>
        <item>关闭当前实例，保留正在运行的会话</item>
        <item>给终端发送 ESC</item>
        <item>给终端发送 TAB</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>轨迹球</item>
        <item>\@ 键</item>
        <item>左 Alt 键</item>
        <item>右 Alt 键</item>
        <item>提升音量键</item>
        <item>降低音量键</item>
        <item>相机快门键</item>
        <item>无</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>轨迹球</item>
        <item>\@ 键</item>
        <item>左 Alt 键</item>
        <item>右 Alt 键</item>
        <item>提升音量键</item>
        <item>降低音量键</item>
        <item>相机快门键</item>
        <item>无</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>字本</item>
        <item>词本</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>
</resources>

```

`term/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">终端模拟器</string>
   <string name="preferences">首选项</string>
   <string name="new_window">新窗口</string>
   <string name="close_window">关闭窗口</string>
   <string name="window_list">窗口列表</string>
   <string name="prev_window">前一窗口</string>
   <string name="next_window">后一窗口</string>
   <string name="reset">重置终端</string>
   <string name="send_email">发送电子邮件到...</string>
   <string name="special_keys">特殊键</string>
   <string name="toggle_soft_keyboard">打开/关闭软键盘</string>

   <string name="reset_toast_notification">当前窗口终端状态将被重置</string>

   <string name="enable_wakelock">开启唤醒锁</string>
   <string name="disable_wakelock">关闭唤醒锁</string>
   <string name="enable_wifilock">开启 Wifi 锁</string>
   <string name="disable_wifilock">关闭 Wifi 锁</string>

   <string name="edit_text">编辑文本</string>
   <string name="select_text">选择文本</string>
   <string name="copy_all">全部复制</string>
   <string name="paste">粘贴</string>
   <string name="send_control_key">发送 Ctrl 键</string>
   <string name="send_fn_key">发送 Fn 键</string>

   <string name="window_title">窗口 %1$d</string>

   <string name="service_notify_text">会话正在运行</string>

   <string name="process_exit_message">会话已结束</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">屏幕</string>

   <string name="title_statusbar_preference">状态栏</string>
   <string name="summary_statusbar_preference">显示/隐藏状态栏。</string>
   <string name="dialog_title_statusbar_preference">状态栏</string>

   <string name="title_actionbar_preference">操作栏</string>
   <string name="summary_actionbar_preference">选择操作栏行为 (Android 3.0 及以上)</string>
   <string name="dialog_title_actionbar_preference">操作栏行为</string>

   <string name="title_orientation_preference">屏幕方位</string>
   <string name="summary_orientation_preference">选择屏幕方位行为</string>
   <string name="dialog_title_orientation_preference">屏幕方位行为</string>

   <string name="title_cursorstyle_preference">光标样式</string>
   <string name="summary_cursorstyle_preference">选择光标样式</string>
   <string name="dialog_title_cursorstyle_preference">光标样式</string>

   <string name="title_cursorblink_preference">光标闪烁</string>
   <string name="summary_cursorblink_preference">选择光标闪烁模式</string>
   <string name="dialog_title_cursorblink_preference">光标闪烁</string>

   <string name="text_preferences">文本</string>

   <string name="title_utf8_by_default_preference">默认 UTF-8</string>
   <string name="summary_utf8_by_default_preference">是否将 UTF-8 模式设为默认</string>

   <string name="title_fontsize_preference">文本大小</string>
   <string name="summary_fontsize_preference">选择文本大小</string>
   <string name="dialog_title_fontsize_preference">文本大小</string>

   <string name="title_color_preference">颜色</string>
   <string name="summary_color_preference">选择文本颜色</string>
   <string name="dialog_title_color_preference">文本颜色</string>

   <string name="keyboard_preferences">键盘</string>

   <string name="title_backaction_preference">返回键行为</string>
   <string name="summary_backaction_preference">选择返回键行为</string>
   <string name="dialog_title_backaction_preference">返回键行为</string>

   <string name="title_controlkey_preference">Ctrl 键</string>
   <string name="summary_controlkey_preference">设置 Ctrl 键</string>
   <string name="dialog_title_controlkey_preference">Ctrl 键</string>

   <string name="title_fnkey_preference">Fn 键</string>
   <string name="summary_fnkey_preference">设置 Fn 键</string>
   <string name="dialog_title_fnkey_preference">Fn 键</string>

   <string name="title_ime_preference">输入方式</string>
   <string name="summary_ime_preference">选择输入方式或软键盘</string>
   <string name="dialog_title_ime_preference">输入方式</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">命令行</string>
   <string name="summary_shell_preference">指定命令行使用的 Shell</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">初始命令</string>
   <string name="summary_initialcommand_preference">启动 Shell 时自动执行的命令</string>
   <string name="dialog_title_initialcommand_preference">初始命令</string>

   <string name="title_termtype_preference">终端类型</string>
   <string name="summary_termtype_preference">设置 Shell 的终端类型</string>
   <string name="dialog_title_termtype_preference">终端类型</string>

   <string name="title_close_window_on_process_exit_preference">退出时关闭窗口</string>
   <string name="summary_close_window_on_process_exit_preference">退出 Shell 时是否关闭窗口</string>

   <string name="title_verify_path_preference">验证 PATH 路径</string>
   <string name="summary_verify_path_preference">是否将 PATH 中无效的路径清除</string>

   <string name="title_do_path_extensions_preference">允许 PATH 后扩</string>
   <string name="summary_do_path_extensions_preference">是否允许程序添加额外命令到 PATH</string>

   <string name="title_allow_prepend_path_preference">允许 PATH 前置</string>
   <string name="summary_allow_prepend_path_preference">是否允许程序覆盖 PATH 中已有命令</string>

   <string name="title_home_path_preference">HOME 文件夹</string>
   <string name="summary_home_path_preference">用作 HOME 的可写文件夹路径</string>

   <string name="control_key_dialog_title">Ctrl 与 Fn 键</string>
   <string name="control_key_dialog_control_text">CTRLKEY Space : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
   <string name="control_key_dialog_control_disabled_text">未设置 Ctrl 键</string>
   <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Up\nFNKEY A : Left\nFNKEY S : Down\nFNKEY D : Right\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
   <string name="control_key_dialog_fn_disabled_text">未设置 Fn 键</string>

   <string name="confirm_window_close_message">关闭窗口吗？</string>

   <string name="perm_run_script">在终端模拟器中运行命令</string>
   <string name="permdesc_run_script">允许程序开启新窗口并运行包括与网络、存储卡相关命令在内的所有命令</string>
   <string name="perm_append_to_path">添加命令到终端模拟器</string>
   <string name="permdesc_append_to_path">允许程序添加额外命令</string>
   <string name="perm_prepend_to_path">覆盖终端模拟器中已有命令</string>
   <string name="permdesc_prepend_to_path">允许程序覆盖终端模拟器中已有命令</string>

   <string name="email_transcript_subject">终端模拟器副本</string>
   <string name="email_transcript_chooser_title">发送副本的邮件实例：</string>
   <string name="email_transcript_no_email_activity_found">找不到邮件实例发送副本</string>

   <string name="alt_sends_esc">Alt 键发送 ESC</string>
   <string name="alt_sends_esc_summary_on">开启 Alt 键发送 ESC</string>
   <string name="alt_sends_esc_summary_off">关闭 Alt 键发送 ESC</string>

   <string name="title_mouse_tracking_preference">发送鼠标事件</string>
   <string name="summary_mouse_tracking_preference">触摸与滚屏事件是否被终端忽略</string>

</resources>

```

`term/src/main/res/values-zh-rTW/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>顯示狀態列</item>
        <item>隱藏狀態列</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>Always show action bar</item>
        <item>Hide action bar (touch top of screen or Menu key to show)</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>非閃爍式浮標</item>
        <item>閃爍式浮標</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>方形</item>
        <item>底線</item>
        <item>直線</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 像素</item>
        <item>6 點</item>
        <item>7 點</item>
        <item>8 點</item>
        <item>9 點</item>
        <item>10 點</item>
        <item>12 點</item>
        <item>14 點</item>
        <item>16 點</item>
        <item>20 點</item>
        <item>24 點</item>
        <item>28 點</item>
        <item>32 點</item>
        <item>36 點</item>
        <item>42 點</item>
        <item>48 點</item>
        <item>64 點</item>
        <item>72 點</item>
        <item>96 點</item>
        <item>144 點</item>
        <item>288 點</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>白底黑字</item>
        <item>黑底白字</item>
        <item>藍底白字</item>
        <item>黑底綠字</item>
        <item>黑底黄字</item>
        <item>黑底紅字</item>
        <item>Holo blue on black</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Closes all terminal windows</item>
        <item>Closes this terminal window only</item>
        <item>Closes activity, leaving sessions running</item>
        <item>Sends ESC to terminal</item>
        <item>Sends TAB to terminal</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>軌跡球</item>
        <item>\@ 鍵</item>
        <item>左 Alt 鍵</item>
        <item>右 Alt 鍵</item>
        <item>提升音量鍵</item>
        <item>降低音量鍵</item>
        <item>相機快門鍵</item>
        <item>None</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>軌跡球</item>
        <item>\@ 鍵</item>
        <item>左 Alt 鍵</item>
        <item>右 Alt 鍵</item>
        <item>提升音量鍵</item>
        <item>降低音量鍵</item>
        <item>相機快門鍵</item>
        <item>None</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>字本</item>
        <item>詞本</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>
</resources>

```

`term/src/main/res/values-zh-rTW/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">模擬終端</string>
   <string name="preferences">設定</string>
   <string name="reset">結束</string>
   <string name="send_email">以電郵傳送</string>
   <string name="special_keys">特別按鍵</string>
   <string name="toggle_soft_keyboard">顯示／隱藏鍵盤</string>

   <string name="enable_wakelock">使用喚醒鎖定</string>
   <string name="disable_wakelock">解除喚醒鎖定</string>
   <string name="enable_wifilock">使用 WiFi 鎖定</string>
   <string name="disable_wifilock">解除 WiFi 鎖定</string>

   <string name="edit_text">編輯文字</string>
   <string name="select_text">選擇文字</string>
   <string name="copy_all">全部複製</string>
   <string name="paste">貼上</string>

   <string name="service_notify_text">終端機工作階段執行中</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">螢幕</string>

   <string name="title_statusbar_preference">狀態列</string>
   <string name="summary_statusbar_preference">顯示／隱藏狀態列</string>
   <string name="dialog_title_statusbar_preference">狀態列</string>

   <string name="title_cursorstyle_preference">浮標風格</string>
   <string name="summary_cursorstyle_preference">選擇浮標風格</string>
   <string name="dialog_title_cursorstyle_preference">浮標風格</string>

   <string name="title_cursorblink_preference">浮標閃爍</string>
   <string name="summary_cursorblink_preference">選擇浮標是否閃爍</string>
   <string name="dialog_title_cursorblink_preference">浮標閃爍</string>

   <string name="text_preferences">文字</string>

   <string name="title_fontsize_preference">字型大小</string>
   <string name="summary_fontsize_preference">選擇字元高度</string>
   <string name="dialog_title_fontsize_preference">字型大小</string>

   <string name="title_color_preference">色彩</string>
   <string name="summary_color_preference">選擇文字色彩</string>
   <string name="dialog_title_color_preference">文字色彩</string>

   <string name="keyboard_preferences">鍵盤</string>

   <string name="title_controlkey_preference">Ctrl 鍵</string>
   <string name="summary_controlkey_preference">選擇 Ctrl 鍵</string>
   <string name="dialog_title_controlkey_preference">Ctrl 鍵</string>

   <string name="title_fnkey_preference">Fn 鍵</string>
   <string name="summary_fnkey_preference">選擇 Fn 鍵</string>
   <string name="dialog_title_fnkey_preference">Fn 鍵</string>

   <string name="title_ime_preference">輸入方式</string>
   <string name="summary_ime_preference">選擇軟體鍵盤的輸入方式</string>
   <string name="dialog_title_ime_preference">輸入方式</string>

   <string name="shell_preferences">殼層</string>
   <string name="title_shell_preference">命令列</string>
   <string name="summary_shell_preference">指定殼層的命令列</string>
   <string name="dialog_title_shell_preference">殼層</string>

   <string name="title_initialcommand_preference">初始命令</string>
   <string name="summary_initialcommand_preference">在啟動時傳送至殼層</string>
   <string name="dialog_title_initialcommand_preference">初始命令</string>

   <!-- Don't localize these default values -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_statusbar_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_cursorstyle_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_cursorblink_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_fontsize_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_color_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_controlkey_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_fnkey_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_ime_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_shell_preference -->
   <!-- skipping untranslatable /resources:0/string:name=default_value_initialcommand_preference -->
</resources>

```

`term/src/main/res/values/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

<resources>
    <string-array name="entries_statusbar_preference">
        <item>Show status bar</item>
        <item>Hide status bar</item>
    </string-array>

    <string-array name="entries_actionbar_preference">
        <!-- <item>Action bar disabled</item> -->
        <item>Always show action bar</item>
        <item>Hide action bar (touch top of screen or Menu key to show)</item>
    </string-array>

    <string-array name="entries_orientation_preference">
        <item>Automatic</item>
        <item>Landscape</item>
        <item>Portrait</item>
    </string-array>

    <string-array name="entries_cursorblink_preference">
        <item>Non-blinking cursor</item>
        <item>Blinking cursor</item>
    </string-array>

    <string-array name="entries_cursorstyle_preference">
        <item>Rectangle</item>
        <item>Underline</item>
        <item>Vertical bar</item>
    </string-array>

    <string-array name="entries_fontsize_preference">
        <item>4 x 8 pixels</item>
        <item>6 pt</item>
        <item>7 pt</item>
        <item>8 pt</item>
        <item>9 pt</item>
        <item>10 pt</item>
        <item>12 pt</item>
        <item>14 pt</item>
        <item>16 pt</item>
        <item>20 pt</item>
        <item>24 pt</item>
        <item>28 pt</item>
        <item>32 pt</item>
        <item>36 pt</item>
        <item>42 pt</item>
        <item>48 pt</item>
        <item>64 pt</item>
        <item>72 pt</item>
        <item>96 pt</item>
        <item>144 pt</item>
        <item>288 pt</item>
    </string-array>

    <string-array name="entries_color_preference">
        <item>Black text on white</item>
        <item>White text on black</item>
        <item>White text on blue</item>
        <item>Green text on black</item>
        <item>Amber text on black</item>
        <item>Red text on black</item>
        <item>Holo blue text on black</item>
        <item>Solarized Light</item>
        <item>Solarized Dark</item>
        <item>Linux Console</item>
    </string-array>

    <string-array name="entries_backaction_preference">
        <item>Closes all terminal windows</item>
        <item>Closes this terminal window only</item>
        <item>Closes activity, leaving sessions running</item>
        <item>Sends ESC to terminal</item>
        <item>Sends TAB to terminal</item>
    </string-array>

    <string-array name="entries_controlkey_preference">
        <item>Jog ball</item>
        <item>\@ key</item>
        <item>Left Alt key</item>
        <item>Right Alt key</item>
        <item>Vol Up key</item>
        <item>Vol Down key</item>
        <item>Camera key</item>
        <item>None</item>
    </string-array>

    <string-array name="entries_fnkey_preference">
        <item>Jog ball</item>
        <item>\@ key</item>
        <item>Left Alt key</item>
        <item>Right Alt key</item>
        <item>Vol Up key</item>
        <item>Vol Down key</item>
        <item>Camera key</item>
        <item>None</item>
    </string-array>

    <string-array name="entries_ime_preference">
        <item>Character-based</item>
        <item>Word-based</item>
    </string-array>

    <!-- These are the 'short' names for the control keys. They are used in the special keys dialog. -->
    <string-array name="control_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>

    <!-- These are the 'short' names for the Fn keys. They are used in the special keys dialog. -->
    <string-array name="fn_keys_short_names">
        <item>Ball</item>
        <item>\@</item>
        <item>Left-Alt</item>
        <item>Right-Alt</item>
        <item>Vol-Up</item>
        <item>Vol-Dn</item>
        <item>Camera</item>
        <item>None</item>
    </string-array>
</resources>

```

`term/src/main/res/values/arraysNoLocalize.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 -->

 <!-- Don't localize this file -->

<resources>
    <string-array name="entryvalues_statusbar_preference">
        <item>1</item>
        <item>0</item>
    </string-array>

    <string-array name="entryvalues_actionbar_preference">
        <!-- <item>0</item> -->
        <item>1</item>
        <item>2</item>
    </string-array>

    <string-array name="entryvalues_orientation_preference">
        <item>0</item>
        <item>1</item>
        <item>2</item>
    </string-array>

    <string-array name="entryvalues_cursorblink_preference">
        <item>0</item>
        <item>1</item>
    </string-array>

    <string-array name="entryvalues_cursorstyle_preference">
        <item>0</item>
        <item>1</item>
        <item>2</item>
    </string-array>

    <!-- Note: Must also modify the maximum allowed preference value in TermSettings.readPrefs -->
    <string-array name="entryvalues_fontsize_preference">
        <item>0</item>
        <item>6</item>
        <item>7</item>
        <item>8</item>
        <item>9</item>
        <item>10</item>
        <item>12</item>
        <item>14</item>
        <item>16</item>
        <item>20</item>
        <item>24</item>
        <item>28</item>
        <item>32</item>
        <item>36</item>
        <item>42</item>
        <item>48</item>
        <item>64</item>
        <item>72</item>
        <item>96</item>
        <item>144</item>
        <item>288</item>
    </string-array>

    <string-array name="entryvalues_color_preference">
        <item>0</item>
        <item>1</item>
        <item>2</item>
        <item>3</item>
        <item>4</item>
        <item>5</item>
        <item>6</item>
        <item>7</item>
        <item>8</item>
        <item>9</item>
    </string-array>

    <string-array name="entryvalues_backaction_preference">
        <item>0</item>
        <item>1</item>
        <item>2</item>
        <item>3</item>
        <item>4</item>
    </string-array>

    <string-array name="entryvalues_controlkey_preference">
        <item>0</item>
        <item>1</item>
        <item>2</item>
        <item>3</item>
        <item>4</item>
        <item>5</item>
        <item>6</item>
        <item>7</item>
    </string-array>

    <string-array name="entryvalues_fnkey_preference">
        <item>0</item>
        <item>1</item>
        <item>2</item>
        <item>3</item>
        <item>4</item>
        <item>5</item>
        <item>6</item>
        <item>7</item>
    </string-array>

    <string-array name="entryvalues_ime_preference">
        <item>0</item>
        <item>1</item>
    </string-array>

    <string-array name="entries_termtype_preference">
        <item>vt100</item>
        <item>screen</item>
        <item>linux</item>
        <item>screen-256color</item>
        <item>xterm</item>
    </string-array>
</resources>

```

`term/src/main/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
/* Copyright 2007, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the "License"); 
** you may not use this file except in compliance with the License. 
** You may obtain a copy of the License at 
**
**     http://www.apache.org/licenses/LICENSE-2.0 
**
** Unless required by applicable law or agreed to in writing, software 
** distributed under the License is distributed on an "AS IS" BASIS, 
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
** See the License for the specific language governing permissions and 
** limitations under the License.
*/
-->

<resources>
     <declare-styleable name="EmulatorView">
    </declare-styleable>
</resources>

```

`term/src/main/res/values/defaults.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
   <!-- Don't localize these default values -->
   <string name="pref_statusbar_default" translatable="false">1</string>
   <integer name="pref_actionbar_default">1</integer>
   <integer name="pref_orientation_default">0</integer>
   <string name="pref_cursorstyle_default" translatable="false">0</string>
   <string name="pref_cursorblink_default" translatable="false">0</string>
   <string name="pref_fontsize_default" translatable="false">10</string>
   <string name="pref_color_default" translatable="false">1</string>
   <bool name="pref_utf8_by_default_default">false</bool>
   <string name="pref_backaction_default" translatable="false">2</string>
   <string name="pref_controlkey_default" translatable="false">5</string>
   <string name="pref_fnkey_default" translatable="false">4</string>
   <string name="pref_ime_default" translatable="false">0</string>
   <bool name="pref_alt_sends_esc_default">false</bool>
   <string name="pref_shell_default" translatable="false">/system/bin/sh -</string>
   <string name="pref_initialcommand_default" translatable="false"></string>
   <string name="pref_termtype_default" translatable="false">screen</string>
   <bool name="pref_close_window_on_process_exit_default">true</bool>
   <bool name="pref_verify_path_default">true</bool>
   <bool name="pref_do_path_extensions_default">true</bool>
   <bool name="pref_allow_prepend_path_default">true</bool>
   <!-- the home_path default is set dynamically in Term.onResume() -->
   <bool name="pref_mouse_tracking_default">false</bool>
   <bool name="pref_use_keyboard_shortcuts_default">true</bool>
</resources>

```

`term/src/main/res/values/id.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="id" name="imageview" />
    <item type="id" name="textview" />
    <item type="id" name="mainview" />
    <item type="id" name="scrollview" />
</resources>

```

`term/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->
<resources>
   <string name="application_terminal">Terminal Emulator</string>
   <string name="preferences">Preferences</string>
   <string name="new_window">New window</string>
   <string name="close_window">Close window</string>
   <string name="window_list">Windows</string>
   <string name="prev_window">Prev window</string>
   <string name="next_window">Next window</string>
   <string name="reset">Reset term</string>
   <string name="send_email">Email to</string>
   <string name="special_keys">Special keys</string>
   <string name="toggle_soft_keyboard">Toggle soft keyboard</string>

   <string name="reset_toast_notification">This window\'s terminal state has been reset.</string>

   <string name="enable_wakelock">Take WakeLock</string>
   <string name="disable_wakelock">Drop WakeLock</string>
   <string name="enable_wifilock">Take WifiLock</string>
   <string name="disable_wifilock">Drop WifiLock</string>

   <string name="edit_text">Edit text</string>
   <string name="select_text">Select text</string>
   <string name="copy_all">Copy all</string>
   <string name="paste">Paste</string>
   <string name="send_control_key">Send control key</string>
   <string name="send_fn_key">Send fn key</string>

   <string name="window_title">Window %1$d</string>

   <string name="service_notify_text">Terminal session is running</string>

   <string name="process_exit_message">Terminal session finished</string>

   <!-- Preference dialog -->
   <string name="screen_preferences">Screen</string>

   <string name="title_statusbar_preference">Status bar</string>
   <string name="summary_statusbar_preference">Show/hide status bar.</string>
   <string name="dialog_title_statusbar_preference">Status bar</string>

   <string name="title_actionbar_preference">Action bar</string>
   <string name="summary_actionbar_preference">Choose the action bar\'s behavior (Android 3.0 and up).</string>
   <string name="dialog_title_actionbar_preference">Action bar behavior</string>

   <string name="title_orientation_preference">Screen orientation</string>
   <string name="summary_orientation_preference">Choose the screen orientation behavior.</string>
   <string name="dialog_title_orientation_preference">Screen orientation behavior</string>

   <string name="title_cursorstyle_preference">Cursor style</string>
   <string name="summary_cursorstyle_preference">Choose cursor style.</string>
   <string name="dialog_title_cursorstyle_preference">Cursor style</string>

   <string name="title_cursorblink_preference">Cursor blink</string>
   <string name="summary_cursorblink_preference">Choose cursor blink.</string>
   <string name="dialog_title_cursorblink_preference">Cursor blink</string>

   <string name="text_preferences">Text</string>

   <string name="title_utf8_by_default_preference">Default to UTF-8</string>
   <string name="summary_utf8_by_default_preference">Whether UTF-8 mode is enabled by default.</string>

   <string name="title_fontsize_preference">Font size</string>
   <string name="summary_fontsize_preference">Choose character height in points.</string>
   <string name="dialog_title_fontsize_preference">Font size</string>

   <string name="title_color_preference">Colors</string>
   <string name="summary_color_preference">Choose text color.</string>
   <string name="dialog_title_color_preference">Text color</string>

   <string name="keyboard_preferences">Keyboard</string>

   <string name="title_backaction_preference">Back button behavior</string>
   <string name="summary_backaction_preference">Choose what pressing the back button does.</string>
   <string name="dialog_title_backaction_preference">Back button behavior</string>

   <string name="title_controlkey_preference">Control key</string>
   <string name="summary_controlkey_preference">Choose control key.</string>
   <string name="dialog_title_controlkey_preference">Control key</string>

   <string name="title_fnkey_preference">Fn key</string>
   <string name="summary_fnkey_preference">Choose Fn key.</string>
   <string name="dialog_title_fnkey_preference">Fn key</string>

   <string name="title_ime_preference">Input method</string>
   <string name="summary_ime_preference">Choose input method for soft keyboard.</string>
   <string name="dialog_title_ime_preference">Input method</string>

   <string name="shell_preferences">Shell</string>
   <string name="title_shell_preference">Command line</string>
   <string name="summary_shell_preference">Specify the shell command line.</string>
   <string name="dialog_title_shell_preference">Shell</string>

   <string name="title_initialcommand_preference">Initial command</string>
   <string name="summary_initialcommand_preference">Sent to the shell when it starts.</string>
   <string name="dialog_title_initialcommand_preference">Initial Command</string>

   <string name="title_termtype_preference">Terminal type</string>
   <string name="summary_termtype_preference">What terminal type to report to the shell.</string>
   <string name="dialog_title_termtype_preference">Terminal type</string>

   <string name="title_close_window_on_process_exit_preference">Close window on exit</string>
   <string name="summary_close_window_on_process_exit_preference">Whether a window should close when its shell exits.</string>

   <string name="title_verify_path_preference">Verify PATH entries</string>
   <string name="summary_verify_path_preference">Whether inaccessible directories should be removed from the PATH.</string>

   <string name="title_do_path_extensions_preference">Allow PATH extensions</string>
   <string name="summary_do_path_extensions_preference">Whether other apps should be allowed to provide additional commands (add to PATH).</string>

   <string name="title_allow_prepend_path_preference">Allow PATH prepend</string>
   <string name="summary_allow_prepend_path_preference">Whether other apps should be allowed to override existing commands (add to the beginning of PATH).</string>

   <string name="title_home_path_preference">HOME folder</string>
   <string name="summary_home_path_preference">Path to a writable folder to be used as HOME.</string>

   <string name="control_key_dialog_title">Control and Function Keys</string>
   <!-- The word CTRLKEY should be left un-translated. It will be replaced at run-time with the
        actual control key key name. -->
   <string name="control_key_dialog_control_text">CTRLKEY Space : Control-@ (NUL)\nCTRLKEY A..Z : Control-A..Z\nCTRLKEY 5 : Control-]\nCTRLKEY 6 : Control-^\nCTRLKEY 7 : Control-_\nCTRLKEY 9 : F11\nCTRLKEY 0 : F12</string>
  <string name="control_key_dialog_control_disabled_text">No control key set.</string>
  <!-- The word FNKEY should be left un-translated. It will be replaced at run-time with the
       actual function key key name. -->
  <string name="control_key_dialog_fn_text">FNKEY 1..9 : F1-F9\nFNKEY 0 : F10\nFNKEY W : Up\nFNKEY A : Left\nFNKEY S : Down\nFNKEY D : Right\nFNKEY P : PageUp\nFNKEY N : PageDown\nFNKEY T : Tab\nFNKEY L : | (pipe)\nFNKEY U : _ (underscore)\nFNKEY E : Control-[ (ESC)\nFNKEY X : Delete\nFNKEY I : Insert\nFNKEY H : Home\nFNKEY F : End\nFNKEY . : Control-\\\n</string>
  <string name="control_key_dialog_fn_disabled_text">No function key set.</string>

  <string name="confirm_window_close_message">Close this window?</string>

  <string name="perm_run_script">Run arbitrary commands in Terminal Emulator</string>
  <string name="permdesc_run_script">Allows application to open new windows in Terminal Emulator for Android and run commands in those windows with all of Terminal Emulator for Android\'s permissions, including access to the Internet and your SD Card.</string>
  <string name="perm_append_to_path">Add commands to Terminal Emulator</string>
  <string name="permdesc_append_to_path">Allows application to provide additional commands (add directories to the PATH) for Terminal Emulator for Android.</string>
  <string name="perm_prepend_to_path">Override commands in Terminal Emulator</string>
  <string name="permdesc_prepend_to_path">Allows application to override existing commands with its own versions (prepend directories to the PATH) in Terminal Emulator for Android.</string>

  <string name="email_transcript_subject">Transcript from Terminal Emulator for Android</string>
  <string name="email_transcript_chooser_title">Mail transcript using:</string>
  <string name="email_transcript_no_email_activity_found">Could not choose an email activity to send transcript.</string>

  <string name="alt_sends_esc">Alt key sends ESC</string>
  <string name="alt_sends_esc_summary_on">Alt key sends ESC.</string>
  <string name="alt_sends_esc_summary_off">Alt key does not send ESC.</string>

  <string name="title_mouse_tracking_preference">Send mouse events</string>
  <string name="summary_mouse_tracking_preference">Whether tap and scroll events should be sent as escape sequences to the terminal.</string>

  <string name="title_use_keyboard_shortcuts">Use Keyboard Shortcuts</string>
  <string name="use_keyboard_shortcuts_summary_on">Ctrl-Tab: cycle window, Ctrl-Shift-N: new window, Ctrl-Shift-V: paste.</string>
  <string name="use_keyboard_shortcuts_summary_off">Keyboard shortcuts disabled.</string>

  <string name="help">Help</string>
  <string name="help_url" translatable="false">http://jackpal.github.com/Android-Terminal-Emulator/help/index.html</string>
  <string name="activity_term_here_title">Term here</string>
  <!-- BEGIN SHORTCUT RELATED STRINGS -->
  <!-- AndroidManifest.xml -->
  <string name="activity_shortcut_create">"Term shortcut"</string>
  <!-- FSNavigator.java -->
  <string name="fsnavigator_title">FILE SELECTOR</string>
  <string name="fsnavigator_no_external_storage">External storage not available</string>
  <string name="fsnavigator_optional_enter_path">Or enter path here.</string>
  <string name="fsnavigator_change_theme">Change theme</string>
  <!-- AddShortcut.java -->
  <string name="addshortcut_command_hint">command</string>
  <string name="addshortcut_example_hint">--example=\""a\"</string>
  <string name="addshortcut_button_find_command">Find command</string>
  <string name="addshortcut_navigator_title">SELECT SHORTCUT TARGET</string>
  <string name="addshortcut_command_window_instructions">Command window requires full path, no arguments. For other commands use Arguments window (ex: cd /sdcard).</string>
  <string name="addshortcut_arguments_label">Arguments\:</string>
  <string name="addshortcut_shortcut_label">Shortcut label\:</string>
  <string name="addshortcut_button_text_icon">Text icon</string>
  <string name="addshortcut_make_text_icon">MAKE TEXT ICON</string>
  <string name="addshortcut_text_icon_instructions"></string>
  <string name="addshortcut_title">Term shortcut</string>
  <!-- ColorValue.java -->
  <string name="colorvalue_letter_alpha">α</string>
  <string name="colorvalue_letter_red">R</string>
  <string name="colorvalue_letter_green">G</string>
  <string name="colorvalue_letter_blue">B</string>
  <string name="colorvalue_label_lock_button_column">LOCK</string>
  <string name="colorvalue_icon_text_entry_hint">Enter icon text</string>
  <!-- END SHORTCUT RELATED STRINGS -->
</resources>

```

`term/src/main/res/values/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2007 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->

<!-- The base theme. This theme is only used for API level 1..10.
 -->

<resources>
    <style name="Theme" parent="@android:style/Theme.Light">
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowFrame">@null</item>
        <item name="android:windowContentOverlay">@null</item>
    </style>
</resources>


```

`term/src/main/res/xml/preferences.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2008 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->

<PreferenceScreen
        xmlns:android="http://schemas.android.com/apk/res/android">

    <PreferenceCategory
            android:title="@string/screen_preferences"
            android:key="screen">

        <ListPreference
                android:key="statusbar"
                android:defaultValue="@string/pref_statusbar_default"
                android:title="@string/title_statusbar_preference"
                android:summary="@string/summary_statusbar_preference"
                android:entries="@array/entries_statusbar_preference"
                android:entryValues="@array/entryvalues_statusbar_preference"
                android:dialogTitle="@string/dialog_title_statusbar_preference" />

        <ListPreference
                android:key="actionbar"
                android:defaultValue="@integer/pref_actionbar_default"
                android:title="@string/title_actionbar_preference"
                android:summary="@string/summary_actionbar_preference"
                android:entries="@array/entries_actionbar_preference"
                android:entryValues="@array/entryvalues_actionbar_preference"
                android:dialogTitle="@string/dialog_title_actionbar_preference" />

        <ListPreference
                android:key="orientation"
                android:defaultValue="@integer/pref_orientation_default"
                android:title="@string/title_orientation_preference"
                android:summary="@string/summary_orientation_preference"
                android:entries="@array/entries_orientation_preference"
                android:entryValues="@array/entryvalues_orientation_preference"
                android:dialogTitle="@string/dialog_title_orientation_preference" />

<!--
        <ListPreference
                android:key="cursorstyle"
                android:defaultValue="@string/pref_cursorstyle_default"
                android:title="@string/title_cursorstyle_preference"
                android:summary="@string/summary_cursorstyle_preference"
                android:entries="@array/entries_cursorstyle_preference"
                android:entryValues="@array/entryvalues_cursorstyle_preference"
                android:dialogTitle="@string/dialog_title_cursorstyle_preference" />

        <ListPreference
                android:key="cursorblink"
                android:defaultValue="@string/pref_cursorblink_default"
                android:title="@string/title_cursorblink_preference"
                android:summary="@string/summary_cursorblink_preference"
                android:entries="@array/entries_cursorblink_preference"
                android:entryValues="@array/entryvalues_cursorblink_preference"
                android:dialogTitle="@string/dialog_title_cursorblink_preference" />
-->

    </PreferenceCategory>

    <PreferenceCategory
            android:title="@string/text_preferences">

        <ListPreference
                android:key="fontsize"
                android:defaultValue="@string/pref_fontsize_default"
                android:title="@string/title_fontsize_preference"
                android:summary="@string/summary_fontsize_preference"
                android:entries="@array/entries_fontsize_preference"
                android:entryValues="@array/entryvalues_fontsize_preference"
                android:dialogTitle="@string/dialog_title_fontsize_preference" />

        <ListPreference
                android:key="color"
                android:defaultValue="@string/pref_color_default"
                android:title="@string/title_color_preference"
                android:summary="@string/summary_color_preference"
                android:entries="@array/entries_color_preference"
                android:entryValues="@array/entryvalues_color_preference"
                android:dialogTitle="@string/dialog_title_color_preference" />

        <CheckBoxPreference
                android:key="utf8_by_default"
                android:defaultValue="@bool/pref_utf8_by_default_default"
                android:title="@string/title_utf8_by_default_preference"
                android:summary="@string/summary_utf8_by_default_preference" />

    </PreferenceCategory>

    <PreferenceCategory
            android:title="@string/keyboard_preferences">

        <ListPreference
                android:key="backaction"
                android:defaultValue="@string/pref_backaction_default"
                android:title="@string/title_backaction_preference"
                android:summary="@string/summary_backaction_preference"
                android:entries="@array/entries_backaction_preference"
                android:entryValues="@array/entryvalues_backaction_preference"
                android:dialogTitle="@string/dialog_title_backaction_preference" />

        <ListPreference
                android:key="controlkey"
                android:defaultValue="@string/pref_controlkey_default"
                android:title="@string/title_controlkey_preference"
                android:summary="@string/summary_controlkey_preference"
                android:entries="@array/entries_controlkey_preference"
                android:entryValues="@array/entryvalues_controlkey_preference"
                android:dialogTitle="@string/dialog_title_controlkey_preference" />

        <ListPreference
                android:key="fnkey"
                android:defaultValue="@string/pref_fnkey_default"
                android:title="@string/title_fnkey_preference"
                android:summary="@string/summary_fnkey_preference"
                android:entries="@array/entries_fnkey_preference"
                android:entryValues="@array/entryvalues_fnkey_preference"
                android:dialogTitle="@string/dialog_title_fnkey_preference" />

        <ListPreference
                android:key="ime"
                android:defaultValue="@string/pref_ime_default"
                android:title="@string/title_ime_preference"
                android:summary="@string/summary_ime_preference"
                android:entries="@array/entries_ime_preference"
                android:entryValues="@array/entryvalues_ime_preference"
                android:dialogTitle="@string/dialog_title_ime_preference" />

        <CheckBoxPreference android:title="@string/alt_sends_esc"
                android:key="alt_sends_esc"
                android:defaultValue="@bool/pref_alt_sends_esc_default"
                android:summaryOn="@string/alt_sends_esc_summary_on"
                android:summaryOff="@string/alt_sends_esc_summary_off" />

        <CheckBoxPreference android:title="@string/title_use_keyboard_shortcuts"
                android:key="use_keyboard_shortcuts"
                android:defaultValue="@bool/pref_use_keyboard_shortcuts_default"
                android:summaryOn="@string/use_keyboard_shortcuts_summary_on"
                android:summaryOff="@string/use_keyboard_shortcuts_summary_off" />

        </PreferenceCategory>

    <PreferenceCategory
        android:title="@string/shell_preferences">

    <EditTextPreference
            android:key="shell"
            android:defaultValue="@string/pref_shell_default"
            android:title="@string/title_shell_preference"
            android:summary="@string/summary_shell_preference"
            android:dialogTitle="@string/dialog_title_shell_preference" />
    <EditTextPreference
            android:key="initialcommand"
            android:defaultValue="@string/pref_initialcommand_default"
            android:title="@string/title_initialcommand_preference"
            android:summary="@string/summary_initialcommand_preference"
            android:dialogTitle="@string/dialog_title_initialcommand_preference" />
    <ListPreference
            android:key="termtype"
            android:defaultValue="@string/pref_termtype_default"
            android:title="@string/title_termtype_preference"
            android:summary="@string/summary_termtype_preference"
            android:entries="@array/entries_termtype_preference"
            android:entryValues="@array/entries_termtype_preference"
            android:dialogTitle="@string/dialog_title_termtype_preference" />
    <CheckBoxPreference android:title="@string/title_mouse_tracking_preference"
            android:key="mouse_tracking"
            android:defaultValue="@bool/pref_mouse_tracking_default"
            android:summary="@string/summary_mouse_tracking_preference" />
    <CheckBoxPreference
            android:key="close_window_on_process_exit"
            android:defaultValue="@bool/pref_close_window_on_process_exit_default"
            android:title="@string/title_close_window_on_process_exit_preference"
            android:summary="@string/summary_close_window_on_process_exit_preference" />
    <CheckBoxPreference
            android:key="verify_path"
            android:defaultValue="@bool/pref_verify_path_default"
            android:title="@string/title_verify_path_preference"
            android:summary="@string/summary_verify_path_preference" />
    <CheckBoxPreference
            android:key="do_path_extensions"
            android:defaultValue="@bool/pref_do_path_extensions_default"
            android:title="@string/title_do_path_extensions_preference"
            android:summary="@string/summary_do_path_extensions_preference" />
    <CheckBoxPreference
            android:key="allow_prepend_path"
            android:dependency="do_path_extensions"
            android:defaultValue="@bool/pref_allow_prepend_path_default"
            android:title="@string/title_allow_prepend_path_preference"
            android:summary="@string/summary_allow_prepend_path_preference" />
    <!-- the home_path default is set dynamically in Term.onResume() -->
    <EditTextPreference
            android:key="home_path"
            android:title="@string/title_home_path_preference"
            android:summary="@string/summary_home_path_preference" />
    </PreferenceCategory>
</PreferenceScreen>

```

`tests/controlSequences/256color.txt`:

```txt
]4;16;rgb:00/00/00\]4;17;rgb:00/00/5f\]4;18;rgb:00/00/87\]4;19;rgb:00/00/af\]4;20;rgb:00/00/d7\]4;21;rgb:00/00/ff\]4;22;rgb:00/5f/00\]4;23;rgb:00/5f/5f\]4;24;rgb:00/5f/87\]4;25;rgb:00/5f/af\]4;26;rgb:00/5f/d7\]4;27;rgb:00/5f/ff\]4;28;rgb:00/87/00\]4;29;rgb:00/87/5f\]4;30;rgb:00/87/87\]4;31;rgb:00/87/af\]4;32;rgb:00/87/d7\]4;33;rgb:00/87/ff\]4;34;rgb:00/af/00\]4;35;rgb:00/af/5f\]4;36;rgb:00/af/87\]4;37;rgb:00/af/af\]4;38;rgb:00/af/d7\]4;39;rgb:00/af/ff\]4;40;rgb:00/d7/00\]4;41;rgb:00/d7/5f\]4;42;rgb:00/d7/87\]4;43;rgb:00/d7/af\]4;44;rgb:00/d7/d7\]4;45;rgb:00/d7/ff\]4;46;rgb:00/ff/00\]4;47;rgb:00/ff/5f\]4;48;rgb:00/ff/87\]4;49;rgb:00/ff/af\]4;50;rgb:00/ff/d7\]4;51;rgb:00/ff/ff\]4;52;rgb:5f/00/00\]4;53;rgb:5f/00/5f\]4;54;rgb:5f/00/87\]4;55;rgb:5f/00/af\]4;56;rgb:5f/00/d7\]4;57;rgb:5f/00/ff\]4;58;rgb:5f/5f/00\]4;59;rgb:5f/5f/5f\]4;60;rgb:5f/5f/87\]4;61;rgb:5f/5f/af\]4;62;rgb:5f/5f/d7\]4;63;rgb:5f/5f/ff\]4;64;rgb:5f/87/00\]4;65;rgb:5f/87/5f\]4;66;rgb:5f/87/87\]4;67;rgb:5f/87/af\]4;68;rgb:5f/87/d7\]4;69;rgb:5f/87/ff\]4;70;rgb:5f/af/00\]4;71;rgb:5f/af/5f\]4;72;rgb:5f/af/87\]4;73;rgb:5f/af/af\]4;74;rgb:5f/af/d7\]4;75;rgb:5f/af/ff\]4;76;rgb:5f/d7/00\]4;77;rgb:5f/d7/5f\]4;78;rgb:5f/d7/87\]4;79;rgb:5f/d7/af\]4;80;rgb:5f/d7/d7\]4;81;rgb:5f/d7/ff\]4;82;rgb:5f/ff/00\]4;83;rgb:5f/ff/5f\]4;84;rgb:5f/ff/87\]4;85;rgb:5f/ff/af\]4;86;rgb:5f/ff/d7\]4;87;rgb:5f/ff/ff\]4;88;rgb:87/00/00\]4;89;rgb:87/00/5f\]4;90;rgb:87/00/87\]4;91;rgb:87/00/af\]4;92;rgb:87/00/d7\]4;93;rgb:87/00/ff\]4;94;rgb:87/5f/00\]4;95;rgb:87/5f/5f\]4;96;rgb:87/5f/87\]4;97;rgb:87/5f/af\]4;98;rgb:87/5f/d7\]4;99;rgb:87/5f/ff\]4;100;rgb:87/87/00\]4;101;rgb:87/87/5f\]4;102;rgb:87/87/87\]4;103;rgb:87/87/af\]4;104;rgb:87/87/d7\]4;105;rgb:87/87/ff\]4;106;rgb:87/af/00\]4;107;rgb:87/af/5f\]4;108;rgb:87/af/87\]4;109;rgb:87/af/af\]4;110;rgb:87/af/d7\]4;111;rgb:87/af/ff\]4;112;rgb:87/d7/00\]4;113;rgb:87/d7/5f\]4;114;rgb:87/d7/87\]4;115;rgb:87/d7/af\]4;116;rgb:87/d7/d7\]4;117;rgb:87/d7/ff\]4;118;rgb:87/ff/00\]4;119;rgb:87/ff/5f\]4;120;rgb:87/ff/87\]4;121;rgb:87/ff/af\]4;122;rgb:87/ff/d7\]4;123;rgb:87/ff/ff\]4;124;rgb:af/00/00\]4;125;rgb:af/00/5f\]4;126;rgb:af/00/87\]4;127;rgb:af/00/af\]4;128;rgb:af/00/d7\]4;129;rgb:af/00/ff\]4;130;rgb:af/5f/00\]4;131;rgb:af/5f/5f\]4;132;rgb:af/5f/87\]4;133;rgb:af/5f/af\]4;134;rgb:af/5f/d7\]4;135;rgb:af/5f/ff\]4;136;rgb:af/87/00\]4;137;rgb:af/87/5f\]4;138;rgb:af/87/87\]4;139;rgb:af/87/af\]4;140;rgb:af/87/d7\]4;141;rgb:af/87/ff\]4;142;rgb:af/af/00\]4;143;rgb:af/af/5f\]4;144;rgb:af/af/87\]4;145;rgb:af/af/af\]4;146;rgb:af/af/d7\]4;147;rgb:af/af/ff\]4;148;rgb:af/d7/00\]4;149;rgb:af/d7/5f\]4;150;rgb:af/d7/87\]4;151;rgb:af/d7/af\]4;152;rgb:af/d7/d7\]4;153;rgb:af/d7/ff\]4;154;rgb:af/ff/00\]4;155;rgb:af/ff/5f\]4;156;rgb:af/ff/87\]4;157;rgb:af/ff/af\]4;158;rgb:af/ff/d7\]4;159;rgb:af/ff/ff\]4;160;rgb:d7/00/00\]4;161;rgb:d7/00/5f\]4;162;rgb:d7/00/87\]4;163;rgb:d7/00/af\]4;164;rgb:d7/00/d7\]4;165;rgb:d7/00/ff\]4;166;rgb:d7/5f/00\]4;167;rgb:d7/5f/5f\]4;168;rgb:d7/5f/87\]4;169;rgb:d7/5f/af\]4;170;rgb:d7/5f/d7\]4;171;rgb:d7/5f/ff\]4;172;rgb:d7/87/00\]4;173;rgb:d7/87/5f\]4;174;rgb:d7/87/87\]4;175;rgb:d7/87/af\]4;176;rgb:d7/87/d7\]4;177;rgb:d7/87/ff\]4;178;rgb:d7/af/00\]4;179;rgb:d7/af/5f\]4;180;rgb:d7/af/87\]4;181;rgb:d7/af/af\]4;182;rgb:d7/af/d7\]4;183;rgb:d7/af/ff\]4;184;rgb:d7/d7/00\]4;185;rgb:d7/d7/5f\]4;186;rgb:d7/d7/87\]4;187;rgb:d7/d7/af\]4;188;rgb:d7/d7/d7\]4;189;rgb:d7/d7/ff\]4;190;rgb:d7/ff/00\]4;191;rgb:d7/ff/5f\]4;192;rgb:d7/ff/87\]4;193;rgb:d7/ff/af\]4;194;rgb:d7/ff/d7\]4;195;rgb:d7/ff/ff\]4;196;rgb:ff/00/00\]4;197;rgb:ff/00/5f\]4;198;rgb:ff/00/87\]4;199;rgb:ff/00/af\]4;200;rgb:ff/00/d7\]4;201;rgb:ff/00/ff\]4;202;rgb:ff/5f/00\]4;203;rgb:ff/5f/5f\]4;204;rgb:ff/5f/87\]4;205;rgb:ff/5f/af\]4;206;rgb:ff/5f/d7\]4;207;rgb:ff/5f/ff\]4;208;rgb:ff/87/00\]4;209;rgb:ff/87/5f\]4;210;rgb:ff/87/87\]4;211;rgb:ff/87/af\]4;212;rgb:ff/87/d7\]4;213;rgb:ff/87/ff\]4;214;rgb:ff/af/00\]4;215;rgb:ff/af/5f\]4;216;rgb:ff/af/87\]4;217;rgb:ff/af/af\]4;218;rgb:ff/af/d7\]4;219;rgb:ff/af/ff\]4;220;rgb:ff/d7/00\]4;221;rgb:ff/d7/5f\]4;222;rgb:ff/d7/87\]4;223;rgb:ff/d7/af\]4;224;rgb:ff/d7/d7\]4;225;rgb:ff/d7/ff\]4;226;rgb:ff/ff/00\]4;227;rgb:ff/ff/5f\]4;228;rgb:ff/ff/87\]4;229;rgb:ff/ff/af\]4;230;rgb:ff/ff/d7\]4;231;rgb:ff/ff/ff\]4;232;rgb:08/08/08\]4;233;rgb:12/12/12\]4;234;rgb:1c/1c/1c\]4;235;rgb:26/26/26\]4;236;rgb:30/30/30\]4;237;rgb:3a/3a/3a\]4;238;rgb:44/44/44\]4;239;rgb:4e/4e/4e\]4;240;rgb:58/58/58\]4;241;rgb:62/62/62\]4;242;rgb:6c/6c/6c\]4;243;rgb:76/76/76\]4;244;rgb:80/80/80\]4;245;rgb:8a/8a/8a\]4;246;rgb:94/94/94\]4;247;rgb:9e/9e/9e\]4;248;rgb:a8/a8/a8\]4;249;rgb:b2/b2/b2\]4;250;rgb:bc/bc/bc\]4;251;rgb:c6/c6/c6\]4;252;rgb:d0/d0/d0\]4;253;rgb:da/da/da\]4;254;rgb:e4/e4/e4\]4;255;rgb:ee/ee/ee\System colors:
[48;5;0m  [48;5;1m  [48;5;2m  [48;5;3m  [48;5;4m  [48;5;5m  [48;5;6m  [48;5;7m  [0m
[48;5;8m  [48;5;9m  [48;5;10m  [48;5;11m  [48;5;12m  [48;5;13m  [48;5;14m  [48;5;15m  [0m

Color cube, 6x6x6:
[48;5;16m  [48;5;17m  [48;5;18m  [48;5;19m  [48;5;20m  [48;5;21m  [0m [48;5;52m  [48;5;53m  [48;5;54m  [48;5;55m  [48;5;56m  [48;5;57m  [0m [48;5;88m  [48;5;89m  [48;5;90m  [48;5;91m  [48;5;92m  [48;5;93m  [0m [48;5;124m  [48;5;125m  [48;5;126m  [48;5;127m  [48;5;128m  [48;5;129m  [0m [48;5;160m  [48;5;161m  [48;5;162m  [48;5;163m  [48;5;164m  [48;5;165m  [0m [48;5;196m  [48;5;197m  [48;5;198m  [48;5;199m  [48;5;200m  [48;5;201m  [0m 
[48;5;22m  [48;5;23m  [48;5;24m  [48;5;25m  [48;5;26m  [48;5;27m  [0m [48;5;58m  [48;5;59m  [48;5;60m  [48;5;61m  [48;5;62m  [48;5;63m  [0m [48;5;94m  [48;5;95m  [48;5;96m  [48;5;97m  [48;5;98m  [48;5;99m  [0m [48;5;130m  [48;5;131m  [48;5;132m  [48;5;133m  [48;5;134m  [48;5;135m  [0m [48;5;166m  [48;5;167m  [48;5;168m  [48;5;169m  [48;5;170m  [48;5;171m  [0m [48;5;202m  [48;5;203m  [48;5;204m  [48;5;205m  [48;5;206m  [48;5;207m  [0m 
[48;5;28m  [48;5;29m  [48;5;30m  [48;5;31m  [48;5;32m  [48;5;33m  [0m [48;5;64m  [48;5;65m  [48;5;66m  [48;5;67m  [48;5;68m  [48;5;69m  [0m [48;5;100m  [48;5;101m  [48;5;102m  [48;5;103m  [48;5;104m  [48;5;105m  [0m [48;5;136m  [48;5;137m  [48;5;138m  [48;5;139m  [48;5;140m  [48;5;141m  [0m [48;5;172m  [48;5;173m  [48;5;174m  [48;5;175m  [48;5;176m  [48;5;177m  [0m [48;5;208m  [48;5;209m  [48;5;210m  [48;5;211m  [48;5;212m  [48;5;213m  [0m 
[48;5;34m  [48;5;35m  [48;5;36m  [48;5;37m  [48;5;38m  [48;5;39m  [0m [48;5;70m  [48;5;71m  [48;5;72m  [48;5;73m  [48;5;74m  [48;5;75m  [0m [48;5;106m  [48;5;107m  [48;5;108m  [48;5;109m  [48;5;110m  [48;5;111m  [0m [48;5;142m  [48;5;143m  [48;5;144m  [48;5;145m  [48;5;146m  [48;5;147m  [0m [48;5;178m  [48;5;179m  [48;5;180m  [48;5;181m  [48;5;182m  [48;5;183m  [0m [48;5;214m  [48;5;215m  [48;5;216m  [48;5;217m  [48;5;218m  [48;5;219m  [0m 
[48;5;40m  [48;5;41m  [48;5;42m  [48;5;43m  [48;5;44m  [48;5;45m  [0m [48;5;76m  [48;5;77m  [48;5;78m  [48;5;79m  [48;5;80m  [48;5;81m  [0m [48;5;112m  [48;5;113m  [48;5;114m  [48;5;115m  [48;5;116m  [48;5;117m  [0m [48;5;148m  [48;5;149m  [48;5;150m  [48;5;151m  [48;5;152m  [48;5;153m  [0m [48;5;184m  [48;5;185m  [48;5;186m  [48;5;187m  [48;5;188m  [48;5;189m  [0m [48;5;220m  [48;5;221m  [48;5;222m  [48;5;223m  [48;5;224m  [48;5;225m  [0m 
[48;5;46m  [48;5;47m  [48;5;48m  [48;5;49m  [48;5;50m  [48;5;51m  [0m [48;5;82m  [48;5;83m  [48;5;84m  [48;5;85m  [48;5;86m  [48;5;87m  [0m [48;5;118m  [48;5;119m  [48;5;120m  [48;5;121m  [48;5;122m  [48;5;123m  [0m [48;5;154m  [48;5;155m  [48;5;156m  [48;5;157m  [48;5;158m  [48;5;159m  [0m [48;5;190m  [48;5;191m  [48;5;192m  [48;5;193m  [48;5;194m  [48;5;195m  [0m [48;5;226m  [48;5;227m  [48;5;228m  [48;5;229m  [48;5;230m  [48;5;231m  [0m 
Grayscale ramp:
[48;5;232m  [48;5;233m  [48;5;234m  [48;5;235m  [48;5;236m  [48;5;237m  [48;5;238m  [48;5;239m  [48;5;240m  [48;5;241m  [48;5;242m  [48;5;243m  [48;5;244m  [48;5;245m  [48;5;246m  [48;5;247m  [48;5;248m  [48;5;249m  [48;5;250m  [48;5;251m  [48;5;252m  [48;5;253m  [48;5;254m  [48;5;255m  [0m

```

`tests/controlSequences/combiningCharReplacement.txt`:

```txt
Overwriting a letter with combining diacritic with a letter without in an
80-column line:

xxxxxMu[combining diaeresis]nchenxxx[...] ESC [ 7 G u:
xxxxxMünchenxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[7Gu

Overwriting a letter without combining diacritic with a letter with combining diacritic in an 80-column line:

xxxxMunchenxxx[...] ESC [ 6 G u [combining diaeresis]:
xxxxMunchenxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[6Gü

```

`tests/controlSequences/combiningChars.txt`:

```txt
a combining grave accent: à
a combining grave accent combining low line: à̲
a combining enclosing circle backslash: à̲⃠
musical symbol g clef: 𝄞

a combining grave accent combining low line at the end of an 80-column line:   à̲

```

`tests/controlSequences/hideCursor.txt`:

```txt
[?25lThe cursor is now hidden.

```

`tests/controlSequences/setTitle.txt`:

```txt
]0;I am a title\Window title should now be 'I am a title'.

```

`tests/controlSequences/showCursor.txt`:

```txt
[?25hThe cursor is now visible.

```

`tests/controlSequences/textStyle.txt`:

```txt
Text style test
normal:              [0mtext[0m
bold:                [1mtext[0m
faint:               [2mtext[0m
italic:              [3mtext[0m (may show as inverse)
underline:           [4mtext[0m
blink:               [5mtext[0m (may show as bold)
6:                   [6mtext[0m
inverse:             [7mtext[0m
invisible:           [8mtext[0m
bold-underline:      [1;4mtext[0m
bold-ul-inverse:     [1;4;7mtext[0m
invis-bold-ul:       [1;4;8mtext[0m
invis-bold-ul-invrs: [1;4;7;8mtext[0m
everything:          [1;2;3;4;5;6;7;8mtext[0m
Reset bold/faint:    [1;2;3;4;5;6;7mtext[22mtext[23;24;25;27mtext[0m
Reset bold/faint:    [1mtext[22mtext[0m
Reset bold/faint:    [2mtext[22mtext[0m
dim colors:          [31;42mred on green[0m
bright colors:       [91;102mred on green[0m

```

`tests/emulatorview-test/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="jackpal.androidterm.test"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="11" />

    <instrumentation
        android:name="android.test.InstrumentationTestRunner"
        android:targetPackage="jackpal.androidterm" />

    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <uses-library android:name="android.test.runner" />
    </application>

</manifest>

```

`tests/emulatorview-test/ant.properties`:

```properties
# This file is used to override default values used by the Ant build system.
#
# This file must be checked into Version Control Systems, as it is
# integral to the build system of your project.

# This file is only used by the Ant script.

# You can use this to override default values such as
#  'source.dir' for the location of your java source folder and
#  'out.dir' for the location of your output folder.

# You can also use it define how the release builds are signed by declaring
# the following properties:
#  'key.store' for the location of your keystore and
#  'key.alias' for the name of the key to use.
# The password will be asked during the build when you use the 'release' target.

tested.project.dir=../..

```

`tests/emulatorview-test/proguard-project.txt`:

```txt
# To enable ProGuard in your project, edit project.properties
# to define the proguard.config property as described in that file.
#
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in ${sdk.dir}/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the ProGuard
# include property in project.properties.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

```

`tests/emulatorview-test/project.properties`:

```properties
# This file is automatically generated by Android Tools.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
#
# This file must be checked in Version Control Systems.
#
# To customize properties used by the Ant build system edit
# "ant.properties", and override values to adapt the script to your
# project structure.
#
# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt

# Project target.
target=android-11

```

`tests/emulatorview-test/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">Emulatorview-testTest</string>

</resources>
```

`tests/emulatorview-test/src/jackpal/androidterm/emulatorview/InputConnectionTest.java`:

```java
package jackpal.androidterm.emulatorview;

import android.test.AndroidTestCase;
// import android.test.mock.MockApplication;
// import android.test.mock.MockContext;
// import android.util.DisplayMetrics;
// import android.view.inputmethod.InputConnection;

public class InputConnectionTest extends AndroidTestCase {

    public InputConnectionTest() {
        super();
    }

    public void testBackSpace() {
//		MockContext cn = new MockContext();
//		MockApplication a = new MockApplication();
//		TermSession ts = new TermSession();
//		DisplayMetrics m = new DisplayMetrics();
//		EmulatorView e = new EmulatorView(cn, ts, m);
//		InputConnection c = e.onCreateInputConnection(null);
    }
}

```

`tests/emulatorview-test/src/jackpal/androidterm/emulatorview/ModifierKeyTest.java`:

```java
package jackpal.androidterm.emulatorview;

import android.test.AndroidTestCase;
// import android.view.KeyEvent;

public class ModifierKeyTest extends AndroidTestCase {

    public void testCtrlKey() {
//		ModifierKey mk = new ModifierKey(KeyEvent.KEYCODE_CTRL_LEFT);
//		assertFalse(mk.isActive());
//		mk.handleModifierKey(KeyEvent.KEYCODE_CTRL_LEFT, true);
//		assertTrue(mk.isActive());
    }
}

```

`tests/emulatorview-test/src/jackpal/androidterm/emulatorview/TermKeyListenerTest.java`:

```java
package jackpal.androidterm.emulatorview;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;

import android.annotation.TargetApi;
import android.test.AndroidTestCase;
import android.view.KeyEvent;

class MockTermSession extends TermSession {

    private byte[] charseq = null;

    @Override
    public void write(byte[] data, int offset, int count) {
        if (charseq==null) {
            charseq = data;
        } else {
            byte[] tmp = new byte[data.length + charseq.length];
            for (int i = 0; i < charseq.length; i++) {
                tmp[i] = charseq[i];
            }
            for (int i = 0; i < data.length; i++) {
                tmp[i+charseq.length] = data[i];
            }
            charseq = tmp;
        }
    }

    public void clearQueue() {
        charseq = null;
    }

    public byte[] getCharSequence() {
        return charseq;
    }

    @Override
    public void write(String data) {
        try {
            byte[] bytes = data.getBytes("UTF-8");
            write(bytes, 0, bytes.length);
        } catch (UnsupportedEncodingException e) {
        }
    }

    @Override
    public void write(int codePoint) {
        CharBuffer charBuf = CharBuffer.allocate(2);
        ByteBuffer byteBuf = ByteBuffer.allocate(4);
        CharsetEncoder encoder = Charset.forName("UTF-8").newEncoder();

        charBuf.clear();
        byteBuf.clear();
        Character.toChars(codePoint, charBuf.array(), 0);
        encoder.reset();
        encoder.encode(charBuf, byteBuf, true);
        encoder.flush(byteBuf);
        write(byteBuf.array(), 0, byteBuf.position()-1);
    }

}

@TargetApi(3)
public class TermKeyListenerTest extends  AndroidTestCase {
    //TermKeyListener tkl_AltIsEsc;
    TermKeyListener tkl_AltNotEsc;
    //MockTermSession mckTermSessionA = new MockTermSession();
    MockTermSession mckTermSessionB = new MockTermSession();
    public TermKeyListenerTest() {
        super();
    }

    public void setUp() {
        //tkl_AltIsEsc = new TermKeyListener(mckTermSessionA);
        tkl_AltNotEsc = new TermKeyListener(mckTermSessionB);
        mckTermSessionB.clearQueue();
    }

    public void testKey_a()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_A,
                  0,
                  new byte[]{0x61});
    }

    public void testKey_X()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_X,
                  KeyEvent.META_SHIFT_ON,
                  new byte[]{0x58});
    }

    public void testKey_CTRL_c()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_C,

                  KeyEvent.META_CTRL_ON ,
                  new byte[]{0x03});
    }

    public void testKey_ALT_x_no_esc()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_X,

                  KeyEvent.META_ALT_ON,
                  new byte[]{0x00,0x00,0x00,0x00});
    }

    public void testKey_ALT_x_esc()
            throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.setAltSendsEsc(true);
        int keycode = KeyEvent.KEYCODE_ALT_LEFT;
        KeyEvent event = new KeyEvent(1,2, KeyEvent.ACTION_DOWN, keycode, 0,
                0);
        tkl_AltNotEsc.keyDown(keycode, event, false, true);
        keyHelperToggle(KeyEvent.KEYCODE_X,

                      KeyEvent.META_ALT_ON,
                      new byte[]{0x1b,0x78}, true);
        }

    public void testKey_ALT_c_no_esc()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_C,

                  KeyEvent.META_ALT_ON,
                  new byte[]{-61,-89,0x00,0x00});
    }


    public void testKey_enter()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_ENTER,
                  0,
                  new byte[]{0x0d});
    }


    public void testKey_del()
        throws UnsupportedEncodingException, IOException {
        KeyEvent event = new KeyEvent(1,2, KeyEvent.ACTION_DOWN,
                                      KeyEvent.KEYCODE_DEL,0 ,0);
        tkl_AltNotEsc.keyDown(event.getKeyCode(), event, true, false);
        byte[] res = mckTermSessionB.getCharSequence();
        byte[] exp = "\177".getBytes("UTF-8");
        assertNotNull(res);
        assertEquals(exp.length, res.length);
        for (int i = 0; i<exp.length; i++) {
            assertEquals(exp[i],res[i]);
        }
    }

    public void testKey_CTRL_C()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_C,
                  KeyEvent.META_CTRL_ON | KeyEvent.META_SHIFT_ON,
                  new byte[]{0x03});
    }

    public void testKey_CTRL_2()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_2,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x00});
    }

    public void testKey_CTRL_SPC()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_SPACE,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x00});
    }

    public void testKey_CTRL_3()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_3,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x1b});
    }

    public void testKey_CTRL_LEFT_BRACKET()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_LEFT_BRACKET,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x1b});
    }

    public void testKey_CTRL_BACKSLASH()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_BACKSLASH,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x1c});
    }

    public void testKey_CTRL_4()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_4,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x1c});
    }

    public void testKey_CTRL_RIGHT_BRACKET()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_RIGHT_BRACKET,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x1d});
    }

    public void testKey_CTRL_5()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_5,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x1d});
    }

    public void testKey_CTRL_CARET()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_6,
                  KeyEvent.META_CTRL_ON | KeyEvent.META_SHIFT_ON,
                  new byte[]{0x1e});
    }

    public void testKey_CTRL_6()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_6,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x1e});
    }

    public void testKey_CTRL_UNDERSCORE()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_MINUS,
                  KeyEvent.META_CTRL_ON | KeyEvent.META_SHIFT_ON,
                  new byte[]{0x1f});
    }

    public void testKey_CTRL_7()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_7,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x1f});
    }

    public void testKey_CTRL_8()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_8,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{0x7f});
    }

    public void testKey_CTRL_9()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_9,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{27,91,50,51,126});
    }

    public void testKey_CTRL_0()
        throws UnsupportedEncodingException, IOException {
        keyHelper(KeyEvent.KEYCODE_0,
                  KeyEvent.META_CTRL_ON,
                  new byte[]{27,91,50,52,126});
    }

    public void testKey_FN_w()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_W,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,79,65}, true);
    }

    public void testKey_FN_a()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_A,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,79,68}, true);
    }

    public void testKey_FN_s()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_S,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,79,66}, true);
    }

    public void testKey_FN_d()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_D,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,79,67}, true);
    }

    public void testKey_FN_p()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_P,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,91,53,126}, true);
    }

    public void testKey_FN_n()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_N,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,91,54,126}, true);
    }

    public void testKey_FN_t()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_T,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{9}, true);
    }

    public void testKey_FN_l()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_L,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{124,0,0,0}, true);
    }

    public void testKey_FN_u()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_U,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{95,0,0,0}, true);
    }

    public void testKey_FN_e()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_E,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,0,0,0}, true);
    }

    public void testKey_FN_i()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_I,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,91,50,126}, true);
    }

    public void testKey_FN_x()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_X,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,91,51,126}, true);
    }

    public void testKey_FN_h()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_H,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,91,49,126}, true);
    }

    public void testKey_FN_f()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_F,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,91,52,126}, true);
    }

    public void testKey_FN_PERIOD()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_PERIOD,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{28,0,0,0}, true);
    }

    public void testKey_FN_9()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_9,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{-62,-69,0,0}, true);
    }

    public void testKey_FN_0()
        throws UnsupportedEncodingException, IOException {
        tkl_AltNotEsc.handleFnKey(true);
        keyHelperToggle(KeyEvent.KEYCODE_0,
                  KeyEvent.META_FUNCTION_ON,
                  new byte[]{27,91,50,49,126}, true);
    }

    private void keyHelper(int keycode, int metastate,
            byte[] expectedOutput)
                       throws UnsupportedEncodingException, IOException{
        keyHelperToggle(keycode, metastate, expectedOutput, false);
    }

    private void keyHelperToggle(int keycode, int metastate,
               byte[] expectedOutPut, boolean toggle)
        throws UnsupportedEncodingException, IOException {
        KeyEvent event = new KeyEvent(1,2, KeyEvent.ACTION_DOWN, keycode, 0,
                                      metastate);
        tkl_AltNotEsc.keyDown(event.getKeyCode(), event, true, toggle);
        byte[] res = mckTermSessionB.getCharSequence();
        assertNotNull(res);
        assertTrue(expectedOutPut.length <= res.length);
        for (int i=0; i<expectedOutPut.length; i++) {
            assertEquals(expectedOutPut[i], res[i]);
        }
    }

    public void testPreconditions() {

    }

    public void tearDown() {
    }

}

```

`tests/fullWidthText`:

```
Make sure UTF-8 is enabled.
Full-width text:   [ＡＢＣ]
Normal-width text: [ABC   ]

```

`tests/issue145/README.md`:

```md
This directory contains files to help reproduce issue 145

fuzzer.go generates random strings of UTF-encoded characters.

issue145repro.txt - some text from a run of fuzzer.go.

Created by ./fuzzer | head -c 983 | tail -c 6 >issue145repro.txt

This is a minimal repro case for

https://github.com/jackpal/Android-Terminal-Emulator/issues/145

Repro steps
-----------

On a PC:

adb shell mkdir /data/local
adb push issue145repro.txt /data/local/issue145repro.txt

Run ATE

Configure ATE's preferences for UTF8

On ATE:

cat /data/local/issue145repro.txt

```

`tests/issue145/fuzzer.go`:

```go
// Generate a repatable string of characters for fuzz testing.

package main

import (
	"fmt"
	"math/rand"
	"unicode"
)

func main() {
	source := rand.NewSource(17)
	r := rand.New(source)

	for {
		switch r.Intn(4) {
		case 0:
			if r.Intn(20) == 0 {
				fmt.Printf("\n")
			} else {
				out(r, 32, 128)
			}
		case 1:
			out(r, 128, 256)
		case 2:
			out(r, 256, 0x10000)
		default:
			out(r, 0x10000, unicode.MaxRune)
		}
	}
}

func out(r *rand.Rand, begin, end int) {
	var c rune
	c = (rune)(r.Intn(end-begin) + begin)
	fmt.Printf("%c", c)
}

```

`tests/issue145/issue145repro.txt`:

```txt
𬘴
(
```

`tests/issue149/colors.go`:

```go
// Generate a repatable string of characters for fuzz testing.

package main

import (
	"fmt"
)

func setFore(c int) {
	fmt.Printf("\x1b[38;5;%dm", c)
}

func setBack(c int) {
	fmt.Printf("\x1b[48;5;%dm", c)
}

func main() {
	/*
		for i := 0; i < 255; i++ {
			setFore(i)
			fmt.Printf("Fore Color %d      \n", i)
		}
		setFore(0)
	*/

	for i := 0; i < 255; i++ {
		setBack(i)
		fmt.Printf("Back Color %d      \n", i)
	}
}

```

`tests/wideChars/combining-chars.txt`:

```txt
East Asian wide characters with combining diacritics:

中文 [combining low line]:
中文̲

xxx中[combining low line]文:
xxx中̲文

Overwriting an East Asian wide character with combining diacritic with an East
Asian wide character without combining diacritic, in the middle of an 80-column
line with mixed narrow and wide chars:

xxx[...]xxx中文[combining low line]xxx[...]xxx你好ESC [ 23 G 国:
xxxxxxxxxxxxxxxxxxxx中文̲xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[23G国

xxx[...]xxx中文[combining low line]。xxx[...]xxx你好xESC [ 23 G 国:
xxxxxxxxxxxxxxxxxxxx中文̲。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[23G国

Overwriting an East Asian wide character with another one with a combining
diacritic, in the middle of an 80-column line with mixed narrow and wide chars:

xxx[...]xxx中文xxx[...]xxx你好ESC [ 23 G 国[combining low line]:
xxxxxxxxxxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[23G国̲

xxx[...]xxx中文。xxx[...]xxx你好xESC [ 23 G 国[combining low line]:
xxxxxxxxxxxxxxxxxxxx中文。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[23G国̲

Overwriting a narrow character with an East Asian wide character with a
combining diacritic, in the middle of an 80-column line with mixed narrow and
wide chars:

xxx[...]xxx中文xxx[...]xxx你好xESC [ 25 G 。[combining low line]:
xxxxxxxxxxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[25G。̲

xxx[...]xxx中y文xxx[...]xxx你好ESC [ 23 G ，[combining low line]:
xxxxxxxxxxxxxxxxxxxx中y文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[23G，̲

Overwriting a narrow character with a combining diacritic with an East Asian
wide character, in the middle of an 80-column line with mixed narrow and
widechars:

xxxxxxxxàxxx[...]xxx中文xxx[...]xxx你好xESC [ 9 G 中:
xxxxxxxxàxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[9G中

xxxxxxxxàxxx[...]xxx中文xxx[...]xxx你好xESC [ 8 G 中:
xxxxxxxxàxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[8G中

Overwriting an East Asian wide character with combining diacritic with a narrow
character without combining diacritic, in the middle of an 80-column line with
mixed narrow and wide chars:

xxx[...]xxx中文[combining low line]xxx[...]xxx你好ESC [ 23 G y:
xxxxxxxxxxxxxxxxxxxx中文̲xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[23Gy

xxx[...]xxx中文[combining low line]。xxx[...]xxx你好xESC [ 23 G y:
xxxxxxxxxxxxxxxxxxxx中文̲。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[23Gy


```

`tests/wideChars/last-column-wrapping.txt`:

```txt
A line taking 81 screen columns, with an East Asian wide character at column 79
(should be truncated or wrapped on an 80-column terminal):

xxxxxxxxxxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好

```

`tests/wideChars/linkification.txt`:

```txt
A link on a line with East Asian wide characters:
中国国际航空公司 http://www.airchina.com/

A link on a long line with East Asian wide characters (the link should be
wrapped across two lines on an 80-column terminal):
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 中国国际航空公司 http://www.airchina.com/

```

`tests/wideChars/overwriting1.txt`:

```txt
Overwriting an East Asian wide character with another one:

中国 ESC [ 2 D 文:
中国[2D文

xxx中文 ESC [ 2 D 国:
xxx中文[2D国

Overwriting an East Asian wide character with another one, in the middle of
an 80-column line with mixed narrow and wide chars:

xxx[...]xxx中文xxx[...]xxx你好ESC [ 23 G 国:
xxxxxxxxxxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[23G国

xxx[...]xxx中文。xxx[...]xxx你好xESC [ 23 G 国:
xxxxxxxxxxxxxxxxxxxx中文。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[23G国

```

`tests/wideChars/overwriting2.txt`:

```txt
Inserting an East Asian wide character into the middle of another one:

中国 ESC [ D 文:
中国[D文

xxx中文 ESC [ D 国:
xxx中文[D国

Inserting an East Asian wide character into the middle of another one, in the
middle of an 80-column line with mixed narrow and wide chars:

xxx[...]xxx中文xxx[...]xxx你好xESC [ 24 G 国:
xxxxxxxxxxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[24G国

xxx[...]xxx中文。xxx[...]xxx你好ESC [ 24 G 国:
xxxxxxxxxxxxxxxxxxxx中文。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[24G国

```

`tests/wideChars/overwriting3.txt`:

```txt
Overwriting an East Asian wide character with a narrow character:

中国 ESC [ 2 D x:
中国[2Dx

xxx中文 ESC [ 2 D x:
xxx中文[2Dx

Overwriting an East Asian wide character with a narrow character, in the middle
of an 80-column line with mixed narrow and wide chars:

xxx[...]xxx中文xxx[...]xxx你好xESC [ 23 G y:
xxxxxxxxxxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[23Gy

xxx[...]xxx中文。xxx[...]xxx你好ESC [ 23 G y:
xxxxxxxxxxxxxxxxxxxx中文。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[23Gy

```

`tests/wideChars/overwriting4.txt`:

```txt
Overwriting a narrow character with an East Asian wide character:

xxx ESC [ D 中:
xxx[D中

xxx ESC [ 3 D 中:
xxx[3D中

Overwriting a narrow character with an East Asian wide character, in the middle
of an 80-column line with mixed narrow and wide chars:

xxx[...]xxx中文xxx[...]xxx你好xESC [ 25 G 版:
xxxxxxxxxxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[25G版

xxx[...]xxx中文y。xxx[...]xxx你好ESC [ 25 G 版:
xxxxxxxxxxxxxxxxxxxx中文y。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[25G版

```

`tests/wideChars/overwriting5.txt`:

```txt
Inserting a narrow character into the middle of an East Asian wide character:

中国 ESC [ D x:
中国[Dx

xxx中文 ESC [ D x:
xxx中文[Dx

Inserting a narrow character into the middle of an East Asian wide character,
in the middle of an 80-column line with mixed narrow and wide chars:

xxx[...]xxx中文xxx[...]xxx你好xESC [ 24 G y:
xxxxxxxxxxxxxxxxxxxx中文xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[24Gy

xxx[...]xxx中文。xxx[...]xxx你好ESC [ 24 G y:
xxxxxxxxxxxxxxxxxxxx中文。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[24Gy

```

`tests/wideChars/sip-chars.txt`:

```txt
East Asian wide characters in the Supplementary Ideographic Plane (thanks to
http://www.i18nguy.com/unicode/supplementary-test.html):

𠜎𠜱𠝹𠱓𠱸

Mixed East Asian wide characters from the BMP and SIP:

中文：𠜎𠜱，你好，𠝹国。
𠱸，中文：你好，𠝹国。

Narrow characters and mixed east Asian wide characters from the BMP and SIP, in
an 80-column line:
xxxxxxxxxx中文:𠜎𠜱，你好，xx𠝹国。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好xxxxxxxxxx
xxxxxxxxxx𠱸,中文：你xx好，𠝹国。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx好

Overwriting an East Asian wide character from the SIP with a narrow character:

中文：𠜎 ESC [ 2 D x:
中文：𠜎[2Dx

xxx中文：𠜎 ESC [ 2 D x:
xxx中文：𠜎[2Dx

Overwriting an East Asian wide character from the SIP with a narrow character,
in the middle of an 80-column line with mixed narrow and wide chars:

xxx[...]xxx中文：𠜎xxx[...]xxx你好xESC [ 27 G y:
xxxxxxxxxxxxxxxxxxxx中文：𠜎xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[27Gy

xxx[...]xxx中文：𠜎。xxx[...]xxx你好ESC [ 27 G y:
xxxxxxxxxxxxxxxxxxxx中文：𠜎。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[27Gy

Overwriting an East Asian wide character from the SIP with an East Asian wide
character from the BMP:

中文：𠜎 ESC [ 2 D 国:
中文：𠜎[2D国

xxx中文：𠜎 ESC [ 2 D 国:
xxx中文：𠜎[2D国

Overwriting an East Asian wide character from the SIP with an East Asian wide
character from the BMP in the middle of an 80-column line with mixed narrow and
wide chars:

xxx[...]xxx中文：𠜎xxx[...]xxx你好xESC [ 27 G 国:
xxxxxxxxxxxxxxxxxxxx中文：𠜎xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[27G国

xxx[...]xxx中文：𠜎。xxx[...]xxx你好ESC [ 27 G 国:
xxxxxxxxxxxxxxxxxxxx中文：𠜎。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[27G国

Overwriting an East Asian wide character from the BMP with an East Asian wide
character from the SIP:

中文：国 ESC [ 2 D 𠜎:
中文：国[2D𠜎

xxx中文：国 ESC [ 2 D 𠜎:
xxx中文：国[2D𠜎

Overwriting an East Asian wide character from the BMP with an East Asian wide
character from the SIP in the middle of an 80-column line with mixed narrow and
wide chars:

xxx[...]xxx中文：国xxx[...]xxx你好xESC [ 27 G 𠜎:
xxxxxxxxxxxxxxxxxxxx中文：国xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[27G𠜎

xxx[...]xxx中文：国。xxx[...]xxx你好ESC [ 27 G 𠜎:
xxxxxxxxxxxxxxxxxxxx中文：国。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[27G𠜎

Inserting a narrow character into the middle of an East Asian wide character
from the SIP in the middle of an 80-column line with mixed narrow and wide
chars:

xxx[...]xxx中文：𠜎xxx[...]xxx你好xESC [ 28 G y:
xxxxxxxxxxxxxxxxxxxx中文：𠜎xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[28Gy

xxx[...]xxx中文：𠜎。xxx[...]xxx你好ESC [ 28 G y:
xxxxxxxxxxxxxxxxxxxx中文：𠜎。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[28Gy

Inserting an East Asian wide character from the SIP into the middle of an East
Asian wide character from the BMP in the middle of an 80-column line with mixed
narrow and wide chars:

xxx[...]xxx中文：国xxx[...]xxx你好xESC [ 28 G 𠜎:
xxxxxxxxxxxxxxxxxxxx中文：国xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[28G𠜎

xxx[...]xxx中文：国。xxx[...]xxx你好ESC [ 28 G 𠜎:
xxxxxxxxxxxxxxxxxxxx中文：国。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[28G𠜎

Inserting an East Asian wide character from the BMP into the middle of an East
Asian wide character from the SIP in the middle of an 80-column line with mixed
narrow and wide chars:

xxx[...]xxx中文：𠜎xxx[...]xxx你好xESC [ 28 G 国:
xxxxxxxxxxxxxxxxxxxx中文：𠜎xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好x[28G国

xxx[...]xxx中文：𠜎。xxx[...]xxx你好ESC [ 28 G 国:
xxxxxxxxxxxxxxxxxxxx中文：𠜎。xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx你好[28G国


```

`tools/build-debug`:

```
#!/bin/bash
# command line build script for building debug version
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ATE_ROOT="$( cd $DIR/.. && pwd )"

cd "$ATE_ROOT"

if [ ! -f "local.properties" ]; then
    echo "local.properties does not exist. Please create it."
    exit 1
fi

./gradlew assembleDebug

```

`tools/build-release`:

```
#!/bin/bash
# command line build script for building release version
# This will only work on my (Jack Palevich) computer, because it
# requires the private key store used to sign the release version
# of Terminal Emulator for Android.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ATE_ROOT="$( cd $DIR/.. && pwd )"

cd "$ATE_ROOT"

if [ ! -f "local.properties" ]; then
    echo "local.properties does not exist. Please create it."
    exit 1
fi

./gradlew assembleRelease && ./tools/sign-release-build

```

`tools/import-icons`:

```
#!/bin/bash

set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ATE_ROOT="$( cd $DIR/.. && pwd )"

cd "$ATE_ROOT"

if [ "$#" -ne 1 ] || ! [ -f "$1-512.png" ]; then
  echo "Usage: $0 BASE_PATH_OF_ICONS_TO_IMPORT" >&2
  exit 1
fi

ICON=$1

RES=term/src/main/res
IC_LAUNCHER=ic_launcher.png

cp $ICON-48.png $RES/drawable/$IC_LAUNCHER
cp $ICON-36.png $RES/drawable-ldpi/$IC_LAUNCHER
cp $ICON-48.png $RES/drawable-mdpi/$IC_LAUNCHER
cp $ICON-72.png $RES/drawable-hdpi/$IC_LAUNCHER
cp $ICON-96.png $RES/drawable-xhdpi/$IC_LAUNCHER
cp $ICON-144.png $RES/drawable-xxhdpi/$IC_LAUNCHER
cp $ICON-192.png $RES/drawable-xxxhdpi/$IC_LAUNCHER

cp $ICON-512.png artwork/android-terminal-emulator-512.png

echo "Remember to update artwork/Feature Graphic.xcf"

```

`tools/increment-version-number`:

```
#!/bin/bash
# command line build script for building release version
# This will only work on my (Jack Palevich) computer, because it
# requires the private key store used to sign the release version
# of Terminal Emulator for Android.
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ATE_ROOT="$( cd $DIR/.. && pwd )"

cd "$ATE_ROOT"

MANIFEST="./term/src/main/AndroidManifest.xml"

if [ ! -f "$MANIFEST" ]; then
    echo "manifest $MANIFEST not found."
    exit 1
fi

perl -i -pe 's/(?<=android:versionName="1.0.)(\d+)/$1+1/e;s/(?<=android:versionCode=")(\d+)/$1+1/e;' "$MANIFEST"

```

`tools/install-sdk-packages`:

```
#!/bin/bash
# command line build script for installing required SDK packages.
set -e

if [ -z "${ANDROID_SDK_ROOT+xxx}" ]; then
    echo "Please define ANDROID_SDK_ROOT to point to the Android SDK"
    exit 1
fi

if [ ! -d "$ANDROID_SDK_ROOT" ]; then
    echo "The directory $ANDROID_SDK_ROOT = ${ANDROID_SDK_ROOT} does not exist."
    exit 1
fi

ANDROID="$ANDROID_SDK_ROOT/tools/android"

# The available SDK versions can be listed by:
# $ANDROID list sdk --all -e

# The update sdk command takes a comma-separated list of packages to install.
# Installing them all at once may simplify the process of agreeing to licenses.

$ANDROID update sdk -u -a -t android-22,build-tools-22.0.1,extra-android-m2repository

```

`tools/push-and-run-debug`:

```
#!/bin/bash
# command line build script for installing and running terminal emulator.
set -e

if [ -z "${ANDROID_SDK_ROOT+xxx}" ]; then
    echo "Please define ANDROID_SDK_ROOT to point to the Android SDK"
    exit 1
fi

if [ ! -d "$ANDROID_SDK_ROOT" ]; then
    echo "The directory $ANDROID_SDK_ROOT = ${ANDROID_SDK_ROOT} does not exist."
    exit 1
fi

ADB="$ANDROID_SDK_ROOT/platform-tools/adb"

$ADB uninstall jackpal.androidterm
$ADB install -r term/build/outputs/apk/term-debug.apk && $ADB shell am start -n jackpal.androidterm/jackpal.androidterm.Term

```

`tools/push-and-run-release`:

```
#!/bin/bash
# command line build script for installing and running terminal emulator.
set -e

if [ -z "${ANDROID_SDK_ROOT+xxx}" ]; then
    echo "Please define ANDROID_SDK_ROOT to point to the Android SDK"
    exit 1
fi

if [ ! -d "$ANDROID_SDK_ROOT" ]; then
    echo "The directory $ANDROID_SDK_ROOT = ${ANDROID_SDK_ROOT} does not exist."
    exit 1
fi

ADB="$ANDROID_SDK_ROOT/platform-tools/adb"

$ADB uninstall jackpal.androidterm
$ADB install -r term/build/outputs/apk/Term.apk && $ADB shell am start -n jackpal.androidterm/jackpal.androidterm.Term

```

`tools/push-samples-debug`:

```
#!/bin/bash
# command line build script for installing and running terminal emulator.
set -e

if [ -z "${ANDROID_SDK_ROOT+xxx}" ]; then
    echo "Please define ANDROID_SDK_ROOT to point to the Android SDK"
    exit 1
fi

if [ ! -d "$ANDROID_SDK_ROOT" ]; then
    echo "The directory $ANDROID_SDK_ROOT = ${ANDROID_SDK_ROOT} does not exist."
    exit 1
fi

ADB="$ANDROID_SDK_ROOT/platform-tools/adb"

$ADB uninstall jackpal.androidterm.sample.intents
$ADB install -r samples/intents/build/outputs/apk/intents-debug.apk

$ADB uninstall jackpal.androidterm.sample.pathbroadcasts
$ADB install -r samples/pathbroadcasts/build/outputs/apk/pathbroadcasts-debug.apk

$ADB uninstall jackpal.androidterm.sample.telnet
$ADB install -r samples/telnet/build/outputs/apk/telnet-debug.apk

```

`tools/sign-release-build`:

```
#!/bin/bash

# Script to sign the APK. Only needed by Jack Palevich.

# command line build script for building release version
# This will only work on my (Jack Palevich) computer, because it
# requires the private key store used to sign the release version
# of Terminal Emulator for Android.
set -e

ANDROID_TERMINAL_EMULATOR_KEYSTORE="$HOME/Documents/workspace/keystore/jackpal.keystore"

ZIPALIGN="/Users/jack/Library/Android/sdk/build-tools/21.1.2/zipalign"

if [ ! -f "$ANDROID_TERMINAL_EMULATOR_KEYSTORE" ]; then
    echo "Release keystore file is missing at ${ANDROID_TERMINAL_EMULATOR_KEYSTORE}. Cannot build release build."
    exit 1
fi

if [ ! -f "$ZIPALIGN" ]; then
    echo "Zipalign tool is missing at ${ZIPALIGN}. Cannot build release build."
    exit 1
fi


DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

APKDIR="$DIR/../term/build/outputs/apk"

if [ ! -d "$APKDIR" ]; then
  echo "No APK directory $APKDIR"
  exit 1
fi

cd "$APKDIR"

jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 \
  -keystore "$ANDROID_TERMINAL_EMULATOR_KEYSTORE" \
  -signedjar term-release-signed.apk \
  term-release-unsigned.apk jackpal.keystore

# Verify signature
# jarsigner -verify -verbose -certs term-release-signed.apk

# Align for faster loading.

rm -f Term.apk
"$ZIPALIGN" -v 4 term-release-signed.apk Term.apk

echo "Signed-and-aligned APK:"
echo `pwd`/Term.apk


```