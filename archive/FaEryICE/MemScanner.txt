Project Path: arc_FaEryICE_MemScanner_4v1_spw2

Source Tree:

```txt
arc_FaEryICE_MemScanner_4v1_spw2
├── MemScanner
│   ├── DriverScanner.c
│   ├── DriverScanner.h
│   ├── Import.h
│   ├── MemScanner.vcxproj
│   ├── MemScanner.vcxproj.filters
│   ├── NativeStruct.h
│   ├── Private.c
│   ├── Private.h
│   ├── ProcessScanner.c
│   ├── ProcessScanner.h
│   ├── SectionScanner.c
│   ├── SectionScanner.h
│   ├── Utils.c
│   ├── Utils.h
│   └── main.c
├── MemScanner.sln
└── README.md

```

`MemScanner.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30611.23
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MemScanner", "MemScanner\MemScanner.vcxproj", "{A03B3488-ABEB-4D77-8C35-CEBFFC44699E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A03B3488-ABEB-4D77-8C35-CEBFFC44699E}.Debug|x64.ActiveCfg = Debug|x64
		{A03B3488-ABEB-4D77-8C35-CEBFFC44699E}.Debug|x64.Build.0 = Debug|x64
		{A03B3488-ABEB-4D77-8C35-CEBFFC44699E}.Debug|x64.Deploy.0 = Debug|x64
		{A03B3488-ABEB-4D77-8C35-CEBFFC44699E}.Release|x64.ActiveCfg = Release|x64
		{A03B3488-ABEB-4D77-8C35-CEBFFC44699E}.Release|x64.Build.0 = Release|x64
		{A03B3488-ABEB-4D77-8C35-CEBFFC44699E}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3AF30B78-0863-4DD0-9F09-E07067B13245}
	EndGlobalSection
EndGlobal

```

`MemScanner/DriverScanner.c`:

```c
#include "DriverScanner.h"
#include "Private.h"
#include "Utils.h"


extern POBJECT_TYPE* IoDriverObjectType;

extern DYNAMIC_DATA   g_dynData;
extern PDRIVER_OBJECT g_DriverObject;
//-------------------------------------------------------------------------------------------------------------------------------------
VOID ScanDriverByDriverObjectMemory()
{
    PVOID                    lpStartAddr     = NULL;
    SIZE_T                   ulSize          = 0;
    ULONG_PTR                lpSearchAddr    = 0;
    ULONG_PTR                lpEndAddr       = 0;
    ULONG                    ulEntrySize     = 0;
    ULONG                    ulCurrentSize   = 0;
    ULONG_PTR                pDriverObject   = 0;
    NTSTATUS                 status          = STATUS_SUCCESS;
    PKLDR_DATA_TABLE_ENTRY   pLdr            = NULL;


    if (g_dynData.ver >= WINVER_7)
    {
        lpStartAddr = g_DriverObject;
        lpStartAddr = (PVOID)((ULONG_PTR)lpStartAddr & 0xFFFFFFFF00000000);
        ulSize = 0x300000000;
    }
    else
    {
        return;
    }

    lpSearchAddr = (ULONG_PTR)lpStartAddr;
    lpEndAddr    = lpSearchAddr + ulSize - sizeof(DRIVER_OBJECT);

    KdPrint(("[%s] lpSearchAddr:%p lpEndAddr:%p\n", __FUNCTION__, lpSearchAddr, lpEndAddr));

    while (TRUE)
    {
        if (lpSearchAddr + PAGE_SIZE > lpEndAddr)
        {
            ulEntrySize = (ULONG)(lpEndAddr - lpSearchAddr);
        }
        else
        {
            ulEntrySize = PAGE_SIZE;
        }

        if (!MmsIsAddressValidLength((PVOID)lpSearchAddr, ulEntrySize))
        {
            goto NextLoop;
        }

        pDriverObject = lpSearchAddr;

        ulCurrentSize = 0;
        ulEntrySize  -= sizeof(DRIVER_OBJECT);

        while (ulCurrentSize < ulEntrySize)
        {
            if (MmsIsRealDriverObject((PDRIVER_OBJECT)pDriverObject))
            {
                pLdr = (PKLDR_DATA_TABLE_ENTRY)(((PDRIVER_OBJECT)pDriverObject)->DriverSection);
                KdPrint(("[%s] pDriverObject:%p FullName:%wZ, DllBase:%I64x, Size:%x\n", __FUNCTION__, pDriverObject, &pLdr->FullDllName, pLdr->DllBase, pLdr->SizeOfImage));

                ulCurrentSize += sizeof(DRIVER_OBJECT);
                pDriverObject += sizeof(DRIVER_OBJECT);
            }
            else
            {
                ulCurrentSize += sizeof(ULONG_PTR);
                pDriverObject += sizeof(ULONG_PTR);
            }
        }

    NextLoop:
        lpSearchAddr += PAGE_SIZE;
        if (lpSearchAddr >= lpEndAddr)
        {
            break;
        }
    }
}
//-------------------------------------------------------------------------------------------------------------------------------------
VOID ScanDriverByLdrDataTableEntryMemory()
{
    PVOID                  lpStartAddr  = NULL;
    SIZE_T                 ulSize       = 0;
    ULONG_PTR              lpSearchAddr = 0;
    ULONG_PTR              lpTargetAddr = 0;
    ULONG                  ulEntrySize  = 0;
    ULONG_PTR              lpEndAddr    = 0;
    PLDR_DATA_TABLE_ENTRY  lpLdrEntry   = NULL;
    PPOOL_HEADER           PoolHeader   = NULL;

    if (g_dynData.ver >= WINVER_7)
    {
        lpStartAddr = g_DriverObject->DriverSection;
        lpStartAddr = (PVOID)((ULONG_PTR)lpStartAddr & 0xFFFFFFFF00000000);
        ulSize = 0x300000000;
    }
    else
    {
        return;
    }

    if (!lpStartAddr)
    {
        return;
    }

    lpSearchAddr = (ULONG_PTR)lpStartAddr;
    lpEndAddr    = lpSearchAddr + ulSize - sizeof(POOL_HEADER);

    KdPrint(("[%s] lpSearchAddr:%p lpEndAddr:%p\n", __FUNCTION__, lpSearchAddr, lpEndAddr));

    // Search For _ldr_data_table_entry
    while (TRUE)
    {
        if (lpSearchAddr + PAGE_SIZE > lpEndAddr)
        {
            ulEntrySize = (ULONG)(lpEndAddr - lpSearchAddr);
        }
        else
        {
            ulEntrySize = PAGE_SIZE;
        }

        if (!MmsIsAddressValidLength((PVOID)lpSearchAddr, ulEntrySize))
        {
            goto NextLoop;
        }

        lpTargetAddr = lpSearchAddr;

        while (TRUE)
        {
            PoolHeader = (PPOOL_HEADER)lpTargetAddr;
            if (PoolHeader->PoolTag == 'dLmM')
            {
                lpLdrEntry = (PLDR_DATA_TABLE_ENTRY)(lpTargetAddr + sizeof(POOL_HEADER));
                if (lpTargetAddr + sizeof(LDR_DATA_TABLE_ENTRY) + sizeof(POOL_HEADER) > lpSearchAddr + ulEntrySize)
                {
                    if (!MmsIsAddressValidLength((PVOID)lpTargetAddr, sizeof(LDR_DATA_TABLE_ENTRY) + sizeof(POOL_HEADER)))
                    {
                        break;
                    }
                }

                if (MmsIsValidUnicodeString(&lpLdrEntry->FullDllName) &&
                    MmsIsValidUnicodeString(&lpLdrEntry->BaseDllName) &&
                    lpLdrEntry->DllBase &&
                    lpLdrEntry->SizeOfImage &&
                    MmIsAddressValid(lpLdrEntry->DllBase))
                {
                    KdPrint(("[%s] FullName:%wZ, BaseName:%wZ, DllBase:%p, Size:%x\n", __FUNCTION__, &lpLdrEntry->FullDllName, &lpLdrEntry->BaseDllName, lpLdrEntry->DllBase, lpLdrEntry->SizeOfImage));
                }

                lpTargetAddr += sizeof(LDR_DATA_TABLE_ENTRY) + sizeof(POOL_HEADER);
            }
            else
            {
                lpTargetAddr += sizeof(ULONG);
            }

            if (lpTargetAddr + sizeof(POOL_HEADER) >= lpSearchAddr + ulEntrySize)
            {
                break;
            }
        }

    NextLoop:
        lpSearchAddr += PAGE_SIZE;
        if (lpSearchAddr >= lpEndAddr)
        {
            break;
        }
    }
}
//-------------------------------------------------------------------------------------------------------------------------------------
VOID ScanDriverByBigPoolSuspiciousPE()
{
    //Not Implement
}
//-------------------------------------------------------------------------------------------------------------------------------------
VOID ScanDriverByMmSessionSuspiciousPE()
{
    //Not Implement
}
//-------------------------------------------------------------------------------------------------------------------------------------
VOID ScanDriverBySystemPtesSuspiciousPE()
{
    //Not Implement
}
//-------------------------------------------------------------------------------------------------------------------------------------
VOID ScanDriverByDriverImageSuspiciousPE()
{
    //Not Implement
}
//-------------------------------------------------------------------------------------------------------------------------------------
VOID ScanDriver()
{
    ScanDriverByDriverObjectMemory();

    ScanDriverByLdrDataTableEntryMemory();

    // 内存扫描
    // 1. For BigPool which allocated By ExAllocatePoolWithTag
    ScanDriverByBigPoolSuspiciousPE();

    // 2. For MmSession which allocated By MmMapViewInSystemSpace
    ScanDriverByMmSessionSuspiciousPE();

    // 3. For SystemPtes which allocated By MmMapLockPagesSpecifyCache
    ScanDriverBySystemPtesSuspiciousPE();

    // 4. For DriverImage which allocated By System Loader...
    ScanDriverByDriverImageSuspiciousPE();
}
//-------------------------------------------------------------------------------------------------------------------------------------

```

`MemScanner/DriverScanner.h`:

```h
#pragma once

#include <ntifs.h>

VOID ScanDriver();
```

`MemScanner/Import.h`:

```h
#pragma once

#include <ntifs.h>

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
    IN ULONG SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength);

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(PVOID Base);

```

`MemScanner/MemScanner.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A03B3488-ABEB-4D77-8C35-CEBFFC44699E}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>MemScanner</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level2</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverScanner.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="Private.c" />
    <ClCompile Include="ProcessScanner.c" />
    <ClCompile Include="SectionScanner.c" />
    <ClCompile Include="Utils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverScanner.h" />
    <ClInclude Include="Import.h" />
    <ClInclude Include="Private.h" />
    <ClInclude Include="ProcessScanner.h" />
    <ClInclude Include="SectionScanner.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="NativeStruct.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`MemScanner/MemScanner.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Private.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverScanner.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SectionScanner.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ProcessScanner.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Private.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Import.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NativeStruct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverScanner.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProcessScanner.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SectionScanner.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`MemScanner/NativeStruct.h`:

```h
#pragma once

#include <ntifs.h>


#define SEC_IMAGE                 0x01000000

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, * PSYSTEM_BASIC_INFORMATION;


typedef struct _SYSTEM_MODULE_ENTRY
{
    HANDLE  Section;
    PVOID   MappedBase;
    PVOID   Base;
    ULONG   Size;
    ULONG   Flags;
    USHORT  LoadOrderIndex;
    USHORT  InitOrderIndex;
    USHORT  LoadCount;
    USHORT  OffsetToFileName;
    UCHAR   ImageName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;


typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG Count;
    SYSTEM_MODULE_ENTRY Modules[ANYSIZE_ARRAY];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
    union {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };

    ULONG_PTR SizeInBytes;

    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };

} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION
{
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;


typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemNotImplemented1,
    SystemProcessesInformation,
    SystemCallCounts,
    SystemConfigurationInformation,
    SystemProcessorTimes,
    SystemGlobalFlag,
    SystemNotImplemented2,
    SystemModuleInformation,
    SystemLockInformation,
    SystemNotImplemented3,
    SystemNotImplemented4,
    SystemNotImplemented5,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPagefileInformation,
    SystemInstructionEmulationCounts,
    SystemInvalidInfoClass1,
    SystemCacheInformation,
    SystemPoolTagInformation,
    SystemProcessorStatistics,
    SystemDpcInformation,
    SystemNotImplemented6,
    SystemLoadImage,
    SystemUnloadImage,
    SystemTimeAdjustment,
    SystemNotImplemented7,
    SystemNotImplemented8,
    SystemNotImplemented9,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemLoadAndCallImage,
    SystemPrioritySeparation,
    SystemNotImplemented10,
    SystemNotImplemented11,
    SystemInvalidInfoClass2,
    SystemInvalidInfoClass3,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemSetTimeSlipEvent,
    SystemCreateSession,
    SystemDeleteSession,
    SystemInvalidInfoClass4,
    SystemRangeStartInformation,
    SystemVerifierInformation,
    SystemAddVerifier,
    SystemSessionProcessesInformation,
    SystemLoadGdiDriverInSystemSpace = 0x0036,
    SystemNumaProcessorMap = 0x0037,
    SystemPrefetcherInformation = 0x0038,
    SystemExtendedProcessInformation = 0x0039,
    SystemRecommendedSharedDataAlignment = 0x003A,
    SystemComPlusPackage = 0x003B,
    SystemNumaAvailableMemory = 0x003C,
    SystemProcessorPowerInformation = 0x003D,
    SystemEmulationBasicInformation = 0x003E,
    SystemEmulationProcessorInformation = 0x003F,
    SystemExtendedHandleInformation = 0x0040,
    SystemLostDelayedWriteInformation = 0x0041,
    SystemBigPoolInformation = 0x0042,
    SystemSessionPoolTagInformation = 0x0043,
    SystemSessionMappedViewInformation = 0x0044,
    SystemHotpatchInformation = 0x0045,
    SystemObjectSecurityMode = 0x0046,
    SystemWatchdogTimerHandler = 0x0047,
    SystemWatchdogTimerInformation = 0x0048,
    SystemLogicalProcessorInformation = 0x0049,
    SystemWow64SharedInformationObsolete = 0x004A,
    SystemRegisterFirmwareTableInformationHandler = 0x004B,
    SystemFirmwareTableInformation = 0x004C,
    SystemModuleInformationEx = 0x004D,
    SystemVerifierTriageInformation = 0x004E,
    SystemSuperfetchInformation = 0x004F,
    SystemMemoryListInformation = 0x0050,
    SystemFileCacheInformationEx = 0x0051,
    SystemThreadPriorityClientIdInformation = 0x0052,
    SystemProcessorIdleCycleTimeInformation = 0x0053,
    SystemVerifierCancellationInformation = 0x0054,
    SystemProcessorPowerInformationEx = 0x0055,
    SystemRefTraceInformation = 0x0056,
    SystemSpecialPoolInformation = 0x0057,
    SystemProcessIdInformation = 0x0058,
    SystemErrorPortInformation = 0x0059,
    SystemBootEnvironmentInformation = 0x005A,
    SystemHypervisorInformation = 0x005B,
    SystemVerifierInformationEx = 0x005C,
    SystemTimeZoneInformation = 0x005D,
    SystemImageFileExecutionOptionsInformation = 0x005E,
    SystemCoverageInformation = 0x005F,
    SystemPrefetchPatchInformation = 0x0060,
    SystemVerifierFaultsInformation = 0x0061,
    SystemSystemPartitionInformation = 0x0062,
    SystemSystemDiskInformation = 0x0063,
    SystemProcessorPerformanceDistribution = 0x0064,
    SystemNumaProximityNodeInformation = 0x0065,
    SystemDynamicTimeZoneInformation = 0x0066,
    SystemCodeIntegrityInformation = 0x0067,
    SystemProcessorMicrocodeUpdateInformation = 0x0068,
    SystemProcessorBrandString = 0x0069,
    SystemVirtualAddressInformation = 0x006A,
    SystemLogicalProcessorAndGroupInformation = 0x006B,
    SystemProcessorCycleTimeInformation = 0x006C,
    SystemStoreInformation = 0x006D,
    SystemRegistryAppendString = 0x006E,
    SystemAitSamplingValue = 0x006F,
    SystemVhdBootInformation = 0x0070,
    SystemCpuQuotaInformation = 0x0071,
    SystemNativeBasicInformation = 0x0072,
    SystemErrorPortTimeouts = 0x0073,
    SystemLowPriorityIoInformation = 0x0074,
    SystemBootEntropyInformation = 0x0075,
    SystemVerifierCountersInformation = 0x0076,
    SystemPagedPoolInformationEx = 0x0077,
    SystemSystemPtesInformationEx = 0x0078,
    SystemNodeDistanceInformation = 0x0079,
    SystemAcpiAuditInformation = 0x007A,
    SystemBasicPerformanceInformation = 0x007B,
    SystemQueryPerformanceCounterInformation = 0x007C,
    SystemSessionBigPoolInformation = 0x007D,
    SystemBootGraphicsInformation = 0x007E,
    SystemScrubPhysicalMemoryInformation = 0x007F,
    SystemBadPageInformation = 0x0080,
    SystemProcessorProfileControlArea = 0x0081,
    SystemCombinePhysicalMemoryInformation = 0x0082,
    SystemEntropyInterruptTimingInformation = 0x0083,
    SystemConsoleInformation = 0x0084,
    SystemPlatformBinaryInformation = 0x0085,
    SystemThrottleNotificationInformation = 0x0086,
    SystemHypervisorProcessorCountInformation = 0x0087,
    SystemDeviceDataInformation = 0x0088,
    SystemDeviceDataEnumerationInformation = 0x0089,
    SystemMemoryTopologyInformation = 0x008A,
    SystemMemoryChannelInformation = 0x008B,
    SystemBootLogoInformation = 0x008C,
    SystemProcessorPerformanceInformationEx = 0x008D,
    SystemSpare0 = 0x008E,
    SystemSecureBootPolicyInformation = 0x008F,
    SystemPageFileInformationEx = 0x0090,
    SystemSecureBootInformation = 0x0091,
    SystemEntropyInterruptTimingRawInformation = 0x0092,
    SystemPortableWorkspaceEfiLauncherInformation = 0x0093,
    SystemFullProcessInformation = 0x0094,
    MaxSystemInfoClass = 0x0095

} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _LDR_DATA_TABLE_ENTRY64
{
    LIST_ENTRY  InLoadOrderModuleList;
    LIST_ENTRY  InMemoryOrderModuleList;
    LIST_ENTRY  InInitializationOrderModuleList;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union
    {
        LIST_ENTRY HashLinks;
        struct
        {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    };
    union
    {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    };
    PVOID EntryPointActivationContext;
    PVOID PatchInformation;
    LIST_ENTRY ForwarderLinks;
    LIST_ENTRY ServiceTagLinks;
    LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union {
        LIST_ENTRY32 HashLinks;
        struct {
            ULONG SectionPointer;
            ULONG CheckSum;
        };
    };
    union {
        struct {
            ULONG TimeDateStamp;
        };
        struct {
            ULONG LoadedImports;
        };
    };

    ULONG EntryPointActivationContext;
    ULONG PatchInformation;
    LIST_ENTRY32 ForwarderLinks;
    LIST_ENTRY32 ServiceTagLinks;
    LIST_ENTRY32 StaticLinks;

} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
    struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
    VOID* ExceptionTable;                                                   //0x10
    ULONG ExceptionTableSize;                                               //0x18
    VOID* GpValue;                                                          //0x20
    struct _NON_PAGED_DEBUG_INFO* NonPagedDebugInfo;                        //0x28
    VOID* DllBase;                                                          //0x30
    VOID* EntryPoint;                                                       //0x38
    ULONG SizeOfImage;                                                      //0x40
    struct _UNICODE_STRING FullDllName;                                     //0x48
    struct _UNICODE_STRING BaseDllName;                                     //0x58
    ULONG Flags;                                                            //0x68
    USHORT LoadCount;                                                       //0x6c
    union
    {
        USHORT SignatureLevel : 4;                                            //0x6e
        USHORT SignatureType : 3;                                             //0x6e
        USHORT Unused : 9;                                                    //0x6e
        USHORT EntireField;                                                 //0x6e
    } u1;                                                                   //0x6e
    VOID* SectionPointer;                                                   //0x70
    ULONG CheckSum;                                                         //0x78
    ULONG CoverageSectionSize;                                              //0x7c
    VOID* CoverageSection;                                                  //0x80
    VOID* LoadedImports;                                                    //0x88
    VOID* Spare;                                                            //0x90
    ULONG SizeOfImageNotRounded;                                            //0x98
    ULONG TimeDateStamp;                                                    //0x9c

} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

typedef struct _POOL_HEADER {
    union {
        struct {
            USHORT PreviousSize : 9;
            USHORT PoolIndex : 7;
            USHORT BlockSize : 9;
            USHORT PoolType : 7;
        };
        ULONG Ulong1;   // used for InterlockedCompareExchange required by Alpha
    };
#if defined (_WIN64)
    ULONG PoolTag;
#endif
    union {
        PEPROCESS ProcessBilled;
#if !defined (_WIN64)
        ULONG PoolTag;
#endif
        struct {
            USHORT AllocatorBackTraceIndex;
            USHORT PoolTagHash;
        };
    };
} POOL_HEADER, * PPOOL_HEADER;

struct _EX_PUSH_LOCK
{
    union
    {
        struct
        {
            ULONGLONG Locked : 1;                                             //0x0
            ULONGLONG Waiting : 1;                                            //0x0
            ULONGLONG Waking : 1;                                             //0x0
            ULONGLONG MultipleShared : 1;                                     //0x0
            ULONGLONG Shared : 60;                                            //0x0
        };
        ULONGLONG Value;                                                    //0x0
        VOID* Ptr;                                                          //0x0
    };
};

//0x40 bytes (sizeof)
typedef struct _OBJECT_CREATE_INFORMATION
{
    ULONG Attributes;                                                       //0x0
    VOID* RootDirectory;                                                    //0x8
    CHAR ProbeMode;                                                         //0x10
    ULONG PagedPoolCharge;                                                  //0x14
    ULONG NonPagedPoolCharge;                                               //0x18
    ULONG SecurityDescriptorCharge;                                         //0x1c
    VOID* SecurityDescriptor;                                               //0x20
    struct _SECURITY_QUALITY_OF_SERVICE* SecurityQos;                       //0x28
    struct _SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;           //0x30
} OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;


typedef struct _OBJECT_HEADER
{
    LONGLONG PointerCount;                                                  //0x0
    union
    {
        LONGLONG HandleCount;                                               //0x8
        VOID* NextToFree;                                                   //0x8
    };
    struct _EX_PUSH_LOCK Lock;                                              //0x10
    UCHAR TypeIndex;                                                        //0x18
    union
    {
        UCHAR TraceFlags;                                                   //0x19
        struct
        {
            UCHAR DbgRefTrace : 1;                                            //0x19
            UCHAR DbgTracePermanent : 1;                                      //0x19
        };
    };
    UCHAR InfoMask;                                                         //0x1a
    union
    {
        UCHAR Flags;                                                        //0x1b
        struct
        {
            UCHAR NewObject : 1;                                              //0x1b
            UCHAR KernelObject : 1;                                           //0x1b
            UCHAR KernelOnlyAccess : 1;                                       //0x1b
            UCHAR ExclusiveObject : 1;                                        //0x1b
            UCHAR PermanentObject : 1;                                        //0x1b
            UCHAR DefaultSecurityQuota : 1;                                   //0x1b
            UCHAR SingleHandleEntry : 1;                                      //0x1b
            UCHAR DeletedInline : 1;                                          //0x1b
        };
    };
    ULONG Reserved;                                                         //0x1c
    union
    {
        struct _OBJECT_CREATE_INFORMATION* ObjectCreateInfo;                //0x20
        VOID* QuotaBlockCharged;                                            //0x20
    };
    VOID* SecurityDescriptor;                                               //0x28
    struct _QUAD Body;                                                      //0x30
} OBJECT_HEADER, * POBJECT_HEADER;


typedef struct _MMVIEW_WIN7 // 0x30
{
    ULONGLONG Entry; // +0x0(0x8)
    ULONGLONG Writable; // +0x8(0x8)
    struct CONTROL_AREA* ControlArea; // +0x8(0x8)
    LIST_ENTRY ViewLinks; // +0x10(0x10)
    PVOID SessionViewVa; // +0x20(0x8)
    ULONG SessionId; // +0x28(0x4)

} MMVIEW_WIN7, * PMMVIEW_WIN7;

typedef struct _MMSESSION_WIN7 // 0x58
{
    KGUARDED_MUTEX SystemSpaceViewLock; // +0x0(0x38)
    KGUARDED_MUTEX* SystemSpaceViewLockPointer; // +0x38(0x8)
    MMVIEW_WIN7* SystemSpaceViewTable; // +0x40(0x8)
    ULONG SystemSpaceHashSize; // +0x48(0x4)
    ULONG SystemSpaceHashEntries; // +0x4c(0x4)
    ULONG SystemSpaceHashKey; // +0x50(0x4)
    ULONG BitmapFailures; // +0x54(0x4)

} MMSESSION_WIN7, * PMMSESSION_WIN7;


typedef struct _MMVIEW_WIN10
{
    RTL_BALANCED_NODE SectionNode;
    ULONG64 Unkown1;              // +0x18
    ULONG_PTR ViewSize;           // +0x20
    ULONG_PTR Unkown2;            // +0x28
    PVOID ControlArea;            // +0x30
    PVOID FileObject;             // +0x38
    ULONG_PTR Unknown3;           // +0x40
    ULONG_PTR Unknown4;           // +0x48
    PVOID SessionViewVa;          // +0x50
    ULONG Unknown5;
    ULONG Unknown6;

} MMVIEW_WIN10, * PMMVIEW_WIN10;

typedef struct _MMVIEW_WIN10_NEW
{
    RTL_BALANCED_NODE SectionNode;
    ULONG64 Unkown1;              // +0x18
    ULONG_PTR ViewSize;           // +0x20
    ULONG_PTR Unkown2;            // +0x28
    PVOID ControlArea;            // +0x30
    ULONG ControlAreaFlag;        // +0x38
    PVOID FileObject;             // +0x40
    ULONG_PTR Unknown3;           // +0x48
    ULONG_PTR Unknown4;           // +0x50
    PVOID SessionViewVa;          // +0x58
    ULONG Unknown5;
    ULONG Unknown6;

} MMVIEW_WIN10_NEW, * PMMVIEW_WIN10_NEW;

typedef struct _RTL_AVL_TREE
{
    PRTL_BALANCED_NODE Root; // +0x0(0x8)

} RTL_AVL_TREE, * PRTL_AVL_TREE;

typedef struct _MMSESSION_WIN10
{
    EX_PUSH_LOCK SystemSpaceViewLock;
    PEX_PUSH_LOCK SystemSpaceViewLockPointer;
    RTL_AVL_TREE ViewRoot;
    ULONG ViewCount;
    ULONG BitmapFailures;

}MMSESSION_WIN10, * PMMSESSION_WIN10;

typedef struct _MI_SYSTEM_VA_ASSIGNMENT
{
    VOID* BaseAddress;                                                      //0x0
    ULONGLONG NumberOfBytes;                                                //0x8
} MI_SYSTEM_VA_ASSIGNMENT, * PMI_SYSTEM_VA_ASSIGNMENT;

enum _MI_ASSIGNED_REGION_TYPES
{
    AssignedRegionNonPagedPool = 0,
    AssignedRegionPagedPool = 1,
    AssignedRegionSystemCache = 2,
    AssignedRegionSystemPtes = 3,
    AssignedRegionUltraZero = 4,
    AssignedRegionPfnDatabase = 5,
    AssignedRegionCfg = 6,
    AssignedRegionHyperSpace = 7,
    AssignedRegionKernelStacks = 8,
    AssignedRegionPageTables = 9,
    AssignedRegionSession = 10,
    AssignedRegionSecureNonPagedPool = 11,
    AssignedRegionSystemImages = 12,
    AssignedRegionMaximum = 13
};

#pragma warning(disable : 4214)
typedef struct _MMPTE_HARDWARE64
{
    ULONGLONG Valid : 1;
    ULONGLONG Dirty1 : 1;
    ULONGLONG Owner : 1;
    ULONGLONG WriteThrough : 1;
    ULONGLONG CacheDisable : 1;
    ULONGLONG Accessed : 1;
    ULONGLONG Dirty : 1;
    ULONGLONG LargePage : 1;
    ULONGLONG Global : 1;
    ULONGLONG CopyOnWrite : 1;
    ULONGLONG Unused : 1;
    ULONGLONG Write : 1;
    ULONGLONG PageFrameNumber : 36;
    ULONGLONG reserved1 : 4;
    ULONGLONG SoftwareWsIndex : 11;
    ULONGLONG NoExecute : 1;
} MMPTE_HARDWARE64, * PMMPTE_HARDWARE64;

typedef struct _MMPTE
{
    union
    {
        ULONG_PTR Long;
        MMPTE_HARDWARE64 Hard;
    } u;
} MMPTE;
typedef MMPTE* PMMPTE;

//
// This structure is used by the debugger for all targets
// It is the same size as DBGKD_DATA_HEADER on all systems
//
typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

    //
    // Link to other blocks
    //

    LIST_ENTRY64 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, * PDBGKD_DEBUG_DATA_HEADER64;


//
// This structure is the same size on all systems.  The only field
// which must be translated by the debugger is Header.List.
//

//
// DO NOT ADD OR REMOVE FIELDS FROM THE MIDDLE OF THIS STRUCTURE!!!
//
// If you remove a field, replace it with an "unused" placeholder.
// Do not reuse fields until there has been enough time for old debuggers
// and extensions to age out.
//
typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;

    // NT 5.1 Addition

    ULONG64   NtBuildLab;
    ULONG64   KiNormalSystemCall;

    // NT 5.0 hotfix addition

    ULONG64   KiProcessorBlock;
    ULONG64   MmUnloadedDrivers;
    ULONG64   MmLastUnloadedDriver;
    ULONG64   MmTriageActionTaken;
    ULONG64   MmSpecialPoolTag;
    ULONG64   KernelVerifier;
    ULONG64   MmVerifierData;
    ULONG64   MmAllocatedNonPagedPool;
    ULONG64   MmPeakCommitment;
    ULONG64   MmTotalCommitLimitMaximum;
    ULONG64   CmNtCSDVersion;

    // NT 5.1 Addition

    ULONG64   MmPhysicalMemoryBlock;
    ULONG64   MmSessionBase;
    ULONG64   MmSessionSize;
    ULONG64   MmSystemParentTablePage;

    // Server 2003 addition

    ULONG64   MmVirtualTranslationBase;

    USHORT    OffsetKThreadNextProcessor;
    USHORT    OffsetKThreadTeb;
    USHORT    OffsetKThreadKernelStack;
    USHORT    OffsetKThreadInitialStack;

    USHORT    OffsetKThreadApcProcess;
    USHORT    OffsetKThreadState;
    USHORT    OffsetKThreadBStore;
    USHORT    OffsetKThreadBStoreLimit;

    USHORT    SizeEProcess;
    USHORT    OffsetEprocessPeb;
    USHORT    OffsetEprocessParentCID;
    USHORT    OffsetEprocessDirectoryTableBase;

    USHORT    SizePrcb;
    USHORT    OffsetPrcbDpcRoutine;
    USHORT    OffsetPrcbCurrentThread;
    USHORT    OffsetPrcbMhz;

    USHORT    OffsetPrcbCpuType;
    USHORT    OffsetPrcbVendorString;
    USHORT    OffsetPrcbProcStateContext;
    USHORT    OffsetPrcbNumber;

    USHORT    SizeEThread;

    ULONG64   KdPrintCircularBufferPtr;
    ULONG64   KdPrintBufferSize;

    ULONG64   KeLoaderBlock;

    USHORT    SizePcr;
    USHORT    OffsetPcrSelfPcr;
    USHORT    OffsetPcrCurrentPrcb;
    USHORT    OffsetPcrContainedPrcb;

    USHORT    OffsetPcrInitialBStore;
    USHORT    OffsetPcrBStoreLimit;
    USHORT    OffsetPcrInitialStack;
    USHORT    OffsetPcrStackLimit;

    USHORT    OffsetPrcbPcrPage;
    USHORT    OffsetPrcbProcStateSpecialReg;
    USHORT    GdtR0Code;
    USHORT    GdtR0Data;

    USHORT    GdtR0Pcr;
    USHORT    GdtR3Code;
    USHORT    GdtR3Data;
    USHORT    GdtR3Teb;

    USHORT    GdtLdt;
    USHORT    GdtTss;
    USHORT    Gdt64R3CmCode;
    USHORT    Gdt64R3CmTeb;

    ULONG64   IopNumTriageDumpDataBlocks;
    ULONG64   IopTriageDumpDataBlocks;

    // Longhorn addition

    ULONG64   VfCrashDataBlock;
    ULONG64   MmBadPagesDetected;
    ULONG64   MmZeroedPageSingleBitErrorsDetected;

    // Windows 7 addition

    ULONG64   EtwpDebuggerData;
    USHORT    OffsetPrcbContext;

    // Windows 8 addition

    USHORT    OffsetPrcbMaxBreakpoints;
    USHORT    OffsetPrcbMaxWatchpoints;

    ULONG     OffsetKThreadStackLimit;
    ULONG     OffsetKThreadStackBase;
    ULONG     OffsetKThreadQueueListEntry;
    ULONG     OffsetEThreadIrpList;

    USHORT    OffsetPrcbIdleThread;
    USHORT    OffsetPrcbNormalDpcState;
    USHORT    OffsetPrcbDpcStack;
    USHORT    OffsetPrcbIsrStack;

    USHORT    SizeKDPC_STACK_FRAME;

    // Windows 8.1 Addition

    USHORT    OffsetKPriQueueThreadListHead;
    USHORT    OffsetKThreadWaitReason;

    // Windows 10 RS1 Addition

    USHORT    Padding;
    ULONG64   PteBase;

    // Windows 10 RS5 Addition

    ULONG64 RetpolineStubFunctionTable;
    ULONG RetpolineStubFunctionTableSize;
    ULONG RetpolineStubOffset;
    ULONG RetpolineStubSize;

} KDDEBUGGER_DATA64, * PKDDEBUGGER_DATA64;


typedef struct _DUMP_HEADER
{
    ULONG Signature;
    ULONG ValidDump;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG_PTR DirectoryTableBase;
    ULONG_PTR PfnDataBase;
    PLIST_ENTRY PsLoadedModuleList;
    PLIST_ENTRY PsActiveProcessHead;
    ULONG MachineImageType;
    ULONG NumberProcessors;
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParameter1;
    ULONG_PTR BugCheckParameter2;
    ULONG_PTR BugCheckParameter3;
    ULONG_PTR BugCheckParameter4;
    CHAR VersionUser[32];
    struct _KDDEBUGGER_DATA64* KdDebuggerDataBlock;
} DUMP_HEADER, * PDUMP_HEADER;

//0x4 bytes (sizeof)
typedef struct _MMSECTION_FLAGS
{
    ULONG BeingDeleted : 1;                                                   //0x0
    ULONG BeingCreated : 1;                                                   //0x0
    ULONG BeingPurged : 1;                                                    //0x0
    ULONG NoModifiedWriting : 1;                                              //0x0
    ULONG FailAllIo : 1;                                                      //0x0
    ULONG Image : 1;                                                          //0x0
    ULONG Based : 1;                                                          //0x0
    ULONG File : 1;                                                           //0x0
    ULONG AttemptingDelete : 1;                                               //0x0
    ULONG PrefetchCreated : 1;                                                //0x0
    ULONG PhysicalMemory : 1;                                                 //0x0
    ULONG ImageControlAreaOnRemovableMedia : 1;                               //0x0
    ULONG Reserve : 1;                                                        //0x0
    ULONG Commit : 1;                                                         //0x0
    ULONG NoChange : 1;                                                       //0x0
    ULONG WasPurged : 1;                                                      //0x0
    ULONG UserReference : 1;                                                  //0x0
    ULONG GlobalMemory : 1;                                                   //0x0
    ULONG DeleteOnClose : 1;                                                  //0x0
    ULONG FilePointerNull : 1;                                                //0x0
    ULONG PreferredNode : 6;                                                  //0x0
    ULONG GlobalOnlyPerSession : 1;                                           //0x0
    ULONG UserWritable : 1;                                                   //0x0
    ULONG SystemVaAllocated : 1;                                              //0x0
    ULONG PreferredFsCompressionBoundary : 1;                                 //0x0
    ULONG UsingFileExtents : 1;                                               //0x0
    ULONG PageSize64K : 1;                                                    //0x0
} MMSECTION_FLAGS, *PMMSECTION_FLAGS;

struct _MMSECTION_FLAGS2
{
    USHORT PartitionId : 10;                                                  //0x0
    UCHAR NoCrossPartitionAccess : 1;                                         //0x2
    UCHAR SubsectionCrossPartitionReferenceOverflow : 1;                      //0x2
};

//0x8 bytes (sizeof)
struct _EX_FAST_REF
{
    union
    {
        VOID* Object;                                                       //0x0
        ULONGLONG RefCnt : 4;                                                 //0x0
        ULONGLONG Value;                                                    //0x0
    };
};

//0x28 bytes (sizeof)
struct _MI_CONTROL_AREA_WAIT_BLOCK
{
    struct _MI_CONTROL_AREA_WAIT_BLOCK* Next;                               //0x0
    ULONG WaitReason;                                                       //0x8
    ULONG WaitResponse;                                                     //0xc
    struct _KGATE Gate;                                                     //0x10
};

//0x4 bytes (sizeof)
struct _SEGMENT_FLAGS
{
    union
    {
        struct
        {
            USHORT TotalNumberOfPtes4132 : 10;                                //0x0
            USHORT Spare0 : 1;                                                //0x0
            USHORT SessionDriverProtos : 1;                                   //0x0
            USHORT LargePages : 1;                                            //0x0
            USHORT DebugSymbolsLoaded : 1;                                    //0x0
            USHORT WriteCombined : 1;                                         //0x0
            USHORT NoCache : 1;                                               //0x0
        };
        USHORT Short0;                                                      //0x0
    };
    union
    {
        struct
        {
            UCHAR ImageCetShadowStacksReady : 1;                              //0x2
            UCHAR DefaultProtectionMask : 5;                                  //0x2
            UCHAR Binary32 : 1;                                               //0x2
            UCHAR ContainsDebug : 1;                                          //0x2
        };
        UCHAR UChar1;                                                       //0x2
    };
    union
    {
        struct
        {
            UCHAR ForceCollision : 1;                                         //0x3
            UCHAR ImageSigningType : 3;                                       //0x3
            UCHAR ImageSigningLevel : 4;                                      //0x3
        };
        UCHAR UChar2;                                                       //0x3
    };
};

//0x10 bytes (sizeof)
typedef struct _MMEXTEND_INFO
{
    ULONGLONG CommittedSize;                                                //0x0
    ULONG ReferenceCount;                                                   //0x8
} MMEXTEND_INFO, *PMMEXTEND_INFO;

//0x40 bytes (sizeof)
typedef struct _SECTION_IMAGE_INFORMATION
{
    VOID* TransferAddress;                                                  //0x0
    ULONG ZeroBits;                                                         //0x8
    ULONGLONG MaximumStackSize;                                             //0x10
    ULONGLONG CommittedStackSize;                                           //0x18
    ULONG SubSystemType;                                                    //0x20
    union
    {
        struct
        {
            USHORT SubSystemMinorVersion;                                   //0x24
            USHORT SubSystemMajorVersion;                                   //0x26
        };
        ULONG SubSystemVersion;                                             //0x24
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;                             //0x28
            USHORT MinorOperatingSystemVersion;                             //0x2a
        };
        ULONG OperatingSystemVersion;                                       //0x28
    };
    USHORT ImageCharacteristics;                                            //0x2c
    USHORT DllCharacteristics;                                              //0x2e
    USHORT Machine;                                                         //0x30
    UCHAR ImageContainsCode;                                                //0x32
    union
    {
        UCHAR ImageFlags;                                                   //0x33
        struct
        {
            UCHAR ComPlusNativeReady : 1;                                     //0x33
            UCHAR ComPlusILOnly : 1;                                          //0x33
            UCHAR ImageDynamicallyRelocated : 1;                              //0x33
            UCHAR ImageMappedFlat : 1;                                        //0x33
            UCHAR BaseBelow4gb : 1;                                           //0x33
            UCHAR ComPlusPrefer32bit : 1;                                     //0x33
            UCHAR Reserved : 2;                                               //0x33
        };
    };
    ULONG LoaderFlags;                                                      //0x34
    ULONG ImageFileSize;                                                    //0x38
    ULONG CheckSum;                                                         //0x3c
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

//0xc bytes (sizeof)
typedef struct _MI_EXTRA_IMAGE_INFORMATION
{
    ULONG SizeOfHeaders;                                                    //0x0
    ULONG SizeOfImage;                                                      //0x4
    ULONG TimeDateStamp;                                                    //0x8
} MI_EXTRA_IMAGE_INFORMATION, *PMI_EXTRA_IMAGE_INFORMATION;

//0x50 bytes (sizeof)
typedef struct _MI_SECTION_IMAGE_INFORMATION
{
    struct _SECTION_IMAGE_INFORMATION ExportedImageInformation;             //0x0
    struct _MI_EXTRA_IMAGE_INFORMATION InternalImageInformation;            //0x40
} MI_SECTION_IMAGE_INFORMATION, *PMI_SECTION_IMAGE_INFORMATION;

//0x48 bytes (sizeof)
typedef struct _SEGMENT
{
    struct _CONTROL_AREA* ControlArea;                                      //0x0
    ULONG TotalNumberOfPtes;                                                //0x8
    struct _SEGMENT_FLAGS SegmentFlags;                                     //0xc
    ULONGLONG NumberOfCommittedPages;                                       //0x10
    ULONGLONG SizeOfSegment;                                                //0x18
    union
    {
        struct _MMEXTEND_INFO* ExtendInfo;                                  //0x20
        VOID* BasedAddress;                                                 //0x20
    };
    struct _EX_PUSH_LOCK SegmentLock;                                       //0x28
    union
    {
        ULONGLONG ImageCommitment;                                          //0x30
        ULONG CreatingProcessId;                                            //0x30
    } u1;                                                                   //0x30
    union
    {
        struct _MI_SECTION_IMAGE_INFORMATION* ImageInformation;             //0x38
        VOID* FirstMappedVa;                                                //0x38
    } u2;                                                                   //0x38
    struct _MMPTE* PrototypePte;                                            //0x40
} SEGMENT, *PSEGMENT;

//0x20 bytes (sizeof)
typedef struct _MI_PROTOTYPE_PTES_NODE
{
    struct _RTL_BALANCED_NODE Node;                                         //0x0
    union
    {
        struct
        {
            ULONGLONG AllocationType : 3;                                     //0x18
            ULONGLONG Inserted : 1;                                           //0x18
        } e1;                                                               //0x18
        struct
        {
            ULONGLONG PrototypePtesFlags;                                   //0x18
        } e2;                                                               //0x18
    } u1;                                                                   //0x18
} MI_PROTOTYPE_PTES_NODE, *PMI_PROTOTYPE_PTES_NODE;

//0x8 bytes (sizeof)
typedef struct _IMAGE_SECURITY_CONTEXT
{
    union
    {
        VOID* PageHashes;                                                   //0x0
        ULONGLONG Value;                                                    //0x0
        struct
        {
            ULONGLONG SecurityBeingCreated : 2;                               //0x0
            ULONGLONG SecurityMandatory : 1;                                  //0x0
            ULONGLONG PageHashPointer : 61;                                   //0x0
        };
    };
} IMAGE_SECURITY_CONTEXT, *PIMAGE_SECURITY_CONTEXT;

//0x40 bytes (sizeof)
typedef struct _MI_IMAGE_SECURITY_REFERENCE
{
    struct _MI_PROTOTYPE_PTES_NODE ProtosNode;                              //0x0
    VOID* DynamicRelocations;                                               //0x20
    struct _IMAGE_SECURITY_CONTEXT SecurityContext;                         //0x28
    union
    {
        VOID* ImageFileExtents;                                             //0x30
        ULONGLONG ImageFileExtentsUlongPtr;                                 //0x30
        ULONGLONG FilesystemWantsRva : 1;                                     //0x30
        ULONGLONG Spare : 3;                                                  //0x30
    } u1;                                                                   //0x30
    ULONGLONG StrongImageReference;                                         //0x38
} MI_IMAGE_SECURITY_REFERENCE, *PMI_IMAGE_SECURITY_REFERENCE;

typedef struct _CONTROL_AREA
{
    struct _SEGMENT* Segment;                                               //0x0
    union
    {
        struct _LIST_ENTRY ListHead;                                        //0x8
        VOID* AweContext;                                                   //0x8
    };
    ULONGLONG NumberOfSectionReferences;                                    //0x18
    ULONGLONG NumberOfPfnReferences;                                        //0x20
    ULONGLONG NumberOfMappedViews;                                          //0x28
    ULONGLONG NumberOfUserReferences;                                       //0x30
    union
    {
        ULONG LongFlags;                                                    //0x38
        struct _MMSECTION_FLAGS Flags;                                      //0x38
    } u;                                                                    //0x38
    union
    {
        ULONG LongFlags;                                                    //0x3c
        struct _MMSECTION_FLAGS2 Flags;                                     //0x3c
    } u1;                                                                   //0x3c
    struct _EX_FAST_REF FilePointer;                                        //0x40
    volatile LONG ControlAreaLock;                                          //0x48
    ULONG ModifiedWriteCount;                                               //0x4c
    struct _MI_CONTROL_AREA_WAIT_BLOCK* WaitList;                           //0x50
    union
    {
        struct
        {
            union
            {
                ULONG NumberOfSystemCacheViews;                             //0x58
                ULONG ImageRelocationStartBit;                              //0x58
            };
            union
            {
                volatile LONG WritableUserReferences;                       //0x5c
                struct
                {
                    ULONG ImageRelocationSizeIn64k : 16;                      //0x5c
                    ULONG SystemImage : 1;                                    //0x5c
                    ULONG CantMove : 1;                                       //0x5c
                    ULONG StrongCode : 2;                                     //0x5c
                    ULONG BitMap : 2;                                         //0x5c
                    ULONG ImageActive : 1;                                    //0x5c
                    ULONG ImageBaseOkToReuse : 1;                             //0x5c
                };
            };
            union
            {
                ULONG FlushInProgressCount;                                 //0x60
                ULONG NumberOfSubsections;                                  //0x60
                struct _MI_IMAGE_SECURITY_REFERENCE* SeImageStub;           //0x60
            };
        } e2;                                                               //0x58
    } u2;                                                                   //0x58
    struct _EX_PUSH_LOCK FileObjectLock;                                    //0x68
    volatile ULONGLONG LockedPages;                                         //0x70
    union
    {
        ULONGLONG IoAttributionContext : 61;                                  //0x78
        ULONGLONG Spare : 3;                                                  //0x78
        ULONGLONG ImageCrossPartitionCharge;                                //0x78
        ULONGLONG CommittedPageCount : 36;                                    //0x78
    } u3;                                                                   //0x78
} CONTROL_AREA, * PCONTROL_AREA;

// Win10
typedef struct _SECTION
{
    struct _RTL_BALANCED_NODE SectionNode;                                  //0x0
    ULONGLONG StartingVpn;                                                  //0x18
    ULONGLONG EndingVpn;                                                    //0x20
    union
    {
        struct _CONTROL_AREA* ControlArea;                                  //0x28
        struct _FILE_OBJECT* FileObject;                                    //0x28
        ULONGLONG RemoteImageFileObject : 1;                                  //0x28
        ULONGLONG RemoteDataFileObject : 1;                                   //0x28
    } u1;                                                                   //0x28
    ULONGLONG SizeOfSection;                                                //0x30
    union
    {
        ULONG LongFlags;                                                    //0x38
        struct _MMSECTION_FLAGS Flags;                                      //0x38
    } u;                                                                    //0x38
    ULONG InitialPageProtection : 12;                                         //0x3c
    ULONG SessionId : 19;                                                     //0x3c
    ULONG NoValidationNeeded : 1;                                             //0x3c

} SECTION, * PSECTION;


//0x4 bytes (sizeof)
typedef struct _MMSUBSECTION_FLAGS
{
    USHORT SubsectionAccessed : 1;                                            //0x0
    USHORT Protection : 5;                                                    //0x0
    USHORT StartingSector4132 : 10;                                           //0x0
    USHORT SubsectionStatic : 1;                                              //0x2
    USHORT GlobalMemory : 1;                                                  //0x2
    USHORT DirtyPages : 1;                                                    //0x2
    USHORT OnDereferenceList : 1;                                             //0x2
    USHORT SectorEndOffset : 12;                                              //0x2
} MMSUBSECTION_FLAGS, *PMMSUBSECTION_FLAGS;

//0x38 bytes (sizeof)
typedef struct _SUBSECTION
{
    struct _CONTROL_AREA* ControlArea;                                      //0x0
    struct _MMPTE* SubsectionBase;                                          //0x8
    struct _SUBSECTION* NextSubsection;                                     //0x10
    ULONG PtesInSubsection;                                                 //0x18
    union
    {
        ULONG UnusedPtes;                                                   //0x20
        struct _RTL_AVL_TREE GlobalPerSessionHead;                          //0x20
    };
    union
    {
        ULONG LongFlags;                                                    //0x28
        struct _MMSUBSECTION_FLAGS SubsectionFlags;                         //0x28
    } u;                                                                    //0x28
    ULONG StartingSector;                                                   //0x2c
    ULONG NumberOfFullSectors;                                              //0x30
} SUBSECTION, *PSUBSECTION;

//0x40 bytes (sizeof)
typedef struct _SEGMENT_OBJECT
{
    VOID* BaseAddress;                                                      //0x0
    ULONG TotalNumberOfPtes;                                                //0x8
    union _LARGE_INTEGER SizeOfSegment;                                     //0x10
    ULONG NonExtendedPtes;                                                  //0x18
    ULONG ImageCommitment;                                                  //0x1c
    struct _CONTROL_AREA* ControlArea;                                      //0x20
    struct _SUBSECTION* Subsection;                                         //0x28
    struct _MMSECTION_FLAGS* MmSectionFlags;                                //0x30
    struct _MMSUBSECTION_FLAGS* MmSubSectionFlags;                          //0x38
} SEGMENT_OBJECT, *PSEGMENT_OBJECT;

//0x30 bytes (sizeof)
typedef struct _SECTION_OBJECT
{
    VOID* StartingVa;                                                       //0x0
    VOID* EndingVa;                                                         //0x8
    VOID* Parent;                                                           //0x10
    VOID* LeftChild;                                                        //0x18
    VOID* RightChild;                                                       //0x20
    struct _SEGMENT* Segment;                                               //0x28
} SECTION_OBJECT, *PSECTION_OBJECT;

```

`MemScanner/Private.c`:

```c
#include "Private.h"
#include "NativeStruct.h"
#include "import.h"



NTSYSAPI
ULONG
NTAPI
KeCapturePersistentThreadState(
    IN PCONTEXT Context,
    IN PKTHREAD Thread,
    IN ULONG BugCheckCode,
    IN ULONG BugCheckParameter1,
    IN ULONG BugCheckParameter2,
    IN ULONG BugCheckParameter3,
    IN ULONG BugCheckParameter4,
    OUT PVOID VirtualAddress
);

//--------------------------------------------------------------------------------------------------------------
extern DYNAMIC_DATA g_dynData;
//--------------------------------------------------------------------------------------------------------------
PLIST_ENTRY        PsLoadedModuleList;
PVOID              g_KernelBase          = NULL;
ULONG              g_KernelSize          = 0;
KDDEBUGGER_DATA64  g_KdBlock             = { 0 };

//--------------------------------------------------------------------------------------------------------------
VOID InitializeDebuggerBlock()
{
    CONTEXT context = { 0 };
    context.ContextFlags = CONTEXT_FULL;
    RtlCaptureContext(&context);

    PDUMP_HEADER dumpHeader = (PDUMP_HEADER)ExAllocatePoolWithTag(NonPagedPool, DUMP_BLOCK_SIZE, MMS_POOL_TAG);
    if (dumpHeader)
    {
        KeCapturePersistentThreadState(&context, NULL, 0, 0, 0, 0, 0, dumpHeader);
        RtlCopyMemory(&g_KdBlock, (PUCHAR)dumpHeader + KDDEBUGGER_DATA_OFFSET, sizeof(g_KdBlock));

        ExFreePool(dumpHeader);
    }
}
//--------------------------------------------------------------------------------------------------------------
PVOID GetKernelBase(OUT PULONG pSize)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG bytes = 0;
    PSYSTEM_MODULE_INFORMATION pMods = NULL;
    PVOID checkPtr = NULL;
    UNICODE_STRING routineName;

    // Already found
    if (g_KernelBase != NULL)
    {
        if (pSize)
        {
            *pSize = g_KernelSize;
        }

        return g_KernelBase;
    }

    RtlInitUnicodeString(&routineName, L"NtOpenFile");
    checkPtr = MmGetSystemRoutineAddress(&routineName);
    if (checkPtr == NULL)
    {
        return NULL;
    }

    // Protect from UserMode AV
    status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
    if (bytes == 0)
    {
        DbgPrint("MemScanner: %s: Invalid SystemModuleInformation size\n", __FUNCTION__);
        return NULL;
    }

    pMods = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, bytes, MMS_POOL_TAG);
    if (!pMods)
    {
        return NULL;
    }

    RtlZeroMemory(pMods, bytes);

    status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

    if (NT_SUCCESS(status))
    {
        PSYSTEM_MODULE_ENTRY pMod = pMods->Modules;

        for (ULONG i = 0; i < pMods->Count; i++)
        {
            // System routine is inside module
            if (checkPtr >= pMod[i].Base &&
                checkPtr < (PVOID)((PUCHAR)pMod[i].Base + pMod[i].Size))
            {
                g_KernelBase = pMod[i].Base;
                g_KernelSize = pMod[i].Size;
                if (pSize)
                {
                    *pSize = g_KernelSize;
                }

                break;
            }
        }
    }

    if (pMods)
    {
        ExFreePoolWithTag(pMods, MMS_POOL_TAG);
        pMods = NULL;
    }

    return g_KernelBase;
}
//--------------------------------------------------------------------------------------------------------------
NTSTATUS MmsInitLdrData(IN PLDR_DATA_TABLE_ENTRY pThisModule)
{
    PVOID kernelBase = GetKernelBase(NULL);
    if (kernelBase == NULL)
    {
        DbgPrint("MemScanner: %s: Failed to retrieve Kernel base address. Aborting\n", __FUNCTION__);
        return STATUS_NOT_FOUND;
    }

    for (PLIST_ENTRY pListEntry = pThisModule->InLoadOrderModuleList.Flink; pListEntry != &pThisModule->InLoadOrderModuleList; pListEntry = pListEntry->Flink)
    {
        PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
        if (kernelBase == pEntry->DllBase)
        {
            if ((PVOID)pListEntry->Blink >= pEntry->DllBase && (PUCHAR)pListEntry->Blink < (PUCHAR)pEntry->DllBase + pEntry->SizeOfImage)
            {
                PsLoadedModuleList = pListEntry->Blink;
                break;
            }
        }
    }

    if (!PsLoadedModuleList)
    {
        DbgPrint("MemScanner: %s: Failed to retrieve PsLoadedModuleList address. Aborting\n", __FUNCTION__);
        return STATUS_NOT_FOUND;
    }

    return STATUS_SUCCESS;
}
//--------------------------------------------------------------------------------------------------------------
```

`MemScanner/Private.h`:

```h
#pragma once

#include <ntifs.h>
#include "NativeStruct.h"


#ifndef _WIN64
#define DUMP_BLOCK_SIZE        0x20000
#else
#define DUMP_BLOCK_SIZE        0x40000
#endif

#ifndef _WIN64
#define KDDEBUGGER_DATA_OFFSET 0x1068
#else
#define KDDEBUGGER_DATA_OFFSET 0x2080
#endif

#define MMS_POOL_TAG           'cSmM'

#define PHYSICAL_ADDRESS_BITS  40


//
// PTE protection values
//
#define MM_ZERO_ACCESS            0
#define MM_READONLY               1
#define MM_EXECUTE                2
#define MM_EXECUTE_READ           3
#define MM_READWRITE              4
#define MM_WRITECOPY              5
#define MM_EXECUTE_READWRITE      6
#define MM_EXECUTE_WRITECOPY      7

#define MM_PTE_VALID_MASK         0x1
#define MM_PTE_WRITE_MASK         0x800
#define MM_PTE_OWNER_MASK         0x4
#define MM_PTE_WRITE_THROUGH_MASK 0x8
#define MM_PTE_CACHE_DISABLE_MASK 0x10
#define MM_PTE_ACCESS_MASK        0x20
#define MM_PTE_DIRTY_MASK         0x42
#define MM_PTE_LARGE_PAGE_MASK    0x80
#define MM_PTE_GLOBAL_MASK        0x100
#define MM_PTE_COPY_ON_WRITE_MASK 0x200
#define MM_PTE_PROTOTYPE_MASK     0x400
#define MM_PTE_TRANSITION_MASK    0x800


#define MI_SYSTEM_RANGE_START (ULONG_PTR)(0xFFFF080000000000) // start of system space

#define KI_USER_SHARED_DATA 0xFFFFF78000000000UI64

#define SharedUserData ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)

#ifndef PTE_SHIFT
#define PTE_SHIFT 3
#endif
#ifndef PTI_SHIFT
#define PTI_SHIFT 12
#endif
#ifndef PDI_SHIFT
#define PDI_SHIFT 21
#endif
#ifndef PPI_SHIFT
#define PPI_SHIFT 30
#endif
#ifndef PXI_SHIFT
#define PXI_SHIFT 39
#endif

#ifndef PXE_BASE
#define PXE_BASE    0xFFFFF6FB7DBED000UI64
#endif
#ifndef PXE_SELFMAP
#define PXE_SELFMAP 0xFFFFF6FB7DBEDF68UI64
#endif
#ifndef PPE_BASE
#define PPE_BASE    0xFFFFF6FB7DA00000UI64
#endif
#ifndef PDE_BASE
#define PDE_BASE    0xFFFFF6FB40000000UI64
#endif
#ifndef PTE_BASE
#define PTE_BASE    0xFFFFF68000000000UI64
#endif

#define VIRTUAL_ADDRESS_BITS 48
#define VIRTUAL_ADDRESS_MASK ((((ULONG_PTR)1) << VIRTUAL_ADDRESS_BITS) - 1)

#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PXE_PER_PAGE 512

#define PPI_MASK (PPE_PER_PAGE - 1)
#define PXI_MASK (PXE_PER_PAGE - 1)

#define MiGetPxeOffset(va) \
    ((ULONG)(((ULONG_PTR)(va) >> PXI_SHIFT) & PXI_MASK))

#define MiGetPxeAddress(va)   \
    ((PMMPTE)PXE_BASE + MiGetPxeOffset(va))

#define MiGetPpeAddress(va)   \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PPI_SHIFT) << PTE_SHIFT) + PPE_BASE))

#define MiGetPdeAddress(va) \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PDI_SHIFT) << PTE_SHIFT) + PDE_BASE))

#define MiGetPteAddress(va) \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PTI_SHIFT) << PTE_SHIFT) + PTE_BASE))

#define VA_SHIFT (63 - 47)              // address sign extend shift count

#define MiGetVirtualAddressMappedByPte(PTE) \
    ((PVOID)((LONG_PTR)(((LONG_PTR)(PTE) - PTE_BASE) << (PAGE_SHIFT + VA_SHIFT - PTE_SHIFT)) >> VA_SHIFT))

#define MI_IS_PHYSICAL_ADDRESS(Va) \
     ((MiGetPxeAddress(Va)->u.Hard.Valid == 1) && \
     (MiGetPpeAddress(Va)->u.Hard.Valid == 1) && \
     ((MiGetPdeAddress(Va)->u.Long & 0x81) == 0x81) || (MiGetPteAddress(Va)->u.Hard.Valid == 1))



typedef enum _WinVer
{
    WINVER_7       = 0x0610,
    WINVER_7_SP1   = 0x0611,
    WINVER_8       = 0x0620,
    WINVER_81      = 0x0630,
    WINVER_10      = 0x0A00,
    WINVER_10_TH1  = 0x0A01, //
    WINVER_10_TH2  = 0x0A02,
    WINVER_10_RS1  = 0x0A03, // Anniversary update
    WINVER_10_RS2  = 0x0A04, // Creators update
    WINVER_10_RS3  = 0x0A05, // Fall creators update
    WINVER_10_RS4  = 0x0A06, // Spring creators update
    WINVER_10_RS5  = 0x0A07, // October 2018 update
    WINVER_10_19H1 = 0x0A08, // May 2019 update 19H1
    WINVER_10_19H2 = 0x0A09, // November 2019 update 19H2
    WINVER_10_20H1 = 0x0A0A, // April 2020 update 20H1

} WinVer;

typedef struct _DYNAMIC_DATA
{
    WinVer ver;            // OS version
    ULONG  buildNo;        // OS build revision

    PVOID  MmPteSpaceStart;
    PVOID  MmPteSpacecEnd;

    PVOID  MmHyperSpaceStart;
    PVOID  MmHyperSpaceEnd;

    PVOID  MmSharedSystemPageStart;
    PVOID  MmSharedSystemPageEnd;

    PVOID  MmSystemCacheWorkingSetStart;
    PVOID  MmSystemCacheWorkingSetEnd;

    PVOID  MmSystemPtesStart;
    PVOID  MmSystemPtesEnd;

    PVOID  MmDriverImageStart;
    PVOID  MmDriverImageEnd;

    PVOID  MmPagedPoolStart;
    PVOID  MmPagedPoolEnd;

    PVOID  MmNonpagedPoolStart;
    PVOID  MmNonpagedPoolEnd;

    PVOID  MmSessionSpaceStart;
    PVOID  MmSessionSpaceEnd;

    PVOID  MmDynamicVASpaceStart;   // MiVaSystemCache/MiVaSpecialPoolPaged/MiVaSpecialPoolNonPaged
    PVOID  MmDynamicVASpaceEnd;

    PVOID  MmSystemCacheStart;
    PVOID  MmSystemCacheEnd;

    PVOID  MmSpecialPoolStart;
    PVOID  MmSpecialPoolEnd;

    PVOID  MmPfnDatabaseStart;
    PVOID  MmPfnDatabaseEnd;

    PVOID  DYN_PDE_BASE;   // Win10 AU+ relocated PDE base VA
    PVOID  DYN_PTE_BASE;   // Win10 AU+ relocated PTE base VA

} DYNAMIC_DATA, * PDYNAMIC_DATA;

PVOID    GetKernelBase(OUT PULONG pSize);
VOID     InitializeDebuggerBlock();
NTSTATUS MmsInitLdrData(IN PLDR_DATA_TABLE_ENTRY pThisModule);

extern KDDEBUGGER_DATA64 g_KdBlock;
```

`MemScanner/ProcessScanner.h`:

```h
#pragma once

#include <ntifs.h>

VOID ScanSection();
```

`MemScanner/SectionScanner.c`:

```c
#include "SectionScanner.h"
#include "Private.h"
#include "Utils.h"

//----------------------------------------------------------------------------------------------
extern POBJECT_TYPE*  MmSectionObjectType;
extern DYNAMIC_DATA   g_dynData;
//----------------------------------------------------------------------------------------------
VOID ScanImageFileObjectBySectionObjectMemory_Win7AndLater(PVOID lpStartAddr, SIZE_T ScanSize)
{
    SIZE_T                   ulSize         = 0;
    ULONG_PTR                lpSearchAddr   = 0;
    ULONG_PTR                lpEndAddr      = 0;
    ULONG                    ulEntrySize    = 0;
    ULONG                    ulCurrentSize  = 0;
    ULONG_PTR                pSectionObject = 0;
    NTSTATUS                 status         = STATUS_SUCCESS;

    lpSearchAddr = (ULONG_PTR)lpStartAddr;
    lpEndAddr    = (ULONG_PTR)lpStartAddr + ScanSize - sizeof(SECTION_OBJECT);

    KdPrint(("[%s] lpSearchAddr:%p lpEndAddr:%p\n", __FUNCTION__, lpSearchAddr, lpEndAddr));

    while (TRUE)
    {
        if (lpSearchAddr + PAGE_SIZE > lpEndAddr)
        {
            ulEntrySize = (ULONG)(lpEndAddr - lpSearchAddr);
        }
        else
        {
            ulEntrySize = PAGE_SIZE;
        }

        if (!MmsIsAddressValidLength((PVOID)lpSearchAddr, ulEntrySize))
        {
            goto NextLoop;
        }

        pSectionObject = lpSearchAddr;

        ulCurrentSize  = 0;
        ulEntrySize   -= sizeof(SECTION_OBJECT);

        while (ulCurrentSize < ulEntrySize)
        {
            PSECTION_OBJECT pSection = (PSECTION_OBJECT)pSectionObject;
            if (MmsIsRealSectionObject(pSection))
            {
                PCONTROL_AREA ControlArea = pSection->Segment->ControlArea;
                if (ControlArea->u.Flags.File && ControlArea->u.Flags.Image)
                {
                    char          szName[128] = { 0 };
                    PFILE_OBJECT  FileObject = (PFILE_OBJECT)((ULONG_PTR)ControlArea->FilePointer.Value & ~0xF);

                    if (MmsIsRealFileObject(FileObject))
                    {
                        if (MmsGetObjectName(FileObject, szName, 128))
                        {
                            KdPrint(("[%s] SectionObj:%p FileObj:%p FileName:%s\n", __FUNCTION__, pSection, FileObject, szName));
                        }
                    }
                }

                ulCurrentSize  += sizeof(SECTION_OBJECT);
                pSectionObject += sizeof(SECTION_OBJECT);
            }
            else
            {
                ulCurrentSize  += sizeof(ULONG_PTR);
                pSectionObject += sizeof(ULONG_PTR);
            }
        }

    NextLoop:
        lpSearchAddr += PAGE_SIZE;
        if (lpSearchAddr >= lpEndAddr)
        {
            break;
        }
    }
}
//----------------------------------------------------------------------------------------------
VOID ScanImageFileObjectBySectionObjectMemory_Win10(PVOID lpStartAddr, SIZE_T ScanSize)
{
    SIZE_T                   ulSize         = 0;
    ULONG_PTR                lpSearchAddr   = 0;
    ULONG_PTR                lpEndAddr      = 0;
    ULONG                    ulEntrySize    = 0;
    ULONG                    ulCurrentSize  = 0;
    ULONG_PTR                pSectionObject = 0;
    NTSTATUS                 status         = STATUS_SUCCESS;


    lpSearchAddr = (ULONG_PTR)lpStartAddr;
    lpEndAddr    = (ULONG_PTR)lpStartAddr + ScanSize - sizeof(SECTION);

    KdPrint(("[%s] lpSearchAddr:%p lpEndAddr:%p\n", __FUNCTION__, lpSearchAddr, lpEndAddr));

    while (TRUE)
    {
        if (lpSearchAddr + PAGE_SIZE > lpEndAddr)
        {
            ulEntrySize = (ULONG)(lpEndAddr - lpSearchAddr);
        }
        else
        {
            ulEntrySize = PAGE_SIZE;
        }

        if (!MmsIsAddressValidLength((PVOID)lpSearchAddr, ulEntrySize))
        {
            goto NextLoop;
        }

        pSectionObject = lpSearchAddr;

        ulCurrentSize = 0;
        ulEntrySize  -= sizeof(SECTION);

        while (ulCurrentSize < ulEntrySize)
        {
            PSECTION pSection = (PSECTION)pSectionObject;
            if (MmsIsRealSectionObject2(pSection))
            {
                if (pSection->u.Flags.File && pSection->u.Flags.Image)
                {
                    char          szName[128] = { 0 };
                    PCONTROL_AREA ControlArea = (PCONTROL_AREA)((ULONG_PTR)pSection->u1.ControlArea & ~3);
                    PFILE_OBJECT  FileObject = (PFILE_OBJECT)((ULONG_PTR)ControlArea->FilePointer.Value & ~0xF);

                    if (MmsIsRealFileObject(FileObject))
                    {
                        if (MmsGetObjectName(FileObject, szName, 128))
                        {
                            KdPrint(("[%s] SectionObj:%p FileObj:%p FileName:%s\n", __FUNCTION__, pSection, FileObject, szName));
                        }
                    }
                }

                ulCurrentSize  += sizeof(SECTION);
                pSectionObject += sizeof(SECTION);
            }
            else
            {
                ulCurrentSize  += sizeof(ULONG_PTR);
                pSectionObject += sizeof(ULONG_PTR);
            }
        }

    NextLoop:
        lpSearchAddr += PAGE_SIZE;
        if (lpSearchAddr >= lpEndAddr)
        {
            break;
        }
    }
}
//----------------------------------------------------------------------------------------------
VOID ScanImageFileObjectBySectionObjectMemory()
{
    SIZE_T                   ulSize         = 0;
    ULONG_PTR                lpSearchAddr   = 0;
    ULONG_PTR                lpEndAddr      = 0;
    ULONG                    ulEntrySize    = 0;
    ULONG                    ulCurrentSize  = 0;
    ULONG_PTR                pSectionObject = 0;
    NTSTATUS                 status         = STATUS_SUCCESS;

    if (g_dynData.ver >= WINVER_7 && g_dynData.ver <= WINVER_81)
    {
        ulSize = (ULONG_PTR)g_dynData.MmPagedPoolEnd - (ULONG_PTR)g_dynData.MmPagedPoolStart;
        ScanImageFileObjectBySectionObjectMemory_Win7AndLater(g_dynData.MmPagedPoolStart, ulSize);
    }
    else if (g_dynData.ver >= WINVER_10_TH1)
    {
        ulSize = (ULONG_PTR)g_dynData.MmPagedPoolEnd - (ULONG_PTR)g_dynData.MmPagedPoolStart;
        ScanImageFileObjectBySectionObjectMemory_Win10(g_dynData.MmPagedPoolStart, ulSize);
    }
}
//----------------------------------------------------------------------------------------------
VOID ScanSection()
{
    ScanImageFileObjectBySectionObjectMemory();
}
//----------------------------------------------------------------------------------------------

```

`MemScanner/SectionScanner.h`:

```h
#pragma once

#include <ntifs.h>

VOID ScanSection();
```

`MemScanner/Utils.c`:

```c
#include "Utils.h"
#include "Private.h"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
typedef
POBJECT_TYPE
(NTAPI* pfnObGetObjectType)(
    PVOID pObject
    );
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
pfnObGetObjectType g_ObGetObjectType = NULL;

extern POBJECT_TYPE* IoDriverObjectType;
extern POBJECT_TYPE* IoDeviceObjectType;
extern POBJECT_TYPE* MmSectionObjectType;
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
NTSTATUS MmsSearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound)
{
    ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
    if (ppFound == NULL || pattern == NULL || base == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    for (ULONG_PTR i = 0; i < size - len; i++)
    {
        BOOLEAN found = TRUE;
        for (ULONG_PTR j = 0; j < len; j++)
        {
            if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
            {
                found = FALSE;
                break;
            }
        }

        if (found != FALSE)
        {
            *ppFound = (PUCHAR)base + i;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
POBJECT_TYPE MmsGetObjectType(PVOID pObject)
{
    UNICODE_STRING uniFuncName = { 0 };

    if (!g_ObGetObjectType)
    {
        RtlInitUnicodeString(&uniFuncName, L"ObGetObjectType");
        g_ObGetObjectType = (pfnObGetObjectType)MmGetSystemRoutineAddress(&uniFuncName);
    }

    if (g_ObGetObjectType)
    {
        return g_ObGetObjectType(pObject);
    }

    return NULL;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
ULONG MmsGetObjectName(PVOID Object, char* szBuffer, ULONG ulBufferSize)
{
    ULONG                   ulRetLen        = 0;
    ULONG                   ulRet           = 0;
    PUNICODE_STRING         lpUniObjectName = NULL;

    lpUniObjectName = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, 1024 + 2 * sizeof(OBJECT_NAME_INFORMATION), 'nOmM');
    if (!lpUniObjectName)
    {
        return 0;
    }

    memset(lpUniObjectName, 0, 1024 + 2 * sizeof(OBJECT_NAME_INFORMATION));
    lpUniObjectName->MaximumLength = 1024;

    if (NT_SUCCESS(ObQueryNameString(Object, (POBJECT_NAME_INFORMATION)lpUniObjectName, 1024, &ulRetLen)))
    {
        ULONG i, Len = lpUniObjectName->Length / 2;
        for (i = 0; i + 8 < Len && i + 1 < ulBufferSize; i++)
        {
            szBuffer[i] = (char)lpUniObjectName->Buffer[i + 8];
        }

        szBuffer[i++] = 0;
        ulRet = i;
    }

    ExFreePool(lpUniObjectName);
    return ulRet;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN MmsIsAddressValidLength(PVOID lpBuffer, ULONG Len)
{
    ULONG_PTR AddrStart = 0;
    ULONG_PTR AddrEnd   = 0;

    if (!MmIsAddressValid(lpBuffer))
    {
        return FALSE;
    }

    AddrStart = (ULONG_PTR)lpBuffer;
    AddrEnd   = AddrStart + Len;

    AddrStart = ALIGN_UP_BY(AddrStart, PAGE_SIZE);

    for (; AddrStart < AddrEnd; AddrStart += PAGE_SIZE)
    {
        if (!MmIsAddressValid((PVOID)AddrStart))
        {
            return FALSE;
        }
    }

    return TRUE;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN MmsIsRealDriverObject(PDRIVER_OBJECT DriverObject)
{
    BOOLEAN    bRet               = FALSE;
    ULONG_PTR  CurrentVirutalPage = 0;
    ULONG_PTR  PreVirtualPage     = 0;

    if (!DriverObject || !MmIsAddressValid(DriverObject))
    {
        return FALSE;
    }

    if (DriverObject->Type != 4 || DriverObject->Size != sizeof(DRIVER_OBJECT))
    {
        return FALSE;
    }

    CurrentVirutalPage = ALIGN_DOWN_BY(DriverObject, PAGE_SIZE);
    PreVirtualPage     = ALIGN_DOWN_BY((ULONG_PTR)DriverObject - 0x30, PAGE_SIZE); // Win7 ~ Win10 sizeof(_object_header) == 0x30

    if (PreVirtualPage != CurrentVirutalPage)
    {
        if (PreVirtualPage + PAGE_SIZE != CurrentVirutalPage)
        {
            // Impossible;
            return FALSE;
        }
        else
        {
            if (!MmIsAddressValid((PVOID)PreVirtualPage))
            {
                return FALSE;
            }
        }
    }

    // ObGetObjectType会访问到Object之前的内存空间，如果对象头内存与对象体内存不在一个页面，需要确保对象头所在页面也是有效的，正常情况绝不会不在同一个页面下
    if (MmsGetObjectType(DriverObject) != *IoDriverObjectType)
    {
        return FALSE;
    }

    if ((ULONG_PTR)DriverObject->DriverSection <= (ULONG_PTR)MmSystemRangeStart ||
        !MmIsAddressValid(DriverObject->DriverSection) ||
        (DriverObject->DriverSize & 0x1F) ||
        (ULONG_PTR)DriverObject->DriverStart <= (ULONG_PTR)MmSystemRangeStart ||
        ((ULONG_PTR)(DriverObject->DriverStart) & 0xFFF))
    {
        return FALSE;
    }

    PDEVICE_OBJECT DeviceObject = DriverObject->DeviceObject;
    if (DeviceObject)
    {
        if (MmIsAddressValid(DeviceObject) &&
            MmsGetObjectType(DeviceObject) == *IoDeviceObjectType &&
            DeviceObject->Type == 3 &&
            DeviceObject->Size >= sizeof(DEVICE_OBJECT))
        {
            bRet = TRUE;
        }
    }
    else
    {
        bRet = TRUE;
    }

    return bRet;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN MmsIsValidUnicodeString(PUNICODE_STRING lpuniStr)
{
    if (!lpuniStr ||
        !lpuniStr->Buffer ||
        !lpuniStr->Length ||
        lpuniStr->Length > lpuniStr->MaximumLength ||
        !MmsIsAddressValidLength(lpuniStr->Buffer, lpuniStr->Length))
    {
        return FALSE;
    }

    return TRUE;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN MmsIsRealSectionObject(PSECTION_OBJECT SectionObject)
{
    BOOLEAN bRet = FALSE;

    if (MmsIsAddressValidLength((PVOID)((ULONG_PTR)SectionObject - sizeof(OBJECT_HEADER)), sizeof(OBJECT_HEADER) + sizeof(SECTION_OBJECT)) &&
        MmsGetObjectType(SectionObject) == *MmSectionObjectType &&
        (ULONG_PTR)SectionObject->Segment > (ULONG_PTR)MmSystemRangeStart &&
        MmsIsAddressValidLength((PVOID)((ULONG_PTR)SectionObject->Segment - sizeof(OBJECT_HEADER)), sizeof(OBJECT_HEADER) + sizeof(SEGMENT_OBJECT)) &&
        SectionObject->Segment->SizeOfSegment > 0 &&
        SectionObject->Segment->SizeOfSegment < (ULONG_PTR)MmSystemRangeStart &&
        SectionObject->Segment->TotalNumberOfPtes > 0 &&
        (ULONG_PTR)SectionObject->Segment->PrototypePte > (ULONG_PTR)MmSystemRangeStart)
    {
        PCONTROL_AREA ControlArea = (PCONTROL_AREA)SectionObject->Segment->ControlArea;
        if ((ULONG_PTR)ControlArea > (ULONG_PTR)MmSystemRangeStart && 
            MmsIsAddressValidLength(ControlArea, sizeof(CONTROL_AREA)) && // sizeof(CONTROL_AREA) == 0x70/0x78/0x80 ... in all windows version
            !ControlArea->u.Flags.BeingCreated &&
            !ControlArea->u.Flags.BeingDeleted)
        {
            return TRUE;
        }
    }

    return bRet;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN MmsIsRealSectionObject2(PSECTION SectionObject)
{
    BOOLEAN bRet = FALSE;

    if (MmsIsAddressValidLength((PVOID)((ULONG_PTR)SectionObject - sizeof(OBJECT_HEADER)), sizeof(OBJECT_HEADER) + sizeof(SECTION)) &&
        MmsGetObjectType(SectionObject) == *MmSectionObjectType &&
        SectionObject->SizeOfSection > 0 &&
        SectionObject->SizeOfSection < (ULONG_PTR)MmSystemRangeStart &&
        !SectionObject->u.Flags.BeingDeleted &&
        !SectionObject->u.Flags.BeingCreated)
    {
        PCONTROL_AREA ControlArea = (PCONTROL_AREA)((ULONG_PTR)SectionObject->u1.ControlArea & ~3);
        if ((ULONG_PTR)ControlArea > (ULONG_PTR)MmSystemRangeStart &&
            MmsIsAddressValidLength(ControlArea, sizeof(CONTROL_AREA)))
        {
            return TRUE;
        }
    }

    return bRet;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN MmsIsRealFileObject(PFILE_OBJECT FileObject)
{
    BOOLEAN bRet = FALSE;

    if (MmsIsAddressValidLength((PVOID)((ULONG_PTR)FileObject - sizeof(OBJECT_HEADER)), sizeof(OBJECT_HEADER) + sizeof(FILE_OBJECT)) &&
        MmsGetObjectType(FileObject) == *IoFileObjectType &&
        FileObject->Type == 5 &&
        FileObject->Size == sizeof(FILE_OBJECT) &&
        (ULONG_PTR)FileObject->DeviceObject > (ULONG_PTR)MmSystemRangeStart &&
        (ULONG_PTR)FileObject->SectionObjectPointer > (ULONG_PTR)MmSystemRangeStart)
    {
        if ((ULONG_PTR)FileObject->DeviceObject)
        {
            if ((ULONG_PTR)FileObject->DeviceObject > (ULONG_PTR)MmSystemRangeStart &&
                MmsIsAddressValidLength((PVOID)((ULONG_PTR)FileObject->DeviceObject - sizeof(OBJECT_HEADER)), sizeof(OBJECT_HEADER) + sizeof(DEVICE_OBJECT)) &&
                MmsGetObjectType(FileObject->DeviceObject) == *IoDeviceObjectType)
            {
                bRet = TRUE;
            }
            else
            {
                bRet = FALSE;
            }
        }

        if ((ULONG_PTR)FileObject->Vpb)
        {
            if ((ULONG_PTR)FileObject->Vpb > (ULONG_PTR)MmSystemRangeStart &&
                MmsIsAddressValidLength(FileObject->Vpb, sizeof(VPB)) &&
                (ULONG_PTR)FileObject->Vpb->DeviceObject > (ULONG_PTR)MmSystemRangeStart &&
                MmsIsAddressValidLength((PVOID)((ULONG_PTR)FileObject->Vpb->DeviceObject - sizeof(OBJECT_HEADER)), sizeof(OBJECT_HEADER) + sizeof(DEVICE_OBJECT)) &&
                MmsGetObjectType(FileObject->Vpb->DeviceObject) == *IoDeviceObjectType)
            {
                bRet = TRUE;
            }
            else
            {
                bRet = FALSE;
            }
        }
    }

    return bRet;
}
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------

```

`MemScanner/Utils.h`:

```h
#pragma once
#include <ntifs.h>
#include "NativeStruct.h"

NTSTATUS     MmsSearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound);
POBJECT_TYPE MmsGetObjectType(PVOID pObject);
ULONG        MmsGetObjectName(PVOID Object, char* szBuffer, ULONG ulBufferSize);
BOOLEAN      MmsIsAddressValidLength(PVOID lpBuffer, ULONG Len);
BOOLEAN      MmsIsRealDriverObject(PVOID pObject);
BOOLEAN      MmsIsRealSectionObject(PSECTION_OBJECT SectionObject);
BOOLEAN      MmsIsRealSectionObject2(PSECTION SectionObject);
BOOLEAN      MmsIsRealFileObject(PFILE_OBJECT FileObject);
BOOLEAN      MmsIsValidUnicodeString(PUNICODE_STRING lpuniStr);
```

`MemScanner/main.c`:

```c
#include "NativeStruct.h"
#include "Private.h"
#include "Import.h"
#include "Utils.h"
#include "DriverScanner.h"
#include "SectionScanner.h"
#include <ntimage.h>



KEVENT           g_ScannerFinishEvent;

// OS Dependant data
DYNAMIC_DATA     g_dynData        = { 0 };
PDRIVER_OBJECT   g_DriverObject = NULL;

CHAR* g_szAssignedRegionNames[] = {
    "AssignedRegionNonPagedPool",
    "AssignedRegionPagedPool",
    "AssignedRegionSystemCache",
    "AssignedRegionSystemPtes",
    "AssignedRegionUltraZero",
    "AssignedRegionPfnDatabase",
    "AssignedRegionCfg",
    "AssignedRegionHyperSpace",
    "AssignedRegionKernelStacks",
    "AssignedRegionPageTables",
    "AssignedRegionSession",
    "AssignedRegionSecureNonPagedPool",
    "AssignedRegionSystemImages",
    "AssignedRegionMaximum"
};

extern POBJECT_TYPE* MmSectionObjectType;

extern PKDDEBUGGER_DATA64 g_KdDebuggerDataBlock;

//---------------------------------------------------------------------------------------------------------
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
VOID     DriverUnload(PDRIVER_OBJECT DriverObject);
NTSTATUS MmsGetBuildNO(OUT PULONG pBuildNo);
NTSTATUS MmsScanSection(IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound);
NTSTATUS MmsInitDynamicData(IN OUT PDYNAMIC_DATA pData);
NTSTATUS MmsInitMemoryLayoutForWin7AndWin8(IN OUT PDYNAMIC_DATA pData);
NTSTATUS MmsInitMemoryLayoutForWin8_1ToWin10TH2(IN OUT PDYNAMIC_DATA pData);
NTSTATUS MmsInitMemoryLayoutForWin10RS1AndLater(IN OUT PDYNAMIC_DATA pData);

VOID     MmsTestAllocateMemory();
VOID     MmsScannerThread(IN PVOID StartContext);
//---------------------------------------------------------------------------------------------------------
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    NTSTATUS Status       = STATUS_SUCCESS;
    HANDLE   ThreadHandle = NULL;

    UNREFERENCED_PARAMETER(RegistryPath);

    InitializeDebuggerBlock();
    Status = MmsInitDynamicData(&g_dynData);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    Status = MmsInitLdrData((PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    g_DriverObject = DriverObject;

    DriverObject->DriverUnload = DriverUnload;
    
    MmsTestAllocateMemory();

    KeInitializeEvent(&g_ScannerFinishEvent, NotificationEvent, FALSE);
    PsCreateSystemThread(&ThreadHandle,
        0,
        NULL,
        NtCurrentProcess(),
        NULL,
        MmsScannerThread,
        NULL);

    if (ThreadHandle)
    {
        ZwClose(ThreadHandle);
    }

    return STATUS_SUCCESS;
}
//---------------------------------------------------------------------------------------------------------
VOID MmsScannerThread(IN PVOID StartContext)
{
    LARGE_INTEGER liDelayTime = { 0 };

    liDelayTime.QuadPart = -1000 * 10000;
    KeDelayExecutionThread(KernelMode, FALSE, &liDelayTime);

    ScanDriver();
    ScanSection();

    KeSetEvent(&g_ScannerFinishEvent, IO_NO_INCREMENT, FALSE);

    PsTerminateSystemThread(STATUS_SUCCESS);
}
//---------------------------------------------------------------------------------------------------------
VOID DriverUnload(PDRIVER_OBJECT DriverObject)
{
    UNREFERENCED_PARAMETER(DriverObject);

    DbgPrint("[%s] Unloading\n", __FUNCTION__);

    KeWaitForSingleObject(&g_ScannerFinishEvent, Executive, KernelMode, FALSE, NULL);

    DbgPrint("[%s] Unload Complete\n", __FUNCTION__);

    return;
}
//---------------------------------------------------------------------------------------------------------
NTSTATUS MmsScanSection(IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound)
{
    ASSERT(ppFound != NULL);
    if (ppFound == NULL)
        return STATUS_INVALID_PARAMETER;

    PVOID base = GetKernelBase(NULL);
    if (!base)
        return STATUS_NOT_FOUND;

    PIMAGE_NT_HEADERS64 pHdr = RtlImageNtHeader(base);
    if (!pHdr)
        return STATUS_INVALID_IMAGE_FORMAT;

    PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + 1);
    for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection < pFirstSection + pHdr->FileHeader.NumberOfSections; pSection++)
    {
        ANSI_STRING s1, s2;
        RtlInitAnsiString(&s1, section);
        RtlInitAnsiString(&s2, (PCCHAR)pSection->Name);
        if (RtlCompareString(&s1, &s2, TRUE) == 0)
        {
            PVOID ptr = NULL;
            NTSTATUS status = MmsSearchPattern(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->Misc.VirtualSize, &ptr);
            if (NT_SUCCESS(status))
                *ppFound = ptr;

            return status;
        }
    }

    return STATUS_NOT_FOUND;
}
//---------------------------------------------------------------------------------------------------------
NTSTATUS MmsGetBuildNO(OUT PULONG pBuildNo)
{
    ASSERT(pBuildNo != NULL);
    if (pBuildNo == NULL)
        return STATUS_INVALID_PARAMETER;

    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING strRegKey = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    UNICODE_STRING strRegValue = RTL_CONSTANT_STRING(L"BuildLabEx");
    UNICODE_STRING strRegValue10 = RTL_CONSTANT_STRING(L"UBR");
    UNICODE_STRING strVerVal = { 0 };
    HANDLE hKey = NULL;
    OBJECT_ATTRIBUTES keyAttr = { 0 };

    InitializeObjectAttributes(&keyAttr, &strRegKey, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ZwOpenKey(&hKey, KEY_READ, &keyAttr);
    if (NT_SUCCESS(status))
    {
        PKEY_VALUE_FULL_INFORMATION pValueInfo = ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, MMS_POOL_TAG);
        ULONG bytes = 0;

        if (pValueInfo)
        {
            // Try query UBR value
            status = ZwQueryValueKey(hKey, &strRegValue10, KeyValueFullInformation, pValueInfo, PAGE_SIZE, &bytes);
            if (NT_SUCCESS(status))
            {
                *pBuildNo = *(PULONG)((PUCHAR)pValueInfo + pValueInfo->DataOffset);
                goto skip1;
            }

            status = ZwQueryValueKey(hKey, &strRegValue, KeyValueFullInformation, pValueInfo, PAGE_SIZE, &bytes);
            if (NT_SUCCESS(status))
            {
                PWCHAR pData = (PWCHAR)((PUCHAR)pValueInfo->Name + pValueInfo->NameLength);
                for (ULONG i = 0; i < pValueInfo->DataLength; i++)
                {
                    if (pData[i] == L'.')
                    {
                        for (ULONG j = i + 1; j < pValueInfo->DataLength; j++)
                        {
                            if (pData[j] == L'.')
                            {
                                strVerVal.Buffer = &pData[i] + 1;
                                strVerVal.Length = strVerVal.MaximumLength = (USHORT)((j - i) * sizeof(WCHAR));
                                status = RtlUnicodeStringToInteger(&strVerVal, 10, pBuildNo);

                                goto skip1;
                            }
                        }
                    }
                }

            skip1:;
            }

            ExFreePoolWithTag(pValueInfo, MMS_POOL_TAG);
        }
        else
            status = STATUS_NO_MEMORY;

        ZwClose(hKey);
    }
    else
        DbgPrint("[%s] ZwOpenKey failed with status 0x%X\n", __FUNCTION__, status);

    return status;
}
//---------------------------------------------------------------------------------------------------------
NTSTATUS MmsInitDynamicData(IN OUT PDYNAMIC_DATA pData)
{
    NTSTATUS             status = STATUS_SUCCESS;
    RTL_OSVERSIONINFOEXW verInfo = { 0 };

    if (pData == NULL)
    {
        return STATUS_INVALID_ADDRESS;
    }

    RtlZeroMemory(pData, sizeof(DYNAMIC_DATA));
    pData->DYN_PDE_BASE = (PVOID)PDE_BASE;
    pData->DYN_PTE_BASE = (PVOID)PTE_BASE;

    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    status = RtlGetVersion((PRTL_OSVERSIONINFOW)&verInfo);

    if (status != STATUS_SUCCESS)
    {
        return status;
    }

    ULONG ver_short = (verInfo.dwMajorVersion << 8) | (verInfo.dwMinorVersion << 4) | verInfo.wServicePackMajor;
    pData->ver = (WinVer)ver_short;

    // Get kernel build number
    status = MmsGetBuildNO(&pData->buildNo);

    DbgPrint(
        "[%s] OS version %d.%d.%d.%d.%d - 0x%x\n",
        __FUNCTION__,
        verInfo.dwMajorVersion,
        verInfo.dwMinorVersion,
        verInfo.dwBuildNumber,
        verInfo.wServicePackMajor,
        pData->buildNo,
        ver_short
    );

    switch (ver_short)
    {
        // Windows 7
        // Windows 7 SP1
    case WINVER_7:
    case WINVER_7_SP1:
        break;

        // Windows 8
    case WINVER_8:
        break;

        // Windows 8.1
    case WINVER_81:
        break;

        // Windows 10, build 16299/15063/14393/10586/10140
    case WINVER_10:

        if (verInfo.dwBuildNumber == 10240)
        {
            pData->ver = WINVER_10_TH1;
            break;
        }
        else if (verInfo.dwBuildNumber == 10586)
        {
            pData->ver = WINVER_10_TH2;
            break;
        }
        else if (verInfo.dwBuildNumber == 14393)
        {
            pData->ver = WINVER_10_RS1;
            break;
        }
        else if (verInfo.dwBuildNumber == 15063)
        {
            pData->ver = WINVER_10_RS2;
            break;
        }
        else if (verInfo.dwBuildNumber == 16299)
        {
            pData->ver = WINVER_10_RS3;
            break;
        }
        else if (verInfo.dwBuildNumber == 17134)
        {
            pData->ver = WINVER_10_RS4;
            break;
        }
        else if (verInfo.dwBuildNumber == 17763)
        {
            pData->ver = WINVER_10_RS5;
            break;
        }
        else if (verInfo.dwBuildNumber == 18362 || verInfo.dwBuildNumber == 18363)
        {
            pData->ver = verInfo.dwBuildNumber == 18362 ? WINVER_10_19H1 : WINVER_10_19H2;
            break;
        }
        else if (verInfo.dwBuildNumber == 19041)
        {
            pData->ver = WINVER_10_20H1;
            break;
        }
        else
        {
            return STATUS_NOT_SUPPORTED;
        }
    default:
        break;
    }

    if (pData->ver >= WINVER_7 && pData->ver <= WINVER_8)
    {
        status = MmsInitMemoryLayoutForWin7AndWin8(pData);
    }
    else if (pData->ver >= WINVER_81 && pData->ver <= WINVER_10_TH2)
    {
        status = MmsInitMemoryLayoutForWin8_1ToWin10TH2(pData);
    }
    else if (pData->ver >= WINVER_10_RS1)
    {
        status = MmsInitMemoryLayoutForWin10RS1AndLater(pData);

        DbgPrint("[%s] g_KdBlock->KernBase: %p, GetKernelBase() = 0x%p\n", __FUNCTION__, g_KdBlock.KernBase, GetKernelBase(NULL));

        ULONGLONG mask = (1ll << (PHYSICAL_ADDRESS_BITS - 1)) - 1;
        g_dynData.DYN_PTE_BASE = (PVOID)g_KdBlock.PteBase;
        g_dynData.DYN_PDE_BASE = (PVOID)((g_KdBlock.PteBase & ~mask) | ((g_KdBlock.PteBase >> 9) & mask));
    }

    DbgPrint("[%s] MmPagedPoolStart: 0x%p, MmPagedPoolEnd = 0x%p \n",       __FUNCTION__, pData->MmPagedPoolStart, pData->MmPagedPoolEnd);
    DbgPrint("[%s] MmNonpagedPoolStart: 0x%p, MmNonpagedPoolEnd = 0x%p \n", __FUNCTION__, pData->MmNonpagedPoolStart, pData->MmNonpagedPoolEnd);
    DbgPrint("[%s] MmSystemPtesStart: 0x%p, MmSystemPtesEnd = 0x%p \n",     __FUNCTION__, pData->MmSystemPtesStart, pData->MmSystemPtesEnd);
    DbgPrint("[%s] MmDriverImageStart: 0x%p, MmDriverImageEnd = 0x%p \n",   __FUNCTION__, pData->MmDriverImageStart, pData->MmDriverImageEnd);
    DbgPrint("[%s] PDE_BASE: %p, PTE_BASE: %p\n",                           __FUNCTION__, pData->DYN_PDE_BASE, pData->DYN_PTE_BASE);

    if ((ULONG_PTR)pData->DYN_PDE_BASE < MI_SYSTEM_RANGE_START || (ULONG_PTR)pData->DYN_PTE_BASE < MI_SYSTEM_RANGE_START)
    {
        DbgPrint("[%s] Invalid PDE/PTE base, aborting\n", __FUNCTION__);
        return STATUS_UNSUCCESSFUL;
    }

    return status;

}
//---------------------------------------------------------------------------------------------------------
NTSTATUS MmsInitMemoryLayoutForWin7AndWin8(IN OUT PDYNAMIC_DATA pData)
{
    if (!pData)
    {
        return STATUS_INVALID_ADDRESS;
    }

    if (!g_KdBlock.MmNonPagedPoolStart || !g_KdBlock.MmMaximumNonPagedPoolInBytes)
    {
        return STATUS_UNSUCCESSFUL;
    }

    // 可扩展区域
    pData->MmNonpagedPoolStart = *(PVOID*)g_KdBlock.MmNonPagedPoolStart;
    pData->MmNonpagedPoolEnd   = (PVOID)((PUCHAR)pData->MmNonpagedPoolStart + *(PULONG_PTR)g_KdBlock.MmMaximumNonPagedPoolInBytes - 1);

    pData->MmPteSpaceStart   = (PVOID)0xFFFFF68000000000;
    pData->MmPteSpacecEnd    = (PVOID)0xFFFFF6FFFFFFFFFF;

    pData->MmHyperSpaceStart = (PVOID)0xFFFFF70000000000;
    pData->MmHyperSpaceEnd   = (PVOID)0xFFFFF77FFFFFFFFF;

    pData->MmSharedSystemPageStart = (PVOID)0xFFFFF78000000000;
    pData->MmSharedSystemPageEnd   = (PVOID)0xFFFFF78000000FFF;

    pData->MmSystemCacheWorkingSetStart = (PVOID)0xFFFFF78000001000;
    pData->MmSystemCacheWorkingSetEnd   = (PVOID)0xFFFFF7FFFFFFFFFF;

    pData->MmDriverImageStart = (PVOID)0xFFFFF80000000000;
    pData->MmDriverImageEnd   = (PVOID)0xFFFFF87FFFFFFFFF;

    pData->MmSystemPtesStart  = (PVOID)0xFFFFF88000000000;
    pData->MmSystemPtesEnd    = (PVOID)0xFFFFF89FFFFFFFFF;

    pData->MmPagedPoolStart   = (PVOID)0xFFFFF8A000000000;
    pData->MmPagedPoolEnd     = (PVOID)0xFFFFF8BFFFFFFFFF;

    pData->MmSessionSpaceStart = (PVOID)0xFFFFF90000000000;
    pData->MmSessionSpaceEnd   = (PVOID)0xFFFFF97FFFFFFFFF;

    pData->MmDynamicVASpaceStart = (PVOID)0xFFFFF98000000000;
    pData->MmDynamicVASpaceEnd   = (PVOID)0xFFFFFA70FFFFFFFF;

    pData->MmPfnDatabaseStart = (PVOID)0xFFFFFA8000000000;
    pData->MmPfnDatabaseEnd   = (PVOID)((ULONG_PTR)pData->MmNonpagedPoolStart - 1);

    return STATUS_SUCCESS;
}
//---------------------------------------------------------------------------------------------------------
NTSTATUS MmsInitMemoryLayoutForWin8_1ToWin10TH2(IN OUT PDYNAMIC_DATA pData)
{
    if (!pData)
    {
        return STATUS_INVALID_ADDRESS;
    }

    pData->MmPteSpaceStart = (PVOID)0xFFFFF68000000000;
    pData->MmPteSpacecEnd  = (PVOID)0xFFFFF6FFFFFFFFFF;

    pData->MmHyperSpaceStart = (PVOID)0xFFFFF70000000000;
    pData->MmHyperSpaceEnd   = (PVOID)0xFFFFF77FFFFFFFFF;

    pData->MmSharedSystemPageStart = (PVOID)0xFFFFF78000000000;
    pData->MmSharedSystemPageEnd   = (PVOID)0xFFFFF78000000FFF;

    pData->MmSystemCacheStart = (PVOID)0xFFFFB00000000000;
    pData->MmSystemCacheEnd   = (PVOID)0xFFFFBFFFFFFFFFFF;

    pData->MmPagedPoolStart = (PVOID)0xFFFFC00000000000;
    pData->MmPagedPoolEnd   = (PVOID)0xFFFFCF7FFFFFFFFF;

    pData->MmSpecialPoolStart = (PVOID)0xFFFFCF8000000000;
    pData->MmSpecialPoolEnd   = (PVOID)0xFFFFCFFFFFFFFFFF;

    pData->MmSystemPtesStart = (PVOID)0xFFFFD00000000000;
    pData->MmSystemPtesEnd   = (PVOID)0xFFFFDFFFFFFFFFFF;

    pData->MmNonpagedPoolStart = (PVOID)0xFFFFE00000000000;
    pData->MmNonpagedPoolEnd   = (PVOID)0xFFFFF00000000000;//等分成KeNumberNodes块

    pData->MmDriverImageStart = (PVOID)0xFFFFF80000000000;
    pData->MmDriverImageEnd   = (PVOID)0xFFFFF87FFFFFFFFF;

    pData->MmSessionSpaceStart = (PVOID)0xFFFFF90000000000;
    pData->MmSessionSpaceEnd   = (PVOID)0xFFFFF97FFFFFFFFF;

    pData->MmDynamicVASpaceStart = (PVOID)0xFFFFF98000000000;
    pData->MmDynamicVASpaceEnd   = (PVOID)0xFFFFFA70FFFFFFFF;

    pData->MmPfnDatabaseStart = (PVOID)0xFFFFFA8000000000;
    pData->MmPfnDatabaseEnd   = (PVOID)((ULONG_PTR)pData->MmNonpagedPoolStart - 1);

    return STATUS_SUCCESS;
}
//---------------------------------------------------------------------------------------------------------
NTSTATUS MmsInitMemoryLayoutForWin10RS1AndLater(IN OUT PDYNAMIC_DATA pData)
{
    ULONG                     ulIndex                = 0;
    PVOID                     lpTargetAddr           = NULL;
    PMI_SYSTEM_VA_ASSIGNMENT  lpMiSystemVaAssignment = NULL;

    if (!pData)
    {
        return STATUS_INVALID_ADDRESS;
    }

    MmsScanSection(".text", 
        (PCUCHAR)"\x48\x63\xC1\x48\x8D\x0D\xCC\xCC\xCC\xCC\x48\x03\xC0\x48\x8B\x04\xC1\xC3", 
        0xCC, 
        18, 
        (PVOID)&lpTargetAddr);

    if (!lpTargetAddr)
    {
        DbgPrint("[%s] MmsScanSection Failed\n", __FUNCTION__);
        return STATUS_NOT_FOUND;
    }

    lpMiSystemVaAssignment = (PMI_SYSTEM_VA_ASSIGNMENT)((PUCHAR)lpTargetAddr + *(PULONG)((PUCHAR)lpTargetAddr + 6) + 10);
    for (ulIndex = 0; ulIndex < AssignedRegionMaximum; ulIndex++)
    {
        DbgPrint("[%s] Names:%s, BaseAddr:%I64x, Size:%I64x\n", 
            __FUNCTION__, 
            g_szAssignedRegionNames[ulIndex],
            lpMiSystemVaAssignment[ulIndex].BaseAddress, 
            lpMiSystemVaAssignment[ulIndex].NumberOfBytes);
    }

    pData->MmPteSpaceStart = (PVOID)lpMiSystemVaAssignment[AssignedRegionPageTables].BaseAddress;
    pData->MmPteSpacecEnd  = (PVOID)((PUCHAR)lpMiSystemVaAssignment[AssignedRegionPageTables].BaseAddress + lpMiSystemVaAssignment[AssignedRegionPageTables].NumberOfBytes - 1);

    pData->MmHyperSpaceStart = (PVOID)lpMiSystemVaAssignment[AssignedRegionHyperSpace].BaseAddress;
    pData->MmHyperSpaceEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[AssignedRegionHyperSpace].BaseAddress + lpMiSystemVaAssignment[AssignedRegionHyperSpace].NumberOfBytes - 1);

    pData->MmSharedSystemPageStart = (PVOID)0xFFFFF78000000000;
    pData->MmSharedSystemPageEnd   = (PVOID)0xFFFFF78000000FFF;

    pData->MmSystemCacheStart = (PVOID)lpMiSystemVaAssignment[AssignedRegionSystemCache].BaseAddress;
    pData->MmSystemCacheEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[AssignedRegionSystemCache].BaseAddress + lpMiSystemVaAssignment[AssignedRegionSystemCache].NumberOfBytes - 1);

    pData->MmPagedPoolStart = (PVOID)lpMiSystemVaAssignment[AssignedRegionPagedPool].BaseAddress;
    pData->MmPagedPoolEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[AssignedRegionPagedPool].BaseAddress + lpMiSystemVaAssignment[AssignedRegionPagedPool].NumberOfBytes - 1);

    pData->MmSpecialPoolStart = (PVOID)NULL;
    pData->MmSpecialPoolEnd   = (PVOID)NULL;

    pData->MmSystemPtesStart = (PVOID)lpMiSystemVaAssignment[AssignedRegionSystemPtes].BaseAddress;
    pData->MmSystemPtesEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[AssignedRegionSystemPtes].BaseAddress + lpMiSystemVaAssignment[AssignedRegionSystemPtes].NumberOfBytes - 1);

    pData->MmNonpagedPoolStart = (PVOID)lpMiSystemVaAssignment[AssignedRegionNonPagedPool].BaseAddress;
    pData->MmNonpagedPoolEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[AssignedRegionNonPagedPool].BaseAddress + lpMiSystemVaAssignment[AssignedRegionNonPagedPool].NumberOfBytes - 1);//等分成KeNumberNodes块

    if (pData->ver == WINVER_10_RS1)
    {
        pData->MmDriverImageStart = (PVOID)lpMiSystemVaAssignment[13].BaseAddress;
        pData->MmDriverImageEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[13].BaseAddress + lpMiSystemVaAssignment[13].NumberOfBytes - 1);

        pData->MmSessionSpaceStart = (PVOID)lpMiSystemVaAssignment[10].BaseAddress;
        pData->MmSessionSpaceEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[10].BaseAddress + lpMiSystemVaAssignment[10].NumberOfBytes - 1);
    }
    else if (pData->ver == WINVER_10_RS2)
    {
        pData->MmDriverImageStart = (PVOID)lpMiSystemVaAssignment[12].BaseAddress;
        pData->MmDriverImageEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[12].BaseAddress + lpMiSystemVaAssignment[12].NumberOfBytes - 1);

        pData->MmSessionSpaceStart = (PVOID)lpMiSystemVaAssignment[11].BaseAddress;
        pData->MmSessionSpaceEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[11].BaseAddress + lpMiSystemVaAssignment[11].NumberOfBytes - 1);
    }
    else if (pData->ver >= WINVER_10_RS3 && pData->ver <= WINVER_10_RS5)
    {
        pData->MmDriverImageStart = (PVOID)lpMiSystemVaAssignment[13].BaseAddress;
        pData->MmDriverImageEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[13].BaseAddress + lpMiSystemVaAssignment[13].NumberOfBytes - 1);

        pData->MmSessionSpaceStart = (PVOID)lpMiSystemVaAssignment[12].BaseAddress;
        pData->MmSessionSpaceEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[12].BaseAddress + lpMiSystemVaAssignment[12].NumberOfBytes - 1);
    }
    else if (pData->ver == WINVER_10_19H1 || pData->ver == WINVER_10_19H2)
    {
        pData->MmDriverImageStart = (PVOID)lpMiSystemVaAssignment[11].BaseAddress;
        pData->MmDriverImageEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[11].BaseAddress + lpMiSystemVaAssignment[11].NumberOfBytes - 1);

        pData->MmSessionSpaceStart = (PVOID)lpMiSystemVaAssignment[10].BaseAddress;
        pData->MmSessionSpaceEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[10].BaseAddress + lpMiSystemVaAssignment[10].NumberOfBytes - 1);
    }
    else if (pData->ver >= WINVER_10_20H1)
    {
        pData->MmDriverImageStart = (PVOID)lpMiSystemVaAssignment[AssignedRegionSystemImages].BaseAddress;
        pData->MmDriverImageEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[AssignedRegionSystemImages].BaseAddress + lpMiSystemVaAssignment[AssignedRegionSystemImages].NumberOfBytes - 1);

        pData->MmSessionSpaceStart = (PVOID)lpMiSystemVaAssignment[10].BaseAddress;
        pData->MmSessionSpaceEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[10].BaseAddress + lpMiSystemVaAssignment[10].NumberOfBytes - 1);
    }

    pData->MmDynamicVASpaceStart = (PVOID)NULL;
    pData->MmDynamicVASpaceEnd   = (PVOID)NULL;

    pData->MmPfnDatabaseStart = (PVOID)lpMiSystemVaAssignment[AssignedRegionPfnDatabase].BaseAddress;
    pData->MmPfnDatabaseEnd   = (PVOID)((PUCHAR)lpMiSystemVaAssignment[AssignedRegionPfnDatabase].BaseAddress + lpMiSystemVaAssignment[AssignedRegionPfnDatabase].NumberOfBytes - 1);

    return STATUS_SUCCESS;
}
//---------------------------------------------------------------------------------------------------------
VOID MmsTestAllocatePagedPoolMemory()
{
    PVOID lpAddr = NULL;

    lpAddr = ExAllocatePoolWithTag(PagedPool, 256, MMS_POOL_TAG);
    if (lpAddr)
    {
        DbgPrint("[%s] AllocateAddress:%p\n", __FUNCTION__, lpAddr);
        ExFreePool(lpAddr);
    }
}
//---------------------------------------------------------------------------------------------------------
VOID MmsTestAllocateNonPagedPoolMemory()
{
    PVOID lpAddr = NULL;

    lpAddr = ExAllocatePoolWithTag(NonPagedPool, 256, MMS_POOL_TAG);
    if (lpAddr)
    {
        DbgPrint("[%s] AllocateAddress:%p\n", __FUNCTION__, lpAddr);
        ExFreePool(lpAddr);
    }
}
//---------------------------------------------------------------------------------------------------------
VOID MmsTestAllocateMDLMemory()
{
    PHYSICAL_ADDRESS Low = { 0 };
    PHYSICAL_ADDRESS High = { 0 };
    PHYSICAL_ADDRESS Skip = { 0 };
    SIZE_T           SizeOfBytes = 0x332000;

    High.QuadPart = 0x10000000000000;

    PMDL pMdl = MmAllocatePagesForMdl(Low, High, Skip, SizeOfBytes);
    if (pMdl)
    {
        PVOID lpMappedAddr = MmMapLockedPagesSpecifyCache(pMdl, KernelMode, MmNonCached, NULL, 0, 0);
        if (lpMappedAddr)
        {
            DbgPrint("[%s] AllocateAddress:%p\n", __FUNCTION__, lpMappedAddr);

            MmUnmapLockedPages(lpMappedAddr, pMdl);
            lpMappedAddr;
        }

        MmFreePagesFromMdl(pMdl);
        ExFreePool(pMdl);
    }
}
//---------------------------------------------------------------------------------------------------------
VOID MmsTestMapViewInSystemSpace()
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          Status        = STATUS_SUCCESS;
    UNICODE_STRING    uniDllName    = { 0 };
    IO_STATUS_BLOCK   IoStatusblock = { 0 };
    HANDLE            hFileHandle   = NULL;
    HANDLE            hSection      = NULL;
    PVOID             SectionObject = NULL;
    PVOID             MappedAddr    = NULL;
    SIZE_T            MappedSize    = 0;

    RtlInitUnicodeString(&uniDllName, L"\\SystemRoot\\System32\\ntdll.dll");
    InitializeObjectAttributes(&oa, &uniDllName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = ZwCreateFile(&hFileHandle,
        FILE_READ_ACCESS,
        &oa,
        &IoStatusblock,
        NULL,
        0,
        FILE_SHARE_READ,
        FILE_OPEN,
        0,
        NULL,
        0);

    if (!NT_SUCCESS(Status))
    {
        return;
    }

    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);
    Status = ZwCreateSection(&hSection,
        STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ,
        &oa,
        NULL,
        PAGE_READONLY,
        SEC_IMAGE,
        hFileHandle);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = ObReferenceObjectByHandle(hSection, 0, *MmSectionObjectType, KernelMode, &SectionObject, NULL);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    MmMapViewInSystemSpace(SectionObject, &MappedAddr, &MappedSize);
    DbgPrint("[%s] MappedAddr:%p MappedSize:%x\n", __FUNCTION__, MappedAddr, MappedSize);

Cleanup:

    if (MappedAddr)
    {
        MmUnmapViewInSystemSpace(MappedAddr);
        MappedAddr = NULL;
    }

    if (SectionObject)
    {
        ObDereferenceObject(SectionObject);
        SectionObject = NULL;
    }

    if (hSection)
    {
        ZwClose(hSection);
        hSection = NULL;
    }

    if (hFileHandle)
    {
        ZwClose(hFileHandle);
        hFileHandle = NULL;
    }

    return;
}
//---------------------------------------------------------------------------------------------------------
VOID MmsTestAllocateContiguousMemory()
{
    PVOID            lpVirtualAddr        = NULL;
    PHYSICAL_ADDRESS HighestAcceptAddress = {0};
    HighestAcceptAddress.QuadPart = 1000000000;

    // 申请连续的不可分页物理内存空间 并映射到系统空间
    lpVirtualAddr = MmAllocateContiguousMemory(PAGE_SIZE * 10, HighestAcceptAddress);
    if (lpVirtualAddr)
    {
        DbgPrint("[%s] lpVirtualAddr:%p\n", __FUNCTION__, lpVirtualAddr);
        MmFreeContiguousMemory(lpVirtualAddr);
    }
}
//---------------------------------------------------------------------------------------------------------
VOID MmsTestAllocateMemory()
{
    MmsTestAllocatePagedPoolMemory();
    MmsTestAllocateNonPagedPoolMemory();
    MmsTestMapViewInSystemSpace();
    MmsTestAllocateMDLMemory();
    MmsTestAllocateContiguousMemory();
}
//---------------------------------------------------------------------------------------------------------
```

`README.md`:

```md
# MemScanner
Analyze Windows x64 Kernel Memory Layout
***

# Build
Build with VS2019 + WDK 10.0.19041.0 <br>
Support Windows 7 ~ Windows 10 20H1 x64, and Not support x86 Platform
***

# Update
2020/11/19 Repair Bsod in Win7/8, and support Finding FileObject By Scanning SectionObject in Win7~Win10  
2020/11/18 Support Find FileObject By Scanning SectionObject(PagedPool Memory)  
2020/10/26 Support EnumDriver By Scanning DriverObject and LDR_DATA_TABLE_ENTRY(NonPagedPool Memory)
***

# Conclusion
- In Win7 DriverObject is not associated with FileObject, within the procedure of MmLoadSystemImage the SectionObject created and deleted immediately at the end; but in Win10 the life cycle of SectionObject is same to DriverObject.  

```