Project Path: arc_mojtabafalleh_emulator__3vcsmae

Source Tree:

```txt
arc_mojtabafalleh_emulator__3vcsmae
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ CMakePresets.json
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ deps
‚îÇ   ‚îú‚îÄ‚îÄ capstone
‚îÇ   ‚îî‚îÄ‚îÄ unicorn
‚îú‚îÄ‚îÄ doc
‚îÇ   ‚îî‚îÄ‚îÄ splash.png
‚îú‚îÄ‚îÄ headers
‚îÇ   ‚îú‚îÄ‚îÄ Emulator.hpp
‚îÇ   ‚îî‚îÄ‚îÄ Loader.hpp
‚îú‚îÄ‚îÄ main.cpp
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ Disassembler.cpp
    ‚îú‚îÄ‚îÄ Emulator.cpp
    ‚îú‚îÄ‚îÄ Loader.cpp
    ‚îî‚îÄ‚îÄ Logger.cpp

```

`CMakeLists.txt`:

```txt
# CMakeList.txt : CMake project for emulator, include source and define
# project specific logic here.
#
cmake_minimum_required (VERSION 3.8)



# Enable Hot Reload for MSVC compilers if supported.
if (POLICY CMP0141)
  cmake_policy(SET CMP0141 NEW)
  set(CMAKE_MSVC_DEBUG_INFORMATION_FORMAT "$<IF:$<AND:$<C_COMPILER_ID:MSVC>,$<CXX_COMPILER_ID:MSVC>>,$<$<CONFIG:Debug,RelWithDebInfo>:EditAndContinue>,$<$<CONFIG:Debug,RelWithDebInfo>:ProgramDatabase>>")
endif()

project ("emulator")

add_executable(emulator 
    "main.cpp"
    src/Emulator.cpp
    "src/Loader.cpp"
    src/Disassembler.cpp
    "src/Logger.cpp"   )

if (CMAKE_VERSION VERSION_GREATER 3.12)
  set_property(TARGET emulator PROPERTY CXX_STANDARD 20)
endif()

if (WIN32)
    target_link_libraries(emulator dbghelp)
endif()

# TODO: Add tests and install targets if needed.

add_subdirectory(deps/unicorn)
target_link_libraries(emulator unicorn)

add_subdirectory(deps/capstone)
target_link_libraries(emulator capstone)


```

`CMakePresets.json`:

```json
{
    "version": 3,
    "configurePresets": [
        {
            "name": "windows-base",
            "hidden": true,
            "generator": "Ninja",
            "binaryDir": "${sourceDir}/out/build/${presetName}",
            "installDir": "${sourceDir}/out/install/${presetName}",
            "cacheVariables": {
                "CMAKE_C_COMPILER": "cl.exe",
                "CMAKE_CXX_COMPILER": "cl.exe"
            },
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            }
        },
        {
            "name": "x64-debug",
            "displayName": "x64 Debug",
            "inherits": "windows-base",
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "x64-release",
            "displayName": "x64 Release",
            "inherits": "x64-debug",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        },
        {
            "name": "x86-debug",
            "displayName": "x86 Debug",
            "inherits": "windows-base",
            "architecture": {
                "value": "x86",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "x86-release",
            "displayName": "x86 Release",
            "inherits": "x86-debug",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        }
    ]
}

```

`README.md`:

```md
# Emulator-Debugger Hybrid üêâüõ†Ô∏è

![Splash](https://github.com/mojtabafalleh/emulator/blob/master/doc/splash.png)
*A unique hybrid tool combining debugger and emulator for precise execution and deep logging of complex programs*

---

## Overview

This project is a unique hybrid tool between a **debugger** and an **emulator**, designed for precise execution of complex applications, especially those protected with layers like DRM in games.

The program runs the target application using debugging features and executes the main parts of the code with **Unicorn Engine**. When execution reaches Windows API functions, it sets a **breakpoint** on their return addresses and hands control back to Unicorn. This results in **highly accurate and detailed logs**.

---

## What Makes This Project Unique?

- Hybrid execution combining debugger and emulator for high precision and performance  
- Detailed logging, especially around Windows API function calls  
- Ideal for complex and protected applications (e.g., DRM-protected games)  
- Full control over execution at function and return address levels  

---

## Features

- Executes code segments using **Unicorn Engine** for speed and flexibility  
- Sets **breakpoints** at Windows API return addresses and resumes emulation  
- Produces reliable and detailed logs for in-depth program analysis  
- Designed to handle the complexity of protected software execution  

---

## Usage

```bash
git clone --recurse-submodules https://github.com/mojtabafalleh/emulator.git
cd emulator
cmake .
# then go to visual studio and open project by folder
# Run the program with your target application
 emulator "D:\Project\Path\ \to \Your \program.exe"

```

`headers/Emulator.hpp`:

```hpp
#pragma once

#include <unicorn/unicorn.h>
#include "Loader.hpp"
#include <map>
#include <string>
#include <unordered_set>

static const std::map<uint64_t, std::string> kuser_shared_data_offsets = {
    {0x000, "TickCountLowDeprecated"},
    {0x004, "TickCountMultiplier"},
    {0x008, "InterruptTime"},
    {0x010, "SystemTime"},
    {0x018, "TimeZoneBias"},
    {0x020, "ImageNumberLow"},
    {0x024, "ImageNumberHigh"},
    {0x028, "NtSystemRoot"}, // WCHAR*
    {0x02C, "MaxStackTraceDepth"},
    {0x030, "CryptoExponent"},
    {0x034, "TimeZoneId"},
    {0x038, "LargePageMinimum"},
    {0x040, "AitSamplingValue"},
    {0x044, "AppCompatFlag"},
    {0x048, "RNGSeedVersion"},
    {0x050, "GlobalValidationRunlevel"},
    {0x054, "TimeZoneBiasStamp"},
    {0x058, "NtBuildNumber"},
    {0x05C, "NtProductType"},
    {0x060, "ProductTypeIsValid"},
    {0x064, "Reserved0"},
    {0x068, "NtMajorVersion"},
    {0x06C, "NtMinorVersion"},
    {0x070, "ProcessorFeatures"},  // 64 bytes (2 * 32-bit arrays)
    {0x0B0, "Reserved1"},
    {0x0C0, "Reserved2"},
    {0x0F0, "NXSupportPolicy"},
    {0x0F4, "GdiHandleBuffer"},
    {0x100, "UserModeGlobalLogger"},
    {0x180, "HeapTracingThreshold"},
    {0x188, "CritSecTracingThreshold"},
    {0x190, "SuiteMask"},
    {0x194, "KdDebuggerEnabled"},
    {0x198, "MitigationPolicies"},
    {0x1A0, "CyclesPerYield"},
    {0x1A4, "XStateCompactionEnabled"},
    {0x1A8, "ProcessCookie"},
    {0x1B0, "ConsoleSessionForegroundProcessId"},
    {0x1B4, "TimeUpdateLock"},
    {0x1B8, "BaselineSystemTimeQpc"},
    {0x1C0, "BaselineInterruptTimeQpc"},
    {0x1C8, "QpcSystemTimeIncrement"},
    {0x1D0, "QpcInterruptTimeIncrement"},
    {0x1D8, "QpcSystemTimeIncrementShift"},
    {0x1DC, "QpcInterruptTimeIncrementShift"},
    {0x1E0, "QpcSystemTimeIncrementScale"},
    {0x1E8, "QpcInterruptTimeIncrementScale"},
    {0x1F0, "UserModeSharedPerformanceCounters"},
    {0x260, "TickCount"},
    {0x268, "TickCountQuad"},
    {0x270, "ReservedTickCountOverlay"},
    {0x2D0, "TimeSlip"},
    {0x2D4, "Reserved3"},
    {0x2E0, "SystemExpirationDate"},
    {0x2F0, "KdDebuggerNotPresent"},
    {0x2F4, "ActiveConsoleId"},
    {0x2F8, "DismountCount"},
    {0x2FC, "ComPlusPackage"},
    {0x300, "LastSystemRITEventTickCount"},
    {0x308, "NumberOfPhysicalPages"},
    {0x310, "SafeBootMode"},
    {0x314, "SharedDataFlags"},
    {0x318, "DbgErrorPortPresent"},
    {0x31C, "DbgElevationEnabled"},
    {0x320, "DbgVirtEnabled"},
    {0x324, "DbgInstallerDetectEnabled"},
    {0x328, "SystemDllNativeRelocation"},
    {0x32C, "DbgDynProcessorEnabled"},
    {0x330, "DbgSEHValidationEnabled"},
    {0x338, "QpcFrequency"},
    {0x340, "QpcShift"},
    {0x348, "QpcBias"},
    {0x350, "QpcBiasUserModeAccurate"},
    {0x360, "ActiveProcessorCount"},
    {0x364, "ActiveGroupCount"},
    {0x368, "Reserved4"},
    {0x370, "VolatileEnvironmentChecksum"},
    {0x378, "TelemetryCoverageHeader"},
    {0x380, "WheaErrorInjectionInterface"},
    {0x388, "EtwLoggerId"},
    {0x390, "ConsoleInputIdle"},
    {0x394, "TimeSinceLastInput"},
    {0x398, "PendingHotplugEvent"},
    {0x3A0, "UserCapFlags"},
    {0x3A4, "SafeBootModePolicy"},
};
static const std::map<uint64_t, std::string> teb_offsets = {
    {0x30, "ThreadLocalStoragePointer"},
    {0x58, "ClientId (ProcessId, ThreadId)"},
    {0x60, "ProcessEnvironmentBlock (PEB*)"},
    {0x148, "ThreadInfoBlock"},
    {0x2c8, "ActiveFrame"},
    {0x17f8, "ExceptionList"},
};

static const std::map<uint64_t, std::string> peb_offsets = {
    {0x000, "InheritedAddressSpace"},
    {0x002, "ReadImageFileExecOptions"},
    {0x003, "BeingDebugged"},
    {0x010, "ImageBaseAddress"},
    {0x018, "Ldr (PEB_LDR_DATA*)"},
    {0x020, "ProcessParameters"},
    {0x068, "SessionId"},
    {0x0F8, "AppCompatFlags"},
    {0x110, "CSDVersion"},
};

class Emulator {

public:
    uint64_t lastReloadedAddress = 0;
    Emulator(const std::string& exePath, const std::string& exeName);
    ~Emulator();

    bool initialize();
    bool start();

private:
    static void hook_syscall(uc_engine* uc, void* user_data);
    static void hook_cpuid(uc_engine* uc, void* user_data);
    static void hook_mem_write(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
    static void hook_mem_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
    static void hook_code(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
    static void hook_code_block(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
    static bool hook_mem_invalid(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
    void ReloadAtAddress(uint64_t address);
    uint64_t Poi(uc_x86_reg reg);
    std::string exeName;
    std::wstring wExeName;
    ProcessLoader loader;
    uc_engine* unicorn = nullptr;
    uint64_t instruction_count = 0;
};

```

`headers/Loader.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <TlHelp32.h>
#include <psapi.h>
#include <winternl.h>
#include <vector>
#include <string>
#include <unicorn/unicorn.h>
#include <unordered_map>

struct CpuRegisters {
    uint64_t rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp;
    uint64_t r8, r9, r10, r11, r12, r13, r14, r15;
    uint64_t rip, eflags;

    uint64_t xmm[16][16];
};
struct DebugState {
    DEBUG_EVENT lastEvent;
    bool hasPendingEvent = false;
};
typedef struct _THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    LONG Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION;


struct MemoryRegion {
    uint64_t base;
    size_t size;
    std::string name;

    MemoryRegion(uint64_t b, size_t s, const std::string& n = "") : base(b), size(s), name(n) {}
};


class ProcessLoader {
    bool isTlsMode_ = false;
    DebugState lastDebugState;
    DWORD tlsThreadId_ = 0;
    DWORD targetThreadId_ = 0;
    uint64_t breakpointAddress_ = 0;
    std::unordered_map<uint64_t, BYTE> originalBytes_;
    struct ExportedFunctionInfo {
        std::unordered_map<uint64_t, std::string> addrToName;
    };

    std::unordered_map<uint64_t, ExportedFunctionInfo> exportsCache_;
public:
    explicit ProcessLoader(const std::wstring& exePath);
    ~ProcessLoader();
    std::vector<MemoryRegion> memoryRegions_;
    bool LoadAndInspect(uc_engine* unicorn);
    CpuRegisters GetRegisters();
    DWORD RvaToOffset(LPVOID fileBase, DWORD rva);
    std::wstring GetModuleNameByAddress(uint64_t address);
    void LoadAllMemoryRegionsToUnicorn(uc_engine* unicorn);
    MemoryRegion GetMemoryRegionByName(const std::string& name) const;
    std::vector<MemoryRegion> GetMemoryRegion();
    bool MapSingleMemoryPageToUnicorn(uc_engine* unicorn, uint64_t address);
    std::string GetExportedFunctionNameByAddress(uint64_t addr);
    bool RemoveBreakpoint();
    bool resume_program();
    bool SetBreakpoint(void* address);
    void DebugLoop(uc_engine* unicorn);
    bool IsThreadAtBreakpoint( uint64_t breakpointAddress);
private:
    std::wstring exePath_;
    PROCESS_INFORMATION pi_{};
    bool initialized_;

    uint64_t GetTEBAddress(DWORD threadId);
    bool CreateTargetProcess();
    LPVOID GetEntryPointAddress();
    std::vector<LPVOID> GetAllTLSCallbackAddresses();
    bool SetBreakpointAtStartup(uc_engine* unicorn);
    std::string GetMappedFileNameAtAddress(LPVOID base);
    void DebugLoop();

    void Cleanup();
};

```

`main.cpp`:

```cpp
#include "./headers/Emulator.hpp"
#include "src/Logger.cpp"
#include <filesystem>

void printHelp() {
    Logger::logf(Logger::Color::GREEN, "Usage:");
    Logger::logf(Logger::Color::GREEN, "  emulator <full_path_to_exe>");
    Logger::logf(Logger::Color::GREEN, "\nExample:");
    Logger::logf(Logger::Color::GREEN, R"(  emulator "D:\helloworld.exe")");
    Logger::logf(Logger::Color::GREEN, "\nThis program runs the emulator on the specified executable.");
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        Logger::logf(Logger::Color::RED, "[-] No executable path provided.");
        printHelp();
        return -1;
    }

    std::string arg1 = argv[1];
    if (arg1 == "-h" || arg1 == "--help") {
        printHelp();
        return 0;
    }

    std::string fullPath = arg1;
    std::filesystem::path path(fullPath);

    if (!std::filesystem::exists(path)) {
        Logger::logf(Logger::Color::RED, "[-] The specified executable does not exist:");
        Logger::logf(Logger::Color::RED, fullPath.c_str());
        return -1;
    }

    std::string exepath = path.parent_path().string();
    if (!exepath.empty() && exepath.back() != '\\' && exepath.back() != '/')
        exepath += "\\";

    std::string exeName = path.filename().string();

    Logger::logf(Logger::Color::GREEN, "[+] Starting Emulator...");
    Logger::logf(Logger::Color::GREEN, ("    Executable path: " + exepath).c_str());
    Logger::logf(Logger::Color::GREEN, ("    Executable name: " + exeName).c_str());

    Emulator emulator(exepath, exeName);

    if (!emulator.initialize()) {
        Logger::logf(Logger::Color::RED, "[-] Emulator initialization failed.");
        return -1;
    }

    if (!emulator.start()) {
        Logger::logf(Logger::Color::RED, "[-] Emulation failed.");
        return -1;
    }

    Logger::logf(Logger::Color::GREEN, "[+] Emulation finished successfully.");
    return 0;
}

```

`src/Disassembler.cpp`:

```cpp
#include <unicorn/unicorn.h>
#include <capstone/capstone.h>
#include <iostream>

class Disassembler {
public:
    void print_registers(uc_engine* uc) {
        struct {
            uc_x86_reg reg;
            const char* name;
        } regs[] = {
            {UC_X86_REG_RIP, "RIP"}, {UC_X86_REG_RSP, "RSP"},
            {UC_X86_REG_RAX, "RAX"}, {UC_X86_REG_RBX, "RBX"},
            {UC_X86_REG_RCX, "RCX"}, {UC_X86_REG_RDX, "RDX"},
            {UC_X86_REG_RSI, "RSI"}, {UC_X86_REG_RDI, "RDI"},
            {UC_X86_REG_RBP, "RBP"}, {UC_X86_REG_R8,  "R8"},
            {UC_X86_REG_R9,  "R9"},  {UC_X86_REG_R10, "R10"},
            {UC_X86_REG_R11, "R11"}, {UC_X86_REG_R12, "R12"},
            {UC_X86_REG_R13, "R13"}, {UC_X86_REG_R14, "R14"},
            {UC_X86_REG_R15, "R15"},
        };

        for (auto& r : regs) {
            uint64_t val;
            uc_reg_read(uc, r.reg, &val);
            std::cout << r.name << ": 0x" << std::hex << val << "\n";
        }
    }

    void disassemble_at(uc_engine* uc, uint64_t rip) {
        uint8_t code[16];
        if (uc_mem_read(uc, rip, code, sizeof(code)) != UC_ERR_OK) {
            std::cerr << "[!] Cannot read memory for disassembly\n";
            return;
        }

        csh cs;
        cs_insn* insn;
        size_t count;

        if (cs_open(CS_ARCH_X86, CS_MODE_64, &cs) != CS_ERR_OK) {
            std::cerr << "[!] Failed to initialize Capstone\n";
            return;
        }

        count = cs_disasm(cs, code, sizeof(code), rip, 1, &insn);
        if (count > 0) {
         //   std::cout << "[+] Disassembly at RIP:\n";
            std::cout << "0x" << std::hex << insn[0].address << ": "
                << insn[0].mnemonic << " " << insn[0].op_str << "\n";
            cs_free(insn, count);
        }
        else {
            std::cerr << "[!] Failed to disassemble at RIP\n";
        }

        cs_close(&cs);
    }
};

```

`src/Emulator.cpp`:

```cpp
#include "../headers/Emulator.hpp"
#include "Disassembler.cpp"
#include "Logger.cpp"
#include <codecvt>

Emulator::Emulator(const std::string& exePath, const std::string& exeName)
    : exeName(exeName),
    wExeName(exeName.begin(), exeName.end()),
    loader(std::wstring(exePath.begin(), exePath.end()) + wExeName) {
}

Emulator::~Emulator() {
    if (unicorn) {
        uc_close(unicorn);
        Logger::logf(Logger::Color::GREEN, "[+] Unicorn engine closed. Instruction count: %llu", instruction_count);
    }
}
void Emulator::hook_mem_read(uc_engine* uc, uc_mem_type type, uint64_t address,
    int size, int64_t value, void* user_data) {
    uint64_t rip, rsp, gsbase;
    uc_reg_read(uc, UC_X86_REG_RIP, &rip);
    uc_reg_read(uc, UC_X86_REG_RSP, &rsp);
    uc_reg_read(uc, UC_X86_REG_GS_BASE, &gsbase);  

    Emulator* self = static_cast<Emulator*>(user_data);


    if (address >= rsp && address < rsp + 0x1000)
        return;

    const uint64_t kuser_base = 0x00000007FFE0000;
    const uint64_t kuser_size = 0x1000;

    // KUSER_SHARED_DATA
    if (address >= kuser_base && address < kuser_base + kuser_size) {
        uint64_t offset = address - kuser_base;
        std::string description = "Unknown";

        auto it = kuser_shared_data_offsets.upper_bound(offset);
        if (it != kuser_shared_data_offsets.begin()) {
            --it;
            uint64_t base_offset = it->first;
            uint64_t delta = offset - base_offset;
            if (delta == 0)
                description = it->second;
            else
                description = it->second + " + 0x" + std::to_string(delta);
        }

        Logger::logf(Logger::Color::YELLOW,
            "[KUSER_SHARED_DATA] Reading (%s) [RIP: 0x%llx]",
            description.c_str(), rip);
        return;
    }

    // TEB
    if (address >= gsbase && address < gsbase + 0x1000) {
        uint64_t offset = address - gsbase;
        std::string description = "Unknown";

        auto it = teb_offsets.upper_bound(offset);
        if (it != teb_offsets.begin()) {
            --it;
            uint64_t base_offset = it->first;
            uint64_t delta = offset - base_offset;
            if (delta == 0)
                description = it->second;
            else
                description = it->second + " + 0x" + std::to_string(delta);
        }

        Logger::logf(Logger::Color::MAGENTA,
            "[TEB] Reading (%s) at 0x%llx [RIP: 0x%llx]",
            description.c_str(), address, rip);
        return;
    }

    // PEB (TEB + 0x60)
    uint64_t peb_address = 0;
    uc_mem_read(uc, gsbase + 0x60, &peb_address, sizeof(peb_address));
    if (address >= peb_address && address < peb_address + 0x1000) {
        uint64_t offset = address - peb_address;
        std::string description = "Unknown";

        auto it = peb_offsets.upper_bound(offset);
        if (it != peb_offsets.begin()) {
            --it;
            uint64_t base_offset = it->first;
            uint64_t delta = offset - base_offset;
            if (delta == 0)
                description = it->second;
            else
                description = it->second + " + 0x" + std::to_string(delta);
        }

        Logger::logf(Logger::Color::CYAN,
            "[PEB] Reading (%s) at 0x%llx [RIP: 0x%llx]",
            description.c_str(), address, rip);
        return;
    }
  
        if (self->loader.GetModuleNameByAddress(address) == self->wExeName) {
            Logger::logf(Logger::Color::GREEN,
                "[SELF-READ] Reading from code memory at 0x%llx [RIP: 0x%llx]",
                address, rip);
            return;
        }
    

}




void Emulator::hook_mem_write(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data) {
        uint64_t rip, rsp;
        uc_reg_read(uc, UC_X86_REG_RIP, &rip);
        uc_reg_read(uc, UC_X86_REG_RSP, &rsp);
        Emulator* self = static_cast<Emulator*>(user_data);


        if (address >= rsp && address < rsp + 0x1000) {
            return;
        }

        if (self->loader.GetModuleNameByAddress(address) == self->wExeName) {
            Logger::logf(Logger::Color::GREEN,
                "[SELF-Write] Writing in code memory at 0x%llx [RIP: 0x%llx]",
                address, rip);
            return;
        }
  //  Logger::logf(Logger::Color::YELLOW, "[MEM-WRITE] Address: 0x%llx  ", rip);
}


void Emulator::hook_cpuid(uc_engine* uc, void* user_data) {
    uint64_t rip;
    uc_reg_read(uc, UC_X86_REG_RIP, &rip);
    Logger::logf(Logger::Color::MAGENTA, "[CPUID] Executed at 0x%llx", rip);
}


void Emulator::hook_syscall(uc_engine* uc, void* user_data) {
    uint64_t rip;
    uc_reg_read(uc, UC_X86_REG_RIP, &rip);
    uint64_t rax;
    uc_reg_read(uc, UC_X86_REG_RAX, &rax);
    Logger::logf(Logger::Color::CYAN, "[in Line SYSCALL]sycall : 0x%llx Executed at 0x%llx", rax, rip);
    Emulator* self = static_cast<Emulator*>(user_data);
    self->ReloadAtAddress(rip + 0x2);
    
}
void Emulator::hook_code(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {
    Emulator* self = static_cast<Emulator*>(user_data);
    self->instruction_count++;
    Disassembler dis;
    uint64_t rip;
    uc_reg_read(uc, UC_X86_REG_RIP, &rip);
    dis.disassemble_at(uc, rip);
   
    Logger::logf(Logger::Color::YELLOW, "[RPS]: 0x%llx", self->Poi(UC_X86_REG_RSP));
}

bool Emulator::hook_mem_invalid(uc_engine* uc, uc_mem_type type, uint64_t address,
    int size, int64_t value, void* user_data) {
    Emulator* self = static_cast<Emulator*>(user_data);

    uint64_t pageStart = address & ~0xFFF;

   // Logger::logf(Logger::Color::YELLOW, "[!] Invalid memory access @ 0x%llx (type: %d) -> trying to map page 0x%llx", address, type, pageStart);

    if (!self->loader.MapSingleMemoryPageToUnicorn(uc, pageStart)) {
        Logger::logf(Logger::Color::RED, "[-] Failed to dynamically map page at 0x%llx", pageStart);
        return false;  // do not retry access
    }

  //  Logger::logf(Logger::Color::GREEN, "[+] Successfully mapped missing page @ 0x%llx", pageStart);
    return true;  // retry memory access
}

void Emulator::hook_code_block(uc_engine* uc, uint64_t address, uint32_t size, void* user_data) {

    Emulator* self = static_cast<Emulator*>(user_data);

    std::wstring moduleName = self->loader.GetModuleNameByAddress(address);
    if (moduleName != self->wExeName) {

    std::string funcName = self->loader.GetExportedFunctionNameByAddress(address);

    uint64_t return_address = self->Poi(UC_X86_REG_RSP);



    if (!funcName.empty()) {
        if (self->lastReloadedAddress != return_address) {
            Logger::logf(Logger::Color::CYAN, "[+] %s in %ls", funcName.c_str(), moduleName.c_str());
            self->lastReloadedAddress = return_address;
            self->ReloadAtAddress(return_address);
        }
    }


    }
}

void Emulator::ReloadAtAddress(uint64_t address) {
    
    loader.RemoveBreakpoint();
    loader.SetBreakpoint((void*)address);
    loader.resume_program();
    loader.DebugLoop(unicorn);

}

uint64_t Emulator::Poi(uc_x86_reg reg) {
    uint64_t addr = 0;
    if (uc_reg_read(unicorn, reg, &addr) != UC_ERR_OK) {
        Logger::logf(Logger::Color::RED, "[-] Failed to read register");
        return 0;
    }

    uint64_t value = 0;
    if (uc_mem_read(unicorn, addr, &value, sizeof(uint64_t)) != UC_ERR_OK) {
        Logger::logf(Logger::Color::RED, "[-] Failed to read memory at 0x%llx", addr);
        return 0;
    }

    return value;
}
bool Emulator::initialize() {
    Logger::logf(Logger::Color::GREEN, "[+] Initializing Unicorn Engine...");

    uc_err err = uc_open(UC_ARCH_X86, UC_MODE_64, &unicorn);
    if (err != UC_ERR_OK) {
        Logger::logf(Logger::Color::RED, "[-] Failed to initialize Unicorn engine: %s", uc_strerror(err));
        return false;
    }

    if (!loader.LoadAndInspect(unicorn)) {
        Logger::logf(Logger::Color::RED, "[-] Failed to create and debug process");
        return false;
    }

    loader.LoadAllMemoryRegionsToUnicorn(unicorn);
    Logger::logf(Logger::Color::GREEN, "[+] Memory regions loaded into Unicorn.");

    return true;
}

bool Emulator::start() {

    uc_hook trace_hook_block;

    uc_err err;

         err = uc_hook_add(unicorn, &trace_hook_block, UC_HOOK_BLOCK, (void*)hook_code_block, this, 1,0 );
        if (err != UC_ERR_OK) {
            Logger::logf(Logger::Color::RED, "[-] Failed to add code BLOCK hook : %s", uc_strerror(err));
            return false;
    
        }


    // uc_hook trace_hook;

   //   err = uc_hook_add(unicorn, &trace_hook, UC_HOOK_CODE, (void*)hook_code, this, 1, 0);

    if (err != UC_ERR_OK) {
        Logger::logf(Logger::Color::RED, "[-] Failed to add code hook: %s", uc_strerror(err));
        return false;
    }


    uc_hook invalid_mem_hook;
    err = uc_hook_add(unicorn, &invalid_mem_hook,
        UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED | UC_HOOK_MEM_FETCH_UNMAPPED,
        (void*)hook_mem_invalid, this, 1, 0);

    if (err != UC_ERR_OK) {
        Logger::logf(Logger::Color::RED, "[-] Failed to add invalid memory hook: %s", uc_strerror(err));
        return false;
    }

    uc_hook mem_read_hook;
    err = uc_hook_add(unicorn, &mem_read_hook, UC_HOOK_MEM_READ, (void*) hook_mem_read, this, 1, 0);
    if (err != UC_ERR_OK) {
        Logger::logf(Logger::Color::RED, "[-] Failed to add memory read hook: %s", uc_strerror(err));
    }

    uc_hook mem_write_hook;
    err = uc_hook_add(unicorn, &mem_write_hook, UC_HOOK_MEM_WRITE, (void*)hook_mem_write, this, 1, 0);
    if (err != UC_ERR_OK) {
        Logger::logf(Logger::Color::RED, "[-] Failed to add memory write hook: %s", uc_strerror(err));
    }

    uc_hook cpuid_hook;
    uc_hook_add(unicorn, &cpuid_hook, UC_HOOK_INSN, hook_cpuid, this, 1, 0,
        UC_X86_INS_CPUID);


    // SYSCALL instruction
    uc_hook syscall_hook;
    uc_hook_add(unicorn, &syscall_hook, UC_HOOK_INSN, hook_syscall, this, 1, 0,
        UC_X86_INS_SYSCALL);



    uint64_t startAddr;
    uc_reg_read(unicorn, UC_X86_REG_RIP, &startAddr);
    Logger::logf(Logger::Color::CYAN, "[+] Starting emulation from RIP: 0x%llx", startAddr);

    err = uc_emu_start(unicorn, startAddr, 0, 0, 0);
    if (err != UC_ERR_OK) {
        uint64_t rip;
        uc_reg_read(unicorn, UC_X86_REG_RIP, &rip);
        Disassembler disassembler;
        disassembler.disassemble_at(unicorn, rip);
        disassembler.print_registers(unicorn);
        Logger::logf(Logger::Color::RED, "[-] Unicorn emulation error: %s at RIP: 0x%llx From : %ls", uc_strerror(err), rip, loader.GetModuleNameByAddress(rip).c_str());
        return false;
    }

    uint64_t rip;
    uc_reg_read(unicorn, UC_X86_REG_RIP, &rip);
    Logger::logf(Logger::Color::GREEN, "[+] Unicorn emulation finished successfully at RIP: 0x%llx", rip);
    return true;
}

```

`src/Loader.cpp`:

```cpp
#include "../headers/Loader.hpp"
#include <Windows.h>
#include <TlHelp32.h>
#include <unicorn/unicorn.h>
#include "../src/Logger.cpp" 

#pragma comment(lib, "ntdll.lib")

ProcessLoader::ProcessLoader(const std::wstring& exePath)
    : exePath_(exePath), initialized_(false) {
    ZeroMemory(&pi_, sizeof(pi_));
    Logger::logf(Logger::Color::GREEN, "[+] ProcessLoader created for: %ls", exePath_.c_str());
}

ProcessLoader::~ProcessLoader() {
    Logger::logf(Logger::Color::GREEN, "[+] Destructor called, cleaning up...");
    Cleanup();
}

bool ProcessLoader::LoadAndInspect(uc_engine* unicorn) {
    Logger::logf(Logger::Color::GREEN, "[+] Starting process creation and inspection...");
    if (!CreateTargetProcess()) return false;
    if (!SetBreakpointAtStartup(unicorn)) return false;
    DebugLoop();
    return true;
}

bool ProcessLoader::CreateTargetProcess() {
    STARTUPINFOW si = { sizeof(si) };
    if (CreateProcessW(exePath_.c_str(), nullptr, nullptr, nullptr, FALSE,
        DEBUG_ONLY_THIS_PROCESS | CREATE_SUSPENDED, nullptr, nullptr, &si, &pi_)) {
        initialized_ = true;
        Logger::logf(Logger::Color::GREEN, "[+] Process created successfully.");
        return true;
    }
    Logger::logf(Logger::Color::RED, "[-] CreateProcessW failed: %lu", GetLastError());
    return false;
}
LPVOID ProcessLoader::GetEntryPointAddress() {


    PROCESS_BASIC_INFORMATION pbi{};
    if (NtQueryInformationProcess(pi_.hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr) != 0)
        return nullptr;


    PEB peb{};
    if (!ReadProcessMemory(pi_.hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), nullptr)) return nullptr;

    BYTE* imageBase = reinterpret_cast<BYTE*>(peb.Reserved3[1]);


    IMAGE_DOS_HEADER dos{};
    IMAGE_NT_HEADERS64 nt{};

    if (!ReadProcessMemory(pi_.hProcess, imageBase, &dos, sizeof(dos), nullptr)) return nullptr;
    if (!ReadProcessMemory(pi_.hProcess, imageBase + dos.e_lfanew, &nt, sizeof(nt), nullptr)) return nullptr;

    return imageBase + nt.OptionalHeader.AddressOfEntryPoint;
}


std::vector<LPVOID> ProcessLoader::GetAllTLSCallbackAddresses() {
    std::vector<LPVOID> callbacks;

    PROCESS_BASIC_INFORMATION pbi{};
    if (NtQueryInformationProcess(pi_.hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr) != 0)
        return callbacks;

    PEB peb{};
    if (!ReadProcessMemory(pi_.hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), nullptr)) return callbacks;

    BYTE* imageBase = reinterpret_cast<BYTE*>(peb.Reserved3[1]);
    IMAGE_DOS_HEADER dos{};
    if (!ReadProcessMemory(pi_.hProcess, imageBase, &dos, sizeof(dos), nullptr)) return callbacks;

    IMAGE_NT_HEADERS64 nt{};
    if (!ReadProcessMemory(pi_.hProcess, imageBase + dos.e_lfanew, &nt, sizeof(nt), nullptr)) return callbacks;

    IMAGE_DATA_DIRECTORY tlsDir = nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
    if (tlsDir.VirtualAddress == 0 || tlsDir.Size == 0) return callbacks;

    IMAGE_TLS_DIRECTORY64 tls{};
    if (!ReadProcessMemory(pi_.hProcess, imageBase + tlsDir.VirtualAddress, &tls, sizeof(tls), nullptr)) return callbacks;

    ULONGLONG addr = tls.AddressOfCallBacks;
    if (addr == 0) return callbacks;

    while (true) {
        ULONGLONG cbVA = 0;
        if (!ReadProcessMemory(pi_.hProcess, reinterpret_cast<LPCVOID>(addr), &cbVA, sizeof(cbVA), nullptr))
            break;
        if (cbVA == 0) break;
        callbacks.push_back(reinterpret_cast<LPVOID>(cbVA));
        addr += sizeof(ULONGLONG);
    }

    return callbacks;
}



bool ProcessLoader::SetBreakpointAtStartup(uc_engine* unicorn) {
    auto callbacks = GetAllTLSCallbackAddresses();
    isTlsMode_ = !callbacks.empty();

    if (!isTlsMode_) {
        Logger::logf(Logger::Color::YELLOW, "[-] No TLS callbacks found. Falling back to entry point.");
        LPVOID entry = GetEntryPointAddress();
        if (!entry) {
            Logger::logf(Logger::Color::RED, "[-] No valid entry point address.");
            return false;
        }
        callbacks.push_back(entry);
    }

    for (auto bpAddr : callbacks) {
        BYTE originalByte = 0;
        if (!ReadProcessMemory(pi_.hProcess, bpAddr, &originalByte, 1, nullptr)) continue;

        originalBytes_[(uint64_t)bpAddr] = originalByte;
        BYTE int3 = 0xCC;
        if (!WriteProcessMemory(pi_.hProcess, bpAddr, &int3, 1, nullptr)) continue;
        FlushInstructionCache(pi_.hProcess, bpAddr, 1);

        breakpointAddress_ = (uint64_t)bpAddr;
        Logger::logf(Logger::Color::GREEN, "[+] Breakpoint set at 0x%llx", breakpointAddress_);
        break;
    }

    if (ResumeThread(pi_.hThread) == (DWORD)-1) {
        Logger::logf(Logger::Color::RED, "[-] ResumeThread failed: %lu", GetLastError());
        return false;
    }
    return true;
}

bool ProcessLoader::IsThreadAtBreakpoint( uint64_t breakpointAddress) {
    HANDLE hThread = pi_.hThread;
    CONTEXT ctx = {};
    ctx.ContextFlags = CONTEXT_CONTROL;

#ifdef _WIN64
    if (!GetThreadContext(hThread, &ctx)) {
        ResumeThread(hThread);
        return false;
    }

    bool isAtBp = (ctx.Rip == breakpointAddress);
#else
    if (!GetThreadContext(hThread, &ctx)) {
        ResumeThread(hThread);
        return false;
    }

    bool isAtBp = (ctx.Eip == breakpointAddress);
#endif

    ResumeThread(hThread);
    return isAtBp;
}
void ProcessLoader::DebugLoop() {
    DEBUG_EVENT dbgEvent;
    while (WaitForDebugEvent(&dbgEvent, INFINITE)) {
        if (dbgEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT &&
            dbgEvent.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT) {

            DWORD hitThreadId = dbgEvent.dwThreadId;
            lastDebugState.lastEvent = dbgEvent;
            lastDebugState.hasPendingEvent = true;
            HANDLE hThread = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, hitThreadId);
            if (!hThread) {
                Logger::logf(Logger::Color::RED, "[-] OpenThread failed for thread %lu", hitThreadId);
                ContinueDebugEvent(dbgEvent.dwProcessId, dbgEvent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);
                continue;
            }

            CONTEXT ctx = {};
            ctx.ContextFlags = CONTEXT_ALL;
            if (!GetThreadContext(hThread, &ctx)) {
                CloseHandle(hThread);
                ContinueDebugEvent(dbgEvent.dwProcessId, dbgEvent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);
                continue;
            }

            if (ctx.Rip == breakpointAddress_ + 1 || ctx.Rip == breakpointAddress_) {
                ctx.Rip = breakpointAddress_;
                SetThreadContext(hThread, &ctx);
                tlsThreadId_ = hitThreadId;
                CloseHandle(hThread);
                break;
            }
            CloseHandle(hThread);
        }

        ContinueDebugEvent(dbgEvent.dwProcessId, dbgEvent.dwThreadId, DBG_CONTINUE);
    }
}

void ProcessLoader::DebugLoop(uc_engine* unicorn) {
    DEBUG_EVENT dbgEvent;
    while (WaitForDebugEvent(&dbgEvent, INFINITE)) {
        if (dbgEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT &&
            dbgEvent.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT) {

            DWORD hitThreadId = dbgEvent.dwThreadId;
            lastDebugState.lastEvent = dbgEvent;
            lastDebugState.hasPendingEvent = true;
            HANDLE hThread = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, hitThreadId);
            if (!hThread) {
                Logger::logf(Logger::Color::RED, "[-] OpenThread failed for thread %lu", hitThreadId);
                ContinueDebugEvent(dbgEvent.dwProcessId, dbgEvent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);
                continue;
            }

            CONTEXT ctx = {};
            ctx.ContextFlags = CONTEXT_ALL;
            if (!GetThreadContext(hThread, &ctx)) {
                CloseHandle(hThread);
                ContinueDebugEvent(dbgEvent.dwProcessId, dbgEvent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);
                continue;
            }


            if (ctx.Rip == breakpointAddress_ + 1 || ctx.Rip == breakpointAddress_) {
                ctx.Rip = breakpointAddress_;
                SetThreadContext(hThread, &ctx);


                LoadAllMemoryRegionsToUnicorn(unicorn);

                tlsThreadId_ = hitThreadId;
                CloseHandle(hThread);
                break;
            }
         
            CloseHandle(hThread);
        }
        else {
            exit(0);
        }
        ContinueDebugEvent(dbgEvent.dwProcessId, dbgEvent.dwThreadId, DBG_CONTINUE);
    }
}


CpuRegisters ProcessLoader::GetRegisters() {
    CONTEXT ctx = { .ContextFlags = CONTEXT_ALL };
    CpuRegisters regs{};

    HANDLE hThread = (tlsThreadId_ != GetThreadId(pi_.hThread))
        ? OpenThread(THREAD_ALL_ACCESS, FALSE, tlsThreadId_)
        : pi_.hThread;

    if (!hThread) return regs;
    if (GetThreadContext(hThread, &ctx)) {
        regs.rax = ctx.Rax; regs.rbx = ctx.Rbx;
        regs.rcx = ctx.Rcx; regs.rdx = ctx.Rdx;
        regs.rsi = ctx.Rsi; regs.rdi = ctx.Rdi;
        regs.rbp = ctx.Rbp; regs.rsp = ctx.Rsp;
        regs.r8 = ctx.R8;   regs.r9 = ctx.R9;
        regs.r10 = ctx.R10; regs.r11 = ctx.R11;
        regs.r12 = ctx.R12; regs.r13 = ctx.R13;
        regs.r14 = ctx.R14; regs.r15 = ctx.R15;
        regs.rip = ctx.Rip;
    }

    if (hThread != pi_.hThread) CloseHandle(hThread);
   // Logger::logf(Logger::Color::GREEN, "[+] Registers captured from Thread ID: %lu", tlsThreadId_);
    return regs;
}

void ProcessLoader::LoadAllMemoryRegionsToUnicorn(uc_engine* unicorn) {
    uint8_t* addr = nullptr;
    MEMORY_BASIC_INFORMATION mbi{};

    while (VirtualQueryEx(pi_.hProcess, addr, &mbi, sizeof(mbi)) == sizeof(mbi)) {
        DWORD prot = mbi.Protect & 0xFF;
        bool readable = (prot & PAGE_READONLY) || (prot & PAGE_READWRITE) ||
            (prot & PAGE_EXECUTE_READ) || (prot & PAGE_EXECUTE_READWRITE);

        if (mbi.State == MEM_COMMIT && readable && (mbi.Type == MEM_IMAGE || mbi.Type == MEM_PRIVATE)) {
            std::vector<uint8_t> buffer(mbi.RegionSize);
            SIZE_T bytesRead = 0;

            if (ReadProcessMemory(pi_.hProcess, mbi.BaseAddress, buffer.data(), mbi.RegionSize, &bytesRead) && bytesRead > 0) {
                int ucProt = 0;
                switch (prot) {
                case PAGE_READONLY: ucProt = UC_PROT_READ; break;
                case PAGE_READWRITE:
                case PAGE_WRITECOPY: ucProt = UC_PROT_READ | UC_PROT_WRITE; break;
                case PAGE_EXECUTE: ucProt = UC_PROT_EXEC; break;
                case PAGE_EXECUTE_READ: ucProt = UC_PROT_EXEC | UC_PROT_READ; break;
                case PAGE_EXECUTE_READWRITE:
                case PAGE_EXECUTE_WRITECOPY: ucProt = UC_PROT_EXEC | UC_PROT_READ | UC_PROT_WRITE; break;
                default: ucProt = UC_PROT_ALL; break;
                }

                bool alreadyMapped = false;
                for (const MemoryRegion& region : memoryRegions_) {
                    uint64_t base = region.base;
                    size_t size = region.size;
                    if ((uint64_t)mbi.BaseAddress >= base && (uint64_t)mbi.BaseAddress < base + size) {
                        alreadyMapped = true;
                        break;
                    }
                }

                if (!alreadyMapped) {
                    uc_err err = uc_mem_map(unicorn, (uint64_t)mbi.BaseAddress, mbi.RegionSize, ucProt);
                    if (err != UC_ERR_OK) {
                        Logger::logf(Logger::Color::YELLOW, "[*] uc_mem_map failed with prot 0x%x at 0x%llx, retrying with UC_PROT_ALL...", ucProt, (uint64_t)mbi.BaseAddress);
                        err = uc_mem_map(unicorn, (uint64_t)mbi.BaseAddress, mbi.RegionSize, UC_PROT_ALL);
                        if (err != UC_ERR_OK) {
                            Logger::logf(Logger::Color::RED, "[-] uc_mem_map still failed at 0x%llx", (uint64_t)mbi.BaseAddress);
                            addr += mbi.RegionSize;
                            continue;
                        }
                    }
                }

                for (auto& [patchAddr, origByte] : originalBytes_) {
                    if (patchAddr >= (uint64_t)mbi.BaseAddress && patchAddr < (uint64_t)mbi.BaseAddress + bytesRead) {
                        buffer[patchAddr - (uint64_t)mbi.BaseAddress] = origByte;
                    }
                }

                uc_mem_write(unicorn, (uint64_t)mbi.BaseAddress, buffer.data(), bytesRead);

                if (!alreadyMapped) {
                    std::string regionName = GetMappedFileNameAtAddress(mbi.BaseAddress);
                    memoryRegions_.emplace_back((uint64_t)mbi.BaseAddress, mbi.RegionSize, regionName);
                }
            }
        }
        addr += mbi.RegionSize;
    }

    const CpuRegisters& regs = GetRegisters();
    struct {
        int id;
        uint64_t val;
    } reg_map[] = {
        { UC_X86_REG_RAX, regs.rax },
        { UC_X86_REG_RBX, regs.rbx },
        { UC_X86_REG_RCX, regs.rcx },
        { UC_X86_REG_RDX, regs.rdx },
        { UC_X86_REG_RSI, regs.rsi },
        { UC_X86_REG_RDI, regs.rdi },
        { UC_X86_REG_RBP, regs.rbp },
        { UC_X86_REG_RSP, regs.rsp },
        { UC_X86_REG_RIP, regs.rip },
        { UC_X86_REG_R8, regs.r8 },
        { UC_X86_REG_R9, regs.r9 },
        { UC_X86_REG_R10, regs.r10 },
        { UC_X86_REG_R11, regs.r11 },
        { UC_X86_REG_R12, regs.r12 },
        { UC_X86_REG_R13, regs.r13 },
        { UC_X86_REG_R14, regs.r14 },
        { UC_X86_REG_R15, regs.r15 }
    };
    for (auto& r : reg_map) {
        uc_reg_write(unicorn, r.id, &r.val);
    }

    uint64_t teb = GetTEBAddress(tlsThreadId_);
    uc_reg_write(unicorn, UC_X86_REG_GS_BASE, &teb);
    // Logger::logf(Logger::Color::GREEN, "[+] GS Base set to TEB address: 0x%llx", teb);
}




std::wstring ProcessLoader::GetModuleNameByAddress(uint64_t address) {
    for (const auto& region : memoryRegions_) {
        if (address >= region.base && address < region.base + region.size) {
            return region.name.empty() ? L"(unknown)" : std::wstring(region.name.begin(), region.name.end());
        }
    }
    return L"(not found)";
}

uint64_t ProcessLoader::GetTEBAddress(DWORD threadId) {

    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, threadId);
    if (!hThread) return 0;

    THREAD_BASIC_INFORMATION tbi{};
    NTSTATUS status = NtQueryInformationThread(hThread, (THREADINFOCLASS)0, &tbi, sizeof(tbi), nullptr);
    CloseHandle(hThread);
    return status == 0 ? reinterpret_cast<uint64_t>(tbi.TebBaseAddress) : 0;
}

MemoryRegion ProcessLoader::GetMemoryRegionByName(const std::string& name) const {
    uint64_t minBase = UINT64_MAX;
    uint64_t maxEnd = 0;

    for (const auto& region : memoryRegions_) {
        if (region.name == name) {
            if (region.base < minBase)
                minBase = region.base;

            uint64_t end = region.base + region.size;
            if (end > maxEnd)
                maxEnd = end;
        }
    }

    if (minBase == UINT64_MAX || maxEnd == 0)
        return MemoryRegion(0, 0, ""); // Not found

    return MemoryRegion(minBase, maxEnd - minBase, name);
}

std::vector<MemoryRegion> ProcessLoader::GetMemoryRegion() {
    return memoryRegions_;
}

std::string ProcessLoader::GetMappedFileNameAtAddress(LPVOID base) {
    char filename[MAX_PATH] = { 0 };
    if (GetMappedFileNameA(pi_.hProcess, base, filename, MAX_PATH)) {
        std::string fullPath(filename);
        size_t lastSlash = fullPath.find_last_of("\\/");
        if (lastSlash != std::string::npos) {
            return fullPath.substr(lastSlash + 1);
        }
        return fullPath;
    }
    return "";
}
bool ProcessLoader::MapSingleMemoryPageToUnicorn(uc_engine* unicorn, uint64_t address) {
    constexpr size_t pageSize = 0x1000;
    uint64_t pageBase = address & ~(pageSize - 1);

    MEMORY_BASIC_INFORMATION mbi{};
    SIZE_T result = VirtualQueryEx(pi_.hProcess, reinterpret_cast<LPCVOID>(pageBase), &mbi, sizeof(mbi));
    if (result != sizeof(mbi)) {
       Logger::logf(Logger::Color::RED, "[-] VirtualQueryEx failed at 0x%llx (returned size = 0x%llx), error = %lu",pageBase, result, GetLastError());
        return false;
    }

  //  Logger::logf(Logger::Color::CYAN,"[*] VirtualQueryEx: Base=0x%llx, RegionSize=0x%llx, State=0x%lx, Protect=0x%lx, Type=0x%lx",reinterpret_cast<uint64_t>(mbi.BaseAddress),mbi.RegionSize,mbi.State,mbi.Protect,mbi.Type);

    DWORD prot = mbi.Protect;

    // Check if already mapped
    for (const auto& region : memoryRegions_) {
        if (pageBase >= region.base && pageBase < region.base + region.size) {
            Logger::logf(Logger::Color::YELLOW,
                "[!] Page 0x%llx already mapped (inside region base=0x%llx size=0x%llx).",
                pageBase, region.base, region.size);
            return true;
        }
    }

    // Determine UC protection flags
    auto GetUnicornProtection = [](DWORD protect) -> int {
        int flags = UC_PROT_READ;
        if (protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
            flags |= UC_PROT_EXEC;
        if (protect & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
            flags |= UC_PROT_WRITE;
        return flags;
        };

    bool readable = (prot & PAGE_READONLY) || (prot & PAGE_READWRITE) ||
        (prot & PAGE_EXECUTE_READ) || (prot & PAGE_EXECUTE_READWRITE);

    if ((prot & PAGE_GUARD) || prot == PAGE_NOACCESS || !(mbi.State == MEM_COMMIT && readable)) {
      //  Logger::logf(Logger::Color::YELLOW,
       //     "[!] Memory page 0x%llx has limited access (State=0x%lx, prot=0x%lx), trying ReadProcessMemory fallback.",
       //     pageBase, mbi.State, prot);

        std::vector<uint8_t> buffer(pageSize, 0);
        SIZE_T bytesRead = 0;
        if (ReadProcessMemory(pi_.hProcess, reinterpret_cast<LPCVOID>(pageBase), buffer.data(), pageSize, &bytesRead) && bytesRead > 0) {
          //  Logger::logf(Logger::Color::CYAN,
         //       "[*] ReadProcessMemory fallback succeeded: read 0x%llx bytes from 0x%llx",
          //      bytesRead, pageBase);

            int ucProt = GetUnicornProtection(prot);

            uc_err err = uc_mem_map(unicorn, pageBase, pageSize, ucProt);
            if (err != UC_ERR_OK) {
                Logger::logf(Logger::Color::RED,
                    "[-] uc_mem_map (fallback) failed at 0x%llx: %s",
                    pageBase, uc_strerror(err));
                return false;
            }

            uc_mem_write(unicorn, pageBase, buffer.data(), bytesRead);
            memoryRegions_.push_back({ pageBase, pageSize, "ReadMemoryFallback" });
          //  Logger::logf(Logger::Color::GREEN,
          //      "[+] Successfully mapped missing page @ 0x%llx with fallback.",
          //      pageBase);
            return true;
        }
        else {
            Logger::logf(Logger::Color::RED,
                "[-] ReadProcessMemory fallback failed at 0x%llx, error = %lu",
                pageBase, GetLastError());
            return false;
        }
    }

    // Standard case - fully accessible memory
    std::vector<uint8_t> buffer(pageSize);
    SIZE_T bytesRead = 0;
    if (!ReadProcessMemory(pi_.hProcess, reinterpret_cast<LPCVOID>(pageBase), buffer.data(), pageSize, &bytesRead) || bytesRead == 0) {
        Logger::logf(Logger::Color::RED,
            "[-] ReadProcessMemory failed at 0x%llx (bytesRead=0x%llx), error = %lu",
            pageBase, bytesRead, GetLastError());
        return false;
    }

    Logger::logf(Logger::Color::CYAN,
        "[*] Successfully read 0x%llx bytes from target at 0x%llx",
        bytesRead, pageBase);

    int ucProt = GetUnicornProtection(prot);

    Logger::logf(Logger::Color::CYAN,
        "[*] Mapping 0x%llx with UC protection 0x%x (Windows prot=0x%lx)",
        pageBase, ucProt, prot);

    uc_err err = uc_mem_map(unicorn, pageBase, pageSize, ucProt);
    if (err != UC_ERR_OK) {
        Logger::logf(Logger::Color::RED,
            "[-] uc_mem_map failed at 0x%llx: %s",
            pageBase, uc_strerror(err));
        return false;
    }

    uc_mem_write(unicorn, pageBase, buffer.data(), bytesRead);
    Logger::logf(Logger::Color::GREEN,
        "[+] Page at 0x%llx mapped to Unicorn with %llu bytes written.",
        pageBase, bytesRead);

    std::string name = GetMappedFileNameAtAddress(reinterpret_cast<void*>(pageBase));
    Logger::logf(Logger::Color::CYAN,
        "[*] Mapped file name for 0x%llx: %s",
        pageBase, name.c_str());

    memoryRegions_.push_back({ pageBase, pageSize, name });

    return true;
}




bool ProcessLoader::resume_program() {
    if (!initialized_) {
        Logger::logf(Logger::Color::RED, "[-] Process not initialized, cannot resume.");
        return false;
    }

    if (lastDebugState.hasPendingEvent) {
        if (ContinueDebugEvent(lastDebugState.lastEvent.dwProcessId,
            lastDebugState.lastEvent.dwThreadId,
            DBG_CONTINUE)) {
            lastDebugState.hasPendingEvent = false;
            //Logger::logf(Logger::Color::GREEN, "[+] Process resumed from suspended state.");
            return true;
        }
        else {
            Logger::logf(Logger::Color::RED, "[-] Failed to continue debug event: %lu", GetLastError());
            return false;
        }
    }

    Logger::logf(Logger::Color::YELLOW, "[*] No pending debug event to resume.");
    return false;
}

bool ProcessLoader::SetBreakpoint(void* address) {
    BYTE originalByte = 0;


    if (!ReadProcessMemory(pi_.hProcess, address, &originalByte, 1, nullptr)) {
        Logger::logf(Logger::Color::RED, "[-] Failed to read original byte at 0x%llx", (uint64_t)address);
        return false;
    }


    originalBytes_[(uint64_t)address] = originalByte;

    BYTE int3 = 0xCC;

    if (!WriteProcessMemory(pi_.hProcess, address, &int3, 1, nullptr)) {
        Logger::logf(Logger::Color::RED, "[-] Failed to write breakpoint at 0x%llx", (uint64_t)address);
        return false;
    }

    if (!FlushInstructionCache(pi_.hProcess, address, 1)) {
        Logger::logf(Logger::Color::YELLOW, "[!] FlushInstructionCache failed at 0x%llx", (uint64_t)address);
       
    }

    breakpointAddress_ = (uint64_t)address;
   // Logger::logf(Logger::Color::GREEN, "[+] Breakpoint set at 0x%llx", breakpointAddress_);

    return true;
}

std::string ProcessLoader::GetExportedFunctionNameByAddress(uint64_t addr) {
    HMODULE hMods[1024];
    DWORD cbNeeded;
    if (!EnumProcessModules(pi_.hProcess, hMods, sizeof(hMods), &cbNeeded)) {
        Logger::logf(Logger::Color::RED, "[-] EnumProcessModules failed.");
        return "";
    }

    for (unsigned int i = 0; i < (cbNeeded / sizeof(HMODULE)); ++i) {
        MODULEINFO modInfo;
        if (!GetModuleInformation(pi_.hProcess, hMods[i], &modInfo, sizeof(modInfo)))
            continue;

        uint64_t base = reinterpret_cast<uint64_t>(modInfo.lpBaseOfDll);
        uint64_t end = base + modInfo.SizeOfImage;
        if (addr < base || addr >= end)
            continue;


        auto it = exportsCache_.find(base);
        if (it != exportsCache_.end()) {
            auto& cache = it->second;
            auto found = cache.addrToName.find(addr);
            if (found != cache.addrToName.end())
                return found->second;
            else
                return "";
        }


        char path[MAX_PATH];
        if (!GetModuleFileNameExA(pi_.hProcess, hMods[i], path, MAX_PATH))
            continue;

        HANDLE hFile = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);
        if (hFile == INVALID_HANDLE_VALUE)
            continue;

        HANDLE hMapping = CreateFileMappingA(hFile, nullptr, PAGE_READONLY, 0, 0, nullptr);
        if (!hMapping) {
            CloseHandle(hFile);
            continue;
        }

        LPVOID fileBase = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
        if (!fileBase) {
            CloseHandle(hMapping);
            CloseHandle(hFile);
            continue;
        }

        PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)fileBase;
        PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((BYTE*)fileBase + dos->e_lfanew);
        DWORD exportRVA = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (!exportRVA) {
            UnmapViewOfFile(fileBase);
            CloseHandle(hMapping);
            CloseHandle(hFile);
            continue;
        }

        PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)fileBase +
            RvaToOffset(fileBase, exportRVA));

        DWORD* functions = (DWORD*)((BYTE*)fileBase + RvaToOffset(fileBase, exportDir->AddressOfFunctions));
        DWORD* names = (DWORD*)((BYTE*)fileBase + RvaToOffset(fileBase, exportDir->AddressOfNames));
        WORD* ordinals = (WORD*)((BYTE*)fileBase + RvaToOffset(fileBase, exportDir->AddressOfNameOrdinals));

        ExportedFunctionInfo cache;
        for (DWORD j = 0; j < exportDir->NumberOfFunctions; ++j) {
            uint64_t funcAddr = base + functions[j];
            std::string funcName;
            for (DWORD k = 0; k < exportDir->NumberOfNames; ++k) {
                if (ordinals[k] == j) {
                    const char* name = (const char*)fileBase + RvaToOffset(fileBase, names[k]);
                    funcName = std::string(name);
                    break;
                }
            }
            cache.addrToName[funcAddr] = funcName;
        }

        UnmapViewOfFile(fileBase);
        CloseHandle(hMapping);
        CloseHandle(hFile);

        exportsCache_[base] = std::move(cache);


        auto found = exportsCache_[base].addrToName.find(addr);
        if (found != exportsCache_[base].addrToName.end())
            return found->second;
        else
            return "";
    }

    return "";
}

DWORD ProcessLoader::RvaToOffset(LPVOID fileBase, DWORD rva) {
    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)fileBase;
    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((BYTE*)fileBase + dos->e_lfanew);
    PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt);

    for (int i = 0; i < nt->FileHeader.NumberOfSections; i++, section++) {
        DWORD sectVA = section->VirtualAddress;
        DWORD sectSize = section->Misc.VirtualSize;
        if (rva >= sectVA && rva < sectVA + sectSize) {
            return section->PointerToRawData + (rva - sectVA);
        }
    }

    return rva;
}
bool ProcessLoader::RemoveBreakpoint() {
    auto it = originalBytes_.find(breakpointAddress_);
    if (it == originalBytes_.end()) return false;

    BYTE originalByte = it->second;
    SIZE_T bytesWritten = 0;
    if (!WriteProcessMemory(pi_.hProcess, (LPVOID)breakpointAddress_, &originalByte, 1, &bytesWritten) || bytesWritten != 1) {
        Logger::logf(Logger::Color::RED, "[-] Failed to restore original byte at 0x%llx", breakpointAddress_);
        return false;
    }
    FlushInstructionCache(pi_.hProcess, (LPVOID)breakpointAddress_, 1);
   // Logger::logf(Logger::Color::GREEN, "[+] Restored original byte at 0x%llx", breakpointAddress_);
    return true;
}

void ProcessLoader::Cleanup() {
    if (initialized_) {
        TerminateProcess(pi_.hProcess, 0);
        CloseHandle(pi_.hThread);
        CloseHandle(pi_.hProcess);
        initialized_ = false;
    }
}

```

`src/Logger.cpp`:

```cpp
#include <cstdarg>
#include <cstdio>
#include <string>

class Logger {
public:
    enum class Color {
        DEFAULT,
        RED,
        GREEN,
        YELLOW,
        BLUE,
        MAGENTA,
        CYAN,
        WHITE,
        GRAY
    };

    static void logf(Color color, const char* format, ...) {

        printf("%s", get_color_code(color));


        va_list args;
        va_start(args, format);
        vprintf(format, args);
        va_end(args);


        printf("%s", get_color_code(Color::DEFAULT));
        printf("\n");
    }

private:
    static const char* get_color_code(Color color) {
        switch (color) {
        case Color::RED:     return "\033[31m";
        case Color::GREEN:   return "\033[32m";
        case Color::YELLOW:  return "\033[33m";
        case Color::BLUE:    return "\033[34m";
        case Color::MAGENTA: return "\033[35m";
        case Color::CYAN:    return "\033[36m";
        case Color::WHITE:   return "\033[37m";
        case Color::GRAY:   return "\033[90m";
        default:             return "\033[0m";
        }
    }
};

```