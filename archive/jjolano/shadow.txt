Project Path: arc_jjolano_shadow_ahidsm7c

Source Tree:

```txt
arc_jjolano_shadow_ahidsm7c
├── LICENSE
├── Makefile
├── README.md
├── Shadow.dylib
│   ├── Makefile
│   ├── Shadow.plist
│   ├── dylib.x
│   ├── hooks
│   │   ├── DeviceCheck.x
│   │   ├── LSApplicationWorkspace.x
│   │   ├── NSArray.x
│   │   ├── NSBundle.x
│   │   ├── NSData.x
│   │   ├── NSDictionary.x
│   │   ├── NSFileHandle.x
│   │   ├── NSFileManager.x
│   │   ├── NSFileVersion.x
│   │   ├── NSFileWrapper.x
│   │   ├── NSProcessInfo.x
│   │   ├── NSString.x
│   │   ├── NSThread.x
│   │   ├── NSURL.x
│   │   ├── UIApplication.x
│   │   ├── UIImage.x
│   │   ├── dyld.x
│   │   ├── hooks.h
│   │   ├── libc.x
│   │   ├── mach.x
│   │   ├── mem.x
│   │   ├── objc.x
│   │   ├── sandbox.x
│   │   └── syscall.x
│   └── layout
│       └── Library
│           └── libSandy
│               └── ShadowSettings.plist
├── Shadow.framework
│   ├── Backend.m
│   ├── Core+Utilities.m
│   ├── Core.m
│   ├── Headers
│   │   ├── Shadow
│   │   │   ├── Backend.h
│   │   │   ├── Core+Utilities.h
│   │   │   ├── Core.h
│   │   │   ├── Ruleset.h
│   │   │   └── Settings.h
│   │   └── Shadow.h
│   ├── Makefile
│   ├── Resources
│   │   └── Info.plist
│   ├── Ruleset.m
│   ├── Settings.m
│   ├── Shadow.tbd
│   └── layout
│       └── Library
│           └── Shadow
│               └── Rulesets
│                   ├── JailbreakMisc.plist
│                   ├── StandardRules.plist
│                   └── dpkgInstalled.plist
├── ShadowSettings.bundle
│   ├── Makefile
│   ├── Resources
│   │   ├── About.plist
│   │   ├── App.plist
│   │   ├── Base.lproj
│   │   ├── Hooks.plist
│   │   ├── Info.plist
│   │   ├── Root.plist
│   │   ├── ar.lproj
│   │   │   ├── About.strings
│   │   │   ├── App.strings
│   │   │   ├── Hooks.strings
│   │   │   └── Root.strings
│   │   ├── en.lproj
│   │   │   ├── About.strings
│   │   │   ├── App.strings
│   │   │   ├── Hooks.strings
│   │   │   └── Root.strings
│   │   ├── icon.png
│   │   ├── icon@2x.png
│   │   ├── icon@3x.png
│   │   ├── zh-Hans.lproj
│   │   │   ├── About.strings
│   │   │   ├── App.strings
│   │   │   ├── Hooks.strings
│   │   │   └── Root.strings
│   │   └── zh-Hant.lproj
│   │       ├── About.strings
│   │       ├── App.strings
│   │       ├── Hooks.strings
│   │       └── Root.strings
│   ├── SHDWATLController.h
│   ├── SHDWATLController.m
│   ├── SHDWAboutListController.h
│   ├── SHDWAboutListController.m
│   ├── SHDWAppListController.h
│   ├── SHDWAppListController.m
│   ├── SHDWHooksListController.h
│   ├── SHDWHooksListController.m
│   ├── SHDWRootListController.h
│   ├── SHDWRootListController.m
│   └── layout
│       └── Library
│           └── PreferenceLoader
│               └── Preferences
│                   └── ShadowSettings.plist
├── build.sh
├── common.h
├── control
├── layout
│   └── DEBIAN
│       ├── postinst
│       ├── postrm
│       └── triggers
├── shdw
│   ├── Makefile
│   ├── entitlements.plist
│   └── main.m
└── vendor
    ├── HookKit.framework
    ├── Modulous.framework
    ├── RootBridge.framework
    └── apple
        ├── NSTask.h
        ├── codesign.h
        ├── dyld_priv.h
        └── ptrace.h

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2023, jjolano

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Makefile`:

```
ARCHS ?= armv7 armv7s arm64 arm64e
TARGET ?= iphone:clang:14.5:8.0

include $(THEOS)/makefiles/common.mk
SUBPROJECTS += Shadow.framework
SUBPROJECTS += Shadow.dylib
SUBPROJECTS += ShadowSettings.bundle
SUBPROJECTS += shdw
include $(THEOS_MAKE_PATH)/aggregate.mk

```

`README.md`:

```md
# Shadow

A jailbreak detection bypass for modern iOS jailbreaks.

## Known Issues

### XinaA15

* No support is given, but Shadow should still be functional.

### palera1n

* On iOS 16.2+, Substitute appears to have issues hooking C functions. In this case, please use the `fishhook` hooking library or replace Substitute with ElleKit (?).

## Troubleshooting

Shadow is not guaranteed to work on all apps, but here are some ideas to try:

* Use a different hooking library. `fishhook` is a safe option, but is somewhat limited in what it can hook.
* Disable all tweaks except Shadow. You can use Choicy or libhooker Configurator to do this per-app.
* Use vnodebypass, if supported on your system.
* If semi-(un)tethered or rootless, reboot into normal jailed iOS and use the app.
* Use another bypass tweak, ideally an app-specific bypass tweak. Be wary of enabling multiple bypass tweaks in case of conflicts.
* Downgrade the app. Sometimes, newer versions have updated detection methods.

## Installation

Add my [repo](https://ios.jjolano.me) to your package manager and install the Shadow (`me.jjolano.shadow`) package. Alternatively, download the [latest release](https://github.com/jjolano/shadow/releases/latest) directly from GitHub and open the file with your package manager.

You may need additional repositories for dependencies - these are the current dependencies:

* `libSandy` from [opa334's Repo](https://opa334.github.io) (preferences - sandboxed loading)
* `AltList` from [opa334‘s Repo](https://opa334.github.io) (preferences - application listing)
* `HookKit Framework` (hooking + change hooking library feature)
* `RootBridge Framework` (rootless compatibility/universal binary building)

A recommended (but not required) package is `Injection Foundation` from PoomSmart's Repo (`https://poomsmart.github.io/repo`). This package ensures that Shadow is injected properly into certain apps.

## Usage

After installation, settings are available in the Settings app. You may configure global defaults, or add an app-specific configuration. Shadow allows fine-grained control of its bypass strength, so there will be many options available to configure.

## Legal

*Copyright Act*, RSC 1985, c C-42, s 41.12.

```

`Shadow.dylib/Makefile`:

```
INSTALL_TARGET_PROCESSES = SpringBoard
# LOGOS_DEFAULT_GENERATOR = internal

include $(THEOS)/makefiles/common.mk

TWEAK_NAME = Shadow

Shadow_FILES = $(wildcard hooks/*.x) dylib.x
Shadow_LIBRARIES = sandy
Shadow_FRAMEWORKS = Foundation
Shadow_EXTRA_FRAMEWORKS = Shadow HookKit RootBridge
Shadow_PRIVATE_FRAMEWORKS = MobileCoreServices
Shadow_CFLAGS = -fobjc-arc -I../Shadow.framework/Headers -I../vendor/HookKit.framework/Headers -I../vendor/RootBridge.framework/Headers
Shadow_LDFLAGS = -rpath /Library/Frameworks -rpath /var/jb/Library/Frameworks -rpath /usr/lib -rpath /var/jb/usr/lib
Shadow_LDFLAGS += -F../ -F../vendor
Shadow_LDFLAGS += -weak_framework CydiaSubstrate

include $(THEOS_MAKE_PATH)/tweak.mk

```

`Shadow.dylib/Shadow.plist`:

```plist
{ Filter = { Bundles = ( "com.apple.UIKit" ); }; }

```

`Shadow.dylib/dylib.x`:

```x
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

#import "../common.h"
#import "hooks/hooks.h"

#import <Shadow.h>
#import <Shadow/Settings.h>
#import <libSandy.h>
#import <HookKit.h>
#import <RootBridge.h>

%group hook_springboard
%hook SpringBoard
- (void)applicationDidFinishLaunching:(UIApplication *)application {
    %orig;

    NSOperationQueue* queue = [NSOperationQueue new];

    [queue addOperationWithBlock:^(){
        NSDictionary* ruleset_dpkg = [Shadow generateDatabase];

        if(ruleset_dpkg) {
            BOOL success = [ruleset_dpkg writeToFile:[RootBridge getJBPath:@(SHADOW_DB_PLIST)] atomically:NO];

            if(success) {
                NSLog(@"successfully saved generated db");
            } else {
                NSLog(@"failed to save generate db");
            }
        }
    }];
}
%end
%end

%ctor {
    // Determine the application we're injected into.
    NSString* bundleIdentifier = [Shadow getBundleIdentifier];

    // Injected into SpringBoard.
    if([bundleIdentifier isEqualToString:@"com.apple.springboard"]) {
        %init(hook_springboard);
        return;
    }

    NSString* executablePath = [Shadow getExecutablePath];
    NSString* bundleType = [[executablePath stringByDeletingLastPathComponent] pathExtension];

    // Only load Shadow for applications in /var.
    if(![bundleType isEqualToString:@"app"]) {
        return;
    }

    if([executablePath hasPrefix:@"/Applications"]
    || [executablePath hasPrefix:@"/System"]
    || [executablePath hasPrefix:@"/private/preboot"]
    || [executablePath hasPrefix:@"/var/jb"]) {
        return;
    }

    // Don't load in certain apps
    if([bundleIdentifier hasPrefix:@"com.opa334"]
    || [bundleIdentifier hasPrefix:@"org.coolstar"]
    || [bundleIdentifier hasPrefix:@"science.xnu"]
    || [bundleIdentifier hasPrefix:@"com.apple"]
    || [bundleIdentifier hasPrefix:@"com.samiiau.loader"]
    || [bundleIdentifier hasPrefix:@"com.llsc12.palera1nLoader"]) {
        return;
    }

    NSLog(@"loaded in app");

    // Load preferences.
    if(kCFCoreFoundationVersionNumber >= kCFCoreFoundationVersionNumber_iOS_11_0) {
        libSandy_applyProfile("ShadowSettings");
    }

    NSDictionary* prefs_load = [[ShadowSettings sharedInstance] getPreferencesForIdentifier:bundleIdentifier];

    if(!prefs_load) {
        NSLog(@"[Shadow] warning: preferences not loaded");
        return;
    }

    NSLog(@"%@", prefs_load);

    BOOL enabled = [prefs_load[@"App_Enabled"] boolValue];

    if(!enabled) {
        return;
    }

    // Initialize Shadow instance.
    [Shadow sharedInstance];

    // Initialize hooks.
    NSLog(@"starting hooks");

    #ifdef hookkit_h
    hookkit_lib_t hooklibs = HK_LIB_NONE;
    
    if(prefs_load[@"HK_Library"] && ![prefs_load[@"HK_Library"] isEqualToString:@"auto"]) {
        hookkit_lib_t hooklibs_available_types = [HKSubstitutor getAvailableSubstitutorTypes];
        NSArray<NSDictionary *>* hooklibs_available_info = [HKSubstitutor getSubstitutorTypeInfo:hooklibs_available_types];

        for(NSDictionary* hooklib_info in hooklibs_available_info) {
            if([prefs_load[@"HK_Library"] isEqualToString:hooklib_info[@"id"]]) {
                hookkit_lib_t type = (hookkit_lib_t)[hooklib_info[@"type"] unsignedIntValue];

                if(hooklibs_available_types & type) {
                    hooklibs = type;
                }

                break;
            }
        }
    }

    HKSubstitutor* substitutor = [HKSubstitutor defaultSubstitutor];

    if(hooklibs != HK_LIB_NONE) {
        [substitutor setTypes:hooklibs];
        [substitutor initLibraries];
    }
    
    HKEnableBatching();
    #else
    HKSubstitutor* substitutor = NULL;
    #endif

    if([prefs_load[@"Hook_DynamicLibraries"] boolValue]) {
        NSLog(@"+ dylib");
        
        shadowhook_dyld(substitutor);
    }

    if([prefs_load[@"Hook_Filesystem"] boolValue]) {
        NSLog(@"+ filesystem");

        shadowhook_libc(substitutor);
        shadowhook_NSFileManager(substitutor);
        shadowhook_NSFileHandle(substitutor);
        shadowhook_NSFileVersion(substitutor);
        shadowhook_NSFileWrapper(substitutor);
    }

    if([prefs_load[@"Hook_URLScheme"] boolValue]) {
        NSLog(@"+ urlscheme");

        shadowhook_UIApplication(substitutor);
    }

    if([prefs_load[@"Hook_EnvVars"] boolValue]) {
        NSLog(@"+ envvars");

        NSProcessInfo* procInfo = [NSProcessInfo processInfo];
        NSDictionary* procEnv = [procInfo environment];

        NSArray* safe_envvars = @[
            @"CFFIXED_USER_HOME",
            @"HOME",
            @"LOGNAME",
            @"PATH",
            @"SHELL",
            @"TMPDIR",
            @"USER",
            @"XPC_FLAGS",
            @"XPC_SERVICE_NAME",
            @"__CF_USER_TEXT_ENCODING"
        ];

        for(NSString* envvar in procEnv) {
            if(![safe_envvars containsObject:envvar]) {
                NSLog(@"+ removing envvar: %@", envvar);
                unsetenv([envvar UTF8String]);
            }
        }

        // unsetenv("DYLD_INSERT_LIBRARIES");
        // unsetenv("_MSSafeMode");
        // unsetenv("_SafeMode");
        // unsetenv("_SubstituteSafeMode");
        // unsetenv("JSC_useGC");
        // unsetenv("JSC_useDollarVM");
        // unsetenv("JAILBREAKD_PATH");
        // unsetenv("JAILBREAKD_ARG");
        // unsetenv("JAILBREAKD_CDHASH");

        setenv("SHELL", "/bin/sh", 1);

        // shadowhook_libc_envvar(substitutor);
        // shadowhook_NSProcessInfo(substitutor);
    }

    if([prefs_load[@"Hook_Foundation"] boolValue]) {
        NSLog(@"+ foundation");

        shadowhook_NSArray(substitutor);
        shadowhook_NSDictionary(substitutor);
        shadowhook_NSBundle(substitutor);
        shadowhook_NSString(substitutor);
        shadowhook_NSURL(substitutor);
        shadowhook_NSData(substitutor);
        shadowhook_UIImage(substitutor);
        shadowhook_NSThread(substitutor);
    }

    if([prefs_load[@"Hook_DeviceCheck"] boolValue]) {
        NSLog(@"+ devicecheck");

        shadowhook_DeviceCheck(substitutor);
    }

    if([prefs_load[@"Hook_MachBootstrap"] boolValue]) {
        NSLog(@"+ mach");

        shadowhook_mach(substitutor);
    }

    if([prefs_load[@"Hook_LowLevelC"] boolValue]) {
        NSLog(@"+ llc");

        shadowhook_libc_lowlevel(substitutor);
    }

    if([prefs_load[@"Hook_AntiDebugging"] boolValue]) {
        NSLog(@"+ debug");

        shadowhook_libc_antidebugging(substitutor);
    }

    if([prefs_load[@"Hook_ObjCRuntime"] boolValue]) {
        NSLog(@"+ objc");

        shadowhook_objc(substitutor);
    }

    if([prefs_load[@"Hook_FakeMac"] boolValue]) {
        NSLog(@"+ m1");

        shadowhook_NSProcessInfo_fakemac(substitutor);
    }

    if([prefs_load[@"Hook_Syscall"] boolValue]) {
        NSLog(@"+ syscall");

        shadowhook_syscall(substitutor);
    }

    if([prefs_load[@"Hook_Memory"] boolValue]) {
        NSLog(@"+ memory");

        shadowhook_mem(substitutor);
    }

    if([prefs_load[@"Hook_HideApps"] boolValue]) {
        NSLog(@"+ apps");

        shadowhook_LSApplicationWorkspace(substitutor);
    }

    if([prefs_load[@"Hook_Sandbox"] boolValue]) {
        NSLog(@"+ sandbox");

        shadowhook_sandbox(substitutor);
    }

    if([prefs_load[@"Hook_TweakClasses"] boolValue]) {
        NSLog(@"+ classes");
        
        shadowhook_objc_hidetweakclasses(substitutor);
    }

    if([prefs_load[@"Hook_SymLookup"] boolValue]) {
        NSLog(@"+ dlsym");

        shadowhook_dyld_symlookup(substitutor);
        shadowhook_dyld_symaddrlookup(substitutor);
    }

    if([prefs_load[@"Hook_DynamicLibrariesExtra"] boolValue]) {
        NSLog(@"+ dylibex");

        shadowhook_dyld_extra(substitutor);
    }

    #ifdef hookkit_h
    HKExecuteBatch();
    HKDisableBatching();
    #endif

    NSLog(@"completed hooks");
}

```

`Shadow.dylib/hooks/DeviceCheck.x`:

```x
#import "hooks.h"

%group shadowhook_DeviceCheck
// %hook DCDevice
// - (BOOL)isSupported {
//     // maybe returning unsupported can skip some app attest token generations
// 	return NO;
// }
// %end

%hook UIDevice
+ (BOOL)isJailbroken {
    return NO;
}

- (BOOL)isJailBreak {
    return NO;
}

- (BOOL)isJailBroken {
    return NO;
}
%end

// %hook SFAntiPiracy
// + (int)isJailbroken {
// 	// Probably should not hook with a hard coded value.
// 	// This value may be changed by developers using this library.
// 	// Best to defeat the checks rather than skip them.
// 	return 4783242;
// }
// %end

%hook JailbreakDetectionVC
- (BOOL)isJailbroken {
    return NO;
}
%end

%hook DTTJailbreakDetection
+ (BOOL)isJailbroken {
    return NO;
}
%end

%hook ANSMetadata
- (BOOL)computeIsJailbroken {
    return NO;
}

- (BOOL)isJailbroken {
    return NO;
}
%end

%hook AppsFlyerUtils
+ (BOOL)isJailBreakon {
    return NO;
}

+ (bool)isJailbrokenWithSkipAdvancedJailbreakValidation:(bool)a {
    return false;
}
%end

%hook jailBreak
+ (bool)isJailBreak {
    return false;
}
%end

%hook GBDeviceInfo
- (BOOL)isJailbroken {
    return NO;
}
%end

%hook CMARAppRestrictionsDelegate
- (bool)isDeviceNonCompliant {
    return false;
}
%end

%hook ADYSecurityChecks
+ (bool)isDeviceJailbroken {
    return false;
}
%end

%hook UBReportMetadataDevice
- (void *)is_rooted {
    return NULL;
}
%end

%hook UtilitySystem
+ (bool)isJailbreak {
    return false;
}
%end

%hook GemaltoConfiguration
+ (bool)isJailbreak {
    return false;
}
%end

%hook CPWRDeviceInfo
- (bool)isJailbroken {
    return false;
}
%end

%hook CPWRSessionInfo
- (bool)isJailbroken {
    return false;
}
%end

%hook KSSystemInfo
+ (bool)isJailbroken {
    return false;
}
%end

%hook EMDSKPPConfiguration
- (bool)jailBroken {
    return false;
}
%end

%hook EnrollParameters
- (void *)jailbroken {
    return NULL;
}
%end

%hook EMDskppConfigurationBuilder
- (bool)jailbreakStatus {
    return false;
}
%end

%hook FCRSystemMetadata
- (bool)isJailbroken {
    return false;
}
%end

%hook v_VDMap
- (bool)isJailbrokenDetected {
    return false;
}

- (bool)isJailBrokenDetectedByVOS {
    return false;
}

- (bool)isDFPHookedDetecedByVOS {
    return false;
}

- (bool)isCodeInjectionDetectedByVOS {
    return false;
}

- (bool)isDebuggerCheckDetectedByVOS {
    return false;
}

- (bool)isAppSignerCheckDetectedByVOS {
    return false;
}

- (bool)v_checkAModified {
    return false;
}

- (bool)isRuntimeTamperingDetected {
    return false;
}
%end

%hook SDMUtils
- (BOOL)isJailBroken {
    return NO;
}
%end

%hook OneSignalJailbreakDetection
+ (BOOL)isJailbroken {
    return NO;
}
%end

%hook DigiPassHandler
- (BOOL)rootedDeviceTestResult {
    return NO;
}
%end

%hook AWMyDeviceGeneralInfo
- (bool)isCompliant {
    return true;
}
%end

%hook DTXSessionInfo
- (bool)isJailbroken {
    return false;
}
%end

%hook DTXDeviceInfo
- (bool)isJailbroken {
    return false;
}
%end

%hook JailbreakDetection
- (bool)jailbroken {
    return false;
}
%end

%hook jailBrokenJudge
- (bool)isJailBreak {
    return false;
}

- (bool)isCydiaJailBreak {
    return false;
}

- (bool)isApplicationsJailBreak {
    return false;
}

- (bool)ischeckCydiaJailBreak {
    return false;
}

- (bool)isPathJailBreak {
    return false;
}

- (bool)boolIsjailbreak {
    return false;
}
%end

%hook FBAdBotDetector
- (bool)isJailBrokenDevice {
    return false;
}
%end

%hook TNGDeviceTool
+ (bool)isJailBreak {
    return false;
}

+ (bool)isJailBreak_file {
    return false;
}

+ (bool)isJailBreak_cydia {
    return false;
}

+ (bool)isJailBreak_appList {
    return false;
}

+ (bool)isJailBreak_env {
    return false;
}
%end

%hook DTDeviceInfo
+ (bool)isJailbreak {
    return false;
}
%end

%hook SecVIDeviceUtil
+ (bool)isJailbreak {
    return false;
}   
%end

%hook RVPBridgeExtension4Jailbroken
- (bool)isJailbroken {
    return false;
}
%end

%hook ZDetection
+ (bool)isRootedOrJailbroken {
    return false;
}
%end
%end

void shadowhook_DeviceCheck(HKSubstitutor* hooks) {
    %init(shadowhook_DeviceCheck);
}

```

`Shadow.dylib/hooks/LSApplicationWorkspace.x`:

```x
#import "hooks.h"

#import <MobileCoreServices/LSApplicationWorkspace.h>
#import <MobileCoreServices/LSApplicationProxy.h>
#import <MobileCoreServices/LSBundleProxy.h>

// use of LSApplicationWorkspace seems to be known for getting App Store rejected, but you never know...

%group shadowhook_LSApplicationWorkspace
%hook LSApplicationWorkspace
- (NSArray<LSApplicationProxy *> *)allApplications {
    NSArray<LSApplicationProxy *>* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray<LSApplicationProxy *>* result_filtered = [result mutableCopy];

        for(LSApplicationProxy* ap in result) {
            if([_shadow isURLRestricted:[ap bundleURL]]) {
                [result_filtered removeObject:ap];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSArray<LSApplicationProxy *> *)allInstalledApplications {
    NSArray<LSApplicationProxy *>* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray<LSApplicationProxy *>* result_filtered = [result mutableCopy];

        for(LSApplicationProxy* ap in result) {
            if([_shadow isURLRestricted:[ap bundleURL]]) {
                [result_filtered removeObject:ap];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSArray<LSApplicationProxy *> *)directionsApplications {
    NSArray<LSApplicationProxy *>* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray<LSApplicationProxy *>* result_filtered = [result mutableCopy];

        for(LSApplicationProxy* ap in result) {
            if([_shadow isURLRestricted:[ap bundleURL]]) {
                [result_filtered removeObject:ap];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSArray<LSApplicationProxy *> *)unrestrictedApplications {
    NSArray<LSApplicationProxy *>* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray<LSApplicationProxy *>* result_filtered = [result mutableCopy];

        for(LSApplicationProxy* ap in result) {
            if([_shadow isURLRestricted:[ap bundleURL]]) {
                [result_filtered removeObject:ap];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSArray<NSString *> *)installedApplications {
    NSArray<NSString *>* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray<NSString *>* result_filtered = [result mutableCopy];

        for(NSString* app_bundleId in result) {
            LSBundleProxy* app_bundle = [LSBundleProxy bundleProxyForIdentifier:app_bundleId];

            if(app_bundle) {
                if([_shadow isURLRestricted:[app_bundle bundleURL]]) {
                    [result_filtered removeObject:app_bundleId];
                }
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSArray<LSApplicationProxy *> *)applicationsAvailableForHandlingURLScheme:(NSString *)urlScheme {
    if(!isCallerTweak() && [_shadow isSchemeRestricted:urlScheme]) {
        return @[];
    }

    return %orig;
}

- (NSArray<LSApplicationProxy *> *)applicationsAvailableForOpeningURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return @[];
    }

    return %orig;
}

- (NSArray<LSApplicationProxy *> *)applicationsAvailableForOpeningURL:(NSURL *)url legacySPI:(BOOL)legacySPI {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return @[];
    }

    return %orig;
}

- (NSArray<NSString *> *)publicURLSchemes {
    NSArray<NSString *>* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray<NSString *>* result_filtered = [result mutableCopy];

        for(NSString* scheme in result) {
            if([_shadow isSchemeRestricted:scheme]) {
                [result_filtered removeObject:scheme];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSArray<NSString *> *)privateURLSchemes {
    NSArray<NSString *>* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray<NSString *>* result_filtered = [result mutableCopy];

        for(NSString* scheme in result) {
            if([_shadow isSchemeRestricted:scheme]) {
                [result_filtered removeObject:scheme];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}
%end
%end

void shadowhook_LSApplicationWorkspace(HKSubstitutor* hooks) {
    %init(shadowhook_LSApplicationWorkspace);
}

```

`Shadow.dylib/hooks/NSArray.x`:

```x
#import "hooks.h"

%group shadowhook_NSArray
%hook NSArray
- (id)initWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

+ (id)arrayWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

+ (id)arrayWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (NSArray *)initWithContentsOfURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (NSArray *)arrayWithContentsOfURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return NO;
    }

    return %orig;
}

- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return NO;
    }

    return %orig;
}

- (BOOL)writeToURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:nil];
        }

        return NO;
    }

    return %orig;
}
%end

%hook NSMutableArray
- (id)initWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

- (id)initWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

+ (id)arrayWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

+ (id)arrayWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}
%end
%end

void shadowhook_NSArray(HKSubstitutor* hooks) {
    %init(shadowhook_NSArray);
}

```

`Shadow.dylib/hooks/NSBundle.x`:

```x
#import "hooks.h"

%group shadowhook_NSBundle
%hook NSBundle
- (id)objectForInfoDictionaryKey:(NSString *)key {
    if(!isCallerTweak() && [key isEqualToString:@"SignerIdentity"]) {
        return nil;
    }

    return %orig;
}

+ (instancetype)bundleWithURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }
    
    return %orig;
}

+ (instancetype)bundleWithPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }
    
    return %orig;
}

- (instancetype)initWithURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }
    
    return %orig;
}

- (instancetype)initWithPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }
    
    return %orig;
}

+ (NSBundle *)bundleForClass:(Class)aClass {
    if(!isCallerTweak() && [_shadow isAddrRestricted:(void *)aClass]) {
        return nil;
    }

    return %orig;
}

+ (NSBundle *)bundleWithIdentifier:(NSString *)identifier {
    NSBundle* result = %orig;

    if(!isCallerTweak() && result && [_shadow isPathRestricted:[result bundlePath]]) {
        return nil;
    }

    return result;
}

- (NSURL *)URLForResource:(NSString *)name withExtension:(NSString *)ext subdirectory:(NSString *)subpath {
    NSURL* result = %orig;

    if(!isCallerTweak() && [_shadow isURLRestricted:result]) {
        return nil;
    }

    return result;
}

- (NSURL *)URLForResource:(NSString *)name withExtension:(NSString *)ext {
    NSURL* result = %orig;

    if(!isCallerTweak() && [_shadow isURLRestricted:result]) {
        return nil;
    }

    return result;
}

- (NSArray<NSURL *> *)URLsForResourcesWithExtension:(NSString *)ext subdirectory:(NSString *)subpath {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSURL* url in result) {
            if([_shadow isURLRestricted:url]) {
                [result_filtered removeObject:url];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSURL *)URLForResource:(NSString *)name withExtension:(NSString *)ext subdirectory:(NSString *)subpath localization:(NSString *)localizationName {
    NSURL* result = %orig;

    if(!isCallerTweak() && [_shadow isURLRestricted:result]) {
        return nil;
    }

    return result;
}

- (NSArray<NSURL *> *)URLsForResourcesWithExtension:(NSString *)ext subdirectory:(NSString *)subpath localization:(NSString *)localizationName {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSURL* url in result) {
            if([_shadow isURLRestricted:url]) {
                [result_filtered removeObject:url];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

+ (NSURL *)URLForResource:(NSString *)name withExtension:(NSString *)ext subdirectory:(NSString *)subpath inBundleWithURL:(NSURL *)bundleURL {
    NSURL* result = %orig;

    if(!isCallerTweak() && [_shadow isURLRestricted:result]) {
        return nil;
    }

    return result;
}

+ (NSArray<NSURL *> *)URLsForResourcesWithExtension:(NSString *)ext subdirectory:(NSString *)subpath inBundleWithURL:(NSURL *)bundleURL {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSURL* url in result) {
            if([_shadow isURLRestricted:url]) {
                [result_filtered removeObject:url];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSString *)pathForResource:(NSString *)name ofType:(NSString *)ext {
    NSString* result = %orig;

    if(!isCallerTweak() && [_shadow isPathRestricted:result]) {
        return nil;
    }

    return result;
}

- (NSString *)pathForResource:(NSString *)name ofType:(NSString *)ext inDirectory:(NSString *)subpath {
    NSString* result = %orig;

    if(!isCallerTweak() && [_shadow isPathRestricted:result]) {
        return nil;
    }

    return result;
}

- (NSString *)pathForResource:(NSString *)name ofType:(NSString *)ext inDirectory:(NSString *)subpath forLocalization:(NSString *)localizationName {
    NSString* result = %orig;

    if(!isCallerTweak() && [_shadow isPathRestricted:result]) {
        return nil;
    }

    return result;
}

- (NSArray<NSString *> *)pathsForResourcesOfType:(NSString *)ext inDirectory:(NSString *)subpath {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSString* path in result) {
            if([_shadow isPathRestricted:path]) {
                [result_filtered removeObject:path];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSArray<NSString *> *)pathsForResourcesOfType:(NSString *)ext inDirectory:(NSString *)subpath forLocalization:(NSString *)localizationName {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSString* path in result) {
            if([_shadow isPathRestricted:path]) {
                [result_filtered removeObject:path];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

+ (NSString *)pathForResource:(NSString *)name ofType:(NSString *)ext inDirectory:(NSString *)bundlePath {
    NSString* result = %orig;

    if(!isCallerTweak() && [_shadow isPathRestricted:result]) {
        return nil;
    }

    return result;
}

+ (NSArray<NSString *> *)pathsForResourcesOfType:(NSString *)ext inDirectory:(NSString *)bundlePath {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSString* path in result) {
            if([_shadow isPathRestricted:path]) {
                [result_filtered removeObject:path];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

+ (NSArray<NSBundle *> *)allBundles {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSBundle* bundle in result) {
            if([_shadow isPathRestricted:[bundle bundlePath]]) {
                [result_filtered removeObject:bundle];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

+ (NSArray<NSBundle *> *)allFrameworks {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSBundle* bundle in result) {
            if([_shadow isPathRestricted:[bundle bundlePath]]) {
                [result_filtered removeObject:bundle];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}
%end
%end

void shadowhook_NSBundle(HKSubstitutor* hooks) {
    %init(shadowhook_NSBundle);
}

```

`Shadow.dylib/hooks/NSData.x`:

```x
#import "hooks.h"

%group shadowhook_NSData
%hook NSData
+ (instancetype)dataWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

+ (instancetype)dataWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError * _Nullable *)errorPtr {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        if(errorPtr) {
            *errorPtr = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (instancetype)dataWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

+ (instancetype)dataWithContentsOfURL:(NSURL *)url options:(NSDataReadingOptions)readOptionsMask error:(NSError * _Nullable *)errorPtr {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(errorPtr) {
            *errorPtr = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (instancetype)initWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

- (instancetype)initWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError * _Nullable *)errorPtr {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        if(errorPtr) {
            *errorPtr = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (instancetype)initWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (instancetype)initWithContentsOfURL:(NSURL *)url options:(NSDataReadingOptions)readOptionsMask error:(NSError * _Nullable *)errorPtr {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(errorPtr) {
            *errorPtr = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (id)initWithContentsOfMappedFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

+ (id)dataWithContentsOfMappedFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return NO;
    }

    return %orig;
}

- (BOOL)writeToFile:(NSString *)path options:(NSDataWritingOptions)writeOptionsMask error:(NSError * _Nullable *)errorPtr {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        if(errorPtr) {
            *errorPtr = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileWriteUnknownError userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return NO;
    }

    return %orig;
}

- (BOOL)writeToURL:(NSURL *)url options:(NSDataWritingOptions)writeOptionsMask error:(NSError * _Nullable *)errorPtr {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(errorPtr) {
            *errorPtr = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:nil];
        }

        return NO;
    }

    return %orig;
}
%end
%end

void shadowhook_NSData(HKSubstitutor* hooks) {
    %init(shadowhook_NSData);
}

```

`Shadow.dylib/hooks/NSDictionary.x`:

```x
#import "hooks.h"

%group shadowhook_NSDictionary
%hook NSDictionary
- (id)initWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

- (id)initWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (id)initWithContentsOfURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }
        
        return nil;
    }

    return %orig;
}

+ (id)dictionaryWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

+ (id)dictionaryWithContentsOfURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (id)dictionaryWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return NO;
    }

    return %orig;
}

- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return NO;
    }

    return %orig;
}

- (BOOL)writeToURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:nil];
        }

        return NO;
    }

    return %orig;
}
%end

%hook NSMutableDictionary
- (id)initWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

- (id)initWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

+ (NSMutableDictionary *)dictionaryWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

+ (NSMutableDictionary *)dictionaryWithContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}
%end
%end

void shadowhook_NSDictionary(HKSubstitutor* hooks) {
    %init(shadowhook_NSDictionary);
}

```

`Shadow.dylib/hooks/NSFileHandle.x`:

```x
#import "hooks.h"

%group shadowhook_NSFileHandle
%hook NSFileHandle
+ (instancetype)fileHandleForReadingAtPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }
    
    return %orig;
}

+ (instancetype)fileHandleForReadingFromURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }
        
        return nil;
    }
    
    return %orig;
}

+ (instancetype)fileHandleForWritingAtPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }
    
    return %orig;
}

+ (instancetype)fileHandleForWritingToURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }
        
        return nil;
    }
    
    return %orig;
}

+ (instancetype)fileHandleForUpdatingAtPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }
    
    return %orig;
}

+ (instancetype)fileHandleForUpdatingURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }
        
        return nil;
    }
    
    return %orig;
}
%end
%end

void shadowhook_NSFileHandle(HKSubstitutor* hooks) {
    %init(shadowhook_NSFileHandle);
}

```

`Shadow.dylib/hooks/NSFileManager.x`:

```x
#import "hooks.h"

static char* _NSDirectoryEnumerator_shdw_key = "shdw";

%group shadowhook_NSFileManager
%hook NSDirectoryEnumerator
- (NSArray *)allObjects {
    BOOL isTweak = isCallerTweak();

    if(isTweak) {
        return %orig;
    }

    NSString* base = objc_getAssociatedObject(self, _NSDirectoryEnumerator_shdw_key);

    if(!base) {
        NSLog(@"NSDirectoryEnumerator base not found");
        base = @"";
    }

    if([_shadow isPathRestricted:base]) {
        return @[];
    }

    NSArray* result = %orig; 

    if(result) {
        result = [Shadow filterPathArray:result restricted:NO options:@{kShadowRestrictionWorkingDir : base}];
    }

    return result;
}

- (id)nextObject {
    BOOL isTweak = isCallerTweak();

    if(isTweak) {
        return %orig;
    }

    NSString* base = objc_getAssociatedObject(self, _NSDirectoryEnumerator_shdw_key);

    if(!base) {
        NSLog(@"NSDirectoryEnumerator base not found");
        base = @"";
    }

    if([_shadow isPathRestricted:base]) {
        return nil;
    }

    id result = %orig;

    // keep looping until we get something unrestricted or nil
    while(result) {
        NSString* path = nil;

        if([result isKindOfClass:[NSURL class]]) {
            path = [result path];
        } else if([result isKindOfClass:[NSString class]]) {
            path = result;
        }

        if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : base}]) {
            result = %orig;
        } else {
            break;
        }
    }

    return result;
}
%end

%hook NSFileManager
- (BOOL)fileExistsAtPath:(NSString *)path {
    BOOL result = %orig;

    if(result && !isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return result;
}

- (BOOL)fileExistsAtPath:(NSString *)path isDirectory:(BOOL *)isDirectory {
    BOOL result = %orig;

    if(result && !isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return result;
}

- (BOOL)isReadableFileAtPath:(NSString *)path {
    BOOL result = %orig;

    if(result && !isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return result;
}

- (BOOL)isWritableFileAtPath:(NSString *)path {
    BOOL result = %orig;

    if(result && !isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return result;
}

- (BOOL)isDeletableFileAtPath:(NSString *)path {
    BOOL result = %orig;

    if(result && !isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return result;
}

- (BOOL)isExecutableFileAtPath:(NSString *)path {
    BOOL result = %orig;

    if(result && !isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return result;
}

- (NSData *)contentsAtPath:(NSString *)path {
    NSData* result = %orig;

    if(result && !isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return nil;
    }

    return result;
}

- (BOOL)contentsEqualAtPath:(NSString *)path1 andPath:(NSString *)path2 {
    if(!isCallerTweak() && ([_shadow isPathRestricted:path1 options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isPathRestricted:path2 options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        return NO;
    }

    return %orig;
}

- (NSArray<NSURL *> *)contentsOfDirectoryAtURL:(NSURL *)url includingPropertiesForKeys:(NSArray<NSURLResourceKey> *)keys options:(NSDirectoryEnumerationOptions)mask error:(NSError * _Nullable *)error {
    BOOL isTweak = isCallerTweak();

    if(isTweak) {
        return %orig;
    }

    if([_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }
    
    NSArray* result = %orig;
    
    if(result) {
        result = [Shadow filterPathArray:result restricted:NO options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}];
    }

    return result;
}

- (NSArray<NSString *> *)contentsOfDirectoryAtPath:(NSString *)path error:(NSError * _Nullable *)error {
    BOOL isTweak = isCallerTweak();

    if(isTweak) {
        return %orig;
    }

    if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }
    
    NSArray* result = %orig;
    
    if(result) {
        result = [Shadow filterPathArray:result restricted:NO options:@{kShadowRestrictionWorkingDir : path}];
    }

    return result;
}

- (NSDirectoryEnumerator<NSURL *> *)enumeratorAtURL:(NSURL *)url includingPropertiesForKeys:(NSArray<NSURLResourceKey> *)keys options:(NSDirectoryEnumerationOptions)mask errorHandler:(BOOL (^)(NSURL *url, NSError *error))handler {
    NSDirectoryEnumerator* result = %orig;
    
    if(result) {
        objc_setAssociatedObject(result, _NSDirectoryEnumerator_shdw_key, [url path], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        NSLog(@"%@: %@", @"enumeratorAtURL", url);
    }

    return result;
}

- (NSDirectoryEnumerator<NSString *> *)enumeratorAtPath:(NSString *)path {
    NSDirectoryEnumerator* result = %orig;

    if(result) {
        objc_setAssociatedObject(result, _NSDirectoryEnumerator_shdw_key, path, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        NSLog(@"%@: %@", @"enumeratorAtPath", path);
    }
    
    return result;
}

- (NSArray<NSString *> *)subpathsOfDirectoryAtPath:(NSString *)path error:(NSError * _Nullable *)error {
    BOOL isTweak = isCallerTweak();

    if(isTweak) {
        return %orig;
    }

    if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }
    
    NSArray* result = %orig;
    
    if(result) {
        result = [Shadow filterPathArray:result restricted:NO options:@{kShadowRestrictionWorkingDir : path}];
    }

    return result;
}

- (NSArray<NSString *> *)subpathsAtPath:(NSString *)path {
    BOOL isTweak = isCallerTweak();

    if(isTweak) {
        return %orig;
    }

    if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return nil;
    }
    
    NSArray* result = %orig;
    
    if(result) {
        result = [Shadow filterPathArray:result restricted:NO options:@{kShadowRestrictionWorkingDir : path}];
    }

    return result;
}

- (void)getFileProviderServicesForItemAtURL:(NSURL *)url completionHandler:(void (^)(NSDictionary *services, NSError *error))completionHandler {
    if(!isCallerTweak() && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(completionHandler) {
            completionHandler(nil, [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]);
        }

        return;
    }

    %orig;
}

- (NSString *)destinationOfSymbolicLinkAtPath:(NSString *)path error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }
        
        return nil;
    }

    return %orig;
}

- (NSArray<NSString *> *)componentsToDisplayForPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return nil;
    }

    return %orig;
}

- (NSString *)displayNameAtPath:(NSString *)path {
    NSString* result = %orig;

    if(result && !isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return nil;
    }

    return result;
}

- (NSDictionary<NSFileAttributeKey, id> *)attributesOfItemAtPath:(NSString *)path error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }

    // Make sure rootfs is marked read-only
    NSDictionary<NSFileAttributeKey, id>* result = %orig;

    if(result && (
        [path hasPrefix:@"/private/preboot"]
        || [path hasPrefix:@"/private/var"]
        || [path hasPrefix:@"/var"]
    )) {
        NSMutableDictionary<NSFileAttributeKey, id>* result_filtered = [result mutableCopy];
        [result_filtered setObject:@(YES) forKey:NSFileAppendOnly];
        result = [result_filtered copy];
    }

    return result;
}

- (NSDictionary<NSFileAttributeKey, id> *)attributesOfFileSystemForPath:(NSString *)path error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }

    // Make sure rootfs is marked read-only
    NSDictionary<NSFileAttributeKey, id>* result = %orig;

    if(result && (
        [path hasPrefix:@"/private/preboot"]
        || [path hasPrefix:@"/private/var"]
        || [path hasPrefix:@"/var"]
    )) {
        NSMutableDictionary<NSFileAttributeKey, id>* result_filtered = [result mutableCopy];
        [result_filtered setObject:@(YES) forKey:NSFileAppendOnly];
        result = [result_filtered copy];
    }

    return result;
}

- (BOOL)getRelationship:(NSURLRelationship *)outRelationship ofDirectoryAtURL:(NSURL *)directoryURL toItemAtURL:(NSURL *)otherURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isURLRestricted:directoryURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isURLRestricted:otherURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }
        
        return NO;
    }

    return %orig;
}

- (BOOL)getRelationship:(NSURLRelationship *)outRelationship ofDirectory:(NSSearchPathDirectory)directory inDomain:(NSSearchPathDomainMask)domainMask toItemAtURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)changeCurrentDirectoryPath:(NSString *)path {
    NSLog(@"%@: %@", @"changeCurrentDirectoryPath", path);

    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return %orig;
}

- (NSDictionary *)fileAttributesAtPath:(NSString *)path traverseLink:(BOOL)yorn {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return nil;
    }

    return %orig;
}

- (NSDictionary *)fileSystemAttributesAtPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return nil;
    }

    // Make sure rootfs is marked read-only
    NSDictionary<NSFileAttributeKey, id>* result = %orig;

    if(result && (
        [path hasPrefix:@"/private/preboot"]
        || [path hasPrefix:@"/private/var"]
        || [path hasPrefix:@"/var"]
    )) {
        NSMutableDictionary<NSFileAttributeKey, id>* result_filtered = [result mutableCopy];
        [result_filtered setObject:@(YES) forKey:NSFileAppendOnly];
        result = [result_filtered copy];
    }

    return result;
}

- (NSArray *)directoryContentsAtPath:(NSString *)path {
    BOOL isTweak = isCallerTweak();

    if(isTweak) {
        return %orig;
    }

    if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return nil;
    }
    
    NSArray* result = %orig;
    
    if(result) {
        result = [Shadow filterPathArray:result restricted:NO options:@{kShadowRestrictionWorkingDir : path}];
    }

    return result;
}

- (NSString *)pathContentOfSymbolicLinkAtPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return nil;
    }

    return %orig;
}

- (BOOL)replaceItemAtURL:(NSURL *)originalItemURL withItemAtURL:(NSURL *)newItemURL backupItemName:(NSString *)backupItemName options:(NSFileManagerItemReplacementOptions)options resultingItemURL:(NSURL * _Nullable *)resultingURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isURLRestricted:originalItemURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isURLRestricted:newItemURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)copyItemAtURL:(NSURL *)srcURL toURL:(NSURL *)dstURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isURLRestricted:srcURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isURLRestricted:dstURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isPathRestricted:srcPath options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isPathRestricted:dstPath options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)moveItemAtURL:(NSURL *)srcURL toURL:(NSURL *)dstURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isURLRestricted:srcURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isURLRestricted:dstURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)moveItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isPathRestricted:srcPath options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isPathRestricted:dstPath options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)isUbiquitousItemAtURL:(NSURL *)url {
    BOOL result = %orig;

    if(!isCallerTweak() && result && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return result;
}

- (BOOL)setUbiquitous:(BOOL)flag itemAtURL:(NSURL *)url destinationURL:(NSURL *)destinationURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isURLRestricted:destinationURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)startDownloadingUbiquitousItemAtURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)evictUbiquitousItemAtURL:(NSURL *)url error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (NSURL *)URLForPublishingUbiquitousItemAtURL:(NSURL *)url expirationDate:(NSDate * _Nullable *)outDate error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (BOOL)createSymbolicLinkAtURL:(NSURL *)url withDestinationURL:(NSURL *)destURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)createSymbolicLinkAtPath:(NSString *)path withDestinationPath:(NSString *)destPath error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)linkItemAtURL:(NSURL *)srcURL toURL:(NSURL *)dstURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isURLRestricted:srcURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isURLRestricted:dstURL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)linkItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && ([_shadow isPathRestricted:srcPath options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isPathRestricted:dstPath options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)copyPath:(NSString *)src toPath:(NSString *)dest handler:(id)handler {
    if(!isCallerTweak() && ([_shadow isPathRestricted:src options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isPathRestricted:dest options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        return NO;
    }

    return %orig;
}

- (BOOL)movePath:(NSString *)src toPath:(NSString *)dest handler:(id)handler {
    if(!isCallerTweak() && ([_shadow isPathRestricted:src options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isPathRestricted:dest options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        return NO;
    }

    return %orig;
}

- (BOOL)removeFileAtPath:(NSString *)path handler:(id)handler {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return %orig;
}

- (BOOL)changeFileAttributes:(NSDictionary *)attributes atPath:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return %orig;
}

- (BOOL)linkPath:(NSString *)src toPath:(NSString *)dest handler:(id)handler {
    if(!isCallerTweak() && ([_shadow isPathRestricted:src options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}] || [_shadow isPathRestricted:dest options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}])) {
        return NO;
    }

    return %orig;
}

- (BOOL)createDirectoryAtURL:(NSURL *)url withIntermediateDirectories:(BOOL)createIntermediates attributes:(NSDictionary<NSFileAttributeKey, id> *)attributes error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)createDirectoryAtPath:(NSString *)path withIntermediateDirectories:(BOOL)createIntermediates attributes:(NSDictionary<NSFileAttributeKey, id> *)attributes error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)createFileAtPath:(NSString *)path contents:(NSData *)data attributes:(NSDictionary<NSFileAttributeKey, id> *)attr {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        return NO;
    }

    return %orig;
}

- (BOOL)removeItemAtURL:(NSURL *)URL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:URL options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)removeItemAtPath:(NSString *)path error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)trashItemAtURL:(NSURL *)url resultingItemURL:(NSURL * _Nullable *)outResultingURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url options:@{kShadowRestrictionWorkingDir : [self currentDirectoryPath]}]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}
%end
%end

void shadowhook_NSFileManager(HKSubstitutor* hooks) {
    %init(shadowhook_NSFileManager);
}

```

`Shadow.dylib/hooks/NSFileVersion.x`:

```x
#import "hooks.h"

%group shadowhook_NSFileVersion
%hook NSFileVersion
+ (NSFileVersion *)currentVersionOfItemAtURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

+ (NSArray<NSFileVersion *> *)otherVersionsOfItemAtURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

+ (NSFileVersion *)versionOfItemAtURL:(NSURL *)url forPersistentIdentifier:(id)persistentIdentifier {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

+ (NSURL *)temporaryDirectoryURLForNewVersionOfItemAtURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

+ (NSFileVersion *)addVersionOfItemAtURL:(NSURL *)url withContentsOfURL:(NSURL *)contentsURL options:(NSFileVersionAddingOptions)options error:(NSError * _Nullable *)outError {
    if(!isCallerTweak() && ([_shadow isURLRestricted:url] || [_shadow isURLRestricted:contentsURL])) {
        if(outError) {
            *outError = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (NSArray<NSFileVersion *> *)unresolvedConflictVersionsOfItemAtURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (NSURL *)replaceItemAtURL:(NSURL *)url options:(NSFileVersionReplacingOptions)options error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (BOOL)removeOtherVersionsOfItemAtURL:(NSURL *)url error:(NSError * _Nullable *)outError {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return NO;
    }

    return %orig;
}

+ (void)getNonlocalVersionsOfItemAtURL:(NSURL *)url completionHandler:(void (^)(NSArray<NSFileVersion *> *nonlocalFileVersions, NSError *error))completionHandler {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(completionHandler) {
            completionHandler(nil, [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]);
        }

        return;
    }

    %orig;
}
%end
%end

void shadowhook_NSFileVersion(HKSubstitutor* hooks) {
    %init(shadowhook_NSFileVersion);
}

```

`Shadow.dylib/hooks/NSFileWrapper.x`:

```x
#import "hooks.h"

%group shadowhook_NSFileWrapper
%hook NSFileWrapper
- (instancetype)initWithURL:(NSURL *)url options:(NSFileWrapperReadingOptions)options error:(NSError * _Nullable *)outError {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(outError) {
            *outError = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return 0;
    }

    return %orig;
}

- (instancetype)initSymbolicLinkWithDestinationURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return 0;
    }

    return %orig;
}

- (BOOL)matchesContentsOfURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return NO;
    }

    return %orig;
}

- (BOOL)readFromURL:(NSURL *)url options:(NSFileWrapperReadingOptions)options error:(NSError * _Nullable *)outError {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(outError) {
            *outError = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)writeToURL:(NSURL *)url options:(NSFileWrapperWritingOptions)options originalContentsURL:(NSURL *)originalContentsURL error:(NSError * _Nullable *)outError {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(outError) {
            *outError = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}
%end
%end

void shadowhook_NSFileWrapper(HKSubstitutor* hooks) {
    %init(shadowhook_NSFileWrapper);
}

```

`Shadow.dylib/hooks/NSProcessInfo.x`:

```x
#import "hooks.h"

// %group shadowhook_NSProcessInfo
// %hook NSProcessInfo
// - (BOOL)isOperatingSystemAtLeastVersion:(NSOperatingSystemVersion)version {
//     if(isCallerTweak()) {
//         return %orig;
//     }

//     // Override version checks that use this method.
//     return YES;
// }

// - (NSDictionary *)environment {
// 	NSDictionary* result = %orig;

    // if(!isCallerTweak() && result) {
    //     NSMutableDictionary* filtered_result = [result mutableCopy];

    //     [filtered_result removeObjectForKey:@"DYLD_INSERT_LIBRARIES"];
    //     [filtered_result removeObjectForKey:@"_MSSafeMode"];
    //     [filtered_result removeObjectForKey:@"_SafeMode"];
    //     [filtered_result removeObjectForKey:@"_SubstituteSafeMode"];

    //     if([result objectForKey:@"SHELL"]) {
    //         [filtered_result setObject:@"/bin/sh" forKey:@"SHELL"];
    //     }

    //     // struct utsname systemInfo;
    //     // uname(&systemInfo);
    //     // [filtered_result setObject:@(systemInfo.machine) forKey:@"SIMULATOR_DEVICE_NAME"];

    //     result = [filtered_result copy];
    // }

//     return result;
// }
// %end
// %end

%group shadowhook_NSProcessInfo_fakemac
%hook NSProcessInfo
- (BOOL)macCatalystApp {
    if(isCallerTweak()) {
        return %orig;
    }

    // actually would be funny if this bypasses a lot of checks
    return YES;
}

- (BOOL)isiOSAppOnMac {
    if(isCallerTweak()) {
        return %orig;
    }

    // actually would be funny if this bypasses a lot of checks
    return YES;
}
%end
%end

void shadowhook_NSProcessInfo(HKSubstitutor* hooks) {
    // %init(shadowhook_NSProcessInfo);
}

void shadowhook_NSProcessInfo_fakemac(HKSubstitutor* hooks) {
    %init(shadowhook_NSProcessInfo_fakemac);
}

```

`Shadow.dylib/hooks/NSString.x`:

```x
#import "hooks.h"

typedef void (^NSAttributedStringCompletionHandler)(NSAttributedString *, NSDictionary<NSAttributedStringDocumentAttributeKey, id> *, NSError *);

%group shadowhook_NSString
%hook NSString
- (instancetype)initWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (instancetype)initWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (instancetype)stringWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        if(error) {
            *error = [NSError errorWithDomain:NSCocoaErrorDomain code:NSFileNoSuchFileError userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (instancetype)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (instancetype)initWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (instancetype)stringWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (instancetype)initWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (NSUInteger)completePathIntoString:(NSString * _Nullable *)outputName caseSensitive:(BOOL)flag matchesIntoArray:(NSArray<NSString *> * _Nullable *)outputArray filterTypes:(NSArray<NSString *> *)filterTypes {
    if(isCallerTweak() || ![_shadow isPathRestricted:self]) {
        return %orig;
    }

    NSUInteger result = %orig;

    if(result && ([_shadow isPathRestricted:self] || (outputName && [_shadow isPathRestricted:*outputName]))) {
        if(outputName) {
            *outputName = nil;
        }

        if(outputArray) {
            *outputArray = nil;
        }
        
        return 0;
    }

    return result;
}

- (NSString *)stringByResolvingSymlinksInPath {
    NSString* result = %orig;

    if(!isCallerTweak() && [_shadow isPathRestricted:result]) {
        return self;
    }

    return result;
}

// - (NSString *)stringByExpandingTildeInPath {
//     NSString* result = %orig;

//     if(!isCallerTweak() && [_shadow isPathRestricted:result]) {
//         return self;
//     }

//     return result;
// }

- (NSString *)stringByStandardizingPath {
    NSString* result = %orig;

    if(!isCallerTweak() && [_shadow isPathRestricted:result]) {
        return self;
    }

    return result;
}
%end

%hook NSAttributedString
- (instancetype)initWithHTML:(NSData *)data baseURL:(NSURL *)base documentAttributes:(NSDictionary<NSAttributedStringDocumentAttributeKey, id> * _Nullable *)dict {
    if(!isCallerTweak() && [_shadow isURLRestricted:base]) {
        return nil;
    }

    return %orig;
}

- (instancetype)initWithURL:(NSURL *)url options:(NSDictionary<NSAttributedStringDocumentReadingOptionKey, id> *)options documentAttributes:(NSDictionary<NSAttributedStringDocumentAttributeKey, id> * _Nullable *)dict error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

+ (void)loadFromHTMLWithFileURL:(NSURL *)fileURL options:(NSDictionary<NSAttributedStringDocumentReadingOptionKey, id> *)options completionHandler:(NSAttributedStringCompletionHandler)completionHandler {
    if(!isCallerTweak() && [_shadow isURLRestricted:fileURL]) {
        if(completionHandler) {
            completionHandler(nil, nil, nil);
        }

        return;
    }

    %orig;
}
%end
%end

%group shadowhook_NSCharacterSet
%hook NSCharacterSet
+ (NSCharacterSet *)characterSetWithContentsOfFile:(NSString *)fName {
    if(!isCallerTweak() && [_shadow isPathRestricted:fName]) {
        return nil;
    }

    return %orig;
}
%end
%end

void shadowhook_NSString(HKSubstitutor* hooks) {
    %init(shadowhook_NSString);
    %init(shadowhook_NSCharacterSet);
}

```

`Shadow.dylib/hooks/NSThread.x`:

```x
#import "hooks.h"

%group shadowhook_NSThread
%hook NSThread
- (NSArray *)callStackReturnAddresses {
    NSArray* result = %orig;

    if(!isCallerTweak() && result) {
        NSMutableArray* result_filtered = [result mutableCopy];

        for(NSNumber* ret_addr in result) {
            if([_shadow isAddrRestricted:[ret_addr pointerValue]]) {
                [result_filtered removeObject:ret_addr];
            }
        }

        result = [result_filtered copy];
    }

    return result;
}

- (NSArray *)callStackSymbols {
    if(isCallerTweak()) {
        return %orig;
    }

    // todo: properly filter this (maybe use NSPredicate?)
    return @[];
}
%end
%end

void shadowhook_NSThread(HKSubstitutor* hooks) {
    %init(shadowhook_NSThread);
}

```

`Shadow.dylib/hooks/NSURL.x`:

```x
#import "hooks.h"

%group shadowhook_NSURL
%hook NSURL
- (BOOL)checkResourceIsReachableAndReturnError:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:self]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)checkPromisedItemIsReachableAndReturnError:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:self]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (BOOL)getPromisedItemResourceValue:(id  _Nullable *)value forKey:(NSURLResourceKey)key error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:self]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return NO;
    }

    return %orig;
}

- (NSDictionary<NSURLResourceKey, id> *)promisedItemResourceValuesForKeys:(NSArray<NSURLResourceKey> *)keys error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:self]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}

- (NSURL *)fileReferenceURL {
    if(!isCallerTweak() && [_shadow isURLRestricted:self]) {
        return nil;
    }

    return %orig;
}

- (NSURL *)filePathURL {
    if(!isCallerTweak() && [_shadow isURLRestricted:self]) {
        return nil;
    }

    return %orig;
}

- (NSURL *)URLByResolvingSymlinksInPath {
    if(!isCallerTweak() && [_shadow isURLRestricted:self]) {
        return nil;
    }

    return %orig;
}

- (NSURL *)URLByStandardizingPath {
    if(!isCallerTweak() && [_shadow isURLRestricted:self]) {
        return nil;
    }

    return %orig;
}

+ (NSData *)bookmarkDataWithContentsOfURL:(NSURL *)bookmarkFileURL error:(NSError * _Nullable *)error {
    if(!isCallerTweak() && [_shadow isURLRestricted:bookmarkFileURL]) {
        if(error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        }

        return nil;
    }

    return %orig;
}
%end
%end

%group shadowhook_NSURLSession
%hook NSURLSession
- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        return nil;
    }

    return %orig;
}

- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL {
    if(!isCallerTweak() && [_shadow isURLRestricted:fileURL]) {
        return nil;
    }

    return %orig;
}

- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler {
    if(!isCallerTweak() && [_shadow isURLRestricted:fileURL]) {
        return nil;
    }

    return %orig;
}
%end
%end

%group shadowhook_NSURLRequest
%hook NSURLRequest
+ (instancetype)requestWithURL:(NSURL *)URL {
    if(!isCallerTweak() && [_shadow isURLRestricted:URL]) {
        return nil;
    }

    return %orig;
}

- (instancetype)initWithURL:(NSURL *)URL {
    if(!isCallerTweak() && [_shadow isURLRestricted:URL]) {
        return nil;
    }

    return %orig;
}

+ (instancetype)requestWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval {
    if(!isCallerTweak() && [_shadow isURLRestricted:URL]) {
        return nil;
    }

    return %orig;
}

- (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval {
    if(!isCallerTweak() && [_shadow isURLRestricted:URL]) {
        return nil;
    }

    return %orig;
}
%end
%end

void shadowhook_NSURL(HKSubstitutor* hooks) {
    %init(shadowhook_NSURL);
    %init(shadowhook_NSURLRequest);
    %init(shadowhook_NSURLSession);
}

```

`Shadow.dylib/hooks/UIApplication.x`:

```x
#import "hooks.h"

%group shadowhook_UIApplication
%hook UIApplication
- (BOOL)canOpenURL:(NSURL *)url {
    if(!isCallerTweak() && [_shadow isURLRestricted:url]) {
        NSLog(@"%@: %@", @"canOpenURL restricted", url);
        return NO;
    }

    return %orig;
}
%end
%end

void shadowhook_UIApplication(HKSubstitutor* hooks) {
    %init(shadowhook_UIApplication);
}

```

`Shadow.dylib/hooks/UIImage.x`:

```x
#import "hooks.h"

%group shadowhook_UIImage
%hook UIImage
- (instancetype)initWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}

+ (UIImage *)imageWithContentsOfFile:(NSString *)path {
    if(!isCallerTweak() && [_shadow isPathRestricted:path]) {
        return nil;
    }

    return %orig;
}
%end
%end

void shadowhook_UIImage(HKSubstitutor* hooks) {
    %init(shadowhook_UIImage);
}

```

`Shadow.dylib/hooks/dyld.x`:

```x
#import "hooks.h"

static NSMutableArray<NSDictionary *>* _shdw_dyld_collection = nil;
static NSMutableArray<NSValue *>* _shdw_dyld_add_image = nil;
static NSMutableArray<NSValue *>* _shdw_dyld_remove_image = nil;
static BOOL _shdw_dyld_error = NO;
// static NSOperationQueue* _shdw_dyld_queue = nil;
// NSMutableData* _shdw_dyld_task_dyld_info = nil;

// todo: maybe hook this private symbol
// extern void call_funcs_for_add_image(struct mach_header *mh, unsigned long vmaddr_slide);

static uint32_t (*original_dyld_image_count)();
static uint32_t replaced_dyld_image_count() {
    if(isCallerTweak()) {
        return original_dyld_image_count();
    }

    NSArray* _dyld_collection = [_shdw_dyld_collection copy];
    return [_dyld_collection count];
}

static const struct mach_header* (*original_dyld_get_image_header)(uint32_t image_index);
static const struct mach_header* replaced_dyld_get_image_header(uint32_t image_index) {
    if(isCallerTweak()) {
        return original_dyld_get_image_header(image_index);
    }

    NSArray* _dyld_collection = [_shdw_dyld_collection copy];
    return image_index < [_dyld_collection count] ? (struct mach_header *)[_dyld_collection[image_index][@"mach_header"] pointerValue] : NULL;
}

static intptr_t (*original_dyld_get_image_vmaddr_slide)(uint32_t image_index);
static intptr_t replaced_dyld_get_image_vmaddr_slide(uint32_t image_index) {
    if(isCallerTweak()) {
        return original_dyld_get_image_vmaddr_slide(image_index);
    }

    NSArray* _dyld_collection = [_shdw_dyld_collection copy];
    return image_index < [_dyld_collection count] ? (intptr_t)[_dyld_collection[image_index][@"slide"] pointerValue] : 0;
}

static const char* (*original_dyld_get_image_name)(uint32_t image_index);
static const char* replaced_dyld_get_image_name(uint32_t image_index) {
    if(isCallerTweak()) {
        return original_dyld_get_image_name(image_index);
    }

    NSArray* _dyld_collection = [_shdw_dyld_collection copy];
    return image_index < [_dyld_collection count] ? [_dyld_collection[image_index][@"name"] fileSystemRepresentation] : NULL;
}

static void* (*original_dlopen)(const char* path, int mode);
static void* replaced_dlopen(const char* path, int mode) {
    if(isCallerTweak() || !path) {
        return original_dlopen(path, mode);
    }

    if(path[0] != '/') {
        if(![_shadow isPathRestricted:@(path) options:@{
            kShadowRestrictionWorkingDir : @"/usr/lib",
            kShadowRestrictionFileExtension : @"dylib"
            }]) {
            return original_dlopen(path, mode);
        }
    } else {
        if(![_shadow isCPathRestricted:path]) {
            return original_dlopen(path, mode);
        }
    }

    _shdw_dyld_error = YES;
    return NULL;
}

static void* (*original_dlopen_internal)(const char* path, int mode, void* caller);
static void* replaced_dlopen_internal(const char* path, int mode, void* caller) {
    if(isCallerTweak() || !path) {
        return original_dlopen_internal(path, mode, caller);
    }

    if(path[0] != '/') {
        if(![_shadow isPathRestricted:@(path) options:@{
            kShadowRestrictionWorkingDir : @"/usr/lib",
            kShadowRestrictionFileExtension : @"dylib"
            }]) {
            return original_dlopen_internal(path, mode, caller);
        }
    } else {
        if(![_shadow isCPathRestricted:path]) {
            return original_dlopen_internal(path, mode, caller);
        }
    }

    _shdw_dyld_error = YES;
    return NULL;
}

static bool (*original_dlopen_preflight)(const char* path);
static bool replaced_dlopen_preflight(const char* path) {
    if(isCallerTweak() || !path) {
        return original_dlopen_preflight(path);
    }

    if(path[0] != '/') {
        if(![_shadow isPathRestricted:@(path) options:@{
            kShadowRestrictionWorkingDir : @"/usr/lib",
            kShadowRestrictionFileExtension : @"dylib"
            }]) {
            return original_dlopen_preflight(path);
        }
    } else {
        if(![_shadow isCPathRestricted:path]) {
            return original_dlopen_preflight(path);
        }
    }

    return false;
}

static void (*original_dyld_register_func_for_add_image)(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));
static void replaced_dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) {
    if(isCallerTweak() || !func) {
        return original_dyld_register_func_for_add_image(func);
    }

    // add to our collection
    [_shdw_dyld_add_image addObject:[NSValue valueWithPointer:func]];

    // do initial call
    NSArray* _dyld_collection = [_shdw_dyld_collection copy];

    if(_dyld_collection) {
        for(NSDictionary* dylib in _dyld_collection) {
            func((struct mach_header *)[dylib[@"mach_header"] pointerValue], (intptr_t)[dylib[@"slide"] pointerValue]);
        }
    }
}

static void (*original_dyld_register_func_for_remove_image)(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));
static void replaced_dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) {
    if(isCallerTweak() || !func) {
        return original_dyld_register_func_for_remove_image(func);
    }

    [_shdw_dyld_remove_image addObject:[NSValue valueWithPointer:func]];
}

static kern_return_t (*original_task_info)(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt);
static kern_return_t replaced_task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt) {
    if(isCallerTweak()) {
        return original_task_info(target_task, flavor, task_info_out, task_info_outCnt);
    }

    kern_return_t result = original_task_info(target_task, flavor, task_info_out, task_info_outCnt);

    if(flavor == TASK_DYLD_INFO && result == KERN_SUCCESS) {
        struct task_dyld_info *task_info = (struct task_dyld_info *) task_info_out;
        struct dyld_all_image_infos *dyld_info = (struct dyld_all_image_infos *) task_info->all_image_info_addr;
        dyld_info->infoArrayCount = 1;
        dyld_info->uuidArrayCount = 1;

        // todo: improve this
    }

    return result;
}

void shadowhook_dyld_updatelibs(const struct mach_header* mh, intptr_t vmaddr_slide) {
    if(!mh) {
        return;
    }

    const char* image_path = dyld_image_path_containing_address(mh);

    // Add if safe dylib.
    if(image_path) {
        NSString* path = [NSString stringWithUTF8String:image_path];

        if([path hasPrefix:@"/System"] || ![_shadow isPathRestricted:path options:@{kShadowRestrictionEnableResolve : @(NO)}]) {
            NSLog(@"%@: %@: %@", @"dyld", @"adding lib", path);

            [_shdw_dyld_collection addObject:@{
                @"name" : path,
                @"mach_header" : [NSValue valueWithPointer:mh],
                @"slide" : [NSValue valueWithPointer:(void *)vmaddr_slide]
            }];

            // Call event handlers.
            NSArray* _dyld_add_image = [_shdw_dyld_add_image copy];

            if([_dyld_add_image count]) {
                NSLog(@"%@: %@", @"dyld", @"add_image calling handlers");

                for(NSValue* func_ptr in _dyld_add_image) {
                    void (*func)(const struct mach_header*, intptr_t) = [func_ptr pointerValue];
                    func(mh, vmaddr_slide);
                }
            }
        }
    }
}

void shadowhook_dyld_updatelibs_r(const struct mach_header* mh, intptr_t vmaddr_slide) {
    if(!mh) {
        return;
    }

    NSArray* _dyld_collection = [_shdw_dyld_collection copy];
    NSDictionary* dylibToRemove = nil;

    for(NSDictionary* dylib in _dyld_collection) {
        if((struct mach_header *)[dylib[@"mach_header"] pointerValue] == mh) {
            // Don't remove while in enumeration, store for later
            dylibToRemove = dylib;
            break;
        }
    }

    if(dylibToRemove) {
        // Remove this from our collection
        NSLog(@"%@: %@: %@", @"dyld", @"removing lib", dylibToRemove[@"name"]);
        [_shdw_dyld_collection removeObject:dylibToRemove];

        // Call event handlers.
        NSArray* _dyld_remove_image = [_shdw_dyld_remove_image copy];

        if([_dyld_remove_image count]) {
            NSLog(@"%@: %@", @"dyld", @"remove_image calling handlers");
            
            for(NSValue* func_ptr in _dyld_remove_image) {
                void (*func)(const struct mach_header*, intptr_t) = [func_ptr pointerValue];
                func(mh, vmaddr_slide);
            }
        }
    }
}

static char* (*original_dlerror)(void);
static char* replaced_dlerror(void) {
    if(isCallerTweak() || !_shdw_dyld_error) {
        return original_dlerror();
    }

    _shdw_dyld_error = NO;
    return "library not found";
}

static void* (*original_dlsym)(void* handle, const char* symbol);
static void* replaced_dlsym(void* handle, const char* symbol) {
    if(isCallerTweak()) {
        return original_dlsym(handle, symbol);
    }

    void* addr = original_dlsym(handle, symbol);

    if(![_shadow isAddrRestricted:addr]) {
        return addr;
    }

    if(symbol) {
        NSLog(@"%@: %@: %s", @"dlsym", @"restricted symbol lookup", symbol);
    }

    _shdw_dyld_error = YES;
    return NULL;
}

static int (*original_dladdr)(const void* addr, Dl_info* info);
static int replaced_dladdr(const void* addr, Dl_info* info) {
    if(isCallerTweak()) {
        return original_dladdr(addr, info);
    }

    int result = original_dladdr(addr, info);

    if(result && [_shadow isAddrRestricted:addr]) {
        if(info) {
            void* sym;

            // try to find the real original addr
            do {
                sym = dlsym(RTLD_NEXT, info->dli_sname);
            } while(sym && [_shadow isAddrRestricted:sym]);
            
            if(sym) {
                return original_dladdr(sym, info);
            } else {
                // as a fallback, we'll just say this addr is part of the executable itself
                info->dli_fname = [[Shadow getExecutablePath] fileSystemRepresentation];
            }
        }
    }

    return result;
}

void shadowhook_dyld(HKSubstitutor* hooks) {
    _shdw_dyld_collection = [NSMutableArray new];
    _shdw_dyld_add_image = [NSMutableArray new];
    _shdw_dyld_remove_image = [NSMutableArray new];

    _dyld_register_func_for_add_image(shadowhook_dyld_updatelibs);
    _dyld_register_func_for_remove_image(shadowhook_dyld_updatelibs_r);

    MSHookFunction(_dyld_get_image_name, replaced_dyld_get_image_name, (void **) &original_dyld_get_image_name);
    MSHookFunction(_dyld_image_count, replaced_dyld_image_count, (void **) &original_dyld_image_count);
    MSHookFunction(_dyld_get_image_header, replaced_dyld_get_image_header, (void **) &original_dyld_get_image_header);
    MSHookFunction(_dyld_get_image_vmaddr_slide, replaced_dyld_get_image_vmaddr_slide, (void **) &original_dyld_get_image_vmaddr_slide);
    MSHookFunction(_dyld_register_func_for_add_image, replaced_dyld_register_func_for_add_image, (void **) &original_dyld_register_func_for_add_image);
    MSHookFunction(_dyld_register_func_for_remove_image, replaced_dyld_register_func_for_remove_image, (void **) &original_dyld_register_func_for_remove_image);

    MSHookFunction(task_info, replaced_task_info, (void **) &original_task_info);
    MSHookFunction(dlopen_preflight, replaced_dlopen_preflight, (void **) &original_dlopen_preflight);

    MSHookFunction(dlerror, replaced_dlerror, (void **) &original_dlerror);
}

void shadowhook_dyld_extra(HKSubstitutor* hooks) {
    // dlopen hook code from Choicy
    MSImageRef libdyldImage = MSGetImageByName("/usr/lib/system/libdyld.dylib");
    void* libdyldHandle = dlopen("/usr/lib/system/libdyld.dylib", RTLD_NOW);

    void* dlopen_global_var_ptr = MSFindSymbol(libdyldImage, "__ZN5dyld45gDyldE");

    MSHookFunction(dlopen, replaced_dlopen, (void **) &original_dlopen);

    if(kCFCoreFoundationVersionNumber >= kCFCoreFoundationVersionNumber_iOS_14_1 && !dlopen_global_var_ptr) {
        void* dlopen_internal_ptr = MSFindSymbol(libdyldImage, "__ZL15dlopen_internalPKciPv");

        if(dlopen_internal_ptr) {
            MSHookFunction(dlopen_internal_ptr, replaced_dlopen_internal, (void **) &original_dlopen_internal);
        }
    } else {
        void* dlopen_from_ptr = dlsym(libdyldHandle, "dlopen_from");

        if(dlopen_from_ptr) {
            MSHookFunction(dlopen_from_ptr, replaced_dlopen_internal, (void **) &original_dlopen_internal);
        }
    }

    // MSCloseImage(libdyldImage);
}

void shadowhook_dyld_symlookup(HKSubstitutor* hooks) {
    MSHookFunction(dlsym, replaced_dlsym, (void **) &original_dlsym);
}

void shadowhook_dyld_symaddrlookup(HKSubstitutor* hooks) {
    MSHookFunction(dladdr, replaced_dladdr, (void **) &original_dladdr);
}

```

`Shadow.dylib/hooks/hooks.h`:

```h
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

#import <stdio.h>
#import <sys/stat.h>
#import <sys/statvfs.h>
#import <sys/mount.h>
#import <sys/syscall.h>
#import <sys/utsname.h>
#import <sys/syslimits.h>
#import <sys/time.h>
#import <errno.h>
#import <fcntl.h>
#import <mach-o/dyld.h>
#import <mach-o/dyld_images.h>
#import <mach-o/nlist.h>
#import <dlfcn.h>
#import <dirent.h>
#import <sys/sysctl.h>
#import <mach/mach.h>
#import <mach/task_info.h>
#import <mach/mach_traps.h>
#import <mach/host_special_ports.h>
#import <mach/task_special_ports.h>
#import <sandbox.h>
#import <bootstrap.h>
#import <spawn.h>
#import <objc/runtime.h>

#import "../../common.h"
#import <Shadow.h>

#import <substrate.h>
#import <HookKit.h>

// HookKit overrides
#ifdef hookkit_h
#define MSHookFunction(a,b,c)   [hooks hookFunction:a withReplacement:b outOldPtr:c]
#define MSHookMessageEx         HKHookMessage
#define MSGetImageByName        HKOpenImage
#define MSFindSymbol            HKFindSymbol
#define MSCloseImage            HKCloseImage
#endif

// private symbols
#import "../../vendor/apple/dyld_priv.h"
#import "../../vendor/apple/codesign.h"
#import "../../vendor/apple/ptrace.h"

#define _shadow                 [Shadow sharedInstance]

#define isCallerTweak()         [_shadow isAddrExternal:__builtin_extract_return_addr(__builtin_return_address(0))]

extern void shadowhook_DeviceCheck(HKSubstitutor* hooks);
extern void shadowhook_dyld(HKSubstitutor* hooks);
extern void shadowhook_libc(HKSubstitutor* hooks);
extern void shadowhook_mach(HKSubstitutor* hooks);
extern void shadowhook_NSArray(HKSubstitutor* hooks);
extern void shadowhook_NSBundle(HKSubstitutor* hooks);
extern void shadowhook_NSData(HKSubstitutor* hooks);
extern void shadowhook_NSDictionary(HKSubstitutor* hooks);
extern void shadowhook_NSFileHandle(HKSubstitutor* hooks);
extern void shadowhook_NSFileManager(HKSubstitutor* hooks);
extern void shadowhook_NSFileVersion(HKSubstitutor* hooks);
extern void shadowhook_NSFileWrapper(HKSubstitutor* hooks);
extern void shadowhook_NSProcessInfo(HKSubstitutor* hooks);
extern void shadowhook_NSString(HKSubstitutor* hooks);
extern void shadowhook_NSURL(HKSubstitutor* hooks);
extern void shadowhook_objc(HKSubstitutor* hooks);
extern void shadowhook_sandbox(HKSubstitutor* hooks);
extern void shadowhook_syscall(HKSubstitutor* hooks);
extern void shadowhook_UIApplication(HKSubstitutor* hooks);
extern void shadowhook_UIImage(HKSubstitutor* hooks);
extern void shadowhook_libc_envvar(HKSubstitutor* hooks);
extern void shadowhook_libc_lowlevel(HKSubstitutor* hooks);
extern void shadowhook_libc_antidebugging(HKSubstitutor* hooks);
extern void shadowhook_dyld_extra(HKSubstitutor* hooks);
extern void shadowhook_dyld_symlookup(HKSubstitutor* hooks);
extern void shadowhook_dyld_symaddrlookup(HKSubstitutor* hooks);
extern void shadowhook_NSProcessInfo_fakemac(HKSubstitutor* hooks);
extern void shadowhook_mem(HKSubstitutor* hooks);
extern void shadowhook_objc_hidetweakclasses(HKSubstitutor* hooks);
extern void shadowhook_LSApplicationWorkspace(HKSubstitutor* hooks);
extern void shadowhook_NSThread(HKSubstitutor* hooks);

```

`Shadow.dylib/hooks/libc.x`:

```x
#import "hooks.h"

static int (*original_access)(const char* pathname, int mode);
static int replaced_access(const char* pathname, int mode) {
    int result = original_access(pathname, mode);

    if(result != -1 && !isCallerTweak() && [_shadow isCPathRestricted:pathname]) {
        errno = ENOENT;
        return -1;
    }

    return result;
}

static ssize_t (*original_readlink)(const char* pathname, char* buf, size_t bufsize);
static ssize_t replaced_readlink(const char* pathname, char* buf, size_t bufsize) {
    ssize_t result = original_readlink(pathname, buf, bufsize);

    if(result != -1 && !isCallerTweak() && [_shadow isCPathRestricted:pathname]) {
        errno = ENOENT;
        return -1;
    }

    return result;
}

static ssize_t (*original_readlinkat)(int dirfd, const char* pathname, char* buf, size_t bufsize);
static ssize_t replaced_readlinkat(int dirfd, const char* pathname, char* buf, size_t bufsize) {
    if(isCallerTweak()) {
        return original_readlinkat(dirfd, pathname, buf, bufsize);
    }

    if(pathname
    && dirfd != fileno(stderr)
    && dirfd != fileno(stdout)
    && dirfd != fileno(stdin)) {
        NSString* path = [NSString stringWithUTF8String:pathname];

        // Get file descriptor path.
        char pathnameParent[PATH_MAX];
        NSString* pathParent = nil;

        if(dirfd == AT_FDCWD) {
            pathParent = [[NSFileManager defaultManager] currentDirectoryPath];
        } else if(fcntl(dirfd, F_GETPATH, pathnameParent) != -1) {
            pathParent = [NSString stringWithUTF8String:pathnameParent];
        }

        if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : pathParent}]) {
            errno = [path isAbsolutePath] ? ENOENT : EBADF;
            return -1;
        }
    }

    return original_readlinkat(dirfd, pathname, buf, bufsize);
}

static int (*original_chdir)(const char* pathname);
static int replaced_chdir(const char* pathname) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_chdir(pathname);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_fchdir)(int fd);
static int replaced_fchdir(int fd) {
    if(isCallerTweak()) {
        return original_fchdir(fd);
    }

    // Get file descriptor path.
    if(fd != fileno(stderr)
    && fd != fileno(stdout)
    && fd != fileno(stdin)) {
        char pathname[PATH_MAX];

        if(fcntl(fd, F_GETPATH, pathname) != -1 && [_shadow isCPathRestricted:pathname]) {
            errno = EBADF;
            return -1;
        }
    }

    return original_fchdir(fd);
}

static int (*original_chroot)(const char* pathname);
static int replaced_chroot(const char* pathname) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_chroot(pathname);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_creat)(const char* pathname, mode_t mode);
static int replaced_creat(const char* pathname, mode_t mode) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_creat(pathname, mode);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_getfsstat)(struct statfs* buf, int bufsize, int flags);
static int replaced_getfsstat(struct statfs* buf, int bufsize, int flags) {
    if(isCallerTweak()) {
        return original_getfsstat(buf, bufsize, flags);
    }

    int result = original_getfsstat(buf, bufsize, flags);

    if(result != -1 && buf) {
        struct statfs* buf_ptr = buf;
        struct statfs* buf_end = buf + sizeof(struct statfs) * result;

        while(buf_ptr < buf_end) {
            if([_shadow isCPathRestricted:buf_ptr->f_mntonname]) {
                // handle bindfs/chroot
                strcpy(buf_ptr->f_mntonname, "/");
            }

            if(strcmp(buf_ptr->f_mntonname, "/") == 0) {
                // Mark rootfs read-only
                buf_ptr->f_flags |= MNT_RDONLY | MNT_ROOTFS | MNT_SNAPSHOT;
                break;
            }

            buf_ptr++;
        }
    }

    return result;
}

static int (*original_getmntinfo)(struct statfs** mntbufp, int flags);
static int replaced_getmntinfo(struct statfs** mntbufp, int flags) {
    if(isCallerTweak()) {
        return original_getmntinfo(mntbufp, flags);
    }

    int result = original_getmntinfo(mntbufp, flags);

    if(result > 0) {
        struct statfs** buf_ptr = mntbufp;
        struct statfs** buf_end = mntbufp + sizeof(struct statfs *) * result;

        while(buf_ptr < buf_end) {
            if([_shadow isCPathRestricted:(*buf_ptr)->f_mntonname]) {
                // handle bindfs/chroot
                strcpy((*buf_ptr)->f_mntonname, "/");
            }

            if(strcmp((*buf_ptr)->f_mntonname, "/") == 0) {
                // Mark rootfs read-only
                (*buf_ptr)->f_flags |= MNT_RDONLY | MNT_ROOTFS | MNT_SNAPSHOT;
                break;
            }

            buf_ptr++;
        }
    }

    return result;
}

static int (*original_statfs)(const char* pathname, struct statfs* buf);
static int replaced_statfs(const char* pathname, struct statfs* buf) {
    if(isCallerTweak()) {
        return original_statfs(pathname, buf);
    }

    if([_shadow isCPathRestricted:pathname]) {
        errno = ENOENT;
        return -1;
    }

    int result = original_statfs(pathname, buf);

    if(result == 0) {
        // Modify flags
        if(buf) {
            if([_shadow isCPathRestricted:buf->f_mntonname]) {
                // handle bindfs/chroot
                strcpy(buf->f_mntonname, "/");
            }

            if(strcmp(buf->f_mntonname, "/") == 0) {
                // Mark rootfs read-only
                buf->f_flags |= MNT_RDONLY | MNT_ROOTFS | MNT_SNAPSHOT;
            }
        }
    }

    return result;
}

static int (*original_fstatfs)(int fd, struct statfs* buf);
static int replaced_fstatfs(int fd, struct statfs* buf) {
    if(isCallerTweak()) {
        return original_fstatfs(fd, buf);
    }

    if(fd != fileno(stderr)
    && fd != fileno(stdout)
    && fd != fileno(stdin)) {
        // Get file descriptor path.
        char pathname[PATH_MAX];

        if(fcntl(fd, F_GETPATH, pathname) != -1 && [_shadow isCPathRestricted:pathname]) {
            errno = EBADF;
            return -1;
        }
    }

    int result = original_fstatfs(fd, buf);

    if(result == 0) {
        // Modify flags
        if(buf) {
            if([_shadow isCPathRestricted:buf->f_mntonname]) {
                // handle bindfs/chroot
                strcpy(buf->f_mntonname, "/");
            }

            if(strcmp(buf->f_mntonname, "/") == 0) {
                // Mark rootfs read-only
                buf->f_flags |= MNT_RDONLY | MNT_ROOTFS | MNT_SNAPSHOT;
            }
        }
    }

    return result;
}

static int (*original_statvfs)(const char* pathname, struct statvfs* buf);
static int replaced_statvfs(const char* pathname, struct statvfs* buf) {
    if(isCallerTweak()) {
        return original_statvfs(pathname, buf);
    }

    if([_shadow isCPathRestricted:pathname]) {
        errno = ENOENT;
        return -1;
    }

    // use statfs to get f_mntonname
    struct statfs st;
    if(statfs(pathname, &st) == -1) {
        memset(buf, 0, sizeof(struct statvfs));
        errno = ENOENT;
        return -1;
    }

    int result = original_statvfs(pathname, buf);

    if(result == 0) {
        if([_shadow isCPathRestricted:st.f_mntonname]) {
            // handle bindfs/chroot
            strcpy(st.f_mntonname, "/");
        }
        
        if(strcmp(st.f_mntonname, "/") == 0) {
            // Mark rootfs read-only
            buf->f_flag |= MNT_RDONLY | MNT_ROOTFS | MNT_SNAPSHOT;
        }
    }

    return result;
}

static int (*original_fstatvfs)(int fd, struct statvfs* buf);
static int replaced_fstatvfs(int fd, struct statvfs* buf) {
    if(isCallerTweak()) {
        return original_fstatvfs(fd, buf);
    }

    // use fstatfs to get f_mntonname, replaced version for path checking
    struct statfs st;
    if(replaced_fstatfs(fd, &st) == -1) {
        memset(buf, 0, sizeof(struct statvfs));
        errno = EBADF;
        return -1;
    }

    int result = original_fstatvfs(fd, buf);

    if(result == 0) {
        if([_shadow isCPathRestricted:st.f_mntonname]) {
            // handle bindfs/chroot
            strcpy(st.f_mntonname, "/");
        }

        if(strcmp(st.f_mntonname, "/") == 0) {
            // Mark rootfs read-only
            buf->f_flag |= MNT_RDONLY | MNT_ROOTFS | MNT_SNAPSHOT;
        }
    }

    return result;
}

static int (*original_stat)(const char* pathname, struct stat* buf);
static int replaced_stat(const char* pathname, struct stat* buf) {
    int result = original_stat(pathname, buf);

    if(result != -1 && !isCallerTweak() && [_shadow isCPathRestricted:pathname]) {
        if(buf) {
            memset(buf, 0, sizeof(struct stat));
        }
        
        errno = ENOENT;
        return -1;
    }

    return result;
}

static int (*original_lstat)(const char* pathname, struct stat* buf);
static int replaced_lstat(const char* pathname, struct stat* buf) {
    if(isCallerTweak()) {
        return original_lstat(pathname, buf);
    }

    struct stat _buf;
    int result = original_lstat(pathname, &_buf);

    if(result == 0) {
        NSString* path = [NSString stringWithUTF8String:pathname];

        // Only use resolve flag if target is not a symlink.
        if([_shadow isPathRestricted:path options:@{kShadowRestrictionEnableResolve : @(!(_buf.st_mode & S_IFLNK))}]) {
            errno = ENOENT;
            return -1;
        }
    }

    if(buf) {
        memcpy(buf, &_buf, sizeof(struct stat));
    }

    return result;
}

static int (*original_fstat)(int fd, struct stat* buf);
static int replaced_fstat(int fd, struct stat* buf) {
    if(isCallerTweak()) {
        return original_fstat(fd, buf);
    }

    if(fd != fileno(stderr)
    && fd != fileno(stdout)
    && fd != fileno(stdin)) {
        // Get file descriptor path.
        char pathname[PATH_MAX];

        if(fcntl(fd, F_GETPATH, pathname) != -1 && [_shadow isCPathRestricted:pathname]) {
            errno = EBADF;
            return -1;
        }
    }

    return original_fstat(fd, buf);
}

static int (*original_fstatat)(int dirfd, const char* pathname, struct stat* buf, int flags);
static int replaced_fstatat(int dirfd, const char* pathname, struct stat* buf, int flags) {
    if(isCallerTweak()) {
        return original_fstatat(dirfd, pathname, buf, flags);
    }

    if(pathname
    && dirfd != fileno(stderr)
    && dirfd != fileno(stdout)
    && dirfd != fileno(stdin)) {
        NSString* path = [NSString stringWithUTF8String:pathname];

        // Get file descriptor path.
        char pathnameParent[PATH_MAX];
        NSString* pathParent = nil;

        if(dirfd == AT_FDCWD) {
            pathParent = [[NSFileManager defaultManager] currentDirectoryPath];
        } else if(fcntl(dirfd, F_GETPATH, pathnameParent) != -1) {
            pathParent = [NSString stringWithUTF8String:pathnameParent];
        }

        if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : pathParent}]) {
            errno = [path isAbsolutePath] ? ENOENT : EBADF;
            return -1;
        }
    }

    return original_fstatat(dirfd, pathname, buf, flags);
}

static int (*original_faccessat)(int dirfd, const char* pathname, int mode, int flags);
static int replaced_faccessat(int dirfd, const char* pathname, int mode, int flags) {
    if(isCallerTweak()) {
        return original_faccessat(dirfd, pathname, mode, flags);
    }

    if(pathname
    && dirfd != fileno(stderr)
    && dirfd != fileno(stdout)
    && dirfd != fileno(stdin)) {
        NSString* path = [NSString stringWithUTF8String:pathname];

        // Get file descriptor path.
        char pathnameParent[PATH_MAX];
        NSString* pathParent = nil;

        if(dirfd == AT_FDCWD) {
            pathParent = [[NSFileManager defaultManager] currentDirectoryPath];
        } else if(fcntl(dirfd, F_GETPATH, pathnameParent) != -1) {
            pathParent = [NSString stringWithUTF8String:pathnameParent];
        }

        if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : pathParent}]) {
            errno = [path isAbsolutePath] ? ENOENT : EBADF;
            return -1;
        }
    }

    return original_faccessat(dirfd, pathname, mode, flags);
}

// static int (*original_scandir)(const char* dirname, struct dirent*** namelist, int (*select)(struct dirent *), int (*compar)(const void *, const void *));
// static int replaced_scandir(const char* dirname, struct dirent*** namelist, int (*select)(struct dirent *), int (*compar)(const void *, const void *)) {
//     int result = original_scandir(dirname, namelist, select, compar);

//     return result;
// }

static int (*original_readdir_r)(DIR* dirp, struct dirent* entry, struct dirent** oresult);
static int replaced_readdir_r(DIR* dirp, struct dirent* entry, struct dirent** oresult) {
    if(isCallerTweak()) {
        return original_readdir_r(dirp, entry, oresult);
    }

    int result = original_readdir_r(dirp, entry, oresult);
    
    if(result == 0 && *oresult) {
        int fd = dirfd(dirp);

        // Get file descriptor path.
        char pathname[PATH_MAX];

        if(fcntl(fd, F_GETPATH, pathname) != -1) {
            NSString* pathParent = [NSString stringWithUTF8String:pathname];

            do {
                if([_shadow isPathRestricted:@((*oresult)->d_name) options:@{kShadowRestrictionWorkingDir : pathParent}]) {
                    // call readdir again to skip ahead
                    result = original_readdir_r(dirp, entry, oresult);
                } else {
                    break;
                }
            } while(result == 0 && *oresult);
        }
    }

    return result;
}

static struct dirent* (*original_readdir)(DIR* dirp);
static struct dirent* replaced_readdir(DIR* dirp) {
    if(isCallerTweak()) {
        return original_readdir(dirp);
    }

    struct dirent* result = original_readdir(dirp);
    
    if(result) {
        int fd = dirfd(dirp);

        // Get file descriptor path.
        char pathname[PATH_MAX];
        
        if(fcntl(fd, F_GETPATH, pathname) != -1) {
            NSString* pathParent = [NSString stringWithUTF8String:pathname];

            do {
                if([_shadow isPathRestricted:@(result->d_name) options:@{kShadowRestrictionWorkingDir : pathParent}]) {
                    // call readdir again to skip ahead
                    result = original_readdir(dirp);
                } else {
                    break;
                }
            } while(result);
        }
    }

    return result;
}

static FILE* (*original_fopen)(const char* pathname, const char* mode);
static FILE* replaced_fopen(const char* pathname, const char* mode) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_fopen(pathname, mode);
    }

    errno = ENOENT;
    return NULL;
}

static FILE* (*original_freopen)(const char* pathname, const char* mode, FILE* stream);
static FILE* replaced_freopen(const char* pathname, const char* mode, FILE* stream) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_freopen(pathname, mode, stream);
    }

    errno = ENOENT;
    return NULL;
}

static char* (*original_realpath)(const char* pathname, char* resolved_path);
static char* replaced_realpath(const char* pathname, char* resolved_path) {
    char* result = original_realpath(pathname, resolved_path);

    if(result && !isCallerTweak() && [_shadow isCPathRestricted:pathname]) {
        errno = ENOENT;
        return NULL;
    }

    return result;
}

static int (*original_getattrlist)(const char* path, struct attrlist* attrList, void* attrBuf, size_t attrBufSize, unsigned long options);
static int replaced_getattrlist(const char* path, struct attrlist* attrList, void* attrBuf, size_t attrBufSize, unsigned long options) {
    int result = original_getattrlist(path, attrList, attrBuf, attrBufSize, options);

    if(result != -1 && !isCallerTweak() && [_shadow isCPathRestricted:path]) {
        errno = ENOENT;
        return -1;
    }

    return result;
}

static int (*original_symlink)(const char* path1, const char* path2);
static int replaced_symlink(const char* path1, const char* path2) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:path2]) {
        return original_symlink(path1, path2);
    }

    errno = EACCES;
    return -1;
}

static int (*original_link)(const char* path1, const char* path2);
static int replaced_link(const char* path1, const char* path2) {
    if(isCallerTweak() || !([_shadow isCPathRestricted:path1] || [_shadow isCPathRestricted:path2])) {
        return original_link(path1, path2);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_rename)(const char* old, const char* new);
static int replaced_rename(const char* old, const char* new) {
    if(isCallerTweak() || !([_shadow isCPathRestricted:old] || [_shadow isCPathRestricted:new])) {
        return original_rename(old, new);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_remove)(const char* pathname);
static int replaced_remove(const char* pathname) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_remove(pathname);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_unlink)(const char* pathname);
static int replaced_unlink(const char* pathname) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_unlink(pathname);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_unlinkat)(int dirfd, const char* pathname, int flags);
static int replaced_unlinkat(int dirfd, const char* pathname, int flags) {
    if(isCallerTweak()) {
        return original_unlinkat(dirfd, pathname, flags);
    }

    if(pathname
    && dirfd != fileno(stderr)
    && dirfd != fileno(stdout)
    && dirfd != fileno(stdin)) {
        NSString* path = [NSString stringWithUTF8String:pathname];

        // Get file descriptor path.
        char pathnameParent[PATH_MAX];
        NSString* pathParent = nil;

        if(dirfd == AT_FDCWD) {
            pathParent = [[NSFileManager defaultManager] currentDirectoryPath];
        } else if(fcntl(dirfd, F_GETPATH, pathnameParent) != -1) {
            pathParent = [NSString stringWithUTF8String:pathnameParent];
        }

        if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : pathParent}]) {
            errno = [path isAbsolutePath] ? ENOENT : EBADF;
            return -1;
        }
    }

    return original_unlinkat(dirfd, pathname, flags);
}

static int (*original_rmdir)(const char* pathname);
static int replaced_rmdir(const char* pathname) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_rmdir(pathname);
    }

    errno = ENOENT;
    return -1;
}

static long (*original_pathconf)(const char* pathname, int name);
static long replaced_pathconf(const char* pathname, int name) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_pathconf(pathname, name);
    }

    errno = ENOENT;
    return -1;
}

static long (*original_fpathconf)(int fd, int name);
static long replaced_fpathconf(int fd, int name) {
    if(isCallerTweak()) {
        return original_fpathconf(fd, name);
    }
    
    if(fd != fileno(stderr)
    && fd != fileno(stdout)
    && fd != fileno(stdin)) {
        // Get file descriptor path.
        char pathname[PATH_MAX];

        if(fcntl(fd, F_GETPATH, pathname) != -1 && [_shadow isCPathRestricted:pathname]) {
            errno = EBADF;
            return -1;
        }
    }

    return original_fpathconf(fd, name);
}

static int (*original_utimes)(const char* pathname, const struct timeval times[2]);
static int replaced_utimes(const char* pathname, const struct timeval times[2]) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_utimes(pathname, times);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_futimes)(int fd, const struct timeval times[2]);
static int replaced_futimes(int fd, const struct timeval times[2]) {
    if(isCallerTweak()) {
        return original_futimes(fd, times);
    }
    
    if(fd != fileno(stderr)
    && fd != fileno(stdout)
    && fd != fileno(stdin)) {
        // Get file descriptor path.
        char pathname[PATH_MAX];

        if(fcntl(fd, F_GETPATH, pathname) != -1 && [_shadow isCPathRestricted:pathname]) {
            errno = EBADF;
            return -1;
        }
    }

    return original_futimes(fd, times);
}

static char* (*original_getenv)(const char* name);
static char* replaced_getenv(const char* name) {
    if(isCallerTweak()) {
        return original_getenv(name);
    }

    char* result = original_getenv(name);

    // if(result && name) {
    //     if(strcmp(name, "DYLD_INSERT_LIBRARIES") == 0
    //     || strcmp(name, "_MSSafeMode") == 0
    //     || strcmp(name, "_SafeMode") == 0
    //     || strcmp(name, "_SubstituteSafeMode") == 0) {
    //         return NULL;
    //     }

    //     if(strcmp(name, "SHELL") == 0) {
    //         return "/bin/sh";
    //     }
    // }

    return result;
}

static int (*original_ptrace)(int _request, pid_t _pid, caddr_t _addr, int _data);
static int replaced_ptrace(int _request, pid_t _pid, caddr_t _addr, int _data) {
    if(_request == PT_DENY_ATTACH) {
        return 0;
    }

    return original_ptrace(_request, _pid, _addr, _data);
}

static int (*original_sysctl)(int* name, u_int namelen, void* oldp, size_t* oldlenp, void* newp, size_t newlen);
static int replaced_sysctl(int* name, u_int namelen, void* oldp, size_t* oldlenp, void* newp, size_t newlen) {
    if(namelen == 4
    && name[0] == CTL_KERN
    && name[1] == KERN_PROC
    && name[2] == KERN_PROC_ALL
    && name[3] == 0) {
        // Running process check.
        *oldlenp = 0;
        return 0;
    }

    int ret = original_sysctl(name, namelen, oldp, oldlenp, newp, newlen);

    if(ret == 0
    && name[0] == CTL_KERN
    && name[1] == KERN_PROC
    && name[2] == KERN_PROC_PID
    && name[3] == getpid()) {
        // Remove trace flag.
        if(oldp) {
            struct kinfo_proc *p = ((struct kinfo_proc *) oldp);

            if(p->kp_proc.p_flag & P_TRACED) {
                p->kp_proc.p_flag &= ~P_TRACED;
            }

            if(p->kp_proc.p_flag & P_SELECT) {
                p->kp_proc.p_flag &= ~P_SELECT;
            }
        }
    }

    return ret;
}

static pid_t replaced_getppid() {
    return 1;
}

static int (*original_open)(const char *pathname, int oflag, ...);
static int replaced_open(const char *pathname, int oflag, ...) {
    void* arg;
    va_list args;
    va_start(args, oflag);
    arg = va_arg(args, void *);
    va_end(args);

    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original_open(pathname, oflag, arg);
    }

    errno = ENOENT;
    return -1;
}

static int (*original_openat)(int dirfd, const char *pathname, int oflag, ...);
static int replaced_openat(int dirfd, const char *pathname, int oflag, ...) {
    void* arg;
    va_list args;
    va_start(args, oflag);
    arg = va_arg(args, void *);
    va_end(args);

    if(isCallerTweak()) {
        return original_openat(dirfd, pathname, oflag, arg);
    }

    if(pathname
    && dirfd != fileno(stderr)
    && dirfd != fileno(stdout)
    && dirfd != fileno(stdin)) {
        NSString* path = [NSString stringWithUTF8String:pathname];

        // Get file descriptor path.
        char pathnameParent[PATH_MAX];
        NSString* pathParent = nil;

        if(dirfd == AT_FDCWD) {
            pathParent = [[NSFileManager defaultManager] currentDirectoryPath];
        } else if(fcntl(dirfd, F_GETPATH, pathnameParent) != -1) {
            pathParent = [NSString stringWithUTF8String:pathnameParent];
        }

        if([_shadow isPathRestricted:path options:@{kShadowRestrictionWorkingDir : pathParent}]) {
            errno = [path isAbsolutePath] ? ENOENT : EBADF;
            return -1;
        }
    }

    return original_openat(dirfd, pathname, oflag, arg);
}

static DIR* (*original___opendir2)(const char* pathname, size_t bufsize);
static DIR* replaced___opendir2(const char* pathname, size_t bufsize) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:pathname]) {
        return original___opendir2(pathname, bufsize);
    }

    errno = ENOENT;
    return NULL;
}

void shadowhook_libc(HKSubstitutor* hooks) {
    MSHookFunction(access, replaced_access, (void **) &original_access);
    MSHookFunction(chdir, replaced_chdir, (void **) &original_chdir);
    MSHookFunction(chroot, replaced_chroot, (void **) &original_chroot);
    MSHookFunction(creat, replaced_creat, (void **) &original_creat);
    MSHookFunction(statfs, replaced_statfs, (void **) &original_statfs);
    MSHookFunction(fstatfs, replaced_fstatfs, (void **) &original_fstatfs);
    MSHookFunction(statvfs, replaced_statvfs, (void **) &original_statvfs);
    MSHookFunction(fstatvfs, replaced_fstatvfs, (void **) &original_fstatvfs);
    MSHookFunction(stat, replaced_stat, (void **) &original_stat);
    MSHookFunction(lstat, replaced_lstat, (void **) &original_lstat);
    MSHookFunction(faccessat, replaced_faccessat, (void **) &original_faccessat);
    MSHookFunction(readdir_r, replaced_readdir_r, (void **) &original_readdir_r);
    MSHookFunction(readdir, replaced_readdir, (void **) &original_readdir);
    MSHookFunction(fopen, replaced_fopen, (void **) &original_fopen);
    MSHookFunction(freopen, replaced_freopen, (void **) &original_freopen);
    MSHookFunction(realpath, replaced_realpath, (void **) &original_realpath);
    MSHookFunction(readlink, replaced_readlink, (void **) &original_readlink);
    MSHookFunction(readlinkat, replaced_readlinkat, (void **) &original_readlinkat);
    MSHookFunction(link, replaced_link, (void **) &original_link);
    // MSHookFunction(scandir, replaced_scandir, (void **) &original_scandir);
    MSHookFunction(getmntinfo, replaced_getmntinfo, (void **) &original_getmntinfo);
    MSHookFunction(getattrlist, replaced_getattrlist, (void **) &original_getattrlist);
    MSHookFunction(symlink, replaced_symlink, (void **) &original_symlink);
    MSHookFunction(rename, replaced_rename, (void **) &original_rename);
    MSHookFunction(remove, replaced_remove, (void **) &original_remove);
    MSHookFunction(unlink, replaced_unlink, (void **) &original_unlink);
    MSHookFunction(unlinkat, replaced_unlinkat, (void **) &original_unlinkat);
    MSHookFunction(rmdir, replaced_rmdir, (void **) &original_rmdir);
    MSHookFunction(pathconf, replaced_pathconf, (void **) &original_pathconf);
    MSHookFunction(fpathconf, replaced_fpathconf, (void **) &original_fpathconf);
    MSHookFunction(utimes, replaced_utimes, (void **) &original_utimes);
    MSHookFunction(futimes, replaced_futimes, (void **) &original_futimes);
    MSHookFunction(fchdir, replaced_fchdir, (void **) &original_fchdir);
    MSHookFunction(getfsstat, replaced_getfsstat, (void **) &original_getfsstat);
    MSHookFunction(fstat, replaced_fstat, (void **) &original_fstat);
    MSHookFunction(fstatat, replaced_fstatat, (void **) &original_fstatat);
}

void shadowhook_libc_envvar(HKSubstitutor* hooks) {
    MSHookFunction(getenv, replaced_getenv, (void **) &original_getenv);
}

void shadowhook_libc_lowlevel(HKSubstitutor* hooks) {
    MSHookFunction(open, replaced_open, (void **) &original_open);
    MSHookFunction(openat, replaced_openat, (void **) &original_openat);
    MSHookFunction(__opendir2, replaced___opendir2, (void **) &original___opendir2);
}

void shadowhook_libc_antidebugging(HKSubstitutor* hooks) {
    MSHookFunction(ptrace, replaced_ptrace, (void **) &original_ptrace);
    MSHookFunction(sysctl, replaced_sysctl, (void **) &original_sysctl);
    MSHookFunction(getppid, replaced_getppid, NULL);
}

```

`Shadow.dylib/hooks/mach.x`:

```x
#import "hooks.h"

static kern_return_t (*original_bootstrap_check_in)(mach_port_t bp, const char* service_name, mach_port_t* sp);
static kern_return_t replaced_bootstrap_check_in(mach_port_t bp, const char* service_name, mach_port_t* sp) {
    if(!isCallerTweak() && service_name) {
        NSLog(@"%@: %s", @"bootstrap_check_in", service_name);

        if(strstr(service_name, "cy:") == service_name
        || strstr(service_name, "lh:") == service_name
        || strstr(service_name, "rbs:") == service_name
        || strstr(service_name, "org.coolstar") == service_name
        || strstr(service_name, "com.ex") == service_name
        || strstr(service_name, "com.saurik") == service_name
        || strstr(service_name, "com.opa334") == service_name
        || strstr(service_name, "me.jjolano") == service_name
        || strstr(service_name, "jailbreakd") != NULL){
            return BOOTSTRAP_UNKNOWN_SERVICE;
        }
    }

    return original_bootstrap_check_in(bp, service_name, sp);
}

static kern_return_t (*original_bootstrap_look_up)(mach_port_t bp, const char* service_name, mach_port_t* sp);
static kern_return_t replaced_bootstrap_look_up(mach_port_t bp, const char* service_name, mach_port_t* sp) {
    if(!isCallerTweak() && service_name) {
        NSLog(@"%@: %s", @"bootstrap_look_up", service_name);

        if(strstr(service_name, "cy:") == service_name
        || strstr(service_name, "lh:") == service_name
        || strstr(service_name, "rbs:") == service_name
        || strstr(service_name, "org.coolstar") == service_name
        || strstr(service_name, "com.ex") == service_name
        || strstr(service_name, "com.saurik") == service_name
        || strstr(service_name, "com.opa334") == service_name
        || strstr(service_name, "me.jjolano") == service_name
        || strstr(service_name, "jailbreakd") != NULL){
            return BOOTSTRAP_UNKNOWN_SERVICE;
        }
    }

    return original_bootstrap_look_up(bp, service_name, sp);
}

void shadowhook_mach(HKSubstitutor* hooks) {
    MSHookFunction(bootstrap_check_in, replaced_bootstrap_check_in, (void **) &original_bootstrap_check_in);
    MSHookFunction(bootstrap_look_up, replaced_bootstrap_look_up, (void **) &original_bootstrap_look_up);
}

```

`Shadow.dylib/hooks/mem.x`:

```x
#import "hooks.h"

static kern_return_t (*original_vm_region_64)(vm_map_read_t target_task, vm_address_t* address, vm_size_t* size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t* infoCnt, mach_port_t* object_name);
static kern_return_t replaced_vm_region_64(vm_map_read_t target_task, vm_address_t* address, vm_size_t* size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t* infoCnt, mach_port_t* object_name) {
    kern_return_t result = original_vm_region_64(target_task, address, size, flavor, info, infoCnt, object_name);

    if(!isCallerTweak() && result == KERN_SUCCESS && flavor != VM_REGION_TOP_INFO) {
        // Hide executable flag
        vm_region_basic_info_64_t rinfo = (vm_region_basic_info_64_t)info;

        if(rinfo->protection) {
            rinfo->protection |= VM_PROT_READ;
            rinfo->protection &= ~VM_PROT_EXECUTE;
        }
    }

    return result;
}

static kern_return_t (*original_vm_region_recurse_64)(vm_map_read_t target_task, vm_address_t* address, vm_size_t* size, natural_t* nesting_depth, vm_region_recurse_info_t info, mach_msg_type_number_t* infoCnt);
static kern_return_t replaced_vm_region_recurse_64(vm_map_read_t target_task, vm_address_t* address, vm_size_t* size, natural_t* nesting_depth, vm_region_recurse_info_t info, mach_msg_type_number_t* infoCnt) {
    kern_return_t result = original_vm_region_recurse_64(target_task, address, size, nesting_depth, info, infoCnt);

    if(!isCallerTweak() && result == KERN_SUCCESS) {
        // Hide executable flag
        vm_region_basic_info_64_t rinfo = (vm_region_basic_info_64_t)info;

        if(rinfo->protection) {
            rinfo->protection |= VM_PROT_READ;
            rinfo->protection &= ~VM_PROT_EXECUTE;
        }
    }

    return result;
}

void shadowhook_mem(HKSubstitutor* hooks) {
    MSHookFunction(vm_region_64, replaced_vm_region_64, (void **) &original_vm_region_64);
    MSHookFunction(vm_region_recurse_64, replaced_vm_region_recurse_64, (void **) &original_vm_region_recurse_64);
}

```

`Shadow.dylib/hooks/objc.x`:

```x
#import "hooks.h"

// %group shadowhook_objc
// %hook NSObject
// + (Class)class {
//     Class result = %orig;

//     if(!isCallerTweak() && [_shadow isAddrRestricted:(__bridge const void *)result]) {
//         return nil;
//     }

//     return result;
// }
// %end
// %end

static const char* (*original_class_getImageName)(Class cls);
static const char* replaced_class_getImageName(Class cls) {
    const char* result = original_class_getImageName(cls);

    if(isCallerTweak() || ![_shadow isCPathRestricted:result]) {
        return result;
    }

    return [[Shadow getExecutablePath] fileSystemRepresentation];
}

static const char * _Nonnull * (*original_objc_copyImageNames)(unsigned int *outCount);
static const char * _Nonnull * replaced_objc_copyImageNames(unsigned int *outCount) {
    const char * _Nonnull * result = original_objc_copyImageNames(outCount);

    if(isCallerTweak() || !result || !outCount) {
        return result;
    }

    const char* exec_name = _dyld_get_image_name(0);
    unsigned int i;

    for(i = 0; i < *outCount; i++) {
        if(strcmp(result[i], exec_name) == 0) {
            // Stop after app executable.
            // todo: improve this to filter instead
            *outCount = (i + 1);
            break;
        }
    }

    return result;
}

static const char * _Nonnull * (*original_objc_copyClassNamesForImage)(const char* image, unsigned int *outCount);
static const char * _Nonnull * replaced_objc_copyClassNamesForImage(const char* image, unsigned int *outCount) {
    if(isCallerTweak() || ![_shadow isCPathRestricted:image]) {
        return original_objc_copyClassNamesForImage(image, outCount);
    }

    return NULL;
}

static Class (*original_NSClassFromString)(NSString* aClassName);
static Class replaced_NSClassFromString(NSString* aClassName) {
    Class result = original_NSClassFromString(aClassName);

    if(isCallerTweak() || ![_shadow isAddrRestricted:(__bridge const void *)result]) {
        return result;
    }

    return nil;
}

typedef struct _NXMapTable NXMapTable;
typedef struct _NXHashTable NXHashTable;

extern void* NXMapGet(NXMapTable *table, const char *name);
extern void* NXHashGet(NXHashTable *table, const void *data);

static void* (*original_NXMapGet)(NXMapTable *table, const char *name);
static void* replaced_NXMapGet(NXMapTable *table, const char *name) {
    void* result = original_NXMapGet(table, name);

    if(isCallerTweak() || ![_shadow isAddrRestricted:result]) {
        return result;
    }

    return nil;
}

static void* (*original_NXHashGet)(NXHashTable *table, const void *data);
static void* replaced_NXHashGet(NXHashTable *table, const void *data) {
    void* result = original_NXHashGet(table, data);

    if(isCallerTweak() || ![_shadow isAddrRestricted:result]) {
        return result;
    }

    return nil;
}

void shadowhook_objc(HKSubstitutor* hooks) {
    // %init(shadowhook_objc);
    MSHookFunction(class_getImageName, replaced_class_getImageName, (void **) &original_class_getImageName);
    MSHookFunction(objc_copyClassNamesForImage, replaced_objc_copyClassNamesForImage, (void **) &original_objc_copyClassNamesForImage);
    MSHookFunction(objc_copyImageNames, replaced_objc_copyImageNames, (void **) &original_objc_copyImageNames);
}

void shadowhook_objc_hidetweakclasses(HKSubstitutor* hooks) {
    MSHookFunction(NSClassFromString, replaced_NSClassFromString, (void **) &original_NSClassFromString);
    MSHookFunction(NXMapGet, replaced_NXMapGet, (void **) &original_NXMapGet);
    MSHookFunction(NXHashGet, replaced_NXHashGet, (void **) &original_NXHashGet);
}

```

`Shadow.dylib/hooks/sandbox.x`:

```x
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#import "hooks.h"

// extern void* SecTaskCopyValueForEntitlement(void* task, CFStringRef entitlement, CFErrorRef  _Nullable *error);
// extern void* SecTaskCreateFromSelf(CFAllocatorRef allocator);

// extern int MISValidateSignatureAndCopyInfo(NSString* file, NSDictionary* options, NSDictionary** info);
// extern NSString* kMISValidationOptionAllowAdHocSigning;
// extern NSString* kMISValidationOptionRespectUppTrustAndAuthorization;

// static int (*original_MISValidateSignatureAndCopyInfo)(NSString* file, NSDictionary* options, NSDictionary** info);
// static int replaced_MISValidateSignatureAndCopyInfo(NSString* file, NSDictionary* options, NSDictionary** info) {
//     int result =  original_MISValidateSignatureAndCopyInfo(file, options, info);

//     if(result == 0) {
//         // Don't allow checking trust cache for self
//         if([file hasPrefix:[[NSBundle mainBundle] bundlePath]]
//         && options[kMISValidationOptionAllowAdHocSigning]
//         && options[kMISValidationOptionRespectUppTrustAndAuthorization]) {
//             return -1;
//         }

//         if([_shadow isPathRestricted:file]) {
//             return -1;
//         }
//     }

//     return result;
// }

static kern_return_t (*original_task_for_pid)(task_port_t task, pid_t pid, task_port_t* target);
static kern_return_t replaced_task_for_pid(task_port_t task, pid_t pid, task_port_t* target) {
    if(!isCallerTweak()) {
        NSLog(@"%@: %d", @"task_for_pid", pid);
        return KERN_FAILURE;
    }
    
    return original_task_for_pid(task, pid, target);
}

static kern_return_t (*original_host_get_special_port)(host_priv_t host_priv, int node, int which, mach_port_t* port);
static kern_return_t replaced_host_get_special_port(host_priv_t host_priv, int node, int which, mach_port_t* port) {
    if(!isCallerTweak()) {
        NSLog(@"%@: %d", @"host_get_special_port", which);

        if(port) {
            *port = MACH_PORT_NULL;
        }

        return KERN_FAILURE;
    }

    return original_host_get_special_port(host_priv, node, which, port);
}

static kern_return_t (*original_task_get_special_port)(task_inspect_t task, int which_port, mach_port_t *special_port);
static kern_return_t replaced_task_get_special_port(task_inspect_t task, int which_port, mach_port_t *special_port) {
    if(!isCallerTweak()) {
        NSLog(@"%@: %d", @"task_get_special_port", which_port);

        if(special_port) {
            *special_port = MACH_PORT_NULL;
        }
        
        return KERN_FAILURE;
    }

    return original_task_get_special_port(task, which_port, special_port);
}

// static kern_return_t (*original_task_get_exception_ports)(task_t task, exception_mask_t exception_mask, exception_mask_array_t masks, mach_msg_type_number_t *masksCnt, exception_handler_array_t old_handlers, exception_behavior_array_t old_behaviors, exception_flavor_array_t old_flavors);
// static kern_return_t replaced_task_get_exception_ports(task_t task, exception_mask_t exception_mask, exception_mask_array_t masks, mach_msg_type_number_t *masksCnt, exception_handler_array_t old_handlers, exception_behavior_array_t old_behaviors, exception_flavor_array_t old_flavors) {
//     return original_task_get_exception_ports(task, exception_mask, masks, masksCnt, old_handlers, old_behaviors, old_flavors);
// }

static int (*original_sigaction)(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);
static int replaced_sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact) {
    int result = original_sigaction(sig, act, oact);

    if(!isCallerTweak()) {
        NSLog(@"%@: %d", @"sigaction", sig);
    
        if(oact && ([_shadow isAddrRestricted:(oact->__sigaction_u).__sa_handler] || [_shadow isAddrRestricted:(oact->__sigaction_u).__sa_sigaction])) {
            memset(oact, 0, sizeof(struct sigaction));
        }
    }

    return result;
}

static int (*original_sandbox_check)(pid_t pid, const char *operation, enum sandbox_filter_type type, ...);
static int replaced_sandbox_check(pid_t pid, const char *operation, enum sandbox_filter_type type, ...) {
    void* data[5];
    va_list args;
    va_start(args, type);

    for(int i = 0; i < 5; i++) {
        data[i] = va_arg(args, void *);
    }

    va_end(args);

    if(!isCallerTweak() && operation && strcmp(operation, "mach-lookup") == 0 && data[0]) {
        const char* name = (const char *)data[0];

        if(strstr(name, "cy:") == name
        || strstr(name, "lh:") == name
        || strstr(name, "rbs:") == name
        || strstr(name, "jailbreakd") == name
        || strstr(name, "org.coolstar") == name
        || strstr(name, "com.ex") == name
        || strstr(name, "org.saurik") == name) {
            return -1;
        }
    }

    return original_sandbox_check(pid, operation, type, data[0], data[1], data[2], data[3], data[4]);
}

static int (*original_fcntl)(int fd, int cmd, ...);
static int replaced_fcntl(int fd, int cmd, ...) {
    void* arg;
    va_list args;
    va_start(args, cmd);
    arg = va_arg(args, void *);
    va_end(args);

    if(!isCallerTweak()) {
        if(cmd == F_ADDSIGS) {
            // Prevent adding invalid code signatures.
            errno = EINVAL;
            return -1;
        }

        if(cmd == F_CHECK_LV) {
            // Library Validation
            if(arg) {
                original_fcntl(fd, cmd, arg);

                fchecklv_t* checkInfo = (fchecklv_t *) arg;
                ((char *) checkInfo->lv_error_message)[0] = '\0';

                return 0;
            }
        }

        if(cmd == F_ADDFILESIGS_RETURN) {
            return -1;
        }
    }

    return original_fcntl(fd, cmd, arg);
}

static int fn_enosys() {
    errno = ENOSYS;
    return -1;
}

// static int replaced_system(const char* command) {
//     if(command == NULL) return 0;
//     errno = ENOSYS;
//     return -1;
// }

void shadowhook_sandbox(HKSubstitutor* hooks) {
    // %init(shadowhook_sandbox);

    MSHookFunction(sandbox_check, replaced_sandbox_check, (void **) &original_sandbox_check);
    MSHookFunction(fcntl, replaced_fcntl, (void **) &original_fcntl);
    MSHookFunction(host_get_special_port, replaced_host_get_special_port, (void **) &original_host_get_special_port);
    MSHookFunction(task_get_special_port, replaced_task_get_special_port, (void **) &original_task_get_special_port);
    // MSHookFunction(task_get_exception_ports, replaced_task_get_exception_ports, (void **) &original_task_get_exception_ports);
    MSHookFunction(task_for_pid, replaced_task_for_pid, (void **) &original_task_for_pid);
    MSHookFunction(sigaction, replaced_sigaction, (void **) &original_sigaction);
    // MSHookFunction(MISValidateSignatureAndCopyInfo, replaced_MISValidateSignatureAndCopyInfo, (void **) &original_MISValidateSignatureAndCopyInfo);

    MSHookFunction(execle, fn_enosys, NULL);
    MSHookFunction(execlp, fn_enosys, NULL);
    MSHookFunction(execl, fn_enosys, NULL);
    MSHookFunction(execve, fn_enosys, NULL);
    MSHookFunction(execvp, fn_enosys, NULL);
    MSHookFunction(execv, fn_enosys, NULL);
    MSHookFunction(posix_spawn, fn_enosys, NULL);
    MSHookFunction(posix_spawnp, fn_enosys, NULL);
    MSHookFunction(fork, fn_enosys, NULL);
    MSHookFunction(vfork, fn_enosys, NULL);

    // void* sym_system = MSFindSymbol(NULL, "_system");

    // if(sym_system) {
    //     MSHookFunction(sym_system, replaced_system, NULL);
    // }
}

```

`Shadow.dylib/hooks/syscall.x`:

```x
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#import "hooks.h"

static int (*original_syscall)(int number, ...);
static int replaced_syscall(int number, ...) {
    NSLog(@"%@: %d", @"syscall", number);

	va_list args;
	va_start(args, number);

    void* stack[8];
    memcpy(stack, args, sizeof(stack));

    // Handle single pathname syscalls
    if(!isCallerTweak()) {
        if(number == SYS_open
        || number == SYS_chdir
        || number == SYS_access
        || number == SYS_execve
        || number == SYS_chroot
        || number == SYS_rmdir
        || number == SYS_stat
        || number == SYS_lstat
        || number == SYS_getattrlist
        || number == SYS_open_extended
        || number == SYS_stat_extended
        || number == SYS_lstat_extended
        || number == SYS_access_extended
        || number == SYS_stat64
        || number == SYS_lstat64
        || number == SYS_stat64_extended
        || number == SYS_lstat64_extended
        || number == SYS_readlink
        || number == SYS_pathconf) {
            const char* pathname = va_arg(args, const char *);

            if([_shadow isCPathRestricted:pathname]) {
                errno = ENOENT;
                return -1;
            }
        }
    }

    // Handle ptrace (anti debug)
    if(number == SYS_ptrace) {
        int _request = va_arg(args, int);

        if(_request == PT_DENY_ATTACH) {
            return 0;
        }
    }

    va_end(args);

    return original_syscall(number, stack[0], stack[1], stack[2], stack[3], stack[4], stack[5], stack[6], stack[7]);
}

static int (*original_csops)(pid_t pid, unsigned int ops, void* useraddr, size_t usersize);
static int replaced_csops(pid_t pid, unsigned int ops, void* useraddr, size_t usersize) {
    int ret = original_csops(pid, ops, useraddr, usersize);

    if(!isCallerTweak() && pid == getpid()) {
        if(ops == CS_OPS_STATUS) {
            // (Un)set some flags
            ret &= ~CS_PLATFORM_BINARY;
            ret &= ~CS_GET_TASK_ALLOW;
            ret &= ~CS_INSTALLER;
            ret &= ~CS_ENTITLEMENTS_VALIDATED;
            ret |= 0x0000300; /* CS_JIT_ALLOW */
            ret |= CS_REQUIRE_LV;
        }

        if(ops == CS_OPS_CDHASH) {
            // Hide CDHASH for trustcache checks
            errno = EBADEXEC;
            return -1;
        }

        if(ops == CS_OPS_MARKKILL) {
            errno = EBADEXEC;
            return -1;
        }
    }

    return ret;
}

// todo: research on "supervised syscalls"
void shadowhook_syscall(HKSubstitutor* hooks) {
    MSHookFunction(syscall, replaced_syscall, (void **) &original_syscall);
    MSHookFunction(csops, replaced_csops, (void **) &original_csops);

    // d4001001
    // const uint8_t bytes_svc80[] = {
    //     0x01, 0x10, 0x00, 0xd4
    // };

    // const uint8_t bytes_ret[] = {
    //     0xc0, 0x03, 0x5f, 0xd6
    // };
}

```

`Shadow.dylib/layout/Library/libSandy/ShadowSettings.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>AllowedProcesses</key>
		<array>
			<string>*</string>
		</array>
		<key>Extensions</key>
		<array>
			<dict>
				<key>type</key>
				<string>file</string>
				<key>extension_class</key>
				<string>com.apple.app-sandbox.read-write</string>
				<key>path</key>
				<string>/var/mobile/Library/Preferences/me.jjolano.shadow.plist</string>
			</dict>
		</array>
	</dict>
</plist>

```

`Shadow.framework/Backend.m`:

```m
#import <Shadow/Core+Utilities.h>
#import <Shadow/Backend.h>
#import <Shadow/Ruleset.h>
#import <RootBridge.h>

#import "../common.h"

@implementation ShadowBackend

- (instancetype)init {
    if((self = [super init])) {
        cache_restricted = [NSCache new];
        rulesets = [[self class] _loadRulesets];
    }

    return self;
}

+ (NSArray<ShadowRuleset *> *)_loadRulesets {
    NSMutableArray<ShadowRuleset *>* result = [NSMutableArray new];

    NSURL* ruleset_path_url = [NSURL fileURLWithPath:[RootBridge getJBPath:@SHADOW_RULESETS] isDirectory:YES];
    NSArray* ruleset_urls = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:ruleset_path_url includingPropertiesForKeys:@[] options:0 error:nil];

    if(ruleset_urls) {
        for(NSURL* url in ruleset_urls) {
            ShadowRuleset* ruleset = [ShadowRuleset rulesetWithURL:url];

            if(ruleset) {
                NSDictionary* info = [[ruleset internalDictionary] objectForKey:@"RulesetInfo"];

                if(info) {
                    NSLog(@"[ShadowBackend] loaded ruleset: '%@' by %@ (%@)", [info objectForKey:@"Name"], [info objectForKey:@"Author"], url);
                } else {
                    NSLog(@"[ShadowBackend] loaded ruleset: %@", url);
                }

                [result addObject:ruleset];
            } else {
                NSLog(@"[ShadowBackend] failed to load ruleset: %@", url);
            }
        }
    }

    return [result copy];
}

- (BOOL)isPathRestricted:(NSString *)path {
    if(!path || [path length] == 0 || [path isEqualToString:@"/"] || ![path isAbsolutePath]) {
        return NO;
    }

    NSNumber* cached = [cache_restricted objectForKey:path];

    if(cached) {
        return [cached boolValue];
    }

    __block BOOL compliant = YES;
    __block BOOL blacklisted = NO;
    __block BOOL whitelisted = NO;

    // Check rulesets
    [rulesets enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(ShadowRuleset* ruleset, NSUInteger idx, BOOL* stop) {
        if(![ruleset isPathCompliant:path]) {
            compliant = NO;
            *stop = YES;
        } else {
            if([ruleset isPathWhitelisted:path]) {
                whitelisted = YES;
                *stop = YES;
            } else {
                if([ruleset isPathBlacklisted:path]) {
                    blacklisted = YES;
                }
            }
        }
    }];

    BOOL restricted = !compliant || (blacklisted && !whitelisted);

    if(!restricted) {
        restricted = [self isPathRestricted:[path stringByDeletingLastPathComponent]];
    }

    [cache_restricted setObject:@(restricted) forKey:path];
    return restricted;
}

- (BOOL)isSchemeRestricted:(NSString *)scheme {
    if(!scheme || [scheme length] == 0) {
        return NO;
    }

    // Add some exceptions
    NSArray* exceptions = @[@"file", @"http", @"https"];

    if([exceptions containsObject:scheme]) {
        return NO;
    }

    __block BOOL restricted = NO;

    // Check rulesets
    [rulesets enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(ShadowRuleset* ruleset, NSUInteger idx, BOOL* stop) {
        if([ruleset isSchemeRestricted:scheme]) {
            restricted = YES;
            *stop = YES;
        }
    }];

    return restricted;
}
@end

```

`Shadow.framework/Core+Utilities.m`:

```m
#import <Shadow/Core+Utilities.h>
#import <Shadow/Ruleset.h>
#import <RootBridge.h>

#import "../vendor/apple/dyld_priv.h"
#import "../common.h"

extern char*** _NSGetArgv();

@implementation Shadow (Utilities)

+ (NSString *)getStandardizedPath:(NSString *)path {
    if(!path) {
        return path;
    }

    NSURL* url = [NSURL URLWithString:path];

    if(!url) {
        url = [NSURL fileURLWithPath:path];
    }

    NSString* standardized_path = [[url standardizedURL] path];

    if(standardized_path) {
        path = standardized_path;
    }

    while([path containsString:@"/./"]) {
        path = [path stringByReplacingOccurrencesOfString:@"/./" withString:@"/"];
    }

    while([path containsString:@"//"]) {
        path = [path stringByReplacingOccurrencesOfString:@"//" withString:@"/"];
    }

    if([path length] > 1) {
        if([path hasSuffix:@"/"]) {
            path = [path substringToIndex:[path length] - 1];
        }

        while([path hasSuffix:@"/."]) {
            path = [path stringByDeletingLastPathComponent];
        }
        
        while([path hasSuffix:@"/.."]) {
            path = [path stringByDeletingLastPathComponent];
            path = [path stringByDeletingLastPathComponent];
        }
    }

    if([path hasPrefix:@"/private/var"] || [path hasPrefix:@"/private/etc"]) {
        NSMutableArray* pathComponents = [[path pathComponents] mutableCopy];
        [pathComponents removeObjectAtIndex:1];
        path = [NSString pathWithComponents:pathComponents];
    }

    if([path hasPrefix:@"/var/tmp"]) {
        NSMutableArray* pathComponents = [[path pathComponents] mutableCopy];
        [pathComponents removeObjectAtIndex:1];
        path = [NSString pathWithComponents:pathComponents];
    }

    return path;
}

// code from Choicy
//methods of getting executablePath and bundleIdentifier with the least side effects possible
//for more information, check out https://github.com/checkra1n/BugTracker/issues/343
+ (NSString *)getExecutablePath {
    char* executablePathC = **_NSGetArgv();
    return executablePathC ? @(executablePathC) : nil;
}

+ (NSString *)getBundleIdentifier {
    CFBundleRef mainBundle = CFBundleGetMainBundle();
    return mainBundle ? (__bridge NSString *)CFBundleGetIdentifier(mainBundle) : nil;
}

+ (NSDictionary *)generateDatabase {
    // Determine dpkg info database path.
    NSArray* dpkgInfoPaths = @[
        @"/Library/dpkg/info",
        @"/var/lib/dpkg/info"
    ];

    NSString* dpkgInfoPath = nil;

    for(NSString* path in dpkgInfoPaths) {
        NSString* path_r = [RootBridge getJBPath:path];

        if([[NSFileManager defaultManager] fileExistsAtPath:path_r]) {
            dpkgInfoPath = path_r;
            break;
        }
    }

    if(!dpkgInfoPath) {
        return nil;
    }

    // // Load standard (built-in) ruleset.
    // NSString* ruleset_path = [@SHADOW_RULESETS stringByAppendingPathComponent:@"StandardRules.plist"];
    // ShadowRuleset* ruleset = [ShadowRuleset rulesetWithPath:[RootBridge getJBPath:ruleset_path]];

    NSArray* db_list_skip = @[@"base.list", @"firmware-sbin.list"];

    NSMutableSet* db_installed = [NSMutableSet new];
    NSMutableSet* db_exception = [NSMutableSet new];
    NSMutableSet* schemes = [NSMutableSet new];

    // Iterate all list files in database.
    NSArray* db_files = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:[NSURL fileURLWithPath:dpkgInfoPath isDirectory:YES] includingPropertiesForKeys:@[] options:0 error:nil];

    for(NSURL* db_file in db_files) {
        if([[db_file pathExtension] isEqualToString:@"list"]) {
            NSString* content = [NSString stringWithContentsOfURL:db_file encoding:NSUTF8StringEncoding error:nil];

            if(content) {
                // Read all lines
                NSArray* lines = [content componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];

                for(NSString* line in lines) {
                    NSString* path = [self getStandardizedPath:line];

                    if(!path || [path length] == 0 || [path isEqualToString:@"/"]) {
                        continue;
                    }

                    if([[path pathExtension] isEqualToString:@"app"]) {
                        NSBundle* appBundle = [NSBundle bundleWithPath:[RootBridge getJBPath:path]];

                        if(appBundle) {
                            NSDictionary* plist = [appBundle infoDictionary];
                            NSDictionary* urltypes = [plist objectForKey:@"CFBundleURLTypes"];

                            if(urltypes) {
                                for(NSDictionary* type in urltypes) {
                                    NSArray* urlschemes = [type objectForKey:@"CFBundleURLSchemes"];

                                    if(urlschemes) {
                                        [schemes addObjectsFromArray:urlschemes];
                                    }
                                }
                            }
                        }
                    }

                    // if(ruleset && ![ruleset isPathCompliant:path]) {
                    //     continue;
                    // }
                    
                    if([db_list_skip containsObject:[db_file lastPathComponent]]) {
                        [db_exception addObject:path];
                    } else {
                        [db_installed addObject:path];
                    }
                }
            }
        }
    }

    // filter installed ruleset
    NSArray* filter_names = @[
        @"/.",
        @"/Library/Application Support",
        @"/usr/lib",
        @"/usr/libexec",
        @"/usr/lib/system",
        @"/var/mobile/Library/Caches",
        @"/var/mobile/Media",
        @"/System/Library/PrivateFrameworks/CoreEmoji.framework",
        @"/System/Library/PrivateFrameworks/CoreEmoji.framework/SearchEngineOverrideLists",
        @"/System/Library/PrivateFrameworks/CoreEmoji.framework/SearchModel-en",
        @"/System/Library/PrivateFrameworks/TextInput.framework"
    ];

    [db_exception addObjectsFromArray:filter_names];
    [db_installed minusSet:db_exception];

    NSPredicate* emoji = [NSPredicate predicateWithFormat:@"SELF LIKE '/System/Library/PrivateFrameworks/CoreEmoji.framework/*.lproj'"];
    NSPredicate* not_emoji = [NSCompoundPredicate notPredicateWithSubpredicate:emoji];
    
    [db_installed filterUsingPredicate:not_emoji];

    return @{
        @"RulesetInfo" : @{
            @"Name" : @"dpkg installed files",
            @"Author" : @"Shadow Service"
        },
        @"BlacklistExactPaths" : [db_installed allObjects],
        @"BlacklistURLSchemes" : [schemes allObjects]
    };
}

+ (NSArray *)filterPathArray:(NSArray *)array restricted:(BOOL)restricted options:(NSDictionary<NSString *, id> *)options {
    Shadow* shadow = [Shadow sharedInstance];
    __block BOOL _restricted = restricted;

    NSIndexSet* indexes = [array indexesOfObjectsPassingTest:^BOOL(id obj, NSUInteger idx, BOOL* stop) {
        if([obj isKindOfClass:[NSString class]]) {
            return [shadow isPathRestricted:obj options:options] == _restricted;
        }
        
        if([obj isKindOfClass:[NSURL class]]) {
            return [shadow isURLRestricted:obj options:options] == _restricted;
        }

        return NO;
    }];

    return [array objectsAtIndexes:indexes];
}
@end

```

`Shadow.framework/Core.m`:

```m
#import <Shadow/Core.h>
#import <Shadow/Core+Utilities.h>
#import <Shadow/Backend.h>
#import <RootBridge.h>

#import <dlfcn.h>
#import <pwd.h>

#import "../vendor/apple/dyld_priv.h"

@implementation Shadow
@synthesize bundlePath, homePath, realHomePath, hasAppSandbox, rootless;

- (instancetype)init {
    if((self = [super init])) {
        bundlePath = [[[self class] getExecutablePath] stringByDeletingLastPathComponent];
        homePath = NSHomeDirectory();
        realHomePath = @(getpwuid(getuid())->pw_dir);

        bundlePath = [[self class] getStandardizedPath:bundlePath];
        homePath = [[self class] getStandardizedPath:homePath];
        realHomePath = [[self class] getStandardizedPath:realHomePath];

        hasAppSandbox = [[bundlePath pathExtension] isEqualToString:@"app"];
        rootless = [RootBridge isJBRootless];

        backend = [ShadowBackend new];
    }

    return self;
}

+ (instancetype)sharedInstance {
    static Shadow* sharedInstance = nil;
    static dispatch_once_t onceToken = 0;

    dispatch_once(&onceToken, ^{
        sharedInstance = [self new];
    });

    return sharedInstance;
}

- (BOOL)isAddrExternal:(const void *)addr {
    if(addr) {
        const char* image_path = dyld_image_path_containing_address(addr);

        if(image_path) {
            if(strstr(image_path, [bundlePath fileSystemRepresentation]) != NULL) {
                return NO;
            }

            return YES;
        }
    }

    return NO;
}

- (BOOL)isAddrRestricted:(const void *)addr {
    if(addr) {
        // See if this address belongs to a restricted file.
        const char* image_path = dyld_image_path_containing_address(addr);
        return [self isCPathRestricted:image_path];
    }

    return NO;
}

- (BOOL)isCPathRestricted:(const char *)path {
    if(path) {
        return [self isPathRestricted:[NSString stringWithUTF8String:path]];
    }

    return NO;
}

- (BOOL)isPathRestricted:(NSString *)path {
    return [self isPathRestricted:path options:nil];
}

- (BOOL)isPathRestricted:(NSString *)path options:(NSDictionary<NSString *, id> *)options {
    if(!path || [path length] == 0 || [path isEqualToString:@"/"]) {
        return NO;
    }

    // Resolve any tilde paths.
    path = [path stringByExpandingTildeInPath];

    if([path characterAtIndex:0] == '~') {
        return NO;
    }

    // Attempt to resolve any relative paths.
    if(![path isAbsolutePath]) {
        NSString* cwd = [options objectForKey:kShadowRestrictionWorkingDir];

        if(!cwd || ![cwd isAbsolutePath]) {
            cwd = [[NSFileManager defaultManager] currentDirectoryPath];
        }

        path = [cwd stringByAppendingPathComponent:path];
    }

    // Standardize path string for our checks.
    path = [[self class] getStandardizedPath:path];

    // Run checks if path is outside the app sandbox.
    BOOL shouldCheckPath = (!hasAppSandbox || (![path hasPrefix:bundlePath] && ![path hasPrefix:homePath]));

    if(shouldCheckPath) {
        // Add file extension if needed.
        NSString* file_ext = [options objectForKey:kShadowRestrictionFileExtension];

        if(file_ext && ![[path pathExtension] isEqualToString:file_ext]) {
            path = [path stringByAppendingFormat:@".%@", file_ext];
        }

        // Rootless optimization: skip rooted checks
        if(rootless) {
            if(![path hasPrefix:@"/var"] && ![path hasPrefix:@"/private/preboot"] && ![path hasPrefix:@"/usr/lib"]) {
                return NO;
            }

            if([path hasPrefix:@"/var/jb"] || [path hasPrefix:@"/cores/"]) {
                return YES;
            }
        }

        if([path hasPrefix:@"/usr/lib"]) {
            // Skip checks if file doesn't exist
            int errno_old = errno;
            if(access([path fileSystemRepresentation], F_OK) != 0) {
                // reset errno
                errno = errno_old;
                return NO;
            }
        }

        if([backend isPathRestricted:path]) {
            NSLog(@"[Shadow] isPathRestricted: restricted path: %@", path);
            return YES;
        }
    }

    // Resolve into full path and check again.
    if(![options objectForKey:kShadowRestrictionEnableResolve] || [[options objectForKey:kShadowRestrictionEnableResolve] boolValue]) {
        NSString* resolved_path = [path stringByStandardizingPath];

        if(![resolved_path isEqualToString:path]) {
            NSMutableDictionary* opt = [NSMutableDictionary dictionaryWithDictionary:options];
            [opt setObject:@(NO) forKey:kShadowRestrictionEnableResolve];

            if([self isPathRestricted:resolved_path options:[opt copy]]) {
                return YES;
            }
        }
    }

    if(shouldCheckPath) {
        NSLog(@"[Shadow] isPathRestricted: allowed path: %@", path);
    }

    return NO;
}

- (BOOL)isURLRestricted:(NSURL *)url {
    return [self isURLRestricted:url options:nil];
}

- (BOOL)isURLRestricted:(NSURL *)url options:(NSDictionary<NSString *, id> *)options {
    if(!url) {
        return NO;
    }

    if([url isFileURL]) {
        NSString *path = [url path];

        if([url isFileReferenceURL]) {
            NSURL *surl = [url filePathURL];

            if(surl) {
                path = [surl path];
            }
        }

        return [self isPathRestricted:path options:options];
    }

    return [self isSchemeRestricted:[url scheme]];
}

- (BOOL)isSchemeRestricted:(NSString *)scheme {
    return [backend isSchemeRestricted:scheme];
}
@end

```

`Shadow.framework/Headers/Shadow.h`:

```h
#ifndef shadow_h
#define shadow_h

#import <Shadow/Core.h>
#import <Shadow/Core+Utilities.h>

#endif

```

`Shadow.framework/Headers/Shadow/Backend.h`:

```h
#ifndef shadow_backend_h
#define shadow_backend_h

#import <Foundation/Foundation.h>
#import <Shadow/Ruleset.h>

@interface ShadowBackend : NSObject {
    NSArray<ShadowRuleset *>* rulesets;
    NSCache<NSString *, NSNumber *>* cache_restricted;
}

- (BOOL)isPathRestricted:(NSString *)path;
- (BOOL)isSchemeRestricted:(NSString *)scheme;
@end
#endif

```

`Shadow.framework/Headers/Shadow/Core+Utilities.h`:

```h
#ifndef shadow_core_utilities_h
#define shadow_core_utilities_h

#import <Foundation/Foundation.h>
#import "Core.h"

@interface Shadow (Utilities)
+ (NSString *)getStandardizedPath:(NSString *)path;
+ (NSString *)getExecutablePath;
+ (NSString *)getBundleIdentifier;
+ (NSDictionary *)generateDatabase;
+ (NSArray *)filterPathArray:(NSArray *)array restricted:(BOOL)restricted options:(NSDictionary<NSString *, id> *)options;
@end
#endif

```

`Shadow.framework/Headers/Shadow/Core.h`:

```h
#ifndef shadow_core_h
#define shadow_core_h

#import <Foundation/Foundation.h>
#import <Shadow/Backend.h>

#define kShadowRestrictionEnableResolve         @"kShadowRestrictionEnableResolve"
#define kShadowRestrictionWorkingDir            @"kShadowRestrictionWorkingDir"
#define kShadowRestrictionFileExtension         @"kShadowRestrictionFileExtension"

@interface Shadow : NSObject {
    ShadowBackend* backend;
}

@property (strong, nonatomic, readonly) NSString* bundlePath;
@property (strong, nonatomic, readonly) NSString* homePath;
@property (strong, nonatomic, readonly) NSString* realHomePath;
@property (assign, nonatomic, readonly) BOOL hasAppSandbox;
@property (assign, nonatomic, readonly) BOOL rootless;

+ (instancetype)sharedInstance;

- (BOOL)isAddrExternal:(const void *)addr;
- (BOOL)isAddrRestricted:(const void *)addr;

- (BOOL)isCPathRestricted:(const char *)path;
- (BOOL)isPathRestricted:(NSString *)path;
- (BOOL)isPathRestricted:(NSString *)path options:(NSDictionary<NSString *, id> *)options;

- (BOOL)isURLRestricted:(NSURL *)url;
- (BOOL)isURLRestricted:(NSURL *)url options:(NSDictionary<NSString *, id> *)options;

- (BOOL)isSchemeRestricted:(NSString *)scheme;
@end
#endif

```

`Shadow.framework/Headers/Shadow/Ruleset.h`:

```h
#ifndef shadow_ruleset_h
#define shadow_ruleset_h

#import <Foundation/Foundation.h>

@interface ShadowRuleset : NSObject {
    NSSet<NSString *>* set_urlschemes;
    NSSet<NSString *>* set_whitelist;
    NSSet<NSString *>* set_blacklist;

    NSPredicate* pred_whitelist;
    NSPredicate* pred_blacklist;
}

@property (strong, nonatomic) NSDictionary* internalDictionary;

+ (instancetype)rulesetWithURL:(NSURL *)url;
+ (instancetype)rulesetWithPath:(NSString *)path;

- (BOOL)isPathCompliant:(NSString *)path;
- (BOOL)isPathWhitelisted:(NSString *)path;
- (BOOL)isPathBlacklisted:(NSString *)path;
- (BOOL)isSchemeRestricted:(NSString *)scheme;
@end
#endif

```

`Shadow.framework/Headers/Shadow/Settings.h`:

```h
#ifndef shadow_settings_h
#define shadow_settings_h

#import <Foundation/Foundation.h>

@interface ShadowSettings : NSObject
@property (strong, nonatomic, readonly) NSDictionary<NSString *, id>* defaultSettings;
@property (strong, nonatomic, readonly) NSUserDefaults* userDefaults;

+ (instancetype)sharedInstance;

- (NSDictionary<NSString *, id> *)getPreferencesForIdentifier:(NSString *)bundleIdentifier;
@end
#endif

```

`Shadow.framework/Makefile`:

```
include $(THEOS)/makefiles/common.mk

FRAMEWORK_NAME = Shadow

Shadow_FILES = Core.m Core+Utilities.m Backend.m Ruleset.m Settings.m
Shadow_FRAMEWORKS = Foundation CoreFoundation
Shadow_EXTRA_FRAMEWORKS = RootBridge
Shadow_INSTALL_PATH = /Library/Frameworks
Shadow_CFLAGS = -fobjc-arc -IHeaders -I../vendor/RootBridge.framework/Headers
Shadow_LDFLAGS = -F../vendor/ -install_name @rpath/Shadow.framework/Shadow
Shadow_LDFLAGS += -rpath /Library/Frameworks -rpath /var/jb/Library/Frameworks -rpath /usr/lib -rpath /var/jb/usr/lib

include $(THEOS_MAKE_PATH)/framework.mk

```

`Shadow.framework/Resources/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>Shadow</string>
	<key>CFBundleIdentifier</key>
	<string>me.jjolano.fmwk.shadow</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1</string>
</dict>
</plist>

```

`Shadow.framework/Ruleset.m`:

```m
#import <Shadow/Ruleset.h>

@implementation ShadowRuleset
@synthesize internalDictionary;

- (instancetype)init {
    if((self = [super init])) {
        set_urlschemes = nil;
        set_whitelist = nil;
        set_blacklist = nil;

        pred_whitelist = nil;
        pred_blacklist = nil;
    }

    return self;
}

+ (instancetype)rulesetWithURL:(NSURL *)url {
    NSDictionary* ruleset_dict = [NSDictionary dictionaryWithContentsOfURL:url];

    if(ruleset_dict) {
        ShadowRuleset* ruleset = [self new];
        [ruleset setInternalDictionary:ruleset_dict];
        [ruleset _compile];
        return ruleset;
    }

    return nil;
}

+ (instancetype)rulesetWithPath:(NSString *)path {
    NSURL* file_url = [NSURL fileURLWithPath:path isDirectory:NO];
    return [self rulesetWithURL:file_url];
}

- (void)_compile {
    NSOperationQueue* queue = [NSOperationQueue new];
    [queue setQualityOfService:NSOperationQualityOfServiceUserInteractive];

    NSArray* urlschemes = [internalDictionary objectForKey:@"BlacklistURLSchemes"];

    if(urlschemes) {
        [queue addOperationWithBlock:^{
            set_urlschemes = [NSSet setWithArray:urlschemes];
        }];
    }

    NSArray* whitelist_paths = [internalDictionary objectForKey:@"WhitelistExactPaths"];

    if(whitelist_paths) {
        [queue addOperationWithBlock:^{
            set_whitelist = [NSSet setWithArray:whitelist_paths];
        }];
    }

    NSArray* blacklist_paths = [internalDictionary objectForKey:@"BlacklistExactPaths"];

    if(blacklist_paths) {
        [queue addOperationWithBlock:^{
            set_blacklist = [NSSet setWithArray:blacklist_paths];
        }];
    }

    NSArray* whitelist_preds = [internalDictionary objectForKey:@"WhitelistPredicates"];

    if(whitelist_preds) {
        [queue addOperationWithBlock:^{
            NSMutableArray<NSPredicate *>* preds = [NSMutableArray new];

            for(NSString* pred_str in whitelist_preds) {
                [preds addObject:[NSPredicate predicateWithFormat:pred_str]];
            }

            pred_whitelist = [NSCompoundPredicate orPredicateWithSubpredicates:preds];
        }];
    }

    NSArray* blacklist_preds = [internalDictionary objectForKey:@"BlacklistPredicates"];

    if(blacklist_preds) {
        [queue addOperationWithBlock:^{
            NSMutableArray<NSPredicate *>* preds = [NSMutableArray new];

            for(NSString* pred_str in blacklist_preds) {
                [preds addObject:[NSPredicate predicateWithFormat:pred_str]];
            }

            pred_blacklist = [NSCompoundPredicate orPredicateWithSubpredicates:preds];
        }];
    }

    [queue waitUntilAllOperationsAreFinished];
}

- (BOOL)isPathCompliant:(NSString *)path {
    NSDictionary* structure = [internalDictionary objectForKey:@"FileSystemStructure"];

    // Skip checks if ruleset doesn't define a structure or if path is a key.
    if(!structure || [structure objectForKey:path]) {
        return YES;
    }

    // Find the closest key in the structure.
    NSString* path_tmp = path;
    NSArray* structure_base = nil;

    do {
        path_tmp = [path_tmp stringByDeletingLastPathComponent];
        structure_base = [structure objectForKey:path_tmp];
    } while(!structure_base && ![path_tmp isEqualToString:@"/"]);

    // Check if path begins with any of the structure's child paths.
    if(structure_base) {
        BOOL compliant = NO;

        for(NSString* name in structure_base) {
            NSString* structure_path = [path_tmp stringByAppendingPathComponent:name];

            if([path hasPrefix:structure_path]) {
                compliant = YES;
                break;
            }
        }

        return compliant;
    }

    return YES;
}

- (BOOL)isPathWhitelisted:(NSString *)path {
    if([set_whitelist containsObject:path] || [pred_whitelist evaluateWithObject:path]) {
        return YES;
    }

    NSArray* array_whitelist = [internalDictionary objectForKey:@"WhitelistPaths"];

    if(array_whitelist) {
        for(NSString* whitelist_path in array_whitelist) {
            if([path hasPrefix:whitelist_path]) {
                return YES;
            }
        }
    }

    return NO;
}

- (BOOL)isPathBlacklisted:(NSString *)path {
    if([set_blacklist containsObject:path] || [pred_blacklist evaluateWithObject:path]) {
        return YES;
    }

    NSArray* array_blacklist = [internalDictionary objectForKey:@"BlacklistPaths"];

    if(array_blacklist) {
        for(NSString* blacklist_path in array_blacklist) {
            if([path hasPrefix:blacklist_path]) {
                return YES;
            }
        }
    }

    return NO;
}

- (BOOL)isSchemeRestricted:(NSString *)scheme {
    return [set_urlschemes containsObject:scheme];
}
@end

```

`Shadow.framework/Settings.m`:

```m
#import <Shadow/Settings.h>
#import <RootBridge.h>
#import "../common.h"

@implementation ShadowSettings
@synthesize defaultSettings, userDefaults;

- (instancetype)init {
    if((self = [super init])) {
        defaultSettings = @{
            @"Global_Enabled" : @(NO),
            @"HK_Library" : @"fishhook",
            @"Hook_Filesystem" : @(YES),
            @"Hook_DynamicLibraries" : @(YES),
            @"Hook_URLScheme" : @(YES),
            @"Hook_EnvVars" : @(YES),
            @"Hook_Foundation" : @(NO),
            @"Hook_DeviceCheck" : @(YES),
            @"Hook_MachBootstrap" : @(NO),
            @"Hook_SymLookup" : @(NO),
            @"Hook_LowLevelC" : @(NO),
            @"Hook_AntiDebugging" : @(NO),
            @"Hook_DynamicLibrariesExtra" : @(NO),
            @"Hook_ObjCRuntime" : @(NO),
            @"Hook_FakeMac" : @(NO),
            @"Hook_Syscall" : @(NO),
            @"Hook_Sandbox" : @(NO),
            @"Hook_Memory" : @(NO),
            @"Hook_TweakClasses" : @(NO),
            @"Hook_HideApps" : @(NO)
        };

        userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@SHADOW_PREFS_PLIST];
        [userDefaults registerDefaults:defaultSettings];
    }

    return self;
}

+ (instancetype)sharedInstance {
    static ShadowSettings* sharedInstance = nil;
    static dispatch_once_t onceToken = 0;

    dispatch_once(&onceToken, ^{
        sharedInstance = [self new];
    });

    return sharedInstance;
}

- (NSDictionary<NSString *, id> *)getPreferencesForIdentifier:(NSString *)bundleIdentifier {
    if(!userDefaults) {
        return nil;
    }

    NSMutableDictionary* result = [defaultSettings mutableCopy];
    NSDictionary* app_settings = bundleIdentifier ? [userDefaults objectForKey:bundleIdentifier] : nil;

    BOOL useAppSettings = [[app_settings objectForKey:@"App_Enabled"] boolValue];

    if(useAppSettings) {
        // Use app overrides.
        [result setObject:@(YES) forKey:@"App_Enabled"];

        for(NSString* key in defaultSettings) {
            id value = [app_settings objectForKey:key];

            if(!value) {
                id defaultValue = @(NO);

                if([[defaultSettings objectForKey:key] isKindOfClass:[NSString class]]) {
                    defaultValue = [defaultSettings objectForKey:key];
                }

                value = defaultValue;
            }
            
            [result setObject:value forKey:key];
        }
    } else {
        // Use global defaults.
        if([userDefaults boolForKey:@"Global_Enabled"]) {
            [result setObject:@(YES) forKey:@"App_Enabled"];

            for(NSString* key in defaultSettings) {
                [result setObject:[userDefaults objectForKey:key] forKey:key];
            }
        }
    }

    return [result copy];
}
@end

```

`Shadow.framework/Shadow.tbd`:

```tbd
---
archs:                 [ armv7, armv7s, arm64, arm64e ]
platform:              ios
install-name:          '@rpath/Shadow.framework/Shadow'
current-version:       0
compatibility-version: 0
exports:
  - archs:                [ armv7, armv7s, arm64, arm64e ]
    objc-classes:         [ _Shadow, _ShadowBackend,
                            _ShadowSettings, _ShadowRuleset ]
...

```

`Shadow.framework/layout/Library/Shadow/Rulesets/JailbreakMisc.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>RulesetInfo</key>
	<dict>
		<key>Name</key>
		<string>Miscellaneous Jailbreak Files</string>
		<key>Author</key>
		<string>jjolano</string>
	</dict>
	<key>BlacklistExactPaths</key>
	<array>
		<string>/usr/lib/pspawn_payload-stg2.dylib</string>
		<string>/usr/lib/tweakloader.dylib</string>
		<string>/usr/lib/libjailbreak.dylib</string>
		<string>/usr/lib/libhooker.dylib</string>
		<string>/usr/lib/libblackjack.dylib</string>
		<string>/usr/lib/libellekit.dylib</string>
		<string>/usr/lib/libsubstitute.dylib</string>
		<string>/usr/lib/libsubstitute.0.dylib</string>
		<string>/usr/lib/libsubstrate.dylib</string>
		<string>/dev/ptmx</string>
		<string>/dev/kmem</string>
		<string>/dev/mem</string>
		<string>/dev/vn0</string>
		<string>/dev/vn1</string>
	</array>
	<key>BlacklistPaths</key>
	<array>
		<string>/usr/lib/TweakInject</string>
		<string>/usr/lib/tweaks</string>
		<string>/usr/lib/libkrw</string>
		<string>/usr/libexec/ellekit</string>
		<string>/var/containers/Bundle/iosbinpack64</string>
		<string>/var/containers/Bundle/tweaksupport</string>
		<string>/var/db/stash</string>
		<string>/var/db/sudo</string>
		<string>/var/run/FilzaHelper</string>
		<string>/var/run/sudo</string>
		<string>/usr/libexec/cydia</string>
		<string>/System/Library/PreferenceBundles/AppList.bundle</string>
		<string>/Library/Frameworks/</string>
		<string>/Library/LaunchDaemons/</string>
		<string>/cores/</string>
		<string>/Library/Caches/cy-</string>
		<string>/dev/dlci.</string>
		<string>/private/preboot/jb-</string>
		<string>/var/MobileSoftwareUpdate/mnt1</string>
	</array>
	<key>BlacklistPredicates</key>
	<array>
		<string>SELF LIKE '/private/preboot/*/procursus*'</string>
		<string>SELF LIKE '/private/preboot/*/jb*'</string>
		<string>SELF LIKE '/var/run/*.pid'</string>
		<string>SELF ENDSWITH '_TrollStore'</string>
		<string>SELF LIKE '/*.app/LIAPP*'</string>
		<string>SELF LIKE[c] '/usr/lib/*substitute*'</string>
		<string>SELF LIKE[c] '/usr/lib/*substrate*'</string>
		<string>SELF LIKE[c] '/usr/lib/*ellekit*'</string>
	</array>
	<key>BlacklistURLSchemes</key>
	<array>
		<string>cydia</string>
		<string>zbra</string>
		<string>sileo</string>
		<string>undecimus</string>
		<string>xina</string>
		<string>filza</string>
		<string>apt-repo</string>
		<string>installer</string>
		<string>santander</string>
	</array>
</dict>
</plist>

```

`Shadow.framework/layout/Library/Shadow/Rulesets/StandardRules.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>RulesetInfo</key>
	<dict>
		<key>Name</key>
		<string>Standard Rules</string>
		<key>Author</key>
		<string>jjolano</string>
	</dict>
	<key>FileSystemStructure</key>
	<dict>
		<key>/</key>
		<array>
			<string>.ba</string>
			<string>.file</string>
			<string>.mb</string>
			<string>Applications</string>
			<string>Developer</string>
			<string>Library</string>
			<string>System</string>
			<string>bin</string>
			<string>cores</string>
			<string>dev</string>
			<string>etc</string>
			<string>private</string>
			<string>sbin</string>
			<string>tmp</string>
			<string>usr</string>
			<string>var</string>
		</array>
		<key>/private</key>
		<array>
			<string>etc</string>
			<string>preboot</string>
			<string>system_data</string>
			<string>var</string>
			<string>xarts</string>
		</array>
		<key>/var</key>
		<array>
			<string>.DocumentRevisions-V100</string>
            <string>.overprovisioning_file</string>
            <string>Keychains</string>
            <string>Managed Preferences</string>
            <string>MobileAsset</string>
            <string>MobileDevice</string>
            <string>MobileSoftwareUpdate</string>
            <string>audit</string>
            <string>buddy</string>
            <string>containers</string>
            <string>datamigrator</string>
            <string>db</string>
            <string>dextcores</string>
            <string>empty</string>
            <string>folders</string>
            <string>hardware</string>
            <string>installd</string>
            <string>keybags</string>
            <string>log</string>
            <string>logs</string>
            <string>mobile</string>
            <string>msgs</string>
            <string>networkd</string>
            <string>preferences</string>
            <string>protected</string>
            <string>root</string>
            <string>run</string>
            <string>select</string>
            <string>staged_system_apps</string>
            <string>tmp</string>
            <string>vm</string>
            <string>wireless</string>
		</array>
		<key>/Library</key>
		<array>
			<string>Application Support</string>
			<string>Audio</string>
            <string>Caches</string>
            <string>Filesystems</string>
            <string>Frameworks</string>
            <string>Internet Plug-Ins</string>
            <string>Keychains</string>
            <string>LaunchAgents</string>
            <string>LaunchDaemons</string>
            <string>Logs</string>
            <string>Managed Preferences</string>
            <string>MobileDevice</string>
            <string>MusicUISupport</string>
            <string>Preferences</string>
            <string>Printers</string>
            <string>RegionFeatures</string>
            <string>Ringtones</string>
            <string>Updates</string>
            <string>Wallpaper</string>
        </array>
		<key>/usr</key>
		<array>
			<string>bin</string>
            <string>lib</string>
            <string>libexec</string>
            <string>sbin</string>
            <string>share</string>
            <string>standalone</string>
		</array>
		<key>/etc</key>
		<array>
			<string>asl</string>
            <string>asl.conf</string>
            <string>group</string>
            <string>hosts</string>
            <string>hosts.equiv</string>
            <string>master.passwd</string>
            <string>networks</string>
            <string>notify.conf</string>
            <string>passwd</string>
            <string>ppp</string>
            <string>protocols</string>
            <string>racoon</string>
            <string>services</string>
            <string>ttys</string>
		</array>
		<key>/var/containers</key>
		<array>
			<string>Bundle</string>
			<string>Data</string>
			<string>Shared</string>
			<string>Temp</string>
		</array>
		<key>/var/containers/Bundle</key>
		<array>
			<string>Application</string>
		</array>
		<key>/var/mobile</key>
		<array>
			<string>Applications</string>
			<string>Backups</string>
			<string>Containers</string>
			<string>Documents</string>
			<string>Downloads</string>
			<string>Library</string>
			<string>Media</string>
			<string>MobileSoftwareUpdate</string>
		</array>
		<key>/var/mobile/Media</key>
		<array>
			<string>AirFair</string>
			<string>Books</string>
			<string>DCIM</string>
			<string>Downloads</string>
			<string>MediaAnalysis</string>
			<string>PublicStaging</string>
			<string>Recordings</string>
			<string>PhotoData</string>
			<string>Photos</string>
			<string>Radio</string>
			<string>Purchases</string>
			<string>iTunesRestore</string>
			<string>iTunes_Control</string>
		</array>
		<key>/bin</key>
		<array>
			<string>ps</string>
			<string>df</string>
		</array>
		<key>/var/mobile/Library/Preferences</key>
		<array>
			<string>.GlobalPreferences.plist</string>
			<string>.GlobalPreferences_m.plist</string>
			<string>TVRemoteConnectionService.plist</string>
			<string>UITextInputContextIdentifiers.plist</string>
			<string>bookassetd.plist</string>
			<string>ckkeyrolld.plist</string>
			<string>dprivacyd.plist</string>
			<string>nfcd.plist</string>
			<string>silhouette.plist</string>
			<string>siriknowledged.plist</string>
			<string>systemgroup.com.apple.icloud.searchpartyd.sharedsettings.plist</string>
			<string>Wallpaper.png</string>
		</array>
		<key>/var/mobile/Library/Caches</key>
		<array>
			<string>Checkpoint.plist</string>
			<string>CloudKit</string>
			<string>DateFormats.plist</string>
			<string>FamilyCircle</string>
			<string>GameKit</string>
			<string>GeoServices</string>
			<string>MappedImageCache</string>
			<string>PassKit</string>
			<string>VoiceServices</string>
			<string>VoiceTrigger</string>
			<string>mediaanalysisd-service</string>
			<string>sharedCaches</string>
			<string>videosubscriptionsd</string>
			<string>rtcreportingd</string>
		</array>
		<key>/var/mobile/Library/Cookies</key>
		<array>
			<string>Cookies.binarycookies</string>
		</array>
		<key>/var/log</key>
		<array>
			<string>asl</string>
			<string>mDNSResponder</string>
			<string>ppp</string>
		</array>
		<key>/Library/Application Support</key>
		<array>
			<string>AggregateDictionary</string>
			<string>BTServer</string>
		</array>
		<key>/var/mobile/Library/Application Support</key>
		<array>
			<string>Containers</string>
			<string>CloudDocs</string>
			<string>CloudKitMailConversationsFlags</string>
			<string>FileProvider</string>
			<string>UsageTrackingAgent</string>
			<string>icloudsubscriptionoptimizerd</string>
			<string>lacle.tmp</string>
			<string>livefsd</string>
			<string>smbclientd</string>
			<string>videosubscriptionsd</string>
		</array>
		<key>/var/mobile/Library</key>
		<array>
			<string>Accessibility</string>
			<string>Accounts</string>
			<string>AddressBook</string>
			<string>AggregateDictionary</string>
			<string>AirPlayRoutePrediction</string>
			<string>AppleMediaServices</string>
			<string>ApplePushService</string>
			<string>Application Support</string>
			<string>Assets</string>
			<string>Assistant</string>
			<string>Avatar</string>
			<string>BackBoard</string>
			<string>Backup</string>
			<string>Biome</string>
			<string>BulletinBoard</string>
			<string>Caches</string>
			<string>Calendar</string>
			<string>CallDirectory</string>
			<string>CallHistoryDB</string>
			<string>CallHistoryTransactions</string>
			<string>CallServices</string>
			<string>Carrier Bundles</string>
			<string>CarrierDefault.bundle</string>
			<string>ClassKit</string>
			<string>Contacts</string>
			<string>ContactsMetadata</string>
			<string>ControlCenter</string>
			<string>Cookies</string>
			<string>CoreAS</string>
			<string>CoreAccessories</string>
			<string>CoreBehavior</string>
			<string>CoreBrightness</string>
			<string>CoreDuet</string>
			<string>CoreFollowUp</string>
			<string>CrashReporter</string>
			<string>DES</string>
			<string>DataAccess</string>
			<string>DataDeliveryServices</string>
			<string>DiagnosticPipeline</string>
			<string>DifferentialPrivacy</string>
			<string>DoNotDisturb</string>
			<string>DuetActivityScheduler</string>
			<string>DuetExpertCenter</string>
			<string>ExternalAccessory</string>
			<string>ExposureNotification</string>
			<string>FaceTime</string>
			<string>FairPlay</string>
			<string>Finance</string>
			<string>FrontBoard</string>
			<string>GameKit</string>
			<string>HTTPStorages</string>
			<string>Handwriting</string>
			<string>Health</string>
			<string>IdentityServices</string>
			<string>Inboxes</string>
			<string>IntelligencePlatform</string>
			<string>Intents</string>
			<string>ISP</string>
			<string>Keyboard</string>
			<string>KeyboardServices</string>
			<string>LanguageModeling</string>
			<string>LASD</string>
			<string>LiveFiles</string>
			<string>LiveFiles.ticotsord</string>
			<string>Logs</string>
			<string>Mail</string>
			<string>Maps</string>
			<string>MediaRemote</string>
			<string>MediaStream</string>
			<string>MedicalID</string>
			<string>MemoryMaintenance</string>
			<string>MessagesMetaData</string>
			<string>Mobile Documents</string>
			<string>MobileContainerManager</string>
			<string>MobileInstallation</string>
			<string>MusicLibrary</string>
			<string>NFStorage</string>
			<string>NanoMusicSync</string>
			<string>News</string>
			<string>Notes</string>
			<string>OSAnalytics</string>
			<string>OTALogging</string>
			<string>OnDemandResources</string>
			<string>POMMES</string>
			<string>Passes</string>
			<string>PeopleSuggester</string>
			<string>PersonalizationPortrait</string>
			<string>Photos</string>
			<string>Preferences</string>
			<string>PrivacyAccounting</string>
			<string>ProactiveInsights</string>
			<string>Recents</string>
			<string>Reminders</string>
			<string>ReplayKit</string>
			<string>ResponseKit</string>
			<string>SMS</string>
			<string>Safari</string>
			<string>SafariSafeBrowsing</string>
			<string>SafeHarbor</string>
			<string>Saved Application State</string>
			<string>SecureElementService</string>
			<string>Sharing</string>
			<string>Shortcuts</string>
			<string>SoftwareUpdate</string>
			<string>SoftwareUpdateCore</string>
			<string>SplashBoard</string>
			<string>Spotlight</string>
			<string>SpringBoard</string>
			<string>StatusKit</string>
			<string>Suggestions</string>
			<string>SyncedPreferences</string>
			<string>TCC</string>
			<string>Translation</string>
			<string>Trial</string>
			<string>UserConfigurationProfiles</string>
			<string>UserFonts</string>
			<string>UserNotifications</string>
			<string>UserNotificationsUI</string>
			<string>VoiceServices</string>
			<string>VoiceTrigger</string>
			<string>Voicemail</string>
			<string>WatchConnectivity</string>
			<string>Weather</string>
			<string>WebClips</string>
			<string>WebKit</string>
			<string>chronod</string>
			<string>coreidvd</string>
			<string>dmd</string>
			<string>homed</string>
			<string>idcredd</string>
			<string>locationd</string>
			<string>mad</string>
			<string>sessionkitd</string>
			<string>studentd</string>
			<string>terminus</string>
		</array>
		<key>/var/mobile/Library/ControlCenter</key>
		<array>
			<string>ModuleConfiguration.plist</string>
		</array>
		<key>/usr/share</key>
		<array>
			<string>CSI</string>
			<string>com.apple.languageassetd</string>
			<string>icu</string>
			<string>langid</string>
			<string>locale</string>
			<string>misc</string>
			<string>morphun</string>
			<string>progressui</string>
			<string>tokenizer</string>
			<string>zoneinfo</string>
			<string>zoneinfo.default</string>
		</array>
		<key>/usr/share/locale</key>
		<array>
			<string>UTF-8</string>
		</array>
		<key>/usr/share/locale/UTF-8</key>
		<array>
			<string>LC_CTYPE</string>
		</array>
		<key>/var/mobile/Library/Logs</key>
		<array>
			<string>AppleSupport</string>
			<string>Bluetooth</string>
			<string>CoreDuet</string>
			<string>CrashReporter</string>
			<string>Dedisco</string>
			<string>DiagnosticPipeline</string>
			<string>ExposureNotification</string>
			<string>NotificationProxy</string>
			<string>SMSMigrator</string>
			<string>RTCReporting</string>
			<string>WirelessRadioManager</string>
			<string>mobileactivationd</string>
		</array>
		<key>/usr/bin</key>
		<array>
			<string>DumpBasebandCrash</string>
			<string>IOMFB_FDR_Loader</string>
			<string>PerfPowerServicesExtended</string>
			<string>abmlite</string>
			<string>afktool</string>
			<string>brctl</string>
			<string>codecctl</string>
			<string>fileproviderctl</string>
			<string>footprint</string>
			<string>hidutil</string>
			<string>hpmdiagnose</string>
			<string>kbdebug</string>
			<string>lsdiagnose</string>
			<string>ltop</string>
			<string>nfsstat</string>
			<string>orionmicroupdate</string>
			<string>powerlogHelperd</string>
			<string>swift-inspect</string>
			<string>sysdiagnose</string>
			<string>tailspin</string>
			<string>taskinfo</string>
			<string>umtool</string>
			<string>vm_stat</string>
			<string>zprint</string>
		</array>
		<key>/usr/sbin</key>
		<array>
			<string>BTAvrCP</string>
			<string>BTLEServer</string>
			<string>BTMagic</string>
			<string>BTMap</string>
			<string>BTPbap</string>
			<string>BlueTool</string>
			<string>WRM_CoreDataStore.momd</string>
			<string>WirelessRadioManagerd</string>
			<string>absd</string>
			<string>addNetworkInterface</string>
			<string>aslmanager</string>
			<string>audioclocksyncd</string>
			<string>bluetoothd</string>
			<string>cfprefsd</string>
			<string>ckksctl</string>
			<string>distnoted</string>
			<string>fairplayd.A2</string>
			<string>filecoordinationd</string>
			<string>hdik</string>
			<string>ioreg</string>
			<string>mDNSResponder</string>
			<string>mDNSResponderHelper</string>
			<string>mediaserverd</string>
			<string>notifyd</string>
			<string>nvram</string>
			<string>otctl</string>
			<string>pppd</string>
			<string>racoon</string>
			<string>rtadvd</string>
			<string>spindump</string>
			<string>syslogd</string>
			<string>wifid</string>
		</array>
		<key>/usr/lib</key>
		<array>
			<string>bbmasks</string>
			<string>dyld</string>
			<string>libCoreKE.dylib</string>
			<string>libMTLCapture.dylib</string>
			<string>libMTLToolsDiagnostics.dylib</string>
			<string>libSystem.B_asan.dylib</string>
			<string>libSystem_asan.dylib</string>
			<string>libffi-trampolines.dylib</string>
			<string>libobjc-trampolines.dylib</string>
			<string>libstdc++.6.dylib</string>
			<string>libstdc++.6.0.9.dylib</string>
			<string>system</string>
			<string>swift</string>
			<string>updaters</string>
			<string>log</string>
			<string>xpc</string>
			<string>libstdc++.dylib</string>
		</array>
		<key>/sbin</key>
		<array>
			<string>fsck</string>
			<string>fsck_apfs</string>
			<string>fsck_exfat</string>
			<string>fsck_hfs</string>
			<string>fsck_msdos</string>
			<string>launchd</string>
			<string>mount</string>
			<string>mount_apfs</string>
			<string>mount_hfs</string>
			<string>mount_lifs</string>
			<string>mount_nfs</string>
			<string>mount_tmpfs</string>
			<string>newfs_apfs</string>
			<string>newfs_exfat</string>
			<string>newfs_hfs</string>
			<string>newfs_msdos</string>
			<string>umount</string>
		</array>
	</dict>
	<key>WhitelistPaths</key>
	<array>
		<string>/var/mobile/Library/Preferences/com.apple</string>
		<string>/var/mobile/Library/Caches/com.apple</string>
		<string>/var/mobile/Library/Caches/.com.apple</string>
		<string>/tmp/com.apple</string>
		<string>/var/mobile/Library/Saved Application State/com.apple</string>
		<string>/var/mobile/Library/Application Support/Containers/com.apple</string>
		<string>/var/mobile/Library/SplashBoard/Snapshots/com.apple</string>
		<string>/var/mobile/Library/Cookies/com.apple</string>
		<string>/Library/LaunchDaemons/com.apple</string>
		<string>/var/log/com.apple</string>
		<string>/var/mobile/Library/Application Support/com.apple</string>
		<string>/var/mobile/Library/com.apple</string>
		<string>/var/mobile/Library/Logs/com.apple</string>
		<string>/var/mobile/Library/Caches/TelephonyUI-</string>
	</array>
	<key>WhitelistPredicates</key>
	<array>
		<string>SELF LIKE '/var/mobile/Library/Carrier?Bundle.bundle'</string>
		<string>SELF LIKE '/var/mobile/Library/Operator?Bundle.bundle'</string>
	</array>
	<key>BlacklistPaths</key>
	<array>
		<string>/tmp/</string>
		<string>/var/mobile/Library/Saved Application State/</string>
		<string>/var/mobile/Library/Application Support/Containers/</string>
		<string>/var/mobile/Library/SplashBoard/Snapshots/</string>
		<string>/var/root/</string>
		<string>/var/log/</string>
	</array>
</dict>
</plist>

```

`Shadow.framework/layout/Library/Shadow/Rulesets/dpkgInstalled.plist`:

```plist
{}

```

`ShadowSettings.bundle/Makefile`:

```
INSTALL_TARGET_PROCESSES = Preferences

include $(THEOS)/makefiles/common.mk

BUNDLE_NAME = ShadowSettings

ShadowSettings_FILES = $(wildcard *.m)
ShadowSettings_FRAMEWORKS = Foundation
ShadowSettings_EXTRA_FRAMEWORKS = Shadow AltList HookKit RootBridge
ShadowSettings_PRIVATE_FRAMEWORKS = Preferences
ShadowSettings_INSTALL_PATH = /Library/PreferenceBundles
ShadowSettings_CFLAGS = -fobjc-arc -I../Shadow.framework/Headers -I../vendor/HookKit.framework/Headers -I../vendor/RootBridge.framework/Headers
ShadowSettings_LDFLAGS = -rpath /Library/Frameworks -rpath /var/jb/Library/Frameworks -rpath /usr/lib -rpath /var/jb/usr/lib
ShadowSettings_LDFLAGS += -F../ -F../vendor

include $(THEOS_MAKE_PATH)/bundle.mk

```

`ShadowSettings.bundle/Resources/About.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>UPDATES_HDR</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSTitleValueCell</string>
			<key>label</key>
			<string>LATEST_VERSION</string>
			<key>get</key>
			<string>aboutLatestVersion:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSButtonCell</string>
			<key>action</key>
			<string>openChangeLog:</string>
			<key>label</key>
			<string>VISIT_CHANGELOG</string>
		</dict>

		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>CREDITS_HDR</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSTitleValueCell</string>
			<key>label</key>
			<string>DEVELOPER</string>
			<key>get</key>
			<string>aboutDeveloper:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSTitleValueCell</string>
			<key>label</key>
			<string>LOCALIZATION_HDR</string>
			<key>get</key>
			<string>aboutTranslator:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSButtonCell</string>
			<key>action</key>
			<string>openGitHub:</string>
			<key>label</key>
			<string>VISIT_GITHUB</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSButtonCell</string>
			<key>action</key>
			<string>openKofi:</string>
			<key>label</key>
			<string>VISIT_KOFI</string>
		</dict>
	</array>
	<key>title</key>
	<string>ABOUT_TITLE</string>
</dict>
</plist>

```

`ShadowSettings.bundle/Resources/App.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>APP_SETTINGS</string>
			<key>footerText</key>
			<string>APP_SETTINGS_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>App_Enabled</string>
			<key>label</key>
			<string>ENABLE_SHADOW</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
	</array>
</dict>
</plist>

```

`ShadowSettings.bundle/Resources/Hooks.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>INTERNAL_SETTINGS</string>
			<key>footerText</key>
			<string>HK_LIB_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSLinkListCell</string>
			<key>id</key>
			<string>HK_Library</string>
			<key>label</key>
			<string>HOOKING_LIBRARY</string>
			<key>detail</key>
			<string>PSListItemsController</string>
			<key>staticTextMessage</key>
			<string>HK_LIB_SELECT</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
			<key>valuesDataSource</key>
			<string>getValues:</string>
			<key>titlesDataSource</key>
			<string>getTitles:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>ESSENTIAL_HOOKS</string>
			<key>footerText</key>
			<string>ESSENTIAL_HOOKS_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_Filesystem</string>
			<key>label</key>
			<string>HOOK_FILE_SYSTEM</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_DynamicLibraries</string>
			<key>label</key>
			<string>HOOK_DYLIB</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_URLScheme</string>
			<key>label</key>
			<string>HOOK_URLSCHEME</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_EnvVars</string>
			<key>label</key>
			<string>HOOK_ENVVARS</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>REC_HOOKS</string>
			<key>footerText</key>
			<string>REC_HOOKS_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_DeviceCheck</string>
			<key>label</key>
			<string>HOOK_DETECTFMWK</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_Foundation</string>
			<key>label</key>
			<string>HOOK_FOUNDATION</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_FakeMac</string>
			<key>label</key>
			<string>HOOK_MAC</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>EXTRA_HOOKS</string>
			<key>footerText</key>
			<string>EXTRA_HOOKS_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_MachBootstrap</string>
			<key>label</key>
			<string>HOOK_MACH</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_SymLookup</string>
			<key>label</key>
			<string>HOOK_SYMLOOKUP</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_ObjCRuntime</string>
			<key>label</key>
			<string>HOOK_OBJC</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_AntiDebugging</string>
			<key>label</key>
			<string>HOOK_ANTIDBG</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_Syscall</string>
			<key>label</key>
			<string>HOOK_SYSCALL</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_HideApps</string>
			<key>label</key>
			<string>HOOK_APPENUM</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>DNGR_HOOKS</string>
			<key>footerText</key>
			<string>DNGR_HOOKS_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_Sandbox</string>
			<key>label</key>
			<string>HOOK_SANDBOX</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_LowLevelC</string>
			<key>label</key>
			<string>HOOK_LLC</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_Memory</string>
			<key>label</key>
			<string>HOOK_MEM</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_TweakClasses</string>
			<key>label</key>
			<string>HOOK_TWEAKCLASS</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Hook_DynamicLibrariesExtra</string>
			<key>label</key>
			<string>HOOK_DYLD</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
	</array>
</dict>
</plist>

```

`ShadowSettings.bundle/Resources/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>ShadowSettings</string>
	<key>CFBundleIdentifier</key>
	<string>me.jjolano.shadow</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundlePackageType</key>
	<string>BNDL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1.0</string>
	<key>NSPrincipalClass</key>
	<string>SHDWRootListController</string>
</dict>
</plist>

```

`ShadowSettings.bundle/Resources/Root.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>GLOBAL_SETTINGS</string>
			<key>footerText</key>
			<string>ALWAYS_ON_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSSwitchCell</string>
			<key>id</key>
			<string>Global_Enabled</string>
			<key>label</key>
			<string>ALWAYS_ON</string>
			<key>get</key>
			<string>readPreferenceValue:</string>
			<key>set</key>
			<string>setPreferenceValue:forSpecifier:</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>footerText</key>
			<string>BYPASS_SETTINGS_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSLinkCell</string>
			<key>detail</key>
			<string>SHDWHooksListController</string>
			<key>isController</key>
			<true/>
			<key>label</key>
			<string>BYPASS_SETTINGS</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>ROOT_APP_SETTINGS</string>
			<key>footerText</key>
			<string>ROOT_APP_SETTINGS_DESC</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSLinkListCell</string>
			<key>detail</key>
			<string>SHDWATLController</string>
			<key>subcontrollerClass</key>
			<string>SHDWAppListController</string>
			<key>label</key>
			<string>APPLICATIONS</string>
			<key>sections</key>
			<array>
				<dict>
					<key>sectionType</key>
					<string>Custom</string>
					<key>sectionPredicate</key>
					<string>NOT (atl_bundleIdentifier BEGINSWITH 'com.apple') AND atl_isHidden == NO</string>
				</dict>
			</array>
			<key>useSearchBar</key>
			<true/>
			<key>alphabeticIndexingEnabled</key>
			<true/>
			<key>showIdentifiersAsSubtitle</key>
			<true/>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSButtonCell</string>
			<key>action</key>
			<string>respring:</string>
			<key>label</key>
			<string>RESPRING</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSButtonCell</string>
			<key>action</key>
			<string>reset:</string>
			<key>label</key>
			<string>RESET</string>
			<key>confirmation</key>
			<dict>
				<key>prompt</key>
				<string>RESET_PROMPT</string>
				<key>title</key>
				<string>RESET</string>
				<key>okTitle</key>
				<string>RESET</string>
				<key>cancelTitle</key>
				<string>RESET_CANCEL</string>
			</dict>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSLinkCell</string>
			<key>detail</key>
			<string>SHDWAboutListController</string>
			<key>isController</key>
			<true/>
			<key>label</key>
			<string>ROOT_ABOUT</string>
		</dict>
	</array>
	<key>title</key>
	<string>Shadow</string>
</dict>
</plist>

```

`ShadowSettings.bundle/Resources/ar.lproj/About.strings`:

```strings
{
"ABOUT_TITLE" = "حول";
"BYPASS_VERSION" = "إصدار التخطي";
"SERVICE_VERSION" = "إصدار الخدمة";
"BUILD_DATE" = "تاريخ البناء";
"SOFTWARE_LICENSE" = "ترخيص البرمجيات";
"UPDATES_HDR" = "التحديثات";
"PACKAGE_VERSION" = "إصدار الحزمة";
"LATEST_VERSION" = "أحدث إصدار";
"CREDITS_HDR" = "الاعتمادات";
"DEVELOPER" = "المطور";
"VISIT_GITHUB" = "زيارة Shadow على GitHub";
"VISIT_KOFI" = "أرسل بقشيشًا عبر Ko-fi";
"LOCALIZATION_HDR" = "المترجم";
"VISIT_CHANGELOG" = "عرض أحدث التغييرات";
"TRANSLATOR" = "iA7myd";
}

```

`ShadowSettings.bundle/Resources/ar.lproj/App.strings`:

```strings
{
"APP_SETTINGS" = "إعدادات التطبيق";
"APP_SETTINGS_DESC" = "تفعيل إعدادات التخطي لهذا التطبيق.";
"ENABLE_SHADOW" = "تفعيل Shadow";
"ENABLED" = "مُفعَّل";
}

```

`ShadowSettings.bundle/Resources/ar.lproj/Hooks.strings`:

```strings
{
"INTERNAL_SETTINGS" = "الإعدادات الداخلية";
"HK_LIB_DESC" = "التحكم في الخطافات المستخدمة للتصدي لبرمجيات التطبيق. قد توفر بعض الخطافات تحسينًا للتخطي، ولكنها قد تؤثر أيضًا على استقرار التطبيق.";
"HOOKING_LIBRARY" = "مكتبة الخطافات";
"HK_LIB_SELECT" = "هذه لائحة بمكتبات الخطافات المتاحة للاستخدام على جهازك. حدد \"تلقائي\" للسماح لـ HookKit باختيار أفضل مكتبة خطافات لجهازك.";
"AUTOMATIC" = "تلقائي";
"ESSENTIAL_HOOKS" = "الخطافات الأساسية";
"ESSENTIAL_HOOKS_DESC" = "تغطي الخطافات الأساسية معظم طرق كشف الجيلبريك الأكثر شيوعًا.";
"HOOK_FILE_SYSTEM" = "ملف النظام";
"HOOK_DYLIB" = "المكتبات الديناميكية";
"HOOK_URLSCHEME" = "معالجات عناوين URL";
"HOOK_ENVVARS" = "تغيرات البنية";
"REC_HOOKS" = "الخطافات الموصى بها";
"REC_HOOKS_DESC" = "تغطي الخطافات الموصى بها طرقًا إضافية يمكن استخدامها لتخطي كشف الجيلبريك.";
"HOOK_DETECTFMWK" = "كشف هياكل البناء";
"HOOK_FILE_SYSTEM_EX" = "ملف النظام (إضافي)";
"HOOK_FOUNDATION" = "هيكل البناء Foundation";
"HOOK_MAC" = "محاكاة M1 Mac (لـ iOS 14+)";
"EXTRA_HOOKS" = "خطافات إضافية";
"EXTRA_HOOKS_DESC" = "تغطي الخطافات الإضافية المزيد من الطرق التي يمكن استخدامها لكشف الجيلبريك، بما في ذلك واجهة برمجة التطبيقات الخاصة (APIs).";
"HOOK_MACH" = "بحوثات Mach الخدمة";
"HOOK_SYMLOOKUP" = "بحوثات رمز وقت التشغيل";
"HOOK_OBJC" = "طرق قوالب Objective-C";
"HOOK_ANTIDBG" = "طرق مضادات التصحيح";
"HOOK_SYSCALL" = "استدعاءات النظام الخاصة";
"HOOK_APPENUM" = "تعداد التطبيق";
"DNGR_HOOKS" = "الخطافات الخطرة";
"DNGR_HOOKS_DESC" = "طرق التخطي منخفضة المستوى. قد تتسبب هذه الخطافات في تعطل بعض التطبيقات.";
"HOOK_SANDBOX" = "فرض Sandbox التطبيق";
"HOOK_LLC" = "معالجات الملفات منخفضة المستوى";
"HOOK_MEM" = "إخفاء الذاكرة التنفيذية";
"HOOK_TWEAKCLASS" = "إخفاء قوالب الأدوات";
"HOOK_DYLD" = "مُحمِّل المكتبة الديناميكي";
}

```

`ShadowSettings.bundle/Resources/ar.lproj/Root.strings`:

```strings
{
"GLOBAL_SETTINGS" = "الإعدادات العامة";
"ALWAYS_ON" = "التشغيل دائمًا";
"ALWAYS_ON_DESC" = "محاولات لتخطي كشف الجيلبريك في جميع التطبيقات افتراضيًا. ليس له تأثير على التطبيقات التي لديها إعداداتها الخاصة.";
"BYPASS_SETTINGS" = "إعدادات التخطي";
"BYPASS_SETTINGS_DESC" = "اضبط قوة تخطي كشف الجيلبريك. قد يتأثر أداء التطبيق.";
"ROOT_APP_SETTINGS" = "إعدادات التطبيق";
"ROOT_APP_SETTINGS_DESC" = "إعدادات التطبيقات الخاصة بها سيتم تطبيقها فوق الإعداد العام إذا كان مفعلًا.";
"APPLICATIONS" = "التطبيقات";
"RESPRING" = "إعادة تشغيل واجهة النظام";
"RESET" = "إعادة تعيين الإعدادات";
"RESET_PROMPT" = "سيؤدي هذا إلى إعادة تعيين كل إعدادات Shadow";
"RESET_CANCEL" = "إلغاء";
"ROOT_ABOUT" = "حول";
}

```

`ShadowSettings.bundle/Resources/en.lproj/About.strings`:

```strings
"ABOUT_TITLE" = "About";
"BYPASS_VERSION" = "Bypass Version";
"SERVICE_VERSION" = "Service Version";
"BUILD_DATE" = "Build Date";
"SOFTWARE_LICENSE" = "Software License";
"UPDATES_HDR" = "Updates";
"PACKAGE_VERSION" = "Package Version";
"LATEST_VERSION" = "Latest Version";
"CREDITS_HDR" = "Credits";
"DEVELOPER" = "Developer";
"VISIT_GITHUB" = "Visit Shadow on GitHub";
"VISIT_KOFI" = "Send a Tip with Ko-fi";
"LOCALIZATION_HDR" = "Translation";
"VISIT_CHANGELOG" = "View Latest Changes";

/* your name here! */
"TRANSLATOR" = "jjolano";

```

`ShadowSettings.bundle/Resources/en.lproj/App.strings`:

```strings
"APP_SETTINGS" = "Application Settings";
"APP_SETTINGS_DESC" = "Enables bypass settings for this application.";

"ENABLE_SHADOW" = "Enable Shadow";
"ENABLED" = "Enabled";

```

`ShadowSettings.bundle/Resources/en.lproj/Hooks.strings`:

```strings
"INTERNAL_SETTINGS" = "Internal Settings";
"HK_LIB_DESC" = "Controls the methods used to intercept application code. Some hooking libraries may provide a bypass improvement, but may also affect app stability.";

"HOOKING_LIBRARY" = "Hooking Library";
"HK_LIB_SELECT" = "This is a list of hooking libraries available to use on your device. Select \"Automatic\" to allow HookKit to choose the best hooking library for your device.";
"AUTOMATIC" = "Automatic";

"ESSENTIAL_HOOKS" = "Essential Hooks";
"ESSENTIAL_HOOKS_DESC" = "Essential hooks cover the most common jailbreak detection methods.";

"HOOK_FILE_SYSTEM" = "File System";
"HOOK_DYLIB" = "Dynamic Libraries";
"HOOK_URLSCHEME" = "URL Handlers";
"HOOK_ENVVARS" = "Environment Variables";

"REC_HOOKS" = "Recommended Hooks";
"REC_HOOKS_DESC" = "Recommended hooks cover additional methods which may be used by jailbreak detection.";

"HOOK_DETECTFMWK" = "Detection Frameworks";
"HOOK_FILE_SYSTEM_EX" = "File System (Extra)";
"HOOK_FOUNDATION" = "Foundation Framework"; /* Foundation is the name of Apple's framework. */
"HOOK_MAC" = "M1 Mac Spoof (iOS 14+)";

"EXTRA_HOOKS" = "Extra Hooks";
"EXTRA_HOOKS_DESC" = "Extra hooks cover even more methods that may be used by jailbreak detection, including private APIs.";

"HOOK_MACH" = "Mach Service Lookups";
"HOOK_SYMLOOKUP" = "Runtime Symbol Lookups";
"HOOK_OBJC" = "Objective-C Class Methods";
"HOOK_ANTIDBG" = "Anti-Debugging Methods";
"HOOK_SYSCALL" = "Private Syscalls";
"HOOK_APPENUM" = "App Enumeration";

"DNGR_HOOKS" = "Dangerous Hooks";
"DNGR_HOOKS_DESC" = "Low-level bypass methods. These hooks may cause some apps to crash.";

"HOOK_SANDBOX" = "Enforce App Sandbox";
"HOOK_LLC" = "Low-Level File Handles";
"HOOK_MEM" = "Hide Executable Memory";
"HOOK_TWEAKCLASS" = "Hide Tweak Classes";
"HOOK_DYLD" = "Dynamic Library Loader";

```

`ShadowSettings.bundle/Resources/en.lproj/Root.strings`:

```strings
"GLOBAL_SETTINGS" = "Global Settings";

"ALWAYS_ON" = "Always-On";
"ALWAYS_ON_DESC" = "Attempts to bypass jailbreak detection in all apps by default. Has no effect if overrode by per-app settings.";

"BYPASS_SETTINGS" = "Bypass Settings";
"BYPASS_SETTINGS_DESC" = "Adjust the strength of the jailbreak detection bypass. App performance may be affected.";

"ROOT_APP_SETTINGS" = "Application Settings";
"ROOT_APP_SETTINGS_DESC" = "Per-app settings will override global settings, if enabled.";

"APPLICATIONS" = "Applications";

"RESPRING" = "Restart SpringBoard";
"RESET" = "Reset Settings";
"RESET_PROMPT" = "This will reset all settings for Shadow.";
"RESET_CANCEL" = "Cancel";

"ROOT_ABOUT" = "About";

```

`ShadowSettings.bundle/Resources/zh-Hans.lproj/About.strings`:

```strings
"ABOUT_TITLE" = "关于";
"BYPASS_VERSION" = "屏蔽版本";
"SERVICE_VERSION" = "服务版本";
"BUILD_DATE" = "构建日期";
"SOFTWARE_LICENSE" = "软件许可";
"UPDATES_HDR" = "更新";
"PACKAGE_VERSION" = "安装包版本";
"LATEST_VERSION" = "最新版本";
"CREDITS_HDR" = "致谢";
"DEVELOPER" = "开发者";
"VISIT_GITHUB" = "在GitHub上查看Shadow";
"VISIT_KOFI" = "在Ko-fi上赞助作者";
"LOCALIZATION_HDR" = "简体中文翻译";
"VISIT_CHANGELOG" = "查看最新的更新日志";

/* your name here! */
"TRANSLATOR" = "nehyci";

```

`ShadowSettings.bundle/Resources/zh-Hans.lproj/App.strings`:

```strings
"APP_SETTINGS" = "应用设置";
"APP_SETTINGS_DESC" = "对此应用启用屏蔽设置。";

"ENABLE_SHADOW" = "启用Shadow";
"ENABLED" = "Enabled";

```

`ShadowSettings.bundle/Resources/zh-Hans.lproj/Hooks.strings`:

```strings
"INTERNAL_SETTINGS" = "内部设置";
"HK_LIB_DESC" = "控制Hook方法。一些Hook库可能提供更好的屏蔽效果，但也可能影响应用的稳定性。";

"HOOKING_LIBRARY" = "Hook库";
"HK_LIB_SELECT" = "这是一个可以在您的设备上使用的Hook库列表。 选择 \"自动\" 来允许HookKit为您的设备选择最合适的Hook库。";
"AUTOMATIC" = "自动";

"COMPAT_SETTINGS" = "兼容性设置";

"ALLOW_RESOURCES" = "允许插件资源";
"ALLOW_RESOURCES_DESC" = "某些插件需要完全访问一些越狱资源。除非需要插件，否则不要启用此功能。";

"ROOTLESS_MODE" = "启用无根模式";
"ROOTLESS_MODE_DESC" = "如果您在无根越狱中运行Shadow，请启用此设置。如果您使用的越狱不是无根越狱，请不要启用。";

"ENHANCEMENT_SETTINGS" = "优化设置";

"ENH_PATH_RESOLVING" = "优化路径处理";
"ENH_PR_DESC" = "启用此设置将产生对文件访问操作的额外处理，但会对性能产生明显影响。";

"ESSENTIAL_HOOKS" = "基本Hook";
"ESSENTIAL_HOOKS_DESC" = "基本Hook包含最常见的越狱检测方法。";

"HOOK_FILE_SYSTEM" = "文件系统";
"HOOK_DYLIB" = "动态库";
"HOOK_URLSCHEME" = "URL处理";
"HOOK_ENVVARS" = "环境变量";

"REC_HOOKS" = "推荐Hook";
"REC_HOOKS_DESC" = "推荐Hook包含可能使用的其他越狱检测方法。";

"HOOK_DETECTFMWK" = "检测框架";
"HOOK_FILE_SYSTEM_EX" = "文件系统（额外）";
"HOOK_FOUNDATION" = "Foundation框架"; /* Foundation是Apple的框架名称. */
"HOOK_MAC" = "M1 Mac 伪装（iOS 14+）";

"EXTRA_HOOKS" = "额外Hook";
"EXTRA_HOOKS_DESC" = "额外Hook包含可能使用的更多越狱检测方法，包括私有API。";

"HOOK_MACH" = "Mach服务查找";
"HOOK_SYMLOOKUP" = "运行时符号查找";
"HOOK_OBJC" = "Objective-C方法";
"HOOK_ANTIDBG" = "反调试方法";
"HOOK_SYSCALL" = "私有系统调用";
"HOOK_APPENUM" = "应用枚举";

"DNGR_HOOKS" = "危险Hook";
"DNGR_HOOKS_DESC" = "底层屏蔽方法。这些Hook可能会使一些应用程序崩溃。";

"HOOK_SANDBOX" = "增强应用沙盒";
"HOOK_LLC" = "底层文件处理";
"HOOK_MEM" = "隐藏可执行内存";
"HOOK_TWEAKCLASS" = "隐藏插件的Objective-C类";
"HOOK_DYLD" = "动态库加载器";

```

`ShadowSettings.bundle/Resources/zh-Hans.lproj/Root.strings`:

```strings
"GLOBAL_SETTINGS" = "全局设置";

"ALWAYS_ON" = "始终开启";
"ALWAYS_ON_DESC" = "默认情况下，在所有应用中尝试屏蔽越狱检测。如果被应用设置覆盖，则没有效果。";

"BYPASS_SETTINGS" = "屏蔽设置";
"BYPASS_SETTINGS_DESC" = "调整越狱检测屏蔽的强度。可能影响应用性能。";

"ROOT_APP_SETTINGS" = "应用设置";
"ROOT_APP_SETTINGS_DESC" = "如果启用，每个应用的设置将覆盖全局设置。";

"APPLICATIONS" = "应用";

"RESPRING" = "重启SpringBoard";
"RESET" = "重置设置";
"RESET_PROMPT" = "这将重置Shadow的所有设置。";
"RESET_CANCEL" = "取消";

"ROOT_ABOUT" = "关于";

```

`ShadowSettings.bundle/Resources/zh-Hant.lproj/About.strings`:

```strings
{
    "ABOUT_TITLE" = "\U95dc\U65bc";
    "BUILD_DATE" = "\U7248\U672c\U65e5\U671f";
    "BYPASS_VERSION" = "\U9632\U5075\U6e2c\U7248\U672c";
    "CREDITS_HDR" = "\U9cf4\U8b1d\U4eba\U54e1";
    DEVELOPER = "\U958b\U767c\U8005";
    "LATEST_VERSION" = "\U6e90\U6700\U65b0\U5b89\U88dd\U5305\U7248\U672c";
    "LOCALIZATION_HDR" = "繁體中文翻譯";
    "PACKAGE_VERSION" = "\U672c\U6a5f\U5df2\U5b89\U88dd\U5305\U7248\U672c";
    "SERVICE_VERSION" = "\U670d\U52d9\U7248\U672c";
    "SOFTWARE_LICENSE" = "\U8edf\U9ad4\U8a31\U53ef\U8b49";
    TRANSLATOR = CySxL;
    "UPDATES_HDR" = "\U7248\U672c\U6aa2\U67e5";
    "VISIT_GITHUB" = "\U5728GitHub\U700f\U89bd\U539f\U59cb\U78bc";
    "VISIT_KOFI" = "\U5728Ko-fi\U6253\U8cde\U652f\U6301\U6211\Ud83e\Udef6";
    "VISIT_CHANGELOG" = "查看更新日誌";
}
```

`ShadowSettings.bundle/Resources/zh-Hant.lproj/App.strings`:

```strings
{
    "APP_SETTINGS" = "\U61c9\U7528\U7a0b\U5f0f\U8a2d\U5b9a";
    "APP_SETTINGS_DESC" = "\U91dd\U5c0d\U6b64\U61c9\U7528\U7a0b\U5f0f\U555f\U7528\U9632\U8d8a\U7344\U5075\U6e2c\U8a2d\U5b9a\U3002";
    "ENABLE_SHADOW" = "\U555f\U7528Shadow";
    "ENABLED" = "Enabled";
}
```

`ShadowSettings.bundle/Resources/zh-Hant.lproj/Hooks.strings`:

```strings
{
    "ALLOW_RESOURCES" = "\U5141\U8a31\U63d2\U9ad4\U8cc7\U6e90";
    "ALLOW_RESOURCES_DESC" = "\U6709\U4e9b\U63d2\U9ad4\U9700\U8981\U5b8c\U5168\U5b58\U53d6\U67d0\U4e9b\U8d8a\U7344\U8cc7\U6e90\U3002\U9664\U975e\U6709\U7279\U5225\U9700\U6c42\Uff0c\U5426\U5247\U8acb\U52ff\U555f\U7528\U6b64\U529f\U80fd\U3002\U8b6f\U8005\U8a3b\Uff1a\U555f\U7528\U6b64\U529f\U80fd\U5c07\U964d\U4f4e\U9632\U8d8a\U7344\U5075\U6e2c\U80fd\U529b\U3002";
    AUTOMATIC = "\U81ea\U52d5";
    "COMPAT_SETTINGS" = "\U63d2\U9ad4\U76f8\U5bb9\U6027\U8a2d\U5b9a";
    "ENHANCEMENT_SETTINGS" = "優化設定";
    "ENH_PATH_RESOLVING" = "優化路徑處理";
    "ENH_PR_DESC" = "啟用此設定來對檔案存取運算進行額外處理。這將可能提升防偵測能力但同時明顯降低App運行效能";
    "DNGR_HOOKS" = "\U5371\U96aa\U639b\U9264\Ud83e\Ude9d";
    "DNGR_HOOKS_DESC" = "\U5e95\U5c64\U9632\U8d8a\U7344\U5075\U6e2c\U65b9\U6cd5\U3002\U67d0\U4e9b\U639b\U9264\U53ef\U80fd\U6703\U5c0e\U81f4\U61c9\U7528\U7a0b\U5f0f\U5d29\U6f70\U3002";
    "ESSENTIAL_HOOKS" = "\U57fa\U672c\U639b\U9264\Ud83e\Ude9d";
    "ESSENTIAL_HOOKS_DESC" = "\U57fa\U672c\U639b\U9264\U6db5\U84cb\U4e86\U5e38\U898b\U7684\U8d8a\U7344\U5075\U6e2c\U65b9\U5f0f\U3002";
    "EXTRA_HOOKS" = "\U984d\U5916\U639b\U9264\Ud83e\Ude9d";
    "EXTRA_HOOKS_DESC" = "\U984d\U5916\U639b\U9264\U6db5\U84cb\U4e86\U66f4\U591a\U7684\U8d8a\U7344\U5075\U6e2c\U65b9\U6cd5\Uff0c\U5305\U542b\U79c1\U4ebaAPI\U3002";
    "HK_LIB_DESC" = "\U9078\U64c7\U6514\U622a\U61c9\U7528\U7a0b\U5f0f\U5167\U78bc\U7684\U65b9\U6cd5\U3002\U67d0\U4e9b\U639b\U9264\U51fd\U5f0f\U5eab\U53ef\U80fd\U6703\U63d0\U4f9b\U66f4\U597d\U7684\U9632\U8d8a\U7344\U5075\U6e2c\U80fd\U529b\Uff0c\U4f46\U4e5f\U53ef\U80fd\U5f71\U97ff\U61c9\U7528\U7a0b\U5e8f\U7a69\U5b9a\U6027\U3002";
    "HK_LIB_SELECT" = "\U9019\U662f\U53ef\U5728\U8a2d\U5099\U4e0a\U4f7f\U7528\U7684\U639b\U9264\U51fd\U5f0f\U5eab\U5217\U8868\U3002\U9078\U64c7\U300c\U81ea\U52d5\U300d\U4ee5\U5141\U8a31Hookkit\U70ba\U60a8\U7684\U8a2d\U5099\U9078\U64c7\U6700\U4f73\U7684\U639b\U9264\U51fd\U5f0f\U5eab\U3002\U8b6f\U8005\U8a3b\Uff1a\U300c\U81ea\U52d5\U300d\U5c07\U6703\U9078\U64c7\U57fa\U65bc\U60a8\U8d8a\U7344\U5de5\U5177\U7684\U51fd\U5f0f\U5eab\Uff0c\U53ea\U6703\U63d0\U5347\U61c9\U7528\U7a0b\U5f0f\U904b\U884c\U7684\U6548\U80fd\Uff0c\U4e0d\U6703\U589e\U5f37\U9632\U8d8a\U7344\U5075\U6e2c\U80fd\U529b\Uff1b\U9078\U64c7\U300cElleKit, fishhook, Dobby\U300d\U5c0d\U67d0\U4e9b\U61c9\U7528\U7a0b\U5f0f\U53ef\U4ee5\U589e\U5f37\U9632\U8d8a\U7344\U5075\U6e2c\U80fd\U529b\U3002";
    "HOOKING_LIBRARY" = "\U639b\U9264\U51fd\U5f0f\U5eab";
    "HOOK_ANTIDBG" = "Anti-Debugging Methods";
    "HOOK_APPENUM" = "App Enumeration";
    "HOOK_DETECTFMWK" = "Detection Frameworks";
    "HOOK_DYLD" = "Dynamic Library Loader";
    "HOOK_DYLIB" = "Dynamic Libraries";
    "HOOK_ENVVARS" = "Environment Variables";
    "HOOK_FILE_SYSTEM" = "File System";
    "HOOK_FILE_SYSTEM_EX" = "File System (Extra)";
    "HOOK_FOUNDATION" = "Foundation Framework";
    "HOOK_LLC" = "Low-Level File Handles";
    "HOOK_MAC" = "M1 Mac Spoof (iOS 14+)";
    "HOOK_MACH" = "Mach Service Lookups";
    "HOOK_MEM" = "Hide Executable Memory";
    "HOOK_OBJC" = "Objective-C Class Methods";
    "HOOK_SANDBOX" = "Enforce App Sandbox";
    "HOOK_SYMLOOKUP" = "Runtime Symbol Lookups";
    "HOOK_SYSCALL" = "Private Syscalls";
    "HOOK_TWEAKCLASS" = "Hide Tweak Classes";
    "HOOK_URLSCHEME" = "URL Handlers";
    "INTERNAL_SETTINGS" = "\U5167\U90e8\U8a2d\U5b9a";
    "REC_HOOKS" = "\U63a8\U85a6\U639b\U9264\Ud83e\Ude9d";
    "REC_HOOKS_DESC" = "\U63a8\U85a6\U639b\U9264\U6db5\U84cb\U4e86\U8d8a\U7344\U5075\U6e2c\U53ef\U80fd\U4f7f\U7528\U7684\U5176\U4ed6\U65b9\U6cd5\U3002";
    "ROOTLESS_MODE" = "\U555f\U7528\U7121\U6839(Rootless)\U6a21\U5f0f";
    "ROOTLESS_MODE_DESC" = "\U5982\U679c\U60a8\U5728\U7121\U6839(Rootless)\U8d8a\U7344\U4e2d\U4f7f\U7528Shadow\Uff0c\U8acb\U958b\U555f\U6b64\U8a2d\U5b9a\U3002\U5982\U679c\U60a8\U7684\U8d8a\U7344\U4e0d\U662f\U7121\U6839\U7684\Uff0c\U8acb\U4e0d\U8981\U555f\U7528\U6b64\U8a2d\U5b9a\U3002";
}
```

`ShadowSettings.bundle/Resources/zh-Hant.lproj/Root.strings`:

```strings
{
    "ALWAYS_ON" = "\U7e3d\U662f\U555f\U7528";
    "ALWAYS_ON_DESC" = "\U9810\U8a2d\U7e5e\U904e\U6240\U6709\U61c9\U7528\U7a0b\U5f0f\U4e2d\U7684\U8d8a\U7344\U5075\U6e2c\U3002\U5982\U679c\U5728\U4e0b\U65b9\U7684\U300c\U500b\U5225\U61c9\U7528\U7a0b\U5f0f\U9632\U8d8a\U7344\U5075\U6e2c\U8a2d\U5b9a\U300d\U4e2d\U6709\U984d\U5916\U8abf\U6574\Uff0c\U5247\U6b64\U529f\U80fd\U88ab\U8986\U5beb\U6c92\U6709\U6548\U679c\U3002";
    APPLICATIONS = "\U9078\U64c7\U61c9\U7528\U7a0b\U5f0f";
    "BYPASS_SETTINGS" = "\U5168\U57df\U9632\U8d8a\U7344\U5075\U6e2c\U8a2d\U5b9a";
    "BYPASS_SETTINGS_DESC" = "\U8abf\U6574\U9632\U8d8a\U7344\U5075\U6e2c\U7684\U5f37\U5ea6\U3002\U61c9\U7528\U7a0b\U5f0f\U6027\U80fd\U53ef\U80fd\U6703\U53d7\U5230\U5f71\U97ff\U3002";
    "GLOBAL_SETTINGS" = "\U5168\U57df\U8a2d\U5b9a";
    RESET = "\U91cd\U7f6e\U6240\U6709\U8a2d\U5b9a";
    "RESET_CANCEL" = "\U53d6\U6d88";
    "RESET_PROMPT" = "\U9019\U5c07\U91cd\U7f6eShadow\U7684\U6240\U6709\U8a2d\U5b9a\U3002";
    RESPRING = "\U91cd\U65b0\U8f09\U5165SpringBoard";
    "ROOT_ABOUT" = "\U95dc\U65bc";
    "ROOT_APP_SETTINGS" = "\U500b\U5225\U61c9\U7528\U7a0b\U5f0f\U9632\U8d8a\U7344\U5075\U6e2c\U8a2d\U5b9a";
    "ROOT_APP_SETTINGS_DESC" = "\U5982\U679c\U555f\U7528\U4e86\U500b\U5225\U61c9\U7528\U7a0b\U5f0f\U8a2d\U5b9a\Uff0c\U5247\U5c07\U8986\U5beb\U4e0a\U65b9\U7684\U5168\U57df\U8a2d\U5b9a\U3002";
}
```

`ShadowSettings.bundle/SHDWATLController.h`:

```h
#import <AltList/ATLApplicationListSubcontrollerController.h>

@interface SHDWATLController : ATLApplicationListSubcontrollerController
- (NSString *)previewStringForApplicationWithIdentifier:(NSString *)applicationID;
@end

```

`ShadowSettings.bundle/SHDWATLController.m`:

```m
#import "SHDWATLController.h"
#import <Shadow/Settings.h>

@implementation SHDWATLController {
	NSUserDefaults* prefs;
}

- (NSString *)previewStringForApplicationWithIdentifier:(NSString *)applicationID {
    // read enabled status for applicationID
    NSDictionary* app_settings = [prefs objectForKey:applicationID];

    if(app_settings) {
        // show "Enabled" label if shadow is enabled in app
        if(app_settings[@"App_Enabled"] && [app_settings[@"App_Enabled"] boolValue]) {
            return [[NSBundle bundleForClass:[self class]] localizedStringForKey:@"ENABLED" value:@"Enabled" table:@"App"];
        }
    }

    return @"";
}

- (instancetype)init {
	if((self = [super init])) {
		prefs = [[ShadowSettings sharedInstance] userDefaults];
	}

	return self;
}
@end

```

`ShadowSettings.bundle/SHDWAboutListController.h`:

```h
#import <Foundation/Foundation.h>
#import <Preferences/PSListController.h>

@interface SHDWAboutListController : PSListController
- (NSString *)aboutDeveloper:(id)sender;
- (NSString *)aboutTranslator:(id)sender;
- (NSString *)aboutLatestVersion:(id)sender;

- (void)openGitHub:(id)sender;
- (void)openKofi:(id)sender;
- (void)openChangeLog:(id)sender;
@end

```

`ShadowSettings.bundle/SHDWAboutListController.m`:

```m
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#import "SHDWAboutListController.h"

@implementation SHDWAboutListController {
	NSString* packageVersion;
	NSString* latestVersion;
}

- (NSArray *)specifiers {
	if(!_specifiers) {
		_specifiers = [self loadSpecifiersFromPlistName:@"About" target:self];
	}

	return _specifiers;
}

- (NSString *)aboutDeveloper:(id)sender {
	return @"jjolano";
}

- (NSString *)aboutTranslator:(id)sender {
	return [[NSBundle bundleForClass:[self class]] localizedStringForKey:@"TRANSLATOR" value:@"Unknown" table:@"About"];
}

- (NSString *)aboutLatestVersion:(id)sender {
	if(latestVersion) {
		return latestVersion;
	}

	NSURL* update_url = [NSURL URLWithString:@"https://api.github.com/repos/jjolano/shadow/releases/latest"];

	NSURLSession* session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration ephemeralSessionConfiguration] delegate:nil delegateQueue:[NSOperationQueue mainQueue]];
	NSURLSessionDataTask* task = [session dataTaskWithURL:update_url completionHandler:^(NSData* data, NSURLResponse* response, NSError* error) {
		if(!error) {
			NSDictionary* json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];

			if(json) {
				latestVersion = [json[@"tag_name"] substringFromIndex:1];
			} else {
				latestVersion = @"unknown";
			}
		} else {
			latestVersion = @"unknown";
		}

		[self reloadSpecifier:sender];
	}];

	[task resume];

	return latestVersion;
}

- (void)openGitHub:(id)sender {
	[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"https://github.com/jjolano/shadow"]];
}

- (void)openKofi:(id)sender {
	[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"https://ko-fi.com/jjolano"]];
}

- (void)openChangeLog:(id)sender {
	[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"https://github.com/jjolano/shadow/releases/latest"]];
}

- (instancetype)init {
	if((self = [super init])) {
		packageVersion = nil;
		latestVersion = nil;
	}

	return self;
}
@end

```

`ShadowSettings.bundle/SHDWAppListController.h`:

```h
#import <Foundation/Foundation.h>
#import <Preferences/PSSpecifier.h>
#import <Preferences/PSListController.h>

#import <AltList/ATLApplicationListSubcontroller.h>

@interface SHDWAppListController : ATLApplicationListSubcontroller
- (id)readPreferenceValue:(PSSpecifier *)specifier;
- (void)setPreferenceValue:(id)value forSpecifier:(PSSpecifier *)specifier;
- (NSArray *)getValues:(PSSpecifier *)specifier;
- (NSArray *)getTitles:(PSSpecifier *)specifier;
@end

```

`ShadowSettings.bundle/SHDWAppListController.m`:

```m
#import "SHDWAppListController.h"

#import <Shadow/Settings.h>
#import <HookKit.h>

@implementation SHDWAppListController {
	NSUserDefaults* prefs;

	NSMutableArray* hk_lib_values;
	NSMutableArray* hk_lib_titles;
}

- (NSArray *)specifiers {
	if(!_specifiers) {
		_specifiers = [self loadSpecifiersFromPlistName:@"App" target:self];
		[_specifiers addObjectsFromArray:[self loadSpecifiersFromPlistName:@"Hooks" target:self]];
	}

	return _specifiers;
}

- (id)readPreferenceValue:(PSSpecifier *)specifier {
	NSDictionary* prefs_app = [prefs dictionaryForKey:[self applicationID]];

	if(prefs_app) {
		id value = prefs_app[[specifier identifier]];
		if(value) return value;
	}

	if([[specifier identifier] isEqualToString:@"HK_Library"]) {
		return [[[ShadowSettings sharedInstance] defaultSettings] objectForKey:@"HK_Library"];
	}

	return nil;
}

- (void)setPreferenceValue:(id)value forSpecifier:(PSSpecifier *)specifier {
	NSDictionary* prefs_app = [prefs dictionaryForKey:[self applicationID]];
	NSMutableDictionary* prefs_app_m = prefs_app ? [prefs_app mutableCopy] : [NSMutableDictionary new];

	prefs_app_m[[specifier identifier]] = value;

	[prefs setObject:[prefs_app_m copy] forKey:[self applicationID]];
	[prefs synchronize];
}

- (NSArray *)getValues:(PSSpecifier *)specifier {
	return [hk_lib_values copy];
}

- (NSArray *)getTitles:(PSSpecifier *)specifier {
	return [hk_lib_titles copy];
}

- (instancetype)init {
	if((self = [super init])) {
		prefs = [[ShadowSettings sharedInstance] userDefaults];

		hk_lib_values = [NSMutableArray new];
		hk_lib_titles = [NSMutableArray new];

		hookkit_lib_t hooklibs = [HKSubstitutor getAvailableSubstitutorTypes];
		NSArray<NSDictionary *>* hooklibs_info = [HKSubstitutor getSubstitutorTypeInfo:hooklibs];

		[hk_lib_values addObject:@"auto"];
		[hk_lib_titles addObject:[[NSBundle bundleForClass:[self class]] localizedStringForKey:@"AUTOMATIC" value:@"Automatic" table:@"Hooks"]];

        for(NSDictionary* hooklib_info in hooklibs_info) {
			[hk_lib_values addObject:hooklib_info[@"id"]];
			[hk_lib_titles addObject:hooklib_info[@"name"]];
        }
	}

	return self;
}
@end

```

`ShadowSettings.bundle/SHDWHooksListController.h`:

```h
#import <Foundation/Foundation.h>
#import <Preferences/PSSpecifier.h>
#import <Preferences/PSListController.h>

@interface SHDWHooksListController : PSListController
- (id)readPreferenceValue:(PSSpecifier *)specifier;
- (void)setPreferenceValue:(id)value forSpecifier:(PSSpecifier *)specifier;
- (NSArray *)getValues:(PSSpecifier *)specifier;
- (NSArray *)getTitles:(PSSpecifier *)specifier;
@end

```

`ShadowSettings.bundle/SHDWHooksListController.m`:

```m
#import "SHDWHooksListController.h"

#import <Shadow/Settings.h>
#import <HookKit.h>

@implementation SHDWHooksListController {
	NSUserDefaults* prefs;

	NSMutableArray* hk_lib_values;
	NSMutableArray* hk_lib_titles;
}

- (NSArray *)specifiers {
	if(!_specifiers) {
		_specifiers = [self loadSpecifiersFromPlistName:@"Hooks" target:self];
		[self setTitle:@"Bypass Settings"];
	}

	return _specifiers;
}

- (id)readPreferenceValue:(PSSpecifier *)specifier {
	return [prefs objectForKey:[specifier identifier]];
}

- (void)setPreferenceValue:(id)value forSpecifier:(PSSpecifier *)specifier {
	[prefs setObject:value forKey:[specifier identifier]];
	[prefs synchronize];
}

- (NSArray *)getValues:(PSSpecifier *)specifier {
	return [hk_lib_values copy];
}

- (NSArray *)getTitles:(PSSpecifier *)specifier {
	return [hk_lib_titles copy];
}

- (instancetype)init {
	if((self = [super init])) {
		prefs = [[ShadowSettings sharedInstance] userDefaults];

		hk_lib_values = [NSMutableArray new];
		hk_lib_titles = [NSMutableArray new];

		hookkit_lib_t hooklibs = [HKSubstitutor getAvailableSubstitutorTypes];
		NSArray<NSDictionary *>* hooklibs_info = [HKSubstitutor getSubstitutorTypeInfo:hooklibs];

		[hk_lib_values addObject:@"auto"];
		[hk_lib_titles addObject:[[NSBundle bundleForClass:[self class]] localizedStringForKey:@"AUTOMATIC" value:@"Automatic" table:@"Hooks"]];

        for(NSDictionary* hooklib_info in hooklibs_info) {
			[hk_lib_values addObject:hooklib_info[@"id"]];
			[hk_lib_titles addObject:hooklib_info[@"name"]];
        }
	}

	return self;
}
@end

```

`ShadowSettings.bundle/SHDWRootListController.h`:

```h
#import <Foundation/Foundation.h>
#import <Preferences/PSSpecifier.h>
#import <Preferences/PSListController.h>
#import <spawn.h>

@interface SHDWRootListController : PSListController
- (id)readPreferenceValue:(PSSpecifier *)specifier;
- (void)setPreferenceValue:(id)value forSpecifier:(PSSpecifier *)specifier;
- (void)respring:(id)sender;
- (void)reset:(id)sender;
@end

```

`ShadowSettings.bundle/SHDWRootListController.m`:

```m
#import "SHDWRootListController.h"

#import <Shadow/Core+Utilities.h>
#import <Shadow/Settings.h>

#import <RootBridge.h>

@implementation SHDWRootListController {
	NSUserDefaults* prefs;
}

- (NSArray *)specifiers {
	if(!_specifiers) {
		_specifiers = [self loadSpecifiersFromPlistName:@"Root" target:self];
	}

	return _specifiers;
}

- (id)readPreferenceValue:(PSSpecifier *)specifier {
	return [prefs objectForKey:[specifier identifier]];
}

- (void)setPreferenceValue:(id)value forSpecifier:(PSSpecifier *)specifier {
	[prefs setObject:value forKey:[specifier identifier]];
	[prefs synchronize];
}

- (void)respring:(id)sender {
	if([[NSFileManager defaultManager] fileExistsAtPath:[RootBridge getJBPath:@"/usr/bin/sbreload"]]) {
		pid_t pid;
		const char *args[] = {"sbreload", NULL, NULL, NULL};
		posix_spawn(&pid, [[RootBridge getJBPath:@"/usr/bin/sbreload"] fileSystemRepresentation], NULL, NULL, (char *const *)args, NULL);
	} else {
		pid_t pid;
		const char *args[] = {"killall", "-9", "SpringBoard", NULL};
		posix_spawn(&pid, [[RootBridge getJBPath:@"/usr/bin/killall"] fileSystemRepresentation], NULL, NULL, (char *const *)args, NULL);
	}
}

- (void)reset:(id)sender {
	NSDictionary* prefs_dict = [prefs dictionaryRepresentation];
    for(id key in prefs_dict) {
		[prefs removeObjectForKey:key];
    }

    [prefs synchronize];
	
	[self respring:sender];
}

- (instancetype)init {
	if((self = [super init])) {
		prefs = [[ShadowSettings sharedInstance] userDefaults];
	}

	return self;
}
@end

```

`ShadowSettings.bundle/layout/Library/PreferenceLoader/Preferences/ShadowSettings.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>entry</key>
	<dict>
		<key>bundle</key>
		<string>ShadowSettings</string>
		<key>cell</key>
		<string>PSLinkCell</string>
		<key>detail</key>
		<string>SHDWRootListController</string>
		<key>icon</key>
		<string>icon.png</string>
		<key>isController</key>
		<true/>
		<key>label</key>
		<string>Shadow</string>
	</dict>
</dict>
</plist>

```

`build.sh`:

```sh
#!/usr/bin/env bash
set -e

PWD=$(dirname -- "$0")
cd $PWD

# create fresh build directory
rm -rf $PWD/build
mkdir -p $PWD/build

# build main project (rootless ver.)
make clean &&
THEOS_PACKAGE_SCHEME=rootless ARCHS="arm64 arm64e" TARGET=iphone:clang:latest:14.0 make package FINALPACKAGE=1 &&
cp -p "`ls -dtr1 packages/* | tail -1`" $PWD/build/

rm -rf $THEOS/lib/Shadow.framework

# build main project (rooted ver.)
make clean &&
make package FINALPACKAGE=1 &&
cp -p "`ls -dtr1 packages/* | tail -1`" $PWD/build/

rm -rf $THEOS/lib/Shadow.framework

```

`common.h`:

```h
#define BUNDLE_ID           "me.jjolano.shadow"
#define MACH_SERVICE_NAME   BUNDLE_ID ".service"
#define SHADOW_RULESETS     "/Library/Shadow/Rulesets"
#define SHADOW_DB_PLIST     SHADOW_RULESETS "/dpkgInstalled.plist"
#define SHADOW_PREFS_PLIST  "/var/mobile/Library/Preferences/" BUNDLE_ID ".plist"

#ifdef DEBUG
#define NSLog(...) NSLog(__VA_ARGS__)
#else
#define NSLog(...) (void)0
#endif

#ifndef kCFCoreFoundationVersionNumber_iOS_14_1
#define kCFCoreFoundationVersionNumber_iOS_14_1 1751.108
#endif

#ifndef kCFCoreFoundationVersionNumber_iOS_11_0
#define kCFCoreFoundationVersionNumber_iOS_11_0 1443.00
#endif

```

`control`:

```
Package: me.jjolano.shadow
Name: Shadow
Pre-Depends: dpkg
Depends: firmware (>= 8.0), com.opa334.altlist, com.opa334.libsandy, me.jjolano.fmwk.hookkit, me.jjolano.hkmodule.substrate, me.jjolano.fmwk.rootbridge
Suggests: com.ps.injectionfoundation
Recommends: mobilesubstrate, preferenceloader, me.jjolano.hkmodule.fishhook
Provides: me.jjolano.shadow.beta
Replaces: me.jjolano.shadow.beta
Conflicts: me.jjolano.shadow.beta, me.jjolano.shadow.legacy
Version: 3.7.6
Architecture: iphoneos-arm
Description: A modern jailbreak detection bypass.
Maintainer: jjolano
Author: jjolano
Section: System

```

`layout/DEBIAN/postinst`:

```
#!/usr/bin/env bash

if [[ $DPKG_MAINTSCRIPT_ARCH == "iphoneos-arm64" ]]
then
    DPKG_ROOT="/var/jb"
fi

case "$1" in
    configure)
        chown -R mobile:mobile "$DPKG_ROOT/Library/Shadow"
        chmod -R 0777 "$DPKG_ROOT/Library/Shadow"

        "$DPKG_ROOT/usr/local/bin/shdw" -g > /dev/null || true
    ;;

    triggered)
        "$DPKG_ROOT/usr/local/bin/shdw" -g > /dev/null || true
    ;;
esac

exit 0

```

`layout/DEBIAN/postrm`:

```
#!/usr/bin/env bash

if [[ $DPKG_MAINTSCRIPT_ARCH == "iphoneos-arm64" ]]
then
    DPKG_ROOT="/var/jb"
fi

case "$1" in
    triggered)
        "$DPKG_ROOT/usr/local/bin/shdw" -g > /dev/null || true
    ;;
esac

exit 0

```

`layout/DEBIAN/triggers`:

```
interest /var/mobile
interest /var/jb/Applications
interest /System
interest /Applications

```

`shdw/Makefile`:

```
include $(THEOS)/makefiles/common.mk

TOOL_NAME = shdw

shdw_FILES = main.m
shdw_CFLAGS = -fobjc-arc -I../Shadow.framework/Headers -I../vendor/RootBridge.framework/Headers
shdw_LDFLAGS = -rpath /Library/Frameworks -rpath /var/jb/Library/Frameworks -rpath /usr/lib -rpath /var/jb/usr/lib
shdw_LDFLAGS += -F../ -F../vendor/
shdw_CODESIGN_FLAGS = -Sentitlements.plist
shdw_INSTALL_PATH = /usr/local/bin
shdw_EXTRA_FRAMEWORKS = Shadow RootBridge
shdw_FRAMEWORKS = Foundation

include $(THEOS_MAKE_PATH)/tool.mk

```

`shdw/entitlements.plist`:

```plist
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>platform-application</key>
    <true/>
    <key>com.apple.private.security.container-required</key>
    <false/>
</dict>
</plist>

```

`shdw/main.m`:

```m
#import <stdio.h>
#import <unistd.h>
#import <Foundation/Foundation.h>

#import <Shadow.h>
#import <Shadow/Core+Utilities.h>

#import <RootBridge.h>

#import "../common.h"

int main(int argc, char *argv[], char *envp[]) {
    @autoreleasepool {
        if(argc == 1) {
            printf("shdw - command line utility for Shadow\n");
            printf("usage: %s [-g] | <path> [path [...]]\n", argv[0]);
            printf("\tpath: check if path is restricted\n");
            printf("\t-g: regenerate dpkg installed ruleset\n");

            return 0;
        }

        bool regenerateDb = false;

        int opt;
        while((opt = getopt(argc, argv, "g")) != -1) {
            switch(opt) {
                case 'g':
                    regenerateDb = true;
                    break;
            }
        }

        if(regenerateDb) {
            NSDictionary* ruleset_dpkg = [Shadow generateDatabase];

            if(ruleset_dpkg) {
                BOOL success = [ruleset_dpkg writeToFile:[RootBridge getJBPath:@(SHADOW_DB_PLIST)] atomically:NO];

                if(success) {
                    printf("successfully regenerated dpkg ruleset\n");
                    return 0;
                } else {
                    fprintf(stderr, "error: failed to save generated ruleset\n");
                }
            } else {
                fprintf(stderr, "error: could not generate ruleset\n");
            }

            return -1;
        }

        Shadow* shadow = [Shadow sharedInstance];

        if(!shadow) {
            fprintf(stderr, "error: could not init Shadow\n");
            return -1;
        }

        for(int i = optind; i < argc; i++) {
            // ignore relative paths
            if(argv[i][0] != '/') {
                continue;
            }

            BOOL restricted = [shadow isCPathRestricted:argv[i]];
            printf("%s: %s\n", argv[i], restricted ? "restricted" : "allowed");
        }

        return 0;
    }
}

```

`vendor/apple/NSTask.h`:

```h
/*	NSTask.h
	Copyright (c) 1996-2007, Apple Inc. All rights reserved.
*/

#import <Foundation/NSObject.h>

@class NSString, NSArray, NSDictionary;

@interface NSTask : NSObject

// Create an NSTask which can be run at a later time
// An NSTask can only be run once. Subsequent attempts to
// run an NSTask will raise.
// Upon task death a notification will be sent
//   { Name = NSTaskDidTerminateNotification; object = task; }
//

- (instancetype)init;

// set parameters
// these methods can only be done before a launch
- (void)setLaunchPath:(NSString *)path;
- (void)setArguments:(NSArray *)arguments;
- (void)setEnvironment:(NSDictionary *)dict;
	// if not set, use current
- (void)setCurrentDirectoryPath:(NSString *)path;
	// if not set, use current

// set standard I/O channels; may be either an NSFileHandle or an NSPipe
- (void)setStandardInput:(id)input;
- (void)setStandardOutput:(id)output;
- (void)setStandardError:(id)error;

// get parameters
- (NSString *)launchPath;
- (NSArray *)arguments;
- (NSDictionary *)environment;
- (NSString *)currentDirectoryPath;

// get standard I/O channels; could be either an NSFileHandle or an NSPipe
- (id)standardInput;
- (id)standardOutput;
- (id)standardError;

// actions
- (void)launch;

- (void)interrupt; // Not always possible. Sends SIGINT.
- (void)terminate; // Not always possible. Sends SIGTERM.

- (BOOL)suspend;
- (BOOL)resume;

// status
- (int)processIdentifier; 
- (BOOL)isRunning;

- (int)terminationStatus;

@end

@interface NSTask (NSTaskConveniences)

+ (NSTask *)launchedTaskWithLaunchPath:(NSString *)path arguments:(NSArray *)arguments;
	// convenience; create and launch

- (void)waitUntilExit;
	// poll the runLoop in defaultMode until task completes

@end

FOUNDATION_EXPORT NSString * const NSTaskDidTerminateNotification;

```

`vendor/apple/codesign.h`:

```h
/*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _SYS_CODESIGN_H_
#define _SYS_CODESIGN_H_

#include <sys/types.h>

/* code signing attributes of a process */
#define    CS_VALID        0x0000001    /* dynamically valid */
#define CS_ADHOC        0x0000002    /* ad hoc signed */
#define CS_GET_TASK_ALLOW    0x0000004    /* has get-task-allow entitlement */
#define CS_INSTALLER        0x0000008    /* has installer entitlement */

#define    CS_HARD            0x0000100    /* don't load invalid pages */
#define    CS_KILL            0x0000200    /* kill process if it becomes invalid */
#define CS_CHECK_EXPIRATION    0x0000400    /* force expiration checking */
#define CS_RESTRICT        0x0000800    /* tell dyld to treat restricted */
#define CS_ENFORCEMENT        0x0001000    /* require enforcement */
#define CS_REQUIRE_LV        0x0002000    /* require library validation */
#define CS_ENTITLEMENTS_VALIDATED    0x0004000

#define    CS_ALLOWED_MACHO    0x00ffffe

#define CS_EXEC_SET_HARD    0x0100000    /* set CS_HARD on any exec'ed process */
#define CS_EXEC_SET_KILL    0x0200000    /* set CS_KILL on any exec'ed process */
#define CS_EXEC_SET_ENFORCEMENT    0x0400000    /* set CS_ENFORCEMENT on any exec'ed process */
#define CS_EXEC_SET_INSTALLER    0x0800000    /* set CS_INSTALLER on any exec'ed process */

#define CS_KILLED        0x1000000    /* was killed by kernel for invalidity */
#define CS_DYLD_PLATFORM    0x2000000    /* dyld used to load this is a platform binary */
#define CS_PLATFORM_BINARY    0x4000000    /* this is a platform binary */
#define CS_PLATFORM_PATH    0x8000000    /* platform binary by the fact of path (osx only) */

/* csops  operations */
#define CS_OPS_STATUS       0   /* return status */
#define CS_OPS_MARKINVALID  1   /* invalidate process */
#define CS_OPS_MARKHARD     2   /* set HARD flag */
#define CS_OPS_MARKKILL     3   /* set KILL flag (sticky) */
#define CS_OPS_PIDPATH      4   /* get executable's pathname */
#define CS_OPS_CDHASH       5   /* get code directory hash */
#define CS_OPS_PIDOFFSET    6   /* get offset of active Mach-o slice */
#define CS_OPS_ENTITLEMENTS_BLOB 7  /* get entitlements blob */
#define CS_OPS_MARKRESTRICT 8   /* set RESTRICT flag (sticky) */

#ifndef KERNEL

__BEGIN_DECLS

/* code sign operations */
int csops(pid_t pid, unsigned int  ops, void * useraddr, size_t usersize);

__END_DECLS

#endif /* ! KERNEL */

#endif /* _SYS_CODESIGN_H_ */

```

`vendor/apple/dyld_priv.h`:

```h
/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-
 *
 * Copyright (c) 2003-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _MACH_O_DYLD_PRIV_H_
#define _MACH_O_DYLD_PRIV_H_

#include <assert.h>
#include <stdbool.h>
#include <unistd.h>
#include <Availability.h>
#include <TargetConditionals.h>
#include <mach-o/dyld.h>
#include <uuid/uuid.h>

#if __cplusplus
extern "C" {
#endif /* __cplusplus */



//
// private interface between libSystem.dylib and dyld
//
extern void _dyld_atfork_prepare(void);
extern void _dyld_atfork_parent(void);
extern void _dyld_fork_child(void);



typedef void (*_dyld_objc_notify_mapped)(unsigned count, const char* const paths[], const struct mach_header* const mh[]);
typedef void (*_dyld_objc_notify_init)(const char* path, const struct mach_header* mh);
typedef void (*_dyld_objc_notify_unmapped)(const char* path, const struct mach_header* mh);


//
// Note: only for use by objc runtime
// Register handlers to be called when objc images are mapped, unmapped, and initialized.
// Dyld will call back the "mapped" function with an array of images that contain an objc-image-info section.
// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to
// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),
// dyld will call the "mapped" function with already loaded objc images.  During any later dlopen() call,
// dyld will also call the "mapped" function.  Dyld will call the "init" function when dyld would be called
// initializers in that image.  This is when objc calls any +load methods in that image.
//
void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,
                                _dyld_objc_notify_init      init,
                                _dyld_objc_notify_unmapped  unmapped);


//
// get slide for a given loaded mach_header  
// Mac OS X 10.6 and later
//
extern intptr_t _dyld_get_image_slide(const struct mach_header* mh);



struct dyld_unwind_sections
{
	const struct mach_header*		mh;
	const void*						dwarf_section;
	uintptr_t						dwarf_section_length;
	const void*						compact_unwind_section;
	uintptr_t						compact_unwind_section_length;
};


//
// Returns true iff some loaded mach-o image contains "addr".
//	info->mh							mach header of image containing addr
//  info->dwarf_section					pointer to start of __TEXT/__eh_frame section
//  info->dwarf_section_length			length of __TEXT/__eh_frame section
//  info->compact_unwind_section		pointer to start of __TEXT/__unwind_info section
//  info->compact_unwind_section_length	length of __TEXT/__unwind_info section
//
// Exists in Mac OS X 10.6 and later 
#if !__USING_SJLJ_EXCEPTIONS__
extern bool _dyld_find_unwind_sections(void* addr, struct dyld_unwind_sections* info);
#endif


//
// This is an optimized form of dladdr() that only returns the dli_fname field.
//
// Exists in Mac OS X 10.6 and later 
extern const char* dyld_image_path_containing_address(const void* addr);


//
// This is an optimized form of dladdr() that only returns the dli_fbase field.
// Return NULL, if address is not in any image tracked by dyld.
//
// Exists in Mac OS X 10.11 and later
extern const struct mach_header* dyld_image_header_containing_address(const void* addr);

//
// Return the mach header of the process
//
// Exists in Mac OS X 10.16 and later
extern const struct mach_header* _dyld_get_prog_image_header(void);

typedef uint32_t dyld_platform_t;

typedef struct {
    dyld_platform_t platform;
    uint32_t        version;
} dyld_build_version_t;

// Returns the active platform of the process
extern dyld_platform_t dyld_get_active_platform(void);

// Base platforms are platforms that have version numbers (macOS, iOS, watchos, tvOS, bridgeOS)
// All other platforms are mapped to a base platform for version checks

// It is intended that most code in the OS will use the version set constants, which will correctly deal with secret and future
// platforms. For example:

//  if (dyld_program_sdk_at_least(dyld_fall_2018_os_versions)) {
//      New behaviour for programs built against the iOS 12, tvOS 12, watchOS 5, macOS 10.14, or bridgeOS 3 (or newer) SDKs
//  } else {
//      Old behaviour
//  }

// In cases where more precise control is required (such as APIs that were added to varions platforms in different years)
// the os specific values may be used instead. Unlike the version set constants, the platform specific ones will only ever
// return true if the running binary is the platform being testsed, allowing conditions to be built for specific platforms
// and releases that came out at different times. For example:

//  if (dyld_program_sdk_at_least(dyld_platform_version_iOS_12_0)
//      || dyld_program_sdk_at_least(dyld_platform_version_watchOS_6_0)) {
//      New behaviour for programs built against the iOS 12 (fall 2018), watchOS 6 (fall 2019) (or newer) SDKs
//  } else {
//      Old behaviour all other platforms, as well as older iOSes and watchOSes
//  }

extern dyld_platform_t dyld_get_base_platform(dyld_platform_t platform);

// SPI to ask if a platform is a simulation platform
extern bool dyld_is_simulator_platform(dyld_platform_t platform);

// Takes a version and returns if the image was built againt that SDK or newer
// In the case of multi_plaform mach-o's it tests against the active platform
extern bool dyld_sdk_at_least(const struct mach_header* mh, dyld_build_version_t version);

// Takes a version and returns if the image was built with that minos version or newer
// In the case of multi_plaform mach-o's it tests against the active platform
extern bool dyld_minos_at_least(const struct mach_header* mh, dyld_build_version_t version);

// Convenience versions of the previous two functions that run against the the main executable
extern bool dyld_program_sdk_at_least(dyld_build_version_t version);
extern bool dyld_program_minos_at_least(dyld_build_version_t version);

// Function that walks through the load commands and calls the internal block for every version found
// Intended as a fallback for very complex (and rare) version checks, or for tools that need to
// print our everything for diagnostic reasons
extern void dyld_get_image_versions(const struct mach_header* mh, void (^callback)(dyld_platform_t platform, uint32_t sdk_version, uint32_t min_version));

// Convienence constants for dyld version SPIs.

// Because we now have so many different OSes with different versions these version set values are intended to
// to provide a more convenient way to version check. They may be used instead of platform specific version in
// dyld_sdk_at_least(), dyld_minos_at_least(), dyld_program_sdk_at_least(), and dyld_program_minos_at_least().
// Since they are references into a lookup table they MUST NOT be used by any code that does not ship as part of
// the OS, as the values may change and the tables in older OSes may not have the necessary values for back
// deployed binaries. These values are future proof against new platforms being added, and any checks against
// platforms that did not exist at the epoch of a version set will return true since all versions of that platform
// are inherently newer.

//@VERSION_DEFS@

//
// This finds the SDK version a binary was built against.
// Returns zero on error, or if SDK version could not be determined.
//
// Exists in Mac OS X 10.8 and later 
// Exists in iOS 6.0 and later
extern uint32_t dyld_get_sdk_version(const struct mach_header* mh);


//
// This finds the SDK version that the main executable was built against.
// Returns zero on error, or if SDK version could not be determined.
//
// Note on watchOS, this returns the equivalent iOS SDK version number
// (i.e an app built against watchOS 2.0 SDK returne 9.0).  To see the
// platform specific sdk version use dyld_get_program_sdk_watch_os_version().
//
// Exists in Mac OS X 10.8 and later 
// Exists in iOS 6.0 and later
extern uint32_t dyld_get_program_sdk_version(void);

// #if TARGET_OS_WATCH
// // watchOS only.
// // This finds the Watch OS SDK version that the main executable was built against.
// // Exists in Watch OS 2.0 and later
// extern uint32_t dyld_get_program_sdk_watch_os_version(void);


// // watchOS only.
// // This finds the Watch min OS version that the main executable was built to run on.
// // Note: dyld_get_program_min_os_version() returns the iOS equivalent (e.g. 9.0)
// //       whereas this returns the raw watchOS version (e.g. 2.0).
// // Exists in Watch OS 3.0 and later
// extern uint32_t dyld_get_program_min_watch_os_version(void);
// #endif

// #if TARGET_OS_BRIDGE
// // bridgeOS only.
// // This finds the bridgeOS SDK version that the main executable was built against.
// // Exists in bridgeOSOS 2.0 and later
// extern uint32_t dyld_get_program_sdk_bridge_os_version(void);

// // bridgeOS only.
// // This finds the Watch min OS version that the main executable was built to run on.
// // Note: dyld_get_program_min_os_version() returns the iOS equivalent (e.g. 9.0)
// //       whereas this returns the raw bridgeOS version (e.g. 2.0).
// // Exists in bridgeOS 2.0 and later
// extern uint32_t dyld_get_program_min_bridge_os_version(void);
// #endif

//
// This finds the min OS version a binary was built to run on.
// Returns zero on error, or if no min OS recorded in binary.
//
// Exists in Mac OS X 10.8 and later 
// Exists in iOS 6.0 and later
extern uint32_t dyld_get_min_os_version(const struct mach_header* mh);


//
// This finds the min OS version the main executable was built to run on.
// Returns zero on error, or if no min OS recorded in binary.
//
// Exists in Mac OS X 10.8 and later 
// Exists in iOS 6.0 and later
extern uint32_t dyld_get_program_min_os_version(void);




//
// Returns if any OS dylib has overridden its copy in the shared cache
//
// Exists in iPhoneOS 3.1 and later 
// Exists in Mac OS X 10.10 and later
extern bool dyld_shared_cache_some_image_overridden(void);


	
//
// Returns if the process is setuid or is code signed with entitlements.
// NOTE: It is safe to call this prior to malloc being initialized.  This function
// is guaranteed to not call malloc, or depend on its state.
//
// Exists in Mac OS X 10.9 and later
extern bool dyld_process_is_restricted(void);



//
// Returns path used by dyld for standard dyld shared cache file for the current arch.
//
// Exists in Mac OS X 10.11 and later
extern const char* dyld_shared_cache_file_path(void);



//
// Returns if there are any inserted (via DYLD_INSERT_LIBRARIES) or interposing libraries.
//
// Exists in Mac OS X 10.15 and later
extern bool dyld_has_inserted_or_interposing_libraries(void);

//
// Return true if dyld contains a fix for a specific identifier. Intended for staging breaking SPI
// changes
//
// Exists in macOS 10.16, iOS 14, tvOS14, watchOS 7 and later

extern bool _dyld_has_fix_for_radar(const char *rdar);


//
// <rdar://problem/13820686> for OpenGL to tell dyld it is ok to deallocate a memory based image when done.
//
// Exists in Mac OS X 10.9 and later
#define NSLINKMODULE_OPTION_CAN_UNLOAD                  0x20


//
// Update all bindings on specified image. 
// Looks for uses of 'replacement' and changes it to 'replacee'.
// NOTE: this is less safe than using static interposing via DYLD_INSERT_LIBRARIES
// because the running program may have already copy the pointer values to other
// locations that dyld does not know about.
//
struct dyld_interpose_tuple {
	const void* replacement;
	const void* replacee;
};
extern void dyld_dynamic_interpose(const struct mach_header* mh, const struct dyld_interpose_tuple array[], size_t count);


struct dyld_shared_cache_dylib_text_info {
	uint64_t		version;		// current version 2
	// following fields all exist in version 1
	uint64_t		loadAddressUnslid;
	uint64_t		textSegmentSize; 
	uuid_t			dylibUuid;
	const char*		path;			// pointer invalid at end of iterations
	// following fields all exist in version 2
	uint64_t        textSegmentOffset;  // offset from start of cache
};
typedef struct dyld_shared_cache_dylib_text_info dyld_shared_cache_dylib_text_info;


#ifdef __BLOCKS__
//
// Given the UUID of a dyld shared cache file, this function will attempt to locate the cache
// file and if found iterate all images, returning info about each one.  Returns 0 on success.
//
// Exists in Mac OS X 10.11 and later
//           iOS 9.0 and later
extern int dyld_shared_cache_iterate_text(const uuid_t cacheUuid, void (^callback)(const dyld_shared_cache_dylib_text_info* info));


//
// Given the UUID of a dyld shared cache file, and a NULL terminated array of extra directory paths to search,
// this function will scan the standard and extra directories looking for a cache file that matches the UUID
// and if found iterate all images, returning info about each one.  Returns 0 on success.
//
// Exists in Mac OS X 10.12 and later
//           iOS 10.0 and later
extern int dyld_shared_cache_find_iterate_text(const uuid_t cacheUuid, const char* extraSearchDirs[], void (^callback)(const dyld_shared_cache_dylib_text_info* info));
#endif /* __BLOCKS */


//
// Returns if the specified address range is in a dyld owned memory
// that is mapped read-only and will never be unloaded.
//
// Exists in Mac OS X 10.12 and later
//           iOS 10.0 and later
extern bool _dyld_is_memory_immutable(const void* addr, size_t length);


//
// Finds the UUID (from LC_UUID load command) of given image.
// Returns false if LC_UUID is missing or mach_header is malformed.
//
// Exists in Mac OS X 10.12 and later
// Exists in iOS 10.0 and later
extern bool _dyld_get_image_uuid(const struct mach_header* mh, uuid_t uuid);


//
// Gets the UUID of the dyld shared cache in the current process.
// Returns false if there is no dyld shared cache in use by the processes.
//
// Exists in Mac OS X 10.12 and later
// Exists in iOS 10.0 and later
extern bool _dyld_get_shared_cache_uuid(uuid_t uuid);


//
// Returns the start address of the dyld cache in the process and sets length to the size of the cache.
// Returns NULL if the process is not using a dyld shared cache
//
// Exists in Mac OS X 10.13 and later
// Exists in iOS 11.0 and later
extern const void* _dyld_get_shared_cache_range(size_t* length);


//
// Returns if the currently active dyld shared cache is optimized.
// Note: macOS does not use optimized caches and will always return false.
//
// Exists in Mac OS X 10.15 and later
// Exists in iOS 13.0 and later
extern bool _dyld_shared_cache_optimized(void);


//
// Returns if the currently active dyld shared cache was built locally.
//
// Exists in Mac OS X 10.15 and later
// Exists in iOS 13.0 and later
extern bool _dyld_shared_cache_is_locally_built(void);

//
// Returns if the given app needs a closure built.
//
// Exists in Mac OS X 10.15 and later
// Exists in iOS 13.0 and later
extern bool dyld_need_closure(const char* execPath, const char* dataContainerRootDir);


struct dyld_image_uuid_offset {
    uuid_t                      uuid;
	uint64_t                    offsetInImage;
    const struct mach_header*   image;
};

//
// Given an array of addresses, returns info about each address.
// Common usage is the array or addresses was produced by a stack backtrace.
// For each address, returns the where that image was loaded, the offset
// of the address in the image, and the image's uuid.  If a specified
// address is unknown to dyld, all fields will be returned a zeros.
//
// Exists in macOS 10.14 and later
// Exists in iOS 12.0 and later
extern void _dyld_images_for_addresses(unsigned count, const void* addresses[], struct dyld_image_uuid_offset infos[]);


//
// Lets you register a callback which is called each time an image is loaded and provides the mach_header*, path, and
// whether the image may be unloaded later.  During the call to _dyld_register_for_image_loads(), the callback is called
// once for each image currently loaded.
//
// Exists in macOS 10.14 and later
// Exists in iOS 12.0 and later
extern void _dyld_register_for_image_loads(void (*func)(const struct mach_header* mh, const char* path, bool unloadable));




//
// Lets you register a callback which is called for bulk notifications of images loaded. During the call to
// _dyld_register_for_bulk_image_loads(), the callback is called once with all images currently loaded.
// Then later during dlopen() the callback is called once with all newly images.
//
// Exists in macOS 10.15 and later
// Exists in iOS 13.0 and later
extern void _dyld_register_for_bulk_image_loads(void (*func)(unsigned imageCount, const struct mach_header* mhs[], const char* paths[]));


//
// DriverKit main executables do not have an LC_MAIN.  Instead DriverKit.framework's initializer calls
// _dyld_register_driverkit_main() with a function pointer that dyld should call into instead
// of using LC_MAIN.
//
extern void _dyld_register_driverkit_main(void (*mainFunc)(void));


//
// This is similar to _dyld_shared_cache_contains_path(), except that it returns the canonical
// shared cache path for the given path.
//
// Exists in macOS 10.16 and later
// Exists in iOS 14.0 and later
extern const char* _dyld_shared_cache_real_path(const char* path);


//
// Dyld has a number of modes. This function returns the mode for the current process.
// dyld2 is the classic "interpreter" way to run.
// dyld3 runs by compiling down and caching what dyld needs to do into a "closure".
//
// Exists in macOS 10.16 and later
// Exists in iOS 14.0 and later
//
#define DYLD_LAUNCH_MODE_USING_CLOSURE               0x00000001     // if 0, then running in classic dyld2 mode
#define DYLD_LAUNCH_MODE_BUILT_CLOSURE_AT_LAUNCH     0x00000002     // launch was slow, to build closure
#define DYLD_LAUNCH_MODE_CLOSURE_SAVED_TO_FILE       0x00000004     // next launch will be faster
#define DYLD_LAUNCH_MODE_CLOSURE_FROM_OS             0x00000008     // closure built into dyld cache
#define DYLD_LAUNCH_MODE_MINIMAL_CLOSURE             0x00000010     // closure does not contain fix ups
extern uint32_t _dyld_launch_mode(void);


//
// When dyld must terminate a process because of a required dependent dylib
// could not be loaded or a symbol is missing, dyld calls abort_with_reason()
// using one of the following error codes.
//
#define DYLD_EXIT_REASON_DYLIB_MISSING          1
#define DYLD_EXIT_REASON_DYLIB_WRONG_ARCH       2
#define DYLD_EXIT_REASON_DYLIB_WRONG_VERSION    3
#define DYLD_EXIT_REASON_SYMBOL_MISSING         4
#define DYLD_EXIT_REASON_CODE_SIGNATURE         5
#define DYLD_EXIT_REASON_FILE_SYSTEM_SANDBOX    6
#define DYLD_EXIT_REASON_MALFORMED_MACHO        7
#define DYLD_EXIT_REASON_OTHER                  9

//
// When it has more information about the termination, dyld will use abort_with_payload().
// The payload is a dyld_abort_payload structure.  The fixed fields are offsets into the
// payload for the corresponding string.  If the offset is zero, that string is not available.
//
struct dyld_abort_payload {
	uint32_t version;                   // first version is 1
	uint32_t flags;                     // 0x00000001 means dyld terminated at launch, backtrace not useful
	uint32_t targetDylibPathOffset;     // offset in payload of path string to dylib that could not be loaded
	uint32_t clientPathOffset;          // offset in payload of path string to image requesting dylib
	uint32_t symbolOffset;              // offset in payload of symbol string that could not be found
	// string data
};
typedef struct dyld_abort_payload dyld_abort_payload;


// These global variables are implemented in libdyld.dylib
// Old programs that used crt1.o also defined these globals.
// The ones in dyld are not used when an old program is run.
extern int          NXArgc;
extern const char** NXArgv;
extern       char** environ;       // POSIX says this not const, because it pre-dates const
extern const char*  __progname;


// called by libSystem_initializer only
extern void _dyld_initializer(void);

// never called from source code. Used by static linker to implement lazy binding
extern void dyld_stub_binder(void) __asm__("dyld_stub_binder");

// never call from source code.  Used by closure builder to bind missing lazy symbols to
extern void _dyld_missing_symbol_abort(void);

// Called only by objc to see if dyld has uniqued this selector.
// Returns the value if dyld has uniqued it, or nullptr if it has not.
// Note, this function must be called after _dyld_objc_notify_register.
//
// Exists in Mac OS X 10.15 and later
// Exists in iOS 13.0 and later
extern const char* _dyld_get_objc_selector(const char* selName);


// Called only by objc to see if dyld has pre-optimized classes with this name.
// The callback will be called once for each class with the given name where
// isLoaded is true if that class is in a binary which has been previously passed
// to the objc load notifier.
// Note you can set stop to true to stop iterating.
// Also note, this function must be called after _dyld_objc_notify_register.
//
// Exists in Mac OS X 10.15 and later
// Exists in iOS 13.0 and later
extern void _dyld_for_each_objc_class(const char* className,
                                      void (^callback)(void* classPtr, bool isLoaded, bool* stop));


// Called only by objc to see if dyld has pre-optimized protocols with this name.
// The callback will be called once for each protocol with the given name where
// isLoaded is true if that protocol is in a binary which has been previously passed
// to the objc load notifier.
// Note you can set stop to true to stop iterating.
// Also note, this function must be called after _dyld_objc_notify_register.
//
// Exists in Mac OS X 10.15 and later
// Exists in iOS 13.0 and later
extern void _dyld_for_each_objc_protocol(const char* protocolName,
                                         void (^callback)(void* protocolPtr, bool isLoaded, bool* stop));


// called by exit() before it calls cxa_finalize() so that thread_local
// objects are destroyed before global objects.
extern void _tlv_exit(void);

typedef enum {
    dyld_objc_string_kind
} DyldObjCConstantKind;

// CF constants such as CFString's can be moved in to a contiguous range of
// shared cache memory.  This returns true if the given pointer is to an object of
// the given kind.
//
// Exists in Mac OS X 10.16 and later
// Exists in iOS 14.0 and later
extern bool _dyld_is_objc_constant(DyldObjCConstantKind kind, const void* addr);


// temp exports to keep tapi happy, until ASan stops using dyldVersionNumber
extern double      dyldVersionNumber;
extern const char* dyldVersionString;

#if __cplusplus
}
#endif /* __cplusplus */

#endif /* _MACH_O_DYLD_PRIV_H_ */

```

`vendor/apple/ptrace.h`:

```h
/*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*-
 * Copyright (c) 1984, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ptrace.h	8.2 (Berkeley) 1/4/94
 */

#ifndef _SYS_PTRACE_H_
#define _SYS_PTRACE_H_

#include <sys/appleapiopts.h>
#include <sys/cdefs.h>

enum {
	ePtAttachDeprecated __deprecated_enum_msg("PT_ATTACH is deprecated. See PT_ATTACHEXC") = 10
};


#define PT_TRACE_ME     0       /* child declares it's being traced */
#define PT_READ_I       1       /* read word in child's I space */
#define PT_READ_D       2       /* read word in child's D space */
#define PT_READ_U       3       /* read word in child's user structure */
#define PT_WRITE_I      4       /* write word in child's I space */
#define PT_WRITE_D      5       /* write word in child's D space */
#define PT_WRITE_U      6       /* write word in child's user structure */
#define PT_CONTINUE     7       /* continue the child */
#define PT_KILL         8       /* kill the child process */
#define PT_STEP         9       /* single step the child */
#define PT_ATTACH       ePtAttachDeprecated     /* trace some running process */
#define PT_DETACH       11      /* stop tracing a process */
#define PT_SIGEXC       12      /* signals as exceptions for current_proc */
#define PT_THUPDATE     13      /* signal for thread# */
#define PT_ATTACHEXC    14      /* attach to running process with signal exception */

#define PT_FORCEQUOTA   30      /* Enforce quota for root */
#define PT_DENY_ATTACH  31

#define PT_FIRSTMACH    32      /* for machine-specific requests */

__BEGIN_DECLS

#ifndef KERNEL

int     ptrace(int _request, pid_t _pid, caddr_t _addr, int _data);

#endif /* !KERNEL */

__END_DECLS

#endif  /* !_SYS_PTRACE_H_ */

```