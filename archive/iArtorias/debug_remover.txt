Project Path: arc_iArtorias_debug_remover_61xyvxvf

Source Tree:

```txt
arc_iArtorias_debug_remover_61xyvxvf
├── README.md
├── debug_remover
│   ├── debug_remover.vcxproj
│   ├── debug_remover.vcxproj.filters
│   ├── include
│   │   └── retdec
│   │       ├── pelib
│   │       │   ├── BoundImportDirectory.h
│   │       │   ├── CoffSymbolTable.h
│   │       │   ├── ComHeaderDirectory.h
│   │       │   ├── ConfigDirectory.h
│   │       │   ├── DebugDirectory.h
│   │       │   ├── DelayImportDirectory.h
│   │       │   ├── ExportDirectory.h
│   │       │   ├── IatDirectory.h
│   │       │   ├── ImageLoader.h
│   │       │   ├── ImportDirectory.h
│   │       │   ├── InputBuffer.h
│   │       │   ├── OutputBuffer.h
│   │       │   ├── PeFile.h
│   │       │   ├── PeLibAux.h
│   │       │   ├── PeLibInc.h
│   │       │   ├── RelocationsDirectory.h
│   │       │   ├── ResourceDirectory.h
│   │       │   ├── RichHeader.h
│   │       │   ├── SecurityDirectory.h
│   │       │   └── TlsDirectory.h
│   │       └── utils
│   │           ├── container.h
│   │           ├── conversion.h
│   │           ├── filter_iterator.h
│   │           ├── ord_lookup.h
│   │           └── string.h
│   ├── main.cpp
│   └── src
│       ├── pelib
│       │   ├── BoundImportDirectory.cpp
│       │   ├── CoffSymbolTable.cpp
│       │   ├── ComHeaderDirectory.cpp
│       │   ├── ConfigDirectory.cpp
│       │   ├── DebugDirectory.cpp
│       │   ├── ExportDirectory.cpp
│       │   ├── IatDirectory.cpp
│       │   ├── ImageLoader.cpp
│       │   ├── InputBuffer.cpp
│       │   ├── OutputBuffer.cpp
│       │   ├── PeFile.cpp
│       │   ├── PeLibAux.cpp
│       │   ├── RelocationsDirectory.cpp
│       │   ├── ResourceDirectory.cpp
│       │   ├── RichHeader.cpp
│       │   └── SecurityDirectory.cpp
│       └── utils
│           ├── conversion.cpp
│           ├── ord_lookup.cpp
│           └── string.cpp
└── debug_remover.sln

```

`README.md`:

```md
# **Debug Remover**
[![GitHub All Releases](https://img.shields.io/github/downloads/iArtorias/debug_remover/total.svg)](https://github.com/iArtorias/debug_remover/releases)

### A tiny tool to strip the debug information from Windows binary files.

## Usage

```
debug_remover <binary_file>
```

### Before

![debug_remover](https://i.imgur.com/oKCMKxk.png)

### After

![debug_remover](https://i.imgur.com/HuqBtAb.png)

## Stuff used

- **PeLib by RetDec** (https://github.com/iArtorias/pelib-updated | https://github.com/avast/retdec)

## Compilation notes

- **Visual Studio 2022** is recommended to compile this project

```

`debug_remover.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32228.430
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "debug_remover", "debug_remover\debug_remover.vcxproj", "{244459D5-4AB1-4797-9F2D-159C6D8D21FD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{244459D5-4AB1-4797-9F2D-159C6D8D21FD}.Debug|x64.ActiveCfg = Debug|x64
		{244459D5-4AB1-4797-9F2D-159C6D8D21FD}.Debug|x64.Build.0 = Debug|x64
		{244459D5-4AB1-4797-9F2D-159C6D8D21FD}.Debug|x86.ActiveCfg = Debug|Win32
		{244459D5-4AB1-4797-9F2D-159C6D8D21FD}.Debug|x86.Build.0 = Debug|Win32
		{244459D5-4AB1-4797-9F2D-159C6D8D21FD}.Release|x64.ActiveCfg = Release|x64
		{244459D5-4AB1-4797-9F2D-159C6D8D21FD}.Release|x64.Build.0 = Release|x64
		{244459D5-4AB1-4797-9F2D-159C6D8D21FD}.Release|x86.ActiveCfg = Release|Win32
		{244459D5-4AB1-4797-9F2D-159C6D8D21FD}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {60B8EBCE-299C-4384-906B-19025F76E6EA}
	EndGlobalSection
EndGlobal

```

`debug_remover/debug_remover.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{244459d5-4ab1-4797-9f2d-159c6d8d21fd}</ProjectGuid>
    <RootNamespace>debugremover</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>include;src;$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName).x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <IncludePath>include;src;$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName).x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>include;src;$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <IncludePath>include;src;$(IncludePath)</IncludePath>
    <TargetName>$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <DebugInformationFormat>None</DebugInformationFormat>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="src\pelib\BoundImportDirectory.cpp" />
    <ClCompile Include="src\pelib\CoffSymbolTable.cpp" />
    <ClCompile Include="src\pelib\ComHeaderDirectory.cpp" />
    <ClCompile Include="src\pelib\ConfigDirectory.cpp" />
    <ClCompile Include="src\pelib\DebugDirectory.cpp" />
    <ClCompile Include="src\pelib\ExportDirectory.cpp" />
    <ClCompile Include="src\pelib\IatDirectory.cpp" />
    <ClCompile Include="src\pelib\ImageLoader.cpp" />
    <ClCompile Include="src\pelib\InputBuffer.cpp" />
    <ClCompile Include="src\pelib\OutputBuffer.cpp" />
    <ClCompile Include="src\pelib\PeFile.cpp" />
    <ClCompile Include="src\pelib\PeLibAux.cpp" />
    <ClCompile Include="src\pelib\RelocationsDirectory.cpp" />
    <ClCompile Include="src\pelib\ResourceDirectory.cpp" />
    <ClCompile Include="src\pelib\RichHeader.cpp" />
    <ClCompile Include="src\pelib\SecurityDirectory.cpp" />
    <ClCompile Include="src\utils\conversion.cpp" />
    <ClCompile Include="src\utils\ord_lookup.cpp" />
    <ClCompile Include="src\utils\string.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\retdec\pelib\BoundImportDirectory.h" />
    <ClInclude Include="include\retdec\pelib\CoffSymbolTable.h" />
    <ClInclude Include="include\retdec\pelib\ComHeaderDirectory.h" />
    <ClInclude Include="include\retdec\pelib\ConfigDirectory.h" />
    <ClInclude Include="include\retdec\pelib\DebugDirectory.h" />
    <ClInclude Include="include\retdec\pelib\DelayImportDirectory.h" />
    <ClInclude Include="include\retdec\pelib\ExportDirectory.h" />
    <ClInclude Include="include\retdec\pelib\IatDirectory.h" />
    <ClInclude Include="include\retdec\pelib\ImageLoader.h" />
    <ClInclude Include="include\retdec\pelib\ImportDirectory.h" />
    <ClInclude Include="include\retdec\pelib\InputBuffer.h" />
    <ClInclude Include="include\retdec\pelib\OutputBuffer.h" />
    <ClInclude Include="include\retdec\pelib\PeFile.h" />
    <ClInclude Include="include\retdec\pelib\PeLibAux.h" />
    <ClInclude Include="include\retdec\pelib\PeLibInc.h" />
    <ClInclude Include="include\retdec\pelib\RelocationsDirectory.h" />
    <ClInclude Include="include\retdec\pelib\ResourceDirectory.h" />
    <ClInclude Include="include\retdec\pelib\RichHeader.h" />
    <ClInclude Include="include\retdec\pelib\SecurityDirectory.h" />
    <ClInclude Include="include\retdec\pelib\TlsDirectory.h" />
    <ClInclude Include="include\retdec\utils\container.h" />
    <ClInclude Include="include\retdec\utils\conversion.h" />
    <ClInclude Include="include\retdec\utils\filter_iterator.h" />
    <ClInclude Include="include\retdec\utils\ord_lookup.h" />
    <ClInclude Include="include\retdec\utils\string.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`debug_remover/debug_remover.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\deps">
      <UniqueIdentifier>{4f9d2f9a-e652-4c65-a533-448e7466d0af}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\deps">
      <UniqueIdentifier>{8c6c11ea-b6f1-423a-b915-0c6b5f739744}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\deps\pelib">
      <UniqueIdentifier>{a0a1055f-f63e-4f55-b167-7a181b7f4531}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\deps\pelib">
      <UniqueIdentifier>{42db9302-fd4a-4a84-8639-fc0702212342}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\deps\pelib\utils">
      <UniqueIdentifier>{cc3cf644-2a80-48f1-9066-fa9a1abef6e7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\deps\pelib\utils">
      <UniqueIdentifier>{a77b4c9b-058c-4c2c-9aba-bbe142d8a5c4}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\BoundImportDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\CoffSymbolTable.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\ComHeaderDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\ConfigDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\DebugDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\ExportDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\IatDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\ImageLoader.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\InputBuffer.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\OutputBuffer.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\PeFile.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\PeLibAux.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\RelocationsDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\ResourceDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\RichHeader.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\pelib\SecurityDirectory.cpp">
      <Filter>Source Files\deps\pelib</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\conversion.cpp">
      <Filter>Source Files\deps\pelib\utils</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\ord_lookup.cpp">
      <Filter>Source Files\deps\pelib\utils</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\string.cpp">
      <Filter>Source Files\deps\pelib\utils</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\retdec\pelib\BoundImportDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\CoffSymbolTable.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\ComHeaderDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\ConfigDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\DebugDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\DelayImportDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\ExportDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\IatDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\ImageLoader.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\ImportDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\InputBuffer.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\OutputBuffer.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\PeFile.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\PeLibAux.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\PeLibInc.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\RelocationsDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\ResourceDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\RichHeader.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\SecurityDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\pelib\TlsDirectory.h">
      <Filter>Header Files\deps\pelib</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\utils\container.h">
      <Filter>Header Files\deps\pelib\utils</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\utils\conversion.h">
      <Filter>Header Files\deps\pelib\utils</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\utils\filter_iterator.h">
      <Filter>Header Files\deps\pelib\utils</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\utils\ord_lookup.h">
      <Filter>Header Files\deps\pelib\utils</Filter>
    </ClInclude>
    <ClInclude Include="include\retdec\utils\string.h">
      <Filter>Header Files\deps\pelib\utils</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`debug_remover/include/retdec/pelib/BoundImportDirectory.h`:

```h
/*
* BoundImportDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_BOUNDIMPORTDIRECTORY_H
#define RETDEC_PELIB_BOUNDIMPORTDIRECTORY_H

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/PeLibAux.h"
#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	/// Class that handles the BoundImport directory.
	/**
	* This class can read and modify the BoundImport directory table of a PE file.
	**/
	class BoundImportDirectory
	{
		protected:
		  std::vector<PELIB_IMAGE_BOUND_DIRECTORY> m_vIbd; ///< Stores the individual BoundImport fields.

		  int read(InputBuffer& inpBuffer, unsigned char* data, unsigned int dwSize);
		  unsigned int totalModules() const;
		public:
		  virtual ~BoundImportDirectory() = default;

		  /// Reads the BoundImport directory table from a PE file.
		  int read(ImageLoader & imageLoader); // EXPORT
		  /// Adds another bound import.
		  int addBoundImport(const std::string& strModuleName, std::uint32_t dwTds, std::uint16_t dwOmn, std::uint16_t wWfr); // EXPORT
		  /// Identifies a module through it's name.
		  int getModuleIndex(const std::string& strModuleName) const; // EXPORT
		  /// Returns the number of files in the BoundImport directory.
		  unsigned int calcNumberOfModules() const; // EXPORT
		  /// Reads the BoundImport directory table from a PE file.
		  int read(unsigned char* pcBuffer, unsigned int uiSize); // EXPORT
		  /// Rebuilds the BoundImport directory.
		  void rebuild(std::vector<std::uint8_t>& vBuffer, bool fMakeValid = true) const; // EXPORT
		  /// Empties the BoundImport directory.
		  void clear(); // EXPORT
		  /// Removes a bound import.
		  void removeBoundImport(const std::string& strModuleName); // EXPORT
		  /// Returns the size of the BoundImport directory.
		  unsigned int size() const; // EXPORT
		  /// Writes the current bound import directory to a file.
		  int write(const std::string& strFilename, std::uint32_t dwOffset, bool fMakeValid = true) const; // EXPORT

		  /// Retrieves the TimeDateStamp value of a bound import.
		  std::uint32_t getTimeDateStamp(std::uint32_t dwBidnr) const; // EXPORT
		  /// Retrieves the OffsetModuleName value of a bound import.
		  std::uint16_t getOffsetModuleName(std::uint32_t dwBidnr) const; // EXPORT
		  /// Retrieves the NumberOfModuleForwarderRefs value of a bound import.
		  std::uint16_t getNumberOfModuleForwarderRefs(std::uint32_t dwBidnr) const; // EXPORT
		  /// Retrieves the ModuleName value of a bound import.
		  std::string getModuleName(std::uint32_t dwBidnr) const; // EXPORT

		  /// Updates the TimeDateStamp value of a bound import.
		  void setTimeDateStamp(std::uint32_t dwBidnr, std::uint32_t dwTds); // EXPORT
		  /// Updates the OffsetModuleName value of a bound import.
		  void setOffsetModuleName(std::uint32_t dwBidnr, std::uint16_t wOmn); // EXPORT
		  /// Updates the NumberOfModuleForwarderRefs value of a bound import.
		  void setNumberOfModuleForwarderRefs(std::uint32_t dwBidnr, std::uint16_t wMfr); // EXPORT
		  /// Updates the ModuleName value of a bound import.
		  void setModuleName(std::uint32_t dwBidnr, const std::string& strModuleName); // EXPORT

		  std::uint32_t getTimeDateStamp(std::uint32_t dwBidnr, std::uint32_t forwardedModule) const; // EXPORT _module
		  std::uint16_t getOffsetModuleName(std::uint32_t dwBidnr, std::uint32_t forwardedModule) const; // EXPORT _module
		  std::uint16_t getNumberOfModuleForwarderRefs(std::uint32_t dwBidnr, std::uint32_t forwardedModule) const; // EXPORT _module
		  std::string getModuleName(std::uint32_t dwBidnr, std::uint32_t forwardedModule) const; // EXPORT _module

		  void setTimeDateStamp(std::uint32_t dwBidnr, std::uint32_t forwardedModule, std::uint32_t dwTds); // EXPORT _module
		  void setOffsetModuleName(std::uint32_t dwBidnr, std::uint32_t forwardedModule, std::uint16_t wOmn); // EXPORT _module
		  void setNumberOfModuleForwarderRefs(std::uint32_t dwBidnr, std::uint32_t forwardedModule, std::uint16_t wMfr); // EXPORT _module
		  void setModuleName(std::uint32_t dwBidnr, std::uint32_t forwardedModule, const std::string& strModuleName); // EXPORT _module

		  std::uint16_t calcNumberOfModuleForwarderRefs(std::uint32_t dwBidnr) const; // EXPORT
		  void addForwardedModule(std::uint32_t dwBidnr, const std::string& name, std::uint32_t timeStamp = 0, std::uint16_t offsetModuleName = 0, std::uint16_t forwardedModules = 0); // EXPORT
		  void removeForwardedModule(std::uint32_t dwBidnr, std::uint16_t forwardedModule); // EXPORT
	};
}

#endif

```

`debug_remover/include/retdec/pelib/CoffSymbolTable.h`:

```h
/**
 * @file CoffSymbolTable.h
 * @brief Class for COFF symbol table.
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#ifndef RETDEC_PELIB_COFFSYMBOLTABLE_H
#define RETDEC_PELIB_COFFSYMBOLTABLE_H

#include "retdec/pelib/PeLibInc.h"

namespace PeLib
{
	/**
	 * This class handless the COFF symbol table.
	 */
	class CoffSymbolTable
	{
		private:
			std::size_t stringTableSize;
			std::uint32_t numberOfStoredSymbols;
			ByteBuffer stringTable;
			ByteBuffer symbolTableDump;
			std::vector<PELIB_IMAGE_COFF_SYMBOL> symbolTable;
			LoaderError m_ldrError;

			void read(InputBuffer& inputbuffer, unsigned int uiSize);
		public:
			CoffSymbolTable();
			~CoffSymbolTable();

			LoaderError loaderError() const;
			void setLoaderError(LoaderError ldrError);

			int read(ByteBuffer & fileData, std::size_t uiOffset, std::size_t uiSize);
			std::size_t getSizeOfStringTable() const;
			std::size_t getNumberOfStoredSymbols() const;
			std::uint32_t getSymbolIndex(std::size_t ulSymbol) const;
			const std::string & getSymbolName(std::size_t ulSymbol) const;
			std::uint32_t getSymbolValue(std::size_t ulSymbol) const;
			std::uint16_t getSymbolSectionNumber(std::size_t ulSymbol) const;
			std::uint8_t getSymbolTypeComplex(std::size_t ulSymbol) const;
			std::uint8_t getSymbolTypeSimple(std::size_t ulSymbol) const;
			std::uint8_t getSymbolStorageClass(std::size_t ulSymbol) const;
			std::uint8_t getSymbolNumberOfAuxSymbols(std::size_t ulSymbol) const;
	};
}

#endif

```

`debug_remover/include/retdec/pelib/ComHeaderDirectory.h`:

```h
/*
* ComHeaderDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_COMHEADERDIRECTORY_H
#define RETDEC_PELIB_COMHEADERDIRECTORY_H

#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	/// Class that handles the COM+ descriptor directory.
	/**
	* This class handles the COM+ Descriptor directory which was added to PE files
	* which work with the .NET runtime modules.
	**/
	class ComHeaderDirectory
	{
		protected:
		  PELIB_IMAGE_COR20_HEADER m_ichComHeader; ///< The COM+ descriptor.

		public:
		  virtual ~ComHeaderDirectory() = default;

		  /// Read a file's COM+ runtime descriptor directory.
		  int read(ImageLoader & imageLoader); // EXPORT
		  /// Rebuild the COM+ descriptor.
		  void rebuild(std::vector<std::uint8_t>& vBuffer) const; // EXPORT
		  /// Returns the size of the current COM+ descriptor.
		  unsigned int size() const; // EXPORT
		  /// Writes the current COM+ descriptor directory to a file.
		  int write(const std::string& strFilename, unsigned int dwOffset) const; // EXPORT

		  /// Get the COM+ descriptor's SizeOfHeader (cb) value.
		  std::uint32_t getSizeOfHeader() const; // EXPORT
		  /// Get the COM+ descriptor's MajorRuntimeVersion value.
		  std::uint16_t getMajorRuntimeVersion() const; // EXPORT
		  /// Get the COM+ descriptor's MinorRuntimeVersion value.
		  std::uint16_t getMinorRuntimeVersion() const; // EXPORT
		  /// Get the COM+ descriptor's MetaData (Virtual Address) value.
		  std::uint32_t getMetaDataVa() const; // EXPORT
		  /// Get the COM+ descriptor's MetaData (Size) value.
		  std::uint32_t getMetaDataSize() const; // EXPORT
		  /// Get the COM+ descriptor's Flags value.
		  std::uint32_t getFlags() const; // EXPORT
		  /// Get the COM+ descriptor's EntryPointToken value.
		  std::uint32_t getEntryPointToken() const; // EXPORT
		  /// Get the COM+ descriptor's Resources (Virtual Address) value.
		  std::uint32_t getResourcesVa() const; // EXPORT
		  /// Get the COM+ descriptor's Resources (Size) value.
		  std::uint32_t getResourcesSize() const; // EXPORT
		  /// Get the COM+ descriptor's StrongNameSignature (Virtual Address) value.
		  std::uint32_t getStrongNameSignatureVa() const; // EXPORT
		  /// Get the COM+ descriptor's StrongNameSignature (Size) value.
		  std::uint32_t getStrongNameSignatureSize() const; // EXPORT
		  /// Get the COM+ descriptor's CodeManagerTable (Virtual Address) value.
		  std::uint32_t getCodeManagerTableVa() const; // EXPORT
		  /// Get the COM+ descriptor's CodeManagerTable (Size) value.
		  std::uint32_t getCodeManagerTableSize() const; // EXPORT
		  /// Get the COM+ descriptor's VTableFixup (Virtual Address) value.
		  std::uint32_t getVTableFixupsVa() const; // EXPORT
		  /// Get the COM+ descriptor's VTableFixup (Size) value.
		  std::uint32_t getVTableFixupsSize() const; // EXPORT
		  /// Get the COM+ descriptor's ExportAddressTable (Virtual Address) value.
		  std::uint32_t getExportAddressTableJumpsVa() const; // EXPORT
		  /// Get the COM+ descriptor's ExportAddressTable (Size) value.
		  std::uint32_t getExportAddressTableJumpsSize() const; // EXPORT
		  /// Get the COM+ descriptor's ManagedNativeHeader (Virtual Address) value.
		  std::uint32_t getManagedNativeHeaderVa() const; // EXPORT
		  /// Get the COM+ descriptor's ManagedNativeHeader (Size) value.
		  std::uint32_t getManagedNativeHeaderSize() const; // EXPORT

		  /// Change the COM+ descriptor's SizeOfHeader (cb) value.
		  void setSizeOfHeader(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's MajorRuntimeVersion value.
		  void setMajorRuntimeVersion(std::uint16_t wValue); // EXPORT
		  /// Change the COM+ descriptor's MinorRuntimeVersion value.
		  void setMinorRuntimeVersion(std::uint16_t wValue); // EXPORT
		  /// Change the COM+ descriptor's MetaData (VirtualAddress) value.
		  void setMetaDataVa(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's MetaData (Size) value.
		  void setMetaDataSize(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's Flags value.
		  void setFlags(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's EntryPointToken value.
		  void setEntryPointToken(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's Resources (VirtualAddress) value.
		  void setResourcesVa(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's Resources (Size) value.
		  void setResourcesSize(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's StrongNameSignatureVa (VirtualAddress) value.
		  void setStrongNameSignatureVa(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's StrongNameSignatureVa (Size) value.
		  void setStrongNameSignagureSize(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's CodeManagerTable (VirtualAddress) value.
		  void setCodeManagerTableVa(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's CodeManagerTable (Size) value.
		  void setCodeManagerTableSize(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's VTableFixups (VirtualAddress) value.
		  void setVTableFixupsVa(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's VTableFixups (Size) value.
		  void setVTableFixupsSize(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's ExportAddressTableJumps (VirtualAddress) value.
		  void setExportAddressTableJumpsVa(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's ExportAddressTableJumps (Size) value.
		  void setExportAddressTableJumpsSize(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's ManagedNativeHeader (VirtualAddress) value.
		  void setManagedNativeHeaderVa(std::uint32_t dwValue); // EXPORT
		  /// Change the COM+ descriptor's ManagedNativeHeader (Size) value.
		  void setManagedNativeHeaderSize(std::uint32_t dwValue); // EXPORT
	};
}
#endif

```

`debug_remover/include/retdec/pelib/ConfigDirectory.h`:

```h
/**
 * @file include/retdec/pelib/ConfigDirectory.h
 * @brief Class representing Load Config Directory of PE file
 * @copyright (c) 2021 Avast Software, licensed under the MIT license
 */

#ifndef RETDEC_PELIB_CONFIGDIRECTORY_H
#define RETDEC_PELIB_CONFIGDIRECTORY_H

#include "retdec/pelib/ImageLoader.h"

namespace PeLib {
/// Class that handles the Debug directory.
class ConfigDirectory
{
protected:
	PELIB_IMAGE_LOAD_CONFIG_DIRECTORY32 dir32 = { 0 };
	PELIB_IMAGE_LOAD_CONFIG_DIRECTORY64 dir64 = { 0 };
	bool is64bit = { 0 };

public:
	virtual ~ConfigDirectory() = default;

	int read(ImageLoader& imageLoader);

	std::uint32_t getTimeDateStamp() const;
};
} // namespace PeLib

#endif

```

`debug_remover/include/retdec/pelib/DebugDirectory.h`:

```h
/*
* DebugDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_DEBUGDIRECTORY_H
#define RETDEC_PELIB_DEBUGDIRECTORY_H

#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	/// Class that handles the Debug directory.
	class DebugDirectory
	{
		protected:
		  /// Stores the various DebugDirectory structures.
		  std::vector<PELIB_IMG_DEBUG_DIRECTORY> m_vDebugInfo;
		  /// Stores RVAs which are occupied by this debug directory.
		  std::vector<std::pair<unsigned int, unsigned int>> m_occupiedAddresses;

		  void read(ImageLoader & imageLoader, std::vector<PELIB_IMG_DEBUG_DIRECTORY> & debugInfo, std::uint32_t rva, std::uint32_t size);

		public:
		  virtual ~DebugDirectory() = default;

		  /// Reads the Debug directory from a file.
		  int read(std::istream& inStream, ImageLoader & imageLoader);
		  ///
		  void clear(); // EXPORT
		  /// Rebuilds the current Debug directory.
		  void rebuild(std::vector<std::uint8_t>& obBuffer) const; // EXPORT
		  /// Returns the size the current Debug directory needs after rebuilding.
		  unsigned int size() const;
		  /// Writes the current Debug directory back to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset) const; // EXPORT

		  /// Returns the number of DebugDirectory image structures in the current DebugDirectory.
		  unsigned int calcNumberOfEntries() const; // EXPORT

		  /// Adds a new debug structure.
		  void addEntry(); // EXPORT
		  /// Removes a debug structure.
		  void removeEntry(std::size_t uiIndex); // EXPORT

		  /// Returns the Characteristics value of a debug structure.
		  std::uint32_t getCharacteristics(std::size_t uiIndex) const; // EXPORT
		  /// Returns the TimeDateStamp value of a debug structure.
		  std::uint32_t getTimeDateStamp(std::size_t uiIndex) const; // EXPORT
		  /// Returns the MajorVersion value of a debug structure.
		  std::uint16_t getMajorVersion(std::size_t uiIndex) const; // EXPORT
		  /// Returns the MinorVersion value of a debug structure.
		  std::uint16_t getMinorVersion(std::size_t uiIndex) const; // EXPORT
		  /// Returns the Type value of a debug structure.
		  std::uint32_t getType(std::size_t uiIndex) const; // EXPORT
		  /// Returns the SizeOfData value of a debug structure.
		  std::uint32_t getSizeOfData(std::size_t uiIndex) const; // EXPORT
		  /// Returns the AddressOfRawData value of a debug structure.
		  std::uint32_t getAddressOfRawData(std::size_t uiIndex) const; // EXPORT
		  /// Returns the PointerToRawData value of a debug structure.
		  std::uint32_t getPointerToRawData(std::size_t uiIndex) const; // EXPORT
		  std::vector<std::uint8_t> getData(std::size_t index) const; // EXPORT

		  /// Sets the Characteristics value of a debug structure.
		  void setCharacteristics(std::size_t uiIndex, std::uint32_t dwValue); // EXPORT
		  /// Sets the TimeDateStamp value of a debug structure.
		  void setTimeDateStamp(std::size_t uiIndex, std::uint32_t dwValue); // EXPORT
		  /// Sets the MajorVersion value of a debug structure.
		  void setMajorVersion(std::size_t uiIndex, std::uint16_t wValue); // EXPORT
		  /// Sets the MinorVersion value of a debug structure.
		  void setMinorVersion(std::size_t uiIndex, std::uint16_t wValue); // EXPORT
		  /// Sets the Type value of a debug structure.
		  void setType(std::size_t uiIndex, std::uint32_t dwValue); // EXPORT
		  /// Sets the SizeOfData value of a debug structure.
		  void setSizeOfData(std::size_t uiIndex, std::uint32_t dwValue); // EXPORT
		  /// Sets the AddressOfRawData value of a debug structure.
		  void setAddressOfRawData(std::size_t uiIndex, std::uint32_t dwValue); // EXPORT
		  /// Sets the PointerToRawData value of a debug structure.
		  void setPointerToRawData(std::size_t uiIndex, std::uint32_t dwValue); // EXPORT
		  void setData(std::size_t index, const std::vector<std::uint8_t>& data); // EXPORT

		  const std::vector<std::pair<unsigned int, unsigned int>>& getOccupiedAddresses() const;
	};
}
#endif

```

`debug_remover/include/retdec/pelib/DelayImportDirectory.h`:

```h
/**
 * @file DelayImportDirectory.h
 * @brief Class for delay import directory.
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#ifndef RETDEC_PELIB_DELAY_IMPORT_DIRECTORY_H
#define RETDEC_PELIB_DELAY_IMPORT_DIRECTORY_H

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	/**
	 * This class handles delay import directory.
	 */

	class DelayImportDirectory
	{
		typedef typename std::vector<PELIB_IMAGE_DELAY_IMPORT_DIRECTORY_RECORD >::const_iterator DelayImportDirectoryIterator;

		private:
			std::vector<PELIB_IMAGE_DELAY_IMPORT_DIRECTORY_RECORD> records;

			void init()
			{
				records.clear();
			}

		public:
			DelayImportDirectory()
			{
				init();
			}

			~DelayImportDirectory()
			{

			}

			// Delay-import descriptors made by MS Visual C++ 6.0 have old format
			// of delay import directory, where all entries are VAs (as opposite to RVAs from newer MS compilers).
			// We convert the delay-import directory entries to RVAs by checking the lowest bit in the delay-import descriptor's Attributes value
			std::uint64_t normalizeDelayImportValue(std::uint64_t imageBase, std::uint64_t virtualAddress)
			{
				// Ignore zero items
				if (virtualAddress != 0)
				{
					// Sample: 0fc4cb0620f95bdd624f2c78eea4d2b59594244c6671cf249526adf2f2cb71ec
					// Contains artificially created delay import directory with incorrect values:
					//
					//  Attributes                      0x00000000 <-- Old MS delay import record, contains VAs
					//  NameRva                         0x004010e6
					//  ModuleHandleRva                 0x00000000
					//  DelayImportAddressTableRva      0x00001140 <-- WRONG! This is an RVA
					//  DelayImportNameTableRva         0x004010c0
					//  BoundDelayImportTableRva        0x00000000
					//  ...

					if (virtualAddress > imageBase)
					{
						virtualAddress = virtualAddress - imageBase;
					}
				}

				return virtualAddress;
			}

			void normalize32BitDelayImport(PELIB_IMAGE_DELAY_LOAD_DESCRIPTOR & rec, std::uint64_t imageBase)
			{
				rec.NameRva                    = (std::uint32_t)normalizeDelayImportValue(imageBase, rec.NameRva);
				rec.ModuleHandleRva            = (std::uint32_t)normalizeDelayImportValue(imageBase, rec.ModuleHandleRva);
				rec.DelayImportAddressTableRva = (std::uint32_t)normalizeDelayImportValue(imageBase, rec.DelayImportAddressTableRva);
				rec.DelayImportNameTableRva    = (std::uint32_t)normalizeDelayImportValue(imageBase, rec.DelayImportNameTableRva);
				rec.BoundDelayImportTableRva   = (std::uint32_t)normalizeDelayImportValue(imageBase, rec.BoundDelayImportTableRva);
				rec.UnloadDelayImportTableRva  = (std::uint32_t)normalizeDelayImportValue(imageBase, rec.UnloadDelayImportTableRva);
			}

			bool isTerminationEntry(PELIB_IMAGE_DELAY_LOAD_DESCRIPTOR & importDescriptor)
			{
				return (importDescriptor.Attributes == 0 &&
						importDescriptor.NameRva == 0 &&
						importDescriptor.ModuleHandleRva == 0 &&
						importDescriptor.DelayImportAddressTableRva == 0 &&
						importDescriptor.DelayImportNameTableRva == 0 &&
						importDescriptor.BoundDelayImportTableRva == 0 &&
						importDescriptor.UnloadDelayImportTableRva == 0 &&
						importDescriptor.TimeStamp == 0);
			}

			int read(ImageLoader & imageLoader)
			{
				std::uint32_t rva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
				std::uint32_t size = imageLoader.getDataDirSize(PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);
				std::uint32_t sizeOfImage = imageLoader.getSizeOfImage();
				std::uint32_t pointerSize = imageLoader.getPointerSize();
				std::uint64_t imageBase   = imageLoader.getImageBase();
				std::uint64_t ordinalMask = imageLoader.getOrdinalMask();

				if(rva >= sizeOfImage)
					return ERROR_INVALID_FILE;
				init();

				// Keep loading until we encounter an entry filled with zeros
				for(std::uint32_t i = 0;; i += sizeof(PELIB_IMAGE_DELAY_LOAD_DESCRIPTOR))
				{
					PELIB_IMAGE_DELAY_IMPORT_DIRECTORY_RECORD rec;

					// Read the n-th import directory entry
					if((rva + i) >= sizeOfImage)
						break;
					if(!imageLoader.readImage(&rec.delayedImport, rva + i, sizeof(PELIB_IMAGE_DELAY_LOAD_DESCRIPTOR)))
						break;

					// Valid delayed import entry starts either with 0 or 0x01.
					// We strict require one of the valid values here
					if(rec.delayedImport.Attributes > PELIB_DELAY_ATTRIBUTE_V2)
						break;

					// Stop on blatantly invalid entries
					if(rec.delayedImport.NameRva < sizeof(PELIB_IMAGE_DOS_HEADER) ||
					   rec.delayedImport.DelayImportNameTableRva < sizeof(PELIB_IMAGE_DOS_HEADER))
						break;

					// Check for the termination entry
					if(isTerminationEntry(rec.delayedImport))
						break;

					// Convert older (MS Visual C++ 6.0) delay-import descriptor to newer one.
					// These delay-import descriptors are distinguishable by lowest bit in rec.Attributes to be zero.
					// Sample: 2775d97f8bdb3311ace960a42eee35dbec84b9d71a6abbacb26c14e83f5897e4
					if(imageLoader.getImageBitability() == 32 && (rec.delayedImport.Attributes & PELIB_DELAY_ATTRIBUTE_V2) == 0)
						normalize32BitDelayImport(rec.delayedImport, (std::uint32_t)imageBase);

					// Stop on blatantly invalid delay import entries (old PELIB behavior)
					if(rec.delayedImport.DelayImportNameTableRva >= sizeOfImage || rec.delayedImport.DelayImportAddressTableRva >= sizeOfImage)
						return ERROR_INVALID_FILE;

					// Get name of library
					imageLoader.readString(rec.Name, rec.delayedImport.NameRva, IMPORT_LIBRARY_MAX_LENGTH);

					//
					//  LOADING NAME ADDRESSES/NAME ORDINALS
					//

					std::vector<uint64_t> nameAddresses;
					std::uint32_t rva2 = rec.delayedImport.DelayImportNameTableRva;

					for(;;)
					{
						std::uint64_t nameAddress;

						// Read single name address. Also stop processing if the RVA gets out of image
						if(imageLoader.readPointer(rva2, nameAddress) != pointerSize)
							return ERROR_INVALID_FILE;
						rva2 += pointerSize;

						// Value of zero means that this is the end of the bound import name table
						if(nameAddress == 0)
							break;
						nameAddresses.push_back(nameAddress);
					}

					//
					//  LOADING FUNCTION POINTERS
					//

					std::vector<uint64_t> funcAddresses;
					rva2 = rec.delayedImport.DelayImportAddressTableRva;

					// Read all (VAs) of import names
					for (std::size_t i = 0; i < nameAddresses.size(); i++)
					{
						std::uint64_t funcAddress;

						// Read single name address. Also stop processing if the RVA gets out of image
						if(imageLoader.readPointer(rva2, funcAddress) != pointerSize)
							return ERROR_INVALID_FILE;
						rva2 += pointerSize;

						// Value of zero means that this is the end of the bound import name table
						if(funcAddress == 0)
							break;
						funcAddresses.push_back(funcAddress);
					}

					//
					//  MERGE BOTH TOGETHER
					//

					std::size_t numberOfFunctions = std::min(nameAddresses.size(), funcAddresses.size());
					for (std::size_t i = 0; i < numberOfFunctions; i++)
					{
						PELIB_DELAY_IMPORT function;
						std::uint64_t nameAddress = nameAddresses[i];
						std::uint64_t funcAddress = funcAddresses[i];

						// Check name address. It could be ordinal, VA or RVA
						if (!(nameAddress & ordinalMask))
						{
							// Convert name address to RVA, if needed
							if((rec.delayedImport.Attributes & PELIB_DELAY_ATTRIBUTE_V2) == 0)
								nameAddress = normalizeDelayImportValue(imageBase, nameAddress);

							// Read the function hint
							if(imageLoader.readImage(&function.hint, nameAddress, sizeof(function.hint)) != sizeof(function.hint))
								break;

							// Read the function name
							imageLoader.readString(function.fname, nameAddress + sizeof(function.hint), IMPORT_SYMBOL_MAX_LENGTH);
						}
						else
						{
							function.hint = (std::uint16_t)(nameAddress & 0xFFFF);
						}

						// Convert function address to RVA, if needed
						if(imageBase <= funcAddress && funcAddress < imageBase + sizeOfImage)
							funcAddress -= imageBase;
						function.address = funcAddress;

						// Insert the function to the list
						rec.addFunction(function);
					}

					records.push_back(rec);
				}
				return ERROR_NONE;
			}

			std::size_t getNumberOfFiles() const
			{
				return records.size();
			}

			const PELIB_IMAGE_DELAY_IMPORT_DIRECTORY_RECORD *getFile(std::size_t index) const
			{
				return index < getNumberOfFiles() ? &records[index] : nullptr;
			}

			DelayImportDirectoryIterator begin() const
			{
				return records.begin();
			}

			DelayImportDirectoryIterator end() const
			{
				return records.end();
			}
	};
}

#endif

```

`debug_remover/include/retdec/pelib/ExportDirectory.h`:

```h
/*
* ExportDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_EXPORTDIRECTORY_H
#define RETDEC_PELIB_EXPORTDIRECTORY_H

#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	/// Class that handles the export directory.
	/**
	* This class handles the export directory.
	* \todo getNameString
	**/
	class ExportDirectory
	{
		protected:
		  /// Used to store all necessary information about a file's exported functions.
		  PELIB_IMAGE_EXP_DIRECTORY m_ied;
		  /// Stores RVAs which are occupied by this export directory.
		  std::vector<std::pair<unsigned int, unsigned int>> m_occupiedAddresses;

		  void addOccupiedAddress(const std::string & str, std::uint32_t rva);

		public:
		  virtual ~ExportDirectory() = default;

		  /// Load the export directory from the image loader
		  int read(ImageLoader & imageLoader);

		  /// Add another function to be exported.
		  void addFunction(const std::string& strFuncname, std::uint32_t dwFuncAddr); // EXPORT
		  unsigned int calcNumberOfFunctions() const; // EXPORT
		  void clear(); // EXPORT
		  /// Identifies a function through it's name.
		  int getFunctionIndex(const std::string& strFunctionName) const; // EXPORT
		  /// Rebuild the current export directory.
		  void rebuild(std::vector<std::uint8_t>& vBuffer, std::uint32_t dwRva) const; // EXPORT
		  void removeFunction(unsigned int index); // EXPORT
		  /// Returns the size of the current export directory.
		  unsigned int size() const; // EXPORT
		  /// Writes the current export directory to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva) const; // EXPORT

		  /// Changes the name of the file (according to the export directory).
		  void setNameString(const std::string& strFilename); // EXPORT
		  std::string getNameString() const; // EXPORT

		  /// Get the name of an exported function.
		  std::string getFunctionName(std::size_t index) const; // EXPORT
		  /// Get the ordinal of an exported function.
		  std::uint16_t getFunctionOrdinal(std::size_t index) const; // EXPORT
		  /// Get the address of the name of an exported function.
		  std::uint32_t getAddressOfName(std::size_t index) const; // EXPORT
		  /// Get the address of an exported function.
		  std::uint32_t getAddressOfFunction(std::size_t index) const; // EXPORT

		  /// Change the name of an exported function.
		  void setFunctionName(std::size_t index, const std::string& strName); // EXPORT
		  /// Change the ordinal of an exported function.
		  void setFunctionOrdinal(std::size_t index, std::uint16_t wValue); // EXPORT
		  /// Change the address of the name of an exported function.
		  void setAddressOfName(std::size_t index, std::uint32_t dwValue); // EXPORT
		  /// Change the address of an exported function.
		  void setAddressOfFunction(std::size_t index, std::uint32_t dwValue); // EXPORT

		  /*
		  std::uint16_t getFunctionOrdinal(std::string strFuncname) const;
		  std::uint32_t getAddressOfName(std::string strFuncname) const;
		  std::uint32_t getAddressOfFunction(std::string strFuncname) const;

		  void setFunctionOrdinal(std::string strFuncname, std::uint16_t wValue);
		  void setAddressOfName(std::string strFuncname, std::uint32_t dwValue);
		  void setAddressOfFunction(std::string strFuncname, std::uint32_t dwValue);
		  */

		  /// Return the Base value of the export directory.
		  std::uint32_t getBase() const; // EXPORT
		  /// Return the Characteristics value of the export directory.
		  std::uint32_t getCharacteristics() const; // EXPORT
		  /// Return the TimeDateStamp value of the export directory.
		  std::uint32_t getTimeDateStamp() const; // EXPORT
		  /// Return the MajorVersion value of the export directory.
		  std::uint16_t getMajorVersion() const; // EXPORT
		  /// Return the MinorVersion value of the export directory.
		  std::uint16_t getMinorVersion() const; // EXPORT
		  /// Return the Name value of the export directory.
		  std::uint32_t getName() const; // EXPORT
		  /// Return the NumberOfFunctions value of the export directory.
		  std::uint32_t getNumberOfFunctions() const; // EXPORT
		  /// Return the NumberOfNames value of the export directory.
		  std::uint32_t getNumberOfNames() const; // EXPORT
		  /// Return the AddressOfFunctions value of the export directory.
		  std::uint32_t getAddressOfFunctions() const; // EXPORT
		  /// Return the AddressOfNames value of the export directory.
		  std::uint32_t getAddressOfNames() const; // EXPORT
		  /// Returns the AddressOfNameOrdinals value.
		  std::uint32_t getAddressOfNameOrdinals() const; // EXPORT

/*		  /// Returns the number of NameOrdinals.
		  std::uint32_t getNumberOfNameOrdinals() const; // EXPORT
		  /// Returns the number of AddressOfFunctionNames values.
		  std::uint32_t getNumberOfAddressOfFunctionNames() const; // EXPORT
		  /// Returns the number of AddressOfFunction values.
		  std::uint32_t getNumberOfAddressOfFunctions() const; // EXPORT
*/
		  /// Set the Base value of the export directory.
		  void setBase(std::uint32_t dwValue); // EXPORT
		  /// Set the Characteristics value of the export directory.
		  void setCharacteristics(std::uint32_t dwValue); // EXPORT
		  /// Set the TimeDateStamp value of the export directory.
		  void setTimeDateStamp(std::uint32_t dwValue); // EXPORT
		  /// Set the MajorVersion value of the export directory.
		  void setMajorVersion(std::uint16_t wValue); // EXPORT
		  /// Set the MinorVersion value of the export directory.
		  void setMinorVersion(std::uint16_t wValue); // EXPORT
		  /// Set the Name value of the export directory.
		  void setName(std::uint32_t dwValue); // EXPORT
		  /// Set the NumberOfFunctions value of the export directory.
		  void setNumberOfFunctions(std::uint32_t dwValue); // EXPORT
		  /// Set the NumberOfNames value of the export directory.
		  void setNumberOfNames(std::uint32_t dwValue); // EXPORT
		  /// Set the AddressOfFunctions value of the export directory.
		  void setAddressOfFunctions(std::uint32_t dwValue); // EXPORT
		  /// Set the AddressOfNames value of the export directory.
		  void setAddressOfNames(std::uint32_t dwValue); // EXPORT
		  void setAddressOfNameOrdinals(std::uint32_t value); // EXPORT

		  const std::vector<std::pair<unsigned int, unsigned int>>& getOccupiedAddresses() const;
	};
}
#endif

```

`debug_remover/include/retdec/pelib/IatDirectory.h`:

```h
/*
* IatDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_IATDIRECTORY_H
#define RETDEC_PELIB_IATDIRECTORY_H

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	/// Class that handles the Import Address Table (IAT)
	/**
	* This class can read and modify the Import Address Table of a PE file.
	**/
	class IatDirectory
	{
		protected:
		  std::vector<std::uint32_t> m_vIat; ///< Stores the individual IAT fields.

		public:
		  virtual ~IatDirectory() = default;

		  /// Reads the Import Address Table from a PE file.
		  int read(const void * buffer, std::size_t buffersize); // EXPORT
		  /// Reads the Import Address Table from an image loader
		  int read(PeLib::ImageLoader & imageLoader); // EXPORT
		  /// Returns the number of fields in the IAT.
		  unsigned int calcNumberOfAddresses() const; // EXPORT
		  /// Adds another address to the IAT.
		  void addAddress(std::uint32_t dwValue); // EXPORT
		  /// Removes an address from the IAT.
		  void removeAddress(unsigned int index); // EXPORT
		  /// Empties the IAT.
		  void clear(); // EXPORT
		  // Rebuilds the IAT.
		  void rebuild(std::vector<std::uint8_t>& vBuffer) const; // EXPORT
		  /// Returns the size of the current IAT.
		  unsigned int size() const; // EXPORT
		  /// Writes the current IAT to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset) const; // EXPORT

		  /// Retrieve the value of a field in the IAT.
		  std::uint32_t getAddress(unsigned int index) const; // EXPORT
		  /// Change the value of a field in the IAT.
		  void setAddress(std::uint32_t dwAddrnr, std::uint32_t dwValue); // EXPORT
	};
}

#endif


```

`debug_remover/include/retdec/pelib/ImageLoader.h`:

```h
/*
* ImageLoader.h - Interface to the PE imaage loader class
*
* Copyright (c) 2020 Ladislav Zezula
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_IMAGE_LOADER_H
#define RETDEC_PELIB_IMAGE_LOADER_H

#include <string>
#include <vector>

#include "PeLibAux.h"

namespace PeLib {

//-----------------------------------------------------------------------------
// Enum for ImageLoader::getFieldOffset()

enum struct PELIB_MEMBER_TYPE : std::uint32_t
{
	OPTHDR_sizeof,
	OPTHDR_sizeof_fixed,
	OPTHDR_NumberOfRvaAndSizes,
	OPTHDR_DataDirectory,
	OPTHDR_DataDirectory_EXPORT_Rva,
	OPTHDR_DataDirectory_RSRC_Rva,
	OPTHDR_DataDirectory_TLS_Rva,
	OPTHDR_DataDirectory_DEBUG_Rva,
	OPTHDR_DataDirectory_CONFIG_Rva,
};

//-----------------------------------------------------------------------------
// Support structure for one PE image compare result

enum struct PELIB_COMPARE_RESULT : std::uint32_t
{
	ImagesEqual,                                    // The images are equal
	ImagesWindowsLoadedWeDidnt,                     //
	ImagesWindowsDidntLoadWeDid,                    //
	ImagesDifferentSize,                            // The images have different size
	ImagesDifferentPageAccess,                      // An image page is different (accessible vs non-accessible)
	ImagesDifferentPageValue,                       // There is a different value at a certain offset
	ImagesInvalidPageInImage,                       // A page in the image mapped by Windows is invalid
	ImagesCompareInvalid,
};

//-----------------------------------------------------------------------------
// Windows build numbers

const std::uint32_t	BuildNumberXP = 2600;           // Behavior equal to Windows XP
const std::uint32_t BuildNumberVista = 6000;        // Behavior equal to Windows Vista (SP0 = 6000, SP1 = 6001, SP2 = 6002)
const std::uint32_t BuildNumber7 = 7600;            // Behavior equal to Windows 7 (SP0 = 7600, SP1 = 7601)
const std::uint32_t BuildNumber8 = 9200;            // Behavior equal to Windows 8
const std::uint32_t BuildNumber10 = 10240;          // Behavior equal to Windows 10
const std::uint32_t BuildNumberMask = 0x0FFFF;      // Mask for extracting the operating system
const std::uint32_t BuildNumber64Bit = 0x10000;     // Emulate 64-bit system

//-----------------------------------------------------------------------------
// Flags for ImageLoader::Load() and ImageLoader::Save()

const std::uint32_t IoFlagHeadersOnly = 1;          // Only load/save PE headers
const std::uint32_t IoFlagNewFile     = 2;          // Create the PE as new file (for unpackers)
const std::uint32_t IoFlagLoadAsImage = 4;          // Load the data as mapped image file

//-----------------------------------------------------------------------------
// Structure for comparison with Windows mapped images

typedef bool (*PFN_VERIFY_ADDRESS)(void * ptr, size_t length);
typedef bool (*PFN_COMPARE_CALLBACK)(struct PELIB_IMAGE_COMPARE * pImgCompare, size_t BytesCompared, size_t BytesTotal);

struct PELIB_IMAGE_COMPARE
{
	PFN_VERIFY_ADDRESS PfnVerifyAddress = nullptr;  // Custom function for verifying memory address
	PFN_COMPARE_CALLBACK PfnCompareCallback = nullptr; // Custom function for calling compare callback
	PELIB_COMPARE_RESULT compareResult = PELIB_COMPARE_RESULT::ImagesCompareInvalid;
	const char * szFileName = nullptr;              // Current file being compared (plain name)
	const char * dumpIfNotEqual = nullptr;          // If non-NULL, the image will be dumped into that file if different
	std::uint32_t differenceOffset = 0;             // If compareResult is ImagesDifferentPageValue, this contains offset of the difference
	std::uint32_t startTickCount = 0;               // GetTickCount value at the start of image testing
};

//-----------------------------------------------------------------------------
// Support structure for one PE file page

struct PELIB_FILE_PAGE
{
	PELIB_FILE_PAGE()
	{
		isInvalidPage = true;
		isZeroPage = false;
	}

	// Initializes the page with a valid data
	bool setValidPage(const void * data, size_t length)
	{
		// Write the valid data to the page
		writeToPage(data, 0, length);

		// Write zero data to the end of the page
		memset(buffer.data() + length, 0, PELIB_PAGE_SIZE - length);

		isInvalidPage = false;
		isZeroPage = false;
		return true;
	}

	// Initializes the page as zero page. To save memory, we won't initialize buffer
	void setZeroPage()
	{
		buffer.clear();
		isInvalidPage = false;
		isZeroPage = true;
	}

	void writeToPage(const void * data, size_t offset, size_t length)
	{
		if(offset < PELIB_PAGE_SIZE)
		{
			// Make sure that there is buffer allocated
			if(buffer.size() != PELIB_PAGE_SIZE)
				buffer.resize(PELIB_PAGE_SIZE);

			// Copy the data, up to page size
			if((offset + length) > PELIB_PAGE_SIZE)
				length = PELIB_PAGE_SIZE - offset;
			memcpy(buffer.data() + offset, data, length);
		}
	}

	ByteBuffer buffer;                    // A page-sized buffer, holding one image page. Empty if isInvalidPage
	bool isInvalidPage;                   // For invalid pages within image (SectionAlignment > 0x1000)
	bool isZeroPage;                      // For sections with VirtualSize != 0, RawSize = 0
};

//-----------------------------------------------------------------------------
// Image loader class interface

class ImageLoader
{
	public:

	ImageLoader(std::uint32_t loaderFlags = 0);

	int Load(ByteBuffer & fileData, bool loadHeadersOnly = false);
	int Load(std::istream & fs, std::streamoff fileOffset = 0, bool loadHeadersOnly = false);
	int Load(const char * fileName, bool loadHeadersOnly = false);

	int Save(std::ostream & fs, std::streamoff fileOffset = 0, std::uint32_t saveFlags = 0);
	int Save(const char * fileName, std::uint32_t saveFlags = 0);

	bool relocateImage(std::uint64_t newImageBase);

	std::uint32_t readImage(void * buffer, std::uint32_t rva, std::uint32_t bytesToRead);
	std::uint32_t writeImage(void * buffer, std::uint32_t rva, std::uint32_t bytesToRead);

	std::uint32_t readString(std::string & str, std::uint32_t rva, std::uint32_t maxLength = 65535);
	std::uint32_t readStringRc(std::string & str, std::uint32_t rva);
	std::uint32_t readStringRaw(ByteBuffer & fileData,
		                        std::string & str,
		                        std::size_t offset,
		                        std::size_t maxLength = 65535,
		                        bool mustBePrintable = false,
		                        bool mustNotBeTooLong = false);
	std::uint32_t stringLength(std::uint32_t rva, std::uint32_t maxLength = 65535) const;

	std::uint32_t readPointer(std::uint32_t rva, std::uint64_t & pointerValue);
	std::uint32_t getPointerSize() const;

	std::uint32_t dumpImage(const char * fileName);

	std::uint32_t getImageBitability() const;

	std::uint32_t vaToRva(std::uint64_t VirtualAddress) const;
	std::uint32_t getFileOffsetFromRva(std::uint32_t rva) const;
	std::uint32_t getValidOffsetFromRva(std::uint32_t rva) const;
	std::uint32_t getRealPointerToRawData(std::size_t sectionIndex) const;
	std::uint32_t getRealSizeOfRawData(std::size_t sectionIndex) const;
	std::uint32_t getImageProtection(std::uint32_t characteristics) const;
	std::size_t   getSectionIndexByRva(std::uint32_t Rva) const;

	std::uint32_t getFieldOffset(PELIB_MEMBER_TYPE field) const;

	const PELIB_IMAGE_DOS_HEADER & getDosHeader() const
	{
		return dosHeader;
	}

	const PELIB_IMAGE_FILE_HEADER & getFileHeader() const
	{
		return fileHeader;
	}

	const PELIB_IMAGE_OPTIONAL_HEADER & getOptionalHeader() const
	{
		return optionalHeader;
	}

	const PELIB_SECTION_HEADER * getSectionHeader(std::size_t sectionIndex) const
	{
		return (sectionIndex < sections.size()) ? &sections[sectionIndex] : nullptr;
	}

	PELIB_SECTION_HEADER * getSectionHeader(std::size_t sectionIndex)
	{
		return (sectionIndex < sections.size()) ? &sections[sectionIndex] : nullptr;
	}

	std::uint64_t getSizeOfFile() const
	{
		return savedFileSize;
	}

	std::uint64_t getOrdinalMask() const
	{
		return (uint64_t)1 << (getImageBitability() - 1);
	}

	std::uint32_t getPeHeaderOffset() const
	{
		return dosHeader.e_lfanew;
	}

	void setPeHeaderOffset(std::uint32_t new_e_lfanew)
	{
		dosHeader.e_lfanew = new_e_lfanew;
	}

	std::uint32_t getNtSignature() const
	{
		return ntSignature;
	}

	std::uint32_t getMachine() const
	{
		return fileHeader.Machine;
	}

	std::uint32_t getPointerToSymbolTable() const
	{
		return fileHeader.PointerToSymbolTable;
	}

	std::uint32_t getNumberOfSymbols() const
	{
		return fileHeader.NumberOfSymbols;
	}

	std::uint32_t getLoadedNumberOfSections() const
	{
		return fileHeader.NumberOfSections;
	}

	std::uint32_t getCharacteristics() const
	{
		return fileHeader.Characteristics;
	}

	std::uint32_t getNumberOfSections() const
	{
		return sections.size();
	}

	std::uint32_t getMagic() const
	{
		return optionalHeader.Magic;
	}

	std::uint64_t getImageBase() const
	{
		return optionalHeader.ImageBase;
	}

	std::uint32_t getAddressOfEntryPoint() const
	{
		return optionalHeader.AddressOfEntryPoint;
	}

	std::uint32_t getSizeOfHeaders() const
	{
		return optionalHeader.SizeOfHeaders;
	}

	std::uint32_t getSizeOfImage() const
	{
		return optionalHeader.SizeOfImage;
	}

	std::uint32_t getSizeOfImageAligned() const
	{
		return AlignToSize(optionalHeader.SizeOfImage, PELIB_PAGE_SIZE);
	}

	std::uint32_t getSectionAlignment() const
	{
		return optionalHeader.SectionAlignment;
	}

	std::uint32_t getFileAlignment() const
	{
		return optionalHeader.FileAlignment;
	}

	std::uint32_t getChecksumFileOffset() const
	{
		return checkSumFileOffset;
	}

	std::uint32_t getRealNumberOfDataDirectories() const
	{
		return realNumberOfRvaAndSizes;
	}

	std::uint32_t getSecurityDirFileOffset() const
	{
		return securityDirFileOffset;
	}

	std::uint32_t getDataDirRva(std::uint64_t dataDirIndex) const
	{
		// The data directory must be present there
		return (optionalHeader.NumberOfRvaAndSizes > dataDirIndex) ? optionalHeader.DataDirectory[dataDirIndex].VirtualAddress : 0;
	}

	std::uint32_t getDataDirSize(std::uint64_t dataDirIndex) const
	{
		// The data directory must be present there
		return (optionalHeader.NumberOfRvaAndSizes > dataDirIndex) ? optionalHeader.DataDirectory[dataDirIndex].Size : 0;
	}

	std::uint32_t getComDirRva() const
	{
		// For 32-bit binaries, the COM directory is valid even if NumberOfRvaAndSizes < IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR
		// Sample: 58b0147d7dd3cd73cb8bf8df077e244650621174f7ff788ad06fd0c1f82aac40
		if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC)
			return optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
		return getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR);
	}

	std::uint32_t getComDirSize() const
	{
		// For 32-bit binaries, the COM directory is valid even if NumberOfRvaAndSizes < IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR
		// Sample: 58b0147d7dd3cd73cb8bf8df077e244650621174f7ff788ad06fd0c1f82aac40
		if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC)
			return optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
		return getDataDirSize(PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR);
	}

	std::uint64_t getVirtualAddressMasked(std::uint32_t rva)
	{
		std::uint64_t virtualAddress = getImageBase() + rva;

		if(getImageBitability() == 32)
			virtualAddress = virtualAddress & 0xFFFFFFFF;
		return virtualAddress;
	}

	// Image manipulation
	void setPointerToSymbolTable(std::uint32_t pointerToSymbolTable);
	void setCharacteristics(std::uint32_t characteristics);
	void setAddressOfEntryPoint(std::uint32_t addressOfEntryPoint);
	void setSizeOfCode(std::uint32_t sizeOfCode, std::uint32_t baseOfCode = UINT32_MAX);
	void setDataDirectory(std::uint32_t entryIndex, std::uint32_t VirtualAddress, std::uint32_t Size = UINT32_MAX);

	PELIB_IMAGE_SECTION_HEADER * addSection(const char * name, std::uint32_t size);
	void calcNewSectionAddresses(std::uint32_t & Rva, std::uint32_t & RawOffset);
	void setSectionName(std::size_t sectionIndex, const char * newName);
	void setSectionVirtualRange(std::size_t sectionIndex, std::uint32_t VirtualAddress, std::uint32_t VirtualSize = UINT32_MAX);
	void setSectionRawDataRange(std::size_t sectionIndex, std::uint32_t PointerToRawData, std::uint32_t SizeOfRawData = UINT32_MAX);
	void setSectionCharacteristics(std::size_t sectionIndex, std::uint32_t Characteristics);
	int  splitSection(std::size_t sectionIndex, const std::string & prevSectName, const std::string & nextSectName, std::uint32_t splitOffset);
	void enlargeLastSection(std::uint32_t sectionSize);
	int  removeSection(std::size_t sizeIncrement);
	void makeValid();

	int setLoaderError(LoaderError ldrErr);
	LoaderError loaderError() const;

	// Testing functions
	std::size_t getMismatchOffset(void * buffer1, void * buffer2, std::uint32_t rva, std::size_t length);
	void compareWithWindowsMappedImage(PELIB_IMAGE_COMPARE & ImageCompare, void * imageData, std::uint32_t imageSize);

	protected:

	typedef void (*READWRITE)(PeLib::PELIB_FILE_PAGE & page, void * buffer, std::size_t offsetInPage, std::size_t bytesInPage);

	static void readFromPage(PELIB_FILE_PAGE & page, void * buffer, size_t offsetInPage, size_t bytesInPage);
	static void writeToPage(PELIB_FILE_PAGE & page, void * buffer, size_t offsetInPage, size_t bytesInPage);
	std::uint32_t readWriteImage(void * buffer, std::uint32_t rva, std::uint32_t bytesToRead, READWRITE ReadWrite);
	std::uint32_t readWriteImageFile(void * buffer, std::uint32_t rva, std::uint32_t bytesToRead, bool bReadOperation);

	void processSectionHeader(PELIB_IMAGE_SECTION_HEADER * pSectionHeader);
	bool processImageRelocation_IA64_IMM64(std::uint32_t fixupAddress, std::uint64_t difference);
	bool processImageRelocations(std::uint64_t oldImageBase, std::uint64_t getImageBase, std::uint32_t VirtualAddress, std::uint32_t Size);
	void writeNewImageBase(std::uint64_t newImageBase);

	int captureDosHeader(ByteBuffer & fileData);
	int saveToFile(std::ostream & fs, std::streamoff fileOffset, std::size_t rva, std::size_t length);
	int saveDosHeaderNew(std::ostream & fs, std::streamoff fileOffset);
	int saveDosHeader(std::ostream & fs, std::streamoff fileOffset);
	int captureNtHeaders(ByteBuffer & fileData);
	int saveNtHeadersNew(std::ostream & fs, std::streamoff fileOffset);
	int saveNtHeaders(std::ostream & fs, std::streamoff fileOffset);
	int captureSectionName(ByteBuffer & fileData, std::string & sectionName, const std::uint8_t * name);
	int captureSectionHeaders(ByteBuffer & fileData);
	int saveSectionHeadersNew(std::ostream & fs, std::streamoff fileOffset);
	int saveSectionHeaders(std::ostream & fs, std::streamoff fileOffset);
	int captureImageSections(ByteBuffer & fileData);
	int captureOptionalHeader32(std::uint8_t * fileData, std::uint8_t * filePtr, std::uint8_t * fileEnd);
	int captureOptionalHeader64(std::uint8_t * fileData, std::uint8_t * filePtr, std::uint8_t * fileEnd);
	std::uint32_t copyDataDirectories(std::uint8_t * optionalHeaderPtr, std::uint8_t * dataDirectoriesPtr, std::size_t optionalHeaderMax, std::uint32_t numberOfRvaAndSizes);

	int verifyDosHeader(PELIB_IMAGE_DOS_HEADER & hdr, std::size_t fileSize);
	int verifyDosHeader(std::istream & fs, std::streamoff fileOffset, std::size_t fileSize);

	int loadImageAsIs(ByteBuffer & fileData);

	std::uint32_t captureImageSection(ByteBuffer & fileData,
									  std::uint32_t virtualAddress,
									  std::uint32_t virtualSize,
									  std::uint32_t pointerToRawData,
									  std::uint32_t sizeOfRawData,
									  std::uint32_t characteristics,
									  bool isImageHeader = false);

	bool isGoodPagePointer(PFN_VERIFY_ADDRESS PfnVerifyAddress, void * pagePtr);
	bool isGoodMappedPage(std::uint32_t rva);
	bool isZeroPage(std::uint32_t rva);

	bool isSectionHeaderPointerToRawData(uint32_t rva);
	bool isLegacyImageArchitecture(std::uint16_t Machine);
	bool checkForValid64BitMachine();
	bool checkForValid32BitMachine();
	bool isValidMachineForCodeIntegrifyCheck(std::uint32_t Bits);
	bool checkForSectionTablesWithinHeader(std::uint32_t e_lfanew);
	bool checkForBadCodeIntegrityImages(ByteBuffer & fileData);
	bool checkForBadArchitectureSpecific();
	bool checkForImageAfterMapping();

	template <typename LOAD_CONFIG>
	bool checkForBadLoadConfigXX(std::uint32_t loadConfigRva, std::uint32_t loadConfigSize);

	// isImageLoadable returns true if the image is OK and can be mapped by NtCreateSection(SEC_IMAGE).
	// This does NOT mean that the image is executable by CreateProcess - more checks are done,
	// like resource integrity or relocation table correctness.
	bool isImageLoadable() const;
	bool isImageMappedOk() const;
	bool isValidImageBlock(std::uint32_t Rva, std::uint32_t Size)  const;

	static std::uint32_t AlignToSize(std::uint32_t ByteSize, std::uint32_t AlignSize)
	{
		return ((ByteSize + (AlignSize - 1)) & ~(AlignSize - 1));
	}

	static std::uint32_t BytesToPages(std::uint32_t ByteSize)
	{
		return (ByteSize >> PELIB_PAGE_SIZE_SHIFT) + ((ByteSize & (PELIB_PAGE_SIZE - 1)) != 0);
	}

	static std::uint64_t signExtend32To64(std::uint32_t value32)
	{
		return (std::uint64_t)(std::int64_t)(std::int32_t)value32;
	}

	// Anti-assert feature. Debug version of isprint in MS Visual C++ asserts
	// when the character is not EOF or is >= 255
	bool isPrintableChar(int ch)
	{
		return ((EOF <= ch) && (ch <= 255)) ? isprint(ch) : false;
	}

	static uint8_t ImageProtectionArray[16];

	std::vector<PELIB_SECTION_HEADER> sections;         // Vector of section headers
	std::vector<PELIB_FILE_PAGE> pages;                 // PE file pages as if mapped
	PELIB_IMAGE_DOS_HEADER  dosHeader;                  // Loaded DOS header
	PELIB_IMAGE_FILE_HEADER fileHeader;                 // Loaded NT file header
	PELIB_IMAGE_OPTIONAL_HEADER optionalHeader;         // 32/64-bit optional header
	ByteBuffer rawFileData;                             // Loaded content of the image in case it couldn't have been mapped
	LoaderError ldrError;
	std::uint64_t savedFileSize;                        // Size of the raw file
	std::uint32_t windowsBuildNumber;
	std::uint32_t ntSignature;
	std::uint32_t maxSectionCount;
	std::uint32_t realNumberOfRvaAndSizes;              // Real present number of RVA and sizes
	std::uint32_t checkSumFileOffset;                   // File offset of the image checksum
	std::uint32_t securityDirFileOffset;                // File offset of security directory
	std::uint32_t ssiImageAlignment32;                  // Alignment of signle-section images under 32-bit OS
	bool is64BitWindows;                                // If true, we simulate 64-bit Windows
	bool ntHeadersSizeCheck;                            // If true, the loader requires minimum size of NT headers
	bool sizeofImageMustMatch;                          // If true, the SizeOfImage must match virtual end of the last section
	bool architectureSpecificChecks;                    // If true, architecture-specific checks are also performed
	bool headerSizeCheck;                               // If true, image loader will imitate Windows XP header size check
	bool loadArmImages;                                 // If true, image loader will load ARM binaries
	bool loadArm64Images;                               // If true, image loader will load ARM64 binaries
	bool loadItaniumImages;                             // If true, image loader will load IA64 binaries
	bool forceIntegrityCheckEnabled;                    // If true, extra checks will be done if IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY is set
	bool forceIntegrityCheckCertificate;                // If true, extra check for certificate will be provided
	bool checkNonLegacyDllCharacteristics;              // If true, extra checks will be performed on DllCharacteristics
	bool checkImagePostMapping;                         // If true, extra checks will be performed after the image is mapped
	bool alignSingleSectionImagesToPage;                // Align single-section images to page size in 64-bit windows
};

}	// namespace PeLib

#endif	// RETDEC_PELIB_IMAGE_LOADER_H

```

`debug_remover/include/retdec/pelib/ImportDirectory.h`:

```h
/*
* ImportDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_IMPORTDIRECTORY_H
#define RETDEC_PELIB_IMPORTDIRECTORY_H

#include <set>
#include <unordered_map>

#include "retdec/pelib/PeLibAux.h"
#include "retdec/pelib/ImageLoader.h"
#include "retdec/pelib/ImageLoader.h"
#include "retdec/utils/ord_lookup.h"
#include "retdec/utils/string.h"

namespace PeLib
{
	class PeLibException;

	/// Class that handles import directories.
	/**
	* This class can read import directories from existing PE files or start completely from scratch.
	* Modifying import directories and writing them to files is also possible.
	* It's worthy to note that many functions require an extra parameter of type newDir
	* because the structure of import directories make it necessary that the OLDDIR import directory
	* must be preserved. That's why some functions (like adding and removing) imported functions
	* only exist for the new import directory, not for the one which is already written to the file.
	* \todo Adding functions by ordinal doesn't work yet (rebuild needs to be changed).
	* \todo Somehow store the rvas of the chunks in the file.
	**/

	class ImportDirectory
	{
		typedef typename std::vector<PELIB_IMAGE_IMPORT_DIRECTORY>::iterator ImpDirFileIterator;
		typedef typename std::vector<PELIB_IMAGE_IMPORT_DIRECTORY>::const_iterator ConstImpDirFileIterator;

		private:
		  /// Stores information about already imported DLLs.
		  std::vector<PELIB_IMAGE_IMPORT_DIRECTORY> m_vOldiid;
		  /// Stores information about imported DLLs which will be added.
		  std::vector<PELIB_IMAGE_IMPORT_DIRECTORY> m_vNewiid;
		  /// Stores RVAs which are occupied by this import directory.
		  std::vector<std::pair<unsigned int, unsigned int>> m_occupiedAddresses;
		  /// Mask for file ordinal
		  std::uint64_t m_ordinalMask;
		  /// Error detected by the import table parser
		  LoaderError m_ldrError;
		  /// size of single thunk item
		  std::size_t m_thunkSize;

		// I can't convince Borland C++ to compile the function outside of the class declaration.
		// That's why the function definition is here.
		/// Tests if a certain function is imported.
		template<typename T> bool hasFunction(std::string strFilename, T value, bool(PELIB_THUNK_DATA::* comp)(T) const) const
		{
			ConstImpDirFileIterator FileIter = m_vOldiid.begin();
			ConstImpDirFileIterator EndIter = m_vOldiid.end();

			for (int i=0;i<=1;i++) // Loop once for m_vOldiid and once for m_vNewiid
			{
				do
				{
					FileIter = std::find_if(
							FileIter,
							EndIter,
							[&](const auto& i) { return i == strFilename; }
					);

					if (FileIter != EndIter)
					{
						auto Iter = std::find_if(
								FileIter->thunk_data.begin(),
								FileIter->thunk_data.end(),
								std::bind(comp, std::placeholders::_1, value)
						);
						if (Iter != FileIter->thunk_data.end())
						{
							return true;
						}
						++FileIter;
					}
				}
				while (FileIter != EndIter);

				FileIter = m_vNewiid.begin();
				EndIter = m_vNewiid.end();
	 		}

	 		return false;
		}

		public:

		  /// Constructor
		  ImportDirectory() : m_ldrError(LDR_ERROR_NONE)
		  {
			  m_ordinalMask = 0x80000000;
			  m_thunkSize = 4;
		  }

		  /// Add a function to the import directory.
		  int addFunction(const std::string& strFilename, std::uint16_t wHint); // EXPORT _byHint
		  /// Add a function to the import directory.
		  int addFunction(const std::string& strFilename, const std::string& strFuncname); // EXPORT _byName

		  /// Get the ID of a file through it's name.
		  unsigned int getFileIndex(const std::string& strFilename, bool newDir) const; // EXPORT
		  /// Get the ID of a function through it's name.
		  unsigned int getFunctionIndex(const std::string& strFilename, const std::string& strFuncname, bool newDir) const; // EXPORT

		  /// Get the name of an imported file.
		  std::string getFileName(std::uint32_t dwFilenr, bool newDir) const; // EXPORT

		  void setFileName(std::uint32_t filenr, bool newDir, const std::string& name); // EXPORT

		  /// Retrieve the loader error
		  LoaderError loaderError() const;
		  void setLoaderError(LoaderError ldrError);

		  /// Get the number of files which are imported.
		  std::uint32_t getNumberOfFiles(bool newDir) const; // EXPORT
		  /// Get the number of functions which are imported by a specific file.
		  std::uint32_t getNumberOfFunctions(std::size_t dwFilenr, bool newDir) const; // EXPORT
		  /// Get information about n-th imported function
		  bool getImportedFunction(std::size_t dwFilenr, std::size_t dwFuncnr, std::string & importName, std::uint16_t & importHint, std::uint32_t & importOrdinal, std::uint32_t & patchRva, bool & isImportByOrdinal, bool newDir) const;

		  /// Get the hint of an imported function.
		  std::uint16_t getFunctionHint(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir) const; // EXPORT
		  void setFunctionHint(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir, std::uint16_t value); // EXPORT
		  /// Get the name of an imported function.
		  std::string getFunctionName(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir) const; // EXPORT
		  void setFunctionName(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir, const std::string& functionName); // EXPORT
		  /// Read a file's import directory.
		  int read(ImageLoader & imageLoader); // EXPORT
		  /// Writes pointer to the buffer (32-bit or 64-bit)
		  void writePointer(OutputBuffer & obBuffer, std::uint64_t pointerValue);
		  /// Rebuild the import directory.
		  void rebuild(std::vector<std::uint8_t>& vBuffer, std::uint32_t dwRva, bool fixEntries = true); // EXPORT
		  /// Remove a file from the import directory.
		  int removeFile(const std::string& strFilename); // EXPORT
		  /// Remove a function from the import directory.
		  int removeFunction(const std::string& strFilename, const std::string& strFuncname); // EXPORT _byName
		  /// Remove a function from the import directory.
		  int removeFunction(const std::string& strFilename, std::uint16_t wHint); // EXPORT _byHint
		  /// Returns the size of the current import directory.
		  unsigned int calculateSize(std::uint32_t pointerSize) const; // EXPORT
		  /// Writes the import directory to a file.
		  int write(const std::string& strFilename, std::uint32_t uiOffset, std::uint32_t uiRva, std::uint32_t pointerSize); // EXPORT
		  /// Updates the pointer size for the import directory
		  void setPointerSize(std::uint32_t pointerSize);

		  /// Returns the FirstThunk value of a function.
		  std::uint32_t getFirstThunk(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir) const; // EXPORT _byNumber
		  void setFirstThunk(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir, std::uint32_t value); // EXPORT _byNumber
		  /// Returns the OriginalFirstThunk value of a function.
		  std::uint32_t getOriginalFirstThunk(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir) const; // EXPORT _byNumber
		  void setOriginalFirstThunk(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir, std::uint32_t value); // EXPORT

//		  std::uint64_t getFirstThunk(const std::string& strFilename, const std::string& strFuncname, bool newDir) const throw (PeLibException);
//		  std::uint64_t getOriginalFirstThunk(const std::string& strFilename, const std::string& strFuncname, bool newDir) const throw (PeLibException);

		  /// Returns the FirstThunk value of a file.
		  std::uint32_t getFirstThunk(const std::string& strFilename, bool newDir) const; // EXPORT _byName
		  /// Returns the OriginalFirstThunk value of a file.
		  std::uint32_t getOriginalFirstThunk(const std::string& strFilename, bool newDir) const; // EXPORT _byName
		  /// Returns the ForwarderChain value of a file.
		  std::uint32_t getForwarderChain(const std::string& strFilename, bool newDir) const; // EXPORT _byName
		  std::uint32_t getRvaOfName(const std::string& strFilename, bool newDir) const; // EXPORT _byName
		  /// Returns the TimeDateStamp value of a file.
		  std::uint32_t getTimeDateStamp(const std::string& strFilename, bool newDir) const; // EXPORT _byName

		  /// Returns the FirstThunk value of a file.
		  std::uint32_t getFirstThunk(std::uint32_t dwFilenr, bool newDir) const; // EXPORT
		  void setFirstThunk(std::uint32_t dwFilenr, bool newDir, std::uint32_t value); // EXPORT _byNumber_function
		  /// Returns the OriginalFirstThunk value of a file.
		  std::uint32_t getOriginalFirstThunk(std::uint32_t dwFilenr, bool newDir) const; // EXPORT
		  void setOriginalFirstThunk(std::uint32_t dwFilenr, bool newDir, std::uint32_t value); // EXPORT _byNumber_function
		  /// Returns the ForwarderChain value of a file.
		  std::uint32_t getForwarderChain(std::uint32_t dwFilenr, bool newDir) const; // EXPORT _byNumber
		  void setForwarderChain(std::uint32_t dwFilenr, bool newDir, std::uint32_t value); // EXPORT _byNumber_function
		  std::uint32_t getRvaOfName(std::uint32_t dwFilenr, bool newDir) const; // EXPORT _byNumber
		  void setRvaOfName(std::uint32_t dwFilenr, bool newDir, std::uint32_t value); // EXPORT
		  /// Returns the TimeDateStamp value of a file.
		  std::uint32_t getTimeDateStamp(std::uint32_t dwFilenr, bool newDir) const; // EXPORT
		  void setTimeDateStamp(std::uint32_t dwFilenr, bool newDir, std::uint32_t value); // EXPORT _byNumber

		  const std::vector<std::pair<unsigned int, unsigned int>>& getOccupiedAddresses() const;

//		  std::uint16_t getFunctionHint(const std::string& strFilename, const std::string& strFuncname, bool newDir) const throw (PeLibException);

		protected:

		  const std::vector<PELIB_IMAGE_IMPORT_DIRECTORY>& getImportList(bool newDir) const;
		  std::vector<PELIB_IMAGE_IMPORT_DIRECTORY>& getImportList(bool newDir);
	};

	/**
	 * Returns whether OriginalFirstThunk of specified import descriptor is valid with a given PE header.
	 * OriginalFirstThunk is valid if it has value higher than file alignment and its RVA can be translated to some offset in the file.
	 *
	 * @param impDesc Import descriptor.
	 * @param imageLoader Reference to image loader.
	 *
	 * @return True if valid, otherwise false.
	 */

	inline bool hasValidOriginalFirstThunk(const PELIB_IMAGE_IMPORT_DESCRIPTOR& impDesc, const ImageLoader & imageLoader)
	{
		return (imageLoader.getSizeOfHeaders() <= impDesc.OriginalFirstThunk && impDesc.OriginalFirstThunk < imageLoader.getSizeOfImage());
	}

	/**
	* Add another import (by Ordinal) to the current file. Note that the import table is not automatically updated.
	* The new imported functions will be added when you recalculate the import table as it's necessary
	* to specify the address the import table will have in the file.
	* @param strFilename The name of a DLL.
	* @param wHint The ordinal of the function in the DLL.
	**/
	inline
	int ImportDirectory::addFunction(const std::string& strFilename, std::uint16_t wHint)
	{
		if (hasFunction(strFilename, wHint, &PELIB_THUNK_DATA::equalHint))
		{
			return ERROR_DUPLICATE_ENTRY;
		}

	 	// Find the imported file.
		ImpDirFileIterator FileIter = std::find_if(
				m_vNewiid.begin(),
				m_vNewiid.end(),
				[&](const auto& i) { return i == strFilename; }
		);

		PELIB_IMAGE_IMPORT_DIRECTORY iid;
		PELIB_THUNK_DATA td;
		td.hint = wHint;
		td.itd.Ordinal = wHint | m_ordinalMask;
		iid.name = strFilename;
		if (FileIter == m_vNewiid.end())
		{
			iid.thunk_data.push_back(td);
			m_vNewiid.push_back(iid);
		}
		else
		{
			FileIter->thunk_data.push_back(td);
		}

		return ERROR_NONE;
	}

	/**
	* Add a function to the Import Directory.
	* @param strFilename Name of the file which will be imported
	* @param strFuncname Name of the function which will be imported.
	**/
	inline
	int ImportDirectory::addFunction(const std::string& strFilename, const std::string& strFuncname)
	{
		if (hasFunction(strFilename, strFuncname, &PELIB_THUNK_DATA::equalFunctionName))
		{
			return ERROR_DUPLICATE_ENTRY;
		}

	 	// Find the imported file.
		ImpDirFileIterator FileIter = std::find_if(
				m_vNewiid.begin(),
				m_vNewiid.end(),
				[&](const auto& i) { return i == strFilename; }
		);

		PELIB_IMAGE_IMPORT_DIRECTORY iid;
		PELIB_THUNK_DATA td;
		td.fname = strFuncname;
		iid.name = strFilename;
		if (FileIter == m_vNewiid.end())
		{
			iid.thunk_data.push_back(td);
			m_vNewiid.push_back(iid);
		}
		else
		{
			FileIter->thunk_data.push_back(td);
		}

		return ERROR_NONE;
	}

	/**
	* Searches through the import directory and returns the number of the import
	* directory entry which belongs to the given filename.
	* @param strFilename Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return The ID of an imported file.
	**/
	inline
	unsigned int ImportDirectory::getFileIndex(const std::string& strFilename, bool newDir) const
	{
		auto * il = &getImportList(newDir);

		ConstImpDirFileIterator FileIter = std::find_if(
				il->begin(),
				il->end(),
				[&](const auto& i) { return i == strFilename; }
		);

		if (FileIter != il->end())
		{
			return static_cast<unsigned int>(std::distance(il->begin(), FileIter));
		}
		else
		{
			return -1;
			// throw Exceptions::InvalidName(ImportDirectoryId, __LINE__);
		}

		return ERROR_NONE;
	}

	/**
	* Searches through an imported file for a specific function.
	* @param strFilename Name of the imported file.
	* @param strFuncname Name of the imported function.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return ID of the imported function.
	**/
	inline
	unsigned int ImportDirectory::getFunctionIndex(const std::string& strFilename, const std::string& strFuncname, bool newDir) const
	{
		unsigned int uiFile = getFileIndex(strFilename, newDir);

		for (unsigned int i=0;i<getNumberOfFunctions(uiFile, newDir);i++)
		{
			if (getFunctionName(uiFile, i, newDir) == strFuncname) return i;
		}

		return -1;
	}

	/**
	* Get the name of an imported file.
	* @param dwFilenr Identifies which file should be checked.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Name of an imported file.
	**/
	inline
	std::string ImportDirectory::getFileName(std::uint32_t dwFilenr, bool newDir) const
	{
		return getImportList(newDir)[dwFilenr].name;
	}

	inline
	void ImportDirectory::setFileName(std::uint32_t filenr, bool newDir, const std::string& name)
	{
		getImportList(newDir)[filenr].name = name;
	}

	/**
	* Get the name of an imported function.
	* @param dwFilenr Identifies which file should be checked.
	* @param dwFuncnr Identifies which function should be checked.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Name of an imported function.
	* \todo Marked line is unsafe (function should be rewritten).
	**/
	inline
	std::string ImportDirectory::getFunctionName(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir) const
	{
		auto & il = getImportList(newDir);

		if(dwFilenr < il.size() && dwFuncnr < il[dwFilenr].thunk_data.size())
		{
			return il[dwFilenr].thunk_data[dwFuncnr].fname;
		}
	}

	inline
	void ImportDirectory::setFunctionName(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir, const std::string& functionName)
	{
		auto & il = getImportList(newDir);

		if(dwFilenr < il.size() && dwFuncnr < il[dwFilenr].thunk_data.size())
		{
			il[dwFilenr].thunk_data[dwFuncnr].fname = functionName;
		}
	}

	/**
	* Get the error that was detected during import table parsing
	**/
	inline
	LoaderError ImportDirectory::loaderError() const
	{
		return m_ldrError;
	}

	inline
	void ImportDirectory::setLoaderError(LoaderError ldrError)
	{
		// Do not override an existing loader error
		if (m_ldrError == LDR_ERROR_NONE)
		{
			m_ldrError = ldrError;
		}
	}

	/**
	* Get the number of files which are currently being imported.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Number of files which are currently being imported.
	**/
	inline
	std::uint32_t ImportDirectory::getNumberOfFiles(bool newDir) const
	{
		return static_cast<std::uint32_t>(getImportList(newDir).size());
	}

	/**
	* Get the number of functions which are currently being imported from a specific file.
	* @param dwFilenr Identifies which file should be checked.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Number of functions which are currently being imported from a specific file.
	**/
	inline
	std::uint32_t ImportDirectory::getNumberOfFunctions(std::size_t dwFilenr, bool newDir) const
	{
		auto& il = getImportList(newDir);
		std::uint32_t numFuncs = 0;

		if(dwFilenr < il.size())
			numFuncs = static_cast<std::uint32_t>(il[dwFilenr].thunk_data.size());
		return numFuncs;
	}

	/**
	* Retrieves the n-th import function from the m-th import directory
	* @param dwFilenr Zero-based index of the imported module
	* @param dwFuncnr Zero-based index of the imported function in the module above
	* @param importName If this is import by name, this string is filled by the import name
	* @param importHint If this is import by name, this 16-bit integer will be filled by the import hint
	* @param importOrdinal If this is import by orginal, this 32-bit integer will be filled by the ordinal of the function
	* @param patchRva RVA of the patched address
	* @param isImportByOrdinal Set to true if this is import by ordinal
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return true = the indexes are in range, so an import was returned
	**/
	inline
	bool ImportDirectory::getImportedFunction(
		std::size_t dwFilenr,
		std::size_t dwFuncnr,
		std::string& importName,
		std::uint16_t& importHint,
		std::uint32_t& importOrdinal,
		std::uint32_t& patchRva,
		bool& isImportByOrdinal,
		bool newDir) const
	{
		auto& il = getImportList(newDir);

		// Range check for the number of modules
		if(dwFilenr < il.size())
		{
			// Range check for the number of functions
			if(dwFuncnr < il[dwFilenr].thunk_data.size())
			{
				if(il[dwFilenr].thunk_data[dwFuncnr].itd.Ordinal & m_ordinalMask)
				{
					importOrdinal = il[dwFilenr].thunk_data[dwFuncnr].itd.Ordinal & ~m_ordinalMask;
					isImportByOrdinal = true;
					importHint = 0;
				}
				else
				{
					importHint = il[dwFilenr].thunk_data[dwFuncnr].hint;
					isImportByOrdinal = false;
					importOrdinal = 0;
				}

				// Function name may be present even if import by ordinal
				// (auto-retrieved on well-known ordinals, e.g. ws2_32.dll)
				importName = il[dwFilenr].thunk_data[dwFuncnr].fname;
				patchRva = il[dwFilenr].thunk_data[dwFuncnr].patchRva;
				return true;
			}
		}

		// Out of range
		return false;
	}

	/**
	* Get the hint of an imported function.
	* @param dwFilenr Identifies which file should be checked.
	* @param dwFuncnr Identifies which function should be checked.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Hint of an imported function.
	**/
	inline
	std::uint16_t ImportDirectory::getFunctionHint(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir) const
	{
		auto& il = getImportList(newDir);
		std::uint16_t hint = 0;

		if(dwFilenr < il.size() && dwFuncnr < il[dwFilenr].thunk_data.size())
		{
			hint = il[dwFilenr].thunk_data[dwFuncnr].hint;
		}

		return hint;
	}

	inline
	void ImportDirectory::setFunctionHint(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir, std::uint16_t value)
	{
		auto& il = getImportList(newDir);

		if(dwFilenr < il.size() && dwFuncnr < il[dwFilenr].thunk_data.size())
		{
			il[dwFilenr].thunk_data[dwFuncnr].hint = value;
		}
	}

	/**
	* Updates pointer size for import directory
	* @param pointerSize Size of the pointer (4 or 8 bytes).
	**/

	inline void ImportDirectory::setPointerSize(std::uint32_t pointerSize)
	{
		m_thunkSize = pointerSize;
		m_ordinalMask = (uint64_t)1 << ((pointerSize * 8) - 1);
	}

	inline bool isBadImportName(const std::string & importName)
	{
		// The name be of nonzero length
		if(importName.size() == 0)
			return true;

		// We don't accept space as the first character, but we accept space in the middle
		// retdec-regression-tests\tools\fileinfo\bugs\issue-460-hash-from-empty-string\000b1f22029c979c27c7310712cae66b8ade37378023487277ad7c86d59a34f6
		if(importName[0] <= 0x20)
			return true;

		// All characters of the name must be a valid (printable) ASCII char
		// Sample: retdec-regression-tests\tools\fileinfo\features\malformed-imports-exports\7CE5BB5CA99B3570514AF03782545D41213A77A0F93D4AAC8269823A8D3A58EF.dat
		for(unsigned char singleChar : importName)
		{
			if(singleChar < 0x20 || singleChar >= 0x7f)
				return true;
		}

		// We didn't find any reason to consider this import invalid
		return false;
	}

	/**
	* Read an import directory from a file.
	* \todo Check if streams failed.
	* @param imageLoader A valid PE loader.
	**/
	inline
	int ImportDirectory::read(ImageLoader & imageLoader)
	{
		std::uint64_t OrdinalMask = imageLoader.getOrdinalMask();
		std::uint32_t SizeOfImage = imageLoader.getSizeOfImage();
		std::uint32_t rvaBegin = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_IMPORT);
		std::uint32_t rva = rvaBegin;
		std::uint32_t uiIndex;

		setPointerSize(imageLoader.getPointerSize());
		m_ldrError = LDR_ERROR_NONE;

		// Verify whether the import directory is within the image
		if(rva > SizeOfImage)
		{
			setLoaderError(LDR_ERROR_IMPDIR_OUT_OF_FILE);
			return ERROR_INVALID_FILE;
		}

		// For tracking unique imported DLLs
		std::vector<PELIB_IMAGE_IMPORT_DIRECTORY> vOldIidCurr;
		std::unordered_map<std::string, int> uniqueDllList;
		std::set<std::uint32_t> seenOffsets;
		std::uint32_t uiDescCounter = 0;

		// Read and store all descriptors. Each descriptor corresponds to one imported DLL name.
		for (;;)
		{
			PELIB_IMAGE_IMPORT_DIRECTORY iidCurr;

			// If the required range is within the file, then we read the data.
			// If not, it's RVA may still be valid due mapping -> keep zeros.
			// Example sample: de0dea00414015bacbcbfc1fa53af9f6731522687d82f5de2e9402410488d190
			// (single entry in the import directory at file offset 0x3EC4 followed by end-of-file)
			if ((rva + sizeof(PELIB_IMAGE_IMPORT_DESCRIPTOR)) >= SizeOfImage)
			{
				setLoaderError(LDR_ERROR_IMPDIR_CUT);
				break;
			}

			// The offset is within the file range -> read it from the image
			imageLoader.readImage(&iidCurr.impdesc, rva, sizeof(PELIB_IMAGE_IMPORT_DESCRIPTOR));
			rva += sizeof(PELIB_IMAGE_IMPORT_DESCRIPTOR);
			uiDescCounter++;

			// If Name or FirstThunk are 0, this descriptor is considered as null-terminator.
			if (iidCurr.impdesc.Name == 0 || iidCurr.impdesc.FirstThunk == 0)
				break;

			// We ignore import names that go beyond the file
			if (iidCurr.impdesc.Name > SizeOfImage)
			{
				setLoaderError(LDR_ERROR_IMPDIR_NAME_RVA_INVALID);
				break;
			}

			if (iidCurr.impdesc.FirstThunk > SizeOfImage)
			{
				setLoaderError(LDR_ERROR_IMPDIR_THUNK_RVA_INVALID);
				break;
			}

			// Retrieve the library name from the image as ASCIIZ string
			imageLoader.readString(iidCurr.name, iidCurr.impdesc.Name, IMPORT_LIBRARY_MAX_LENGTH);

			// Sample: 0BBA9D483A5E26932C1BA5904EA8FA2E063E0419C7B8A6342814266E96E1CEA2
			// 4 imports all invalid names. We stop parsing the imports at an invalid entry,
			// but we won't say that the file is invalid
			if (isBadImportName(iidCurr.name))
			{
				setLoaderError(LDR_ERROR_IMPDIR_NAME_RVA_INVALID);
				break;
			}

			// Ignore too large import directories
			// Sample: CCE461B6EB23728BA3B8A97B9BE84C0FB9175DB31B9949E64144198AB3F702CE, # of impdesc 0x6253 (invalid)
			// Sample: 395e64e7071d35cb85d8312095aede5166db731aac44920679eee5c7637cc58c, # of impdesc 0x0131 (valid)
			if (uniqueDllList.find(iidCurr.name) == uniqueDllList.end())
			{
				// Remember that the DLL was imported before
				uniqueDllList.emplace(iidCurr.name, 1);

				// Check the total number of imported DLLs
				if(uniqueDllList.size() > PELIB_MAX_IMPORT_DLLS)
				{
					setLoaderError(LDR_ERROR_IMPDIR_COUNT_EXCEEDED);
					break;
				}
			}

			// Mark the range occupied by name
			// +1 for null terminator
			// If the end address is even, we need to align it by 2, so next name always starts at even address
			m_occupiedAddresses.emplace_back(iidCurr.impdesc.Name, iidCurr.impdesc.Name + iidCurr.name.length() + 1);
			if (!(m_occupiedAddresses.back().second & 1))
				m_occupiedAddresses.back().second += 1;

			// Push the import descriptor into the vector
			vOldIidCurr.push_back(std::move(iidCurr));
		}

		// Space occupied by import descriptors
		m_occupiedAddresses.emplace_back(rvaBegin, rva);

		// Read the import entries (functions) for each import descriptor. Read both thunks at once
		for(std::size_t i = 0; i < vOldIidCurr.size(); i++)
		{
			// This reflects the check in the Windows loader (LdrpSnapIAT)
			// "If the OriginalFirstThunk field does not point inside the image, then ignore
			// it. This is will detect bogus Borland Linker 2.25 images that did not fill
			// this field in."
			std::uint32_t originalThunk = hasValidOriginalFirstThunk(vOldIidCurr[i].impdesc, imageLoader) ?
				                                                     vOldIidCurr[i].impdesc.OriginalFirstThunk :
				                                                     vOldIidCurr[i].impdesc.FirstThunk;
			std::uint32_t firstThunk = vOldIidCurr[i].impdesc.FirstThunk;

			// Don't allow multiple import descriptors to take data from the same RVA
			if(seenOffsets.count(firstThunk))
				continue;
			seenOffsets.insert(firstThunk);

			// Parse individual imports
			for(uiIndex = 0;; uiIndex++)
			{
				PELIB_THUNK_DATA thunkData;

				// Read single value (32-bit or 64-bit) from the thunk chain
				if(!imageLoader.readPointer(originalThunk, thunkData.itd.Ordinal))
					break;

				// Are we at the end of the list?
				if(thunkData.itd.Ordinal == 0)
					break;

				// Did we exceed the count of imported functions?
				if(uiIndex >= PELIB_MAX_IMPORTED_FUNCTIONS)
				{
					setLoaderError(LDR_ERROR_IMPDIR_IMPORT_COUNT_EXCEEDED);
					break;
				}

				// Set the patch RVA
				thunkData.patchRva = firstThunk;

				// Is it an import by name?
				if((thunkData.itd.Ordinal & OrdinalMask) == 0)
				{
					// Check samples that have import name out of the image
					// Sample: CCE461B6EB23728BA3B8A97B9BE84C0FB9175DB31B9949E64144198AB3F702CE
					if(thunkData.itd.Ordinal < imageLoader.getSizeOfImage())
					{
						// Read the import hint
						if(imageLoader.readImage(&thunkData.hint, thunkData.itd.Ordinal, sizeof(std::uint16_t)) != sizeof(std::uint16_t))
						{
							setLoaderError(LDR_ERROR_IMPDIR_THUNK_RVA_INVALID);
							thunkData.hint = 0;
						}

						// Read the import name
						imageLoader.readString(thunkData.fname, thunkData.itd.Ordinal + sizeof(std::uint16_t), IMPORT_SYMBOL_MAX_LENGTH);

						// Space occupied by names
						// +1 for null terminator
						// If the end address is even, we need to align it by 2, so next name always starts at even address
						m_occupiedAddresses.emplace_back(
							static_cast<unsigned int>(thunkData.itd.Ordinal),
							static_cast<unsigned int>(thunkData.itd.Ordinal + sizeof(thunkData.hint) + thunkData.fname.length() + 1)
						);

						// Align the end by 2
						m_occupiedAddresses.back().second = (m_occupiedAddresses.back().second + 1) & 0xFFFFFFFFE;
					}
					else
					{
						setLoaderError(LDR_ERROR_IMPDIR_THUNK_RVA_INVALID);
					}
				}
				else
				{
					// Mask out the ordinal bit. Then, any ordinal must not be larger than 0xFFFF
					std::uint32_t ordinal = thunkData.itd.Ordinal & ~OrdinalMask;

					// Import by ordinal must be lower-word only; any ordinal that is greater than 0xFFFF is invalid.
					// Sample: 7CE5BB5CA99B3570514AF03782545D41213A77A0F93D4AAC8269823A8D3A58EF
					if((ordinal >> 0x10) == 0)
					{
						thunkData.fname = retdec::utils::ordLookUp(vOldIidCurr[i].name, ordinal, false);
						thunkData.hint = 0;
					}
					else
					{
						setLoaderError(LDR_ERROR_IMPDIR_THUNK_RVA_INVALID);
					}
				}

				// Insert the thunk into the import descriptor
				vOldIidCurr[i].thunk_data.push_back(thunkData);

				// Increment both pointers
				originalThunk += imageLoader.getPointerSize();
				firstThunk += imageLoader.getPointerSize();
			}
		}

		std::swap(vOldIidCurr, m_vOldiid);
		return ERROR_NONE;
	}

	inline void ImportDirectory::writePointer(OutputBuffer & obBuffer, std::uint64_t pointerValue)
	{
		if(m_thunkSize == sizeof(std::uint32_t))
		{
			std::uint32_t pointerValue32 = (std::uint32_t)pointerValue;
			obBuffer << pointerValue32;
		}
		else
		{
			obBuffer << pointerValue;
		}
	}

	/**
	* Rebuilds the import directory.
	* @param vBuffer Buffer the rebuilt import directory will be written to.
	* @param dwRva The RVA of the ImportDirectory in the file.
	* @param fixEntries Boolean flag.
	* \todo uiSizeoffuncnames is not used.
	**/
	inline
	void ImportDirectory::rebuild(std::vector<std::uint8_t>& vBuffer, std::uint32_t dwRva, bool fixEntries)
	{
		unsigned int uiImprva = dwRva;
		unsigned int uiSizeofdescriptors = (static_cast<unsigned int>(m_vNewiid.size() + m_vOldiid.size()) + 1) * PELIB_IMAGE_IMPORT_DESCRIPTOR::size();

		unsigned int uiSizeofdllnames = 0, uiSizeoffuncnames = 0;
		unsigned int uiSizeofoft = 0;

		for (unsigned int i=0;i<m_vNewiid.size();i++)
		{
			uiSizeofdllnames += static_cast<unsigned int>(m_vNewiid[i].name.size()) + 1;
			uiSizeofoft += (static_cast<unsigned int>(m_vNewiid[i].thunk_data.size())+1) * m_thunkSize;

			for(unsigned int j=0;j<m_vNewiid[i].thunk_data.size();j++)
			{
				// +3 for hint (std::uint16_t) and 00-std::uint8_t
				uiSizeoffuncnames += (static_cast<unsigned int>(m_vNewiid[i].thunk_data[j].fname.size()) + 3);
			}
		}

//		for (unsigned int i=0;i<m_vNewiid.size();i++)
//		{
//			uiSizeofoft += (static_cast<unsigned int>(m_vNewiid[i].thunk_data.size())+1) * PELIB_IMAGE_THUNK_DATA::size();
//		}

		OutputBuffer obBuffer(vBuffer);

		// Rebuild IMAGE_IMPORT_DESCRIPTORS
		for (unsigned int i=0;i<m_vOldiid.size();i++)
		{
			obBuffer << m_vOldiid[i].impdesc.OriginalFirstThunk;
			obBuffer << m_vOldiid[i].impdesc.TimeDateStamp;
			obBuffer << m_vOldiid[i].impdesc.ForwarderChain;
			obBuffer << m_vOldiid[i].impdesc.Name;
			obBuffer << m_vOldiid[i].impdesc.FirstThunk;
		}

		unsigned int dllsize = 0;

		for (unsigned int i=0;i<m_vNewiid.size();i++)
		{
			std::uint32_t dwPoft = uiSizeofdescriptors + uiImprva;

			for (unsigned int j=1;j<=i;j++)
			{
				dwPoft += (static_cast<unsigned int>(m_vNewiid[j-1].thunk_data.size()) + 1) * m_thunkSize;
			}

			obBuffer << (fixEntries ? dwPoft : m_vNewiid[i].impdesc.OriginalFirstThunk);
			obBuffer << m_vNewiid[i].impdesc.TimeDateStamp;
			obBuffer << m_vNewiid[i].impdesc.ForwarderChain;
			std::uint32_t dwPdll = uiSizeofdescriptors + uiSizeofoft + uiImprva + dllsize;
			obBuffer << (fixEntries ? dwPdll : m_vNewiid[i].impdesc.Name);
			obBuffer << m_vNewiid[i].impdesc.FirstThunk;

			// store the recalculated values
			if (fixEntries)
			{
				m_vNewiid[i].impdesc.OriginalFirstThunk = dwPoft;
				m_vNewiid[i].impdesc.Name = dwPdll;
			}

			dllsize += static_cast<unsigned int>(m_vNewiid[i].name.size()) + 1;
		}

		obBuffer << static_cast<std::uint32_t>(0);
		obBuffer << static_cast<std::uint32_t>(0);
		obBuffer << static_cast<std::uint32_t>(0);
		obBuffer << static_cast<std::uint32_t>(0);
		obBuffer << static_cast<std::uint32_t>(0);

		std::uint64_t uiPfunc = uiSizeofdescriptors + uiSizeofoft + uiSizeofdllnames + uiImprva;

		// Rebuild original first thunk
		for (std::size_t i = 0;i<m_vNewiid.size();i++)
		{
			for (std::size_t j = 0;j<m_vNewiid[i].thunk_data.size();j++)
			{
				if((m_vNewiid[i].thunk_data[j].itd.Ordinal & m_ordinalMask) || fixEntries == false)
				{
					writePointer(obBuffer, m_vNewiid[i].thunk_data[j].itd.Ordinal);
					//obBuffer << m_vNewiid[i].thunk_data[j].itd.Ordinal;
				}
				else
				{
					writePointer(obBuffer, uiPfunc);
					//obBuffer << uiPfunc;
					// store the offset in Ordinal, they cannot overlay thanks to PELIB_IMAGE_ORDINAL_FLAG
					m_vNewiid[i].thunk_data[j].itd.Ordinal = uiPfunc;
				}
				uiPfunc += static_cast<std::uint64_t>(m_vNewiid[i].thunk_data[j].fname.size()) + 3;
			}
			writePointer(obBuffer, 0);
			//obBuffer << static_cast<std::uint64_t>(0);
		}

		// Write dllnames into import directory
		for (std::size_t i = 0; i < m_vNewiid.size(); i++)
		{
			obBuffer.add(m_vNewiid[i].name.c_str(), static_cast<unsigned int>(m_vNewiid[i].name.size())+1);
		}

		// Write function names into directory
		for (unsigned int i=0;i<m_vNewiid.size();i++)
		{
			for (unsigned int j=0;j<m_vNewiid[i].thunk_data.size();j++)
			{
				obBuffer << m_vNewiid[i].thunk_data[j].hint;
				obBuffer.add(m_vNewiid[i].thunk_data[j].fname.c_str(), static_cast<unsigned int>(m_vNewiid[i].thunk_data[j].fname.size()) + 1);
			}
		}
	}

	/**
	* Removes a specific file and all functions of it from the import directory.
	* @param strFilename Name of the file which will be removed.
	**/
	inline
	int ImportDirectory::removeFile(const std::string& strFilename)
	{
		unsigned int oldSize = static_cast<unsigned int>(m_vNewiid.size());

		m_vNewiid.erase(
			std::remove_if(
				m_vNewiid.begin(),
				m_vNewiid.end(),
				[&](const auto& i) { return i == strFilename; }
			),
			m_vNewiid.end()
		);

		return oldSize == m_vNewiid.size() ? 1 : 0;
	}

	/**
	* Removes a specific function from the import directory.
	* @param strFilename Name of the file which exports the function.
	* @param strFuncname Name of the imported function.
	**/
	inline
	int ImportDirectory::removeFunction(const std::string& strFilename, const std::string& strFuncname)
	{
		ImpDirFileIterator viPos = m_vNewiid.begin();

		int notFound = 1;

		while (viPos != m_vNewiid.end())
		{
			if (isEqualNc(viPos->name, strFilename))
			{
				unsigned int oldSize = static_cast<unsigned int>(viPos->thunk_data.size());
				viPos->thunk_data.erase(
					std::remove_if(
						viPos->thunk_data.begin(),
						viPos->thunk_data.end(),
						[&](const auto& i) { return i.equalFunctionName(strFuncname); }
					),
					viPos->thunk_data.end()
				);
				if (viPos->thunk_data.size() != oldSize) notFound = 0;
			}
			++viPos;
		}

		return notFound;
	}

	/**
	* Removes a specific function from the import directory.
	* @param strFilename Name of the file which exports the function.
	* @param wHint The hint of the function.
	**/
	inline
	int ImportDirectory::removeFunction(const std::string& strFilename, std::uint16_t wHint)
	{
		ImpDirFileIterator viPos = m_vNewiid.begin();
		int notFound = 1;

		while (viPos != m_vNewiid.end())
		{
			if (isEqualNc(viPos->name, strFilename))
			{
				unsigned int oldSize = static_cast<unsigned int>(viPos->thunk_data.size());
				viPos->thunk_data.erase(
					std::remove_if(
						viPos->thunk_data.begin(),
						viPos->thunk_data.end(),
						[&](const auto& i) { return i.equalHint(wHint); }
					),
					viPos->thunk_data.end()
				);
				if (viPos->thunk_data.size() != oldSize) notFound = 0;
			}
			++viPos;
		}

		return notFound;
	}

	/**
	* Writes the current import directory to a file.
	* @param strFilename Name of the file.
	* @param uiOffset File Offset of the new import directory.
	* @param uiRva RVA which belongs to that file offset.
	* @param pointerSize Size of the pointer (4 bytes or 8 bytes)
	**/
	inline
	int ImportDirectory::write(const std::string& strFilename, std::uint32_t uiOffset, std::uint32_t uiRva, std::uint32_t pointerSize)
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);

		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios_base::beg);

		std::vector<std::uint8_t> vBuffer;

		setPointerSize(pointerSize);
		rebuild(vBuffer, uiRva);

		ofFile.write(reinterpret_cast<const char*>(vBuffer.data()), vBuffer.size());
		ofFile.close();

		std::copy(m_vNewiid.begin(), m_vNewiid.end(), std::back_inserter(m_vOldiid));
		m_vNewiid.clear();

		return ERROR_NONE;
	}

	/**
	* Calculates size of import directory that would be written to a PE file.
	* @return Size of the import directory.
	**/
	inline
	std::uint32_t ImportDirectory::calculateSize(std::uint32_t pointerSize) const
	{
		std::uint32_t totalSize = 0;

		// Only the descriptors of m_vOldiid must be rebuilt, not the data they point to.
		for(const auto & element : m_vNewiid)
			totalSize += element.calculateSize(pointerSize);
		return totalSize + (m_vOldiid.size() + 1) * PELIB_IMAGE_IMPORT_DESCRIPTOR::size();
	}

	/**
	* @param strFilename Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return FirstThunk value of an imported file.
	**/
	inline
	std::uint32_t ImportDirectory::getFirstThunk(const std::string& strFilename, bool newDir) const
	{
		return getImportList(newDir)[getFileIndex(strFilename, newDir)].impdesc.FirstThunk;
	}

	/**
	* @param strFilename Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return OriginalFirstThunk value of an imported file.
	**/
	inline
	std::uint32_t ImportDirectory::getOriginalFirstThunk(const std::string& strFilename, bool newDir) const
	{
		return getImportList(newDir)[getFileIndex(strFilename, newDir)].impdesc.OriginalFirstThunk;
	}

	/**
	* @param strFilename Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return ForwarderChain value of an imported file.
	**/
	inline
	std::uint32_t ImportDirectory::getForwarderChain(const std::string& strFilename, bool newDir) const
	{
		return getImportList(newDir)[getFileIndex(strFilename, newDir)].impdesc.ForwarderChain;
	}

	/**
	* @param strFilename Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return TimeDateStamp value of an imported file.
	**/
	inline
	std::uint32_t ImportDirectory::getTimeDateStamp(const std::string& strFilename, bool newDir) const
	{
		return getImportList(newDir)[getFileIndex(strFilename, newDir)].impdesc.TimeDateStamp;
	}

	inline
	std::uint32_t ImportDirectory::getRvaOfName(const std::string& strFilename, bool newDir) const
	{
		return getImportList(newDir)[getFileIndex(strFilename, newDir)].impdesc.Name;
	}

	/**
	* @param dwFilenr Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return FirstThunk value of an imported file.
	**/
	inline
	std::uint32_t ImportDirectory::getFirstThunk(std::uint32_t dwFilenr, bool newDir) const
	{
		return getImportList(newDir)[dwFilenr].impdesc.FirstThunk;
	}

	inline
	void ImportDirectory::setFirstThunk(std::uint32_t dwFilenr, bool newDir, std::uint32_t value)
	{
		getImportList(newDir)[dwFilenr].impdesc.FirstThunk = value;
	}

	/**
	* @param dwFilenr Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return OriginalFirstThunk value of an imported file.
	**/
	inline
	std::uint32_t ImportDirectory::getOriginalFirstThunk(std::uint32_t dwFilenr, bool newDir) const
	{
		return getImportList(newDir)[dwFilenr].impdesc.OriginalFirstThunk;
	}

	inline
	void ImportDirectory::setOriginalFirstThunk(std::uint32_t dwFilenr, bool newDir, std::uint32_t value)
	{
		getImportList(newDir)[dwFilenr].impdesc.OriginalFirstThunk = value;
	}

	/**
	* @param dwFilenr Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return ForwarderChain value of an imported file.
	**/

	inline
	std::uint32_t ImportDirectory::getForwarderChain(std::uint32_t dwFilenr, bool newDir) const
	{
		return getImportList(newDir)[dwFilenr].impdesc.ForwarderChain;
	}

	inline
	void ImportDirectory::setForwarderChain(std::uint32_t dwFilenr, bool newDir, std::uint32_t value)
	{
		getImportList(newDir)[dwFilenr].impdesc.ForwarderChain = value;
	}

	/**
	* @param dwFilenr Name of the imported file.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return TimeDateStamp value of an imported file.
	**/
	inline
	std::uint32_t ImportDirectory::getTimeDateStamp(std::uint32_t dwFilenr, bool newDir) const
	{
		return getImportList(newDir)[dwFilenr].impdesc.TimeDateStamp;
	}

	inline
	void ImportDirectory::setTimeDateStamp(std::uint32_t dwFilenr, bool newDir, std::uint32_t value)
	{
		getImportList(newDir)[dwFilenr].impdesc.TimeDateStamp = value;
	}

	inline
	std::uint32_t ImportDirectory::getRvaOfName(std::uint32_t dwFilenr, bool newDir) const
	{
		return getImportList(newDir)[dwFilenr].impdesc.Name;
	}

	inline
	void ImportDirectory::setRvaOfName(std::uint32_t dwFilenr, bool newDir, std::uint32_t value)
	{
		getImportList(newDir)[dwFilenr].impdesc.Name = value;
	}

	/**
	* @param dwFilenr ID of the imported file.
	* @param dwFuncnr ID of the imported function.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return FirstThunk value of an imported function.
	**/
	inline
	std::uint32_t ImportDirectory::getFirstThunk(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir) const
	{
		return getImportList(newDir)[dwFilenr].thunk_data[dwFuncnr].itd.Ordinal;
	}

	inline
	void ImportDirectory::setFirstThunk(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir, std::uint32_t value)
	{
		getImportList(newDir)[dwFilenr].thunk_data[dwFuncnr].itd.Ordinal = value;
	}

	/**
	* @param dwFilenr ID of the imported file.
	* @param dwFuncnr ID of the imported function.
	* @param newDir Flag to decide if the OLDDIR or new import directory is used.
	* @return OriginalFirstThunk value of an imported function.
	**/
	inline
	std::uint32_t ImportDirectory::getOriginalFirstThunk(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir) const
	{
		if (newDir == false)
		{
			if (dwFuncnr < m_vOldiid[dwFilenr].thunk_data.size())
			{
				return m_vOldiid[dwFilenr].thunk_data[dwFuncnr].itd.Ordinal;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return m_vNewiid[dwFilenr].thunk_data[dwFuncnr].itd.Ordinal;
		}
	}

	inline
	void ImportDirectory::setOriginalFirstThunk(std::uint32_t dwFilenr, std::uint32_t dwFuncnr, bool newDir, std::uint32_t value)
	{
		getImportList(newDir)[dwFilenr].thunk_data[dwFuncnr].itd.Ordinal = value;
	}

	inline
	const std::vector<std::pair<unsigned int, unsigned int>>& ImportDirectory::getOccupiedAddresses() const
	{
		return m_occupiedAddresses;
	}

	inline const std::vector<PELIB_IMAGE_IMPORT_DIRECTORY>& ImportDirectory::getImportList(bool newDir) const
	{
		return (newDir == false) ? m_vOldiid : m_vNewiid;
	}

	inline std::vector<PELIB_IMAGE_IMPORT_DIRECTORY>& ImportDirectory::getImportList(bool newDir)
	{
		return (newDir == false) ? m_vOldiid : m_vNewiid;
	}


} // namespace PeLib

#endif

```

`debug_remover/include/retdec/pelib/InputBuffer.h`:

```h
/*
* InputBuffer.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_INPUTBUFFER_H
#define RETDEC_PELIB_INPUTBUFFER_H

#include <vector>
#include <iterator>
#include <cassert>

namespace PeLib
{
	class InputBuffer
	{
		private:
		  std::vector<unsigned char>& m_vBuffer;
		  unsigned long ulIndex;

		public:
		  InputBuffer(std::vector<unsigned char>& vBuffer);

		  const unsigned char* data() const;
		  unsigned long size();

		  template<typename T>
		  InputBuffer& operator>>(T& value)
		  {
//jk: temporarily disabled because of fails on 64bit systems
//			assert(ulIndex + sizeof(value) <= m_vBuffer.size());

			std::vector<char> data(sizeof(T), 0);
			std::size_t size = ulIndex + sizeof(T) > m_vBuffer.size() ? m_vBuffer.size() - ulIndex : sizeof(T);
			read(data.data(), (unsigned long)size);
			value = *reinterpret_cast<T*>(data.data());
			return *this;
		  }

		  void read(char* lpBuffer, unsigned long ulSize);
		  void reset();
		  void set(unsigned long ulIndex2);
		  void move(unsigned long shift);
		  unsigned long get();
		  void setBuffer(std::vector<unsigned char>& vBuffer);
//		  void updateData(unsigned long ulIndex,
	};
}

#endif

```

`debug_remover/include/retdec/pelib/OutputBuffer.h`:

```h
/*
* OutputBuffer.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_OUTPUTBUFFER_H
#define RETDEC_PELIB_OUTPUTBUFFER_H

#include <vector>
#include <iterator>

namespace PeLib
{
	class OutputBuffer
	{
		private:
		  std::vector<unsigned char>& m_vBuffer;

		public:
		  OutputBuffer(std::vector<unsigned char>& vBuffer);
		  const unsigned char* data() const;
		  unsigned long size();

		  template<typename T>
		  OutputBuffer& operator<<(const T& value)
		  {
			const unsigned char* p = reinterpret_cast<const unsigned char*>(&value);
			std::copy(p, p + sizeof(value), std::back_inserter(m_vBuffer));
			return *this;
		  }
		  void add(const char* lpBuffer, unsigned long ulSize);
		  void reset();
		  void resize(unsigned int uiSize);
		  void set(unsigned int uiPosition);

		  template<typename T>
		  void update(unsigned long ulIndex, const T& value)
		  {
			*reinterpret_cast<T*>(m_vBuffer.data() + ulIndex) = value;
		  }

		  template<typename T>
		  void insert(unsigned long ulIndex, const T& value)
		  {
			if (ulIndex + sizeof(T) >= size())
				resize(ulIndex + sizeof(T));

			update(ulIndex, value);
		  }
	};
}

#endif

```

`debug_remover/include/retdec/pelib/PeFile.h`:

```h
/*
* PeFile.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_PEFILE_H
#define RETDEC_PELIB_PEFILE_H

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/ImageLoader.h"
#include "retdec/pelib/ImportDirectory.h"
#include "retdec/pelib/ExportDirectory.h"
#include "retdec/pelib/BoundImportDirectory.h"
#include "retdec/pelib/ResourceDirectory.h"
#include "retdec/pelib/RelocationsDirectory.h"
#include "retdec/pelib/ComHeaderDirectory.h"
#include "retdec/pelib/IatDirectory.h"
#include "retdec/pelib/DebugDirectory.h"
#include "retdec/pelib/TlsDirectory.h"
#include "retdec/pelib/RichHeader.h"
#include "retdec/pelib/CoffSymbolTable.h"
#include "retdec/pelib/DelayImportDirectory.h"
#include "retdec/pelib/SecurityDirectory.h"
#include "retdec/pelib/ConfigDirectory.h"

namespace PeLib
{
	/**
	* This class represents the common structures of PE and PE+ files.
	**/
	class PeFile
	{
		protected:
		  std::string m_filename; ///< Name of the current file.
		  ImageLoader m_imageLoader;
		  RichHeader m_richheader; ///< Rich header of the current file.
		  CoffSymbolTable m_coffsymtab; ///< Symbol table of the current file.
		  SecurityDirectory m_secdir; ///< Security directory of the current file.
		public:
		  virtual ~PeFile();

		  /// Returns the name of the current file.
		  virtual std::string getFileName() const = 0; // EXPORT
		  /// Changes the name of the current file.
		  virtual void setFileName(const std::string & strFilename) = 0; // EXPORT

		  /// Reads the export directory of the current file from disc.
		  virtual int readExportDirectory() = 0; // EXPORT
		  /// Reads the import directory of the current file from disc.
		  virtual int readImportDirectory() = 0; // EXPORT
		  /// Reads the bound import directory of the current file from disc.
		  virtual int readBoundImportDirectory() = 0; // EXPORT
		  /// Reads the resource directory of the current file from disc.
		  virtual int readResourceDirectory() = 0; // EXPORT
		  /// Reads the relocations directory of the current file from disc.
		  virtual int readRelocationsDirectory() = 0; // EXPORT
		  /// Reads the COM+ descriptor directory of the current file from disc.
		  virtual int readComHeaderDirectory() = 0; // EXPORT
		  /// Reads the IAT directory of the current file from disc.
		  virtual int readIatDirectory() = 0; // EXPORT
		  /// Reads the Debug directory of the current file.
		  virtual int readDebugDirectory() = 0; // EXPORT
		  /// Reads the TLS directory of the current file.
		  virtual int readTlsDirectory() = 0; // EXPORT
		  /// Reads rich header of the current file.
		  virtual int readRichHeader(std::size_t offset, std::size_t size, bool ignoreInvalidKey = false)  = 0; // EXPORT
		  /// Reads the COFF symbol table of the current file.
		  virtual int readCoffSymbolTable(ByteBuffer & fileData) = 0; // EXPORT
		  /// Reads delay import directory of the current file.
		  virtual int readDelayImportDirectory() = 0; // EXPORT
		  /// Reads security directory of the current file.
		  virtual int readSecurityDirectory() = 0; // EXPORT
		  /// Returns a loader error, if there was any
		  virtual LoaderError loaderError() const = 0;

		  virtual unsigned int getBits() const = 0;

		  /// Accessor function for the image loader
		  const ImageLoader & imageLoader() const;
		  /// Accessor function for the MZ header.
		  ImageLoader & imageLoader(); // EXPORT

		  /// Accessor function for the Rich header.
		  const RichHeader& richHeader() const;
		  /// Accessor function for the Rich header.
		  RichHeader& richHeader(); // EXPORT

		  /// Accessor function for the COFF symbol table.
		  const CoffSymbolTable& coffSymTab() const;
		  /// Accessor function for the COFF symbol table.
		  CoffSymbolTable& coffSymTab(); // EXPORT

		  /// Accessor function for the security directory.
		  const SecurityDirectory& securityDir() const;
		  /// Accessor function for the security directory.
		  SecurityDirectory& securityDir();
	};

	/**
	* This class implements the common structures of PE and PE+ files.
	**/
	class PeFileT : public PeFile
	{
		private:

		std::ifstream m_ifStream;                         ///< Valid if we opened the file stream ourself
		std::istream& m_iStream;                          ///< Can also reference m_ifStream

		ExportDirectory m_expdir;                         ///< Export directory of the current file.
		ImportDirectory m_impdir;                         ///< Import directory of the current file.
		BoundImportDirectory m_boundimpdir;               ///< BoundImportDirectory of the current file.
		ResourceDirectory m_resdir;                       ///< ResourceDirectory of the current file.
		RelocationsDirectory m_relocs;                    ///< Relocations directory of the current file.
		ComHeaderDirectory m_comdesc;                     ///< COM+ descriptor directory of the current file.
		IatDirectory m_iat;                               ///< Import address table of the current file.
		DebugDirectory m_debugdir;                        ///< Debug directory of the current file.
		DelayImportDirectory m_delayimpdir;               ///< Delay import directory of the current file.
		TlsDirectory m_tlsdir;                            ///< TLS directory of the current file.
		ConfigDirectory m_configdir;                      ///< Load Config directory

		public:

		PeFileT(const std::string& strFileName);
		PeFileT(std::istream& stream);
		PeFileT();                                        /// Default constructor which exists only for the sake of allowing to construct files without filenames.
		virtual ~PeFileT() {}

		/// Load the PE file using the already-open stream
		int loadPeHeaders(bool loadHeadersOnly = false);

		/// Alternate load - can be used when the data are already loaded to memory to prevent duplicating large buffers
		int loadPeHeaders(ByteBuffer & fileData, bool loadHeadersOnly = false);

		/// returns PEFILE64 or PEFILE32
		int getFileType() const;

		/// Returns the name of the current file.
		std::string getFileName() const;
		/// Changes the name of the current file.
		void setFileName(const std::string & strFilename);

		/// Reads the export directory of the current file from disc.
		int readExportDirectory() ;
		/// Reads the import directory of the current file from disc.
		int readImportDirectory() ;
		/// Reads the bound import directory of the current file from disc.
		int readBoundImportDirectory() ;
		/// Reads the resource directory of the current file from disc.
		int readResourceDirectory() ;
		/// Reads the relocations directory of the current file from disc.
		int readRelocationsDirectory() ;
		/// Reads the COM+ descriptor directory of the current file from disc.
		int readComHeaderDirectory() ;
		/// Reads the IAT directory of the current file from disc.
		int readIatDirectory() ;
		/// Reads the Debug directory of the current file.
		int readDebugDirectory() ;
		/// Reads the TLS directory of the current file.
		int readTlsDirectory() ;
		/// Reads rich header of the current file.
		int readRichHeader(std::size_t offset, std::size_t size, bool ignoreInvalidKey = false) ;
		/// Reads the COFF symbol table of the current file.
		int readCoffSymbolTable(ByteBuffer & fileData);
		/// Reads delay import directory of the current file.
		int readDelayImportDirectory() ;
		/// Reads the security directory of the current file.
		int readSecurityDirectory() ;
		int readLoadConfigDirectory();

		/// Checks the entry point code
		LoaderError checkEntryPointErrors() const;
		LoaderError checkForInMemoryLayout(LoaderError ldrError) const;

		/// Returns a loader error, if there was any
		LoaderError loaderError() const;

		unsigned int getBits() const
		{
		  return m_imageLoader.getImageBitability();
		}

		/// Accessor function for the export directory.
		const ExportDirectory & expDir() const;
		/// Accessor function for the export directory.
		ExportDirectory & expDir(); // EXPORT

		/// Accessor function for the import directory.
		const ImportDirectory & impDir() const;
		/// Accessor function for the import directory.
		ImportDirectory & impDir();

		/// Accessor function for the bound import directory.
		const BoundImportDirectory & boundImpDir() const;
		/// Accessor function for the bound import directory.
		BoundImportDirectory & boundImpDir(); // EXPORT

		/// Accessor function for the resource directory.
		const ResourceDirectory & resDir() const;
		/// Accessor function for the resource directory.
		ResourceDirectory & resDir(); // EXPORT

		/// Accessor function for the relocations directory.
		const RelocationsDirectory & relocDir() const;
		/// Accessor function for the relocations directory.
		RelocationsDirectory & relocDir(); // EXPORT

		/// Accessor function for the COM+ descriptor directory.
		const ComHeaderDirectory & comDir() const;
		/// Accessor function for the COM+ descriptor directory.
		ComHeaderDirectory & comDir(); // EXPORT

		/// Accessor function for the IAT directory.
		const IatDirectory & iatDir() const;
		/// Accessor function for the IAT directory.
		IatDirectory & iatDir(); // EXPORT

		/// Accessor function for the debug directory.
		const DebugDirectory & debugDir() const;
		/// Accessor function for the debug directory.
		DebugDirectory & debugDir(); // EXPORT

		/// Accessor function for the delay import directory.
		const DelayImportDirectory & delayImports() const;
		/// Accessor function for the delay import directory.
		DelayImportDirectory & delayImports(); // EXPORT

		/// Accessor function for the TLS directory.
		const TlsDirectory & tlsDir() const;
		/// Accessor function for the TLS directory.
		TlsDirectory & tlsDir();

		const ConfigDirectory& configDir() const;
		ConfigDirectory& configDir();
	};
}

#endif

```

`debug_remover/include/retdec/pelib/PeLibAux.h`:

```h
/*
* PeLibAux.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_PELIBAUX_H
#define RETDEC_PELIB_PELIBAUX_H

#include <cstdint>
#include <ios>
#include <numeric>
#include <string.h>
#include <string>
#include <vector>
#include <fstream>

#ifdef _MSC_VER						// Reduces number of warnings under MS Visual Studio from ~100000 to zero
#pragma warning(disable:4267)		// C4267: 'initializing': conversion from 'size_t' to '_Ty2', possible loss of data
#pragma warning(disable:4244)		// C4244: 'argument': conversion from 'uint64_t' to 'unsigned int', possible loss of data
#endif

//get rid of duplicate windows.h definitions
#ifdef ERROR_NONE
#undef ERROR_NONE
#endif

namespace PeLib
{
	enum errorCodes
	{
		ERROR_NONE = 0,
		ERROR_OPENING_FILE = -1,
		ERROR_INVALID_FILE = -2,
		ERROR_TOO_MANY_SECTIONS = -3,
		ERROR_NOT_ENOUGH_SPACE = -4,
		ERROR_NO_FILE_ALIGNMENT = -5,
		ERROR_NO_SECTION_ALIGNMENT = -6,
		ERROR_ENTRY_NOT_FOUND = -7,
		ERROR_DUPLICATE_ENTRY = -8,
		ERROR_DIRECTORY_DOES_NOT_EXIST = -9,
		ERROR_COFF_SYMBOL_TABLE_DOES_NOT_EXIST = -10,
		ERROR_SKIP_RESOURCE = -11
	};

	enum LoaderError
	{
		LDR_ERROR_NONE = 0,                         // No error
		LDR_ERROR_FILE_TOO_BIG,                     // The file is larger than 0xFFFFFFFF bytes
		LDR_ERROR_E_LFANEW_UNALIGNED,               // The IMAGE_DOS_HEADER::e_lfanew is not aligned to 4
		LDR_ERROR_E_LFANEW_OUT_OF_FILE,             // The IMAGE_DOS_HEADER::e_lfanew is out of (lower 4 GB of) the file
		LDR_ERROR_NTHEADER_OFFSET_OVERFLOW,         // NT header offset + sizeof(IMAGE_NT_HEADERS) overflow
		LDR_ERROR_NTHEADER_OUT_OF_FILE,             // NT header offset + sizeof(IMAGE_NT_HEADERS) is greater than filesize
		LDR_ERROR_NO_NT_SIGNATURE,                  // Missing IMAGE_NT_SIGNATURE in the NT headers
		LDR_ERROR_FILE_HEADER_INVALID,              // Invalid IMAGE_FILE_HEADER::Machine or IMAGE_FILE_HEADER::SizeOfOptionalHeader
		LDR_ERROR_IMAGE_NON_EXECUTABLE,             // Missing IMAGE_FILE_EXECUTABLE_IMAGE in IMAGE_FILE_HEADER::Characteristics
		LDR_ERROR_NO_OPTHDR_MAGIC,                  // Invalid IMAGE_OPTIONAL_HEADER::Magic
		LDR_ERROR_SIZE_OF_HEADERS_ZERO,             // IMAGE_OPTIONAL_HEADER::SizeOfHeaders is zero
		LDR_ERROR_FILE_ALIGNMENT_ZERO,              // IMAGE_OPTIONAL_HEADER::FileAlignment is zero
		LDR_ERROR_FILE_ALIGNMENT_NOT_POW2,          // IMAGE_OPTIONAL_HEADER::FileAlignment is not power of two
		LDR_ERROR_SECTION_ALIGNMENT_ZERO,           // IMAGE_OPTIONAL_HEADER::SectionAlignment is zero
		LDR_ERROR_SECTION_ALIGNMENT_NOT_POW2,       // IMAGE_OPTIONAL_HEADER::SectionAlignment is not power of two
		LDR_ERROR_SECTION_ALIGNMENT_TOO_SMALL,      // IMAGE_OPTIONAL_HEADER::SectionAlignment is less than IMAGE_OPTIONAL_HEADER::FileAlignment
		LDR_ERROR_SECTION_ALIGNMENT_INVALID,        // IMAGE_OPTIONAL_HEADER::SectionAlignment must be equal to IMAGE_OPTIONAL_HEADER::FileAlignment if (FileAlignment < 512)
		LDR_ERROR_SIZE_OF_IMAGE_TOO_BIG,            // IMAGE_OPTIONAL_HEADER::SizeOfImage is too big
		LDR_ERROR_INVALID_MACHINE32,                // IMAGE_FILE_HEADER::Machine is invalid for IMAGE_OPTIONAL_HEADER::Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC
		LDR_ERROR_INVALID_MACHINE64,                // IMAGE_FILE_HEADER::Machine is invalid for IMAGE_OPTIONAL_HEADER::Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC
		LDR_ERROR_SIZE_OF_HEADERS_INVALID,          // IMAGE_OPTIONAL_HEADER::SizeOfHeaders is greater than IMAGE_OPTIONAL_HEADER::SizeOfImage
		LDR_ERROR_SIZE_OF_OPTHDR_NOT_ALIGNED,       // IMAGE_OPTIONAL_HEADER::SizeOfHeaders is not aligned to 8 (64-bit Windows only)
		LDR_ERROR_SIZE_OF_IMAGE_ZERO,               // Number of PTEs for the entire image is zero
		LDR_ERROR_IMAGE_BASE_NOT_ALIGNED,           // IMAGE_OPTIONAL_HEADER::ImageBase is not aligned to 64KB
		LDR_ERROR_SIZE_OF_IMAGE_PTES_ZERO,          // Number of Page Table Entries for the image is zero
		LDR_ERROR_RAW_DATA_OVERFLOW,                // Overflow in section's raw data size
		LDR_ERROR_SECTION_HEADERS_OUT_OF_IMAGE,     // Section headers are out of the image
		LDR_ERROR_SECTION_HEADERS_OVERFLOW,         // Image with single subsection: size of headers is near the end of range
		LDR_ERROR_SECTION_SIZE_MISMATCH,            // Image with single subsection: virtual values with rawdata values don't match
		LDR_ERROR_INVALID_SECTION_VA,               // Images with normal sections: invalid virtual address of a section
		LDR_ERROR_INVALID_SECTION_VSIZE,            // Images with normal sections: invalid virtual size of a section
		LDR_ERROR_INVALID_SECTION_RAWSIZE,          // Images with normal sections: invalid raw data size
		LDR_ERROR_INVALID_SIZE_OF_IMAGE,            // IMAGE_OPTIONAL_HEADER::SizeOfImage doesn't match the (header+sections)
		LDR_ERROR_FILE_IS_CUT,                      // The PE file is cut
		LDR_ERROR_FILE_IS_CUT_LOADABLE,             // The PE file is cut, but loadable

		// Errors from Import Table parser
		LDR_ERROR_IMPDIR_OUT_OF_FILE,               // Offset of the import directory is out of the file
		LDR_ERROR_IMPDIR_CUT,                       // Import directory is cut
		LDR_ERROR_IMPDIR_COUNT_EXCEEDED,            // Number of import descriptors exceeds maximum
		LDR_ERROR_IMPDIR_NAME_RVA_INVALID,          // RVA of the import name is invalid
		LDR_ERROR_IMPDIR_THUNK_RVA_INVALID,         // RVA of the import thunk is invalid
		LDR_ERROR_IMPDIR_IMPORT_COUNT_EXCEEDED,     // Number of imported functions exceeds maximum

		// Errors from resource parser
		LDR_ERROR_RSRC_OVER_END_OF_IMAGE,           // Array of resource directory entries goes beyond end of the image
		LDR_ERROR_RSRC_NAME_OUT_OF_IMAGE,           // One of the resource names points out of the image
		LDR_ERROR_RSRC_DATA_OUT_OF_IMAGE,           // One of the resource data points out of the image
		LDR_ERROR_RSRC_SUBDIR_OUT_OF_IMAGE,         // One of the resource subdirectories points out of the image

		// Errors from entry point checker
		LDR_ERROR_ENTRY_POINT_OUT_OF_IMAGE,         // The entry point is out of the image
		LDR_ERROR_ENTRY_POINT_ZEROED,               // The entry point is zeroed

		// Errors from signature parser
		LDR_ERROR_DIGITAL_SIGNATURE_CUT,            // The file signature is out of the file
		LDR_ERROR_DIGITAL_SIGNATURE_ZEROED,         // The file signature is zeroed

		// Errors from relocations
		LDR_ERROR_RELOCATIONS_OUT_OF_IMAGE,         // The relocation directory points out of the image
		LDR_ERROR_RELOC_BLOCK_INVALID_VA,           // A relocation block has invalid virtual address
		LDR_ERROR_RELOC_BLOCK_INVALID_LENGTH,       // A relocation block has invalid length
		LDR_ERROR_RELOC_ENTRY_BAD_TYPE,             // A relocation entry has invalid type

		// Other errors
		LDR_ERROR_INMEMORY_IMAGE,                   // The file is a 1:1 in-memory image

		LDR_ERROR_MAX

	};

	struct LoaderErrorInfo
	{
		const char * loaderErrorString;
		const char * loaderErrorUserFriendly;
		bool loadableAnyway;
	};

	class PeFile;

	typedef std::vector<std::uint8_t> ByteBuffer;

	enum
	{
		PEFILE32 = 32,
		PEFILE64 = 64,
		PEFILE_UNKNOWN = 0
	};

	const std::uint16_t PELIB_IMAGE_DOS_SIGNATURE = 0x5A4D;

	const std::uint32_t PELIB_PAGE_SIZE = 0x1000;

	const std::uint32_t PELIB_PAGE_SIZE_SHIFT = 12;

	const std::uint32_t PELIB_SIZE_64KB = 0x10000;

	const std::uint32_t PELIB_SIZE_10MB = 0xA00000;

	const std::uint32_t PELIB_IMAGE_NT_SIGNATURE = 0x00004550;

	const std::uint32_t PELIB_MM_SIZE_OF_LARGEST_IMAGE = 0x77000000;

	const std::uint32_t PELIB_MAX_TLS_CALLBACKS      = 0x100;           // Maximum number of processed TLS callbacks
	const std::uint32_t PELIB_MAX_IMPORT_DLLS        = 0x100;           // Maximum number of imported DLLs we consider OK
	const std::uint32_t PELIB_MAX_IMPORTED_FUNCTIONS = 0x1000;          // Maximum number of exported functions (per DLL) that we support
	const std::uint32_t PELIB_MAX_EXPORTED_FUNCTIONS = 0x1000;          // Maximum number of exported functions that we support
	const std::uint32_t PE_MAX_SECTION_COUNT_XP = 96;
	const std::uint32_t PE_MAX_SECTION_COUNT_7 = 192;

	const std::uint32_t PELIB_IMAGE_DEBUG_INFO_CODEVIEW = 2;

	const std::uint32_t PELIB_SECTOR_SIZE = 0x200;

	const std::uint32_t PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

	const std::uint32_t PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY = 0x80000000;
	const std::uint32_t PELIB_IMAGE_RESOURCE_NAME_IS_STRING = 0x80000000;
	const std::uint32_t PELIB_IMAGE_RESOURCE_RVA_MASK = 0x7FFFFFFF;
	const std::uint16_t PELIB_MAX_RESOURCE_ENTRIES = 0x8000;            // Maximum number of resource directory entries we consider OK

	enum : std::uint32_t
	{
		PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT,		// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_IMPORT,		// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE,		// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_EXCEPTION,
		PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY,
		PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC,	// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG,
		PELIB_IMAGE_DIRECTORY_ENTRY_ARCHITECTURE,
		PELIB_IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
		PELIB_IMAGE_DIRECTORY_ENTRY_TLS,
		PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
		PELIB_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,	// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_IAT,		// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT,
		PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR
	};

	enum : std::uint32_t
	{
		PELIB_PAGE_NOACCESS          = 0x01,
		PELIB_PAGE_READONLY          = 0x02,
		PELIB_PAGE_READWRITE         = 0x04,
		PELIB_PAGE_WRITECOPY         = 0x08,
		PELIB_PAGE_EXECUTE           = 0x10,
		PELIB_PAGE_EXECUTE_READ      = 0x20,
		PELIB_PAGE_EXECUTE_READWRITE = 0x40,
		PELIB_PAGE_EXECUTE_WRITECOPY = 0x80,
	};

	enum : std::uint32_t
	{
		PELIB_IMAGE_SCN_TYPE_NO_PAD		= 0x00000008,
		PELIB_IMAGE_SCN_CNT_CODE		   = 0x00000020,
		PELIB_IMAGE_SCN_CNT_INITIALIZED_DATA	   = 0x00000040,
		PELIB_IMAGE_SCN_CNT_UNINITIALIZED_DATA     = 0x00000080,
		PELIB_IMAGE_SCN_LNK_OTHER		  = 0x00000100,
		PELIB_IMAGE_SCN_LNK_INFO		   = 0x00000200,
		PELIB_IMAGE_SCN_LNK_REMOVE		 = 0x00000800,
		PELIB_IMAGE_SCN_LNK_COMDAT		 = 0x00001000,
		PELIB_IMAGE_SCN_NO_DEFER_SPEC_EXC	  = 0x00004000,
		PELIB_IMAGE_SCN_GPREL		      = 0x00008000,
		PELIB_IMAGE_SCN_MEM_FARDATA		= 0x00008000,
		PELIB_IMAGE_SCN_MEM_PURGEABLE	      = 0x00020000,
		PELIB_IMAGE_SCN_MEM_16BIT		  = 0x00020000,
		PELIB_IMAGE_SCN_MEM_LOCKED		 = 0x00040000,
		PELIB_IMAGE_SCN_MEM_PRELOAD		= 0x00080000,
		PELIB_IMAGE_SCN_ALIGN_1BYTES	       = 0x00100000,
		PELIB_IMAGE_SCN_ALIGN_2BYTES	       = 0x00200000,
		PELIB_IMAGE_SCN_ALIGN_4BYTES	       = 0x00300000,
		PELIB_IMAGE_SCN_ALIGN_8BYTES	       = 0x00400000,
		PELIB_IMAGE_SCN_ALIGN_16BYTES	      = 0x00500000,
		PELIB_IMAGE_SCN_ALIGN_BYTES		= 0x00600000,
		PELIB_IMAGE_SCN_ALIGN_64BYTES	      = 0x00700000,
		PELIB_IMAGE_SCN_ALIGN_128BYTES	     = 0x00800000,
		PELIB_IMAGE_SCN_ALIGN_256BYTES	     = 0x00900000,
		PELIB_IMAGE_SCN_ALIGN_512BYTES	     = 0x00A00000,
		PELIB_IMAGE_SCN_ALIGN_1024BYTES	    = 0x00B00000,
		PELIB_IMAGE_SCN_ALIGN_2048BYTES	    = 0x00C00000,
		PELIB_IMAGE_SCN_ALIGN_4096BYTES	    = 0x00D00000,
		PELIB_IMAGE_SCN_ALIGN_8192BYTES	    = 0x00E00000,
		PELIB_IMAGE_SCN_LNK_NRELOC_OVFL	    = 0x01000000,
		PELIB_IMAGE_SCN_MEM_DISCARDABLE	    = 0x02000000,
		PELIB_IMAGE_SCN_MEM_NOT_CACHED	     = 0x04000000,
		PELIB_IMAGE_SCN_MEM_NOT_PAGED	      = 0x08000000,
		PELIB_IMAGE_SCN_MEM_SHARED		 = 0x10000000,
		PELIB_IMAGE_SCN_MEM_EXECUTE		= 0x20000000,
		PELIB_IMAGE_SCN_MEM_READ		   = 0x40000000,
		PELIB_IMAGE_SCN_MEM_WRITE		  = 0x80000000U
	};

	enum PELIB_IMAGE_FILE_MACHINE : std::uint16_t
	{
		PELIB_IMAGE_FILE_MACHINE_UNKNOWN		= 0,
		PELIB_IMAGE_FILE_MACHINE_I386			= 0x014C,
		PELIB_IMAGE_FILE_MACHINE_I486			= 0x014D,	// https://corkami.googlecode.com/svn/wiki/PE.wiki
		PELIB_IMAGE_FILE_MACHINE_PENTIUM		= 0x014E,	// https://corkami.googlecode.com/svn/wiki/PE.wiki
		PELIB_IMAGE_FILE_MACHINE_R3000_BIG		= 0x0160,
		PELIB_IMAGE_FILE_MACHINE_R3000_LITTLE	= 0x0162,
		PELIB_IMAGE_FILE_MACHINE_R4000			= 0x0166,
		PELIB_IMAGE_FILE_MACHINE_R10000			= 0x0168,
		PELIB_IMAGE_FILE_MACHINE_WCEMIPSV2		= 0x0169,
		PELIB_IMAGE_FILE_MACHINE_ALPHA			= 0x0184,
		PELIB_IMAGE_FILE_MACHINE_SH3			= 0x01A2,
		PELIB_IMAGE_FILE_MACHINE_SH3DSP			= 0x01A3,
		PELIB_IMAGE_FILE_MACHINE_SH3E			= 0x01A4,
		PELIB_IMAGE_FILE_MACHINE_SH4			= 0x01A6,
		PELIB_IMAGE_FILE_MACHINE_SH5			= 0x01A8,
		PELIB_IMAGE_FILE_MACHINE_ARM			= 0x01C0,
		PELIB_IMAGE_FILE_MACHINE_THUMB			= 0x01C2,
		PELIB_IMAGE_FILE_MACHINE_ARMNT			= 0x01C4,
		PELIB_IMAGE_FILE_MACHINE_AM33			= 0x01D3,
		PELIB_IMAGE_FILE_MACHINE_POWERPC		= 0x01F0,
		PELIB_IMAGE_FILE_MACHINE_POWERPCFP		= 0x01F1,
		PELIB_IMAGE_FILE_MACHINE_IA64			= 0x0200,
		PELIB_IMAGE_FILE_MACHINE_MIPS16			= 0x0266,
		PELIB_IMAGE_FILE_MACHINE_MOTOROLA68000	= 0x0268,
		PELIB_IMAGE_FILE_MACHINE_PARISC			= 0x0290,
		PELIB_IMAGE_FILE_MACHINE_ALPHA64		= 0x0284,
		PELIB_IMAGE_FILE_MACHINE_AXP64			= PELIB_IMAGE_FILE_MACHINE_ALPHA64,
		PELIB_IMAGE_FILE_MACHINE_MIPSFPU		= 0x0366,
		PELIB_IMAGE_FILE_MACHINE_MIPSFPU16		= 0x0466,
		PELIB_IMAGE_FILE_MACHINE_TRICORE		= 0x0520,
		PELIB_IMAGE_FILE_MACHINE_EBC			= 0x0EBC,
		PELIB_IMAGE_FILE_MACHINE_AMD64			= 0x8664,
		PELIB_IMAGE_FILE_MACHINE_M32R			= 0x9041,
		PELIB_IMAGE_FILE_MACHINE_ARM64			= 0xAA64,
		PELIB_IMAGE_FILE_MACHINE_MSIL			= 0xC0EE
	};

	enum : std::uint32_t
	{
		PELIB_IMAGE_FILE_RELOCS_STRIPPED	   = 0x0001,
		PELIB_IMAGE_FILE_EXECUTABLE_IMAGE	  = 0x0002,
		PELIB_IMAGE_FILE_LINE_NUMS_STRIPPED	= 0x0004,
		PELIB_IMAGE_FILE_LOCAL_SYMS_STRIPPED       = 0x0008,
		PELIB_IMAGE_FILE_AGGRESSIVE_WS_TRIM	 = 0x0010,
		PELIB_IMAGE_FILE_LARGE_ADDRESS_AWARE       = 0x0020,
		PELIB_IMAGE_FILE_BYTES_REVERSED_LO	 = 0x0080,
		PELIB_IMAGE_FILE_32BIT_MACHINE	     = 0x0100,
		PELIB_IMAGE_FILE_DEBUG_STRIPPED	    = 0x0200,
		PELIB_IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   = 0x0400,
		PELIB_IMAGE_FILE_NET_RUN_FROM_SWAP	 = 0x0800,
		PELIB_IMAGE_FILE_SYSTEM		    = 0x1000,
		PELIB_IMAGE_FILE_DLL		       = 0x2000,
		PELIB_IMAGE_FILE_UP_SYSTEM_ONLY	    = 0x4000,
		PELIB_IMAGE_FILE_BYTES_REVERSED_HI	 = 0x8000
	};

	enum : std::uint16_t
	{
		PELIB_IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE            = 0x0040,
		PELIB_IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY         = 0x0080,
		PELIB_IMAGE_DLLCHARACTERISTICS_NX_COMPAT               = 0x0100,
		PELIB_IMAGE_DLLCHARACTERISTICS_NO_ISOLATION            = 0x0200,
		PELIB_IMAGE_DLLCHARACTERISTICS_NO_SEH                  = 0x0400,
		PELIB_IMAGE_DLLCHARACTERISTICS_NO_BIND                 = 0x0800,
		PELIB_IMAGE_DLLCHARACTERISTICS_APPCONTAINER            = 0x1000,
		PELIB_IMAGE_DLLCHARACTERISTICS_WDM_DRIVER              = 0x2000,
		PELIB_IMAGE_DLLCHARACTERISTICS_GUARD_CF                = 0x4000,
		PELIB_IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE   = 0x8000
	};

	enum : std::uint16_t
	{
		PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC      = 0x10b,
		PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC      = 0x20b,
		PELIB_IMAGE_ROM_OPTIONAL_HDR_MAGIC       = 0x107
	};

	enum : std::uint16_t
	{
		PELIB_IMAGE_SUBSYSTEM_UNKNOWN	      = 0,
		PELIB_IMAGE_SUBSYSTEM_NATIVE	       = 1,
		PELIB_IMAGE_SUBSYSTEM_WINDOWS_GUI	  = 2,
		PELIB_IMAGE_SUBSYSTEM_WINDOWS_CUI	  = 3,
		PELIB_IMAGE_SUBSYSTEM_OS2_CUI	      = 5,
		PELIB_IMAGE_SUBSYSTEM_POSIX_CUI	    = 7,
		PELIB_IMAGE_SUBSYSTEM_NATIVE_WINDOWS       = 8,
		PELIB_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       = 9
	};

	enum : uint16_t
	{
		PELIB_IMAGE_REL_BASED_ABSOLUTE        = 0,
		PELIB_IMAGE_REL_BASED_HIGH            = 1,
		PELIB_IMAGE_REL_BASED_LOW             = 2,
		PELIB_IMAGE_REL_BASED_HIGHLOW         = 3,
		PELIB_IMAGE_REL_BASED_HIGHADJ         = 4,
		PELIB_IMAGE_REL_BASED_MIPS_JMPADDR    = 5,
		PELIB_IMAGE_REL_BASED_IA64_IMM64      = 9,
		PELIB_IMAGE_REL_BASED_DIR64           = 10
	};

	enum : std::uint32_t
	{
		PELIB_RT_CURSOR = 1,		// 1
		PELIB_RT_BITMAP,			// 2
		PELIB_RT_ICON,			// 3
		PELIB_RT_MENU,			// 4
		PELIB_RT_DIALOG,			// 5
		PELIB_RT_STRING,			// 6
		PELIB_RT_FONTDIR,			// 7
		PELIB_RT_FONT,			// 8
		PELIB_RT_ACCELERATOR,		// 9
		PELIB_RT_RCDATA,			// 10
		PELIB_RT_MESSAGETABLE,	// 11
		PELIB_RT_GROUP_CURSOR,	// 12
		PELIB_RT_GROUP_ICON = 14,	// 14
		PELIB_RT_VERSION = 16,
		PELIB_RT_DLGINCLUDE,
		PELIB_RT_PLUGPLAY = 19,
		PELIB_RT_VXD,
		PELIB_RT_ANICURSOR,
		PELIB_RT_ANIICON,
		PELIB_RT_HTML,
		PELIB_RT_MANIFEST,
		PELIB_RT_DLGINIT = 240,
		PELIB_RT_TOOLBAR
	};

	enum : std::uint16_t
	{
		PELIB_LANG_NEUTRAL = 0x00,
		PELIB_LANG_ARABIC = 0x01,
		PELIB_LANG_BULGARIAN = 0x02,
		PELIB_LANG_CATALAN = 0x03,
		PELIB_LANG_CHINESE = 0x04,
		PELIB_LANG_CZECH = 0x05,
		PELIB_LANG_DANISH = 0x06,
		PELIB_LANG_GERMAN = 0x07,
		PELIB_LANG_GREEK = 0x08,
		PELIB_LANG_ENGLISH = 0x09,
		PELIB_LANG_SPANISH = 0x0A,
		PELIB_LANG_FINNISH = 0x0B,
		PELIB_LANG_FRENCH = 0x0C,
		PELIB_LANG_HEBREW = 0x0D,
		PELIB_LANG_HUNGARIAN = 0x0E,
		PELIB_LANG_ICELANDIC = 0x0F,
		PELIB_LANG_ITALIAN = 0x10,
		PELIB_LANG_JAPANESE = 0x11,
		PELIB_LANG_KOREAN = 0x12,
		PELIB_LANG_DUTCH = 0x13,
		PELIB_LANG_NORWEGIAN = 0x14,
		PELIB_LANG_POLISH = 0x15,
		PELIB_LANG_PORTUGUESE = 0x16,
		PELIB_LANG_ROMANIAN = 0x18,
		PELIB_LANG_RUSSIAN = 0x19,
		PELIB_LANG_CROATIAN = 0x1A,
		PELIB_LANG_SERBIAN_NEUTRAL = 0x7C1A,
		PELIB_LANG_BOSNIAN_NEUTRAL = 0x781A,
		PELIB_LANG_SLOVAK = 0x1B,
		PELIB_LANG_ALBANIAN = 0x1C,
		PELIB_LANG_SWEDISH = 0x1D,
		PELIB_LANG_THAI = 0x1E,
		PELIB_LANG_TURKISH = 0x1F,
		PELIB_LANG_URDU = 0x20,
		PELIB_LANG_INDONESIAN = 0x21,
		PELIB_LANG_UKRAINIAN = 0x22,
		PELIB_LANG_BELARUSIAN = 0x23,
		PELIB_LANG_SLOVENIAN = 0x24,
		PELIB_LANG_ESTONIAN = 0x25,
		PELIB_LANG_LATVIAN = 0x26,
		PELIB_LANG_LITHUANIAN = 0x27,
		PELIB_LANG_PERSIAN = 0x29,
		PELIB_LANG_VIETNAMESE = 0x2A,
		PELIB_LANG_ARMENIAN = 0x2B,
		PELIB_LANG_AZERI = 0x2C,
		PELIB_LANG_BASQUE = 0x2D,
		PELIB_LANG_SORBIAN = 0x2E,
		PELIB_LANG_LOWER_SORBIAN = 0x2E,
		PELIB_LANG_UPPER_SORBIAN = 0x2E,
		PELIB_LANG_MACEDONIAN = 0x2F,
		PELIB_LANG_TSWANA = 0x32,
		PELIB_LANG_XHOSA = 0x34,
		PELIB_LANG_ZULU = 0x35,
		PELIB_LANG_AFRIKAANS = 0x36,
		PELIB_LANG_GEORGIAN = 0x37,
		PELIB_LANG_FAEROESE = 0x38,
		PELIB_LANG_HINDI = 0x39,
		PELIB_LANG_MALTESE = 0x3A,
		PELIB_LANG_SAMI = 0x3B,
		PELIB_LANG_IRISH = 0x3C,
		PELIB_LANG_MALAY = 0x3E,
		PELIB_LANG_KAZAK = 0x3F,
		PELIB_LANG_KYRGYZ = 0x40,
		PELIB_LANG_SWAHILI = 0x41,
		PELIB_LANG_UZBEK = 0x43,
		PELIB_LANG_TATAR = 0x44,
		PELIB_LANG_BENGALI = 0x45,
		PELIB_LANG_PUNJABI = 0x46,
		PELIB_LANG_GUJARATI = 0x47,
		PELIB_LANG_ORIYA = 0x48,
		PELIB_LANG_TAMIL = 0x49,
		PELIB_LANG_TELUGU = 0x4A,
		PELIB_LANG_KANNADA = 0x4B,
		PELIB_LANG_MALAYALAM = 0x4C,
		PELIB_LANG_ASSAMESE = 0x4D,
		PELIB_LANG_MARATHI = 0x4E,
		PELIB_LANG_SANSKRIT = 0x4F,
		PELIB_LANG_MONGOLIAN = 0x50,
		PELIB_LANG_TIBETAN = 0x51,
		PELIB_LANG_WELSH = 0x52,
		PELIB_LANG_KHMER = 0x53,
		PELIB_LANG_LAO = 0x54,
		PELIB_LANG_GALICIAN = 0x56,
		PELIB_LANG_KONKANI = 0x57,
		PELIB_LANG_MANIPURI = 0x58,
		PELIB_LANG_SINDHI = 0x59,
		PELIB_LANG_SYRIAC = 0x5A,
		PELIB_LANG_SINHALESE = 0x5B,
		PELIB_LANG_INUKTITUT = 0x5D,
		PELIB_LANG_AMHARIC = 0x5E,
		PELIB_LANG_TAMAZIGHT = 0x5F,
		PELIB_LANG_KASHMIRI = 0x60,
		PELIB_LANG_NEPALI = 0x61,
		PELIB_LANG_FRISIAN = 0x62,
		PELIB_LANG_PASHTO = 0x63,
		PELIB_LANG_FILIPINO = 0x64,
		PELIB_LANG_DIVEHI = 0x65,
		PELIB_LANG_HAUSA = 0x68,
		PELIB_LANG_YORUBA = 0x6A,
		PELIB_LANG_QUECHUA = 0x6B,
		PELIB_LANG_SOTHO = 0x6C,
		PELIB_LANG_BASHKIR = 0x6D,
		PELIB_LANG_LUXEMBOURGISH = 0x6E,
		PELIB_LANG_GREENLANDIC = 0x6F,
		PELIB_LANG_IGBO = 0x70,
		PELIB_LANG_TIGRIGNA = 0x73,
		PELIB_LANG_YI = 0x78,
		PELIB_LANG_MAPUDUNGUN = 0x7A,
		PELIB_LANG_MOHAWK = 0x7C,
		PELIB_LANG_BRETON = 0x7E,
		PELIB_LANG_INVARIANT = 0x7F,
		PELIB_LANG_UIGHUR = 0x80,
		PELIB_LANG_MAORI = 0x81,
		PELIB_LANG_OCCITAN = 0x82,
		PELIB_LANG_CORSICAN = 0x83,
		PELIB_LANG_ALSATIAN = 0x84,
		PELIB_LANG_YAKUT = 0x85,
		PELIB_LANG_KICHE = 0x86,
		PELIB_LANG_KINYARWANDA = 0x87,
		PELIB_LANG_WOLOF = 0x88,
		PELIB_LANG_DARI = 0x8C,
		PELIB_LANG_MALAGASY = 0x8D
	};

	template<typename T>
	unsigned int accumulate(unsigned int size, const T& v)
	{
		return size + v.size();
	}

	class PELIB_IMAGE_FILE_MACHINE_ITERATOR
	{
		public:
		typedef std::vector<PELIB_IMAGE_FILE_MACHINE>::const_iterator imageFileMachineIterator;
		private:
		const std::vector<PELIB_IMAGE_FILE_MACHINE> all =
		{
			PELIB_IMAGE_FILE_MACHINE_UNKNOWN,
			PELIB_IMAGE_FILE_MACHINE_I386,
			PELIB_IMAGE_FILE_MACHINE_I486,
			PELIB_IMAGE_FILE_MACHINE_PENTIUM,
			PELIB_IMAGE_FILE_MACHINE_R3000_BIG,
			PELIB_IMAGE_FILE_MACHINE_R3000_LITTLE,
			PELIB_IMAGE_FILE_MACHINE_R4000,
			PELIB_IMAGE_FILE_MACHINE_R10000,
			PELIB_IMAGE_FILE_MACHINE_WCEMIPSV2,
			PELIB_IMAGE_FILE_MACHINE_ALPHA,
			PELIB_IMAGE_FILE_MACHINE_SH3,
			PELIB_IMAGE_FILE_MACHINE_SH3DSP,
			PELIB_IMAGE_FILE_MACHINE_SH3E,
			PELIB_IMAGE_FILE_MACHINE_SH4,
			PELIB_IMAGE_FILE_MACHINE_SH5,
			PELIB_IMAGE_FILE_MACHINE_ARM,
			PELIB_IMAGE_FILE_MACHINE_THUMB,
			PELIB_IMAGE_FILE_MACHINE_ARMNT,
			PELIB_IMAGE_FILE_MACHINE_AM33,
			PELIB_IMAGE_FILE_MACHINE_POWERPC,
			PELIB_IMAGE_FILE_MACHINE_POWERPCFP,
			PELIB_IMAGE_FILE_MACHINE_IA64,
			PELIB_IMAGE_FILE_MACHINE_MIPS16,
			PELIB_IMAGE_FILE_MACHINE_MOTOROLA68000,
			PELIB_IMAGE_FILE_MACHINE_PARISC,
			PELIB_IMAGE_FILE_MACHINE_ALPHA64,
			PELIB_IMAGE_FILE_MACHINE_AXP64,
			PELIB_IMAGE_FILE_MACHINE_MIPSFPU,
			PELIB_IMAGE_FILE_MACHINE_MIPSFPU16,
			PELIB_IMAGE_FILE_MACHINE_TRICORE,
			PELIB_IMAGE_FILE_MACHINE_EBC,
			PELIB_IMAGE_FILE_MACHINE_AMD64,
			PELIB_IMAGE_FILE_MACHINE_M32R,
			PELIB_IMAGE_FILE_MACHINE_ARM64,
			PELIB_IMAGE_FILE_MACHINE_MSIL
		};
		public:
		PELIB_IMAGE_FILE_MACHINE_ITERATOR();
		~PELIB_IMAGE_FILE_MACHINE_ITERATOR();

		bool isValidMachineCode(PELIB_IMAGE_FILE_MACHINE value) const;
		imageFileMachineIterator begin() const;
		imageFileMachineIterator end() const;
	};

	struct PELIB_IMAGE_DOS_HEADER
	{
		std::uint16_t e_magic;
		std::uint16_t e_cblp;
		std::uint16_t e_cp;
		std::uint16_t e_crlc;
		std::uint16_t e_cparhdr;
		std::uint16_t e_minalloc;
		std::uint16_t e_maxalloc;
		std::uint16_t e_ss;
		std::uint16_t e_sp;
		std::uint16_t e_csum;
		std::uint16_t e_ip;
		std::uint16_t e_cs;
		std::uint16_t e_lfarlc;
		std::uint16_t e_ovno;
		std::uint16_t e_res[4];
		std::uint16_t e_oemid;
		std::uint16_t e_oeminfo;
		std::uint16_t e_res2[10];
		std::uint32_t e_lfanew;

		PELIB_IMAGE_DOS_HEADER()
		{
			memset(this, 0, sizeof(PELIB_IMAGE_DOS_HEADER));
		}

		static inline std::size_t size()
		{
			return 64;
		}
	};

	struct PELIB_IMAGE_FILE_HEADER
	{
		std::uint16_t Machine;
		std::uint16_t NumberOfSections;
		std::uint32_t TimeDateStamp;
		std::uint32_t PointerToSymbolTable;
		std::uint32_t NumberOfSymbols;
		std::uint16_t SizeOfOptionalHeader;
		std::uint16_t Characteristics;

		PELIB_IMAGE_FILE_HEADER()
		{
			Machine = 0;
			NumberOfSections = 0;
			TimeDateStamp = 0;
			PointerToSymbolTable = 0;
			NumberOfSymbols = 0;
			SizeOfOptionalHeader = 0;
			Characteristics = 0;
		}

		static inline std::size_t size()
		{
			return 20;
		}
	};

	struct PELIB_IMAGE_DATA_DIRECTORY
	{
		std::uint32_t VirtualAddress;
		std::uint32_t Size;

		PELIB_IMAGE_DATA_DIRECTORY()
		{
			VirtualAddress = 0;
			Size = 0;
		}

		static inline std::size_t size() {return 8;}
	};

	struct PELIB_IMAGE_OPTIONAL_HEADER32
	{
		std::uint16_t Magic;
		std::uint8_t  MajorLinkerVersion;
		std::uint8_t  MinorLinkerVersion;
		std::uint32_t SizeOfCode;
		std::uint32_t SizeOfInitializedData;
		std::uint32_t SizeOfUninitializedData;
		std::uint32_t AddressOfEntryPoint;
		std::uint32_t BaseOfCode;
		std::uint32_t BaseOfData;
		std::uint32_t ImageBase;
		std::uint32_t SectionAlignment;
		std::uint32_t FileAlignment;
		std::uint16_t MajorOperatingSystemVersion;
		std::uint16_t MinorOperatingSystemVersion;
		std::uint16_t MajorImageVersion;
		std::uint16_t MinorImageVersion;
		std::uint16_t MajorSubsystemVersion;
		std::uint16_t MinorSubsystemVersion;
		std::uint32_t Win32VersionValue;
		std::uint32_t SizeOfImage;
		std::uint32_t SizeOfHeaders;
		std::uint32_t CheckSum;
		std::uint16_t Subsystem;
		std::uint16_t DllCharacteristics;
		std::uint32_t SizeOfStackReserve;
		std::uint32_t SizeOfStackCommit;
		std::uint32_t SizeOfHeapReserve;
		std::uint32_t SizeOfHeapCommit;
		std::uint32_t LoaderFlags;
		std::uint32_t NumberOfRvaAndSizes;

		PELIB_IMAGE_DATA_DIRECTORY DataDirectory[PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
	};

	struct PELIB_IMAGE_OPTIONAL_HEADER64
	{
		std::uint16_t Magic;
		std::uint8_t  MajorLinkerVersion;
		std::uint8_t  MinorLinkerVersion;
		std::uint32_t SizeOfCode;
		std::uint32_t SizeOfInitializedData;
		std::uint32_t SizeOfUninitializedData;
		std::uint32_t AddressOfEntryPoint;
		std::uint32_t BaseOfCode;
		std::uint64_t ImageBase;
		std::uint32_t SectionAlignment;
		std::uint32_t FileAlignment;
		std::uint16_t MajorOperatingSystemVersion;
		std::uint16_t MinorOperatingSystemVersion;
		std::uint16_t MajorImageVersion;
		std::uint16_t MinorImageVersion;
		std::uint16_t MajorSubsystemVersion;
		std::uint16_t MinorSubsystemVersion;
		std::uint32_t Win32VersionValue;
		std::uint32_t SizeOfImage;
		std::uint32_t SizeOfHeaders;
		std::uint32_t CheckSum;
		std::uint16_t Subsystem;
		std::uint16_t DllCharacteristics;
		std::uint64_t SizeOfStackReserve;
		std::uint64_t SizeOfStackCommit;
		std::uint64_t SizeOfHeapReserve;
		std::uint64_t SizeOfHeapCommit;
		std::uint32_t LoaderFlags;
		std::uint32_t NumberOfRvaAndSizes;

		PELIB_IMAGE_DATA_DIRECTORY DataDirectory[PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
	};

	// Common structure for both 32-bit and 64-bit PE files
	struct PELIB_IMAGE_OPTIONAL_HEADER
	{
		std::uint16_t Magic;
		std::uint8_t  MajorLinkerVersion;
		std::uint8_t  MinorLinkerVersion;
		std::uint32_t SizeOfCode;
		std::uint32_t SizeOfInitializedData;
		std::uint32_t SizeOfUninitializedData;
		std::uint32_t AddressOfEntryPoint;
		std::uint32_t BaseOfCode;
		std::uint32_t BaseOfData;
		std::uint64_t ImageBase;
		std::uint32_t SectionAlignment;
		std::uint32_t FileAlignment;
		std::uint16_t MajorOperatingSystemVersion;
		std::uint16_t MinorOperatingSystemVersion;
		std::uint16_t MajorImageVersion;
		std::uint16_t MinorImageVersion;
		std::uint16_t MajorSubsystemVersion;
		std::uint16_t MinorSubsystemVersion;
		std::uint32_t Win32VersionValue;
		std::uint32_t SizeOfImage;
		std::uint32_t SizeOfHeaders;
		std::uint32_t CheckSum;
		std::uint16_t Subsystem;
		std::uint16_t DllCharacteristics;
		std::uint64_t SizeOfStackReserve;
		std::uint64_t SizeOfStackCommit;
		std::uint64_t SizeOfHeapReserve;
		std::uint64_t SizeOfHeapCommit;
		std::uint32_t LoaderFlags;
		std::uint32_t NumberOfRvaAndSizes;

		PELIB_IMAGE_DATA_DIRECTORY DataDirectory[PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
	};

	template<int x>
	struct PELIB_IMAGE_NT_HEADERS_EX
	{
		std::uint32_t Signature;
		PELIB_IMAGE_FILE_HEADER FileHeader;
		PELIB_IMAGE_OPTIONAL_HEADER OptionalHeader;
		std::vector<PELIB_IMAGE_DATA_DIRECTORY> dataDirectories;
		bool lastDirectoryIsIncomplete;

		unsigned int sizeOfSignature() const
		{
			return sizeof(std::uint32_t);
		}

		unsigned int size() const
		{
			return sizeOfSignature()
				+ PELIB_IMAGE_FILE_HEADER::size()
				+ sizeof(PELIB_IMAGE_OPTIONAL_HEADER)
				+ static_cast<unsigned int>(dataDirectories.size()) * PELIB_IMAGE_DATA_DIRECTORY::size();
		}

		unsigned int loadedSize() const
		{
			auto res = size();
			if (lastDirectoryIsIncomplete && !dataDirectories.empty())
			{
				res -= sizeof(dataDirectories[0].Size);
			}

			return res;
		}

		PELIB_IMAGE_NT_HEADERS_EX()
		{
			Signature = 0;
			lastDirectoryIsIncomplete = false;
		}
	};

	const unsigned int PELIB_IMAGE_SIZEOF_SHORT_NAME  = 8;
	const unsigned int PELIB_IMAGE_SIZEOF_MAX_NAME    = 1024;

	struct PELIB_IMAGE_SECTION_HEADER
	{
		PELIB_IMAGE_SECTION_HEADER()
		{
			memset(Name, 0, sizeof(Name));
			VirtualSize = 0;
			VirtualAddress = 0;
			SizeOfRawData = 0;
			PointerToRawData = 0;
			PointerToRelocations = 0;
			PointerToLinenumbers = 0;
			NumberOfRelocations = 0;
			NumberOfLinenumbers = 0;
			Characteristics = 0;
		}

		std::uint8_t  Name[PELIB_IMAGE_SIZEOF_SHORT_NAME];
		std::uint32_t VirtualSize;
		std::uint32_t VirtualAddress;
		std::uint32_t SizeOfRawData;
		std::uint32_t PointerToRawData;
		std::uint32_t PointerToRelocations;
		std::uint32_t PointerToLinenumbers;
		std::uint16_t NumberOfRelocations;
		std::uint16_t NumberOfLinenumbers;
		std::uint32_t Characteristics;
	};

	struct PELIB_SECTION_HEADER : public PELIB_IMAGE_SECTION_HEADER
	{
		void setName(const char * newName)
		{
			// Copy the name to the fixed_length name
			memset(Name, 0, PELIB_IMAGE_SIZEOF_SHORT_NAME);
			for(std::size_t i = 0; i < PELIB_IMAGE_SIZEOF_SHORT_NAME; i++)
			{
				if(newName[i] == 0)
					break;
				Name[i] = newName[i];
			}

			// Also put it to the string
			sectionName = newName;
		}

		const std::string & getName() const
		{
			return sectionName;
		}

		void setVirtualRange(std::uint32_t newVirtualAddress, std::uint32_t newVirtualSize)
		{
			if(newVirtualAddress != UINT32_MAX)
				VirtualAddress = newVirtualAddress;
			if(newVirtualSize != UINT32_MAX)
				VirtualSize = newVirtualSize;
		}

		void setRawDataRange(std::uint32_t newPointerToRawData, std::uint32_t newSizeOfRawData)
		{
			if(newPointerToRawData != UINT32_MAX)
				PointerToRawData = newPointerToRawData;
			if(newSizeOfRawData != UINT32_MAX)
				SizeOfRawData = newSizeOfRawData;
		}

		static const std::size_t size()
		{
			return sizeof(PELIB_IMAGE_SECTION_HEADER);
		}

		std::string sectionName;
	};

	struct PELIB_IMAGE_THUNK_DATA
	{
		std::uint64_t Ordinal;

		PELIB_IMAGE_THUNK_DATA()
		{
			Ordinal = 0;
		}
	};

	struct PELIB_IMAGE_IMPORT_DESCRIPTOR
	{
		std::uint32_t	OriginalFirstThunk;
		std::uint32_t	TimeDateStamp;
		std::uint32_t	ForwarderChain;
		std::uint32_t	Name;
		std::uint32_t	FirstThunk;

		PELIB_IMAGE_IMPORT_DESCRIPTOR()
		{
			OriginalFirstThunk = 0;
			TimeDateStamp = 0;
			ForwarderChain = 0;
			Name = 0;
			FirstThunk = 0;
		}

		static inline std::size_t size() {return 20;}
	};

	struct PELIB_IMAGE_EXPORT_DIRECTORY
	{
		std::uint32_t	Characteristics;
		std::uint32_t	TimeDateStamp;
		std::uint16_t	MajorVersion;
		std::uint16_t	MinorVersion;
		std::uint32_t	Name;
		std::uint32_t	Base;
		std::uint32_t	NumberOfFunctions;
		std::uint32_t	NumberOfNames;
		std::uint32_t	AddressOfFunctions;
		std::uint32_t	AddressOfNames;
		std::uint32_t	AddressOfNameOrdinals;

		PELIB_IMAGE_EXPORT_DIRECTORY()
		{
			Characteristics = 0;
			TimeDateStamp = 0;
			MajorVersion = 0;
			MinorVersion = 0;
			Name = 0;
			Base = 0;
			NumberOfFunctions = 0;
			NumberOfNames = 0;
			AddressOfFunctions = 0;
			AddressOfNames = 0;
			AddressOfNameOrdinals = 0;
		}

		static inline std::size_t size()
		{
			return sizeof(PELIB_IMAGE_EXPORT_DIRECTORY);
		}
	};

	struct PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR
	{
		std::uint32_t	TimeDateStamp;
		std::uint16_t	OffsetModuleName;
		std::uint16_t	NumberOfModuleForwarderRefs;

		PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR()
		{
			TimeDateStamp = 0;
			OffsetModuleName = 0;
			NumberOfModuleForwarderRefs = 0;
		}

		static inline std::size_t size()
		{
			return 8;
		}
	};

	// Stores all necessary information about a BoundImport field.
	struct PELIB_IMAGE_BOUND_DIRECTORY
	{
		PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR ibdDescriptor; ///< Information about the imported file.
		std::string strModuleName; ///< Name of the imported file.
		std::vector<PELIB_IMAGE_BOUND_DIRECTORY> moduleForwarders;

		// Will be used in std::find_if
		// Passing by-reference not possible (see C++ Standard Core Language Defect Reports, Revision 29, Issue 106)
		/// Compares the passed filename to the struct's filename.
		bool equal(const std::string strModuleName2) const;

		std::size_t size() const;
	};

	struct PELIB_EXP_FUNC_INFORMATION
	{
		std::uint32_t addroffunc;
		std::uint32_t addrofname;
		std::uint16_t ordinal;
		std::string funcname;

		PELIB_EXP_FUNC_INFORMATION();

		bool equal(const std::string strFunctionName) const;
		inline unsigned int size() const
		{
			unsigned int uiSize = 4;
			if (addroffunc) uiSize += 2;// + 4;
			if (!funcname.empty())
				uiSize = (unsigned int)(uiSize + 4 + funcname.size() + 1);
			return uiSize;
		}
	};

	struct PELIB_IMAGE_RESOURCE_DIRECTORY
	{
		std::uint32_t	Characteristics;
		std::uint32_t	TimeDateStamp;
		std::uint16_t	MajorVersion;
		std::uint16_t	MinorVersion;
		std::uint16_t	NumberOfNamedEntries;
		std::uint16_t	NumberOfIdEntries;

		PELIB_IMAGE_RESOURCE_DIRECTORY();

		static inline std::size_t size() {return 16;}
	};

	struct PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY
	{
		std::uint32_t	Name;
		std::uint32_t	OffsetToData;

		PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY();

		static inline std::size_t size() {return 8;}
	};

	const unsigned int PELIB_IMAGE_SIZEOF_BASE_RELOCATION = 8;

	struct PELIB_IMG_RES_DIR_ENTRY
	{
		PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY irde;
		std::string wstrName;

		bool operator<(const PELIB_IMG_RES_DIR_ENTRY& first) const;

	};

	struct PELIB_IMAGE_BASE_RELOCATION
	{
		std::uint32_t	VirtualAddress;
		std::uint32_t	SizeOfBlock;

		PELIB_IMAGE_BASE_RELOCATION()
		{
			VirtualAddress = 0;
			SizeOfBlock = 0;
		}

		static inline std::size_t size() {return 72;}
	};

	struct PELIB_IMAGE_COR20_HEADER
	{
		std::uint32_t	cb;
		std::uint16_t	MajorRuntimeVersion;
		std::uint16_t	MinorRuntimeVersion;
		PELIB_IMAGE_DATA_DIRECTORY MetaData;
		std::uint32_t	Flags;
		std::uint32_t	EntryPointToken;
		PELIB_IMAGE_DATA_DIRECTORY Resources;
		PELIB_IMAGE_DATA_DIRECTORY StrongNameSignature;
		PELIB_IMAGE_DATA_DIRECTORY CodeManagerTable;
		PELIB_IMAGE_DATA_DIRECTORY VTableFixups;
		PELIB_IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
		PELIB_IMAGE_DATA_DIRECTORY ManagedNativeHeader;

		PELIB_IMAGE_COR20_HEADER();
		static inline std::size_t size() {return 72;}
	};

	// Used to store a file's export table.
	struct PELIB_IMAGE_EXP_DIRECTORY
	{
		/// The IMAGE_EXPORTED_DIRECTORY of a file's export table.
		PELIB_IMAGE_EXPORT_DIRECTORY ied;
		/// The original filename of current file.
		std::string name;
		std::vector<PELIB_EXP_FUNC_INFORMATION> functions;

		inline std::size_t size() const
		{
			return (PELIB_IMAGE_EXPORT_DIRECTORY::size() + name.size() + 1 +
			std::accumulate(functions.begin(), functions.end(), 0, accumulate<PELIB_EXP_FUNC_INFORMATION>));
		}
	};

	bool isEqualNc(const std::string& s1, const std::string& s2);

	// Used for parsing a file's import table. It combines the function name, the hint
	// and the IMAGE_THUNK_DATA of an imported function.
	struct PELIB_THUNK_DATA
	{
		/// The IMAGE_THUNK_DATA struct of an imported function.
		PELIB_IMAGE_THUNK_DATA itd;
		/// The function name of an imported function.
		std::string fname;
		/// The RVA of the patched address (from the FirstThunk)
		std::uint32_t patchRva;
		/// The hint of an imported function (only if imported by name)
		std::uint16_t hint;

		PELIB_THUNK_DATA()
		{
			patchRva = 0;
			hint = 0;
		}

		bool equalHint(std::uint16_t wHint) const
		{
			return hint == wHint;
//			return itd.Ordinal == (wHint | PELIB_IMAGE_ORDINAL_FLAGS<bits>::PELIB_IMAGE_ORDINAL_FLAG);
		}

		bool equalFunctionName(std::string strFunctionName) const
		{
			return isEqualNc(fname, strFunctionName);
		}

		std::uint32_t calculateSize(std::uint32_t pointerSize) const
		{
			return pointerSize + fname.size() + 1 + sizeof(hint);
		}
	};

	struct PELIB_DELAY_IMPORT
	{
		std::uint64_t address;
		std::uint16_t hint;
		std::string fname;

		PELIB_DELAY_IMPORT() : hint(0)
		{

		}
	};

	// Used to store a file's import table. Every struct of this sort
	// can store import information of one DLL.
	struct PELIB_IMAGE_IMPORT_DIRECTORY
	{
		/// The IMAGE_IMPORT_DESCRIPTOR of an imported DLL.
		PELIB_IMAGE_IMPORT_DESCRIPTOR impdesc;
		/// The name of an imported DLL.
		std::string name;
		/// The list of functions imported from the DLL
		//std::vector<PELIB_THUNK_DATA> originalfirstthunk;
		//std::vector<PELIB_THUNK_DATA> firstthunk;
		std::vector<PELIB_THUNK_DATA> thunk_data;

		inline std::uint32_t calculateSize(std::uint32_t pointerSize) const
		{
			std::uint32_t totalSize = sizeof(PELIB_IMAGE_IMPORT_DESCRIPTOR) + name.size() + 1;  // descriptor + dllname

			for(const auto & element : thunk_data)
				totalSize += element.calculateSize(pointerSize);
			return totalSize + pointerSize;                            // Add zero-termination
		}

		bool operator==(std::string strFilename) const
		{
			return isEqualNc(this->name, strFilename);
		}
	};

	const std::size_t IMPORT_LIBRARY_MAX_LENGTH = 256;
	const std::size_t IMPORT_SYMBOL_MAX_LENGTH = 256;

	struct PELIB_IMAGE_RESOURCE_DATA_ENTRY
	{
		std::uint32_t	OffsetToData;
		std::uint32_t	Size;
		std::uint32_t	CodePage;
		std::uint32_t	Reserved;

		static inline unsigned int size() {return 16;}

		PELIB_IMAGE_RESOURCE_DATA_ENTRY();
	};

	struct PELIB_IMAGE_RESOURCE_DATA
	{
		PELIB_IMAGE_RESOURCE_DATA_ENTRY irdEntry;
		std::vector<std::uint8_t> vData;
	};

	struct IMG_BASE_RELOC
	{
		PELIB_IMAGE_BASE_RELOCATION ibrRelocation;
		std::vector<std::uint16_t> vRelocData;
	};

	struct PELIB_IMAGE_DEBUG_DIRECTORY
	{
		std::uint32_t	Characteristics;
		std::uint32_t	TimeDateStamp;
		std::uint16_t	MajorVersion;
		std::uint16_t	MinorVersion;
		std::uint32_t	Type;
		std::uint32_t	SizeOfData;
		std::uint32_t	AddressOfRawData;
		std::uint32_t	PointerToRawData;

		static std::size_t size() {return 28;}

		PELIB_IMAGE_DEBUG_DIRECTORY();
	};

	struct PELIB_IMG_DEBUG_DIRECTORY
	{
		PELIB_IMAGE_DEBUG_DIRECTORY idd;
		std::vector<std::uint8_t> data;
	};

	struct PELIB_IMAGE_TLS_DIRECTORY32
	{
		std::uint32_t StartAddressOfRawData;
		std::uint32_t EndAddressOfRawData;
		std::uint32_t AddressOfIndex;
		std::uint32_t AddressOfCallBacks;
		std::uint32_t SizeOfZeroFill;
		std::uint32_t Characteristics;
	};

	struct PELIB_IMAGE_TLS_DIRECTORY
	{
		std::uint64_t StartAddressOfRawData;
		std::uint64_t EndAddressOfRawData;
		std::uint64_t AddressOfIndex;
		std::uint64_t AddressOfCallBacks;
		std::uint32_t SizeOfZeroFill;
		std::uint32_t Characteristics;

		PELIB_IMAGE_TLS_DIRECTORY()
		{
			StartAddressOfRawData = 0;
			EndAddressOfRawData = 0;
			AddressOfIndex = 0;
			AddressOfCallBacks = 0;
			SizeOfZeroFill = 0;
			Characteristics = 0;
		}
	};

	std::uint32_t BytesToPages(std::uint32_t ByteSize);
	std::uint32_t AlignToSize(std::uint32_t ByteSize, std::uint32_t AlignSize);

	std::uint64_t fileSize(const std::string& filename);
	std::uint64_t fileSize(std::istream& stream);
	std::uint64_t fileSize(std::ofstream& file);
	std::uint64_t fileSize(std::fstream& file);
	unsigned int alignOffset(unsigned int uiOffset, unsigned int uiAlignment);
	std::size_t getStringFromFileOffset(
			std::istream &stream,
			std::string &result,
			std::size_t fileOffset,
			std::size_t maxLength = 0,
			bool isPrintable = false,
			bool isNotTooLong = false);

	const char * getLoaderErrorString(LoaderError ldrError, bool userFriendly = false);
	bool getLoaderErrorLoadableAnyway(LoaderError ldrError);

  /*  enum MzHeader_Field {e_magic, e_cblp, e_cp, e_crlc, e_cparhdr, e_minalloc, e_maxalloc,
						e_ss, e_sp, e_csum, e_ip, e_cs, e_lfarlc, e_ovno, e_res, e_oemid,
						e_oeminfo, e_res2, e_lfanew};
	enum PeHeader_Field {NtSignature, Machine, NumberOfSections, TimeDateStamp, PointerToSymbolTable,
						NumberOfSymbols, SizeOfOptionalHeader, Characteristics, Magic,
						MajorLinkerVersion, MinorLinkerVersion, SizeOfCode, SizeOfInitializedData,
						SizeOfUninitializedData, AddressOfEntryPoint, BaseOfCode, BaseOfData, ImageBase,
						SectionAlignment, FileAlignment, MajorOperatingSystemVersion, MinorOperatingSystemVersion,
						MajorImageVersion, MinorImageVersion, MajorSubsystemVersion, MinorSubsystemVersion,
						Win32VersionValue, SizeOfImage, SizeOfHeaders, CheckSum, Subsystem, DllCharacteristics,
						SizeOfStackReserve, SizeOfStackCommit, SizeOfHeapReserve, SizeOfHeapCommit,
						LoaderFlags, NumberOfRvaAndSizes, DataDirectoryRva, DataDirectorySize};
	enum Section_Field {SectionName, VirtualSize, VirtualAddress, SizeOfRawData, PointerToRawData, PointerToRelocations,
						PointerToLinenumbers, NumberOfRelocations, NumberOfLinenumbers, SectionCharacteristics};
*/

	const unsigned int PELIB_IMAGE_SIZEOF_COFF_SYMBOL = 18;
	const std::size_t COFF_SYMBOL_NAME_MAX_LENGTH = 256;

	struct PELIB_IMAGE_COFF_SYMBOL
	{
		std::uint32_t Index;
		std::string Name;
		std::uint32_t Value;
		std::uint16_t SectionNumber;
		std::uint8_t TypeComplex;
		std::uint8_t TypeSimple;
		std::uint8_t StorageClass;
		std::uint8_t NumberOfAuxSymbols;

		PELIB_IMAGE_COFF_SYMBOL() : Index(0), Value(0), SectionNumber(0),
			TypeComplex(0), TypeSimple(0), StorageClass(0), NumberOfAuxSymbols(0)
		{

		}
	};

	struct PELIB_IMAGE_RICH_HEADER_RECORD
	{
		std::string Signature;
		std::uint16_t ProductId;
		std::uint16_t ProductBuild;
		std::uint32_t Count;
		std::string ProductName;
		std::string VisualStudioName;

		PELIB_IMAGE_RICH_HEADER_RECORD() : ProductId(0), ProductBuild(0), Count(0)
		{

		}
	};

	struct PELIB_IMAGE_LOAD_CONFIG_CODE_INTEGRITY
	{
		std::uint16_t Flags;                         // Flags to indicate if CI information is available, etc.
		std::uint16_t Catalog;                       // 0xFFFF means not available
		std::uint32_t CatalogOffset;
		std::uint32_t Reserved;                      // Additional bitmask to be defined later
	};

	// Load config directory
	struct PELIB_IMAGE_LOAD_CONFIG_DIRECTORY32
	{
		std::uint32_t Size;
		std::uint32_t TimeDateStamp;
		std::uint16_t MajorVersion;
		std::uint16_t MinorVersion;
		std::uint32_t GlobalFlagsClear;
		std::uint32_t GlobalFlagsSet;
		std::uint32_t CriticalSectionDefaultTimeout;
		std::uint32_t DeCommitFreeBlockThreshold;
		std::uint32_t DeCommitTotalFreeThreshold;
		std::uint32_t LockPrefixTable;
		std::uint32_t MaximumAllocationSize;
		std::uint32_t VirtualMemoryThreshold;
		std::uint32_t ProcessHeapFlags;
		std::uint32_t ProcessAffinityMask;
		std::uint16_t CSDVersion;
		std::uint16_t DependentLoadFlags;
		std::uint32_t EditList;
		std::uint32_t SecurityCookie;
		std::uint32_t SEHandlerTable;
		std::uint32_t SEHandlerCount;
		std::uint32_t GuardCFCheckFunctionPointer;
		std::uint32_t GuardCFDispatchFunctionPointer;
		std::uint32_t GuardCFFunctionTable;
		std::uint32_t GuardCFFunctionCount;
		std::uint32_t GuardFlags;
		PELIB_IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
		std::uint32_t GuardAddressTakenIatEntryTable;
		std::uint32_t GuardAddressTakenIatEntryCount;
		std::uint32_t GuardLongJumpTargetTable;
		std::uint32_t GuardLongJumpTargetCount;
		std::uint32_t DynamicValueRelocTable;
		std::uint32_t CHPEMetadataPointer;
		std::uint32_t GuardRFFailureRoutine;
		std::uint32_t GuardRFFailureRoutineFunctionPointer;
		std::uint32_t DynamicValueRelocTableOffset;
		std::uint16_t DynamicValueRelocTableSection;
		std::uint16_t Reserved2;
		std::uint32_t GuardRFVerifyStackPointerFunctionPointer;
		std::uint32_t HotPatchTableOffset;
		std::uint32_t Reserved3;
		std::uint32_t EnclaveConfigurationPointer;
		std::uint32_t VolatileMetadataPointer;
		std::uint32_t GuardEHContinuationTable;
		std::uint32_t GuardEHContinuationCount;
	};

	struct PELIB_IMAGE_LOAD_CONFIG_DIRECTORY64
	{
		std::uint32_t Size;
		std::uint32_t TimeDateStamp;
		std::uint16_t MajorVersion;
		std::uint16_t MinorVersion;
		std::uint32_t GlobalFlagsClear;
		std::uint32_t GlobalFlagsSet;
		std::uint32_t CriticalSectionDefaultTimeout;
		std::uint64_t DeCommitFreeBlockThreshold;
		std::uint64_t DeCommitTotalFreeThreshold;
		std::uint64_t LockPrefixTable;
		std::uint64_t MaximumAllocationSize;
		std::uint64_t VirtualMemoryThreshold;
		std::uint64_t ProcessAffinityMask;
		std::uint32_t ProcessHeapFlags;
		std::uint16_t CSDVersion;
		std::uint16_t DependentLoadFlags;
		std::uint64_t EditList;
		std::uint64_t SecurityCookie;
		std::uint64_t SEHandlerTable;
		std::uint64_t SEHandlerCount;
		std::uint64_t GuardCFCheckFunctionPointer;
		std::uint64_t GuardCFDispatchFunctionPointer;
		std::uint64_t GuardCFFunctionTable;
		std::uint64_t GuardCFFunctionCount;
		std::uint32_t GuardFlags;
		PELIB_IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
		std::uint64_t GuardAddressTakenIatEntryTable;
		std::uint64_t GuardAddressTakenIatEntryCount;
		std::uint64_t GuardLongJumpTargetTable;
		std::uint64_t GuardLongJumpTargetCount;
		std::uint64_t DynamicValueRelocTable;
		std::uint64_t CHPEMetadataPointer;
		std::uint64_t GuardRFFailureRoutine;
		std::uint64_t GuardRFFailureRoutineFunctionPointer;
		std::uint32_t DynamicValueRelocTableOffset;
		std::uint16_t DynamicValueRelocTableSection;
		std::uint16_t Reserved2;
		std::uint64_t GuardRFVerifyStackPointerFunctionPointer;
		std::uint32_t HotPatchTableOffset;
		std::uint32_t Reserved3;
		std::uint64_t EnclaveConfigurationPointer;
		std::uint64_t VolatileMetadataPointer;
		std::uint64_t GuardEHContinuationTable;
		std::uint64_t GuardEHContinuationCount;
	};

	// This structure is defined in the "delayimp.h" header file as ImgDelayDescrV1 or ImgDelayDescrV2.
	// Fields suffixed with "Rva" are direct virtual addresses in the "V1" version of the structure.
	struct PELIB_IMAGE_DELAY_LOAD_DESCRIPTOR
	{
		std::uint32_t Attributes;                           // Attributes. See PELIB_DELAY_ATTRIBUTE_XXX for more info
		std::uint32_t NameRva;                              // RVA to dll name
		std::uint32_t ModuleHandleRva;                      // RVA of module handle
		std::uint32_t DelayImportAddressTableRva;           // RVA of the IAT
		std::uint32_t DelayImportNameTableRva;              // RVA of the INT
		std::uint32_t BoundDelayImportTableRva;             // RVA of the optional bound IAT
		std::uint32_t UnloadDelayImportTableRva;            // RVA of optional copy of original IAT
		std::uint32_t TimeStamp;                            // 0 if not bound, O.W. date/time stamp of DLL bound to (Old BIND)
	};

	const std::uint32_t PELIB_DELAY_ATTRIBUTE_V2 = 0x01;	// If this bit is set, then the structure is version 2

	struct PELIB_IMAGE_DELAY_IMPORT_DIRECTORY_RECORD
	{
		private:
			typedef typename std::vector<PELIB_DELAY_IMPORT>::const_iterator DelayImportIterator;
			bool hasOrdinalNumbers;
			std::vector<PELIB_DELAY_IMPORT> Functions;

		public:
			PELIB_IMAGE_DELAY_LOAD_DESCRIPTOR delayedImport;
			std::string Name;

			PELIB_IMAGE_DELAY_IMPORT_DIRECTORY_RECORD()
			{
				init();
			}

			~PELIB_IMAGE_DELAY_IMPORT_DIRECTORY_RECORD()
			{

			}

			void init()
			{
				memset(&delayedImport, 0, sizeof(PELIB_IMAGE_DELAY_LOAD_DESCRIPTOR));
				hasOrdinalNumbers = false;
				Functions.clear();
				Name.clear();
			}

			void addFunction(const PELIB_DELAY_IMPORT &function)
			{
				Functions.push_back(function);
				if(function.hint)
				{
					hasOrdinalNumbers = true;
				}
			}

			auto ordinalNumbersAreValid() const
			{
				return hasOrdinalNumbers;
			}

			auto getNumberOfFunctions() const
			{
				return Functions.size();
			}

			const PELIB_DELAY_IMPORT *getFunction(std::size_t index) const
			{
				return index < getNumberOfFunctions() ? &Functions[index] : nullptr;
			}

			PELIB_DELAY_IMPORT *getFunction(std::size_t index)
			{
				return index < getNumberOfFunctions() ? &Functions[index] : nullptr;
			}

			const DelayImportIterator begin() const
			{
				return Functions.begin();
			}

			DelayImportIterator begin()
			{
				return Functions.begin();
			}

			const DelayImportIterator end() const
			{
				return Functions.end();
			}

			DelayImportIterator end()
			{
				return Functions.end();
			}
	};

	enum
	{
		PELIB_WIN_CERT_REVISION_1_0 = 0x100,
		PELIB_WIN_CERT_REVISION_2_0 = 0x200
	};

	enum
	{
		PELIB_WIN_CERT_TYPE_X509 = 1,
		PELIB_WIN_CERT_TYPE_PKCS_SIGNED_DATA = 2,
		PELIB_WIN_CERT_TYPE_RESERVED_1 = 3,
		PELIB_WIN_CERT_TYPE_TS_STACK_SIGNED = 4
	};

	struct PELIB_IMAGE_CERTIFICATE_ENTRY
	{
		std::uint32_t Length;
		std::uint16_t Revision;
		std::uint16_t CertificateType;
		std::vector<unsigned char> Certificate;

		static inline unsigned int size() { return 8; }
	};
}

class IStreamWrapper
{
	public:
		IStreamWrapper(std::istream& stream) :
				_stream(stream)
		{
			_pos = _stream.tellg();
			_state = _stream.rdstate();
			_stream.clear();
		}

		~IStreamWrapper()
		{
			_stream.setstate(_state);
			_stream.seekg(_pos, std::ios::beg);
		}

		operator std::istream&() const
		{
			return _stream;
		}
		std::istream& getIstream()
		{
			return _stream;
		}

		// Needed wrapped methods.
		//
		explicit operator bool() const
		{
			return static_cast<bool>(_stream);
		}

		IStreamWrapper& seekg(std::streampos pos)
		{
			_stream.seekg(pos);
			return *this;
		}

		IStreamWrapper& seekg(std::streamoff off, std::ios_base::seekdir way)
		{
			_stream.seekg(off, way);
			return *this;
		}

		std::streampos tellg()
		{
			return _stream.tellg();
		}

		IStreamWrapper& read(char* s, std::streamsize n)
		{
			_stream.read(s, n);
			return *this;
		}

		std::streamsize gcount() const
		{
			return _stream.gcount();
		}

		void clear(std::ios_base::iostate state = std::ios_base::goodbit)
		{
			return _stream.clear(state);
		}

	private:
		std::istream& _stream;
		std::streampos _pos;
		std::ios::iostate _state;
};

#endif

```

`debug_remover/include/retdec/pelib/PeLibInc.h`:

```h
/*
* PeLibInc.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_PELIBINC_H
#define RETDEC_PELIB_PELIBINC_H

#include <algorithm>
#include <climits>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <functional>

#include "retdec/pelib/InputBuffer.h"
#include "retdec/pelib/OutputBuffer.h"
#include "retdec/pelib/PeLibAux.h"

#endif

```

`debug_remover/include/retdec/pelib/RelocationsDirectory.h`:

```h
/*
* Relocations.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_RELOCATIONSDIRECTORY_H
#define RETDEC_PELIB_RELOCATIONSDIRECTORY_H

#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	/// Class that handles the relocations directory.
	/**
	* This class handles the relocations directory.
	**/
	class RelocationsDirectory
	{
		protected:
		  std::vector<IMG_BASE_RELOC> m_vRelocations; ///< Used to store the relocation data.
		  LoaderError m_ldrError;                     /// Error detected by the import table parser

		public:
		  /// Constructor and destructor
		  RelocationsDirectory();
		  virtual ~RelocationsDirectory() = default;

		  /// Read a file's relocations directory.
		  int read(ImageLoader & imageLoader); // EXPORT

		  /// Retrieve the loader error
		  LoaderError loaderError() const;
		  void setLoaderError(LoaderError ldrError);

		  /// Returns the number of relocations in the relocations directory.
		  unsigned int calcNumberOfRelocations() const; // EXPORT
		  /// Returns the number of relocation data entries of a specific relocation.
		  unsigned int calcNumberOfRelocationData(unsigned int ulRelocation) const; // EXPORT

		  /// Read a file's relocations directory.
		  void read(const std::uint8_t * data, std::uint32_t uiSize, std::uint32_t sizeOfImage);
		  /// Returns the size of the relocations directory.
		  unsigned int size() const; // EXPORT

		  /// Returns the VA of a relocation.
		  std::uint32_t getVirtualAddress(unsigned int ulRelocation) const; // EXPORT
		  /// Returns the SizeOfBlock value of a relocation.
		  std::uint32_t getSizeOfBlock(unsigned int ulRelocation) const; // EXPORT
		  /// Returns the RelocationData of a relocation.
		  std::uint16_t getRelocationData(unsigned int ulRelocation, unsigned int ulDataNumber) const; // EXPORT

		  /// Changes the relocation data of a relocation.
		  void setRelocationData(unsigned int ulRelocation, unsigned int ulDataNumber, std::uint16_t wData); // EXPORT

		  /// Changes the VirtualAddress of a relocation.
		  void setVirtualAddress(unsigned int ulRelocation, std::uint32_t dwValue); // EXPORT
		  /// Changes the SizeOfBlock of a relocation.
		  void setSizeOfBlock(unsigned int ulRelocation, std::uint32_t dwValue); // EXPORT

		  void addRelocation(); // EXPORT
		  /// Adds new data to a relocation.
		  void addRelocationData(unsigned int ulRelocation, std::uint16_t wValue); // EXPORT
		  /// Removes data from a relocation.
		  void removeRelocationData(unsigned int ulRelocation, std::uint16_t wValue); // EXPORT
		  void removeRelocation(unsigned int index); // EXPORT
		  void removeRelocationData(unsigned int relocindex, unsigned int dataindex); // EXPORT
	};
}

#endif

```

`debug_remover/include/retdec/pelib/ResourceDirectory.h`:

```h
/*
* ResourceDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_RESOURCEDIRECTORY_H
#define RETDEC_PELIB_RESOURCEDIRECTORY_H

#include <set>

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	class ResourceElement;
	class ResourceDirectory;

	/// The class ResourceChild is used to store information about a resource node.
	class ResourceChild
	{
		friend class ResourceElement;
		friend class ResourceDirectory;
		friend class ResourceNode;
		friend class ResourceLeaf;
		friend class ResourceDirectory;

		/// Stores name and offset of a resource node.
		PELIB_IMG_RES_DIR_ENTRY entry;
		/// A pointer to one of the node's child nodes.
		ResourceElement* child;

		public:
		  /// Function which compares a resource ID to the node's resource ID.
		  bool equalId(std::uint32_t wId) const; // EXPORT
		  /// Function which compares a string to the node's resource name.
		  bool equalName(std::string strName) const; // EXPORT
		  /// Predicate that determines if a child is identified by name or by ID.
		  bool isNamedResource() const; // EXPORT
		  /// Used for sorting a node's children.
		  bool operator<(const ResourceChild& rc) const; // EXPORT

		  /// A comparison function for searching a resource element by its ID.
		  bool hasEqual(std::uint32_t id) const { return equalId(id); }
		  /// A comparison function for searching a resource element by its name.
		  bool hasEqual(const std::string& name) const { return equalName(name); }

		  /// Returns the node's number of children.
		  unsigned int getNumberOfChildren() const; // EXPORT
		  /// Returns a child of this child.
		  ResourceChild* getChildOfThisChild(std::size_t uiIndex); // EXPORT
		  const ResourceChild* getChildOfThisChild(std::size_t uiIndex) const; // EXPORT

		  /// Returns a pointer to ResourceElement.
		  ResourceElement* getNode();
		  const ResourceElement* getNode() const;
		  /// Sets a pointer to ResourceElement.
		  void setNode(ResourceElement* node);

		  /// Returns the name of the node.
		  std::string getName() const; // EXPORT
		  /// Returns the Name value of the node.
		  std::uint32_t getOffsetToName() const; // EXPORT
		  /// Returns the OffsetToData value of the node.
		  std::uint32_t getOffsetToData() const; // EXPORT

		  /// Sets the name of the node.
		  void setName(const std::string& strNewName); // EXPORT
		  /// Sets the Name value of the node.
		  void setOffsetToName(std::uint32_t dwNewOffset); // EXPORT
		  /// Sets the OffsetToData value of the node.
		  void setOffsetToData(std::uint32_t dwNewOffset); // EXPORT

		  /// Returns the size of a resource child.
//		unsigned int size() const;

		  /// Standard constructor. Does absolutely nothing.
		  ResourceChild();
		  /// Makes a deep copy of a ResourceChild object.
		  ResourceChild(const ResourceChild& rhs);
		  /// Makes a deep copy of a ResourceChild object.
		  ResourceChild& operator=(const ResourceChild& rhs);
		  /// Deletes a ResourceChild object.
		  ~ResourceChild();
	};

	/// Base class for ResourceNode and ResourceLeaf, the elements of the resource tree.
	/// \todo write
	class ResourceElement
	{
		friend class ResourceChild;
		friend class ResourceNode;
		friend class ResourceLeaf;

		protected:
		  /// Stores RVA of the resource element in the file.
		  unsigned int uiElementRva;

		  /// Reads the next resource element from the InputBuffer.
		  virtual int read(ImageLoader & imageLoader, std::uint32_t, std::uint32_t, std::uint32_t, ResourceDirectory* resDir) = 0;
		  /// Writes the next resource element into the OutputBuffer.
		  virtual void rebuild(OutputBuffer&, unsigned int, unsigned int, const std::string&) const = 0;
		  /// Recalculates the tree for different RVA.
		  virtual void recalculate(unsigned int& uiCurrentOffset, unsigned int uiNewRva) = 0;

		public:
		  /// Returns the RVA of the element in the file.
		  unsigned int getElementRva() const; // EXPORT
		  /// Indicates if the resource element is a leaf or a node.
		  virtual bool isLeaf() const = 0; // EXPORT
		  /// Corrects erroneous values in the ResourceElement.
		  virtual void makeValid() = 0; // EXPORT
		  /// Returns the size of a resource element.
//		  virtual unsigned int size() const = 0;
		  /// Constructor
		  ResourceElement();
		  /// Necessary virtual destructor.
		  virtual ~ResourceElement() {}
	};

	/// ResourceLeafs represent the leafs of the resource tree: The actual resources.
	class ResourceLeaf : public ResourceElement
	{
		friend class ResourceChild;
		friend class ResourceDirectory;
		template <typename T> friend struct fixNumberOfEntries;
		friend class ResourceDirectory;

		private:
		  /// The resource data.
		  std::vector<std::uint8_t> m_data;
		  /// PeLib equivalent of the Win32 structure IMAGE_RESOURCE_DATA_ENTRY
		  PELIB_IMAGE_RESOURCE_DATA_ENTRY entry;

		protected:
		  int read(ImageLoader & imageLoader, std::uint32_t uiRsrcRva, std::uint32_t uiOffset, std::uint32_t sizeOfImage, ResourceDirectory* resDir);
		  /// Writes the next resource leaf into the OutputBuffer.
		  void rebuild(OutputBuffer&, unsigned int uiOffset, unsigned int uiRva, const std::string&) const;
		  /// Recalculates the tree for different RVA.
		  virtual void recalculate(unsigned int& uiCurrentOffset, unsigned int uiNewRva) override;

		public:
		  /// Indicates if the resource element is a leaf or a node.
		  bool isLeaf() const; // EXPORT
		  /// Corrects erroneous values in the ResourceLeaf.
		  void makeValid(); // EXPORT
		  /// Reads the next resource leaf from the InputBuffer.
		  /// Returns the size of a resource lead.
//		  unsigned int size() const;

		  /// Returns the resource data of this resource leaf.
		  std::vector<std::uint8_t> getData() const; // EXPORT
		  /// Sets the resource data of this resource leaf.
		  void setData(const std::vector<std::uint8_t>& vData); // EXPORT

		  /// Returns the OffsetToData value of this resource leaf.
		  std::uint32_t getOffsetToData() const; // EXPORT
		  /// Returns the Size value of this resource leaf.
		  std::uint32_t getSize() const; // EXPORT
		  /// Returns the CodePage value of this resource leaf.
		  std::uint32_t getCodePage() const; // EXPORT
		  /// Returns the Reserved value of this resource leaf.
		  std::uint32_t getReserved() const; // EXPORT

		  /// Sets the OffsetToData value of this resource leaf.
		  void setOffsetToData(std::uint32_t dwValue); // EXPORT
		  /// Sets the Size value of this resource leaf.
		  void setSize(std::uint32_t dwValue); // EXPORT
		  /// Sets the CodePage value of this resource leaf.
		  void setCodePage(std::uint32_t dwValue); // EXPORT
		  /// Sets the Reserved value of this resource leaf.
		  void setReserved(std::uint32_t dwValue); // EXPORT
		  /// Constructor
		  ResourceLeaf();
		  /// Destructor
		  virtual ~ResourceLeaf() override;
	};

	/// ResourceNodes represent the nodes in the resource tree.
	class ResourceNode : public ResourceElement
	{
		friend class ResourceChild;
		friend class ResourceDirectory;
		template <typename T> friend struct fixNumberOfEntries;
		friend class ResourceDirectory;

		/// The node's children.
		std::vector<ResourceChild> children;
		/// The node's header. Equivalent to IMAGE_RESOURCE_DIRECTORY from the Win32 API.
		PELIB_IMAGE_RESOURCE_DIRECTORY header;

		protected:
		  /// Reads the next resource node.
		  int read(ImageLoader & imageLoader, std::uint32_t uiRsrcRva, std::uint32_t uiOffset, std::uint32_t sizeOfImage, ResourceDirectory* resDir);
		  /// Writes the next resource node into the OutputBuffer.
		  void rebuild(OutputBuffer&, unsigned int uiOffset, unsigned int uiRva, const std::string&) const;
		  /// Recalculates the tree for different RVA.
		  virtual void recalculate(unsigned int& uiCurrentOffset, unsigned int uiNewRva) override;

		public:
		  /// Indicates if the resource element is a leaf or a node.
		  bool isLeaf() const; // EXPORT
		  /// Corrects erroneous values in the ResourceNode.
		  void makeValid(); // EXPORT

		  /// Returns the node's number of children.
		  unsigned int getNumberOfChildren() const; // EXPORT
		  /// Adds another child to node.
		  ResourceChild* addChild(); // EXPORT
		  /// Returns a node's child.
		  ResourceChild* getChild(std::size_t uiIndex); // EXPORT
		  const ResourceChild* getChild(std::size_t uiIndex) const; // EXPORT
		  /// Removes a node's child.
		  void removeChild(unsigned int uiIndex); // EXPORT

		  /// Returns the name of one of the node's children.
		  std::string getChildName(unsigned int uiIndex) const; // EXPORT
		  /// Returns the Name value of one of the node's children.
		  std::uint32_t getOffsetToChildName(unsigned int uiIndex) const; // EXPORT
		  /// Returns the OffsetToData value of one of the node's children.
		  std::uint32_t getOffsetToChildData(unsigned int uiIndex) const; // EXPORT

		  /// Sets the name of one of the node's children.
		  void setChildName(unsigned int uiIndex, const std::string& strNewName); // EXPORT
		  /// Sets the Name value of one of the node's children.
		  void setOffsetToChildName(unsigned int uiIndex, std::uint32_t dwNewOffset); // EXPORT
		  /// Sets the OffsetToData value of one of the node's children.
		  void setOffsetToChildData(unsigned int uiIndex, std::uint32_t dwNewOffset); // EXPORT

		  /// Returns the node's Characteristics value.
		  std::uint32_t getCharacteristics() const; // EXPORT
		  /// Returns the node's TimeDateStamp value.
		  std::uint32_t getTimeDateStamp() const; // EXPORT
		  /// Returns the node's MajorVersion value.
		  std::uint16_t getMajorVersion() const; // EXPORT
		  /// Returns the node's MinorVersion value.
		  std::uint16_t getMinorVersion() const; // EXPORT
		  /// Returns the node's NumberOfNamedEntries value.
		  std::uint16_t getNumberOfNamedEntries() const; // EXPORT
		  /// Returns the node's NumberOfIdEntries value.
		  std::uint16_t getNumberOfIdEntries() const; // EXPORT

		  /// Sets the node's Characteristics value.
		  void setCharacteristics(std::uint32_t value); // EXPORT
		  /// Sets the node's TimeDateStamp value.
		  void setTimeDateStamp(std::uint32_t value); // EXPORT
		  /// Sets the node's MajorVersion value.
		  void setMajorVersion(std::uint16_t value); // EXPORT
		  /// Sets the node's MinorVersion value.
		  void setMinorVersion(std::uint16_t value); // EXPORT
		  /// Sets the node's NumberOfNamedEntries value.
		  void setNumberOfNamedEntries(std::uint16_t value); // EXPORT
		  /// Sets the node's NumberOfIdEntries value.
		  void setNumberOfIdEntries(std::uint16_t value); // EXPORT

		  /// Returns the size of a resource node.
//		unsigned int size() const;

		  /// Constructor
		  ResourceNode();
		  /// Destructor
		  virtual ~ResourceNode() override;
	};

	/// Unspecialized function that's used as base template for the specialized versions below.
	template<typename T>
	struct fixNumberOfEntries
	{
		/// Fixes a resource node's header.
		static void fix(ResourceNode*);
	};

	/// Fixes NumberOfIdEntries value of a node.
	template<>
	struct fixNumberOfEntries<std::uint32_t>
	{
		/// Fixes a resource node's NumberOfIdEntries value.
		static void fix(ResourceNode* node)
		{
			node->header.NumberOfIdEntries = static_cast<std::uint16_t>(
				node->children.size() - std::count_if(
						node->children.begin(),
						node->children.end(),
						[](const auto& i) { return i.isNamedResource(); }
				)
			);
		}
	};

	/// Fixes NumberOfNamedEntries value of a node.
	template<>
	struct fixNumberOfEntries<std::string>
	{
		/// Fixes a resource node's NumberOfNamedEntries value.
		static void fix(ResourceNode* node)
		{
			node->header.NumberOfNamedEntries = static_cast<std::uint16_t>(
				std::count_if(
					node->children.begin(),
					node->children.end(),
					[](const auto& i) { return i.isNamedResource(); }
				)
			);
		}
	};

	/// Class that represents the resource directory of a PE file.
	/**
	* The class ResourceDirectory represents the resource directory of a PE file. This class is fundamentally
	* different from the other classes of the PeLib library due to the structure of the ResourceDirectory.
	* For once, it's possible to manipulate the ResourceDirectory through a set of "high level" functions and
	* and through a set of "low level" functions. The "high level" functions are the functions inside the
	* ResourceDirectory class with the exception of getRoot.<br><br>
	* getRoot on the other hand is the first "low level" function. Use it to retrieve the root node of the
	* resource tree. Then you can traverse through the tree and manipulate individual nodes and leafs
	* directly using the functions provided by the classes ResourceNode and ResourceLeaf.<br><br>
	* There's another difference between the ResourceDirectory class and the other PeLib classes, which is
	* once again caused by the special structure of the PE resource directory. The nodes of the resource
	* tree must be in a certain order. Manipulating the resource tree does not directly sort the nodes
	* correctly as this would cause more trouble than it fixes. That means it's your responsibility to
	* fix the resource tree after manipulating it. PeLib makes the job easy for you, just call the
	* ResourceDirectory<bits>::makeValid function.<br><br>
	* You might also wonder why there's no size() function in this class. I did not forget it. It's just
	* that it's impossible to calculate the size of the resource directory without rebuilding it. So why
	* should PeLib do this if you can do it just as easily by calling rebuild() and then checking the length
	* of the returned vector.<br><br>
	* There are also different ways to serialize (rebuild) the resource tree as it's not a fixed structure
	* that can easily be minimized like most other PE directories.<br><br>
	* This means it's entirely possible that the resource tree you read from a file differs from the one
	* PeLib creates. This might cause a minor issue. The original resource tree might be smaller (due to
	* different padding) so it's crucial that you check if there's enough space in the original resource
	* directory before you write the rebuilt resource directory back to the file.
	**/
	class ResourceDirectory
	{
		protected:
		  /// Start offset of directory in file.
		  unsigned int m_readOffset;
		  /// The root node of the resource directory.
		  ResourceNode m_rnRoot;
		  /// Detection of invalid structure of nodes in directory.
		  std::set<std::size_t> m_resourceNodeOffsets;
		  /// Stores RVAs which are occupied by this export directory.
		  std::vector<std::pair<unsigned int, unsigned int>> m_occupiedAddresses;
		  /// Error detected by the import table parser
		  LoaderError m_ldrError;

		  // Prepare for some crazy syntax below to make Digital Mars happy.

		  /// Retrieves an iterator to a specified resource child.
		  template<typename S, typename T>
		  std::vector<ResourceChild>::const_iterator locateResourceT(S restypeid, T resid) const;

		  /// Retrieves an iterator to a specified resource child.
		  template<typename S, typename T>
		  std::vector<ResourceChild>::iterator locateResourceT(S restypeid, T resid);

		  /// Adds a new resource.
		  template<typename S, typename T>
		  int addResourceT(S restypeid, T resid, ResourceChild& rc);

		  /// Removes new resource.
		  template<typename S, typename T>
		  int removeResourceT(S restypeid, T resid);

		  /// Returns the data of a resource.
		  template<typename S, typename T>
		  int getResourceDataT(S restypeid, T resid, std::vector<std::uint8_t>& data) const;

		  /// Sets the data of a resource.
		  template<typename S, typename T>
		  int setResourceDataT(S restypeid, T resid, std::vector<std::uint8_t>& data);

		  /// Returns the ID of a resource.
		  template<typename S, typename T>
		  std::uint32_t getResourceIdT(S restypeid, T resid) const;

		  /// Sets the ID of a resource.
		  template<typename S, typename T>
		  int setResourceIdT(S restypeid, T resid, std::uint32_t dwNewResId);

		  /// Returns the name of a resource.
		  template<typename S, typename T>
		  std::string getResourceNameT(S restypeid, T resid) const;

		  /// Sets the name of a resource.
		  template<typename S, typename T>
		  int setResourceNameT(S restypeid, T resid, std::string strNewResName);

		public:
		  /// Constructor
		  ResourceDirectory();
		  /// Destructor
		  virtual ~ResourceDirectory() = default;

		  /// Reads the resource directory from a file.
		  int read(ImageLoader & imageLoader);

		  ResourceNode* getRoot();
		  const ResourceNode* getRoot() const;

		  /// Retrieve the loader error
		  LoaderError loaderError() const;
		  void setLoaderError(LoaderError ldrError);

		  /// Corrects a erroneous resource directory.
		  void makeValid();
		  /// Rebuilds the resource directory.
		  void rebuild(std::vector<std::uint8_t>& vBuffer, unsigned int uiRva) const;
		  /// Recalculate the tree for different RVA
		  void recalculate(unsigned int& uiNewSize, unsigned int uiNewRva);
		  /// Returns the size of the rebuilt resource directory.
//		  unsigned int size() const;
		  /// Writes the resource directory to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva) const;

		  /// Adds a new resource type.
		  int addResourceType(std::uint32_t dwResTypeId);
		  /// Adds a new resource type.
		  int addResourceType(const std::string& strResTypeName);

		  /// Removes a resource type and all of it's resources.
		  int removeResourceType(std::uint32_t dwResTypeId);
		  /// Removes a resource type and all of it's resources.
		  int removeResourceType(const std::string& strResTypeName);

		  /// Removes a resource type and all of it's resources.
		  int removeResourceTypeByIndex(unsigned int uiIndex);

		  /// Adds a new resource.
		  int addResource(std::uint32_t dwResTypeId, std::uint32_t dwResId);
		  /// Adds a new resource.
		  int addResource(std::uint32_t dwResTypeId, const std::string& strResName);
		  /// Adds a new resource.
		  int addResource(const std::string& strResTypeName, std::uint32_t dwResId);
		  /// Adds a new resource.
		  int addResource(const std::string& strResTypeName, const std::string& strResName);

		  /// Removes a resource.
		  int removeResource(std::uint32_t dwResTypeId, std::uint32_t dwResId);
		  /// Removes a resource.
		  int removeResource(std::uint32_t dwResTypeId, const std::string& strResName);
		  /// Removes a resource.
		  int removeResource(const std::string& strResTypeName, std::uint32_t dwResId);
		  /// Removes a resource.
		  int removeResource(const std::string& strResTypeName, const std::string& strResName);

		  /// Returns start offset of resource directory in file.
		  unsigned int getOffset() const;

		  /// Returns the number of resource types.
		  unsigned int getNumberOfResourceTypes() const;

		  /// Returns the ID of a resource type.
		  std::uint32_t getResourceTypeIdByIndex(unsigned int uiIndex) const;
		  /// Returns the name of a resource type.
		  std::string getResourceTypeNameByIndex(unsigned int uiIndex) const;

		  /// Converts a resource type ID to an index.
		  int resourceTypeIdToIndex(std::uint32_t dwResTypeId) const;
		  /// Converts a resource type name to an index.
		  int resourceTypeNameToIndex(const std::string& strResTypeName) const;

		  /// Returns the number of resources of a certain resource type.
		  unsigned int getNumberOfResources(std::uint32_t dwId) const;
		  /// Returns the number of resources of a certain resource type.
		  unsigned int getNumberOfResources(const std::string& strResTypeName) const;

		  /// Returns the number of resources of a certain resource type.
		  unsigned int getNumberOfResourcesByIndex(unsigned int uiIndex) const;

		  /// Returns the data of a certain resource.
		  void getResourceData(std::uint32_t dwResTypeId, std::uint32_t dwResId, std::vector<std::uint8_t>& data) const;
		  /// Returns the data of a certain resource.
		  void getResourceData(std::uint32_t dwResTypeId, const std::string& strResName, std::vector<std::uint8_t>& data) const;
		  /// Returns the data of a certain resource.
		  void getResourceData(const std::string& strResTypeName, std::uint32_t dwResId, std::vector<std::uint8_t>& data) const;
		  /// Returns the data of a certain resource.
		  void getResourceData(const std::string& strResTypeName, const std::string& strResName, std::vector<std::uint8_t>& data) const;

		  /// Returns the data of a certain resource.
		  void getResourceDataByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::vector<std::uint8_t>& data) const;

		  /// Sets the data of a certain resource.
		  void setResourceData(std::uint32_t dwResTypeId, std::uint32_t dwResId, std::vector<std::uint8_t>& data);
		  /// Sets the data of a certain resource.
		  void setResourceData(std::uint32_t dwResTypeId, const std::string& strResName, std::vector<std::uint8_t>& data);
		  /// Sets the data of a certain resource.
		  void setResourceData(const std::string& strResTypeName, std::uint32_t dwResId, std::vector<std::uint8_t>& data);
		  /// Sets the data of a certain resource.
		  void setResourceData(const std::string& strResTypeName, const std::string& strResName, std::vector<std::uint8_t>& data);

		  /// Sets the data of a certain resource.
		  void setResourceDataByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::vector<std::uint8_t>& data);

		  /// Returns the ID of a certain resource.
		  std::uint32_t getResourceId(std::uint32_t dwResTypeId, const std::string& strResName) const;
		  /// Returns the ID of a certain resource.
		  std::uint32_t getResourceId(const std::string& strResTypeName, const std::string& strResName) const;

		  /// Returns the ID of a certain resource.
		  std::uint32_t getResourceIdByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex) const;

		  /// Sets the ID of a certain resource.
		  void setResourceId(std::uint32_t dwResTypeId, std::uint32_t dwResId, std::uint32_t dwNewResId);
		  /// Sets the ID of a certain resource.
		  void setResourceId(std::uint32_t dwResTypeId, const std::string& strResName, std::uint32_t dwNewResId);
		  /// Sets the ID of a certain resource.
		  void setResourceId(const std::string& strResTypeName, std::uint32_t dwResId, std::uint32_t dwNewResId);
		  /// Sets the ID of a certain resource.
		  void setResourceId(const std::string& strResTypeName, const std::string& strResName, std::uint32_t dwNewResId);

		  /// Sets the ID of a certain resource.
		  void setResourceIdByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::uint32_t dwNewResId);

		  /// Returns the name of a certain resource.
		  std::string getResourceName(std::uint32_t dwResTypeId, std::uint32_t dwResId) const;
		  /// Returns the name of a certain resource.
		  std::string getResourceName(const std::string& strResTypeName, std::uint32_t dwResId) const;

		  /// Returns the name of a certain resource.
		  std::string getResourceNameByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex) const;

		  /// Sets the name of a certain resource.
		  void setResourceName(std::uint32_t dwResTypeId, std::uint32_t dwResId, const std::string& strNewResName);
		  /// Sets the name of a certain resource.
		  void setResourceName(std::uint32_t dwResTypeId, const std::string& strResName, const std::string& strNewResName);
		  /// Sets the name of a certain resource.
		  void setResourceName(const std::string& strResTypeName, std::uint32_t dwResId, const std::string& strNewResName);
		  /// Sets the name of a certain resource.
		  void setResourceName(const std::string& strResTypeName, const std::string& strResName, const std::string& strNewResName);

		  /// Sets the name of a certain resource.
		  void setResourceNameByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, const std::string& strNewResName);

		  /// Insert offset of loaded node.
		  void insertNodeOffset(std::size_t nodeOffset);
		  /// Check if node with specified offset was loaded.
		  bool hasNodeOffset(std::size_t nodeOffset) const;

		  void addOccupiedAddressRange(unsigned int start, unsigned int end);
		  const std::vector<std::pair<unsigned int, unsigned int>>& getOccupiedAddresses() const;
	};

	/**
	* Looks through the entire resource tree and returns a const_iterator to the resource specified
	* by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @return A const_iterator to the specified resource.
	**/
	template<typename S, typename T>
	std::vector<ResourceChild>::const_iterator ResourceDirectory::locateResourceT(S restypeid, T resid) const
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& res) { return res.hasEqual(restypeid); }
		);
		if (Iter == m_rnRoot.children.end())
		{
			return Iter;
		}

		ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
		return std::find_if(
				currNode->children.begin(),
				currNode->children.end(),
				[&](const auto& res) { return res.hasEqual(resid); }
		);
	}

	/**
	* Looks through the entire resource tree and returns an iterator to the resource specified
	* by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @return An iterator to the specified resource.
	**/
	template<typename S, typename T>
	std::vector<ResourceChild>::iterator ResourceDirectory::locateResourceT(S restypeid, T resid)
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& res) { return res.hasEqual(restypeid); }
		);
		if (Iter == m_rnRoot.children.end())
		{
			return Iter;
		}

		ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
		return std::find_if(
				currNode->children.begin(),
				currNode->children.end(),
				[&](const auto& res) { return res.hasEqual(resid); }
		);
	}

	/**
	* Adds a new resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param rc ResourceChild that will be added.
	**/
	template<typename S, typename T>
	int ResourceDirectory::addResourceT(S restypeid, T resid, ResourceChild& rc)
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& res) { return res.hasEqual(restypeid); }
		);
		if (Iter == m_rnRoot.children.end())
		{
			return ERROR_ENTRY_NOT_FOUND;
			// throw Exceptions::ResourceTypeDoesNotExist(ResourceDirectoryId, __LINE__);
		}

		ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
		auto ResIter = std::find_if(
				currNode->children.begin(),
				currNode->children.end(),
				[&](const auto& res) { return res.hasEqual(resid); }
		);
		if (ResIter != currNode->children.end())
		{
			return ERROR_DUPLICATE_ENTRY;
//			throw Exceptions::EntryAlreadyExists(ResourceDirectoryId, __LINE__);
		}

		rc.child = new ResourceNode;
		ResourceChild rlnew;
		rlnew.child = new ResourceLeaf;
		ResourceNode* currNode2 = static_cast<ResourceNode*>(rc.child);
		currNode2->children.push_back(rlnew);
		currNode->children.push_back(rc);

		fixNumberOfEntries<T>::fix(currNode);
		fixNumberOfEntries<T>::fix(currNode2);

		return ERROR_NONE;
	}

	/**
	* Removes a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	**/
	template<typename S, typename T>
	int ResourceDirectory::removeResourceT(S restypeid, T resid)
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& res) { return res.hasEqual(restypeid); }
		);
		if (Iter == m_rnRoot.children.end())
		{
			return ERROR_ENTRY_NOT_FOUND;
			//throw Exceptions::ResourceTypeDoesNotExist(ResourceDirectoryId, __LINE__);
		}

		ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
		auto ResIter = std::find_if(
				currNode->children.begin(),
				currNode->children.end(),
				[&](const auto& res) { return res.hasEqual(resid); }
		);
		if (ResIter == currNode->children.end())
		{
			return ERROR_ENTRY_NOT_FOUND;
			// throw Exceptions::InvalidName(ResourceDirectoryId, __LINE__);
		}

		currNode->children.erase(ResIter);

		fixNumberOfEntries<T>::fix(currNode);

		return ERROR_NONE;
	}

	/**
	* Returns the data of a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param data The data of the resource will be written into this vector.
	**/
	template<typename S, typename T>
	int ResourceDirectory::getResourceDataT(S restypeid, T resid, std::vector<std::uint8_t>& data) const
	{
		std::vector<ResourceChild>::const_iterator ResIter = locateResourceT(restypeid, resid);
		ResourceNode* currNode = static_cast<ResourceNode*>(ResIter->child);
		ResourceLeaf* currLeaf = static_cast<ResourceLeaf*>(currNode->children[0].child);
		data.assign(currLeaf->m_data.begin(), currLeaf->m_data.end());

		return ERROR_NONE;
	}

	/**
	* Sets the data of a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param data The new data of the resource is taken from this vector.
	**/
	template<typename S, typename T>
	int ResourceDirectory::setResourceDataT(S restypeid, T resid, std::vector<std::uint8_t>& data)
	{
		std::vector<ResourceChild>::iterator ResIter = locateResourceT(restypeid, resid);
		ResourceNode* currNode = static_cast<ResourceNode*>(ResIter->child);
		ResourceLeaf* currLeaf = static_cast<ResourceLeaf*>(currNode->children[0].child);
		currLeaf->m_data.assign(data.begin(), data.end());

		return ERROR_NONE;
	}

	/**
	* Returns the id of a resource, resource type and ID are specified by the parameters.
	* Note: Calling this function with resid == the ID of the resource makes no sense at all.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @return The ID of the specified resource.
	**/
	template<typename S, typename T>
	std::uint32_t ResourceDirectory::getResourceIdT(S restypeid, T resid) const
	{
		std::vector<ResourceChild>::const_iterator ResIter = locateResourceT(restypeid, resid);
		return ResIter->entry.irde.Name;
	}

	/**
	* Sets the id of a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param dwNewResId New ID of the resource.
	**/
	template<typename S, typename T>
	int ResourceDirectory::setResourceIdT(S restypeid, T resid, std::uint32_t dwNewResId)
	{
		std::vector<ResourceChild>::iterator ResIter = locateResourceT(restypeid, resid);
		ResIter->entry.irde.Name = dwNewResId;
		return ERROR_NONE;
	}

	/**
	* Returns the name of a resource, resource type and ID are specified by the parameters.
	* Note: Calling this function with resid == the name of the resource makes no sense at all.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @return The name of the specified resource.
	**/
	template<typename S, typename T>
	std::string ResourceDirectory::getResourceNameT(S restypeid, T resid) const
	{
		std::vector<ResourceChild>::const_iterator ResIter = locateResourceT(restypeid, resid);
		return ResIter->entry.wstrName;
	}

	/**
	* Sets the name of a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param strNewResName The new name of the resource.
	**/
	template<typename S, typename T>
	int ResourceDirectory::setResourceNameT(S restypeid, T resid, std::string strNewResName)
	{
		std::vector<ResourceChild>::iterator ResIter = locateResourceT(restypeid, resid);
		ResIter->entry.wstrName = strNewResName;

		return ERROR_NONE;
	}
}

#endif

```

`debug_remover/include/retdec/pelib/RichHeader.h`:

```h
/**
 * @file RichHeader.h
 * @brief Class for rich header.
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#ifndef RETDEC_PELIB_RICHHEADER_H
#define RETDEC_PELIB_RICHHEADER_H

#include <cstdint>
#include <vector>
#include <map>

namespace PeLib
{
	/**
	 * This class handless rich header.
	 */
	class RichHeader
	{
		public:
			typedef std::vector<PELIB_IMAGE_RICH_HEADER_RECORD>::const_iterator richHeaderIterator;
		private:
			bool headerIsValid;
			bool validStructure;
			std::uint32_t key;
			std::uint64_t offset = 0;
			std::size_t noOfIters;
			std::vector<std::uint32_t> decryptedHeader;
			std::vector<PELIB_IMAGE_RICH_HEADER_RECORD> records;

			void init();
			void setValidStructure();
			void getUserFriendlyProductName(PELIB_IMAGE_RICH_HEADER_RECORD & record);
			bool analyze(bool ignoreInvalidKey = false);
			void read(InputBuffer& inputbuffer, std::size_t uiSize, bool ignoreInvalidKey);
		public:
			RichHeader();
			~RichHeader();

			int read(
					std::istream& inStream,
					std::size_t uiOffset,
					std::size_t uiSize,
					bool ignoreInvalidKey);
			bool isHeaderValid() const;
			bool isStructureValid() const;
			std::size_t getNumberOfIterations() const;
			std::uint64_t getOffset() const;
			std::uint32_t getKey() const;
			const std::uint32_t* getDecryptedHeaderItem(std::size_t index) const;
			std::string getDecryptedHeaderItemSignature(std::size_t index) const;
			std::string getDecryptedHeaderItemsSignature(std::initializer_list<std::size_t> indexes) const;
			std::vector<std::uint8_t> getDecryptedHeaderBytes() const;
			richHeaderIterator begin() const;
			richHeaderIterator end() const;
	};
}

#endif

```

`debug_remover/include/retdec/pelib/SecurityDirectory.h`:

```h
/**
 * @file SecurityDirectory.h
 * @brief Class for certificate directory.
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#ifndef RETDEC_PELIB_SECURITYDIRECTORY_H
#define RETDEC_PELIB_SECURITYDIRECTORY_H

#include <cstdint>

namespace PeLib
{
	class SecurityDirectory
	{
		private:
		  LoaderError m_ldrError;
		  std::vector<PELIB_IMAGE_CERTIFICATE_ENTRY> m_certs;
		  std::uint64_t offset = 0;
		  std::uint64_t size = 0;
		public:
		  /// Constructor
		  SecurityDirectory();
		  std::uint64_t getOffset() const;
		  std::uint64_t getSize() const;
		  /// Number of certificates in the directory.
		  unsigned int calcNumberOfCertificates() const; // EXPORT
		  /// Returns certificate at specified index.
		  const std::vector<unsigned char>& getCertificate(std::size_t index) const; // EXPORT
		  /// Return the loader error
		  LoaderError loaderError() const;
		  /// Read a file's certificate directory.
		  int read(
				  std::istream& inStream,
				  unsigned int uiOffset,
				  unsigned int uiSize); // EXPORT
	};
}

#endif

```

`debug_remover/include/retdec/pelib/TlsDirectory.h`:

```h
/*
* TlsDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#ifndef RETDEC_PELIB_TLSDIRECTORY_H
#define RETDEC_PELIB_TLSDIRECTORY_H

#include "retdec/pelib/ImageLoader.h"

namespace PeLib
{
	/// Class that handles the TLS directory.
	/**
	* This class handles the TLS (Thread Local Storage) directory.
	**/
	class TlsDirectory
	{
		private:
		  PELIB_IMAGE_TLS_DIRECTORY m_tls; ///< Structure that holds all information about the directory.
		  std::vector<uint64_t> m_Callbacks;
		  std::size_t pointerSize;

		public:
		  /// Reads a file's TLS directory.
		  int read(ImageLoader & imageLoader); // EXPORT
		  /// Rebuilds the TLS directory.
		  void rebuild(std::vector<std::uint8_t>& vBuffer) const; // EXPORT
		  /// Returns the size of the TLS Directory.
		  unsigned int size() const; // EXPORT
		  /// Writes the TLS directory to a file.
		  int write(const std::string& strFilename, unsigned int dwOffset) const; // EXPORT

		  /// Returns vector of TLS callbacks
		  const std::vector<std::uint64_t> & getCallbacks() const;
		  /// Returns the StartAddressOfRawData value of the TLS header.
		  std::uint64_t getStartAddressOfRawData() const; // EXPORT
		  /// Returns the EndAddressOfRawData value of the TLS header.
		  std::uint64_t getEndAddressOfRawData() const; // EXPORT
		  /// Returns the AddressOfIndex value of the TLS header.
		  std::uint64_t getAddressOfIndex() const; // EXPORT
		  /// Returns the AddressOfCallBacks value of the TLS header.
		  std::uint64_t getAddressOfCallBacks() const; // EXPORT
		  /// Returns the SizeOfZeroFill value of the TLS header.
		  std::uint32_t getSizeOfZeroFill() const; // EXPORT
		  /// Returns the Characteristics value of the TLS header.
		  std::uint32_t getCharacteristics() const; // EXPORT

		  /// Sets the StartAddressOfRawData value of the TLS header.
		  void setStartAddressOfRawData(std::uint64_t value); // EXPORT
		  /// Sets the EndAddressOfRawData value of the TLS header.
		  void setEndAddressOfRawData(std::uint64_t value); // EXPORT
		  /// Sets the AddressOfIndex value of the TLS header.
		  void setAddressOfIndex(std::uint64_t value); // EXPORT
		  /// Sets the AddressOfCallBacks value of the TLS header.
		  void setAddressOfCallBacks(std::uint64_t value); // EXPORT
		  /// Sets the SizeOfZeroFill value of the TLS header.
		  void setSizeOfZeroFill(std::uint32_t dwValue); // EXPORT
		  /// Sets the Characteristics value of the TLS header.
		  void setCharacteristics(std::uint32_t dwValue); // EXPORT
	};

	/**
	* Reads a file's TLS directory.
	* @param imageLoader Referenve to a valid PE image loader.
	**/
	inline
	int TlsDirectory::read(ImageLoader & imageLoader)
	{
		std::uint64_t imageBase = imageLoader.getImageBase();
		std::uint32_t rva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_TLS);
		std::uint32_t size = imageLoader.getDataDirSize(PELIB_IMAGE_DIRECTORY_ENTRY_TLS);
		std::uint32_t sizeOfImage = imageLoader.getSizeOfImage();
		std::uint32_t bytesRead;

		if((rva + size) >= sizeOfImage)
			return ERROR_INVALID_FILE;

		// Remember the pointer size
		pointerSize = imageLoader.getPointerSize();

		// Read the TLS directory from the image. Differentiate between 32-bit and 64-bit
		if(imageLoader.getImageBitability() == 32)
		{
			PELIB_IMAGE_TLS_DIRECTORY32 TlsDirectory32;

			// Read the 32-bit TLS directory structure
			bytesRead = imageLoader.readImage(&TlsDirectory32, rva, sizeof(PELIB_IMAGE_TLS_DIRECTORY32));
			if(bytesRead != sizeof(PELIB_IMAGE_TLS_DIRECTORY32))
				return ERROR_INVALID_FILE;

			// Convert to 64-bit structure
			m_tls.StartAddressOfRawData = TlsDirectory32.StartAddressOfRawData;
			m_tls.EndAddressOfRawData = TlsDirectory32.EndAddressOfRawData;
			m_tls.AddressOfIndex = TlsDirectory32.AddressOfIndex;
			m_tls.AddressOfCallBacks = TlsDirectory32.AddressOfCallBacks;
			m_tls.SizeOfZeroFill = TlsDirectory32.SizeOfZeroFill;
			m_tls.Characteristics = TlsDirectory32.Characteristics;
		}
		else
		{
			// Read the 32-bit TLS directory structure
			bytesRead = imageLoader.readImage(&m_tls, rva, sizeof(PELIB_IMAGE_TLS_DIRECTORY));
			if(bytesRead != sizeof(PELIB_IMAGE_TLS_DIRECTORY))
				return ERROR_INVALID_FILE;
		}

		// If there is non-zero address of callbacks, we try to read at least one pointer to know
		// if there are TLS callbacks
		if(imageBase < m_tls.AddressOfCallBacks && m_tls.AddressOfCallBacks < (imageBase + sizeOfImage))
		{
			std::uint32_t rva = (std::uint32_t)(m_tls.AddressOfCallBacks - imageBase);

			for(std::uint32_t i = 0; i < PELIB_MAX_TLS_CALLBACKS; i++)
			{
				std::uint64_t AddressOfCallBack = 0;

				if(imageLoader.readPointer(rva, AddressOfCallBack) == 0)
					break;
				if(AddressOfCallBack == 0)
					break;

				m_Callbacks.push_back(AddressOfCallBack);
				rva += pointerSize;
			}
		}

		return ERROR_NONE;
	}

	/**
	* Rebuilds the current TLS Directory.
	* @param vBuffer Buffer where the TLS directory will be written to.
	**/
	inline
	void TlsDirectory::rebuild(std::vector<std::uint8_t>& vBuffer) const
	{
		if(pointerSize == 32)
		{
			PELIB_IMAGE_TLS_DIRECTORY32 TlsDirectory32;

			TlsDirectory32.StartAddressOfRawData = (std::uint32_t)m_tls.StartAddressOfRawData;
			TlsDirectory32.EndAddressOfRawData   = (std::uint32_t)m_tls.EndAddressOfRawData;
			TlsDirectory32.AddressOfIndex        = (std::uint32_t)m_tls.AddressOfIndex;
			TlsDirectory32.AddressOfCallBacks    = (std::uint32_t)m_tls.AddressOfCallBacks;
			TlsDirectory32.SizeOfZeroFill        = m_tls.SizeOfZeroFill;
			TlsDirectory32.Characteristics       = m_tls.Characteristics;

			vBuffer.resize(sizeof(PELIB_IMAGE_TLS_DIRECTORY32));
			memcpy(vBuffer.data(), &TlsDirectory32, sizeof(PELIB_IMAGE_TLS_DIRECTORY32));
		}
		else
		{
			vBuffer.resize(sizeof(PELIB_IMAGE_TLS_DIRECTORY));
			memcpy(vBuffer.data(), &m_tls, sizeof(PELIB_IMAGE_TLS_DIRECTORY));
		}
	}

	/**
	* Returns the size of the TLS directory. Due to the static nature of this structure the return value
	* will always be 24.
	* @return Size in bytes.
	**/
	inline
	unsigned int TlsDirectory::size() const
	{
		return (pointerSize == 32) ? sizeof(PELIB_IMAGE_TLS_DIRECTORY32) : sizeof(PELIB_IMAGE_TLS_DIRECTORY);
	}

	/**
	* @param strFilename Name of the file.
	* @param dwOffset File offset the TLS Directory will be written to.
	**/
	inline
	int TlsDirectory::write(const std::string& strFilename, unsigned int dwOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);

		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(dwOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(vBuffer.data()), vBuffer.size());

		ofFile.close();

		return ERROR_NONE;
	}

	/**
	* @return The vector of TLS callbacks
	**/
	inline
	const std::vector<std::uint64_t> & TlsDirectory::getCallbacks() const
	{
		return m_Callbacks;
	}

	/**
	* @return The StartAddressOfRawData value of the TLS directory.
	**/
	inline
	std::uint64_t TlsDirectory::getStartAddressOfRawData() const
	{
		return m_tls.StartAddressOfRawData;
	}

	/**
	* @return The EndAddressOfRawData value of the TLS directory.
	**/
	inline
	std::uint64_t TlsDirectory::getEndAddressOfRawData() const
	{
		return m_tls.EndAddressOfRawData;
	}

	/**
	* @return The AddressOfIndex value of the TLS directory.
	**/
	inline
	std::uint64_t TlsDirectory::getAddressOfIndex() const
	{
		return m_tls.AddressOfIndex;
	}

	/**
	* @return The AddressOfCallBacks value of the TLS directory.
	**/
	inline
	std::uint64_t TlsDirectory::getAddressOfCallBacks() const
	{
		return m_tls.AddressOfCallBacks;
	}

	/**
	* @return The SizeOfZeroFill value of the TLS directory.
	**/
	inline
	std::uint32_t TlsDirectory::getSizeOfZeroFill() const
	{
		return m_tls.SizeOfZeroFill;
	}

	/**
	* @return The Characteristics value of the TLS directory.
	**/
	inline
	std::uint32_t TlsDirectory::getCharacteristics() const
	{
		return m_tls.Characteristics;
	}

	/**
	* @param value The new StartAddressOfRawData value of the TLS directory.
	**/
	inline
	void TlsDirectory::setStartAddressOfRawData(std::uint64_t value)
	{
		m_tls.StartAddressOfRawData = value;
	}

	/**
	* @param value The new EndAddressOfRawData value of the TLS directory.
	**/
	inline
	void TlsDirectory::setEndAddressOfRawData(std::uint64_t value)
	{
		m_tls.EndAddressOfRawData = value;
	}

	/**
	* @param value The new AddressOfIndex value of the TLS directory.
	**/
	inline
	void TlsDirectory::setAddressOfIndex(std::uint64_t value)
	{
		m_tls.AddressOfIndex = value;
	}

	/**
	* @param value The new AddressOfCallBacks value of the TLS directory.
	**/
	inline
	void TlsDirectory::setAddressOfCallBacks(std::uint64_t value)
	{
		m_tls.AddressOfCallBacks = value;
	}

	/**
	* @param dwValue The new SizeOfZeroFill value of the TLS directory.
	**/
	inline
	void TlsDirectory::setSizeOfZeroFill(std::uint32_t dwValue)
	{
		m_tls.SizeOfZeroFill = dwValue;
	}

	/**
	* @param dwValue The new Characteristics value of the TLS directory.
	**/
	inline
	void TlsDirectory::setCharacteristics(std::uint32_t dwValue)
	{
		m_tls.Characteristics = dwValue;
	}

}
#endif

```

`debug_remover/include/retdec/utils/container.h`:

```h
/**
* @file include/retdec/utils/container.h
* @brief Container utilities.
* @copyright (c) 2017 Avast Software, licensed under the MIT license
*/

#ifndef RETDEC_UTILS_CONTAINER_H
#define RETDEC_UTILS_CONTAINER_H

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <iterator>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <vector>

#include "retdec/utils/filter_iterator.h"

namespace retdec {
namespace utils {

/// @name General Operations with Containers
/// @{

/**
* @brief Returns @c true if @a container contains @a item, @c false otherwise.
*
* @tparam Container Type of the container.
* @tparam Item Type of the items that @a container holds.
*
* If Container is a map, Item has to be a key. To check whether a map contains
* a value, use mapHasValue<>().
*/
// Note to developers: For sequential containers that don't have the find()
// member function, like std::vector or std::list, add a "specialization" which
// uses std::find() from the <algorithm> header file.
template<class Container, typename Item>
bool hasItem(const Container &container, const Item &item) {
	return container.find(item) != container.end();
}

/**
* @brief A "specialization" of hasItem<>() for std::list.
*/
template<typename Item>
bool hasItem(const std::list<Item> &container, const Item &item) {
	// std::list doesn't have the find() member function.
	return find(container.begin(), container.end(), item) != container.end();
}

/**
* @brief A "specialization" of hasItem<>() for std::vector.
*/
template<typename Item>
bool hasItem(const std::vector<Item> &container, const Item &item) {
	// std::vector doesn't have the find() member function.
	return find(container.begin(), container.end(), item) != container.end();
}

/**
* @brief Returns the n-th item in @a container.
*
* @tparam Item Type of the items that @a container holds.
*
* @par Preconditions
*  - <tt>1 <= n <= container.size()</tt>
*/
template<typename Item>
const Item &getNthItem(const std::vector<Item> &container, std::size_t n) {
	assert(1 <= n && n <= container.size() && "n is out of bounds");

	return container[n - 1];
}

/**
* @brief Returns the n-th item in @a container.
*
* @tparam Item Type of the items that @a container holds.
*
* @par Preconditions
*  - <tt>1 <= n <= container.size()</tt>
*/
template<typename Item>
const Item &getNthItem(const std::list<Item> &container, std::size_t n) {
	assert(1 <= n && n <= container.size() && "n is out of bounds");

	auto itemIt = container.begin();
	std::advance(itemIt, n - 1);
	return *itemIt;
}

/**
* @brief Returns the found value if @a container contains @a item, @a
*        defaultValue otherwise.
*
* @tparam Container Type of the container.
* @tparam Item Type of the items that @a container holds.
*
* If Container is a map, the searched and returned values are pairs. To get a
* value corresponding to a given key from a map, use mapGetValueOrDefault<>().
*/
// Note to developers: For sequential containers that don't have the find()
// member function, like std::vector or std::list, add a "specialization" which
// uses std::find() from the <algorithm> header file.
template<class Container, typename Item>
Item getValueOrDefault(const Container &container, const Item &item,
		Item defaultValue = Item()) {
	auto i = container.find(item);
	return i != container.end() ? *i : defaultValue;
}

/**
* @brief A "specialization" of getValueOrDefault<>() for std::list.
*/
template<typename Item>
Item getValueOrDefault(const std::list<Item> &container,
		const Item &item, Item defaultValue = Item()) {
	// std::list doesn't have the find() member function.
	auto i = std::find(container.begin(), container.end(), item);
	return i != container.end() ? *i : defaultValue;
}

/**
* @brief A "specialization" of getValueOrDefault<>() for std::vector.
*/
template<typename Item>
Item getValueOrDefault(const std::vector<Item> &container,
		const Item &item, Item defaultValue = Item()) {
	// std::vector doesn't have the find() member function.
	auto i = std::find(container.begin(), container.end(), item);
	return i != container.end() ? *i : defaultValue;
}

/**
* @brief Removes all occurrences of the given @a item from the given vector.
*
* @tparam Item Type of the items that the vector holds.
*/
template<typename Item>
void removeItem(std::vector<Item> &v, const Item &item) {
	// std::vector does not provide erase() that takes an item as its argument,
	// so we have to use the following idiom, called "erase-remove".
	v.erase(std::remove(v.begin(), v.end(), item), v.end());
}

/**
* @brief Clears the given container.
*
* @tparam Container Type of the container.
*/
template<class Container>
void clear(Container &container) {
	container.clear();
}

/**
* @brief A "specialization" of clear<>() for std::queue.
*/
template<typename Item>
void clear(std::queue<Item> &q) {
	// std::queue doesn't provide the clear() member function.
	while (!q.empty()) {
		q.pop();
	}
}

/**
* @brief A "specialization" of clear<>() for std::stack.
*/
template<typename Item>
void clear(std::stack<Item> &s) {
	// std::stack doesn't provide the clear() member function.
	while (!s.empty()) {
		s.pop();
	}
}

/**
* @brief Returns @c OutputContainer with items from @a input that satistfy @a
*        predicate.
*
* This function is an implementation of the standard functional @c filter()
* function.
*
* Usage example:
* @code
* auto result = filterTo<std::set<int>>(
*     std::vector<int>{1, 2, 3, 4, 5},
*     [](auto i) { return i % 2 == 0; }
* );
* @endcode
* The type of @c result is @c OutputContainer, i.e. @c std::set<int>.
*/
template<typename OutputContainer, typename InputContainer, typename Predicate>
OutputContainer filterTo(const InputContainer &input, const Predicate &predicate) {
	FilterIterator<typename InputContainer::const_iterator> begin(input, predicate);
	decltype(begin) end(input.end());
	return {begin, end};
}

/**
* @brief Returns @c Container with items from @a input that satistfy @a
*        predicate.
*
* It is a shortcut for <tt>filterTo<Container>(input, predicate)</tt>.
*
* Usage example:
* @code
* auto result = filter(
*     std::vector<int>{1, 2, 3, 4, 5},
*     [](auto i) { return i % 2 == 0; }
* );
* @endcode
* The type of @c result is @c Container, i.e. @c std::vector<int>.
*/
template<typename Container, typename Predicate>
Container filter(const Container &input, const Predicate &predicate) {
	return filterTo<Container>(input, predicate);
}

/// @}

/// @name Operations with Sets
/// @{

/**
* @brief Adds all values from @a from into @a to.
*
* @tparam T Type of elements in the sets.
*/
template<typename T>
void addToSet(const std::set<T> &from, std::set<T> &to) {
	to.insert(from.begin(), from.end());
}

/**
* @brief Returns the set union <tt>s1 \\cup s2</tt>.
*
* In other words, this function returns the set whose elements are in @a s1 or
* in @a s2.
*
* @tparam T Type of elements in the sets.
*/
template<typename T>
std::set<T> setUnion(const std::set<T> &s1, const std::set<T> &s2) {
	std::set<T> result;
	std::set_union(s1.begin(), s1.end(), s2.begin(), s2.end(),
		std::inserter(result, result.end()));
	return result;
}

/**
* @brief Returns the set intersection <tt>s1 \\cap s2</tt>.
*
* In other words, this function returns the set whose elements are in both @a
* s1 and @a s2.
*
* @tparam T Type of elements in the sets.
*/
template<typename T>
std::set<T> setIntersection(const std::set<T> &s1, const std::set<T> &s2) {
	std::set<T> result;
	std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
		std::inserter(result, result.end()));
	return result;
}

/**
* @brief Returns the set difference <tt>s1 \\setminus s2</tt>.
*
* In other words, this function returns the set whose elements are in @a s1
* but are not in @a s2.
*
* @tparam T Type of elements in the sets.
*/
template<typename T>
std::set<T> setDifference(const std::set<T> &s1, const std::set<T> &s2) {
	std::set<T> result;
	std::set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
		std::inserter(result, result.end()));
	return result;
}

/**
* @brief Removes all values that are in @a toRemove from @a from.
*
* @tparam T Type of elements in the sets.
*/
template<typename T>
void removeFromSet(std::set<T> &from, const std::set<T> &toRemove) {
	// The solution using std::set_difference<> is slightly faster
	// than this manual loop:
	//
	//   for (auto &item : toRemove) {
	//       from.erase(item);
	//   }
	//
	// Timings (containers with 10000000 elements):
	//
	//   T           | std::set_difference | for loop |
	//   ------------|---------------------|----------|
	//   int         | 3.08s               |  4.43s   |
	//   std::string | 3.74s               |  6.87s   |
	//
	from = setDifference(from, toRemove);
}

/**
* @brief Returns @c true if @a s1 is disjoint with @a s2.
*
* @tparam T Type of elements in the sets.
*/
template<typename T>
bool areDisjoint(const std::set<T> &s1, const std::set<T> &s2) {
	// s1 and s2 are disjoint iff s1 \cap s2 = \emptyset
	// (see http://en.wikipedia.org/wiki/Disjoint_set)
	return setIntersection(s1, s2).empty();
}

/**
* @brief Returns @c true if @a s1 and @a s2 have at least one item in common.
*
* @tparam T Type of elements in the sets.
*/
template<typename T>
bool shareSomeItem(const std::set<T> &s1, const std::set<T> &s2) {
	return !areDisjoint(s1, s2);
}

/// @}

/// @name Operations with Maps
/// @{

/**
* @brief Returns all keys in the given map @a m.
*
* @tparam Map Type of the map (<tt>std::map</tt> or
*             <tt>std::unordered_map</tt>).
*/
template<typename Map>
std::set<typename Map::key_type> getKeysFromMap(const Map &m) {
	std::set<typename Map::key_type> keys;
	for (auto &p : m) {
		keys.insert(p.first);
	}
	return keys;
}

/**
* @brief Returns all values in the given map @a m.
*
* @tparam Map Type of the map (<tt>std::map</tt> or
*             <tt>std::unordered_map</tt>).
*/
template<typename Map>
std::set<typename Map::mapped_type> getValuesFromMap(const Map &m) {
	std::set<typename Map::mapped_type> keys;
	for (auto &p : m) {
		keys.insert(p.second);
	}
	return keys;
}

/**
* @brief Returns @c true if the given map @a m has a key @a k, @c false
*        otherwise.
*
* @tparam Map Type of the map (<tt>std::map</tt> or
*             <tt>std::unordered_map</tt>).
*/
template<typename Map>
bool mapHasKey(const Map &m, const typename Map::key_type &k) {
	return m.find(k) != m.end();
}

/**
* @brief Returns @c true if the given map @a m has a value @a v, @c false
*        otherwise.
*
* @tparam Map Type of the map (<tt>std::map</tt> or
*             <tt>std::unordered_map</tt>).
*/
template<typename Map>
bool mapHasValue(const Map &m, const typename Map::mapped_type &v) {
	for (auto &p : m) {
		if (p.second == v) {
			return true;
		}
	}
	return false;
}

/**
* @brief Returns the value associated to the given @a key in @a m, or
*        @a defaultValue if there is no @a key in @a m.
*
* @tparam Map Type of the map (<tt>std::map</tt> or
*             <tt>std::unordered_map</tt>).
*/
template<typename Map>
typename Map::mapped_type mapGetValueOrDefault(
		const Map &m,
		const typename Map::key_type &key,
		typename Map::mapped_type defaultValue = typename Map::mapped_type()) {
	auto i = m.find(key);
	return i != m.end() ? i->second : defaultValue;
}

/**
* @brief Returns the maximum value from @a m.
*
* If @a m is empty, this function returns <tt>Map::mapped_type()</tt>
* (default-constructed value).
*/
template<typename Map>
typename Map::mapped_type mapGetMaxValue(const Map &m) {
	auto max = std::max_element(m.begin(), m.end(),
		[] (const auto &p1, const auto &p2) { return p1.second < p2.second; });
	return max != m.end() ? max->second : typename Map::mapped_type();
}

/**
* @brief Adds the pair <tt><key, value></tt> to map @a m.
*
* @return Reference to the added value.
*
* @tparam Map Type of the map (<tt>std::map</tt> or
*             <tt>std::unordered_map</tt>).
*
* If the key already exists in the map, its value is overwritten.
*
* The behavior of this function is similar to <tt>m[key] = value</tt>, but does
* not require values in the map to have the default constructor. To use @c
* operator[] in a map, values in the map must have a default constructor. If
* this is not the case, you cannot use @c operator[].
*/
template<typename Map>
typename Map::mapped_type &addToMap(
		const typename Map::key_type &key,
		const typename Map::mapped_type &value,
		Map &m) {
	auto i = m.find(key);
	if (i != m.end()) {
		i->second = value;
		return i->second;
	}
	return m.emplace(key, value).first->second;
}

/**
* @brief Returns a new map that has swapped keys and values.
*
* @tparam K Type of objects serving as keys.
* @tparam V Type of objects serving as values.
*
* For example, if you have <tt>std::map<int, std::string></tt>, this function
* returns <tt>std::map<std::string, int></tt>.
*
* You have to ensure that all values in @c m are distinct; otherwise, the
* returned map may have less elements than @c m.
*/
template<typename K, typename V>
std::map<V, K> getMapWithSwappedKeysAndValues(const std::map<K, V> &m) {
	std::map<V, K> result;
	for (const auto &p : m) {
		result.emplace(p.second, p.first);
	}
	return result;
}

/// @}

/// @name Non-iterable Containers
///
/// They let you insert and check for elements as well as remove elements.
/// They will not let you iterate through them or perform anything that could
/// cause nondeterminism arraising from random order of elements in the
/// underlying container.
/// Use them if their operations are sufficient for your initiall purpose but
/// you are affraid that in future they could be used the wrong way and cause
/// nondeterminism.
/// @{

template <class Elem>
class NonIterableSet {
	public:
		NonIterableSet()
		{

		}
		NonIterableSet(std::initializer_list<Elem> il) :
			_data(il)
		{

		}

		void clear() {
			_data.clear();
		}

		std::pair<Elem, bool> insert(const Elem& val) {
			auto p = _data.insert(val);
			return {*p.first, p.second};
		}

		bool has(const Elem& val) const {
			return _data.find(val) != _data.end();
		}

		bool hasNot(const Elem& val) const {
			return _data.find(val) == _data.end();
		}

	protected:
		std::set<Elem> _data;
};

/// @}

/// @name Hash functor for enum class
///
/// This is universal hash functor for enum class that can be
/// used in std::unordered_map with enum class keys. The most
/// recent compilers support this implicitly, but older versions
/// of GCC need explicit hash function for user-defined enum classes.
///
/// Usage:
/// @code
/// enum class Fruit { Apple, Banana, Orange };
///
/// std::unordered_map<Fruit, std::string, EnumClassKeyHash> m;
/// @endcode
///
/// Solution insipred by: http://stackoverflow.com/a/24847480/2534752
/// @{

struct EnumClassKeyHash
{
	template <typename T>
	std::size_t operator()(T t) const
	{
		return static_cast<std::size_t>(t);
	}
};

/// @}

} // namespace utils
} // namespace retdec

#endif

```

`debug_remover/include/retdec/utils/conversion.h`:

```h
/**
* @file include/retdec/utils/conversion.h
* @brief Conversion utilities.
* @copyright (c) 2017 Avast Software, licensed under the MIT license
*/

#ifndef RETDEC_UTILS_CONVERSION_H
#define RETDEC_UTILS_CONVERSION_H

#include <iomanip>
#include <ios>
#include <limits>
#include <sstream>
#include <string>
#include <type_traits>
#include <vector>

namespace retdec {
namespace utils {

/// @name Conversions
/// @{

char* byteToHexString(uint8_t b, bool uppercase = true);

/**
 * Converts the given array of numbers into a hexadecimal string representation
 * @param data Array to be converted into a hexadecimal string
 * @param dataSize Size of array
 * @param result Into this parameter the result is stored
 * @param offset First byte from @a data which will be converted
 * @param size Number of bytes from @a data for conversion
 *    (0 means all bytes from @a offset)
 * @param uppercase @c true if hex letters (A-F) should be uppercase
 * @param spacing insert ' ' between every byte
 */
template<typename N> void bytesToHexString(
		const N *data,
		std::size_t dataSize,
		std::string &result,
		std::size_t offset = 0,
		std::size_t size = 0,
		bool uppercase = true,
		bool spacing = false)
{
	if (data == nullptr || offset >= dataSize)
	{
		return;
	}

	size = (size == 0 || offset + size > dataSize)
			? dataSize - offset
			: size;

	std::size_t hexIndex = 0;

	std::size_t sz = spacing ? (size * 3 - 1) : (size * 2);
	result.resize(sz);

	for (std::size_t i = 0; i < size; ++i)
	{
		if (spacing && hexIndex > 0)
		{
			result[hexIndex++] = ' ';
		}
		auto res = byteToHexString(data[offset + i], uppercase);
		result[hexIndex++] = res[0];
		result[hexIndex++] = res[1];
	}
}

/**
 * Converts the given vector of numbers into a hexadecimal string representation
 * @param bytes Vector to be converted into a hexadecimal string
 * @param result Into this parameter the result is stored
 * @param offset First byte from @a bytes which will be converted
 * @param size Number of bytes from @a bytes for conversion
 *    (0 means all bytes from @a offset)
 * @param uppercase @c true if hex letters (A-F) should be uppercase
 * @param spacing insert ' ' between every byte
 */
template<typename N> void bytesToHexString(
		const std::vector<N> &bytes,
		std::string &result,
		std::size_t offset = 0,
		std::size_t size = 0,
		bool uppercase = true,
		bool spacing = false)
{
	bytesToHexString(
			bytes.data(),
			bytes.size(),
			result,
			offset,
			size,
			uppercase,
			spacing
	);
}

/**
* @brief Converts the given integer into its hexadecimal representation.
*
* @param[in] w Number to be converted.
* @param[in] addBase Prepends "0x" before the result.
* @param[in] fillToN If needed, prepends "0" before the result to get at least
*                    @c fillToN characters long string.
*
* All letters in the result are lowercase.
*/
template<typename I>
std::string intToHexString(I w, bool addBase = false, unsigned fillToN = 0)
{
	static const char* digits = "0123456789abcdef";

	size_t hex_len = sizeof(I)<<1;

	std::string rc(hex_len,'0');
	for (size_t i = 0, j = (hex_len-1)*4 ; i < hex_len; ++i, j -= 4)
	{
		rc[i] = digits[(w>>j) & 0x0f];
	}

	bool started = false;
	std::string res;
	size_t j = 0;
	if (addBase)
	{
		res.resize(rc.size() + 2);
		res[0] = '0';
		res[1] = 'x';
		j = 2;
	}
	else
	{
		res.resize(rc.size());
	}
	for (size_t i = 0; i < rc.size(); ++i)
	{
		if (started)
		{
			res[j++] = rc[i];
		}
		else if (rc[i] != '0' || (rc.size() - i <= fillToN) || (i == rc.size() - 1))
		{
			res[j++] = rc[i];
			started = true;
		}
	}
	res.resize(j);

	return res;
}

std::vector<uint8_t> hexStringToBytes(const std::string& hexIn);

/**
* @brief Converts the given string into a number.
*
* @param[in] str String to be converted into a number.
* @param[out] number Into this parameter the resulting number is stored.
* @param[in] format Number format (e.g. std::dec, std::hex).
*
* @return @c true if the conversion went ok, @c false otherwise.
*
* If the conversion fails, @a number is left unchanged.
*/
template<typename N>
inline bool strToNum(const std::string &str, N &number,
		std::ios_base &(* format)(std::ios_base &) = std::dec) {
	std::istringstream strStream(str);
	N convNumber = 0;
	strStream >> format >> convNumber;
	if (strStream.fail() || !strStream.eof()) {
		return false;
	}

	// The above checks do not detect conversion of a negative number into an
	// unsigned integer. We have to perform an additional check here.
	if (std::is_unsigned<N>::value && str[0] == '-') {
		return false;
	}

	number = convNumber;
	return true;
}

namespace
{
	const std::size_t BITS_IN_BYTE = 8;
}

/**
 * @brief Converts the given array of numbers into a bits.
 *
 * @param[in] data Array of numbers.
 * @param[in] dataSize Size of array.
 *
 * @return Resulting string.
 */
template<typename N>
std::string bytesToBits(const N *data, std::size_t dataSize) {
	if(!data) {
		dataSize = 0;
	}

	std::string result;
	result.reserve(dataSize * BITS_IN_BYTE);

	for (std::size_t i = 0; i < dataSize; ++i) {
		auto& item = data[i];

		for(std::size_t j = 0; j < BITS_IN_BYTE; ++j) {
			// 0x80 = 0b10000000
			result += ((item << j) & 0x80) ? '1' : '0';
		}
	}

	return result;
}

/**
 * @brief Converts the given vector of numbers into a bits.
 *
 * @param[in] bytes Vector to be converted into a bits.
 *
 * @return Resulting string.
 */
template<typename N>
std::string bytesToBits(const std::vector<N> &bytes) {
	return bytesToBits(bytes.data(), bytes.size());
}
/**
 * Converts the given array of numbers into a string
 * @param data Array to be converted into a string
 * @param dataSize Size of array
 * @param result Into this parameter the result is stored
 * @param offset First byte from @a data which will be converted to string
 * @param size Number of bytes from @a data for conversion
 *    (0 means all bytes from @a offset)
 */
template<typename N> void bytesToString(
		const N *data,
		std::size_t dataSize,
		std::string &result,
		std::size_t offset = 0,
		std::size_t size = 0)
{
	if(!data)
	{
		dataSize = 0;
	}

	if(offset >= dataSize)
	{
		size = 0;
	}
	else
	{
		size = (size == 0 || offset + size > dataSize)
				? dataSize - offset
				: size;
	}

	result.clear();
	result.reserve(size);
	result = std::string(reinterpret_cast<const char*>(data + offset), size);
}

/**
 * Converts the given vector of numbers into a string
 * @param bytes Vector to be converted into a string
 * @param result Into this parameter the result is stored
 * @param offset First byte from @a bytes which will be converted to string
 * @param size Number of bytes from @a bytes for conversion
 *    (0 means all bytes from @a offset)
 */
template<typename N> void bytesToString(
		const std::vector<N> &bytes,
		std::string &result,
		std::size_t offset = 0,
		std::size_t size = 0)
{
	bytesToString(bytes.data(), bytes.size(), result, offset, size);
}

void double10ToDouble8(std::vector<unsigned char> &dest,
	const std::vector<unsigned char> &src);

unsigned short byteSwap16(unsigned short val);
unsigned int byteSwap32(unsigned int val);
std::string byteSwap16(const std::string &val);
std::string byteSwap32(const std::string &val);

/// @}

} // namespace utils
} // namespace retdec

#endif

```

`debug_remover/include/retdec/utils/filter_iterator.h`:

```h
/**
* @file include/retdec/utils/filter_iterator.h
* @brief An adapter of an iterator range in which some elements of the range
*        are skipped.
* @copyright (c) 2017 Avast Software, licensed under the MIT license
*/

#ifndef RETDEC_UTILS_FILTER_ITERATOR_H
#define RETDEC_UTILS_FILTER_ITERATOR_H

#include <functional>
#include <iterator>
#include <utility>

namespace retdec {
namespace utils {

/**
* @brief An adapter of an iterator range in which some elements of the range
*        are skipped.
*
* The filter iterator adapter creates a view of an iterator range in which some
* elements of the range are skipped. A predicate function object controls which
* elements are skipped. When the predicate is applied to an element, if it
* returns true, then the element is retained, and if it returns false, then the
* element is skipped over. When skipping over elements, it is necessary for the
* filter adapter to know when to stop so as to avoid going past the end of the
* underlying range. A filter iterator is, therefore, constructed with pair of
* iterators indicating the range of elements in the unfiltered sequence to be
* traversed and a predicate.
*
* Based on filter_iterator from Boost
* (http://www.boost.org/doc/libs/master/libs/iterator/doc/filter_iterator.html).
* See it for more information. Note, however, that our interface differs from
* the one provided by Boost.
*
* @tparam Iterator Type of the iterators in the range.
*/
template<typename Iterator>
class FilterIterator {
public:
	// Standard typedefs.
	using value_type = typename std::iterator_traits<Iterator>::value_type;
	using reference = typename std::iterator_traits<Iterator>::reference;
	using pointer = typename std::iterator_traits<Iterator>::pointer;
	using difference_type = typename std::iterator_traits<Iterator>::difference_type;
	using iterator_category = std::forward_iterator_tag;

public:
	/**
	* @brief Creates an iterator over the given range.
	*
	* @param[in] begin Start of the range.
	* @param[in] end End of the range.
	* @param[in] predicate Predicate for determining which elements should be
	*                      retained.
	*/
	template<typename Predicate>
	FilterIterator(Iterator begin, Iterator end, Predicate &&predicate):
			current(std::move(begin)),
			end(std::move(end)),
			predicate(std::forward<Predicate>(predicate)) {
		skipElementsWhilePredicateIsFalse();
	}

	/**
	* @brief Creates an iterator over the given container.
	*
	* @param[in] container Container to be iterated.
	* @param[in] predicate Predicate for determining which elements should be
	*                      retained.
	*
	* This constructor is a handy alias for the following code:
	* @code
	* FilterIterator(container.begin(), container.end(), predicate)
	* @endcode
	*/
	template<typename Container, typename Predicate>
	FilterIterator(Container &container, Predicate &&predicate):
		FilterIterator(std::begin(container), std::end(container),
			std::forward<Predicate>(predicate)) {}

	/**
	* @brief Creates an end iterator.
	*/
	FilterIterator(Iterator end): current(end), end(std::move(end)) {}

	FilterIterator(const FilterIterator &other) = default;

	FilterIterator(FilterIterator &&other) = default;

	~FilterIterator() = default;

	FilterIterator &operator=(const FilterIterator &other) = default;

	reference operator*() const {
		return *current;
	}

	pointer operator->() const {
		return &*current;
	}

	bool operator==(const FilterIterator &other) const {
		return current == other.current;
	}

	bool operator!=(const FilterIterator &other) const {
		return !(*this == other);
	}

	FilterIterator &operator++() {
		++current;
		skipElementsWhilePredicateIsFalse();
		return *this;
	}

private:
	void skipElementsWhilePredicateIsFalse() {
		while (current != end && !predicate(*current)) {
			++current;
		}
	}

private:
	Iterator current;
	Iterator end;
	std::function<bool (reference)> predicate;
};

} // namespace utils
} // namespace retdec

#endif

```

`debug_remover/include/retdec/utils/ord_lookup.h`:

```h
/**
 * @file include/retdec/utils/ord_lookup.h
 * @brief Converts well-known ordinals to function names
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#ifndef RETDEC_UTILS_ORD_LOOKUP_H
#define RETDEC_UTILS_ORD_LOOKUP_H

namespace retdec {
namespace utils {

std::string ordLookUp(const std::string& libName, const std::size_t& ordNum, bool forceNameFromOrdinal);

} // namespace utils
} // namespace retdec

#endif

```

`debug_remover/include/retdec/utils/string.h`:

```h
/**
* @file include/retdec/utils/string.h
* @brief String utilities.
* @copyright (c) 2017 Avast Software, licensed under the MIT license
*/

#ifndef RETDEC_UTILS_STRING_H
#define RETDEC_UTILS_STRING_H

#include <algorithm>
#include <limits>
#include <map>
#include <string>
#include <utility>
#include <vector>
#include <set>

namespace retdec {
namespace utils {

// We assume that the largest supported character size is 32 bits.
using WideCharType = std::uint32_t;

// Strings may have different character sizes, so we need to use a generic
// basic_string instead of std::string/std::wstring.
using WideStringType = std::basic_string<WideCharType>;

bool hasOnlyDecimalDigits(const std::string &str);

bool hasOnlyHexadecimalDigits(const std::string &str);

bool hasNonprintableChars(const std::string &str);
bool hasNonasciiChars(const std::string &str);

bool isLowerThanCaseInsensitive(const std::string &str1,
	const std::string &str2);

bool areEqualCaseInsensitive(const std::string &str1, const std::string &str2);

bool isShorterPrefixOfCaseInsensitive(const std::string &str1,
	const std::string &str2);

bool contains(const std::string &str, const std::string &sub);
bool containsAny(const std::string &str, const std::vector<std::string> &subs);

bool containsCaseInsensitive(const std::string &str, const std::string &sub);

bool containsAnyOfChars(const std::string &str, const std::string &chars);
bool containsAnyOfChars(const std::string &str, std::string::value_type c);

std::string toLower(std::string str);
std::string toUpper(std::string str);

std::string toWide(const std::string &str, std::string::size_type length);
std::string unicodeToAscii(const std::uint8_t *bytes, std::size_t nBytes);
std::string unicodeToAscii(const std::uint8_t *bytes, std::size_t nBytes, std::size_t &nRead);
std::string readNullTerminatedAscii(const std::uint8_t *bytes, std::size_t bytesLen,
							std::size_t offset = 0, std::size_t maxBytes = 0, bool failOnExceed = false);

std::string trim(std::string str, const std::string &toTrim = " \t\r\n\v");

std::vector<std::string> split(const std::string &str, char sep = ',',
	bool trimWhitespace = true);

std::string unifyLineEnds(const std::string &str);

/**
* @brief Joins all the strings in @a strings into a single string.
*
* @param[in] strings Strings to be joined.
* @param[in] separator Separator to separate individual strings.
*
* @tparam Container Type of @a strings.
*
* If Container is an unordered container, the order depends on the
* implementation of the container.
*/
template<typename Container>
std::string joinStrings(const Container &strings,
		const std::string &separator = ", ") {
	std::string joined;
	for (auto &s : strings) {
		if (!joined.empty()) {
			joined += separator;
		}
		joined += s;
	}
	return joined;
}

// The number 4 below is needed because of the null byte.
std::string addSlashes(const std::string &str,
	const std::string &toBackslash = std::string("\"'\\\0", 4));

std::string replaceCharsWithStrings(const std::string &str, char what,
	const std::string &withWhat);

/**
* @brief Returns @c true if @a str starts with the prefix @a withWhat, @c false
*        otherwise.
*
* @tparam String Either @c std::string or <code>char *</code>.
*/
template<typename String>
bool startsWith(const std::string &str, const String &withWhat) {
	return str.find(withWhat, 0) == 0;
}

bool endsWith(const std::string &str, const std::string &withWhat);
bool endsWith(const std::string &str, char withWhat);
bool endsWith(const std::string &str, const std::set<std::string>& withWhat);
bool hasSubstringOnPosition(const std::string &str,
	const std::string &withWhat,
	std::string::size_type position);
bool hasSubstringInArea(const std::string &str, const std::string &withWhat,
	std::string::size_type start, std::string::size_type stop);

bool isComposedOnlyOfChars(const std::string &str, const std::string &chars);
bool isComposedOnlyOfChars(const std::string &str, std::string::value_type c);

bool isComposedOnlyOfStrings(const std::string &str, const std::string &ss);

std::string stripDirs(const std::string &path);

std::string replaceAll(const std::string &str, const std::string &from,
	const std::string &to);

std::string replaceNonprintableChars(const std::string &str);
std::string replaceNonasciiChars(const std::string &str);
std::string replaceNonalnumCharsWith(const std::string &str, std::string::value_type c);

std::string removeWhitespace(std::string s);

std::pair<std::size_t, std::size_t> getLineAndColumnFromPosition(
	const std::string &json, std::size_t position);

bool isNumber(const std::string &str);
bool isIdentifier(const std::string &str);
bool isPrintable(const std::string &str);

std::string removeLeadingCharacter(
	const std::string &s,
	char leading,
	std::size_t n = std::numeric_limits<std::size_t>::max());

bool isContolCharacter(char c);
bool isNiceCharacter(unsigned char c);
bool isNiceString(const std::string &str, double maxRatio = 2.0/3);
bool isNiceAsciiWideCharacter(unsigned long long c);
bool isNiceAsciiWideString(
		const std::vector<unsigned long long> &str,
		double minRatio = 1.0);

std::string getIndentation(std::size_t count, char c = '\t');

void appendHex(std::string &n, const long long a);
void appendDec(std::string &n, const long long a);
std::string appendHexRet(const std::string &n, const long long a);
std::string appendDecRet(const std::string &n, const long long a);
void removeSuffix(std::string &n, const std::string &suffix = "_");
std::string removeSuffixRet(const std::string &n,
	const std::string &suffix = "_");

std::string normalizeName(const std::string &name);
std::string normalizeNamePrefix(const std::string &name);

bool findFirstInEmbeddedLists(std::size_t &pos, const std::string &str,
	char c, const std::vector<std::pair<char, char>> &pairs);

std::string removeConsecutiveSpaces(const std::string& str);

std::string asEscapedCString(const WideStringType& value, std::size_t charSize);

std::string removeComments(const std::string& str, char commentChar);

std::string extractVersion(const std::string& input);

} // namespace utils
} // namespace retdec

#endif

```

`debug_remover/main.cpp`:

```cpp
#include <iostream>
#include <filesystem>

// PeLib (https://github.com/iArtorias/pelib-updated | https://github.com/avast/retdec)
#include <retdec/pelib/PeFile.h>
#include <retdec/pelib/DebugDirectory.h>

namespace fs = std::filesystem;
namespace pe = PeLib;

// Error codes
constexpr const char* ERROR_USAGE{ "Usage: debug_remover <binary>" };
constexpr const char* ERROR_NOT_EXIST{ "The specified file doesn't exist" };
constexpr const char* ERROR_EMPTY_FILE{ "The specified file is empty" };
constexpr const char* ERROR_EMPTY_DATA{ "The binary data is empty" };
constexpr const char* ERROR_PE_PARSE{ "An error has occured while trying to parse the PE header" };
constexpr const char* ERROR_NO_DIR{ "Debug directory doesn't exist" };
constexpr const char* ERROR_NO_ENTRIES{ "No debug entries found" };
constexpr const char* ERROR_NULL_OFFSET{ "Debug directory offset is null" };


// Writes the output binary file
inline void write_file( const fs::path& filename, pe::ByteBuffer& data )
{
	std::ofstream out( filename, std::ios::out | std::ios::binary );

	if (out.is_open())
		out.write( reinterpret_cast<const char*>(data.data()), data.size() );

	out.close();
}


// Posts an error message
inline void post_error( const char* msg )
{
	std::cout << msg << std::endl;
	static_cast<void>(std::getchar());
}


// Reads the whole binary file into string
inline std::string bin_to_string( const fs::path& binary_in )
{
	std::string data{};
	std::ifstream file( binary_in, std::ios::in | std::ios::binary );

	if (file.is_open())
	{
		file.seekg( 0x0, std::ios::end );
		data.resize( static_cast<size_t>(fs::file_size( binary_in )) );
		file.seekg( 0x0, std::ios::beg );
		file.read( data.data(), data.size() );
	}

	file.close();

	return data;
}


// Fill the buffer with zeroes at the specific offset
inline void fill_with_zeroes( pe::ByteBuffer& buffer, const uint32_t offset, const uint32_t size )
{
	std::fill( buffer.begin() + offset, buffer.begin() + offset + size, '\0' );
}


int main( int argc, char* argv[] )
{
	if (argc < 0x2)
	{
		post_error( ERROR_USAGE );
		return -1;
	}

	// Input binary file
	auto const binary_in = fs::path( argv[0x1] );

	// Output binary file
	auto const binary_out = binary_in.parent_path() / binary_in.stem() += fs::path( "_stripped" ) += binary_in.extension();

	if (!fs::exists( binary_in ))
	{
		post_error( ERROR_NOT_EXIST );
		return -1;
	}

	if (fs::is_empty( binary_in ))
	{
		post_error( ERROR_EMPTY_FILE );
		return -1;
	}

	// Read the whole binary into string
	auto const data = bin_to_string( binary_in );

	if (data.empty())
	{
		post_error( ERROR_EMPTY_DATA );
		return -1;
	}

	// Represent string as vector of bytes 
	pe::ByteBuffer byte_buffer( data.begin(), data.end() );

	auto parse = new pe::PeFileT( binary_in.generic_string() );

	// Parse/read the whole binary
	auto error = parse->loadPeHeaders( byte_buffer );
	if (error != pe::ERROR_NONE)
	{
		post_error( ERROR_PE_PARSE );
		return -1;
	}

	error = parse->readDebugDirectory();
	if (error == pe::ERROR_DIRECTORY_DOES_NOT_EXIST)
	{
		post_error( ERROR_NO_DIR );
		return -1;
	}

	// Debug directory accessor
	auto debug_dir = parse->debugDir();

	auto const num_entries = debug_dir.calcNumberOfEntries();
	if (num_entries == 0x0)
	{
		post_error( ERROR_NO_ENTRIES );
		return -1;
	}

	// Dos header accessor and more
	pe::ImageLoader& loader = parse->imageLoader();

	// Look for the valid PE signature (0x50450000)
	uint32_t found = data.find( "PE\0\0" );

	if (found != std::string::npos)
	{
		// Find the debug directory field offset and fill it with zeroes
		auto field_offset = loader.getFieldOffset( pe::PELIB_MEMBER_TYPE::OPTHDR_DataDirectory_DEBUG_Rva );
		fill_with_zeroes( byte_buffer, (found + field_offset), 0x8 ); // 0x8 = VirtualAddress + Size 
	}

	// Obtain the debug directory structure offset
	auto const debug_dir_offset = loader.getFileOffsetFromRva( loader.getDataDirRva( pe::PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG ) );

	if (debug_dir_offset == 0x0)
	{
		post_error( ERROR_NULL_OFFSET );
		return -1;
	}

	fill_with_zeroes( byte_buffer, debug_dir_offset, pe::PELIB_IMAGE_DEBUG_DIRECTORY::size() * num_entries ); // 28 * number of found debug entries

	// Iterate through the available debug entries
	for (uint32_t i{ 0x0 }; i < num_entries; i++)
	{
		// Obtain the size and offset of the data directory for specific entry
		auto const entry_offset = debug_dir.getPointerToRawData( i );
		auto const entry_size = debug_dir.getSizeOfData( i );

		fill_with_zeroes( byte_buffer, entry_offset, entry_size );
	}

	write_file( binary_out, byte_buffer);
}
```

`debug_remover/src/pelib/BoundImportDirectory.cpp`:

```cpp
/*
* BoundImportDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include <numeric>
#include <set>
#include <map>

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/BoundImportDirectory.h"

namespace PeLib
{
	/**
	* Adds another bound import to the BoundImport directory.
	* @param strModuleName Name of the PE file which will be imported.
	* @param dwTds Value of the TimeDateStamp of the bound import field.
	* @param wOmn Value of the OffsetModuleName of the bound import field.
	* @param wWfr Value of the NumberOfModuleForwarderRefs of the bound import field.
	**/
	int BoundImportDirectory::addBoundImport(const std::string& strModuleName, std::uint32_t dwTds, std::uint16_t wOmn, std::uint16_t wWfr)
	{
		for (unsigned int i=0;i<m_vIbd.size();i++)
		{
			if (isEqualNc(strModuleName, m_vIbd[i].strModuleName))
			{
				return ERROR_DUPLICATE_ENTRY;
			}
		}

		PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR ibidCurrent;
		ibidCurrent.TimeDateStamp = dwTds;
		ibidCurrent.OffsetModuleName = wOmn;
		ibidCurrent.NumberOfModuleForwarderRefs = wWfr;
		PELIB_IMAGE_BOUND_DIRECTORY ibdCurrent;
		ibdCurrent.ibdDescriptor = ibidCurrent;
		ibdCurrent.strModuleName = strModuleName;
		m_vIbd.push_back(ibdCurrent);

		return ERROR_NONE;
	}

	/**
	* Searches for the first instance of a module with the given modulename.
	* @param strModuleName The name of a module.
	* @return The id of the module.
	**/
	int BoundImportDirectory::getModuleIndex(const std::string& strModuleName) const
	{
		auto Iter = std::find_if(
				m_vIbd.begin(),
				m_vIbd.end(),
				[&](const auto& i) { return i.equal(strModuleName); }
		);

		if (Iter == m_vIbd.end())
		{
			return ERROR_ENTRY_NOT_FOUND;
		}

		return static_cast<int>(std::distance(m_vIbd.begin(), Iter));
	}

	/**
	* @return Number of files in the current BoundImport directory.
	**/
	unsigned int BoundImportDirectory::calcNumberOfModules() const
	{
		return static_cast<unsigned int>(m_vIbd.size());
	}

	/**
	* Searches for the first instance of a module with the given modulename.
	* @param inpBuffer Reference to the input buffer
	* @param data source data
	* @param dwSize length of the source data
	* @return ERROR_NONE if success, otherwise an error code.
	**/
	int BoundImportDirectory::read(InputBuffer& inpBuffer, unsigned char* data, unsigned int dwSize)
	{
		std::vector<PELIB_IMAGE_BOUND_DIRECTORY> currentDirectory;

		do
		{
			if (inpBuffer.get() + PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size() >= inpBuffer.size())
				return ERROR_INVALID_FILE;

			PELIB_IMAGE_BOUND_DIRECTORY ibdCurrent;

			inpBuffer >> ibdCurrent.ibdDescriptor.TimeDateStamp;
			inpBuffer >> ibdCurrent.ibdDescriptor.OffsetModuleName;
			inpBuffer >> ibdCurrent.ibdDescriptor.NumberOfModuleForwarderRefs;

			if (ibdCurrent.ibdDescriptor.TimeDateStamp == 0 && ibdCurrent.ibdDescriptor.OffsetModuleName == 0 && ibdCurrent.ibdDescriptor.NumberOfModuleForwarderRefs == 0) break;

			for (int i=0;i<ibdCurrent.ibdDescriptor.NumberOfModuleForwarderRefs;i++)
			{
				if (inpBuffer.get() + PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size() >= inpBuffer.size())
					return ERROR_INVALID_FILE;

				PELIB_IMAGE_BOUND_DIRECTORY currentForwarder;

				inpBuffer >> currentForwarder.ibdDescriptor.TimeDateStamp;
				inpBuffer >> currentForwarder.ibdDescriptor.OffsetModuleName;
				inpBuffer >> currentForwarder.ibdDescriptor.NumberOfModuleForwarderRefs;

				ibdCurrent.moduleForwarders.push_back(currentForwarder);
			}

			currentDirectory.push_back(ibdCurrent);
			ibdCurrent.moduleForwarders.clear();
		} while (true);

		for (unsigned int i=0;i<currentDirectory.size();i++)
		{
			std::uint32_t wOmn = currentDirectory[i].ibdDescriptor.OffsetModuleName;
			if (wOmn > dwSize)
			{
				return ERROR_INVALID_FILE;
			}

			currentDirectory[i].strModuleName = "";
			for (int k=0;k + wOmn < dwSize && data[wOmn + k] != 0;k++)
			{
				currentDirectory[i].strModuleName += data[wOmn + k];
			}

			for (unsigned int j=0;j<currentDirectory[i].moduleForwarders.size();j++)
			{
				std::uint32_t wOmn2 = currentDirectory[i].moduleForwarders[j].ibdDescriptor.OffsetModuleName;
				if (wOmn2 > dwSize)
				{
					return ERROR_INVALID_FILE;
				}

//				m_vIbd[i].moduleForwarders[j].strModuleName.assign((char*)(&vBimpDir[wOmn2]));
				currentDirectory[i].moduleForwarders[j].strModuleName = "";
				for (int k=0;k + wOmn2 < dwSize && data[wOmn2 + k] != 0;k++)
				{
					currentDirectory[i].moduleForwarders[j].strModuleName += data[wOmn2 + k];
				}
			}
		}

		std::swap(m_vIbd, currentDirectory);

		return ERROR_NONE;
	}

	int BoundImportDirectory::read(unsigned char* pcBuffer, unsigned int uiSize)
	{
		std::vector<unsigned char> vBimpDir(pcBuffer, pcBuffer + uiSize);
		InputBuffer inpBuffer(vBimpDir);

		return read(inpBuffer, vBimpDir.data(), uiSize);
	}

	/**
	* Reads the BoundImport directory from a PE file.
	* @param imageLoader Reference to the image loader
	**/
	int BoundImportDirectory::read(ImageLoader & imageLoader)
	{
		std::uint32_t importRva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT);
		std::uint32_t importSize = imageLoader.getDataDirSize(PELIB_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT);
		std::uint32_t sizeOfImage = imageLoader.getSizeOfImage();

		// Refuse to load blatantly invalid bound import directory
		if(importSize & 0xFF000000)
			return ERROR_INVALID_FILE;

		// Refuse to load too large import directories
		if((importRva + importSize) < importRva || importRva >= sizeOfImage || (importRva + importSize) >= sizeOfImage)
			return ERROR_INVALID_FILE;

		std::vector<unsigned char> vBimpDir(importSize);
		imageLoader.readImage(reinterpret_cast<char*>(vBimpDir.data()), importRva, importSize);

		InputBuffer inpBuffer{vBimpDir};
		return BoundImportDirectory::read(inpBuffer, vBimpDir.data(), importSize);
	}

	unsigned int BoundImportDirectory::totalModules() const
	{
		unsigned int modules = static_cast<unsigned int>(m_vIbd.size());

		for (unsigned int i=0;i<m_vIbd.size();i++)
		{
			modules += static_cast<unsigned int>(m_vIbd[i].moduleForwarders.size());
		}

		return modules;
	}

	/**
	* Rebuilds the BoundImport directory. The rebuilded BoundImport directory can then be
	* written back to a PE file.
	* @param vBuffer Buffer where the rebuilt BoundImport directory will be stored.
	* @param fMakeValid If this flag is true a valid directory will be produced.
	**/
	void BoundImportDirectory::rebuild(std::vector<std::uint8_t>& vBuffer, bool fMakeValid) const
	{
		std::map<std::string, std::uint16_t> filename_offsets;

		OutputBuffer obBuffer(vBuffer);

		std::uint16_t ulNameOffset = static_cast<std::uint16_t>((totalModules() + 1) * PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size());

		for (unsigned int i=0;i<m_vIbd.size();i++)
		{
			obBuffer << m_vIbd[i].ibdDescriptor.TimeDateStamp;

			// Recalculate the offsets if a valid directory is wanted.
			if (fMakeValid)
			{
				if (filename_offsets.find(m_vIbd[i].strModuleName) == filename_offsets.end())
				{
					filename_offsets[m_vIbd[i].strModuleName] = ulNameOffset;
					obBuffer << ulNameOffset;
					ulNameOffset += static_cast<std::uint16_t>(m_vIbd[i].strModuleName.size() + 1);
				}
				else
				{
					obBuffer << filename_offsets[m_vIbd[i].strModuleName];
				}
			}
			else // Otherwise just copy the old values into the buffer.
			{
				obBuffer << m_vIbd[i].ibdDescriptor.OffsetModuleName;
			}

			obBuffer << m_vIbd[i].ibdDescriptor.NumberOfModuleForwarderRefs;

			for (int j=0;j<calcNumberOfModuleForwarderRefs(i);j++)
			{
				obBuffer << m_vIbd[i].moduleForwarders[j].ibdDescriptor.TimeDateStamp;

				if (fMakeValid)
				{
					if (filename_offsets.find(m_vIbd[i].strModuleName) == filename_offsets.end())
					{
						filename_offsets[m_vIbd[i].moduleForwarders[j].strModuleName] = ulNameOffset;
						obBuffer << ulNameOffset;
						ulNameOffset += static_cast<std::uint16_t>(m_vIbd[i].moduleForwarders[j].strModuleName.size() + 1);
					}
					else
					{
						obBuffer << filename_offsets[m_vIbd[i].moduleForwarders[j].strModuleName];
					}
				}
				else // Otherwise just copy the old values into the buffer.
				{
					obBuffer << m_vIbd[i].moduleForwarders[j].ibdDescriptor.OffsetModuleName;
				}

				obBuffer << m_vIbd[i].moduleForwarders[j].ibdDescriptor.NumberOfModuleForwarderRefs;
			}
		}

		obBuffer << static_cast<std::uint32_t>(0);
		obBuffer << static_cast<std::uint16_t>(0);
		obBuffer << static_cast<std::uint16_t>(0);

		for (unsigned int i=0;i<m_vIbd.size();i++)
		{
			if (filename_offsets.find(m_vIbd[i].strModuleName) != filename_offsets.end())
			{
				obBuffer.add(getModuleName(i).c_str(), static_cast<unsigned long>(getModuleName(i).size() + 1));
				filename_offsets.erase(m_vIbd[i].strModuleName);
			}

			for (int j=0;j<calcNumberOfModuleForwarderRefs(i);j++)
			{
				if (filename_offsets.find(getModuleName(i, j)) != filename_offsets.end())
				{
					obBuffer.add(getModuleName(i, j).c_str(), static_cast<unsigned long>(getModuleName(i, j).size() + 1));
					filename_offsets.erase(getModuleName(i, j));
				}
			}
		}
	}

	/**
	* Removes all bound import files.
	**/
	void BoundImportDirectory::clear()
	{
		m_vIbd.clear();
	}

	/**
	* Removes a field specified by the parameter filename from the BoundImport directory.
	* @param strModuleName Name of the file whose field will be removed from the BoundImport directory.
	**/
	void BoundImportDirectory::removeBoundImport(const std::string& strModuleName)
	{
		m_vIbd.erase(
			std::remove_if(
				m_vIbd.begin(),
				m_vIbd.end(),
				[&](const auto& i) { return i.equal(strModuleName); }
			),
			m_vIbd.end()
		);
	}

	/**
	* Returns the size of the rebuilt BoundImportDirectory.
	* @return Size of the rebuilt BoundImportDirectory.
	**/
	unsigned int BoundImportDirectory::size() const
	{
		unsigned int size2 = PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size();

		std::set<std::string> filenames;

		for (unsigned int i = 0; i < m_vIbd.size(); i++)
		{
			filenames.insert(m_vIbd[i].strModuleName);

			size2 += PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size();

			for (unsigned int j = 0; j < m_vIbd[i].moduleForwarders.size(); j++)
			{
				filenames.insert(m_vIbd[i].moduleForwarders[j].strModuleName);

				size2 += PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size();
			}
		}

		for (std::set<std::string>::iterator iter = filenames.begin(); iter != filenames.end(); ++iter)
		{
			size2 += static_cast<unsigned int>(iter->size()) + 1;
		}

		return size2;
	}

	/**
	* @param strFilename Name of the file.
	* @param dwOffset File offset the bound importdirectory will be written to.
	* @param fMakeValid If this flag is true a valid directory will be produced.
	**/
	int BoundImportDirectory::write(const std::string& strFilename, std::uint32_t dwOffset,  bool fMakeValid) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);

		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(dwOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer, fMakeValid);

		ofFile.write(reinterpret_cast<const char*>(vBuffer.data()), static_cast<std::streamsize>(vBuffer.size()));

		ofFile.close();

		return ERROR_NONE;
	}

	/**
	* Retrieves the value of the TimeDateStamp value of a bound import field.
	* @param dwBidnr Number of the bound import field.
	* @return Value of the TimeDateStamp of the bound import field.
	**/
	std::uint32_t BoundImportDirectory::getTimeDateStamp(std::uint32_t dwBidnr) const
	{
		return m_vIbd[dwBidnr].ibdDescriptor.TimeDateStamp;
	}

	/**
	* Retrieves the value of the OffsetModuleName value of a bound import field.
	* @param dwBidnr Number of the bound import field.
	* @return Value of the OffsetModuleName of the bound import field.
	**/
	std::uint16_t BoundImportDirectory::getOffsetModuleName(std::uint32_t dwBidnr) const
	{
		return m_vIbd[dwBidnr].ibdDescriptor.OffsetModuleName;
	}

	/**
	* Retrieves the value of the NumberOfModuleForwarderRefs value of a bound import field.
	* @param dwBidnr Number of the bound import field.
	* @return Value of the NumberOfModuleForwarderRefs of the bound import field.
	**/
	std::uint16_t BoundImportDirectory::getNumberOfModuleForwarderRefs(std::uint32_t dwBidnr) const
	{
		return m_vIbd[dwBidnr].ibdDescriptor.NumberOfModuleForwarderRefs;
	}

	/**
	* Retrieves the value of the ModuleName value of a bound import field.
	* @param dwBidnr Number of the bound import field.
	* @return Value of the ModuleName of the bound import field.
	**/
	std::string BoundImportDirectory::getModuleName(std::uint32_t dwBidnr) const
	{
		return m_vIbd[dwBidnr].strModuleName;
	}

	/**
	* Changes the TimeDateStamp value of an existing bound import field.
	* @param dwBidnr Number of the bound import field which will be changed.
	* @param dwTds New value of the TimeDateStamp of the bound import field.
	**/
	void BoundImportDirectory::setTimeDateStamp(std::uint32_t dwBidnr, std::uint32_t dwTds)
	{
		m_vIbd[dwBidnr].ibdDescriptor.TimeDateStamp = dwTds;
	}

	/**
	* Changes the OffsetModuleName value of an existing bound import field.
	* @param dwBidnr Number of the bound import field which will be changed.
	* @param wOmn New value of the OffsetModuleName of the bound import field.
	**/
	void BoundImportDirectory::setOffsetModuleName(std::uint32_t dwBidnr, std::uint16_t wOmn)
	{
		m_vIbd[dwBidnr].ibdDescriptor.OffsetModuleName = wOmn;
	}

	/**
	* Changes the NumberOfModuleForwarderRefs value of an existing bound import field.
	* @param dwBidnr Number of the bound import field which will be changed.
	* @param wMfr New value of the NumberOfModuleForwarderRefs of the bound import field.
	**/
	void BoundImportDirectory::setNumberOfModuleForwarderRefs(std::uint32_t dwBidnr, std::uint16_t wMfr)
	{
		m_vIbd[dwBidnr].ibdDescriptor.NumberOfModuleForwarderRefs = wMfr;
	}

	/**
	* Changes the ModuleName value of an existing bound import field.
	* @param dwBidnr Number of the bound import field which will be changed.
	* @param strModuleName New value of the ModuleName of the bound import field.
	**/
	void BoundImportDirectory::setModuleName(std::uint32_t dwBidnr, const std::string& strModuleName)
	{
		m_vIbd[dwBidnr].strModuleName = strModuleName;
	}

	std::uint32_t BoundImportDirectory::getTimeDateStamp(std::uint32_t dwBidnr, std::uint32_t forwardedModule) const
	{
		return m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.TimeDateStamp;
	}

	std::uint16_t BoundImportDirectory::getOffsetModuleName(std::uint32_t dwBidnr, std::uint32_t forwardedModule) const
	{
		return m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.OffsetModuleName;
	}

	std::uint16_t BoundImportDirectory::getNumberOfModuleForwarderRefs(std::uint32_t dwBidnr, std::uint32_t forwardedModule) const
	{
		return m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.NumberOfModuleForwarderRefs;
	}

	std::string BoundImportDirectory::getModuleName(std::uint32_t dwBidnr, std::uint32_t forwardedModule) const
	{
		return m_vIbd[dwBidnr].moduleForwarders[forwardedModule].strModuleName;
	}

	void BoundImportDirectory::setTimeDateStamp(std::uint32_t dwBidnr, std::uint32_t forwardedModule, std::uint32_t dwTds)
	{
		m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.TimeDateStamp = dwTds;
	}

	void BoundImportDirectory::setOffsetModuleName(std::uint32_t dwBidnr, std::uint32_t forwardedModule, std::uint16_t wOmn)
	{
		m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.OffsetModuleName = wOmn;
	}

	void BoundImportDirectory::setNumberOfModuleForwarderRefs(std::uint32_t dwBidnr, std::uint32_t forwardedModule, std::uint16_t wMfr)
	{
		m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.NumberOfModuleForwarderRefs = wMfr;
	}

	void BoundImportDirectory::setModuleName(std::uint32_t dwBidnr, std::uint32_t forwardedModule, const std::string& strModuleName)
	{
		m_vIbd[dwBidnr].moduleForwarders[forwardedModule].strModuleName = strModuleName;
	}

	std::uint16_t BoundImportDirectory::calcNumberOfModuleForwarderRefs(std::uint32_t dwBidnr) const
	{
		return static_cast<std::uint16_t>(m_vIbd[dwBidnr].moduleForwarders.size());
	}

	void BoundImportDirectory::addForwardedModule(std::uint32_t dwBidnr, const std::string& name, std::uint32_t timeStamp, std::uint16_t offsetModuleName, std::uint16_t forwardedModules)
	{
		// XXX: Maybe test if there are already 0xFFFF forwarded modules.
		// XXX: Check for duplicate entries. Is it also necessary to check
		//      non-forwarded entries and forwarded entries in other non-forwarded
		//      entries?
		// XXX: Can forwarders forward recursively?

		PELIB_IMAGE_BOUND_DIRECTORY ibdCurrent;
		ibdCurrent.strModuleName = name;
		ibdCurrent.ibdDescriptor.TimeDateStamp = timeStamp;
		ibdCurrent.ibdDescriptor.OffsetModuleName = offsetModuleName;
		ibdCurrent.ibdDescriptor.NumberOfModuleForwarderRefs = forwardedModules;

		m_vIbd[dwBidnr].moduleForwarders.push_back(ibdCurrent);
	}

	void BoundImportDirectory::removeForwardedModule(std::uint32_t dwBidnr, std::uint16_t forwardedModule)
	{
		m_vIbd[dwBidnr].moduleForwarders.erase(m_vIbd[dwBidnr].moduleForwarders.begin() + forwardedModule);
	}
}

```

`debug_remover/src/pelib/CoffSymbolTable.cpp`:

```cpp
/**
 * @file CoffSymbolTable.cpp
 * @brief Class for COFF symbol table.
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/CoffSymbolTable.h"

namespace PeLib
{
	CoffSymbolTable::CoffSymbolTable() : stringTableSize(0), numberOfStoredSymbols(0), m_ldrError(LDR_ERROR_NONE)
	{

	}

	CoffSymbolTable::~CoffSymbolTable()
	{

	}

	void CoffSymbolTable::read(InputBuffer& inputbuffer, unsigned int uiSize)
	{
		PELIB_IMAGE_COFF_SYMBOL symbol;

		for (std::size_t i = 0, e = uiSize / PELIB_IMAGE_SIZEOF_COFF_SYMBOL; i < e; ++i)
		{
			symbol.Name.clear();
			std::uint32_t Zeroes, NameOffset;
			inputbuffer >> Zeroes;
			inputbuffer >> NameOffset;
			inputbuffer >> symbol.Value;
			inputbuffer >> symbol.SectionNumber;
			inputbuffer >> symbol.TypeComplex;
			inputbuffer >> symbol.TypeSimple;
			inputbuffer >> symbol.StorageClass;
			inputbuffer >> symbol.NumberOfAuxSymbols;
			symbol.Index = (std::uint32_t)i;
			if (!Zeroes)
			{
				if (stringTableSize && NameOffset)
				{
					for (std::size_t j = NameOffset; j < stringTableSize && stringTable[j] != '\0'; ++j)
					{
						// If we have symbol name with length of COFF_SYMBOL_NAME_MAX_LENGTH and it
						// contains non-printable character, stop there because it does not seem to be valid.
						if (j - NameOffset == COFF_SYMBOL_NAME_MAX_LENGTH)
						{
							auto nonPrintableChars = std::count_if(symbol.Name.begin(), symbol.Name.end(), [](unsigned char c) { return !isprint(c); });
							if (nonPrintableChars != 0)
								break;
						}

						symbol.Name += stringTable[j];
					}
				}
			}
			else
			{
				for (std::size_t j = i * PELIB_IMAGE_SIZEOF_COFF_SYMBOL, k = 0; k < 8 && symbolTableDump[j] != '\0'; ++j, ++k)
				{
					symbol.Name += symbolTableDump[j];
				}
			}

			i += symbol.NumberOfAuxSymbols;
			inputbuffer.move(symbol.NumberOfAuxSymbols * PELIB_IMAGE_SIZEOF_COFF_SYMBOL);
			symbolTable.push_back(symbol);
		}

		numberOfStoredSymbols = (std::uint32_t)symbolTable.size();
	}

	int CoffSymbolTable::read(ByteBuffer & fileData, std::size_t uiOffset, std::size_t uiSize)
	{
		// Check for overflow
		if ((uiOffset + uiSize) < uiOffset)
		{
			return ERROR_INVALID_FILE;
		}

		std::size_t ulFileSize = fileData.size();
		std::size_t stringTableOffset = uiOffset + uiSize;
		if (uiOffset >= ulFileSize || stringTableOffset >= ulFileSize)
		{
			return ERROR_INVALID_FILE;
		}

		// Copy part of the file data into symbol table dump
		symbolTableDump.assign(fileData.begin() + uiOffset, fileData.begin() + uiOffset + uiSize);
		uiOffset += uiSize;

		InputBuffer ibBuffer(symbolTableDump);

		// Read size of string table
		if (ulFileSize >= stringTableOffset + 4)
		{
			stringTable.resize(sizeof(std::uint32_t));
			memcpy(&stringTableSize, fileData.data() + stringTableOffset, sizeof(uint32_t));
			*reinterpret_cast<std::uint32_t *>(stringTable.data()) = stringTableSize;
			uiOffset = stringTableOffset + sizeof(uint32_t);
		}

		if(ulFileSize > uiOffset)
		{
			if ((ulFileSize - uiOffset) < 4)
			{
				memcpy(&stringTableSize, fileData.data() + stringTableOffset, sizeof(uint32_t));
			}
			else if ((ulFileSize - uiOffset) == 4 && stringTableSize < 4)
			{
				stringTableSize = 4;
			}
		}

		if (stringTableSize > ulFileSize || uiOffset + stringTableSize > ulFileSize)
		{
			stringTableSize = (ulFileSize - uiOffset) + 4;
		}

		// read string table
		if (stringTableSize > 4)
		{
			stringTable.resize(stringTableSize);
			memcpy(stringTable.data() + 4, fileData.data() + uiOffset, stringTableSize - 4);
		}

		read(ibBuffer, uiSize);
		return ERROR_NONE;
	}

	LoaderError CoffSymbolTable::loaderError() const
	{
		return m_ldrError;
	}

	void CoffSymbolTable::setLoaderError(LoaderError ldrError)
	{
		if (m_ldrError == LDR_ERROR_NONE)
		{
			m_ldrError = ldrError;
		}
	}

	std::size_t CoffSymbolTable::getSizeOfStringTable() const
	{
		return stringTableSize;
	}

	std::size_t CoffSymbolTable::getNumberOfStoredSymbols() const
	{
		return numberOfStoredSymbols;
	}

	std::uint32_t CoffSymbolTable::getSymbolIndex(std::size_t ulSymbol) const
	{
		return symbolTable[ulSymbol].Index;
	}

	const std::string & CoffSymbolTable::getSymbolName(std::size_t ulSymbol) const
	{
		return symbolTable[ulSymbol].Name;
	}

	std::uint32_t CoffSymbolTable::getSymbolValue(std::size_t ulSymbol) const
	{
		return symbolTable[ulSymbol].Value;
	}

	std::uint16_t CoffSymbolTable::getSymbolSectionNumber(std::size_t ulSymbol) const
	{
		return symbolTable[ulSymbol].SectionNumber;
	}

	std::uint8_t CoffSymbolTable::getSymbolTypeComplex(std::size_t ulSymbol) const
	{
		return symbolTable[ulSymbol].TypeComplex;
	}

	std::uint8_t CoffSymbolTable::getSymbolTypeSimple(std::size_t ulSymbol) const
	{
		return symbolTable[ulSymbol].TypeSimple;
	}

	std::uint8_t CoffSymbolTable::getSymbolStorageClass(std::size_t ulSymbol) const
	{
		return symbolTable[ulSymbol].StorageClass;
	}

	std::uint8_t CoffSymbolTable::getSymbolNumberOfAuxSymbols(std::size_t ulSymbol) const
	{
		return symbolTable[ulSymbol].NumberOfAuxSymbols;
	}
}

```

`debug_remover/src/pelib/ComHeaderDirectory.cpp`:

```cpp
/*
* ComHeaderDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/ComHeaderDirectory.h"

namespace PeLib
{
	/**
	* Reads a file's COM+ descriptor.
	* @param imageLoader Reference to the valid PE image loader
	**/

	int ComHeaderDirectory::read(ImageLoader & imageLoader)
	{
		std::uint32_t rva = imageLoader.getComDirRva();
		std::uint32_t size = imageLoader.getComDirSize();
		std::uint32_t sizeOfImage = imageLoader.getSizeOfImage();
		if(rva >= sizeOfImage || (rva + size) > sizeOfImage)
		{
			return ERROR_INVALID_FILE;
		}

		// Read the COM header as-is
		if(imageLoader.readImage(&m_ichComHeader, rva, sizeof(PELIB_IMAGE_COR20_HEADER)) != size)
		{
			return ERROR_INVALID_FILE;
		}

		return ERROR_NONE;
	}

	/**
	* Rebuilds the current COM+ descriptor.
	* @param vBuffer Buffer where the COM+ descriptor will be written to.
	**/
	void ComHeaderDirectory::rebuild(std::vector<std::uint8_t>& vBuffer) const
	{
		OutputBuffer obBuffer(vBuffer);

		obBuffer << m_ichComHeader.cb;
		obBuffer << m_ichComHeader.MajorRuntimeVersion;
		obBuffer << m_ichComHeader.MinorRuntimeVersion;
		obBuffer << m_ichComHeader.MetaData.VirtualAddress;
		obBuffer << m_ichComHeader.MetaData.Size;
		obBuffer << m_ichComHeader.Flags;
		obBuffer << m_ichComHeader.EntryPointToken;
		obBuffer << m_ichComHeader.Resources.VirtualAddress;
		obBuffer << m_ichComHeader.Resources.Size;
		obBuffer << m_ichComHeader.StrongNameSignature.VirtualAddress;
		obBuffer << m_ichComHeader.StrongNameSignature.Size;
		obBuffer << m_ichComHeader.CodeManagerTable.VirtualAddress;
		obBuffer << m_ichComHeader.CodeManagerTable.Size;
		obBuffer << m_ichComHeader.VTableFixups.VirtualAddress;
		obBuffer << m_ichComHeader.VTableFixups.Size;
		obBuffer << m_ichComHeader.ExportAddressTableJumps.VirtualAddress;
		obBuffer << m_ichComHeader.ExportAddressTableJumps.Size;
		obBuffer << m_ichComHeader.ManagedNativeHeader.VirtualAddress;
		obBuffer << m_ichComHeader.ManagedNativeHeader.Size;
	}

	/**
	* @return Size in bytes.
	**/
	unsigned int ComHeaderDirectory::size() const
	{
		return PELIB_IMAGE_COR20_HEADER::size();
	}

	/**
	* @param strFilename Name of the file.
	* @param dwOffset File offset the COM+ descriptor will be written to.
	**/
	int ComHeaderDirectory::write(const std::string& strFilename, unsigned int dwOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);

		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(dwOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(vBuffer.data()), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();

		return ERROR_NONE;
	}

	/**
	* @return SizeOfHeader value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getSizeOfHeader() const
	{
		return m_ichComHeader.cb;
	}

	/**
	* @return MajorRuntimeVersion value of the current COM+ descriptor.
	**/
	std::uint16_t ComHeaderDirectory::getMajorRuntimeVersion() const
	{
		return m_ichComHeader.MajorRuntimeVersion;
	}

	/**
	* @return MinorRuntimeVersion value of the current COM+ descriptor.
	**/
	std::uint16_t ComHeaderDirectory::getMinorRuntimeVersion() const
	{
		return m_ichComHeader.MinorRuntimeVersion;
	}

	/**
	* @return MetaData (Virtual Address) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getMetaDataVa() const
	{
		return m_ichComHeader.MetaData.VirtualAddress;
	}

	/**
	* @return MetaData (Size) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getMetaDataSize() const
	{
		return m_ichComHeader.MetaData.Size;
	}

	/**
	* @return Flags value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getFlags() const
	{
		return m_ichComHeader.Flags;
	}

	/**
	* @return EntryPointToken value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getEntryPointToken() const
	{
		return m_ichComHeader.EntryPointToken;
	}

	/**
	* @return Resources (Virtual Address) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getResourcesVa() const
	{
		return m_ichComHeader.Resources.VirtualAddress;
	}

	/**
	* @return Resources (Size) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getResourcesSize() const
	{
		return m_ichComHeader.Resources.Size;
	}

	/**
	* @return StrongNameSignature (Virtual Address) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getStrongNameSignatureVa() const
	{
		return m_ichComHeader.StrongNameSignature.VirtualAddress;
	}

	/**
	* @return StrongNameSignature (Size) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getStrongNameSignatureSize() const
	{
		return m_ichComHeader.StrongNameSignature.Size;
	}

	/**
	* @return CodeManagerTable (Virtual Address) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getCodeManagerTableVa() const
	{
		return m_ichComHeader.CodeManagerTable.VirtualAddress;
	}

	/**
	* @return CodeManagerTable (Size) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getCodeManagerTableSize() const
	{
		return m_ichComHeader.CodeManagerTable.Size;
	}

	/**
	* @return VTableFixups (Virtual Address) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getVTableFixupsVa() const
	{
		return m_ichComHeader.VTableFixups.VirtualAddress;
	}

	/**
	* @return VTableFixups (Size) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getVTableFixupsSize() const
	{
		return m_ichComHeader.VTableFixups.Size;
	}

	/**
	* @return ExportAddressTableJumps (Virtual Address) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getExportAddressTableJumpsVa() const
	{
		return m_ichComHeader.ExportAddressTableJumps.VirtualAddress;
	}

	/**
	* @return ExportAddressTableJumps (Size) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getExportAddressTableJumpsSize() const
	{
		return m_ichComHeader.ExportAddressTableJumps.Size;
	}

	/**
	* @return ManagedNativeHeader (Virtual Address) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getManagedNativeHeaderVa() const
	{
		return m_ichComHeader.ManagedNativeHeader.VirtualAddress;
	}

	/**
	* @return ManagedNativeHeader (Size) value of the current COM+ descriptor.
	**/
	std::uint32_t ComHeaderDirectory::getManagedNativeHeaderSize() const
	{
		return m_ichComHeader.ManagedNativeHeader.Size;
	}

	/**
	* @param dwValue New value for the current SizeOfHeader (cb) value.
	**/
	void ComHeaderDirectory::setSizeOfHeader(std::uint32_t dwValue)
	{
		m_ichComHeader.cb = dwValue;
	}

	/**
	* @param wValue New value for the current MajorRuntimeVersion value.
	**/
	void ComHeaderDirectory::setMajorRuntimeVersion(std::uint16_t wValue)
	{
		m_ichComHeader.MajorRuntimeVersion = wValue;
	}

	/**
	* @param wValue New value for the current MinorRuntimeVersion value.
	**/
	void ComHeaderDirectory::setMinorRuntimeVersion(std::uint16_t wValue)
	{
		m_ichComHeader.MinorRuntimeVersion = wValue;
	}

	/**
	* @param dwValue New value for the current MetaData (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setMetaDataVa(std::uint32_t dwValue)
	{
		m_ichComHeader.MetaData.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current MetaData (Size) value.
	**/
	void ComHeaderDirectory::setMetaDataSize(std::uint32_t dwValue)
	{
		m_ichComHeader.MetaData.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current Flags value.
	**/
	void ComHeaderDirectory::setFlags(std::uint32_t dwValue)
	{
		m_ichComHeader.Flags = dwValue;
	}

	/**
	* @param dwValue New value for the current EntryPointToken value.
	**/
	void ComHeaderDirectory::setEntryPointToken(std::uint32_t dwValue)
	{
		m_ichComHeader.EntryPointToken = dwValue;
	}

	/**
	* @param dwValue New value for the current Resources (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setResourcesVa(std::uint32_t dwValue)
	{
		m_ichComHeader.Resources.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current Resources (Size) value.
	**/
	void ComHeaderDirectory::setResourcesSize(std::uint32_t dwValue)
	{
		m_ichComHeader.Resources.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current StrongNameSignature (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setStrongNameSignatureVa(std::uint32_t dwValue)
	{
		m_ichComHeader.StrongNameSignature.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current StrongNameSignature (Size) value.
	**/
	void ComHeaderDirectory::setStrongNameSignagureSize(std::uint32_t dwValue)
	{
		m_ichComHeader.StrongNameSignature.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current CodeManagerTable (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setCodeManagerTableVa(std::uint32_t dwValue)
	{
		m_ichComHeader.CodeManagerTable.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current CodeManagerTable (Size) value.
	**/
	void ComHeaderDirectory::setCodeManagerTableSize(std::uint32_t dwValue)
	{
		m_ichComHeader.CodeManagerTable.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current VTableFixups (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setVTableFixupsVa(std::uint32_t dwValue)
	{
		m_ichComHeader.VTableFixups.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current VTableFixups (Size) value.
	**/
	void ComHeaderDirectory::setVTableFixupsSize(std::uint32_t dwValue)
	{
		m_ichComHeader.VTableFixups.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current ExportAddressTableJumps (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setExportAddressTableJumpsVa(std::uint32_t dwValue)
	{
		m_ichComHeader.ExportAddressTableJumps.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current ExportAddressTableJumps (Size) value.
	**/
	void ComHeaderDirectory::setExportAddressTableJumpsSize(std::uint32_t dwValue)
	{
		m_ichComHeader.ExportAddressTableJumps.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current ManagedNativeHeader (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setManagedNativeHeaderVa(std::uint32_t dwValue)
	{
		m_ichComHeader.ManagedNativeHeader.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current ManagedNativeHeader (Size) value.
	**/
	void ComHeaderDirectory::setManagedNativeHeaderSize(std::uint32_t dwValue)
	{
		m_ichComHeader.ManagedNativeHeader.Size = dwValue;
	}

}

```

`debug_remover/src/pelib/ConfigDirectory.cpp`:

```cpp
/**
 * @file src/pelib/ConfigDirectory.cpp
 * @brief Class representing Load Config Directory of PE file
 * @copyright (c) 2021 Avast Software, licensed under the MIT license
 */

#include "retdec/pelib/ConfigDirectory.h"

namespace PeLib {
/**
	* @param inStream Input stream.
	* @param imageLoader A valid image loader reference which is necessary because some RVA calculations need to be done.
	**/

int ConfigDirectory::read(ImageLoader& imageLoader)
{
	this->is64bit = imageLoader.getImageBitability();

	std::uint32_t loadRva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG);

	bool readSuccess = false;

	if (this->is64bit)
	{
		readSuccess = imageLoader.readImage(&this->dir64, loadRva, sizeof(dir64)) == sizeof(dir64);
	}
	else
	{
		readSuccess = imageLoader.readImage(&this->dir32, loadRva, sizeof(dir32)) == sizeof(dir32);
	}

	return readSuccess ? ERROR_NONE : ERROR_INVALID_FILE;
}

std::uint32_t ConfigDirectory::getTimeDateStamp() const
{
	return is64bit ? dir64.TimeDateStamp : dir32.TimeDateStamp;
}

} // namespace PeLib
```

`debug_remover/src/pelib/DebugDirectory.cpp`:

```cpp
/*
* DebugDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/DebugDirectory.h"

namespace PeLib
{
	/**
	* @param inStream Input stream.
	* @param imageLoader A valid image loader reference which is necessary because some RVA calculations need to be done.
	**/

	int DebugDirectory::read(std::istream& inStream, ImageLoader & imageLoader)
	{
		std::vector<PELIB_IMG_DEBUG_DIRECTORY> debugInfo;
		std::uint64_t ulFileSize = fileSize(inStream);
		std::size_t rva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG);
		std::size_t size = imageLoader.getDataDirSize(PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG);
		std::size_t sizeOfImage = imageLoader.getSizeOfImage();
		if ((rva + size) < rva || (rva + size) > sizeOfImage)
		{
			return ERROR_INVALID_FILE;
		}

		// Read the array of debug directories
		read(imageLoader, debugInfo, rva, size);

		// For each debug directory, also read its data
		for(auto & debugEntry : debugInfo)
		{
			if ((debugEntry.idd.PointerToRawData + debugEntry.idd.SizeOfData) < debugEntry.idd.PointerToRawData ||
				(debugEntry.idd.PointerToRawData >= ulFileSize) ||
				(debugEntry.idd.PointerToRawData + debugEntry.idd.SizeOfData >= ulFileSize))
			{
				return ERROR_INVALID_FILE;
			}

			// Load the debug info data from the file, not from the image.
			// Some samples may have debug info part of the overlay
			debugEntry.data.resize(debugEntry.idd.SizeOfData);
			inStream.seekg(debugEntry.idd.PointerToRawData);
			inStream.read(reinterpret_cast<char*>(debugEntry.data.data()), debugEntry.idd.SizeOfData);

			// Verify the number of bytes read
			if(inStream.gcount() != debugEntry.idd.SizeOfData)
				return ERROR_INVALID_FILE;

			if (debugEntry.idd.SizeOfData > 0)
			{
				m_occupiedAddresses.push_back(
					std::make_pair(
					debugEntry.idd.AddressOfRawData,
					debugEntry.idd.AddressOfRawData + debugEntry.idd.SizeOfData - 1
				));
			}
		}

		std::swap(debugInfo, m_vDebugInfo);
		return ERROR_NONE;
	}

	void DebugDirectory::read(ImageLoader & imageLoader,
		                      std::vector<PELIB_IMG_DEBUG_DIRECTORY> & debugInfo,
		                      std::uint32_t rva,
		                      std::uint32_t size)
	{
		PELIB_IMG_DEBUG_DIRECTORY iddCurr;
		std::size_t entryCount = size / PELIB_IMAGE_DEBUG_DIRECTORY::size();
		std::uint32_t bytesRead;

		for (std::size_t i = 0; i < entryCount; i++)
		{
			bytesRead = imageLoader.readImage(&iddCurr.idd, rva, sizeof(PELIB_IMAGE_DEBUG_DIRECTORY));
			if(bytesRead != sizeof(PELIB_IMAGE_DEBUG_DIRECTORY))
				break;

			debugInfo.push_back(iddCurr);
			rva += sizeof(PELIB_IMAGE_DEBUG_DIRECTORY);
		}

		if (!debugInfo.empty())
		{
			m_occupiedAddresses.emplace_back(
						rva,
						rva + entryCount * PELIB_IMAGE_DEBUG_DIRECTORY::size() - 1
					);
		}
	}

	/**
	* Rebuilds the current debug directory.
	* @param vBuffer Buffer where the rebuilt directory is stored.
	**/
	void DebugDirectory::rebuild(std::vector<std::uint8_t>& vBuffer) const
	{
		OutputBuffer obBuffer(vBuffer);

		for (unsigned int i=0;i<m_vDebugInfo.size();i++)
		{
			obBuffer << m_vDebugInfo[i].idd.Characteristics;
			obBuffer << m_vDebugInfo[i].idd.TimeDateStamp;
			obBuffer << m_vDebugInfo[i].idd.MajorVersion;
			obBuffer << m_vDebugInfo[i].idd.MinorVersion;
			obBuffer << m_vDebugInfo[i].idd.Type;
			obBuffer << m_vDebugInfo[i].idd.SizeOfData;
			obBuffer << m_vDebugInfo[i].idd.AddressOfRawData;
			obBuffer << m_vDebugInfo[i].idd.PointerToRawData;
		}
	}

	/**
	* @return Size of the debug directory.
	**/
	unsigned int DebugDirectory::size() const
	{
		return static_cast<unsigned int>(m_vDebugInfo.size()) * PELIB_IMAGE_DEBUG_DIRECTORY::size();
	}

	/**
	* @param strFilename Name of the file which will be written.
	* @param uiOffset File offset where the debug directory will be stored.
	**/
	int DebugDirectory::write(const std::string& strFilename, unsigned int uiOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);

		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(vBuffer.data()), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();

		return ERROR_NONE;
	}

	/**
	* @return Number of debug structures in the current Debug directory.
	**/
	unsigned int DebugDirectory::calcNumberOfEntries() const
	{
		return static_cast<unsigned int>(m_vDebugInfo.size());
	}

	/**
	* Adds a new debug structure to the debug directory. The initial values of all members of the structure
	* are undefined.
	**/
	void DebugDirectory::addEntry()
	{
		PELIB_IMG_DEBUG_DIRECTORY p;
		m_vDebugInfo.push_back(p);
	}

	/**
	* Removes a debug structure from the current debug directory. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	**/
	void DebugDirectory::removeEntry(std::size_t uiIndex)
	{
		m_vDebugInfo.erase(m_vDebugInfo.begin() + uiIndex);
	}

	/**
	* Returns the Characteristics value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return Characteristics value of the debug structure.
	**/
	std::uint32_t DebugDirectory::getCharacteristics(std::size_t uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.Characteristics;
	}

	/**
	* Returns the TimeDateStamp value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return TimeDateStamp value of the debug structure.
	**/
	std::uint32_t DebugDirectory::getTimeDateStamp(std::size_t uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.TimeDateStamp;
	}

	/**
	* Returns the MajorVersion value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return MajorVersion value of the debug structure.
	**/
	std::uint16_t DebugDirectory::getMajorVersion(std::size_t uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.MajorVersion;
	}

	/**
	* Returns the MinorVersion value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return MinorVersion value of the debug structure.
	**/
	std::uint16_t DebugDirectory::getMinorVersion(std::size_t uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.MinorVersion;
	}

	/**
	* Returns the Type value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return Type value of the debug structure.
	**/
	std::uint32_t DebugDirectory::getType(std::size_t uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.Type;
	}

	/**
	* Returns the SizeOfData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return SizeOfData value of the debug structure.
	**/
	std::uint32_t DebugDirectory::getSizeOfData(std::size_t uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.SizeOfData;
	}

	/**
	* Returns the AddressOfRawData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return AddressOfRawData value of the debug structure.
	**/
	std::uint32_t DebugDirectory::getAddressOfRawData(std::size_t uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.AddressOfRawData;
	}

	/**
	* Returns the PointerToRawData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return PointerToRawData value of the debug structure.
	**/
	std::uint32_t DebugDirectory::getPointerToRawData(std::size_t uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.PointerToRawData;
	}

	std::vector<std::uint8_t> DebugDirectory::getData(std::size_t index) const
	{
		return m_vDebugInfo[index].data;
	}

	/**
	* Changes the Characteristics value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the Characteristics value of the debug structure.
	**/
	void DebugDirectory::setCharacteristics(std::size_t uiIndex, std::uint32_t dwValue)
	{
		m_vDebugInfo[uiIndex].idd.Characteristics = dwValue;
	}

	/**
	* Changes the TimeDateStamp value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the TimeDateStamp value of the debug structure.
	**/
	void DebugDirectory::setTimeDateStamp(std::size_t uiIndex, std::uint32_t dwValue)
	{
		m_vDebugInfo[uiIndex].idd.TimeDateStamp = dwValue;
	}

	/**
	* Changes the MajorVersion value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param wValue New value of the MajorVersion value of the debug structure.
	**/
	void DebugDirectory::setMajorVersion(std::size_t uiIndex, std::uint16_t wValue)
	{
		m_vDebugInfo[uiIndex].idd.MajorVersion = wValue;
	}

	/**
	* Changes the MinorVersion value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param wValue New value of the MinorVersion value of the debug structure.
	**/
	void DebugDirectory::setMinorVersion(std::size_t uiIndex, std::uint16_t wValue)
	{
		m_vDebugInfo[uiIndex].idd.MinorVersion = wValue;
	}

	/**
	* Changes the Type value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the Type value of the debug structure.
	**/
	void DebugDirectory::setType(std::size_t uiIndex, std::uint32_t dwValue)
	{
		m_vDebugInfo[uiIndex].idd.Type = dwValue;
	}

	/**
	* Changes the SizeOfData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the SizeOfData value of the debug structure.
	**/
	void DebugDirectory::setSizeOfData(std::size_t uiIndex, std::uint32_t dwValue)
	{
		m_vDebugInfo[uiIndex].idd.SizeOfData = dwValue;
	}

	/**
	* Changes the AddressOfRawData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the AddressOfRawData value of the debug structure.
	**/
	void DebugDirectory::setAddressOfRawData(std::size_t uiIndex, std::uint32_t dwValue)
	{
		m_vDebugInfo[uiIndex].idd.AddressOfRawData = dwValue;
	}

	/**
	* Changes the PointerToRawData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the PointerToRawData value of the debug structure.
	**/
	void DebugDirectory::setPointerToRawData(std::size_t uiIndex, std::uint32_t dwValue)
	{
		m_vDebugInfo[uiIndex].idd.PointerToRawData = dwValue;
	}

	void DebugDirectory::setData(std::size_t index, const std::vector<std::uint8_t>& data)
	{
		m_vDebugInfo[index].data = data;
	}

	const std::vector<std::pair<unsigned int, unsigned int>>& DebugDirectory::getOccupiedAddresses() const
	{
		return m_occupiedAddresses;
	}
}

```

`debug_remover/src/pelib/ExportDirectory.cpp`:

```cpp
/*
* ExportDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/ExportDirectory.h"

namespace PeLib
{
	/**
	* @param str Value of the ASCIIZ string.
	* @param rva RVA of the begin of the string
	**/
	void ExportDirectory::addOccupiedAddress(const std::string & str, std::uint32_t rva)
	{
		std::uint32_t rvaEnd = rva + str.length() + 1;

		m_occupiedAddresses.push_back(std::make_pair(rva, rvaEnd));
	}

	/**
	* @param imageLoader Initialized image loader
	* \todo: Proper use of InputBuffer
	**/
	int ExportDirectory::read(ImageLoader & imageLoader)
	{
		PELIB_IMAGE_EXP_DIRECTORY iedCurr;
		std::uint32_t exportRva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT);
		std::uint32_t sizeofImage = imageLoader.getSizeOfImage();
		std::uint32_t bytesRead;

		if(exportRva >= sizeofImage)
		{
			return ERROR_INVALID_FILE;
		}

		// Load the export directory from the image
		bytesRead = imageLoader.readImage(&iedCurr.ied, exportRva, sizeof(PELIB_IMAGE_EXPORT_DIRECTORY));
		if(bytesRead != sizeof(PELIB_IMAGE_EXPORT_DIRECTORY))
		{
			return ERROR_INVALID_FILE;
		}

		m_occupiedAddresses.emplace_back(exportRva, exportRva + sizeof(PELIB_IMAGE_EXPORT_DIRECTORY) - 1);

		// Verify the export directory. Do not allow more functions than the limit
		// Sample: CCE461B6EB23728BA3B8A97B9BE84C0FB9175DB31B9949E64144198AB3F702CE
		if (iedCurr.ied.NumberOfFunctions > PELIB_MAX_EXPORTED_FUNCTIONS || iedCurr.ied.NumberOfNames > PELIB_MAX_EXPORTED_FUNCTIONS)
			return ERROR_INVALID_FILE;

		// Read the name of the export
		imageLoader.readString(iedCurr.name, iedCurr.ied.Name);
		addOccupiedAddress(iedCurr.name, iedCurr.ied.Name);

		// Read the array of functions
		for (std::uint32_t i = 0; i < iedCurr.ied.NumberOfFunctions; i++)
		{
			PELIB_EXP_FUNC_INFORMATION efiCurr;
			std::uint32_t rva = iedCurr.ied.AddressOfFunctions + i * sizeof(efiCurr.addroffunc);

			bytesRead = imageLoader.readImage(&efiCurr.addroffunc, rva, sizeof(efiCurr.addroffunc));
			if(bytesRead != sizeof(efiCurr.addroffunc))
				return ERROR_INVALID_FILE;

			efiCurr.ordinal = iedCurr.ied.Base + i;
			iedCurr.functions.push_back(efiCurr);

			m_occupiedAddresses.emplace_back(
				iedCurr.ied.AddressOfFunctions + i*sizeof(efiCurr.addroffunc),
				iedCurr.ied.AddressOfFunctions + i*sizeof(efiCurr.addroffunc) + sizeof(efiCurr.addroffunc) - 1
			);
		}

		for (std::uint32_t i = 0; i < iedCurr.ied.NumberOfNames; i++)
		{
			PELIB_EXP_FUNC_INFORMATION efiCurr;
			std::uint16_t ordinal;
			std::uint32_t rva = iedCurr.ied.AddressOfNameOrdinals + i * sizeof(efiCurr.ordinal);

			// Read the ordinal
			bytesRead = imageLoader.readImage(&ordinal, rva, sizeof(ordinal));
			if(bytesRead != sizeof(ordinal))
				return ERROR_INVALID_FILE;

			m_occupiedAddresses.emplace_back(
				iedCurr.ied.AddressOfNameOrdinals + i*sizeof(efiCurr.ordinal),
				iedCurr.ied.AddressOfNameOrdinals + i*sizeof(efiCurr.ordinal) + sizeof(efiCurr.ordinal) - 1
			);

			if (ordinal >= iedCurr.functions.size())
				continue;

			iedCurr.functions[ordinal].ordinal = iedCurr.ied.Base + ordinal;

			rva = iedCurr.ied.AddressOfNames + i * sizeof(efiCurr.addrofname);
			if(rva >= sizeofImage)
				return ERROR_INVALID_FILE;

			bytesRead = imageLoader.readImage(&iedCurr.functions[ordinal].addrofname, rva, sizeof(std::uint32_t));
			if(bytesRead != sizeof(std::uint32_t))
				return ERROR_INVALID_FILE;

			m_occupiedAddresses.emplace_back(
				iedCurr.ied.AddressOfNames + i*sizeof(efiCurr.addrofname),
				iedCurr.ied.AddressOfNames + i*sizeof(efiCurr.addrofname) + sizeof(iedCurr.functions[ordinal].addrofname) - 1
			);

			// Read the function name
			imageLoader.readString(iedCurr.functions[ordinal].funcname, iedCurr.functions[ordinal].addrofname);
			addOccupiedAddress(iedCurr.functions[ordinal].funcname, iedCurr.functions[ordinal].addrofname);
		}

		std::swap(m_ied, iedCurr);
		return ERROR_NONE;
	}

	/**
	* @param strFuncname Name of the function.
	* @param dwFuncAddr RVA of the function.
	**/
	void ExportDirectory::addFunction(const std::string& strFuncname, std::uint32_t dwFuncAddr)
	{
		PELIB_EXP_FUNC_INFORMATION efiCurr;
		efiCurr.funcname = strFuncname;
		efiCurr.addroffunc = dwFuncAddr;
		m_ied.functions.push_back(efiCurr);
	}

	void ExportDirectory::removeFunction(unsigned int index)
	{
		m_ied.functions.erase(m_ied.functions.begin() + index);
	}

	void ExportDirectory::clear()
	{
		m_ied.functions.clear();
	}

	unsigned int ExportDirectory::calcNumberOfFunctions() const
	{
		return static_cast<unsigned int>(m_ied.functions.size());
	}

	/**
	* Identifies an exported function through it's name.
	* @param strFunctionName Name of the function
	* @return Number which identifies the functions.
	**/
	int ExportDirectory::getFunctionIndex(const std::string& strFunctionName) const
	{
		auto Iter = std::find_if(
				m_ied.functions.begin(),
				m_ied.functions.end(),
				[&](const auto& i) { return i.equal(strFunctionName); }
		);

		if (Iter == m_ied.functions.end())
		{
//			throw Exceptions::InvalidName(ExportDirectoryId, __LINE__);
			return -1;
		}

		return static_cast<int>(std::distance(m_ied.functions.begin(), Iter));
	}

	/**
	* @param vBuffer Buffer where the rebuilt export directory is written to.
	* @param dwRva RVA of the export directory.
	* \todo fValid flag
	**/
	void ExportDirectory::rebuild(std::vector<std::uint8_t>& vBuffer, std::uint32_t dwRva) const
	{
		unsigned int uiSizeDirectory = sizeof(PELIB_IMAGE_EXPORT_DIRECTORY);

		unsigned int uiSizeNames = 0;
		unsigned int uiSizeAddrFuncs = 0;
		unsigned int uiSizeAddrNames = 0;
		unsigned int uiSizeOrdinals = 0;

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			uiSizeNames += (m_ied.functions[i].funcname.empty()) ? 0 : static_cast<unsigned int>(m_ied.functions[i].funcname.size()) + 1;
			uiSizeAddrFuncs += sizeof(m_ied.functions[i].addroffunc);
			uiSizeAddrNames += (m_ied.functions[i].funcname.empty()) ? 0 : sizeof(m_ied.functions[i].addrofname);
			uiSizeOrdinals += (m_ied.functions[i].funcname.empty()) ? 0 : sizeof(m_ied.functions[i].ordinal);
		}

		unsigned int uiFilenameSize = static_cast<unsigned int>(m_ied.name.size()) + 1;

		OutputBuffer obBuffer(vBuffer);

		obBuffer << m_ied.ied.Characteristics;
		obBuffer << m_ied.ied.TimeDateStamp;
		obBuffer << m_ied.ied.MajorVersion;
		obBuffer << m_ied.ied.MinorVersion;
		obBuffer << dwRva + uiSizeDirectory + uiSizeAddrFuncs + uiSizeAddrNames + uiSizeOrdinals;
		obBuffer << m_ied.ied.Base;
		obBuffer << static_cast<unsigned int>(m_ied.functions.size());

		// TODO: Not correct but sufficient for now. (Update: I forgot what this comment refers to, but I'll leave it in)
		obBuffer << static_cast<unsigned int>(m_ied.functions.size());
		obBuffer << dwRva + uiSizeDirectory;
		obBuffer << dwRva + uiSizeDirectory + uiSizeAddrFuncs;
		obBuffer << dwRva + uiSizeDirectory + uiSizeAddrFuncs + uiSizeAddrNames;

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			obBuffer << m_ied.functions[i].addroffunc;
		}

		unsigned int ulFuncCounter = dwRva + uiSizeDirectory + uiSizeAddrFuncs + uiSizeAddrNames + uiSizeOrdinals + uiFilenameSize;

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			if (!m_ied.functions[i].funcname.empty())
			{
				obBuffer << ulFuncCounter;
				ulFuncCounter += static_cast<unsigned int>(m_ied.functions[i].funcname.size()) + 1;
			}
		}

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			if (!m_ied.functions[i].funcname.empty())
			{
				obBuffer <<  m_ied.functions[i].ordinal;
			}
		}

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			if (m_ied.functions[i].funcname.empty() && m_ied.functions[i].addroffunc)
			{
				obBuffer <<  m_ied.functions[i].ordinal;
			}
		}

		obBuffer.add(m_ied.name.c_str(), static_cast<unsigned int>(m_ied.name.size())+1);

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			if (!m_ied.functions[i].funcname.empty())
			{
				obBuffer.add(m_ied.functions[i].funcname.c_str(), static_cast<unsigned int>(m_ied.functions[i].funcname.size()) + 1);
			}
		}
	}

	/**
	* @return Size of the current export directory.
	**/
	unsigned int ExportDirectory::size() const
	{
		return m_ied.size();
	}

	/**
	* @param strFilename Name of the file.
	* @param uiOffset File offset the export directory will be written to.
	* @param uiRva RVA of the export directory.
	* \todo Check if ofFile.write succeeded.
	**/
	int ExportDirectory::write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);

		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer, uiRva);

		ofFile.write(reinterpret_cast<const char*>(vBuffer.data()), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();

		return ERROR_NONE;
	}

	/**
	* Changes the filename according to the export directory.
	* @param strFilename New filename.
	**/
	void ExportDirectory::setNameString(const std::string& strFilename)
	{
		m_ied.name = strFilename;
	}

	std::string ExportDirectory::getNameString() const
	{
		return m_ied.name;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @return The name of that function.
	**/
	std::string ExportDirectory::getFunctionName(std::size_t dwIndex) const
	{
		return m_ied.functions[dwIndex].funcname;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @return The ordinal of that function.
	**/
	std::uint16_t ExportDirectory::getFunctionOrdinal(std::size_t dwIndex) const
	{
		return m_ied.functions[dwIndex].ordinal;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @return The RVA of the name string of that function.
	**/
	std::uint32_t ExportDirectory::getAddressOfName(std::size_t dwIndex) const
	{
		return m_ied.functions[dwIndex].addrofname;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @return The RVA of that function.
	**/
	std::uint32_t ExportDirectory::getAddressOfFunction(std::size_t dwIndex) const
	{
		return m_ied.functions[dwIndex].addroffunc;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @param strName The name of that function.
	**/
	void ExportDirectory::setFunctionName(std::size_t dwIndex, const std::string& strName)
	{
		m_ied.functions[dwIndex].funcname = strName;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @param wValue The ordinal of that function.
	**/
	void ExportDirectory::setFunctionOrdinal(std::size_t dwIndex, std::uint16_t wValue)
	{
		m_ied.functions[dwIndex].ordinal = wValue;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @param dwValue The RVA of the name string of that function.
	**/
	void ExportDirectory::setAddressOfName(std::size_t dwIndex, std::uint32_t dwValue)
	{
		m_ied.functions[dwIndex].addrofname = dwValue;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @param dwValue The RVA of that function.
	**/
	void ExportDirectory::setAddressOfFunction(std::size_t dwIndex, std::uint32_t dwValue)
	{
		m_ied.functions[dwIndex].addroffunc = dwValue;
	}

	/**
	* @return The ordinal base of the export directory.
	**/
	std::uint32_t ExportDirectory::getBase() const
	{
		return m_ied.ied.Base;
	}

	/**
	* @return The characteristics of the export directory.
	**/
	std::uint32_t ExportDirectory::getCharacteristics() const
	{
		return m_ied.ied.Characteristics;
	}

	/**
	* @return The time/date stamp of the export directory.
	**/
	std::uint32_t ExportDirectory::getTimeDateStamp() const
	{
		return m_ied.ied.TimeDateStamp;
	}

	/**
	* @return The MajorVersion of the export directory.
	**/
	std::uint16_t ExportDirectory::getMajorVersion() const
	{
		return m_ied.ied.MajorVersion;
	}

	/**
	* @return The MinorVersion of the export directory.
	**/
	std::uint16_t ExportDirectory::getMinorVersion() const
	{
		return m_ied.ied.MinorVersion;
	}

	/**
	* @return The RVA of the name of the file.
	**/
	std::uint32_t ExportDirectory::getName() const
	{
		return m_ied.ied.Name;
	}

	/**
	* @return The NumberOfFunctions of the export directory.
	**/
	std::uint32_t ExportDirectory::getNumberOfFunctions() const
	{
		return m_ied.ied.NumberOfFunctions;
	}

	/**
	* @return The NumberOfNames of the export directory.
	**/
	std::uint32_t ExportDirectory::getNumberOfNames() const
	{
		return m_ied.ied.NumberOfNames;
	}

	/**
	* @return The AddressOfFunctions of the export directory.
	**/
	std::uint32_t ExportDirectory::getAddressOfFunctions() const
	{
		return m_ied.ied.AddressOfFunctions;
	}

	/**
	* @return The AddressOfNames of the export directory.
	**/
	std::uint32_t ExportDirectory::getAddressOfNames() const
	{
		return m_ied.ied.AddressOfNames;
	}

/*	std::uint32_t ExportDirectory::getNumberOfNameOrdinals() const
	{
		return static_cast<std::uint32_t>(m_ied.functions.size());
	}

	std::uint32_t ExportDirectory::getNumberOfAddressOfFunctionNames() const
	{
		return static_cast<std::uint32_t>(m_ied.functions.size());
	}

	std::uint32_t ExportDirectory::getNumberOfAddressOfFunctions() const
	{
		return static_cast<std::uint32_t>(m_ied.functions.size());
	}
*/
	/**
	* @return The AddressOfNameOrdinals of the export directory.
	**/
	std::uint32_t ExportDirectory::getAddressOfNameOrdinals() const
	{
		return m_ied.ied.AddressOfNameOrdinals;
	}

	/**
	* @param dwValue The ordinal base of the export directory.
	**/
	void ExportDirectory::setBase(std::uint32_t dwValue)
	{
		m_ied.ied.Base = dwValue;
	}

	/**
	* @param dwValue The Characteristics of the export directory.
	**/
	void ExportDirectory::setCharacteristics(std::uint32_t dwValue)
	{
		m_ied.ied.Characteristics = dwValue;
	}

	/**
	* @param dwValue The TimeDateStamp of the export directory.
	**/
	void ExportDirectory::setTimeDateStamp(std::uint32_t dwValue)
	{
		m_ied.ied.TimeDateStamp = dwValue;
	}

	/**
	* @param wValue The MajorVersion of the export directory.
	**/
	void ExportDirectory::setMajorVersion(std::uint16_t wValue)
	{
		m_ied.ied.MajorVersion = wValue;
	}

	/**
	* @param wValue The MinorVersion of the export directory.
	**/
	void ExportDirectory::setMinorVersion(std::uint16_t wValue)
	{
		m_ied.ied.MinorVersion = wValue;
	}

	/**
	* @param dwValue The Name of the export directory.
	**/
	void ExportDirectory::setName(std::uint32_t dwValue)
	{
		m_ied.ied.Name = dwValue;
	}

	/**
	* @param dwValue The NumberOfFunctions of the export directory.
	**/
	void ExportDirectory::setNumberOfFunctions(std::uint32_t dwValue)
	{
		m_ied.ied.NumberOfFunctions = dwValue;
	}

	/**
	* @param dwValue The NumberOfNames of the export directory.
	**/
	void ExportDirectory::setNumberOfNames(std::uint32_t dwValue)
	{
		m_ied.ied.NumberOfNames = dwValue;
	}

	/**
	* @param dwValue The AddressOfFunctions of the export directory.
	**/
	void ExportDirectory::setAddressOfFunctions(std::uint32_t dwValue)
	{
		m_ied.ied.AddressOfFunctions = dwValue;
	}

	/**
	* @param dwValue The AddressOfNames of the export directory.
	**/
	void ExportDirectory::setAddressOfNames(std::uint32_t dwValue)
	{
		m_ied.ied.AddressOfNames = dwValue;
	}

	void ExportDirectory::setAddressOfNameOrdinals(std::uint32_t value)
	{
		m_ied.ied.AddressOfNameOrdinals = value;
	}

	const std::vector<std::pair<unsigned int, unsigned int>>& ExportDirectory::getOccupiedAddresses() const
	{
		return m_occupiedAddresses;
	}
}

```

`debug_remover/src/pelib/IatDirectory.cpp`:

```cpp
/*
* IatDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/IatDirectory.h"

namespace PeLib
{
	/**
	* Reads the Import Address table from an image
	* @param buffer Pointer to the IAT data
	* @param buffersize Length of the data pointed by 'buffer'
	**/
	int IatDirectory::read(const void * buffer, std::size_t buffersize)
	{
		const std::uint32_t * itemArray = reinterpret_cast<const std::uint32_t *>(buffer);

		// Resize the IAT vector to contain all items
		std::size_t itemCount = buffersize / sizeof(std::uint32_t);
		m_vIat.clear();

		// Read the items, one-by-one, until we find a zero value
		for(std::size_t i = 0; i < itemCount; i++)
		{
			// Insert that item
			m_vIat.push_back(itemArray[i]);

			// Zero is considered terminator
			if(itemArray[i] == 0)
				break;
		}

		return ERROR_NONE;
	}

	/**
	* Reads the Import Address table from an image
	* @param imageLoader Initialized image loader
	**/
	int IatDirectory::read(ImageLoader & imageLoader)
	{
		std::uint8_t * iatArray;
		std::uint32_t iatRva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_IAT);
		std::uint32_t iatSize = imageLoader.getDataDirSize(PELIB_IMAGE_DIRECTORY_ENTRY_IAT);
		std::uint32_t sizeOfImage = imageLoader.getSizeOfImage();
		int fileError = ERROR_NONE;

		// Refuse to load blatantly invalid IAT
		if(iatSize & 0xFF000000)
			return ERROR_INVALID_FILE;

		// Refuse to load too large IAT directories
		if((iatRva + iatSize) < iatRva || iatRva >= sizeOfImage || (iatRva + iatSize) >= sizeOfImage)
			return ERROR_INVALID_FILE;

		// Trim the array size to the size of image
		if((iatRva + iatSize) > sizeOfImage)
			iatSize = sizeOfImage - iatRva;

		// Allocate array for the entire IAT
		if((iatArray = new std::uint8_t[iatSize]) != nullptr)
		{
			// Read the entire IAT to the memory
			iatSize = imageLoader.readImage(iatArray, iatRva, iatSize);

			// Insert the IAT array to the internal IAT vector
			fileError = read(iatArray, iatSize);
			delete [] iatArray;
		}
		else
		{
			fileError = ERROR_NOT_ENOUGH_SPACE;
		}

		return fileError;
	}

	/**
	* Returns the number of fields in the IAT. This is equivalent to the number of
	* imported functions.
	* @return Number of fields in the IAT.
	**/
	unsigned int IatDirectory::calcNumberOfAddresses() const
	{
		return static_cast<unsigned int>(m_vIat.size());
	}

	/**
	* Returns the dwValue of a field in the IAT.
	* @param index Number identifying the field.
	* @return dwValue of the field.
	**/
	std::uint32_t IatDirectory::getAddress(unsigned int index) const
	{
		return m_vIat[index];
	}

	/**
	* Updates the dwValue of a field in the IAT.
	* @param dwAddrnr Number identifying the field.
	* @param dwValue New dwValue of the field.
	**/
	void IatDirectory::setAddress(std::uint32_t dwAddrnr, std::uint32_t dwValue)
	{
		m_vIat[dwAddrnr] = dwValue;
	}

	/**
	* Adds another field to the IAT.
	* @param dwValue dwValue of the new field.
	**/
	void IatDirectory::addAddress(std::uint32_t dwValue)
	{
		m_vIat.push_back(dwValue);
	}

	/**
	* Removes an address from the IAT.
	* @param index Number identifying the field.
	**/
	void IatDirectory::removeAddress(unsigned int index)
	{
		std::vector<std::uint32_t>::iterator pos = m_vIat.begin() + index;
		m_vIat.erase(pos);
	}

	/**
	* Delete all entries from the IAT.
	**/
	void IatDirectory::clear()
	{
		m_vIat.clear();
	}

	/**
	* Rebuilds the complete Import Address Table.
	* @param vBuffer Buffer where the rebuilt IAT will be stored.
	**/
	void IatDirectory::rebuild(std::vector<std::uint8_t>& vBuffer) const
	{
		vBuffer.resize(size());
		OutputBuffer obBuffer(vBuffer);

		for (unsigned int i=0;i<m_vIat.size();i++)
		{
			obBuffer << m_vIat[i];
		}
	}

	unsigned int IatDirectory::size() const
	{
		return static_cast<unsigned int>(m_vIat.size())* sizeof(std::uint32_t);
	}

	/// Writes the current IAT to a file.
	int IatDirectory::write(const std::string& strFilename, unsigned int uiOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);

		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(vBuffer.data()), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();

		return ERROR_NONE;
	}
}

```

`debug_remover/src/pelib/ImageLoader.cpp`:

```cpp
/**
 * @file src/pelib/ImageLoader.cpp
 * @brief Implementation of image
 * @copyright (c) 2020 Avast Software, licensed under the MIT license
 */

#include <cstdint>
#include <iostream>
#include <fstream>

#include "retdec/pelib/ImageLoader.h"

//-----------------------------------------------------------------------------
// Static class variables

std::uint8_t PeLib::ImageLoader::ImageProtectionArray[16] =
{
	PELIB_PAGE_NOACCESS,
	PELIB_PAGE_EXECUTE,
	PELIB_PAGE_READONLY,
	PELIB_PAGE_EXECUTE_READ,
	PELIB_PAGE_WRITECOPY,
	PELIB_PAGE_EXECUTE_WRITECOPY,
	PELIB_PAGE_WRITECOPY,
	PELIB_PAGE_EXECUTE_WRITECOPY,
	PELIB_PAGE_NOACCESS,
	PELIB_PAGE_EXECUTE,
	PELIB_PAGE_READONLY,
	PELIB_PAGE_EXECUTE_READ,
	PELIB_PAGE_READWRITE,
	PELIB_PAGE_EXECUTE_READWRITE,
	PELIB_PAGE_READWRITE,
	PELIB_PAGE_EXECUTE_READWRITE
};

//-----------------------------------------------------------------------------
// Constructor and destructor

PeLib::ImageLoader::ImageLoader(std::uint32_t versionInfo)
{
	memset(&dosHeader, 0, sizeof(PELIB_IMAGE_DOS_HEADER));
	memset(&fileHeader, 0, sizeof(PELIB_IMAGE_FILE_HEADER));
	memset(&optionalHeader, 0, sizeof(PELIB_IMAGE_OPTIONAL_HEADER));
	checkSumFileOffset = 0;
	securityDirFileOffset = 0;
	realNumberOfRvaAndSizes = 0;
	ntSignature = 0;
	ldrError = LDR_ERROR_NONE;

	// By default, set the most benevolent settings
	ssiImageAlignment32 = PELIB_PAGE_SIZE;
	sizeofImageMustMatch = false;
	ntHeadersSizeCheck = false;
	architectureSpecificChecks = false;
	maxSectionCount = 255;
	is64BitWindows = (versionInfo & BuildNumber64Bit) ? true : false;
	windowsBuildNumber = (versionInfo & BuildNumberMask);
	headerSizeCheck = false;
	loadArmImages = true;
	loadArm64Images = true;
	loadItaniumImages = true;
	forceIntegrityCheckEnabled = false;
	forceIntegrityCheckCertificate = false;
	checkNonLegacyDllCharacteristics = false;
	checkImagePostMapping = false;

	// If the caller specified a Windows build, then we configure version-specific behavior
	if(windowsBuildNumber != 0)
	{
		// Single-section images are aligned to zector in Windows XP
		// Note that Windows 8-10 do this somewhat randomly; the same image is mapped differently when in different folders
		ssiImageAlignment32 = (BuildNumberXP <= windowsBuildNumber && windowsBuildNumber < BuildNumberVista) ? PELIB_SECTOR_SIZE : 1;

		// Max section count is smaller in Windows XP
		maxSectionCount = (BuildNumberXP <= windowsBuildNumber && windowsBuildNumber < BuildNumberVista) ? PE_MAX_SECTION_COUNT_XP : PE_MAX_SECTION_COUNT_7;

		// Weird check in Windows XP: See checkForSectionTablesWithinHeader
		headerSizeCheck = (BuildNumberXP <= windowsBuildNumber && windowsBuildNumber < BuildNumberVista);

		// Beginning with Windows Vista, the file size must be >= sizeof(IMAGE_NT_HEADERS)
		ntHeadersSizeCheck = (BuildNumberVista <= windowsBuildNumber);

		// Beginning with Vista, IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY actually does something
		forceIntegrityCheckEnabled = (windowsBuildNumber >= BuildNumberVista);
		forceIntegrityCheckCertificate = (windowsBuildNumber >= BuildNumber8);

		// Beginning with Windows 8, ARM images can also be loader
		loadArmImages = (windowsBuildNumber >= BuildNumber8);

		// ARM64 images are only loaded from Windows 10 up
		loadArm64Images = (windowsBuildNumber >= BuildNumber10);

		// From Windows XP to Windows 7, 64-bit Windows will load Itanium images
		if(is64BitWindows && windowsBuildNumber >= BuildNumber8)
			loadItaniumImages = false;

		// Windows 8+ perform check for bad app container apps
		architectureSpecificChecks = (windowsBuildNumber >= BuildNumber8);

		// After build 17134, SizeOfImage can also be greater than virtual end of the last section
		sizeofImageMustMatch = (windowsBuildNumber <= 17134);

		// Since build 17134, Load Config is checked within nt!MiRelocateImage
		checkImagePostMapping = (windowsBuildNumber >= 17134);

		// Since build 18362, extra checks are performed on non-intel platforms
		checkNonLegacyDllCharacteristics = (windowsBuildNumber >= 18362);

		// Since build 21996, single-section images only contain data up to the image size
		alignSingleSectionImagesToPage = !(windowsBuildNumber >= 21996);
	}
}

//-----------------------------------------------------------------------------
// Public functions

bool PeLib::ImageLoader::relocateImage(std::uint64_t newImageBase)
{
	std::uint32_t VirtualAddress;
	std::uint32_t Size;
	bool result = true;

	// Only relocate the image if the image base is different
	if(newImageBase != optionalHeader.ImageBase)
	{
		// If the image was not properly mapped, don't even try.
		if(pages.size() == 0)
			return false;

		// If relocations are stripped, do nothing
		if(fileHeader.Characteristics & PELIB_IMAGE_FILE_RELOCS_STRIPPED)
			return false;

		// Don't relocate 32-bit images to an address greater than 32bits
		if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC && (newImageBase >> 32))
			return false;

		// Change the image base in the header. This happens even if the image does not have relocations.
		// Sample: f5bae114007e5f5eb2a7e41fbd7cf4062b21e1a33e0648a07eb1e25c106bd7eb
		writeNewImageBase(newImageBase);

		// The image must have relocation directory
		if(optionalHeader.NumberOfRvaAndSizes <= PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC)
			return false;

		// The relocation data directory must be valid
		VirtualAddress = optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
		Size = optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
		if(VirtualAddress == 0 || Size == 0)
			return false;

		// Do not relocate images with weird or invalid relocation table
		if(!isValidImageBlock(VirtualAddress, Size))
			return false;

		// Perform relocations
		result = processImageRelocations(optionalHeader.ImageBase, newImageBase, VirtualAddress, Size);
	}

	return result;
}

std::uint32_t PeLib::ImageLoader::readImage(
	void * buffer,
	std::uint32_t rva,
	std::uint32_t bytesToRead)
{
	// If the image was properly mapped, perform an image-read operation
	if(rawFileData.size() == 0)
	   return readWriteImage(buffer, rva, bytesToRead, readFromPage);

	// If the image loader was unable to map the image, we provide fallback method
	// by translating the RVA to file offset. Note that in some cases, this methos
	// may produce unwanted results.
	// Example: If export directory is at the end of section, it will be padded by zeros by the loader,
	// but in the on-disk version, next section will follow.
	return readWriteImageFile(buffer, rva, bytesToRead, true);
}

std::uint32_t PeLib::ImageLoader::writeImage(
	void * buffer,
	std::uint32_t rva,
	std::uint32_t bytesToRead)
{
	// If the image was properly mapped, perform an image-read operation
	if(rawFileData.size() == 0)
		return readWriteImage(buffer, rva, bytesToRead, writeToPage);

	// If the image loader was unable to map the image, we provide fallback method
	// by translating the RVA to file offset.
	return readWriteImageFile(buffer, rva, bytesToRead, false);
}

std::uint32_t PeLib::ImageLoader::stringLength(
	std::uint32_t rva,
	std::uint32_t maxLength) const
{
	std::uint32_t rvaBegin = rva;
	std::uint32_t rvaEnd = rva + maxLength;
	std::uint32_t length = 0;

	// Is the image mapped OK?
	if(pages.size())
	{
		// Check the last possible address where we read
		if(rvaEnd > getSizeOfImageAligned())
			rvaEnd = getSizeOfImageAligned();

		// Is the offset within the image?
		if(rva < rvaEnd)
		{
			std::size_t pageIndex = rva / PELIB_PAGE_SIZE;

			// The page index must be in range
			if(pageIndex < pages.size())
			{
				while(rva < rvaEnd)
				{
					const PELIB_FILE_PAGE & page = pages[pageIndex];
					const std::uint8_t * dataBegin;
					const std::uint8_t * dataPtr;
					std::uint32_t rvaEndPage = (pageIndex + 1) * PELIB_PAGE_SIZE;

					// If zero page, means this is a zeroed page. This is the end of the string.
					if(page.buffer.empty())
						break;
					dataBegin = dataPtr = page.buffer.data() + (rva & (PELIB_PAGE_SIZE - 1));

					// Perhaps the last page loaded?
					if(rvaEndPage > rvaEnd)
						rvaEndPage = rvaEnd;

					// Try to find the zero byte on the page
					dataPtr = (const std::uint8_t *)memchr(dataPtr, 0, (rvaEndPage - rva));
					if(dataPtr != nullptr)
						return rva + (dataPtr - dataBegin) - rvaBegin;
					rva = rvaEndPage;

					// Move pointers
					pageIndex++;
				}
			}
		}

		// Return the length of the string
		length = (rva - rvaBegin);
	}
	else
	{
		// Recalc the file offset to RVA
		if((rva = getFileOffsetFromRva(rva)) < rawFileData.size())
		{
			const std::uint8_t * stringPtr = rawFileData.data() + rva;
			const std::uint8_t * stringEnd;

			length = rawFileData.size() - rva;

			stringEnd = (const std::uint8_t *)memchr(stringPtr, 0, length);
			if(stringEnd != nullptr)
				length = stringEnd - stringPtr;
		}
	}

	return length;
}

std::uint32_t PeLib::ImageLoader::readString(
	std::string & str,
	std::uint32_t rva,
	std::uint32_t maxLength)
{
	// Check the length of the string at the rva
	std::uint32_t length = stringLength(rva, maxLength);

	// Allocate needeed size in the string
	str.resize(length);

	// Read the string from the image
	readImage((void *)str.data(), rva, length);
	return length;
}

std::uint32_t PeLib::ImageLoader::readPointer(
	std::uint32_t rva,
	std::uint64_t & pointerValue)
{
	std::uint32_t bytesRead = 0;

	switch(getImageBitability())
	{
		case 64:
			if(readImage(&pointerValue, rva, sizeof(std::uint64_t)) == sizeof(std::uint64_t))
				return sizeof(std::uint64_t);
			break;

		case 32:
		{
			std::uint32_t pointerValue32 = 0;

			bytesRead = readImage(&pointerValue32, rva, sizeof(std::uint32_t));
			if(bytesRead == sizeof(std::uint32_t))
			{
				pointerValue = pointerValue32;
				return sizeof(std::uint32_t);
			}

			break;
		}
	}

	return 0;
}

std::uint32_t PeLib::ImageLoader::getPointerSize()  const
{
	return getImageBitability() / 8;
}

std::uint32_t PeLib::ImageLoader::readStringRc(
	std::string & str,
	std::uint32_t rva)
{
	std::vector<std::uint16_t> wideString;
	std::uint32_t bytesToRead;
	std::uint32_t charsRead;
	std::uint16_t length = 0;

	// Read the length of the string from the image
	readImage(&length, rva, sizeof(std::uint16_t));
	rva += sizeof(std::uint16_t);

	// Allocate enough space
	bytesToRead = length * sizeof(std::uint16_t);
	wideString.resize(length);

	// Read the entire string from the image
	charsRead = readImage(wideString.data(), rva, bytesToRead) / sizeof(std::uint16_t);
	str.resize(charsRead);

	// Convert the UTF-16 string to ANSI. Note that this is not the proper way to do it,
	// but it's the same way how retdec-fileinfo.exe always did it, so we keep it that way
	for(std::uint32_t i = 0; i < charsRead; i++)
		str[i] = wideString[i];
	return charsRead;
}

std::uint32_t PeLib::ImageLoader::readStringRaw(
	ByteBuffer & fileData,
	std::string & str,
	std::size_t offset,
	std::size_t maxLength,
	bool mustBePrintable,
	bool mustNotBeTooLong)
{
	std::size_t length = 0;

	if(offset < fileData.size())
	{
		std::uint8_t * stringBegin = fileData.data() + offset;
		std::uint8_t * stringEnd;

		// Make sure we won't read past the end of the buffer
		if((offset + maxLength) > fileData.size())
			maxLength = fileData.size() - offset;

		// Get the length of the string. Do not go beyond the maximum length
		// Note that there is no guaratee that the string is zero terminated, so can't use strlen
		// retdec-regression-tests\tools\fileinfo\bugs\issue-451-strange-section-names\4383fe67fec6ea6e44d2c7d075b9693610817edc68e8b2a76b2246b53b9186a1-unpacked
		stringEnd = (std::uint8_t *)memchr(stringBegin, 0, maxLength);
		if(stringEnd == nullptr)
		{
			// No zero terminator means that the string is limited by max length
			if(mustNotBeTooLong)
				return 0;
			stringEnd = stringBegin + maxLength;
		}

		// Copy the string
		length = stringEnd - stringBegin;
		str.resize(length);
		memcpy(const_cast<char *>(str.data()), stringBegin, length);

		// Ignore strings that contain non-printable chars
		if(mustBePrintable)
		{
			for(auto oneChar : str)
			{
				if(isPrintableChar(oneChar) == false)
				{
					str.clear();
					return 0;
				}
			}
		}
	}

	return length;
}

std::uint32_t PeLib::ImageLoader::dumpImage(const char * fileName)
{
	// Create the file for dumping
	std::ofstream fs(fileName, std::ofstream::binary);
	std::uint32_t bytesWritten = 0;

	if(fs.is_open())
	{
		// Allocate one page filled with zeros
		std::uint8_t zeroPage[PELIB_PAGE_SIZE] = {0};
		char * dataToWrite;

		// Write each page to the file
		for(auto & page : pages)
		{
			dataToWrite = (char *)(page.buffer.size() ? page.buffer.data() : zeroPage);
			fs.write(dataToWrite, PELIB_PAGE_SIZE);
			bytesWritten += PELIB_PAGE_SIZE;
		}
	}

	return bytesWritten;
}

std::uint32_t PeLib::ImageLoader::getImageBitability() const
{
	if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		return 64;

	// Default: 32-bit image
	return 32;
}

std::uint32_t PeLib::ImageLoader::vaToRva(std::uint64_t VirtualAddress) const
{
	if(getImageBase() <= VirtualAddress && VirtualAddress < getImageBase() + optionalHeader.SizeOfImage)
		return (std::uint32_t)(VirtualAddress - getImageBase());

	return UINT32_MAX;
}

std::uint32_t PeLib::ImageLoader::getFileOffsetFromRva(std::uint32_t rva) const
{
	// If we have sections loaded, then we calculate the file offset from section headers
	if(sections.size())
	{
		// Check whether the rva goes into any section
		for(auto & sectHdr : sections)
		{
			// Only if the pointer to raw data is not zero
			if(sectHdr.PointerToRawData != 0 && sectHdr.SizeOfRawData != 0)
			{
				std::uint32_t realPointerToRawData = sectHdr.PointerToRawData;
				std::uint32_t sectionRvaStart = sectHdr.VirtualAddress;
				std::uint32_t virtualSize = (sectHdr.VirtualSize != 0) ? sectHdr.VirtualSize : sectHdr.SizeOfRawData;

				// For multi-section images, real pointer to raw data is aligned down to sector size
				if(optionalHeader.SectionAlignment >= PELIB_PAGE_SIZE)
					realPointerToRawData = realPointerToRawData & ~(PELIB_SECTOR_SIZE - 1);

				// Is the RVA inside that section?
				if(sectionRvaStart <= rva && rva < (sectionRvaStart + virtualSize))
				{
					// Make sure we round the pointer to raw data down to PELIB_SECTOR_SIZE.
					// In case when PointerToRawData is less than 0x200, it maps to the header!
					return realPointerToRawData + (rva - sectionRvaStart);
				}
			}
		}

		// Check if the rva goes into the header
		return (rva < optionalHeader.SizeOfHeaders) ? rva : UINT32_MAX;
	}

	// The rva maps directly to the file offset
	return rva;
}

// similar to getFileOffsetFromRva, but the offset is within the real file and not memory image
std::uint32_t PeLib::ImageLoader::getValidOffsetFromRva(std::uint32_t rva) const
{
	// If we have sections loaded, then we calculate the file offset from section headers
	if (sections.size())
	{
		// Check whether the rva goes into any section
		for (auto& sectHdr : sections)
		{
			// Only if the pointer to raw data is not zero
			if (sectHdr.PointerToRawData != 0 && sectHdr.SizeOfRawData != 0)
			{
				std::uint32_t realPointerToRawData = sectHdr.PointerToRawData;
				std::uint32_t sectionRvaStart = sectHdr.VirtualAddress;
				std::uint32_t virtSize = sectHdr.VirtualSize;
				std::uint32_t rawSize = sectHdr.SizeOfRawData;

				// if rawSize is larger than what is mapped to memory, use only the mapped part
				std::uint32_t section_size = virtSize < rawSize ? virtSize : rawSize;
				// For multi-section images, real pointer to raw data is aligned down to sector size
				if (optionalHeader.SectionAlignment >= PELIB_PAGE_SIZE)
					realPointerToRawData = realPointerToRawData & ~(PELIB_SECTOR_SIZE - 1);

				// Check if the claimed real pointer can actually exist in the file
				std::uint64_t offset = rva - sectionRvaStart;
				bool fitsInFile = realPointerToRawData + offset < savedFileSize;

				// Is the RVA inside that part of the section, that is backed by disk data?
				if (sectionRvaStart <= rva && rva < (sectionRvaStart + section_size) && fitsInFile)
				{
					// Make sure we round the pointer to raw data down to PELIB_SECTOR_SIZE.
					// In case when PointerToRawData is less than 0x200, it maps to the header!
					return realPointerToRawData + offset;
				}
			}
		}

		// Check if the rva goes into the header
		return (rva < optionalHeader.SizeOfHeaders) ? rva : UINT32_MAX;
	}

	return UINT32_MAX;
}

std::uint32_t PeLib::ImageLoader::getFieldOffset(PELIB_MEMBER_TYPE field) const
{
	std::uint32_t imageBitability = getImageBitability();
	std::uint32_t fieldOffset;

	switch (field)
	{
		case PELIB_MEMBER_TYPE::OPTHDR_sizeof:
			return (imageBitability == 64) ? sizeof(PELIB_IMAGE_OPTIONAL_HEADER64) : sizeof(PELIB_IMAGE_OPTIONAL_HEADER32);

		case PELIB_MEMBER_TYPE::OPTHDR_sizeof_fixed:
			return (imageBitability == 64) ? offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory)
				                           : offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory);

		case PELIB_MEMBER_TYPE::OPTHDR_NumberOfRvaAndSizes:
			fieldOffset = (imageBitability == 64) ? offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, NumberOfRvaAndSizes)
				                                  : offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, NumberOfRvaAndSizes);
			return sizeof(PELIB_IMAGE_NT_SIGNATURE) + sizeof(PELIB_IMAGE_FILE_HEADER) + fieldOffset;

		case PELIB_MEMBER_TYPE::OPTHDR_DataDirectory:
			fieldOffset = (imageBitability == 64) ? offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory)
				                                  : offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory);
			return sizeof(PELIB_IMAGE_NT_SIGNATURE) + sizeof(PELIB_IMAGE_FILE_HEADER) + fieldOffset;

		case PELIB_MEMBER_TYPE::OPTHDR_DataDirectory_EXPORT_Rva:
			fieldOffset = (imageBitability == 64) ? offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory)
				                                  : offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory);
			return sizeof(PELIB_IMAGE_NT_SIGNATURE) +
				   sizeof(PELIB_IMAGE_FILE_HEADER) +
				   fieldOffset +
				   PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT * sizeof(PELIB_IMAGE_DATA_DIRECTORY);

		case PELIB_MEMBER_TYPE::OPTHDR_DataDirectory_RSRC_Rva:
			fieldOffset = (imageBitability == 64) ? offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory)
				                                  : offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory);
			return sizeof(PELIB_IMAGE_NT_SIGNATURE) +
				   sizeof(PELIB_IMAGE_FILE_HEADER) +
				   fieldOffset +
				   PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE * sizeof(PELIB_IMAGE_DATA_DIRECTORY);

		case PELIB_MEMBER_TYPE::OPTHDR_DataDirectory_TLS_Rva:
			fieldOffset = (imageBitability == 64) ? offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory)
				                                  : offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory);
			return sizeof(PELIB_IMAGE_NT_SIGNATURE) +
				   sizeof(PELIB_IMAGE_FILE_HEADER) +
				   fieldOffset +
				   PELIB_IMAGE_DIRECTORY_ENTRY_TLS * sizeof(PELIB_IMAGE_DATA_DIRECTORY);

		case PELIB_MEMBER_TYPE::OPTHDR_DataDirectory_DEBUG_Rva:
			fieldOffset = (imageBitability == 64) ? offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory)
				: offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory);
			return sizeof(PELIB_IMAGE_NT_SIGNATURE) +
				sizeof(PELIB_IMAGE_FILE_HEADER) +
				fieldOffset +
				PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG * sizeof(PELIB_IMAGE_DATA_DIRECTORY);

		case PELIB_MEMBER_TYPE::OPTHDR_DataDirectory_CONFIG_Rva:
			fieldOffset = (imageBitability == 64) ? offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory)
				                                  : offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory);
			return sizeof(PELIB_IMAGE_NT_SIGNATURE) +
				   sizeof(PELIB_IMAGE_FILE_HEADER) +
				   fieldOffset +
				   PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG * sizeof(PELIB_IMAGE_DATA_DIRECTORY);
	}

	return UINT32_MAX;
}

std::uint32_t PeLib::ImageLoader::getRealPointerToRawData(std::size_t sectionIndex) const
{
	if(sectionIndex >= sections.size())
		return UINT32_MAX;
	if(optionalHeader.SectionAlignment < PELIB_PAGE_SIZE)
		return sections[sectionIndex].PointerToRawData;

	return sections[sectionIndex].PointerToRawData & ~(PELIB_SECTOR_SIZE - 1);
}

std::uint32_t PeLib::ImageLoader::getRealSizeOfRawData(std::size_t sectionIndex) const
{
	if(sectionIndex >= sections.size())
		return UINT32_MAX;
	if(optionalHeader.SectionAlignment < PELIB_PAGE_SIZE)
		return sections[sectionIndex].SizeOfRawData;

	std::uint32_t beginOfRawData = sections[sectionIndex].PointerToRawData & ~(PELIB_SECTOR_SIZE - 1);
	std::uint32_t endOfRawData = sections[sectionIndex].PointerToRawData + AlignToSize(sections[sectionIndex].SizeOfRawData, optionalHeader.FileAlignment);
	return endOfRawData - beginOfRawData;
}

std::uint32_t PeLib::ImageLoader::getImageProtection(std::uint32_t sectionCharacteristics) const
{
	std::uint32_t Index = 0;

	if(sectionCharacteristics & PELIB_IMAGE_SCN_MEM_EXECUTE)
		Index |= 1;

	if(sectionCharacteristics & PELIB_IMAGE_SCN_MEM_READ)
		Index |= 2;

	if(sectionCharacteristics & PELIB_IMAGE_SCN_MEM_WRITE)
		Index |= 4;

	if(sectionCharacteristics & PELIB_IMAGE_SCN_MEM_SHARED)
		Index |= 8;

	return ImageProtectionArray[Index];
}

std::size_t PeLib::ImageLoader::getSectionIndexByRva(std::uint32_t Rva) const
{
	std::size_t sectionIndex = 0;

	for(const auto & section : sections)
	{
		if(section.VirtualAddress <= Rva && Rva < AlignToSize(section.VirtualAddress + section.VirtualSize, optionalHeader.SectionAlignment))
			return sectionIndex;
		sectionIndex++;
	}

	return SIZE_MAX;
}

//-----------------------------------------------------------------------------
// Manipulation with section data

void PeLib::ImageLoader::setPointerToSymbolTable(std::uint32_t pointerToSymbolTable)
{
	fileHeader.PointerToSymbolTable = pointerToSymbolTable;
}

void PeLib::ImageLoader::setCharacteristics(std::uint32_t characteristics)
{
	fileHeader.Characteristics = characteristics;
}

void PeLib::ImageLoader::setAddressOfEntryPoint(std::uint32_t addressOfEntryPoint)
{
	optionalHeader.AddressOfEntryPoint = addressOfEntryPoint;
}

void PeLib::ImageLoader::setSizeOfCode(
	std::uint32_t sizeOfCode,
	std::uint32_t baseOfCode)
{
	if(sizeOfCode != UINT32_MAX)
		optionalHeader.SizeOfCode = sizeOfCode;
	if(baseOfCode != UINT32_MAX)
		optionalHeader.BaseOfCode = baseOfCode;
}

void PeLib::ImageLoader::setDataDirectory(
	std::uint32_t entryIndex,
	std::uint32_t VirtualAddress,
	std::uint32_t Size)
{
	if(entryIndex < PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES)
	{
		// Make sure there is enough entries
		if(entryIndex >= optionalHeader.NumberOfRvaAndSizes)
			optionalHeader.NumberOfRvaAndSizes = entryIndex + 1;

		if(VirtualAddress != UINT32_MAX)
			optionalHeader.DataDirectory[entryIndex].VirtualAddress = VirtualAddress;
		if(Size != UINT32_MAX)
			optionalHeader.DataDirectory[entryIndex].Size = Size;
	}
}

PeLib::PELIB_IMAGE_SECTION_HEADER * PeLib::ImageLoader::addSection(
	const char * name,
	std::uint32_t sectionSize)
{
	if(optionalHeader.FileAlignment == 0)
		return nullptr;
	if(optionalHeader.SectionAlignment == 0)
		return nullptr;
	if(sections.size() >= UINT16_MAX)
		return nullptr;

	// Calculate the new RVA and file offset
	std::uint32_t Rva = 0;
	std::uint32_t Raw = 0;
	calcNewSectionAddresses(Rva, Raw);

	// Create new section
	PELIB_SECTION_HEADER SectHdr;
	SectHdr.setName(name);
	SectHdr.setVirtualRange(Rva, AlignToSize(sectionSize, optionalHeader.SectionAlignment));
	SectHdr.setRawDataRange(Raw, AlignToSize(sectionSize, optionalHeader.FileAlignment));
	SectHdr.Characteristics = PELIB_IMAGE_SCN_MEM_WRITE | PELIB_IMAGE_SCN_MEM_READ | PELIB_IMAGE_SCN_CNT_INITIALIZED_DATA | PELIB_IMAGE_SCN_CNT_CODE;
	sections.push_back(SectHdr);

	// Return the header of the last section
	return getSectionHeader(sections.size() - 1);
}

void PeLib::ImageLoader::calcNewSectionAddresses(
	std::uint32_t & Rva,
	std::uint32_t & RawOffset)
{
	std::uint32_t NewRawOffset = optionalHeader.SizeOfHeaders;
	std::uint32_t NewRva = optionalHeader.SizeOfHeaders;

	for(const auto & section : sections)
	{
		if((section.VirtualAddress + section.VirtualSize) > NewRva)
			NewRva = section.VirtualAddress + section.VirtualSize;
		if((section.PointerToRawData + section.SizeOfRawData) > NewRawOffset)
			NewRawOffset = section.PointerToRawData + section.SizeOfRawData;
	}

	RawOffset = AlignToSize(NewRawOffset, optionalHeader.FileAlignment);
	Rva = AlignToSize(NewRva, optionalHeader.SectionAlignment);
}

void PeLib::ImageLoader::setSectionName(
	std::size_t sectionIndex,
	const char * newName)
{
	if(sectionIndex < sections.size())
	{
		sections[sectionIndex].setName(newName);
	}
}

void PeLib::ImageLoader::setSectionVirtualRange(
	std::size_t sectionIndex,
	std::uint32_t VirtualAddress,
	std::uint32_t VirtualSize)
{
	if(sectionIndex < sections.size())
	{
		sections[sectionIndex].setVirtualRange(VirtualAddress, VirtualSize);
	}
}

void PeLib::ImageLoader::setSectionRawDataRange(
	std::size_t sectionIndex,
	std::uint32_t PointerToRawData,
	std::uint32_t SizeOfRawData)
{
	if(sectionIndex < sections.size())
	{
		sections[sectionIndex].setRawDataRange(PointerToRawData, SizeOfRawData);
	}
}

void PeLib::ImageLoader::setSectionCharacteristics(
	std::size_t sectionIndex,
	std::uint32_t Characteristics)
{
	if(sectionIndex < sections.size())
	{
		sections[sectionIndex].Characteristics = Characteristics;
	}
}

int PeLib::ImageLoader::splitSection(
	std::size_t sectionIndex,
	const std::string & prevSectName,
	const std::string & nextSectName,
	std::uint32_t splitOffset)
{
	if(!optionalHeader.FileAlignment)
		return PeLib::ERROR_NO_FILE_ALIGNMENT;
	if(!optionalHeader.SectionAlignment)
		return PeLib::ERROR_NO_SECTION_ALIGNMENT;

	// Index needs to be in the range <0, NUMBER OF SECTIONS)
	if(sectionIndex > sections.size())
		return PeLib::ERROR_ENTRY_NOT_FOUND;

	// Offset at which the section is going to be split must be multiple of section alignment
	if(splitOffset & (getSectionAlignment() - 1))
		return PeLib::ERROR_NOT_ENOUGH_SPACE;

	// Do not allow to split if the offset of split is greater than the size of the section
	// Nor do allow the section with size 0 to be created
	if(splitOffset >= getSectionHeader(sectionIndex)->VirtualSize)
		return PeLib::ERROR_NOT_ENOUGH_SPACE;

	// Move every section located after the inserted section by one position
	sections.resize(sections.size() + 1);
	for(std::size_t i = sections.size() - 2; i >= sectionIndex + 1; --i)
		sections[i + 1] = sections[i];

	std::uint32_t originalSize = getSectionHeader(sectionIndex)->SizeOfRawData;

	// Setup the first of the new sections
	setSectionName(sectionIndex, prevSectName.c_str());
	setSectionRawDataRange(sectionIndex, UINT32_MAX, splitOffset);
	setSectionVirtualRange(sectionIndex, UINT32_MAX, splitOffset);

	// Setup the second of the new sections
	setSectionName(sectionIndex + 1, nextSectName.c_str());
	setSectionRawDataRange(sectionIndex + 1, sections[sectionIndex].PointerToRawData + splitOffset, originalSize - splitOffset);
	setSectionVirtualRange(sectionIndex + 1, sections[sectionIndex].VirtualAddress + splitOffset, originalSize - splitOffset);
	setSectionCharacteristics(sectionIndex + 1, PeLib::PELIB_IMAGE_SCN_MEM_WRITE | PeLib::PELIB_IMAGE_SCN_MEM_READ | PeLib::PELIB_IMAGE_SCN_CNT_INITIALIZED_DATA | PeLib::PELIB_IMAGE_SCN_CNT_CODE);
	return PeLib::ERROR_NONE;
}

void PeLib::ImageLoader::enlargeLastSection(std::uint32_t sizeIncrement)
{
	if(sections.size())
	{
		auto & lastSection = sections[sections.size() - 1];

		lastSection.VirtualSize = lastSection.SizeOfRawData = AlignToSize(lastSection.SizeOfRawData + sizeIncrement, getFileAlignment());
		optionalHeader.SizeOfImage = lastSection.VirtualAddress + lastSection.VirtualSize;
	}
}

int PeLib::ImageLoader::removeSection(std::size_t sectionIndex)
{
	if(sectionIndex >= getNumberOfSections())
		return ERROR_ENTRY_NOT_FOUND;

	const PELIB_SECTION_HEADER * pSectionHeader = getSectionHeader(sectionIndex);
	std::uint32_t virtualDiff = pSectionHeader->VirtualSize;
	std::uint32_t rawDiff = pSectionHeader->SizeOfRawData;

	for (std::size_t i = sectionIndex + 1; i < getNumberOfSections(); ++i)
	{
		pSectionHeader = getSectionHeader(i);

		setSectionVirtualRange(i, pSectionHeader->VirtualAddress - virtualDiff);
		setSectionRawDataRange(i, pSectionHeader->PointerToRawData - rawDiff);
	}

	sections.erase(sections.begin() + sectionIndex);
	return ERROR_NONE;
}

void PeLib::ImageLoader::makeValid()
{
	std::uint32_t imageBitability = getImageBitability();
	std::uint32_t sizeOfHeaders;
	std::uint32_t sizeOfImage;
	std::uint32_t dwOffsetDiff;
	std::uint32_t alignment;

	// Fix the NT signature
	ntSignature = PELIB_IMAGE_NT_SIGNATURE;    // 'PE'

	// Fix the IMAGE_FILE_HEADER
	fileHeader.Machine = (imageBitability == 64) ? PELIB_IMAGE_FILE_MACHINE_AMD64 : PELIB_IMAGE_FILE_MACHINE_I386;
	fileHeader.NumberOfSections = (std::uint16_t)sections.size();
	fileHeader.SizeOfOptionalHeader = getFieldOffset(PELIB_MEMBER_TYPE::OPTHDR_sizeof);
	fileHeader.Characteristics = (fileHeader.Characteristics != 0) ? fileHeader.Characteristics : PELIB_IMAGE_FILE_EXECUTABLE_IMAGE | PELIB_IMAGE_FILE_32BIT_MACHINE;

	// Fix the IMAGE_OPTIONAL_HEADER
	optionalHeader.Magic = (imageBitability == 64) ? PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC : PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC;
	optionalHeader.NumberOfRvaAndSizes = PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES;

	alignment = AlignToSize(optionalHeader.SectionAlignment, PELIB_PAGE_SIZE);
	optionalHeader.SectionAlignment = (alignment != 0) ? alignment : PELIB_PAGE_SIZE;

	alignment = AlignToSize(optionalHeader.FileAlignment, PELIB_SECTOR_SIZE);
	optionalHeader.FileAlignment = (alignment != 0) ? alignment : PELIB_SECTOR_SIZE;

	sizeOfHeaders = dosHeader.e_lfanew + sizeof(PELIB_IMAGE_NT_SIGNATURE) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader + fileHeader.NumberOfSections * sizeof(PELIB_IMAGE_SECTION_HEADER);
	optionalHeader.SizeOfHeaders = sizeOfHeaders = AlignToSize(sizeOfHeaders, optionalHeader.FileAlignment);

	sizeOfImage = AlignToSize(optionalHeader.SizeOfHeaders, optionalHeader.SectionAlignment);
	dwOffsetDiff = sizeOfHeaders - getSectionHeader(0)->PointerToRawData;
	for(std::uint16_t i = 0; i < fileHeader.NumberOfSections; i++)
	{
		const PELIB_SECTION_HEADER * pSectionHeader = getSectionHeader(i);

		sizeOfImage += AlignToSize(pSectionHeader->VirtualSize, optionalHeader.SectionAlignment);

		// If the size of headers changed, we need to move all section data further
		if(dwOffsetDiff)
			setSectionRawDataRange(i, pSectionHeader->PointerToRawData + dwOffsetDiff);
	}

	// Fixup the size of image
	optionalHeader.SizeOfImage = AlignToSize(sizeOfImage, optionalHeader.SectionAlignment);
}

//-----------------------------------------------------------------------------
// Loader error

int PeLib::ImageLoader::setLoaderError(PeLib::LoaderError ldrErr)
{
	// Do not override existing loader error
	if(ldrError == LDR_ERROR_NONE)
	{
		ldrError = ldrErr;
	}
	return ERROR_NONE;
}

PeLib::LoaderError PeLib::ImageLoader::loaderError() const
{
	return ldrError;
}

//-----------------------------------------------------------------------------
// Interface for loading files
int PeLib::ImageLoader::Load(
	ByteBuffer & fileData,
	bool loadHeadersOnly)
{
	int fileError;

	// Remember the size of the file for later use
	savedFileSize = fileData.size();

	// Check and capture DOS header
	fileError = captureDosHeader(fileData);
	if(fileError != ERROR_NONE)
		return fileError;

	// Check and capture NT headers. Don't go any fuhrter than here if the NT headers were detected as bad.
	// Sample: retdec-regression-tests\tools\fileinfo\features\pe-loader-corruptions\001-pe-header-cut-001.ex_
	fileError = captureNtHeaders(fileData);
	if(fileError != ERROR_NONE || ldrError == LDR_ERROR_NTHEADER_OUT_OF_FILE)
		return fileError;

	// Check and capture section headers
	fileError = captureSectionHeaders(fileData);
	if(fileError != ERROR_NONE)
		return fileError;

	// Performed by Vista+
	if(forceIntegrityCheckEnabled && checkForBadCodeIntegrityImages(fileData))
		setLoaderError(LDR_ERROR_IMAGE_NON_EXECUTABLE);

	// Shall we map the image content?
	if(loadHeadersOnly == false)
	{
		// Large amount of memory may be allocated during loading the image to memory.
		// We need to handle low memory condition carefully here
		try
		{
			// If there was no detected image error, map the image as if Windows loader would do
			if(isImageLoadable())
			{
				fileError = captureImageSections(fileData);

				// If needed, also perform image load config directory check
				if(fileError == ERROR_NONE)
				{
					if(checkImagePostMapping && checkForImageAfterMapping())
						setLoaderError(LDR_ERROR_IMAGE_NON_EXECUTABLE);
				}
			}

			// If there was any kind of error that prevents the image from being mapped,
			// we load the content as-is and translate virtual addresses using getFileOffsetFromRva
			if(pages.size() == 0)
			{
				fileError = loadImageAsIs(fileData);
			}
		}
		catch(const std::bad_alloc&)
		{
			fileError = ERROR_NOT_ENOUGH_SPACE;
		}
	}

	return fileError;
}

int PeLib::ImageLoader::Load(
	std::istream & fs,
	std::streamoff fileOffset,
	bool loadHeadersOnly)
{
	ByteBuffer fileData;
	std::streampos fileSize;
	std::size_t fileSize2;
	int fileError;

	// We need to reset the stream's error state for cases where the file size is too small
	// Sample: retdec-regression-tests\tools\fileinfo\bugs\exotic-pe-files\shutd0wn97.ex
	fs.clear();

	// Get the file size
	fs.seekg(0, std::ios::end);
	fileSize = fs.tellg();

	// Verify overflow of the file offset
	if(fileOffset > fileSize)
		return ERROR_INVALID_FILE;

	// Windows loader refuses to load any file which is larger than 0xFFFFFFFF
	if(((fileSize - fileOffset) >> 32) != 0)
		return setLoaderError(LDR_ERROR_FILE_TOO_BIG);
	fileSize2 = static_cast<std::size_t>(fileSize - fileOffset);

	// Optimization: Read and verify IMAGE_DOS_HEADER first to see if it *could* be a PE file
	// This prevents reading the entire file (possibly a very large one) just to find out it's not a PE
	if((fileError = verifyDosHeader(fs, fileOffset, fileSize2)) != ERROR_NONE)
		return fileError;

	// Resize the vector so it can hold entire file. Note that this can
	// potentially allocate a very large memory block, so we need to handle that carefully
	try
	{
		fileData.resize(fileSize2);
	}
	catch(const std::bad_alloc&)
	{
		return ERROR_NOT_ENOUGH_SPACE;
	}

	// Read the entire file to memory. Note that under Windows
	// and under low memory condition, the underlying OS call (NtReadFile)
	// can fail on low memory. When that happens, fs.read will read less than
	// required. We need to verify the number of bytes read and return the apropriate error code.
	fs.seekg(fileOffset);
	fs.read(reinterpret_cast<char*>(fileData.data()), fileSize2);
	if(fs.gcount() < (fileSize - fileOffset))
	{
		return ERROR_NOT_ENOUGH_SPACE;
	}

	// Call the Load interface on char buffer
	return Load(fileData, loadHeadersOnly);
}

int PeLib::ImageLoader::Load(
	const char * fileName,
	bool loadHeadersOnly)
{
	std::ifstream fs(fileName, std::ifstream::in | std::ifstream::binary);
	if(!fs.is_open())
		return ERROR_OPENING_FILE;

	return Load(fs, loadHeadersOnly);
}

//-----------------------------------------------------------------------------
// Interface for saving to file

int PeLib::ImageLoader::Save(
	std::ostream & fs,
	std::streamoff fileOffset,
	std::uint32_t saveFlags)
{
	int fileError;

	// This save mode is intended for unpackers. Headers are constructed
	// from metadata and sections are filled with zeros
	if(saveFlags & IoFlagNewFile)
	{
		// Save the DOS header
		fileError = saveDosHeaderNew(fs, fileOffset);
		if(fileError != ERROR_NONE)
			return fileError;

		// Save the NT headers
		fileError = saveNtHeadersNew(fs, fileOffset + dosHeader.e_lfanew);
		if(fileError != ERROR_NONE)
			return fileError;

		// Check and capture section headers
		fileOffset = fileOffset + dosHeader.e_lfanew + sizeof(PELIB_IMAGE_NT_SIGNATURE) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;
		fileError = saveSectionHeadersNew(fs, fileOffset);
		if(fileError != ERROR_NONE)
			return fileError;

		// Write section data to the file, up to size of image
		if(!(saveFlags & IoFlagHeadersOnly))
		{
			// Get the curent file offset and file size
			fileOffset += sections.size() * sizeof(PELIB_IMAGE_SECTION_HEADER);
			std::streamoff fileSize = fileOffset;

			// Estimate the file size with data
			for(const auto & section : sections)
			{
				if(section.SizeOfRawData != 0)
				{
					if((section.PointerToRawData + section.SizeOfRawData) > fileSize)
						fileSize = section.PointerToRawData + section.SizeOfRawData;
				}
			}

			// Shall we write data to the file?
			if(fileSize > fileOffset)
			{
				std::vector<char> ZeroBuffer(fileSize - fileOffset);

				fs.seekp(fileOffset, std::ios::beg);
				fs.write(ZeroBuffer.data(), ZeroBuffer.size());
			}
		}
	}
	else
	{
		// Save the DOS header
		fileError = saveDosHeader(fs, fileOffset);
		if(fileError != ERROR_NONE)
			return fileError;

		// Save the NT headers
		fileError = saveNtHeaders(fs, fileOffset + dosHeader.e_lfanew);
		if(fileError != ERROR_NONE)
			return fileError;

		// Check and capture section headers
		fileOffset = fileOffset + dosHeader.e_lfanew + sizeof(PELIB_IMAGE_NT_SIGNATURE) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;
		fileError = saveSectionHeaders(fs, fileOffset);
		if(fileError != ERROR_NONE)
			return fileError;

		// Write section data to the file, up to size of image
		if(!(saveFlags & IoFlagHeadersOnly))
		{
			// Write each section
			for(const auto & section : sections)
			{
				fileError = saveToFile(fs, section.PointerToRawData, section.VirtualAddress, section.SizeOfRawData);
				if(fileError != ERROR_NONE)
					return fileError;
			}
		}
	}

	return ERROR_NONE;
}

int PeLib::ImageLoader::Save(
	const char * fileName,
	std::uint32_t saveFlags)
{
    std::ofstream fs(fileName, std::ifstream::out | std::ifstream::binary);
    if(!fs.is_open())
        return ERROR_OPENING_FILE;

    return Save(fs, 0, saveFlags);
}

//-----------------------------------------------------------------------------
// Protected functions

void PeLib::ImageLoader::readFromPage(
	PELIB_FILE_PAGE & page,
	void * buffer,
	std::size_t offsetInPage,
	std::size_t bytesInPage)
{
	// Is it a page with actual data?
	if(page.buffer.size())
	{
		memcpy(buffer, page.buffer.data() + offsetInPage, bytesInPage);
	}
	else
	{
		memset(buffer, 0, bytesInPage);
	}
}

void PeLib::ImageLoader::writeToPage(
	PELIB_FILE_PAGE & page,
	void * buffer,
	std::size_t offsetInPage,
	std::size_t bytesInPage)
{
	// Write the data to the page
	page.writeToPage(buffer, offsetInPage, bytesInPage);
}

std::uint32_t PeLib::ImageLoader::readWriteImage(
	void * buffer,
	std::uint32_t rva,
	std::uint32_t bytesToRead,
	READWRITE ReadWrite)
{
	std::uint32_t bytesRead = 0;
	std::uint32_t rvaEnd = rva + bytesToRead;

	// Check the last possible address where we read
	if(rvaEnd > getSizeOfImageAligned())
		rvaEnd = getSizeOfImageAligned();

	// Is the offset within the image?
	if(rva < rvaEnd)
	{
		std::uint8_t * bufferPtr = static_cast<std::uint8_t *>(buffer);

		while(rva < rvaEnd)
		{
			std::uint32_t offsetInPage = rva & (PELIB_PAGE_SIZE - 1);
			std::uint32_t bytesInPage = PELIB_PAGE_SIZE - offsetInPage;
			std::size_t pageIndex = rva / PELIB_PAGE_SIZE;

			// Perhaps the last page loaded?
			if(bytesInPage > (rvaEnd - rva))
				bytesInPage = (rvaEnd - rva);

			// The page index must be in range
			if(pageIndex < pages.size())
			{
				ReadWrite(pages[pageIndex], bufferPtr, offsetInPage, bytesInPage);
			}
			else
			{
				memset(bufferPtr, 0, bytesInPage);
			}

			// Move pointers
			bufferPtr += bytesInPage;
			bytesRead += bytesInPage;
			rva += bytesInPage;
		}
	}

	// Return the number of bytes that were read
	return bytesRead;
}

std::uint32_t PeLib::ImageLoader::readWriteImageFile(
	void * buffer,
	std::uint32_t rva,
	std::uint32_t bytesToRead,
	bool bReadOperation)
{
	std::uint32_t fileOffset = getFileOffsetFromRva(rva);

	// Make sure we won't read/write past the end of the data
	if(fileOffset > rawFileData.size())
		return 0;
	if((fileOffset + bytesToRead) > rawFileData.size())
		bytesToRead = (std::uint32_t)(rawFileData.size() - fileOffset);

	// Read the data
	if(bytesToRead != 0)
	{
		if(bReadOperation)
			memcpy(buffer, rawFileData.data() + fileOffset, bytesToRead);
		else
			memcpy(rawFileData.data() + fileOffset, buffer, bytesToRead);
	}

	// Return the number of bytes read/written
	return bytesToRead;
}

//
// There is a specific piece of code in MiParseImageSectionHeaders (see below).
// Note that this is done on the raw image data *BEFORE* the image is mapped to sections
// Causes map difference on this sample: 2e26926a701df980fb56e5905a93bf2d7ba6981ccabc81cf251b3c0ed6afdc26
// * SizeOfHeaders:                0x1000
// * PointerToRawData section[1]:  0x0200 - this actually points to the IMAGE_SECTION_HEADER of section[3]
// Because the PointerToRawData of section[3] is set to zero, the RVA 0xA014 is also set to zero
//
// The code is here:
//
//   //
//   // Fix for Borland linker problem.  The SizeOfRawData can
//   // be a zero, but the PointerToRawData is not zero.
//   // Set it to zero.
//   //
//
//  if(SectionTableEntry->SizeOfRawData == 0) {
//      SectionTableEntry->PointerToRawData = 0;
//  }
//

void PeLib::ImageLoader::processSectionHeader(
	PELIB_IMAGE_SECTION_HEADER * pSectionHeader)
{
	// Note: Retdec's regression tests don't like it, because they require section headers to have original data
	// Also signature verification stops working if we modify the original data
	if(windowsBuildNumber != 0)
	{
		// Fix the section header. Note that this will modify the data in the on-disk version
		// of the image. Any section that will become mapped to this section header
		// will have the corresponding DWORD zeroed, as expected.
		if(pSectionHeader->PointerToRawData != 0 && pSectionHeader->SizeOfRawData == 0)
		{
			pSectionHeader->PointerToRawData = 0;
		}
	}
}

//-----------------------------------------------------------------------------
// Processes relocation entry for IA64 relocation bundle

#define EMARCH_ENC_I17_IMM7B_INST_WORD_X         3
#define EMARCH_ENC_I17_IMM7B_SIZE_X              7
#define EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X     4
#define EMARCH_ENC_I17_IMM7B_VAL_POS_X           0

#define EMARCH_ENC_I17_IMM9D_INST_WORD_X         3
#define EMARCH_ENC_I17_IMM9D_SIZE_X              9
#define EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X     18
#define EMARCH_ENC_I17_IMM9D_VAL_POS_X           7

#define EMARCH_ENC_I17_IMM5C_INST_WORD_X         3
#define EMARCH_ENC_I17_IMM5C_SIZE_X              5
#define EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X     13
#define EMARCH_ENC_I17_IMM5C_VAL_POS_X           16

#define EMARCH_ENC_I17_IC_INST_WORD_X            3
#define EMARCH_ENC_I17_IC_SIZE_X                 1
#define EMARCH_ENC_I17_IC_INST_WORD_POS_X        12
#define EMARCH_ENC_I17_IC_VAL_POS_X              21

#define EMARCH_ENC_I17_IMM41a_INST_WORD_X        1
#define EMARCH_ENC_I17_IMM41a_SIZE_X             10
#define EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X    14
#define EMARCH_ENC_I17_IMM41a_VAL_POS_X          22

#define EMARCH_ENC_I17_IMM41b_INST_WORD_X        1
#define EMARCH_ENC_I17_IMM41b_SIZE_X             8
#define EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X    24
#define EMARCH_ENC_I17_IMM41b_VAL_POS_X          32

#define EMARCH_ENC_I17_IMM41c_INST_WORD_X        2
#define EMARCH_ENC_I17_IMM41c_SIZE_X             23
#define EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X    0
#define EMARCH_ENC_I17_IMM41c_VAL_POS_X          40

#define EMARCH_ENC_I17_SIGN_INST_WORD_X          3
#define EMARCH_ENC_I17_SIGN_SIZE_X               1
#define EMARCH_ENC_I17_SIGN_INST_WORD_POS_X      27
#define EMARCH_ENC_I17_SIGN_VAL_POS_X            63

#define EXT_IMM64(Value, SourceValue32, Size, InstPos, ValPos)   \
    Value |= (((std::uint64_t)((SourceValue32 >> InstPos) & (((std::uint64_t)1 << Size) - 1))) << ValPos)

#define INS_IMM64(Value, TargetValue32, Size, InstPos, ValPos)   \
    TargetValue32 = (TargetValue32 & ~(((1 << Size) - 1) << InstPos)) |  \
          ((std::uint32_t)((((std::uint64_t)Value >> ValPos) & (((std::uint64_t)1 << Size) - 1))) << InstPos)

bool PeLib::ImageLoader::processImageRelocation_IA64_IMM64(
	std::uint32_t fixupAddress,
	std::uint64_t difference)
{
	std::uint64_t Value64 = 0;
	std::uint32_t BundleBlock[4];

	// Align the fixup address to bundle address
	fixupAddress = fixupAddress & ~0x0F;

	// Load the 4 32-bit values from the target
	if(readImage(BundleBlock, fixupAddress, sizeof(BundleBlock)) != sizeof(BundleBlock))
		return false;

	//
	// Extract the IMM64 from bundle
	//

	EXT_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM7B_INST_WORD_X],
			  EMARCH_ENC_I17_IMM7B_SIZE_X,
			  EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM7B_VAL_POS_X);
	EXT_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM9D_INST_WORD_X],
			  EMARCH_ENC_I17_IMM9D_SIZE_X,
			  EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM9D_VAL_POS_X);
	EXT_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM5C_INST_WORD_X],
			  EMARCH_ENC_I17_IMM5C_SIZE_X,
			  EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM5C_VAL_POS_X);
	EXT_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IC_INST_WORD_X],
			  EMARCH_ENC_I17_IC_SIZE_X,
			  EMARCH_ENC_I17_IC_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IC_VAL_POS_X);
	EXT_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM41a_INST_WORD_X],
			  EMARCH_ENC_I17_IMM41a_SIZE_X,
			  EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM41a_VAL_POS_X);
	EXT_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM41b_INST_WORD_X],
			  EMARCH_ENC_I17_IMM41b_SIZE_X,
			  EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM41b_VAL_POS_X);
	EXT_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM41c_INST_WORD_X],
			  EMARCH_ENC_I17_IMM41c_SIZE_X,
			  EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM41c_VAL_POS_X);
	EXT_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_SIGN_INST_WORD_X],
			  EMARCH_ENC_I17_SIGN_SIZE_X,
			  EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
			  EMARCH_ENC_I17_SIGN_VAL_POS_X);
	//
	// Update 64-bit address
	//

	Value64 += difference;

	//
	// Insert IMM64 into bundle
	//

	INS_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM7B_INST_WORD_X],
			  EMARCH_ENC_I17_IMM7B_SIZE_X,
			  EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM7B_VAL_POS_X);
	INS_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM9D_INST_WORD_X],
			  EMARCH_ENC_I17_IMM9D_SIZE_X,
			  EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM9D_VAL_POS_X);
	INS_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM5C_INST_WORD_X],
			  EMARCH_ENC_I17_IMM5C_SIZE_X,
			  EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM5C_VAL_POS_X);
	INS_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IC_INST_WORD_X],
			  EMARCH_ENC_I17_IC_SIZE_X,
			  EMARCH_ENC_I17_IC_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IC_VAL_POS_X);
	INS_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM41a_INST_WORD_X],
			  EMARCH_ENC_I17_IMM41a_SIZE_X,
			  EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM41a_VAL_POS_X);
	INS_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM41b_INST_WORD_X],
			  EMARCH_ENC_I17_IMM41b_SIZE_X,
			  EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM41b_VAL_POS_X);
	INS_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_IMM41c_INST_WORD_X],
			  EMARCH_ENC_I17_IMM41c_SIZE_X,
			  EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
			  EMARCH_ENC_I17_IMM41c_VAL_POS_X);
	INS_IMM64(Value64, BundleBlock[EMARCH_ENC_I17_SIGN_INST_WORD_X],
			  EMARCH_ENC_I17_SIGN_SIZE_X,
			  EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
			  EMARCH_ENC_I17_SIGN_VAL_POS_X);

	// Write the bundle block back to the image
	return (writeImage(BundleBlock, fixupAddress, sizeof(BundleBlock)) == sizeof(BundleBlock));
}

bool PeLib::ImageLoader::processImageRelocations(
	std::uint64_t oldImageBase,
	std::uint64_t newImageBase,
	std::uint32_t VirtualAddress,
	std::uint32_t Size)
{
	std::uint64_t difference = (newImageBase - oldImageBase);
	std::uint8_t * bufferEnd;
	std::uint8_t * bufferPtr;
	std::uint8_t * buffer;

	// No not accept anything less than size of relocation block
	// Also refuse to process suspiciously large relocation blocks
	if(Size < sizeof(PELIB_IMAGE_BASE_RELOCATION) || Size > PELIB_SIZE_10MB)
		return false;

	// Allocate and read the relocation block
	bufferPtr = buffer = new std::uint8_t[Size];
	if(buffer != nullptr)
	{
		// Read the relocations from the file
		bufferEnd = buffer + readImage(buffer, VirtualAddress, Size);

		// Keep going while there is relocation blocks
		while((bufferPtr + sizeof(PELIB_IMAGE_BASE_RELOCATION)) <= bufferEnd)
		{
			PELIB_IMAGE_BASE_RELOCATION * pRelocBlock = (PELIB_IMAGE_BASE_RELOCATION *)(bufferPtr);
			std::uint16_t * typeAndOffset = (std::uint16_t * )(pRelocBlock + 1);
			std::uint32_t numRelocations;

			// Skip relocation blocks that have invalid values
			if(!isValidImageBlock(pRelocBlock->VirtualAddress, pRelocBlock->SizeOfBlock))
				break;

			// Skip relocation blocks which have invalid size in the header
			if(pRelocBlock->SizeOfBlock <= sizeof(PELIB_IMAGE_BASE_RELOCATION))
			{
				bufferPtr += sizeof(PELIB_IMAGE_BASE_RELOCATION);
				continue;
			}

			// Windows loader seems to skip relocation blocks that go into the 0-th page (the header)
			// Sample: e380e6968f1b431e245f811f94cef6a5b6e17fd7c90ef283338fa1959eb3c536
			if(isZeroPage(pRelocBlock->VirtualAddress))
			{
				bufferPtr += pRelocBlock->SizeOfBlock;
				continue;
			}

			// Calculate number of relocation entries. Prevent buffer overflow
			if((bufferPtr + pRelocBlock->SizeOfBlock) > bufferEnd)
				pRelocBlock->SizeOfBlock = bufferEnd - bufferPtr;
			numRelocations = (pRelocBlock->SizeOfBlock - sizeof(PELIB_IMAGE_BASE_RELOCATION)) / sizeof(std::uint16_t);

			// Parse relocations
			for(std::uint32_t i = 0; i < numRelocations; i++)
			{
				std::uint32_t fixupAddress = pRelocBlock->VirtualAddress + (typeAndOffset[i] & 0x0FFF);
				std::int32_t temp;

				switch(typeAndOffset[i] >> 12)
				{
					// The base relocation applies the difference to the 64-bit field at offset.
					case PELIB_IMAGE_REL_BASED_DIR64:
					{
						std::int64_t fixupValue = 0;

						if(readImage(&fixupValue, fixupAddress, sizeof(fixupValue)) != sizeof(fixupValue))
							break;
						fixupValue += difference;
						writeImage(&fixupValue, fixupAddress, sizeof(fixupValue));
						break;
					}

					// The base relocation applies all 32 bits of the difference to the 32-bit field at offset.
					case PELIB_IMAGE_REL_BASED_HIGHLOW:
					{
						std::int32_t fixupValue = 0;

						if(readImage(&fixupValue, fixupAddress, sizeof(fixupValue)) != sizeof(fixupValue))
							break;
						fixupValue += (std::int32_t)difference;
						writeImage(&fixupValue, fixupAddress, sizeof(fixupValue));
						break;
					}

					// The base relocation adds the high 16 bits of the difference to the 16-bit field at offset.
					case PELIB_IMAGE_REL_BASED_HIGH:
					{
						std::int16_t fixupValue = 0;

						if(readImage(&fixupValue, fixupAddress, sizeof(fixupValue)) != sizeof(fixupValue))
							break;
						temp = (fixupValue << 16);
						temp += (std::int32_t)difference;
						fixupValue = (std::int16_t)(temp >> 16);
						writeImage(&fixupValue, fixupAddress, sizeof(fixupValue));
						break;
					}

					// The base relocation adds the high 16 bits of the difference to the 16-bit field at offset.
					case PELIB_IMAGE_REL_BASED_HIGHADJ:
					{
						std::int16_t fixupValue = 0;

						if(readImage(&fixupValue, fixupAddress, sizeof(fixupValue)) != sizeof(fixupValue))
							break;
						temp = (fixupValue << 16);
						temp += (std::int32_t)typeAndOffset[++i];
						temp += (std::int32_t)difference;
						temp += 0x8000;
						fixupValue = (std::int16_t)(temp >> 16);
						writeImage(&fixupValue, fixupAddress, sizeof(fixupValue));
						break;
					}

					// The base relocation adds the low 16 bits of the difference to the 16-bit field at offset.
					case PELIB_IMAGE_REL_BASED_LOW:
					{
						std::int16_t fixupValue = 0;

						if(readImage(&fixupValue, fixupAddress, sizeof(fixupValue)) != sizeof(fixupValue))
							break;
						fixupValue = (std::int16_t)((std::int32_t)fixupValue + difference);
						writeImage(&fixupValue, fixupAddress, sizeof(fixupValue));
						break;
					}

					// Relocate a MIPS jump address.
					case PELIB_IMAGE_REL_BASED_MIPS_JMPADDR:
					{
						std::uint32_t fixupValue = 0;

						if(readImage(&fixupValue, fixupAddress, sizeof(fixupValue)) != sizeof(fixupValue))
							break;
						temp = (fixupValue & 0x3ffffff) << 2;
						temp += (std::int32_t)difference;
						fixupValue = (fixupValue & ~0x3ffffff) | ((temp >> 2) & 0x3ffffff);
						writeImage(&fixupValue, fixupAddress, sizeof(fixupValue));
						break;
					}

					case PELIB_IMAGE_REL_BASED_IA64_IMM64:
						processImageRelocation_IA64_IMM64(fixupAddress, difference);
						break;

					// Absolute - no fixup required.
					case PELIB_IMAGE_REL_BASED_ABSOLUTE:
						break;

					default:
						return false;
				}
			}

			// Move to the next relocation block
			bufferPtr = bufferPtr + pRelocBlock->SizeOfBlock;
		}

		// Free the relocation buffer
		delete [] buffer;
	}

	return true;
}

void PeLib::ImageLoader::writeNewImageBase(std::uint64_t newImageBase)
{
	std::uint32_t offset = dosHeader.e_lfanew + sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER);

	// 64-bit images
	if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
	{
		PELIB_IMAGE_OPTIONAL_HEADER64 header64{};
		std::uint32_t sizeOfOptionalHeader = offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory);

		readImage(&header64, offset, sizeOfOptionalHeader);
		header64.ImageBase = newImageBase;
		writeImage(&header64, offset, sizeOfOptionalHeader);
	}

	// 32-bit images
	if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC)
	{
		PELIB_IMAGE_OPTIONAL_HEADER32 header32{};
		std::uint32_t sizeOfOptionalHeader = offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory);

		readImage(&header32, offset, sizeOfOptionalHeader);
		header32.ImageBase = (std::uint32_t)newImageBase;
		writeImage(&header32, offset, sizeOfOptionalHeader);
	}
}

int PeLib::ImageLoader::captureDosHeader(ByteBuffer & fileData)
{
	std::uint8_t * fileBegin = fileData.data();
	std::uint8_t * fileEnd = fileBegin + fileData.size();

	// Capture the DOS header
	if((fileBegin + sizeof(PELIB_IMAGE_DOS_HEADER)) >= fileEnd)
		return ERROR_INVALID_FILE;
	memcpy(&dosHeader, fileBegin, sizeof(PELIB_IMAGE_DOS_HEADER));

	// Verify DOS header
	return verifyDosHeader(dosHeader, fileData.size());
}

int PeLib::ImageLoader::saveToFile(
	std::ostream & fs,
	std::streamoff fileOffset,
	std::size_t rva,
	std::size_t length)
{
	std::vector<char> DataBuffer(length);

	readImage(DataBuffer.data(), rva, length);
	fs.seekp(fileOffset, std::ios::beg);
	fs.write(DataBuffer.data(), length);
	return ERROR_NONE;
}

int PeLib::ImageLoader::saveDosHeaderNew(
	std::ostream & fs,
	std::streamoff fileOffset)
{
	// Write DOS header as-is
	fs.seekp(fileOffset, std::ios::beg);
	fs.write(reinterpret_cast<char *>(&dosHeader), sizeof(PELIB_IMAGE_DOS_HEADER));
	return ERROR_NONE;
}

int PeLib::ImageLoader::saveDosHeader(
	std::ostream & fs,
	std::streamoff fileOffset)
{
	// Request some reasonable maximum to the DOS header size
	if(dosHeader.e_lfanew > PELIB_PAGE_SIZE * 10)
		return ERROR_INVALID_FILE;
	return saveToFile(fs, fileOffset, 0, dosHeader.e_lfanew);
}

int PeLib::ImageLoader::captureNtHeaders(ByteBuffer & fileData)
{
	std::uint8_t * fileBegin = fileData.data();
	std::uint8_t * filePtr = fileBegin + dosHeader.e_lfanew;
	std::uint8_t * fileEnd = fileBegin + fileData.size();
	std::size_t ntHeaderSize;
	std::uint16_t optionalHeaderMagic = PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC;

	// Windows 7 or newer require that the file size is greater or equal to sizeof(IMAGE_NT_HEADERS)
	// Note that 64-bit kernel requires this to be sizeof(IMAGE_NT_HEADERS64)
	if(ntHeadersSizeCheck)
	{
		std::uint32_t minFileSize = dosHeader.e_lfanew + sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + sizeof(PELIB_IMAGE_OPTIONAL_HEADER32);

		if((fileBegin + minFileSize) > fileEnd)
			return setLoaderError(LDR_ERROR_NTHEADER_OUT_OF_FILE);
	}

	// Capture the NT signature
	if((filePtr + sizeof(std::uint32_t)) >= fileEnd)
	{
		setLoaderError(LDR_ERROR_NTHEADER_OUT_OF_FILE);
		return ERROR_INVALID_FILE;
	}

	// Check the NT signature
	if((ntSignature = *(std::uint32_t *)(filePtr)) != PELIB_IMAGE_NT_SIGNATURE)
	{
		setLoaderError(LDR_ERROR_NO_NT_SIGNATURE);
		return ERROR_INVALID_FILE;
	}
	filePtr += sizeof(std::uint32_t);

	// Capture the file header. Note that if the NT header is cut, we still want to recognize the file as PE
	if((filePtr + sizeof(PELIB_IMAGE_FILE_HEADER)) >= fileEnd)
	{
		setLoaderError(LDR_ERROR_NTHEADER_OUT_OF_FILE);
		return ERROR_NONE;
	}
	memcpy(&fileHeader, filePtr, sizeof(PELIB_IMAGE_FILE_HEADER));

	// 7baebc6d9f2185fafa760c875ab1386f385a0b3fecf2e6ae339abb4d9ac58f3e
	if(fileHeader.Machine == 0 && fileHeader.SizeOfOptionalHeader == 0)
		setLoaderError(LDR_ERROR_FILE_HEADER_INVALID);
	if(!(fileHeader.Characteristics & PELIB_IMAGE_FILE_EXECUTABLE_IMAGE))
		setLoaderError(LDR_ERROR_IMAGE_NON_EXECUTABLE);
	filePtr += sizeof(PELIB_IMAGE_FILE_HEADER);

	// Windows XP: Number of section must be 96
	// Windows 7: Number of section must be 192
	if(fileHeader.NumberOfSections > maxSectionCount)
		setLoaderError(LDR_ERROR_IMAGE_NON_EXECUTABLE);

	// Check the position of the NT header for integer overflow and for file size overflow
	ntHeaderSize = sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;
	if((dosHeader.e_lfanew + ntHeaderSize) < dosHeader.e_lfanew)
		setLoaderError(LDR_ERROR_NTHEADER_OFFSET_OVERFLOW);

	// Capture optional header. Note that we need to parse it
	// according to IMAGE_OPTIONAL_HEADER::Magic
	if((filePtr + sizeof(std::uint16_t)) < fileEnd)
		optionalHeaderMagic = *(std::uint16_t *)(filePtr);
	if(optionalHeaderMagic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		captureOptionalHeader64(fileBegin, filePtr, fileEnd);
	else
		captureOptionalHeader32(fileBegin, filePtr, fileEnd);

	// Performed by Windows 8+ (nt!MiRelocateImage). If check fails,
	// NtCreateSection returns STATUS_INVALID_IMAGE_FORMAT (0xC000007B)
	// In Windows 10 (since build 10240), this check is only performed for "legacy" images (I386 or AMD64)
	// Sample: 04d3577d1b6309a0032d4c4c1252c55416a09bb617aebafe512fffbdd4f08f18
	if(architectureSpecificChecks && checkForBadArchitectureSpecific())
		setLoaderError(LDR_ERROR_IMAGE_NON_EXECUTABLE);

	// SizeOfHeaders must be nonzero if not a single subsection
	if(optionalHeader.SectionAlignment >= PELIB_PAGE_SIZE && optionalHeader.SizeOfHeaders == 0)
		setLoaderError(LDR_ERROR_SIZE_OF_HEADERS_ZERO);

	// File alignment must not be 0
	if(optionalHeader.FileAlignment == 0)
		setLoaderError(LDR_ERROR_FILE_ALIGNMENT_ZERO);

	// File alignment must be a power of 2
	if(optionalHeader.FileAlignment & (optionalHeader.FileAlignment-1))
		setLoaderError(LDR_ERROR_FILE_ALIGNMENT_NOT_POW2);

	// Section alignment must not be 0
	if(optionalHeader.SectionAlignment == 0)
		setLoaderError(LDR_ERROR_SECTION_ALIGNMENT_ZERO);

	// Section alignment must be a power of 2
	if(optionalHeader.SectionAlignment & (optionalHeader.SectionAlignment - 1))
		setLoaderError(LDR_ERROR_SECTION_ALIGNMENT_NOT_POW2);

	if(optionalHeader.SectionAlignment < optionalHeader.FileAlignment)
		setLoaderError(LDR_ERROR_SECTION_ALIGNMENT_TOO_SMALL);

	// Check for images with "super-section": FileAlignment must be equal to SectionAlignment
	if((optionalHeader.FileAlignment & 511) && (optionalHeader.SectionAlignment != optionalHeader.FileAlignment))
		setLoaderError(LDR_ERROR_SECTION_ALIGNMENT_INVALID);

	// Check for largest image
	if(optionalHeader.SizeOfImage > PELIB_MM_SIZE_OF_LARGEST_IMAGE)
		setLoaderError(LDR_ERROR_SIZE_OF_IMAGE_TOO_BIG);

	// Check for 32-bit images
	if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC && checkForValid32BitMachine() == false)
		setLoaderError(LDR_ERROR_INVALID_MACHINE32);

	// Check for 64-bit images
	if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC && checkForValid64BitMachine() == false)
		setLoaderError(LDR_ERROR_INVALID_MACHINE64);

	// Check the size of image
	if(optionalHeader.SizeOfHeaders > optionalHeader.SizeOfImage)
		setLoaderError(LDR_ERROR_SIZE_OF_HEADERS_INVALID);

	// On 64-bit Windows, size of optional header must be properly aligned to 8-byte boundary
	if(is64BitWindows && (fileHeader.SizeOfOptionalHeader & 0x07))
		setLoaderError(LDR_ERROR_SIZE_OF_OPTHDR_NOT_ALIGNED);

	// Set the size of image
	if(BytesToPages(optionalHeader.SizeOfImage) == 0)
		setLoaderError(LDR_ERROR_SIZE_OF_IMAGE_ZERO);

	// Check for proper alignment of the image base
	if(optionalHeader.ImageBase & (PELIB_SIZE_64KB - 1))
		setLoaderError(LDR_ERROR_IMAGE_BASE_NOT_ALIGNED);

	return ERROR_NONE;
}

int PeLib::ImageLoader::saveNtHeadersNew(
	std::ostream & fs,
	std::streamoff fileOffset)
{
	// Calculate the size of the optional header. Any version of PE file,
	// 32 or 64-bit, must have this field set to a correct value.
	std::uint32_t sizeOfOptionalHeader = getFieldOffset(PELIB_MEMBER_TYPE::OPTHDR_sizeof_fixed) + optionalHeader.NumberOfRvaAndSizes * sizeof(PELIB_IMAGE_DATA_DIRECTORY);

	// Move to the required file offset
	fs.seekp(fileOffset, std::ios::beg);

	// Write the NT signature
	fs.write(reinterpret_cast<char *>(&ntSignature), sizeof(ntSignature));

	// Write the file header
	fileHeader.SizeOfOptionalHeader = sizeOfOptionalHeader;
	fileHeader.NumberOfSections = (std::uint16_t)sections.size();
	fs.write(reinterpret_cast<char *>(&fileHeader), sizeof(PELIB_IMAGE_FILE_HEADER));

	// Write the optional header. Note that we need to distinguish 32-bit and 64-bit header
	if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC)
	{
		PELIB_IMAGE_OPTIONAL_HEADER32 optionalHeader32;

		// Verify some of the data to make sure they are able to convert to 32-bit values
		if((optionalHeader.ImageBase >> 0x20) != 0)
			return ERROR_INVALID_FILE;
		if((optionalHeader.SizeOfStackReserve >> 0x20) != 0)
			return ERROR_INVALID_FILE;
		if((optionalHeader.SizeOfHeapReserve >> 0x20) != 0)
			return ERROR_INVALID_FILE;

		// Convert the optional header to 32-bit variant
		optionalHeader32.Magic                       = optionalHeader.Magic;
		optionalHeader32.MajorLinkerVersion          = optionalHeader.MajorLinkerVersion;
		optionalHeader32.MinorLinkerVersion          = optionalHeader.MinorLinkerVersion;
		optionalHeader32.SizeOfCode                  = optionalHeader.SizeOfCode;
		optionalHeader32.SizeOfInitializedData       = optionalHeader.SizeOfInitializedData;
		optionalHeader32.SizeOfUninitializedData     = optionalHeader.SizeOfUninitializedData;
		optionalHeader32.AddressOfEntryPoint         = optionalHeader.AddressOfEntryPoint;
		optionalHeader32.BaseOfCode                  = optionalHeader.BaseOfCode;
		optionalHeader32.BaseOfData                  = optionalHeader.BaseOfData;
		optionalHeader32.ImageBase                   = (std::uint32_t)optionalHeader.ImageBase;
		optionalHeader32.SectionAlignment            = optionalHeader.SectionAlignment;
		optionalHeader32.FileAlignment               = optionalHeader.FileAlignment;
		optionalHeader32.MajorOperatingSystemVersion = optionalHeader.MajorOperatingSystemVersion;
		optionalHeader32.MinorOperatingSystemVersion = optionalHeader.MinorOperatingSystemVersion;
		optionalHeader32.MajorImageVersion           = optionalHeader.MajorImageVersion;
		optionalHeader32.MinorImageVersion           = optionalHeader.MinorImageVersion;
		optionalHeader32.MajorSubsystemVersion       = optionalHeader.MajorSubsystemVersion;
		optionalHeader32.MinorSubsystemVersion       = optionalHeader.MinorSubsystemVersion;
		optionalHeader32.Win32VersionValue           = optionalHeader.Win32VersionValue;
		optionalHeader32.SizeOfImage                 = optionalHeader.SizeOfImage;
		optionalHeader32.SizeOfHeaders               = optionalHeader.SizeOfHeaders;
		optionalHeader32.CheckSum                    = optionalHeader.CheckSum;
		optionalHeader32.Subsystem                   = optionalHeader.Subsystem;
		optionalHeader32.DllCharacteristics          = optionalHeader.DllCharacteristics;
		optionalHeader32.SizeOfStackReserve          = (std::uint32_t)optionalHeader.SizeOfStackReserve;
		optionalHeader32.SizeOfStackCommit           = (std::uint32_t)optionalHeader.SizeOfStackCommit;
		optionalHeader32.SizeOfHeapReserve           = (std::uint32_t)optionalHeader.SizeOfHeapReserve;
		optionalHeader32.SizeOfHeapCommit            = (std::uint32_t)optionalHeader.SizeOfHeapCommit;
		optionalHeader32.LoaderFlags                 = optionalHeader.LoaderFlags;
		optionalHeader32.NumberOfRvaAndSizes         = optionalHeader.NumberOfRvaAndSizes;
		memcpy(&optionalHeader32.DataDirectory, &optionalHeader.DataDirectory, sizeof(optionalHeader.DataDirectory));

		// Write to file
		fs.write(reinterpret_cast<char *>(&optionalHeader32), sizeOfOptionalHeader);
	}
	else
	{
		PELIB_IMAGE_OPTIONAL_HEADER64 optionalHeader64;

		// Convert the optional header to 64-bit variant
		optionalHeader64.Magic                       = optionalHeader.Magic;
		optionalHeader64.MajorLinkerVersion          = optionalHeader.MajorLinkerVersion;
		optionalHeader64.MinorLinkerVersion          = optionalHeader.MinorLinkerVersion;
		optionalHeader64.SizeOfCode                  = optionalHeader.SizeOfCode;
		optionalHeader64.SizeOfInitializedData       = optionalHeader.SizeOfInitializedData;
		optionalHeader64.SizeOfUninitializedData     = optionalHeader.SizeOfUninitializedData;
		optionalHeader64.AddressOfEntryPoint         = optionalHeader.AddressOfEntryPoint;
		optionalHeader64.BaseOfCode                  = optionalHeader.BaseOfCode;
		optionalHeader64.ImageBase                   = optionalHeader.ImageBase;
		optionalHeader64.SectionAlignment            = optionalHeader.SectionAlignment;
		optionalHeader64.FileAlignment               = optionalHeader.FileAlignment;
		optionalHeader64.MajorOperatingSystemVersion = optionalHeader.MajorOperatingSystemVersion;
		optionalHeader64.MinorOperatingSystemVersion = optionalHeader.MinorOperatingSystemVersion;
		optionalHeader64.MajorImageVersion           = optionalHeader.MajorImageVersion;
		optionalHeader64.MinorImageVersion           = optionalHeader.MinorImageVersion;
		optionalHeader64.MajorSubsystemVersion       = optionalHeader.MajorSubsystemVersion;
		optionalHeader64.MinorSubsystemVersion       = optionalHeader.MinorSubsystemVersion;
		optionalHeader64.Win32VersionValue           = optionalHeader.Win32VersionValue;
		optionalHeader64.SizeOfImage                 = optionalHeader.SizeOfImage;
		optionalHeader64.SizeOfHeaders               = optionalHeader.SizeOfHeaders;
		optionalHeader64.CheckSum                    = optionalHeader.CheckSum;
		optionalHeader64.Subsystem                   = optionalHeader.Subsystem;
		optionalHeader64.DllCharacteristics          = optionalHeader.DllCharacteristics;
		optionalHeader64.SizeOfStackReserve          = optionalHeader.SizeOfStackReserve;
		optionalHeader64.SizeOfStackCommit           = optionalHeader.SizeOfStackCommit;
		optionalHeader64.SizeOfHeapReserve           = optionalHeader.SizeOfHeapReserve;
		optionalHeader64.SizeOfHeapCommit            = optionalHeader.SizeOfHeapCommit;
		optionalHeader64.LoaderFlags                 = optionalHeader.LoaderFlags;
		optionalHeader64.NumberOfRvaAndSizes         = optionalHeader.NumberOfRvaAndSizes;
		memcpy(&optionalHeader64.DataDirectory, &optionalHeader.DataDirectory, sizeof(optionalHeader64.DataDirectory));

		// Write to file
		fs.write(reinterpret_cast<char *>(&optionalHeader64), sizeOfOptionalHeader);
	}

	return ERROR_NONE;
}

int PeLib::ImageLoader::saveNtHeaders(
	std::ostream & fs,
	std::streamoff fileOffset)
{
	// Calculate the size of the optional header. Any version of PE file,
	// 32 or 64-bit, must have this field set to a correct value.
	std::size_t sizeOfOptionalHeader = getFieldOffset(PELIB_MEMBER_TYPE::OPTHDR_sizeof_fixed) + optionalHeader.NumberOfRvaAndSizes * sizeof(PELIB_IMAGE_DATA_DIRECTORY);
	std::size_t sizeOfHeaders = sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + sizeOfOptionalHeader;

	// Give the size of NT headers some reasonable maximum
	if(sizeOfHeaders > PELIB_PAGE_SIZE * 10)
		return ERROR_INVALID_FILE;
	return saveToFile(fs, fileOffset, dosHeader.e_lfanew, sizeOfHeaders);
}

int PeLib::ImageLoader::captureSectionName(
	ByteBuffer & fileData,
	std::string & sectionName,
	const std::uint8_t * Name)
{
	// If the section name is in format of "/12345", then the section name is actually in the symbol table
	// Sample: 2e9c671b8a0411f2b397544b368c44d7f095eb395779de0ad1ac946914dfa34c
	if(fileHeader.PointerToSymbolTable != 0 && Name[0] == '/')
	{
		// Get the offset of the string table
		std::uint32_t stringTableOffset = fileHeader.PointerToSymbolTable + fileHeader.NumberOfSymbols * PELIB_IMAGE_SIZEOF_COFF_SYMBOL;
		std::uint32_t stringTableIndex = 0;

		// Convert the index from string to number
		for (std::size_t i = 1; i < PELIB_IMAGE_SIZEOF_SHORT_NAME && isdigit(Name[i]); i++)
			stringTableIndex = (stringTableIndex * 10) + (Name[i] - '0');

		// Get the section name
		if(readStringRaw(fileData, sectionName, stringTableOffset + stringTableIndex, PELIB_IMAGE_SIZEOF_MAX_NAME, true, true) != 0)
		    return ERROR_NONE;
	}

	// The section name is directly in the section header.
	// It has fixed length and must not be necessarily terminated with zero.
	sectionName.clear();

	// rstrip trailing nulls
	const std::uint8_t* end = Name + PELIB_IMAGE_SIZEOF_SHORT_NAME;
	// find the first non-null from end
	do
	{
		end--;
	} while (end - Name > 0 && *end == 0);

	if (end - Name > 0)
	{
		sectionName.assign(Name, end + 1);
	}

	return ERROR_NONE;
}

int PeLib::ImageLoader::captureSectionHeaders(ByteBuffer & fileData)
{
	std::uint8_t * fileBegin = fileData.data();
	std::uint8_t * filePtr;
	std::uint8_t * fileEnd = fileBegin + fileData.size();
	bool bRawDataBeyondEOF = false;

	// If there are no sections, then we're done
	if(fileHeader.NumberOfSections == 0)
		return ERROR_NONE;

	// Check whether the sections are within the file
	filePtr = fileBegin + dosHeader.e_lfanew + sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;
	if(filePtr > fileEnd)
		return setLoaderError(LDR_ERROR_SECTION_HEADERS_OUT_OF_IMAGE);

	// Set the counters
	std::uint32_t NumberOfSectionPTEs = AlignToSize(optionalHeader.SizeOfHeaders, optionalHeader.SectionAlignment) / PELIB_PAGE_SIZE;
	std::uint64_t NextVirtualAddress = 0;
	std::uint32_t NumberOfPTEs = BytesToPages(optionalHeader.SizeOfImage);
	std::uint32_t FileAlignmentMask = optionalHeader.FileAlignment - 1;
	bool SingleSubsection = (optionalHeader.SectionAlignment < PELIB_PAGE_SIZE);

	// Verify the image
	if(!SingleSubsection)
	{
		// Some extra checks done by the loader
		if((optionalHeader.SizeOfHeaders + (optionalHeader.SectionAlignment - 1)) < optionalHeader.SizeOfHeaders)
			setLoaderError(LDR_ERROR_SECTION_HEADERS_OVERFLOW);

		if(NumberOfSectionPTEs > NumberOfPTEs)
			setLoaderError(LDR_ERROR_SIZE_OF_HEADERS_INVALID);

		// Update the virtual address
		NextVirtualAddress += NumberOfSectionPTEs * PELIB_PAGE_SIZE;
		NumberOfPTEs -= NumberOfSectionPTEs;
	}
	else
	{
		NumberOfSectionPTEs = AlignToSize(optionalHeader.SizeOfImage, PELIB_PAGE_SIZE) / PELIB_PAGE_SIZE;
		NumberOfPTEs -= NumberOfSectionPTEs;
	}

	// Read and verify all section headers
	for(std::uint16_t i = 0; i < fileHeader.NumberOfSections; i++)
	{
		PELIB_SECTION_HEADER sectHdr;

		// Capture one section header
		if((filePtr + sizeof(PELIB_IMAGE_SECTION_HEADER)) > fileEnd)
			break;
		memcpy(&sectHdr, filePtr, sizeof(PELIB_IMAGE_SECTION_HEADER));

		// Fix the section header *in the source data*. We need to do that *after* the section header was loaded
		processSectionHeader((PELIB_IMAGE_SECTION_HEADER *)filePtr);

		// Parse the section headers and check for corruptions
		std::uint32_t PointerToRawData = (sectHdr.SizeOfRawData != 0) ? sectHdr.PointerToRawData : 0;
		std::uint32_t EndOfRawData = PointerToRawData + sectHdr.SizeOfRawData;
		std::uint32_t VirtualSize = (sectHdr.VirtualSize != 0) ? sectHdr.VirtualSize : sectHdr.SizeOfRawData;

		// Overflow check
		if((PointerToRawData + sectHdr.SizeOfRawData) < PointerToRawData)
			setLoaderError(LDR_ERROR_RAW_DATA_OVERFLOW);

		// Verify the image
		if(SingleSubsection)
		{
			// If the image is mapped as single subsection,
			// then the virtual values must match raw values
			if((sectHdr.VirtualAddress != sectHdr.PointerToRawData) || sectHdr.SizeOfRawData < VirtualSize)
				setLoaderError(LDR_ERROR_SECTION_SIZE_MISMATCH);
		}
		else
		{
			// Check the virtual address of the section
			if(NextVirtualAddress != sectHdr.VirtualAddress)
				setLoaderError(LDR_ERROR_INVALID_SECTION_VA);

			// Check the end of the section
			if((NextVirtualAddress + VirtualSize) <= NextVirtualAddress)
				setLoaderError(LDR_ERROR_INVALID_SECTION_VSIZE);

			// Check section size
			if((VirtualSize + (PELIB_PAGE_SIZE - 1)) <= VirtualSize)
				setLoaderError(LDR_ERROR_INVALID_SECTION_VSIZE);

			// Calculate number of PTEs in the section
			NumberOfSectionPTEs = AlignToSize(VirtualSize, optionalHeader.SectionAlignment) / PELIB_PAGE_SIZE;
			if(NumberOfSectionPTEs > NumberOfPTEs)
				setLoaderError(LDR_ERROR_INVALID_SECTION_VSIZE);

			NumberOfPTEs -= NumberOfSectionPTEs;

			// Check end of the raw data for the section
			if(((PointerToRawData + sectHdr.SizeOfRawData + FileAlignmentMask) & ~FileAlignmentMask) < PointerToRawData)
				setLoaderError(LDR_ERROR_INVALID_SECTION_RAWSIZE);

			// On last section, size of raw data must not go after the end of the file
			// Sample: a5957dad4b3a53a5894708c7c1ba91be0668ecbed49e33affee3a18c0737c3a5
			if(i == fileHeader.NumberOfSections - 1 && sectHdr.SizeOfRawData != 0)
			{
				if((sectHdr.PointerToRawData + sectHdr.SizeOfRawData) > fileData.size())
					setLoaderError(LDR_ERROR_FILE_IS_CUT);
			}

			NextVirtualAddress += NumberOfSectionPTEs * PELIB_PAGE_SIZE;
		}

		// Check for raw data beyond end-of-file
		// Note that Windows loader doesn't check this on files that are mapped as single section.
		// We will do that nonetheless, because we want to know that a file is cut.
		if(PointerToRawData != 0 && (fileBegin + EndOfRawData) > fileEnd)
			bRawDataBeyondEOF = true;

		// Resolve the section name
		captureSectionName(fileData, sectHdr.sectionName, sectHdr.Name);

		// Insert the header to the list
		sections.push_back(sectHdr);
		filePtr += sizeof(PELIB_IMAGE_SECTION_HEADER);
	}

	// Verify the image size. Note that this check is no longer performed by Windows 10
	if(sizeofImageMustMatch)
	{
		std::uint32_t ThresholdNumberOfPTEs = (SingleSubsection == false) ? (optionalHeader.SectionAlignment / PELIB_PAGE_SIZE) : 1;
		if(NumberOfPTEs >= ThresholdNumberOfPTEs)
		{
			setLoaderError(LDR_ERROR_INVALID_SIZE_OF_IMAGE);
		}
	}

	// Did we detect a trimmed file?
	if(bRawDataBeyondEOF)
	{
		// Track the state of loadability of the cut file. Some files can still be loadable.
		// Example: bd149478739e660b032e4454057ce8d3e18dfbb6d1677c6ecdcc3aa59b36c8d9
		bool bCutButLoadable = false;

		// Special exception: Even if cut, the file is still loadable
		// if the last section is in the file range. This is because
		// the PE loader in Windows only cares about whether the last section is in the file range
		if(SingleSubsection == false)
		{
			if(!sections.empty())
			{
				PELIB_IMAGE_SECTION_HEADER & lastSection = sections.back();
				std::uint32_t PointerToRawData = (lastSection.SizeOfRawData != 0) ? lastSection.PointerToRawData : 0;
				std::uint32_t EndOfRawData = PointerToRawData + lastSection.SizeOfRawData;

				if((lastSection.SizeOfRawData == 0) || (fileBegin + EndOfRawData) <= fileEnd)
				{
					setLoaderError(LDR_ERROR_FILE_IS_CUT_LOADABLE);
					bCutButLoadable = true;
				}
			}
		}
		else
		{
			setLoaderError(LDR_ERROR_FILE_IS_CUT_LOADABLE);
			bCutButLoadable = true;
		}

		// If the file is not loadable, set the "file is cut" error
		if(bCutButLoadable == false)
		{
			setLoaderError(LDR_ERROR_FILE_IS_CUT);
		}
	}

	return ERROR_NONE;
}

int PeLib::ImageLoader::saveSectionHeadersNew(
	std::ostream & fs,
	std::streamoff fileOffset)
{
	PELIB_IMAGE_SECTION_HEADER * pHeaders;
	std::size_t sectionCount = sections.size();
	std::size_t index = 0;

	if((pHeaders = new PELIB_IMAGE_SECTION_HEADER[sectionCount]) != nullptr)
	{
		// Populate the array with section headers
		for(const auto & section : sections)
		{
			memcpy(pHeaders + index, section.Name, sizeof(PELIB_IMAGE_SECTION_HEADER));
			index++;
		}

		// Write the section headers to file
		fs.seekp(fileOffset, std::ios::beg);
		fs.write(reinterpret_cast<char *>(pHeaders), sectionCount * sizeof(PELIB_IMAGE_SECTION_HEADER));
		delete[] pHeaders;
	}

	return ERROR_NONE;
}

int PeLib::ImageLoader::saveSectionHeaders(
	std::ostream & fs,
	std::streamoff fileOffset)
{
	std::size_t offsetOfHeaders = dosHeader.e_lfanew + sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;
	std::size_t sizeOfHeaders = fileHeader.NumberOfSections * sizeof(PELIB_IMAGE_SECTION_HEADER);

	// Give the size of NT headers some reasonable maximum
	if(sizeOfHeaders > PELIB_PAGE_SIZE * 10)
		return ERROR_INVALID_FILE;
	return saveToFile(fs, fileOffset, offsetOfHeaders, sizeOfHeaders);
}

int PeLib::ImageLoader::captureImageSections(ByteBuffer & fileData)
{
	std::uint32_t virtualAddress = 0;
	std::uint32_t sizeOfHeaders = optionalHeader.SizeOfHeaders;
	std::uint32_t sizeOfImage = optionalHeader.SizeOfImage;

	// Section-based mapping / file-based mapping
	if(optionalHeader.SectionAlignment >= PELIB_PAGE_SIZE)
	{
		// Reserve the image size, aligned up to the page size
		sizeOfImage = AlignToSize(sizeOfImage, PELIB_PAGE_SIZE);
		pages.resize(sizeOfImage / PELIB_PAGE_SIZE);

		// Note: Under Windows XP, the loader maps the entire page of the image header
		// if the condition in checkForSectionTablesWithinHeader() turns out to be true.
		// Windows 7+ uses correct size check.
		// Sample: 1669f0220f1f74523390fe5b61ea09d6e2e4e798ab294c93d0a20900a3c5a52a
		// (Any sample with 4 sections and IMAGE_DOS_HEADER::e_lfanew >= 0x724 will do)
		if(headerSizeCheck && checkForSectionTablesWithinHeader(dosHeader.e_lfanew))
			sizeOfHeaders = AlignToSize(sizeOfHeaders, optionalHeader.SectionAlignment);

		// Capture the file header
		virtualAddress = captureImageSection(fileData, virtualAddress, sizeOfHeaders, 0, sizeOfHeaders, PELIB_IMAGE_SCN_MEM_READ, true);
		if(virtualAddress == 0)
			return ERROR_INVALID_FILE;

		// Capture each section
		if(sections.size() != 0)
		{
			for(auto & sectionHeader : sections)
			{
				// Capture all pages from the section
				if(captureImageSection(fileData, sectionHeader.VirtualAddress,
												 sectionHeader.VirtualSize,
												 sectionHeader.PointerToRawData,
												 sectionHeader.SizeOfRawData,
												 sectionHeader.Characteristics) == 0)
				{
					setLoaderError(LDR_ERROR_INVALID_SECTION_VA);
					break;
				}
			}
		}
		else
		{
			// If the file has no sections, we need to check the SizeOfImage against
			// the virtual address. They must match, otherwise Windows will not load the file.
			// Sample: cdf2a3ff23ec8a0814e285d94c4f081202ea6fe69661ff9940dcafc28e5fc626
			if(virtualAddress > optionalHeader.SizeOfImage || (optionalHeader.SizeOfImage - virtualAddress) > optionalHeader.SectionAlignment)
			{
				setLoaderError(LDR_ERROR_INVALID_SIZE_OF_IMAGE);
			}
		}
	}
	else
	{
		// 64-bit Windows always align single-section images to page size.
		// 32-bit Windows:
		// * Windows XP: sector size
		// * Windows 7 : sector size (network files) or no align (local files)
		// * Windows 10: no align
		// If the image is smaller than one page, it is aligned to one page
		sizeOfImage = AlignToSize(sizeOfImage, ssiImageAlignment32);
		if(is64BitWindows && alignSingleSectionImagesToPage)
			sizeOfImage = AlignToSize(sizeOfImage, PELIB_PAGE_SIZE);
		if(sizeOfImage < PELIB_PAGE_SIZE)
			sizeOfImage = PELIB_PAGE_SIZE;
		pages.resize((sizeOfImage + PELIB_PAGE_SIZE - 1) / PELIB_PAGE_SIZE);

		// Capture the file as-is
		virtualAddress = captureImageSection(fileData, 0, sizeOfImage, 0, sizeOfImage, PELIB_IMAGE_SCN_MEM_WRITE | PELIB_IMAGE_SCN_MEM_READ | PELIB_IMAGE_SCN_MEM_EXECUTE, true);
		if(virtualAddress == 0)
			return ERROR_INVALID_FILE;
	}

	return ERROR_NONE;
}

int PeLib::ImageLoader::verifyDosHeader(
	PELIB_IMAGE_DOS_HEADER & hdr,
	std::size_t fileSize)
{
	if(hdr.e_magic != PELIB_IMAGE_DOS_SIGNATURE)
		return ERROR_INVALID_FILE;
	if(hdr.e_lfanew & 3)
		return setLoaderError(LDR_ERROR_E_LFANEW_UNALIGNED);
	if(hdr.e_lfanew > fileSize)
		return setLoaderError(LDR_ERROR_E_LFANEW_OUT_OF_FILE);

	return ERROR_NONE;
}

int PeLib::ImageLoader::verifyDosHeader(
	std::istream & fs,
	std::streamoff fileOffset,
	std::size_t fileSize)
{
	PELIB_IMAGE_DOS_HEADER tempDosHeader;
	int fileError;

	// The file size must be at least size of DOS header
	if((fileOffset + sizeof(PELIB_IMAGE_DOS_HEADER)) >= fileSize)
		return ERROR_INVALID_FILE;
	fs.seekg(fileOffset);

	// Read the DOS header
	if(fs.read(reinterpret_cast<char*>(&tempDosHeader), sizeof(PELIB_IMAGE_DOS_HEADER)).bad())
		return ERROR_INVALID_FILE;

	// Verify the DOS header
	if((fileError = verifyDosHeader(tempDosHeader, fileSize)) != ERROR_NONE)
		return fileError;

	// If the DOS header points out of the file, it's a wrong file too
	return (ldrError == LDR_ERROR_E_LFANEW_OUT_OF_FILE) ? ERROR_INVALID_FILE : ERROR_NONE;
}

int PeLib::ImageLoader::loadImageAsIs(ByteBuffer & fileData)
{
	rawFileData = fileData;
	return ERROR_NONE;
}

// While copying the data directories, we take into account possible out-of-bounds
// data directory entries, as long as they fit into sizeOfOptionalHeader
// Sample: 53b13d7cfb97b5475e21717397c85376a1de2b18c2eeb6532b160fb8aa3a393d
// This sample has NumberOfRvaAndSizes set to 0x0E, but the IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR (0x0E),
// but the .NET framework (_CorExeMain) does not care about NumberOfRvaAndSizes
// and directly takes the DataDirectory without checking NumberOfRvaAndSizes
std::uint32_t PeLib::ImageLoader::copyDataDirectories(
	std::uint8_t * optionalHeaderPtr,
	std::uint8_t * dataDirectoriesPtr,
	std::size_t optionalHeaderMax,			// How many bytes do we have from the beginning of the optional header till the end of the file
	std::uint32_t numberOfRvaAndSizes)
{
	std::uint8_t * dataDirectoriesEnd = dataDirectoriesPtr + PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES * sizeof(PELIB_IMAGE_DATA_DIRECTORY);

	// Do not leave numberOfRvaAndSizes higher than the maximum possible value
	if(numberOfRvaAndSizes > PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES)
		numberOfRvaAndSizes = PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES;

	// Determine the end of data directories based on file size.
	// Note that the SizeOfOptionalHeader does NOT have any meaning in this
	if(dataDirectoriesEnd > (optionalHeaderPtr + optionalHeaderMax))
		dataDirectoriesEnd = (optionalHeaderPtr + optionalHeaderMax);

	// Copy data directories, up to SizeOfOptionalHeader
	if(dataDirectoriesEnd > dataDirectoriesPtr)
		memcpy(optionalHeader.DataDirectory, dataDirectoriesPtr, (dataDirectoriesEnd - dataDirectoriesPtr));
	return numberOfRvaAndSizes;
}

int PeLib::ImageLoader::captureOptionalHeader64(
	std::uint8_t * fileBegin,
	std::uint8_t * filePtr,
	std::uint8_t * fileEnd)
{
	PELIB_IMAGE_OPTIONAL_HEADER64 optionalHeader64{};
	std::uint32_t sizeOfOptionalHeader = sizeof(PELIB_IMAGE_OPTIONAL_HEADER64);

	// Capture optional header. Note that IMAGE_FILE_HEADER::SizeOfOptionalHeader
	// is not taken into account by the Windows loader - it simply assumes that the entire optional header is present
	if((filePtr + sizeOfOptionalHeader) > fileEnd)
		sizeOfOptionalHeader = (std::uint32_t)(fileEnd - filePtr);
	memcpy(&optionalHeader64, filePtr, sizeOfOptionalHeader);

	// Verify whether it's 64-bit optional header
	if(optionalHeader64.Magic != PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		return setLoaderError(LDR_ERROR_NO_OPTHDR_MAGIC);

	// Convert 32-bit optional header to common optional header
	optionalHeader.Magic                       = optionalHeader64.Magic;
	optionalHeader.MajorLinkerVersion          = optionalHeader64.MajorLinkerVersion;
	optionalHeader.MinorLinkerVersion          = optionalHeader64.MinorLinkerVersion;
	optionalHeader.SizeOfCode                  = optionalHeader64.SizeOfCode;
	optionalHeader.SizeOfInitializedData       = optionalHeader64.SizeOfInitializedData;
	optionalHeader.SizeOfUninitializedData     = optionalHeader64.SizeOfUninitializedData;
	optionalHeader.AddressOfEntryPoint         = optionalHeader64.AddressOfEntryPoint;
	optionalHeader.BaseOfCode                  = optionalHeader64.BaseOfCode;
	optionalHeader.ImageBase                   = optionalHeader64.ImageBase;
	optionalHeader.SectionAlignment            = optionalHeader64.SectionAlignment;
	optionalHeader.FileAlignment               = optionalHeader64.FileAlignment;
	optionalHeader.MajorOperatingSystemVersion = optionalHeader64.MajorOperatingSystemVersion;
	optionalHeader.MinorOperatingSystemVersion = optionalHeader64.MinorOperatingSystemVersion;
	optionalHeader.MajorImageVersion           = optionalHeader64.MajorImageVersion;
	optionalHeader.MinorImageVersion           = optionalHeader64.MinorImageVersion;
	optionalHeader.MajorSubsystemVersion       = optionalHeader64.MajorSubsystemVersion;
	optionalHeader.MinorSubsystemVersion       = optionalHeader64.MinorSubsystemVersion;
	optionalHeader.Win32VersionValue           = optionalHeader64.Win32VersionValue;
	optionalHeader.SizeOfImage                 = optionalHeader64.SizeOfImage;
	optionalHeader.SizeOfHeaders               = optionalHeader64.SizeOfHeaders;
	optionalHeader.CheckSum                    = optionalHeader64.CheckSum;
	optionalHeader.Subsystem                   = optionalHeader64.Subsystem;
	optionalHeader.DllCharacteristics          = optionalHeader64.DllCharacteristics;
	optionalHeader.SizeOfStackReserve          = optionalHeader64.SizeOfStackReserve;
	optionalHeader.SizeOfStackCommit           = optionalHeader64.SizeOfStackCommit;
	optionalHeader.SizeOfHeapReserve           = optionalHeader64.SizeOfHeapReserve;
	optionalHeader.SizeOfHeapCommit            = optionalHeader64.SizeOfHeapCommit;
	optionalHeader.LoaderFlags                 = optionalHeader64.LoaderFlags;
	optionalHeader.NumberOfRvaAndSizes         = optionalHeader64.NumberOfRvaAndSizes;

	// Copy data directories
	realNumberOfRvaAndSizes = copyDataDirectories((std::uint8_t *)(&optionalHeader64),
												  (std::uint8_t *)(&optionalHeader64.DataDirectory[0]),
												  fileEnd - filePtr,
												  optionalHeader64.NumberOfRvaAndSizes);

	// Remember the offset of the checksum field
	checkSumFileOffset = (filePtr - fileBegin) + offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, CheckSum);
	securityDirFileOffset = (filePtr - fileBegin) + offsetof(PELIB_IMAGE_OPTIONAL_HEADER64, DataDirectory) + (sizeof(PELIB_IMAGE_DATA_DIRECTORY) * PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY);
	return ERROR_NONE;
}

int PeLib::ImageLoader::captureOptionalHeader32(
	std::uint8_t * fileBegin,
	std::uint8_t * filePtr,
	std::uint8_t * fileEnd)
{
	PELIB_IMAGE_OPTIONAL_HEADER32 optionalHeader32{};
	std::uint32_t sizeOfOptionalHeader = sizeof(PELIB_IMAGE_OPTIONAL_HEADER32);

	// Capture optional header. Note that IMAGE_FILE_HEADER::SizeOfOptionalHeader
	// is not taken into account by the Windows loader - it simply assumes that the entire optional header is present
	if((filePtr + sizeOfOptionalHeader) > fileEnd)
		sizeOfOptionalHeader = (std::uint32_t)(fileEnd - filePtr);
	memcpy(&optionalHeader32, filePtr, sizeOfOptionalHeader);

	// Note: Do not fail if there's no magic value for 32-bit optional header
	if(optionalHeader32.Magic != PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC)
		setLoaderError(LDR_ERROR_NO_OPTHDR_MAGIC);

	// Convert 32-bit optional header to common optional header
	optionalHeader.Magic                       = optionalHeader32.Magic;
	optionalHeader.MajorLinkerVersion          = optionalHeader32.MajorLinkerVersion;
	optionalHeader.MinorLinkerVersion          = optionalHeader32.MinorLinkerVersion;
	optionalHeader.SizeOfCode                  = optionalHeader32.SizeOfCode;
	optionalHeader.SizeOfInitializedData       = optionalHeader32.SizeOfInitializedData;
	optionalHeader.SizeOfUninitializedData     = optionalHeader32.SizeOfUninitializedData;
	optionalHeader.AddressOfEntryPoint         = optionalHeader32.AddressOfEntryPoint;
	optionalHeader.BaseOfCode                  = optionalHeader32.BaseOfCode;
	optionalHeader.BaseOfData                  = optionalHeader32.BaseOfData;
	optionalHeader.ImageBase                   = optionalHeader32.ImageBase;
	optionalHeader.SectionAlignment            = optionalHeader32.SectionAlignment;
	optionalHeader.FileAlignment               = optionalHeader32.FileAlignment;
	optionalHeader.MajorOperatingSystemVersion = optionalHeader32.MajorOperatingSystemVersion;
	optionalHeader.MinorOperatingSystemVersion = optionalHeader32.MinorOperatingSystemVersion;
	optionalHeader.MajorImageVersion           = optionalHeader32.MajorImageVersion;
	optionalHeader.MinorImageVersion           = optionalHeader32.MinorImageVersion;
	optionalHeader.MajorSubsystemVersion       = optionalHeader32.MajorSubsystemVersion;
	optionalHeader.MinorSubsystemVersion       = optionalHeader32.MinorSubsystemVersion;
	optionalHeader.Win32VersionValue           = optionalHeader32.Win32VersionValue;
	optionalHeader.SizeOfImage                 = optionalHeader32.SizeOfImage;
	optionalHeader.SizeOfHeaders               = optionalHeader32.SizeOfHeaders;
	optionalHeader.CheckSum                    = optionalHeader32.CheckSum;
	optionalHeader.Subsystem                   = optionalHeader32.Subsystem;
	optionalHeader.DllCharacteristics          = optionalHeader32.DllCharacteristics;
	optionalHeader.SizeOfStackReserve          = optionalHeader32.SizeOfStackReserve;
	optionalHeader.SizeOfStackCommit           = optionalHeader32.SizeOfStackCommit;
	optionalHeader.SizeOfHeapReserve           = optionalHeader32.SizeOfHeapReserve;
	optionalHeader.SizeOfHeapCommit            = optionalHeader32.SizeOfHeapCommit;
	optionalHeader.LoaderFlags                 = optionalHeader32.LoaderFlags;
	optionalHeader.NumberOfRvaAndSizes         = optionalHeader32.NumberOfRvaAndSizes;

	// Copy data directories
	realNumberOfRvaAndSizes = copyDataDirectories((std::uint8_t *)(&optionalHeader32),
												  (std::uint8_t *)(&optionalHeader32.DataDirectory[0]),
												  fileEnd - filePtr,
												  optionalHeader32.NumberOfRvaAndSizes);

	// Remember the offset of the checksum field
	checkSumFileOffset = (filePtr - fileBegin) + offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, CheckSum);
	securityDirFileOffset = (filePtr - fileBegin) + offsetof(PELIB_IMAGE_OPTIONAL_HEADER32, DataDirectory) + (sizeof(PELIB_IMAGE_DATA_DIRECTORY) * PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY);
	return ERROR_NONE;
}

std::uint32_t PeLib::ImageLoader::captureImageSection(
	ByteBuffer & fileData,
	std::uint32_t virtualAddress,
	std::uint32_t virtualSize,
	std::uint32_t pointerToRawData,
	std::uint32_t sizeOfRawData,
	std::uint32_t characteristics,
	bool isImageHeader)
{
	std::uint8_t * fileBegin = fileData.data();
	std::uint8_t * rawDataPtr;
	std::uint8_t * rawDataEnd;
	std::uint8_t * fileEnd = fileBegin + fileData.size();
	std::uint32_t sizeOfInitializedPages;            // The part of section with initialized pages
	std::uint32_t sizeOfValidPages;                  // The part of section with valid pages
	std::uint32_t sizeOfSection;                     // Total virtual size of the section
	std::uint32_t pageOffset = 0;
	std::size_t pageIndex;

	// If the virtual size of a section is zero, take the size of raw data
	virtualSize = (virtualSize == 0) ? sizeOfRawData : virtualSize;

	// Virtual size is aligned to PAGE_SIZE (not SectionAlignment!)
	// If SectionAlignment > PAGE_SIZE, header and sections are padded with invalid pages (PAGE_NOACCESS)
	// Sample: f73e66052c8b0a49d56ccadcecdf497c015b5ec6f6724e056f35b57b59afaf59
	virtualSize = AlignToSize(virtualSize, PELIB_PAGE_SIZE);

	// If SizeOfRawData is greater than VirtualSize, cut it to virtual size
	// Note that up to the aligned virtual size, the data are in the section
	if(sizeOfRawData > virtualSize)
		sizeOfRawData = virtualSize;

	// If SectionAlignment is greater than page size, then there are going to be
	// gaps of inaccessible memory after the end of raw data
	// Example: b811f2c047a3e828517c234bd4aa4883e1ec591d88fad21289ae68a6915a6665
	// * has 0x1000 bytes of inaccessible memory at ImageBase+0x1000 (1 page after section header)
	sizeOfInitializedPages = AlignToSize(sizeOfRawData, PELIB_PAGE_SIZE);
	sizeOfValidPages = AlignToSize(virtualSize, PELIB_PAGE_SIZE);
	sizeOfSection = AlignToSize(virtualSize, optionalHeader.SectionAlignment);

	// Get the range of the file containing valid data (aka nonzeros)
	// Pointer to raw data is aligned down to the sector size
	// due to the Windows Loader logic that sets sector offset in the page table entries
	rawDataPtr = fileBegin + (pointerToRawData & ~(PELIB_SECTOR_SIZE - 1));
	rawDataEnd = rawDataPtr + sizeOfRawData;

	// End of raw data is aligned to the file alignment. This does not apply to image header
	// Sample: ab0a9c4a8beee49a13cbf6c684b58f9604d673c9d5522a73ec5dffda909695a1
	// SizeOfHeaders = 0x400, FileAlignment = 0x1000. Only 0x400 bytes is copied to the image
	if(isImageHeader == false)
		rawDataEnd = fileBegin + AlignToSize(pointerToRawData + sizeOfRawData, optionalHeader.FileAlignment);

	// Virtual address must begin exactly at the end of previous VA
	pageIndex = virtualAddress / PELIB_PAGE_SIZE;

	// Some combination of flags in IMAGE_SECTION_HEADER::Characteristics give PAGE_NOACCESS
	// If the image is mapped with SEC_IMAGE_NO_EXECUTE (Windows 10),
	// some of the NOACCESS sections turn into READONLY sections.
	if(getImageProtection(characteristics) != PELIB_PAGE_NOACCESS)
	{
		// If the pointerToRawData is less than SECTOR_SIZE, it will contain file header in it.
		// However, if the pointerToRawData contains 0, then the
		if(pointerToRawData || isImageHeader)
		{
			// Fill all pages that contain data
			while(pageOffset < sizeOfInitializedPages)
			{
				PELIB_FILE_PAGE & filePage = pages[pageIndex++];

				// Only if we didn't get out of the file
				if(rawDataPtr < fileEnd)
				{
					std::size_t bytesToCopy = PELIB_PAGE_SIZE;

					// Check range validity
					if((rawDataPtr + bytesToCopy) > fileEnd)
						bytesToCopy = (fileEnd - rawDataPtr);
					if((rawDataPtr + bytesToCopy) > rawDataEnd)
						bytesToCopy = (rawDataEnd - rawDataPtr);

					// Initialize the page with valid data
					filePage.setValidPage(rawDataPtr, bytesToCopy);
				}
				else
				{
					filePage.setZeroPage();
				}

				// Move pointers
				rawDataPtr += PELIB_PAGE_SIZE;
				pageOffset += PELIB_PAGE_SIZE;
			}
		}

		// Fill all pages that contain zeroed pages
		while(pageOffset < sizeOfValidPages)
		{
			PELIB_FILE_PAGE & filePage = pages[pageIndex++];

			filePage.setZeroPage();
			pageOffset += PELIB_PAGE_SIZE;
		}
	}

	// Leave all other pages filled with zeros
	return virtualAddress + sizeOfSection;
}

bool PeLib::ImageLoader::isGoodPagePointer(
	PFN_VERIFY_ADDRESS PfnVerifyAddress,
	void * pagePtr)
{
	// If the caller didn't supply a verification procedure, use default one
	// The verification procedure can possibly be system-specific, like IsBadReadPtr on Windows
	if(PfnVerifyAddress == nullptr)
	{
		// In order to work in Windows, it must be built with /EHa
		// (Enable C++ Exceptions: Yes with SEH Exceptions (/EHa))
		try
		{
			std::uint8_t dummyBuffer[0x10] = {0};
			memcmp(pagePtr, dummyBuffer, sizeof(dummyBuffer));
			return true;
		}
		catch(...)
		{
			return false;
		}
	}
	else
	{
		return PfnVerifyAddress(pagePtr, PELIB_PAGE_SIZE);
	}
}

bool PeLib::ImageLoader::isGoodMappedPage(std::uint32_t rva)
{
	std::uint32_t pageIndex = (rva / PELIB_PAGE_SIZE);

	return (pageIndex < pages.size()) ? !pages[pageIndex].isInvalidPage : false;
}

bool PeLib::ImageLoader::isZeroPage(std::uint32_t rva)
{
	std::uint32_t pageIndex = (rva / PELIB_PAGE_SIZE);

	return (pageIndex < pages.size()) ? pages[pageIndex].isZeroPage : false;
}

bool PeLib::ImageLoader::isSectionHeaderPointerToRawData(std::uint32_t fileOffset)
{
	std::uint32_t fileOffsetToSectionHeader = dosHeader.e_lfanew + sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;
	std::uint32_t fileOffsetOfPointerToRawData;

	// If there is at least one section
	for(std::size_t i = 0; i < sections.size(); i++, fileOffsetToSectionHeader += sizeof(PELIB_IMAGE_SECTION_HEADER))
	{
		// Get the reference to the section header
		PELIB_IMAGE_SECTION_HEADER & sectHdr = sections[i];

		// Must be a section with SizeOfRawData = 0
		if(sectHdr.SizeOfRawData == 0)
		{
			// Calculate the RVA of the PointerToRawData variable in the last section
			fileOffsetOfPointerToRawData = fileOffsetToSectionHeader + 0x14;  // FIELD_OFFSET(PELIB_IMAGE_SECTION_HEADER, PointerToRawData)

			if(fileOffsetOfPointerToRawData <= fileOffset && fileOffset < fileOffsetOfPointerToRawData + sizeof(std::uint32_t))
				return true;
		}
	}

	return false;
}

// MiIsLegacyImageArchitecture from Windows 10
bool PeLib::ImageLoader::isLegacyImageArchitecture(std::uint16_t Machine)
{
	if(Machine == PELIB_IMAGE_FILE_MACHINE_I386)
		return true;
	if(Machine == PELIB_IMAGE_FILE_MACHINE_AMD64)
		return true;
	return false;
}

bool PeLib::ImageLoader::checkForValid64BitMachine()
{
	if(loadItaniumImages && fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_IA64)
		return true;
	if(loadArm64Images && fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_ARM64)
		return true;
	return (fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_AMD64);
}

bool PeLib::ImageLoader::checkForValid32BitMachine()
{
	if(loadArmImages && fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_ARMNT)
		return true;
	return (fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_I386);
}

bool PeLib::ImageLoader::isValidMachineForCodeIntegrifyCheck(std::uint32_t Bits)
{
	if(Bits & 64)
	{
		// AMD64 is always allowed
		if(fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_AMD64)
			return true;

		// Returns STATUS_INVALID_IMAGE_FORMAT due to page size being 0x2000
		if(fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_IA64)
			return true;

		if(fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_ARM64)
			return true;
	}

	if(Bits & 32)
	{
		// Any of these is allowed
		if(fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_I386 || fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_ARM)
			return true;

		// Since Windows 8, IMAGE_FILE_MACHINE_ARMNT is alowed here as well
		if(loadArmImages && fileHeader.Machine == PELIB_IMAGE_FILE_MACHINE_ARMNT)
			return true;
	}

	return false;
}

// Windows Vista+: If IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY is set,
// there are some more checks implemented by CI!HashpParsePEHeader
// (nt!SeValidateImageHeader -> CI!CiValidateImageHeader -> ... -> CI!HashpParsePEHeader in Win7)
// This function does the same checks like CI!HashpParsePEHeader
bool PeLib::ImageLoader::checkForBadCodeIntegrityImages(ByteBuffer & fileData)
{
	if(optionalHeader.DllCharacteristics & PELIB_IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY)
	{
		PELIB_IMAGE_DATA_DIRECTORY & SecurityDir = optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY];
		std::uint32_t sizeOfNtHeaders = sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + sizeof(PELIB_IMAGE_OPTIONAL_HEADER32);
		std::uint32_t endOfRawData;
		std::size_t peFileSize = fileData.size();

		if(dosHeader.e_lfanew < sizeof(PELIB_IMAGE_DOS_HEADER))
			return true;
		if(dosHeader.e_lfanew > optionalHeader.SectionAlignment)
			return true;
		if((optionalHeader.SectionAlignment - dosHeader.e_lfanew) <= dosHeader.e_lfanew)
			return true;
		if((dosHeader.e_lfanew + sizeOfNtHeaders) > optionalHeader.SectionAlignment)
			return true;

		if(ntSignature != PELIB_IMAGE_NT_SIGNATURE)
			return true;
		if(fileHeader.SizeOfOptionalHeader == 0)
			return true;

		if(!isValidMachineForCodeIntegrifyCheck(32 | 64))
			return true;

		if(optionalHeader.MajorLinkerVersion < 3 && optionalHeader.MajorLinkerVersion < 5)
			return true;
		if(optionalHeader.Magic != PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC && optionalHeader.Magic != PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
			return true;

		// Check whether there is match between bitness of the optional header and machine
		if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC && !isValidMachineForCodeIntegrifyCheck(32))
			return true;
		if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC && !isValidMachineForCodeIntegrifyCheck(64))
			return true;

		if(optionalHeader.SizeOfHeaders == 0 || optionalHeader.SizeOfHeaders > peFileSize)
			return true;
		if(optionalHeader.FileAlignment == 0 || (optionalHeader.FileAlignment & (optionalHeader.FileAlignment - 1)))
			return true;
		if(optionalHeader.SectionAlignment & (optionalHeader.SectionAlignment - 1))
			return true;
		if(optionalHeader.FileAlignment > optionalHeader.SectionAlignment)
			return true;
		if((optionalHeader.FileAlignment & (PELIB_SECTOR_SIZE - 1)) && (optionalHeader.FileAlignment != optionalHeader.SectionAlignment))
			return true;

		// End of headers altogether must fit in the first page
		endOfRawData = dosHeader.e_lfanew + sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;
		endOfRawData += (fileHeader.NumberOfSections * sizeof(PELIB_IMAGE_SECTION_HEADER));
		if(endOfRawData >= PELIB_PAGE_SIZE)
			return true;

		for(auto & section : sections)
		{
			// Windows's ci!CipImageGetImageHash wants start of any section past SizeOfHeaders
			// TODO: This check doesn't seem to hapeen for 32-bit images. Need confirm/deny this
			// Sample: 0E2EEAC29F7BAD81C67F0283541A050FAED973C114F46CF5F270355623A7BA8A
			if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
			{
				if(section.PointerToRawData && section.SizeOfRawData && section.PointerToRawData < optionalHeader.SizeOfHeaders)
				{
					return true;
				}
			}

			if(section.PointerToRawData != 0 && section.PointerToRawData < endOfRawData)
				return true;
			if((section.PointerToRawData + section.SizeOfRawData) < section.PointerToRawData)
				return true;
			if((section.PointerToRawData + section.SizeOfRawData) > peFileSize)
				return true;
			if((section.VirtualAddress + section.SizeOfRawData - 1) < section.SizeOfRawData)
				return true;

			if(section.SizeOfRawData != 0 && (section.PointerToRawData + section.SizeOfRawData) > endOfRawData)
				endOfRawData = (section.PointerToRawData + section.SizeOfRawData);
		}

		// Verify the position and range of the digital signature
		if(SecurityDir.VirtualAddress && SecurityDir.Size)
		{
			if(SecurityDir.VirtualAddress < endOfRawData || SecurityDir.VirtualAddress > peFileSize)
				return true;
			if((SecurityDir.VirtualAddress + SecurityDir.Size) != peFileSize)
				return true;
			if((SecurityDir.VirtualAddress + SecurityDir.Size) < endOfRawData)
				return true;
			if(SecurityDir.VirtualAddress < optionalHeader.SizeOfHeaders)
				return true;
			if(SecurityDir.VirtualAddress & 0x03)
				return true;
		}

		// Windows 8+ fails to load the image if the certificate is zeroed
		// We don't want to parse and verify the certificate here,
		// just check for the most blatantly corrupt certificates
		if(forceIntegrityCheckCertificate)
		{
			std::uint8_t * certPtr = fileData.data() + SecurityDir.VirtualAddress;
			if(SecurityDir.Size > 2 && certPtr[0] == 0 && certPtr[1] == 0)
				return true;
		}
	}

	// All checks passed.
	return false;
}

// Windows 10: For IMAGE_FILE_MACHINE_I386 and IMAGE_FILE_MACHINE_AMD64,
// if(Characteristics & IMAGE_FILE_RELOCS_STRIPPED) and (DllCharacteristics & IMAGE_DLLCHARACTERISTICS_APPCONTAINER),
// MiRelocateImage returns STATUS_INVALID_IMAGE_FORMAT.
bool PeLib::ImageLoader::checkForBadArchitectureSpecific()
{
	// In Windows 10, this check is only performed on "legacy" images
	// (IMAGE_FILE_MACHINE_I386 or IMAGE_FILE_MACHINE_AMD64)
	// Performed by nt!MiRelocateImage -> nt!MiLegacyImageArchitecture
	if(isLegacyImageArchitecture(fileHeader.Machine))
	{
		// If the image has stripped relocations, it can't be an app container
		if((fileHeader.Characteristics & PELIB_IMAGE_FILE_RELOCS_STRIPPED) == 0)
		{
			if(optionalHeader.DllCharacteristics & PELIB_IMAGE_DLLCHARACTERISTICS_APPCONTAINER)
			{
				return true;
			}
		}
	}
	else
	{
		if(checkNonLegacyDllCharacteristics)
		{
			// Check images that do NOT have stripped relocations
			if((fileHeader.Characteristics & PELIB_IMAGE_FILE_RELOCS_STRIPPED) == 0)
			{
				#define MUST_HAVE_FLAGS (PELIB_IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE | PELIB_IMAGE_DLLCHARACTERISTICS_NX_COMPAT)

				if((optionalHeader.DllCharacteristics & MUST_HAVE_FLAGS) != MUST_HAVE_FLAGS)
				{
					return true;
				}
			}
		}
	}

	return false;
}

template <typename LOAD_CONFIG>
bool PeLib::ImageLoader::checkForBadLoadConfigXX(std::uint32_t loadConfigRva, std::uint32_t loadConfigSize)
{
	LOAD_CONFIG LoadConfig = {0};

	// Don't overflow the read
	if(loadConfigSize > sizeof(LOAD_CONFIG))
		loadConfigSize = sizeof(LOAD_CONFIG);

	// Load the load config directory
	if(readImage(&LoadConfig, loadConfigRva, loadConfigSize) == loadConfigSize)
	{
		if(LoadConfig.DynamicValueRelocTableSection >= fileHeader.NumberOfSections)
			return true;

		if(LoadConfig.GuardCFFunctionTable > 0)
		{
			if(LoadConfig.GuardCFFunctionTable < optionalHeader.ImageBase)
				return true;
			if(LoadConfig.GuardCFFunctionCount == 0)
				return true;
		}
	}

	// The load config is OK
	return false;
}

bool PeLib::ImageLoader::checkForImageAfterMapping()
{
	std::uint32_t loadConfigRva = optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
	std::uint32_t loadConfigSize = optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size;

	// Perform the checks of IMAGE_LOAD_CONFIG_DIRECTORY
	// Performed by nt!MiRelocateImage -> nt!MiParseImageLoadConfig, only in case
	// when IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE in IMAGE_OPTIONAL_HEADER::DllCharacteristics is set
	if(optionalHeader.DllCharacteristics & PELIB_IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)
	{
		if(loadConfigRva && loadConfigSize)
		{
			if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC)
			{
				if(checkForBadLoadConfigXX<PELIB_IMAGE_LOAD_CONFIG_DIRECTORY32>(loadConfigRva, loadConfigSize))
					return true;
			}

			if(optionalHeader.Magic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
			{
				if(checkForBadLoadConfigXX<PELIB_IMAGE_LOAD_CONFIG_DIRECTORY64>(loadConfigRva, loadConfigSize))
					return true;
			}
		}
	}

	// Perform extra checks of relocations (performed by nt!MiRelocateImage)
	// Image loading will fail if the architecture is not intel and relocations are screwed
	if(!isLegacyImageArchitecture(fileHeader.Machine))
	{
		PELIB_IMAGE_BASE_RELOCATION BaseReloc;
		std::uint32_t baseRelocRVA = optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
		std::uint32_t baseRelocSize = optionalHeader.DataDirectory[PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

		if(baseRelocRVA && baseRelocSize > sizeof(PELIB_IMAGE_BASE_RELOCATION))
		{
			if(readImage(&BaseReloc, baseRelocRVA, sizeof(PELIB_IMAGE_BASE_RELOCATION)) == sizeof(PELIB_IMAGE_BASE_RELOCATION))
			{
				if(baseRelocSize >= sizeof(PELIB_IMAGE_BASE_RELOCATION) + sizeof(std::uint16_t))
				{
					if(BaseReloc.SizeOfBlock > baseRelocSize)
						return true;
					if(BaseReloc.SizeOfBlock & 0x01)
						return true;
					if(BaseReloc.SizeOfBlock < sizeof(PELIB_IMAGE_BASE_RELOCATION))
						return true;
				}
				else
				{
					if(baseRelocSize != sizeof(PELIB_IMAGE_BASE_RELOCATION))
					{
						return true;
					}
				}

			}
		}
	}

	return false;
}

// Weirdly incorrect check performed by Windows XP's MiCreateImageFileMap.
bool PeLib::ImageLoader::checkForSectionTablesWithinHeader(std::uint32_t e_lfanew)
{
	std::uint32_t OffsetToSectionTable = sizeof(std::uint32_t) + sizeof(PELIB_IMAGE_FILE_HEADER) + fileHeader.SizeOfOptionalHeader;
	std::uint32_t NumberOfSubsections = fileHeader.NumberOfSections;
	std::uint32_t NtHeaderSize;

	// Sample: retdec-regression-tests\features\corkami\inputs\96emptysections.ex
	// Must count with more pages if the header size is greater than one page
	NtHeaderSize = AlignToSize(optionalHeader.SizeOfHeaders, PELIB_PAGE_SIZE) - e_lfanew;

	// If this condition is true, then the image header contains data up to SizeofHeaders
	// If not, the image header contains the entire page.
	if((e_lfanew + OffsetToSectionTable + (NumberOfSubsections + 1) * sizeof(PELIB_IMAGE_SECTION_HEADER)) <= NtHeaderSize)
		return false;

	return true;
}

// Returns true if the image is OK and can be mapped by NtCreateSection(SEC_IMAGE).
// This does NOT mean that the image is executable by CreateProcess - more checks are done,
// like resource integrity or relocation table correctness.
bool PeLib::ImageLoader::isImageLoadable() const
{
	return (ldrError == LDR_ERROR_NONE || ldrError == LDR_ERROR_FILE_IS_CUT_LOADABLE);
}

bool PeLib::ImageLoader::isImageMappedOk() const
{
	// If there was loader error, we didn't map the image
	if(!isImageLoadable())
		return false;
	if(pages.size() == 0)
		return false;
	return true;
}

bool PeLib::ImageLoader::isValidImageBlock(std::uint32_t Rva, std::uint32_t Size) const
{
	if(Rva >= optionalHeader.SizeOfImage || Size >= optionalHeader.SizeOfImage)
		return false;
	if((Rva + Size) < Rva)
		return false;
	if((Rva + Size) > optionalHeader.SizeOfImage)
		return false;
	return true;
}

//-----------------------------------------------------------------------------
// Testing functions

std::size_t PeLib::ImageLoader::getMismatchOffset(
	void * buffer1,
	void * buffer2,
	std::uint32_t rva,
	std::size_t length)
{
	std::uint8_t * byteBuffer1 = reinterpret_cast<std::uint8_t *>(buffer1);
	std::uint8_t * byteBuffer2 = reinterpret_cast<std::uint8_t *>(buffer2);
	std::uint32_t fileOffset = getFileOffsetFromRva(rva);

	for(std::size_t i = 0; i < length; i++)
	{
		if(byteBuffer1[i] != byteBuffer2[i])
		{
			// Windows loader puts 0 in IMAGE_SECTION_HEADER::PointerToRawData if IMAGE_SECTION_HEADER::SizeOfRawData is also zero.
			// However, this is somewhat random - depends on current memory condition, often dissappears
			// when the sample is copied to another location.
			if(isSectionHeaderPointerToRawData(fileOffset + i))
				continue;

			// If under debugger, Microsoft Visual Studio may place a breakpoint
			// at the beginning of __crt_debugger_hook. Ignore such differences
			if(byteBuffer1[i] == 0xCC)
				continue;

			//for(int j = i & 0xFFFFFFF0; j < 0xD00; j++)
			//	printf("byteBuffer1[j]: %02x, byteBuffer2[j]: %02x\n", byteBuffer1[j], byteBuffer2[j]);
			return i;
		}
	}

	return (std::size_t)(-1);
}

void PeLib::ImageLoader::compareWithWindowsMappedImage(
	PELIB_IMAGE_COMPARE & ImageCompare,
	void * imageDataPtr,
	std::uint32_t imageSize)
{
	std::uint8_t * winImageData = reinterpret_cast<std::uint8_t *>(imageDataPtr);
	std::uint8_t * winImageEnd = winImageData + imageSize;
	std::uint8_t singlePage[PELIB_PAGE_SIZE];
	std::size_t mismatchOffset;
	std::size_t rva = 0;

	// Check if the image was loaded by both Windows and us
	// Note that in Windows 7, the image can actually be mapped at base address 0
	// Sample: retdec-regression-tests\features\corkami\inputs\ibnullXP.ex 
	if((winImageData || imageSize) && isImageMappedOk())
	{
		// Check whether the image size is the same
		if(imageSize != getSizeOfImageAligned())
		{
			ImageCompare.compareResult = PELIB_COMPARE_RESULT::ImagesDifferentSize;
			ImageCompare.differenceOffset = 0;
			return;
		}

		// Images with extreme value of SizeOfImage take very long time
		// (even hours) to compare under older Windows (7 or older). We skip them
		//if(imageSize & 0xF0000000)
		//{
		//	ImageCompare.compareResult = PELIB_COMPARE_RESULT::ImagesEqual;
		//	ImageCompare.differenceOffset = 0;
		//	return;
		//}

		// Compare images page-by-page
		while(winImageData < winImageEnd)
		{
			// If the windows page is inaccessible, our page must be inaccessible as well
			bool isGoodPageWin = isGoodPagePointer(ImageCompare.PfnVerifyAddress, winImageData);
			bool isGoodPageMy  = isGoodMappedPage(rva);

			// If we have a compare callback, call it
			if(ImageCompare.PfnCompareCallback != nullptr)
			{
				ImageCompare.PfnCompareCallback(&ImageCompare, rva, imageSize);
			}

			// Both are accessible -> Compare the page
			if(isGoodPageWin && isGoodPageMy)
			{
				// Read the image page
				readImage(singlePage, rva, sizeof(singlePage));

				// Windows: Under low memory condition and heavy load, there may be STATUS_IN_PAGE_ERROR
				// exception thrown when touching the mapped image. For that reason,
				// this function must be framed by __try/__except in caller
				if(memcmp(winImageData, singlePage, PELIB_PAGE_SIZE))
				{
					mismatchOffset = getMismatchOffset(winImageData, singlePage, rva, PELIB_PAGE_SIZE);
					if(mismatchOffset != (std::size_t)(-1))
					{
						ImageCompare.compareResult = PELIB_COMPARE_RESULT::ImagesDifferentPageValue;
						ImageCompare.differenceOffset = rva + mismatchOffset;
						return;
					}
				}
			}
			else
			{
				// Accessible vs inacessible?
				if(isGoodPageWin != isGoodPageMy)
				{
					ImageCompare.compareResult = PELIB_COMPARE_RESULT::ImagesDifferentPageAccess;
					ImageCompare.differenceOffset = rva;
					return;
				}
			}

			// Move pointers
			winImageData += PELIB_PAGE_SIZE;
			rva += PELIB_PAGE_SIZE;
		}
	}

	// Check whether both we and Windows mapped the image OK
	if(isImageMappedOk())
	{
		// Windows didn't map the image
		if(winImageData == nullptr)
		{
			ImageCompare.compareResult = PELIB_COMPARE_RESULT::ImagesWindowsDidntLoadWeDid;
			return;
		}
	}
	else
	{
		// Windows mapped the image
		if(winImageData != nullptr)
		{
			ImageCompare.compareResult = PELIB_COMPARE_RESULT::ImagesWindowsLoadedWeDidnt;
			return;
		}
	}

	// Both Windows and our image are the same
	ImageCompare.compareResult = PELIB_COMPARE_RESULT::ImagesEqual;
	ImageCompare.differenceOffset = 0;
}

```

`debug_remover/src/pelib/InputBuffer.cpp`:

```cpp
/*
* InputBuffer.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/InputBuffer.h"

namespace PeLib
{
	InputBuffer::InputBuffer(std::vector<unsigned char>& vBuffer) : m_vBuffer(vBuffer), ulIndex(0)
	{
	}

	const unsigned char* InputBuffer::data() const
	{
		return m_vBuffer.data();
	}

	unsigned long InputBuffer::size()
	{
		return static_cast<unsigned long>(m_vBuffer.size());
	}

	void InputBuffer::read(char* lpBuffer, unsigned long ulSize)
	{
		if (ulIndex >= m_vBuffer.size())
			return;

		ulSize = (unsigned long)(ulIndex + ulSize > m_vBuffer.size() ? m_vBuffer.size() - ulIndex : ulSize);

		std::copy(m_vBuffer.data() + ulIndex, m_vBuffer.data() + ulIndex + ulSize, lpBuffer);
		ulIndex += ulSize;
	}

	void InputBuffer::reset()
	{
		m_vBuffer.clear();
	}

	void InputBuffer::set(unsigned long ulIndex2)
	{
		this->ulIndex = ulIndex2;
	}

	void InputBuffer::move(unsigned long shift)
	{
		ulIndex += shift;
	}

	unsigned long InputBuffer::get()
	{
		return ulIndex;
	}

	void InputBuffer::setBuffer(std::vector<unsigned char>& vBuffer)
	{
		m_vBuffer = vBuffer;
		ulIndex = 0;
	}
}

```

`debug_remover/src/pelib/OutputBuffer.cpp`:

```cpp
/*
* OutputBuffer.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/OutputBuffer.h"

namespace PeLib
{
	OutputBuffer::OutputBuffer(std::vector<unsigned char>& vBuffer) : m_vBuffer(vBuffer)
	{
		m_vBuffer.clear();
	}

	const unsigned char* OutputBuffer::data() const
	{
		return m_vBuffer.data();
	}

	unsigned long OutputBuffer::size()
	{
		return static_cast<unsigned long>(m_vBuffer.size());
	}

	void OutputBuffer::add(const char* lpBuffer, unsigned long ulSize)
	{
		std::copy(lpBuffer, lpBuffer + ulSize, std::back_inserter(m_vBuffer));
	}

	void OutputBuffer::reset()
	{
		m_vBuffer.clear();
	}

	void OutputBuffer::resize(unsigned int uiSize)
	{
		m_vBuffer.resize(uiSize);
	}
}

```

`debug_remover/src/pelib/PeFile.cpp`:

```cpp
/*
* PeLib.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/PeFile.h"

namespace PeLib
{
	PeFileT::PeFileT(const std::string& strFileName) : m_iStream(m_ifStream)
	{
		setFileName(strFileName);
	}

	PeFileT::PeFileT(std::istream& stream) : m_iStream(stream)
	{}

	PeFileT::PeFileT() : m_iStream(m_ifStream)
	{}

	PeFile::~PeFile()
	{}

	int PeFileT::loadPeHeaders(bool loadHeadersOnly)
	{
		return m_imageLoader.Load(m_iStream, loadHeadersOnly);
	}

	int PeFileT::loadPeHeaders(ByteBuffer & fileData, bool loadHeadersOnly)
	{
		return m_imageLoader.Load(fileData, loadHeadersOnly);
	}

	/// returns PEFILE64 or PEFILE32
	int PeFileT::getFileType() const
	{
		std::uint16_t machine = m_imageLoader.getMachine();
		std::uint16_t magic = m_imageLoader.getMagic();

		if((machine == PELIB_IMAGE_FILE_MACHINE_AMD64 || machine == PELIB_IMAGE_FILE_MACHINE_IA64) && magic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		{
			return PEFILE64;
		}

		if(machine == PELIB_IMAGE_FILE_MACHINE_I386 && magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC)
		{
			return PEFILE32;
		}

		return PEFILE_UNKNOWN;
	}

	/**
	* @return A reference to the file's image loader.
	**/

	const ImageLoader & PeFile::imageLoader() const
	{
		return m_imageLoader;
	}

	/**
	* @return A reference to the file's image loader.
	**/

	ImageLoader & PeFile::imageLoader()
	{
		return m_imageLoader;
	}

	const RichHeader& PeFile::richHeader() const
	{
		return m_richheader;
	}

	RichHeader& PeFile::richHeader()
	{
		return m_richheader;
	}

	const CoffSymbolTable& PeFile::coffSymTab() const
	{
		return m_coffsymtab;
	}

	CoffSymbolTable& PeFile::coffSymTab()
	{
		return m_coffsymtab;
	}

	const SecurityDirectory& PeFile::securityDir() const
	{
		return m_secdir;
	}

	SecurityDirectory& PeFile::securityDir()
	{
		return m_secdir;
	}

	/**
	* @return A reference to the file's import directory.
	**/
	const ImportDirectory & PeFileT::impDir() const
	{
		return m_impdir;
	}

	/**
	* @return A reference to the file's import directory.
	**/
	ImportDirectory & PeFileT::impDir()
	{
		return m_impdir;
	}

	const TlsDirectory & PeFileT::tlsDir() const
	{
		return m_tlsdir;
	}

	TlsDirectory & PeFileT::tlsDir()
	{
		return m_tlsdir;
	}

	const ConfigDirectory& PeFileT::configDir() const
	{
		return m_configdir;
	}

	ConfigDirectory& PeFileT::configDir()
	{
		return m_configdir;
	}

	/**
	* @return A reference to the file's delay import directory.
	**/
	const DelayImportDirectory & PeFileT::delayImports() const
	{
		return m_delayimpdir;
	}

	/**
	* @return A reference to the file's delay import directory.
	**/
	DelayImportDirectory & PeFileT::delayImports()
	{
		return m_delayimpdir;
	}

	/**
	* @return A reference to the file's export directory.
	**/
	const ExportDirectory & PeFileT::expDir() const
	{
		return m_expdir;
	}

	/**
	* @return A reference to the file's export directory.
	**/
	ExportDirectory & PeFileT::expDir()
	{
		return m_expdir;
	}

	/**
	* @return A reference to the file's bound import directory.
	**/
	const BoundImportDirectory & PeFileT::boundImpDir() const
	{
		return m_boundimpdir;
	}

	/**
	* @return A reference to the file's bound import directory.
	**/
	BoundImportDirectory & PeFileT::boundImpDir()
	{
		return m_boundimpdir;
	}

	/**
	* @return A reference to the file's resource directory.
	**/
	const ResourceDirectory & PeFileT::resDir() const
	{
		return m_resdir;
	}

	/**
	* @return A reference to the file's resource directory.
	**/
	ResourceDirectory & PeFileT::resDir()
	{
		return m_resdir;
	}

	/**
	* @return A reference to the file's relocations directory.
	**/
	const RelocationsDirectory & PeFileT::relocDir() const
	{
		return m_relocs;
	}

	/**
	* @return A reference to the file's relocations directory.
	**/
	RelocationsDirectory & PeFileT::relocDir()
	{
		return m_relocs;
	}

	/**
	* @return A reference to the file's COM+ descriptor directory.
	**/
	const ComHeaderDirectory & PeFileT::comDir() const
	{
		return m_comdesc;
	}

	/**
	* @return A reference to the file's COM+ descriptor directory.
	**/
	ComHeaderDirectory & PeFileT::comDir()
	{
		return m_comdesc;
	}

	const IatDirectory & PeFileT::iatDir() const
	{
		return m_iat;
	}

	IatDirectory & PeFileT::iatDir()
	{
		return m_iat;
	}

	const DebugDirectory & PeFileT::debugDir() const
	{
		return m_debugdir;
	}

	DebugDirectory & PeFileT::debugDir()
	{
		return m_debugdir;
	}

	/**
	* @return Filename of the current file.
	**/
	std::string PeFileT::getFileName() const
	{
		return m_filename;
	}

	/**
	* @param strFilename New filename.
	**/
	void PeFileT::setFileName(const std::string & strFilename)
	{
		m_filename = strFilename;
		if (m_ifStream.is_open())
		{
			m_ifStream.close();
		}
		m_ifStream.open(m_filename, std::ifstream::binary);
	}

	int PeFileT::readRichHeader(std::size_t offset, std::size_t size, bool ignoreInvalidKey)
	{
		return richHeader().read(m_iStream, offset, size, ignoreInvalidKey);
	}

	int PeFileT::readCoffSymbolTable(ByteBuffer & fileData)
	{
		if(m_imageLoader.getPointerToSymbolTable() && m_imageLoader.getNumberOfSymbols())
		{
			return coffSymTab().read(
				fileData,
				m_imageLoader.getPointerToSymbolTable(),
				m_imageLoader.getNumberOfSymbols() * PELIB_IMAGE_SIZEOF_COFF_SYMBOL);
		}
		return ERROR_COFF_SYMBOL_TABLE_DOES_NOT_EXIST;
	}

	int PeFileT::readExportDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT))
		{
			return expDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readImportDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_IMPORT))
		{
			return impDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readResourceDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE))
		{
			return resDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readSecurityDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY))
		{
			return securityDir().read(m_iStream,
									  m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY),
									  m_imageLoader.getDataDirSize(PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY));
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readRelocationsDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC))
		{
			return relocDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readDebugDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG))
		{
			return debugDir().read(m_iStream, m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readTlsDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_TLS))
		{
			return tlsDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readBoundImportDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT))
		{
			return boundImpDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readIatDirectory()
	{
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_IAT))
		{
			return iatDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readDelayImportDirectory()
	{
		// Note: Delay imports can have arbitrary size and Windows loader will still load them
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT))
		{
			return delayImports().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readComHeaderDirectory()
	{
		// Need to do this regardless of NumberOf
		if(m_imageLoader.getComDirRva() && m_imageLoader.getComDirSize())
		{
			return comDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	int PeFileT::readLoadConfigDirectory()
	{
		// Need to do this regardless of NumberOf
		if(m_imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG))
		{
			return configDir().read(m_imageLoader);
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	LoaderError PeFileT::checkEntryPointErrors() const
	{
		ImageLoader & imgLoader = const_cast<ImageLoader &>(m_imageLoader);
		std::uint32_t addressOfEntryPoint = m_imageLoader.getAddressOfEntryPoint();
		std::uint32_t sizeOfImage = m_imageLoader.getSizeOfImageAligned();

		if(addressOfEntryPoint >= sizeOfImage)
		{
			return LDR_ERROR_ENTRY_POINT_OUT_OF_IMAGE;
		}

		// Only check PE files compiled for i386 or x64 processors.
		if (m_imageLoader.getMachine() == PELIB_IMAGE_FILE_MACHINE_I386 || m_imageLoader.getMachine() == PELIB_IMAGE_FILE_MACHINE_AMD64)
		{
			// Only if there are no TLS callbacks
			if(m_tlsdir.getCallbacks().size() == 0)
			{
				std::uint64_t entryPointCode[2] = {0, 0};

				// Check if 16 bytes of code are available in the file
				if ((addressOfEntryPoint + sizeof(entryPointCode)) < sizeOfImage)
				{
					// Read the entry point code
					imgLoader.readImage(entryPointCode, addressOfEntryPoint, sizeof(entryPointCode));

					// Zeroed instructions at entry point map either to "add [eax], al" (i386) or "add [rax], al" (AMD64).
					// Neither of these instructions makes sense on the entry point. We check 16 bytes of the entry point,
					// in order to make sure it's really a corruption.
					if ((entryPointCode[0] | entryPointCode[1]) == 0)
					{
						return LDR_ERROR_ENTRY_POINT_ZEROED;
					}
				}
			}
		}

		return LDR_ERROR_NONE;
	}

	LoaderError PeFileT::checkForInMemoryLayout(LoaderError ldrError) const
	{
		std::uint64_t ulFileSize = fileSize(m_iStream);
		std::uint64_t sizeOfImage = m_imageLoader.getSizeOfImage();

		// The file size must be greater or equal to SizeOfImage
		if(ulFileSize >= sizeOfImage && m_imageLoader.getNumberOfSections() != 0)
		{
			std::uint32_t sectionAlignment = m_imageLoader.getSectionAlignment();
			std::uint32_t fileAlignment = m_imageLoader.getFileAlignment();
			std::uint32_t sizeOfHeaders = m_imageLoader.getSizeOfHeaders();

			// SectionAlignment must be greater than file alignment
			if(sectionAlignment >= PELIB_PAGE_SIZE && sectionAlignment > fileAlignment)
			{
				// SizeOfHeaders must be smaller than SectionAlignment
				if(sizeOfHeaders < sectionAlignment)
				{
					std::size_t headerDataSize = sectionAlignment - sizeOfHeaders;

					// Read the entire after-header-data
					ByteBuffer headerData(headerDataSize);
					m_iStream.seekg(sizeOfHeaders, std::ios::beg);
					m_iStream.read(reinterpret_cast<char *>(headerData.data()), headerDataSize);

					// Check whether there are zeros only. If yes, we consider
					// the file to be an in-memory image
					if(std::all_of(headerData.begin(), headerData.end(), [](char item) { return item == 0; }))
						ldrError = LDR_ERROR_INMEMORY_IMAGE;
				}
			}
		}

		return ldrError;
	}

	// Returns an error code indicating loader problem. We check every part of the PE file
	// for possible loader problem. If anything wrong was found, we report it
	LoaderError PeFileT::loaderError() const
	{
		// Check for problems in image loader
		LoaderError ldrError = imageLoader().loaderError();

		// Check the loader error
		if (ldrError == LDR_ERROR_NONE)
			ldrError = coffSymTab().loaderError();

		// Check errors in import directory
		if (ldrError == LDR_ERROR_NONE)
			ldrError = impDir().loaderError();

		// Check errors in resource directory
		if (ldrError == LDR_ERROR_NONE)
			ldrError = resDir().loaderError();

		// Check errors in relocations directory
		if (ldrError == LDR_ERROR_NONE)
			ldrError = relocDir().loaderError();

		// Check errors in security directory
		if (ldrError == LDR_ERROR_NONE)
			ldrError = securityDir().loaderError();

		// Check errors in entry point
		if (ldrError == LDR_ERROR_NONE)
			ldrError = checkEntryPointErrors();

		// If there was a loaded error, we'll check whether
		// the file can't actually be an in-memory version
		if(ldrError != LDR_ERROR_NONE)
			ldrError = checkForInMemoryLayout(ldrError);

		// Nothing wrond found
		return ldrError;
	}
}

```

`debug_remover/src/pelib/PeLibAux.cpp`:

```cpp
/*
* PeLibAux.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include <vector>

#ifdef _MSC_VER
  #include <ctype.h>
#endif

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/PeLibAux.h"
#include "retdec/pelib/PeFile.h"

namespace PeLib
{
	// Keep in sync with PeLib::LoaderError!!!
	static const std::vector<LoaderErrorInfo> LdrErrStrings =
	{
		{"LDR_ERROR_NONE",                         "No error"},
		{"LDR_ERROR_FILE_TOO_BIG",                 "The file is larger than 4GB - 1"},
		{"LDR_ERROR_E_LFANEW_UNALIGNED",           "The IMAGE_DOS_HEADER::e_lfanew is not aligned to 4"},
		{"LDR_ERROR_E_LFANEW_OUT_OF_FILE",         "The IMAGE_DOS_HEADER::e_lfanew is out of (lower 4 GB of) the file"},
		{"LDR_ERROR_NTHEADER_OFFSET_OVERFLOW",     "NT header offset + sizeof(IMAGE_NT_HEADERS) overflow"},
		{"LDR_ERROR_NTHEADER_OUT_OF_FILE",         "NT header offset + sizeof(IMAGE_NT_HEADERS) is greater than filesize"},
		{"LDR_ERROR_NO_NT_SIGNATURE",              "Missing IMAGE_NT_SIGNATURE in the NT headers" },
		{"LDR_ERROR_FILE_HEADER_INVALID",          "Invalid IMAGE_FILE_HEADER::Machine or IMAGE_FILE_HEADER::SizeOfOptionalHeader" },
		{"LDR_ERROR_IMAGE_NON_EXECUTABLE",         "Missing IMAGE_FILE_EXECUTABLE_IMAGE in IMAGE_FILE_HEADER::Characteristics" },
		{"LDR_ERROR_NO_OPTHDR_MAGIC",              "Invalid IMAGE_OPTIONAL_HEADER::Magic" },
		{"LDR_ERROR_SIZE_OF_HEADERS_ZERO",         "IMAGE_OPTIONAL_HEADER::SizeOfHeaders is zero" },
		{"LDR_ERROR_FILE_ALIGNMENT_ZERO",          "IMAGE_OPTIONAL_HEADER::FileAlignment is zero" },
		{"LDR_ERROR_FILE_ALIGNMENT_NOT_POW2",      "IMAGE_OPTIONAL_HEADER::FileAlignment is not power of two" },
		{"LDR_ERROR_SECTION_ALIGNMENT_ZERO",       "IMAGE_OPTIONAL_HEADER::SectionAlignment is zero" },
		{"LDR_ERROR_SECTION_ALIGNMENT_NOT_POW2",   "IMAGE_OPTIONAL_HEADER::SectionAlignment is not power of two" },
		{"LDR_ERROR_SECTION_ALIGNMENT_TOO_SMALL",  "IMAGE_OPTIONAL_HEADER::SectionAlignment is smaller than IMAGE_OPTIONAL_HEADER::FileAlignment" },
		{"LDR_ERROR_SECTION_ALIGNMENT_INVALID",    "IMAGE_OPTIONAL_HEADER::SectionAlignment must be equal to FileAlignment for small alignments" },
		{"LDR_ERROR_SIZE_OF_IMAGE_TOO_BIG",        "IMAGE_OPTIONAL_HEADER::SizeOfImage is too big" },
		{"LDR_ERROR_INVALID_MACHINE32",            "IMAGE_FILE_HEADER::Machine is invalid for 32-bit optional header" },
		{"LDR_ERROR_INVALID_MACHINE64",            "IMAGE_FILE_HEADER::Machine is invalid for 64-bit optional header" },
		{"LDR_ERROR_SIZE_OF_HEADERS_INVALID",      "IMAGE_OPTIONAL_HEADER::SizeOfHeaders is greater than IMAGE_OPTIONAL_HEADER::SizeOfImage" },
		{"LDR_ERROR_SIZE_OF_OPTHDR_NOT_ALIGNED",   "IMAGE_OPTIONAL_HEADER::SizeOfHeaders is not aligned to 8 (64-bit Windows only)" },
		{"LDR_ERROR_SIZE_OF_IMAGE_ZERO",           "Number of PTEs for the entire image is zero" },
		{"LDR_ERROR_IMAGE_BASE_NOT_ALIGNED",       "IMAGE_OPTIONAL_HEADER::ImageBase is not aligned to 64KB" },
		{"LDR_ERROR_SIZE_OF_IMAGE_PTES_ZERO",      "Number of Page Table Entries for the image is zero" },
		{"LDR_ERROR_RAW_DATA_OVERFLOW",            "Overflow in section's raw data size" },
		{"LDR_ERROR_SECTION_HEADERS_OUT_OF_IMAGE", "Section headers are out of the image" },
		{"LDR_ERROR_SECTION_HEADERS_OVERFLOW",     "Image with single subsection: size of headers is near the end of range" },
		{"LDR_ERROR_SECTION_SIZE_MISMATCH",        "Image with single subsection: virtual values with rawdata values don't match" },
		{"LDR_ERROR_INVALID_SECTION_VA",           "Invalid virtual address of a section" },
		{"LDR_ERROR_INVALID_SECTION_VSIZE",        "Invalid virtual size of a section" },
		{"LDR_ERROR_INVALID_SECTION_RAWSIZE",      "Invalid raw data size of a section" },
		{"LDR_ERROR_INVALID_SIZE_OF_IMAGE",        "IMAGE_OPTIONAL_HEADER::SizeOfImage doesn't match the (header+sections)" },
		{"LDR_ERROR_FILE_IS_CUT",                  "The PE file is cut" },
		{"LDR_ERROR_FILE_IS_CUT_LOADABLE",         "The PE file is cut, but loadable", true},

		// Import directory detected errors
		{"LDR_ERROR_IMPDIR_OUT_OF_FILE",           "Offset of the import directory is out of the file", true },
		{"LDR_ERROR_IMPDIR_CUT",                   "Import directory is cut", true },
		{"LDR_ERROR_IMPDIR_COUNT_EXCEEDED",        "Number of import descriptors exceeds maximum", true },
		{"LDR_ERROR_IMPDIR_NAME_RVA_INVALID",      "RVA of the import name is invalid", true },
		{"LDR_ERROR_IMPDIR_THUNK_RVA_INVALID",     "RVA of the import thunk is invalid", true },
		{"LDR_ERROR_IMPDIR_IMPORT_COUNT_EXCEEDED", "Number of imported functions exceeds maximum", true },

		// Resource directory detected errors
		{"LDR_ERROR_RSRC_OVER_END_OF_IMAGE",       "Array of resource directory entries goes beyond end of the image", true },
		{"LDR_ERROR_RSRC_NAME_OUT_OF_IMAGE",       "One of the resource names points out of the image", true },
		{"LDR_ERROR_RSRC_DATA_OUT_OF_IMAGE",       "One of the resource data points out of the image", true },
		{"LDR_ERROR_RSRC_SUBDIR_OUT_OF_IMAGE",     "One of the resource subdirectories points out of the image", true },

		// Entry point error detection
		{"LDR_ERROR_ENTRY_POINT_OUT_OF_IMAGE",     "The position of the entry point is out of the image", true },
		{"LDR_ERROR_ENTRY_POINT_ZEROED",           "The entry point is zeroed; probably damaged file", true },

		// Signature error detection
		{"LDR_ERROR_DIGITAL_SIGNATURE_CUT",        "The digital signature is cut or missing; probably damaged file", true },
		{"LDR_ERROR_DIGITAL_SIGNATURE_ZEROED",     "The digital signature is zeroed; probably damaged file", true },

		// Relocation errors
		{"LDR_ERROR_RELOCATIONS_OUT_OF_IMAGE",     "The relocation directory points out of the image", true },
		{"LDR_ERROR_RELOC_BLOCK_INVALID_VA",       "A relocation block has invalid virtual address", true },
		{"LDR_ERROR_RELOC_BLOCK_INVALID_LENGTH",   "A relocation block has invalid length", true },
		{"LDR_ERROR_RELOC_ENTRY_BAD_TYPE",         "A relocation entry has invalid type", true },

		// Other errors
		{"LDR_ERROR_INMEMORY_IMAGE",               "The file is an in-memory image", false },

	};

	PELIB_IMAGE_FILE_MACHINE_ITERATOR::PELIB_IMAGE_FILE_MACHINE_ITERATOR()
	{

	}

	PELIB_IMAGE_FILE_MACHINE_ITERATOR::~PELIB_IMAGE_FILE_MACHINE_ITERATOR()
	{

	}

	bool PELIB_IMAGE_FILE_MACHINE_ITERATOR::isValidMachineCode(PELIB_IMAGE_FILE_MACHINE value) const
	{
		return find(all.begin(), all.end(), value) != all.end();
	}

	PELIB_IMAGE_FILE_MACHINE_ITERATOR::imageFileMachineIterator PELIB_IMAGE_FILE_MACHINE_ITERATOR::begin() const
	{
		return all.begin();
	}

	PELIB_IMAGE_FILE_MACHINE_ITERATOR::imageFileMachineIterator PELIB_IMAGE_FILE_MACHINE_ITERATOR::end() const
	{
		return all.end();
	}

	unsigned int alignOffset(unsigned int uiOffset, unsigned int uiAlignment)
	{
		if (!uiAlignment) return uiAlignment;
		return (uiOffset % uiAlignment) ? uiOffset + (uiAlignment - uiOffset % uiAlignment) : uiOffset;
	}

	std::uint32_t AlignToSize(std::uint32_t ByteSize, std::uint32_t AlignSize)
	{
		return ((ByteSize + (AlignSize - 1)) & ~(AlignSize - 1));
	}

	std::uint32_t BytesToPages(std::uint32_t ByteSize)
	{
		return (ByteSize >> PELIB_PAGE_SIZE_SHIFT) + ((ByteSize & (PELIB_PAGE_SIZE - 1)) != 0);
	}

	std::uint64_t fileSize(const std::string& filename)
	{
		std::fstream file(filename.c_str());
		file.seekg(0, std::ios::end);
		return file.tellg();
	}

	std::uint64_t fileSize(std::istream& stream)
	{
		std::streamoff oldpos = stream.tellg();
		stream.seekg(0, std::ios::end);
		std::streamoff filesize = stream.tellg();
		stream.seekg(oldpos, std::ios::beg);
		return filesize;
	}

	std::uint64_t fileSize(std::fstream& file)
	{
		std::streamoff oldpos = file.tellg();
		file.seekg(0, std::ios::end);
		std::streamoff filesize = file.tellg();
		file.seekg(oldpos, std::ios::beg);
		return filesize;
	}

	std::uint64_t fileSize(std::ofstream& file)
	{
		std::streamoff oldpos = file.tellp();
		file.seekp(0, std::ios::end);
		std::streamoff filesize = file.tellp();
		file.seekp(oldpos, std::ios::beg);
		return filesize;
	}

	const char * getLoaderErrorString(LoaderError ldrError, bool userFriendly)
	{
		std::size_t index = (std::size_t)ldrError;

		// When the index is within range
		if (index < LdrErrStrings.size())
		{
			return userFriendly ? LdrErrStrings[index].loaderErrorUserFriendly : LdrErrStrings[index].loaderErrorString;
		}

		// If this assert triggers, we need to add the missing string
		// to the PeLib::LdrErrStrings vector
		assert(false);
		return "LDR_ERROR_DESCRIPTIVE_STRING_MISSING";
	}

	bool getLoaderErrorLoadableAnyway(LoaderError ldrError)
	{
		std::size_t index = (std::size_t)ldrError;

		// When the index is within range
		if (index < LdrErrStrings.size())
		{
			return LdrErrStrings[index].loadableAnyway;
		}

		// If this assert triggers, we need to add the missing string
		// to the PeLib::LdrErrStrings vector
		assert(false);
		return false;
	}

	// Anti-assert feature. Debug version of isprint in MS Visual C++ asserts
	// when the character is not EOF or is >= 255
	bool pelibIsPrintableChar(int ch)
	{
		return ((EOF <= ch) && (ch <= 255)) ? isprint(ch) : false;
	}

	/**
	 * @param stream
	 * @param result
	 * @param fileOffset
	 * @param maxLength  Maximum length of the string to get.
	 * @param isPrintable If @c true and a non-printable characters is read,
	 *                    set @p result to an empty string and return 0.
	 * @param isNotTooLong If @c true and @p maxLength is reached, set @p result
	 *                     to an empty string and return 0.
	 * @return Length of the @p result string.
	 */
	std::size_t getStringFromFileOffset(
			std::istream &stream,
			std::string &result,
			std::size_t fileOffset,
			std::size_t maxLength/* = 0*/,
			bool isPrintable/* = false*/,
			bool isNotTooLong/* = false*/)
	{
		IStreamWrapper inStream_w(stream);

		result.clear();
		inStream_w.clear();
		inStream_w.seekg(fileOffset, std::ios::beg);
		if (!inStream_w)
		{
			return 0;
		}

		char namebuffer[2] = { 0 };
		std::size_t size = 0;

		do
		{
			inStream_w.read(namebuffer, 1);
			if (!inStream_w || !namebuffer[0]) break;
			if (isPrintable && !pelibIsPrintableChar(namebuffer[0]))
			{
				result.clear();
				return 0;
			}
			result += namebuffer;
			++size;
			if (maxLength && size == maxLength)
			{
				if (isNotTooLong)
				{
					result.clear();
					return 0;
				}
				else
				{
					break;
				}
			}
		} while (true);

		return size;
	}

	bool isEqualNc(const std::string& s1, const std::string& s2)
	{
		std::string t1 = s1;
		std::string t2 = s2;

		// No std:: to make VC++ happy
#ifdef _MSC_VER
		std::transform(t1.begin(), t1.end(), t1.begin(), [](unsigned char c) { return toupper(c); });
		std::transform(t2.begin(), t2.end(), t2.begin(), [](unsigned char c) { return toupper(c); });
#else
  // Weird syntax to make Borland C++ happy
		std::transform(t1.begin(), t1.end(), t1.begin(), (int(*)(int))std::toupper);
		std::transform(t2.begin(), t2.end(), t2.begin(), (int(*)(int))std::toupper);
#endif
		return t1 == t2;
	}

	PELIB_EXP_FUNC_INFORMATION::PELIB_EXP_FUNC_INFORMATION()
	{
		addroffunc = 0;
		addrofname = 0;
		ordinal = 0;
	}

	PELIB_IMAGE_RESOURCE_DIRECTORY::PELIB_IMAGE_RESOURCE_DIRECTORY()
	{
		Characteristics = 0;
		TimeDateStamp = 0;
		MajorVersion = 0;
		MinorVersion = 0;
		NumberOfNamedEntries = 0;
		NumberOfIdEntries = 0;
	}

	PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY()
	{
		Name = 0;
		OffsetToData = 0;
	}

	bool PELIB_IMG_RES_DIR_ENTRY::operator<(const PELIB_IMG_RES_DIR_ENTRY& first) const
	{
		if ((irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING) && (first.irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING))
		{
			return wstrName < first.wstrName;
		}
		else if (irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
		{
			return true;
		}
		else if (first.irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
		{
			return false;
		}
		else
		{
			return irde.Name < first.irde.Name;
		}
	}

	PELIB_IMAGE_COR20_HEADER::PELIB_IMAGE_COR20_HEADER()
	{
		cb = 0;
		MajorRuntimeVersion = 0;
		MinorRuntimeVersion = 0;
		MetaData.VirtualAddress = 0;
		MetaData.Size = 0;
		Flags = 0;
		EntryPointToken = 0;
		Resources.VirtualAddress = 0;
		Resources.Size = 0;
		StrongNameSignature.VirtualAddress = 0;
		StrongNameSignature.Size = 0;
		CodeManagerTable.VirtualAddress = 0;
		CodeManagerTable.Size = 0;
		VTableFixups.VirtualAddress = 0;
		VTableFixups.Size = 0;
		ExportAddressTableJumps.VirtualAddress = 0;
		ExportAddressTableJumps.Size = 0;
		ManagedNativeHeader.VirtualAddress = 0;
		ManagedNativeHeader.Size = 0;
	}

	PELIB_IMAGE_RESOURCE_DATA_ENTRY::PELIB_IMAGE_RESOURCE_DATA_ENTRY()
	{
		OffsetToData = 0;
		Size = 0;
		CodePage = 0;
		Reserved = 0;
	}

	PELIB_IMAGE_DEBUG_DIRECTORY::PELIB_IMAGE_DEBUG_DIRECTORY()
	{
		Characteristics = 0;
		TimeDateStamp = 0;
		MajorVersion = 0;
		MinorVersion = 0;
		Type = 0;
		SizeOfData = 0;
		AddressOfRawData = 0;
		PointerToRawData = 0;
	}

	/** Compares the passed filename to the struct's filename.
	* @param strModuleName2 A filename.
	* @return True, if the passed filename equals the struct's filename. The comparison is case-sensitive.
	**/
	bool PELIB_IMAGE_BOUND_DIRECTORY::equal(const std::string strModuleName2) const
	{
		return this->strModuleName == strModuleName2;
	}

	bool PELIB_EXP_FUNC_INFORMATION::equal(const std::string strFunctionName) const
	{
		return isEqualNc(this->funcname, strFunctionName);
	}

	std::size_t PELIB_IMAGE_BOUND_DIRECTORY::size() const
	{
		unsigned int size = 0;
		for (unsigned int i = 0; i < moduleForwarders.size(); ++i)
		{
			size += moduleForwarders[i].size();
		}

		return (unsigned int)(size + PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size() + strModuleName.size() + 1);
	}
}

```

`debug_remover/src/pelib/RelocationsDirectory.cpp`:

```cpp
/*
* Relocations.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/RelocationsDirectory.h"

namespace PeLib
{
	/**
	* Constructor
	*/
	RelocationsDirectory::RelocationsDirectory() : m_ldrError(LDR_ERROR_NONE)
	{}

	int RelocationsDirectory::read(ImageLoader & imageLoader)
	{
		std::uint32_t rva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC);
		std::uint32_t size = imageLoader.getDataDirSize(PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC);
		std::uint32_t sizeOfImage = imageLoader.getSizeOfImage();
		std::uint64_t sizeOfFile = imageLoader.getSizeOfFile();

		// Check for relocations out of image
		if(rva >= sizeOfImage || (rva + size) < rva || (rva + size) > sizeOfImage)
		{
			RelocationsDirectory::setLoaderError(LDR_ERROR_RELOCATIONS_OUT_OF_IMAGE);
			return ERROR_INVALID_FILE;
		}

		// Check for relocations out of file
		if(size > sizeOfFile)
		{
			RelocationsDirectory::setLoaderError(LDR_ERROR_RELOCATIONS_OUT_OF_IMAGE);
			return ERROR_INVALID_FILE;
		}

		// Read the entire relocation directory from the image
		std::vector<std::uint8_t> vRelocDirectory(size);
		if(imageLoader.readImage(vRelocDirectory.data(), rva, size) != size)
			return ERROR_INVALID_FILE;

		// Parse the relocations directory
		read(vRelocDirectory.data(), size, sizeOfImage);
		return ERROR_NONE;
	}

	/**
	* Get the error that was detected during parsing of relocations
	**/
	LoaderError RelocationsDirectory::loaderError() const
	{
		return m_ldrError;
	}

	void RelocationsDirectory::setLoaderError(LoaderError ldrError)
	{
		// Do not override an existing error
		if (m_ldrError == LDR_ERROR_NONE)
		{
			m_ldrError = ldrError;
		}
	}

	void RelocationsDirectory::setRelocationData(unsigned int ulRelocation, unsigned int ulDataNumber, std::uint16_t wData)
	{
		m_vRelocations[ulRelocation].vRelocData[ulDataNumber] = wData;
	}

	void RelocationsDirectory::read(const std::uint8_t * data, std::uint32_t uiSize, std::uint32_t sizeOfImage)
	{
		const std::uint8_t * dataEnd = data + uiSize;

		// Clear the current relocations
		m_vRelocations.clear();

		// The entire relocation block looks like this:
		// * PELIB_IMAGE_BASE_RELOCATION (header of block)
		// * array of relocation entry, each has 2 bytes
		// * PELIB_IMAGE_BASE_RELOCATION (header of next block)
		// * array of relocation entry, each has 2 bytes
		// ... and so on, up to uiSize
		while((data + PELIB_IMAGE_SIZEOF_BASE_RELOCATION) < dataEnd)
		{
			const PELIB_IMAGE_BASE_RELOCATION * pRelocBlock = (const PELIB_IMAGE_BASE_RELOCATION *)data;
			IMG_BASE_RELOC ibrCurr;

			// Retrieve the single PELIB_IMAGE_BASE_RELOCATION entry.
			// Note that SizeOfBlock contains size of PELIB_IMAGE_BASE_RELOCATION itself
			// plus sizes of all subsequent fixup entries
			ibrCurr.ibrRelocation.VirtualAddress = pRelocBlock->VirtualAddress;
			ibrCurr.ibrRelocation.SizeOfBlock = pRelocBlock->SizeOfBlock;

			// Verify whether the base virtual address is within the image
			if(ibrCurr.ibrRelocation.VirtualAddress > sizeOfImage)
			{
				setLoaderError(LDR_ERROR_RELOC_BLOCK_INVALID_VA);
				break;
			}
			if((data + ibrCurr.ibrRelocation.SizeOfBlock) > dataEnd)
			{
				setLoaderError(LDR_ERROR_RELOC_BLOCK_INVALID_LENGTH);
				break;
			}

			// Move the offset by the size of relocation block structure
			data += PELIB_IMAGE_SIZEOF_BASE_RELOCATION;

			// Prevent underflow caused by size smaller than PELIB_IMAGE_SIZEOF_BASE_RELOCATION.
			// Example: \retdec-regression-tests\tools\fileinfo\detection\packers\securom\sample_securom_003.dat
			if(ibrCurr.ibrRelocation.SizeOfBlock >= PELIB_IMAGE_SIZEOF_BASE_RELOCATION)
			{
				// Get the number of fixup entries
				const std::uint16_t * typeAndOffsets = (const std::uint16_t *)(pRelocBlock + 1);
				std::uint32_t numberOfEntries = (ibrCurr.ibrRelocation.SizeOfBlock - PELIB_IMAGE_SIZEOF_BASE_RELOCATION) / sizeof(uint16_t);

				for (std::uint32_t i = 0; i < numberOfEntries; i++)
				{
					// Read the type and offset
					if((data + sizeof(std::uint16_t)) > dataEnd)
						break;
					uint16_t typeAndOffset = typeAndOffsets[i];

					// Verify the type and offset
					switch(typeAndOffset >> 12)
					{
						case PELIB_IMAGE_REL_BASED_HIGHADJ:	// This relocation entry occupies two entries
							data += sizeof(uint16_t);
							// No break here!

						case PELIB_IMAGE_REL_BASED_ABSOLUTE:
						case PELIB_IMAGE_REL_BASED_HIGH:
						case PELIB_IMAGE_REL_BASED_LOW:
						case PELIB_IMAGE_REL_BASED_HIGHLOW:
						case PELIB_IMAGE_REL_BASED_MIPS_JMPADDR:
						case PELIB_IMAGE_REL_BASED_IA64_IMM64:
						case PELIB_IMAGE_REL_BASED_DIR64:

							// This is a correct relocation entry. Lower 12 bits contains
							// relocation offset relative to ibrCurr.ibrRelocation.VirtualAddress
							break;

						default:    // Invalid relocation entry type
							setLoaderError(LDR_ERROR_RELOC_ENTRY_BAD_TYPE);
							break;
					}

					// Push the relocation entry to the list
					ibrCurr.vRelocData.push_back(typeAndOffset);
					data += sizeof(uint16_t);
				}

				// Push the data to the relocations vector
				m_vRelocations.push_back(std::move(ibrCurr));
			}
		}
	}

	unsigned int RelocationsDirectory::size() const
	{
		unsigned int size2 = static_cast<unsigned int>(m_vRelocations.size()) * PELIB_IMAGE_BASE_RELOCATION::size();

		for (unsigned int i=0;i<m_vRelocations.size();i++)
		{
			size2 += static_cast<unsigned int>(m_vRelocations[i].vRelocData.size()) * sizeof(std::uint16_t);
		}

		return size2;
	}

	unsigned int RelocationsDirectory::calcNumberOfRelocations() const
	{
		return static_cast<unsigned int>(m_vRelocations.size());
	}

	std::uint32_t RelocationsDirectory::getVirtualAddress(unsigned int ulRelocation) const
	{
		return m_vRelocations[ulRelocation].ibrRelocation.VirtualAddress;
	}

	std::uint32_t RelocationsDirectory::getSizeOfBlock(unsigned int ulRelocation) const
	{
		return m_vRelocations[ulRelocation].ibrRelocation.SizeOfBlock;
	}

	unsigned int RelocationsDirectory::calcNumberOfRelocationData(unsigned int ulRelocation) const
	{
		return static_cast<unsigned int>(m_vRelocations[ulRelocation].vRelocData.size());
	}

	std::uint16_t RelocationsDirectory::getRelocationData(unsigned int ulRelocation, unsigned int ulDataNumber) const
	{
		return m_vRelocations[ulRelocation].vRelocData[ulDataNumber];
	}

	void RelocationsDirectory::setVirtualAddress(unsigned int ulRelocation, std::uint32_t dwValue)
	{
		m_vRelocations[ulRelocation].ibrRelocation.VirtualAddress = dwValue;
	}

	void RelocationsDirectory::setSizeOfBlock(unsigned int ulRelocation, std::uint32_t dwValue)
	{
		m_vRelocations[ulRelocation].ibrRelocation.SizeOfBlock = dwValue;
	}

	void RelocationsDirectory::addRelocation()
	{
		IMG_BASE_RELOC newrelocation;
		m_vRelocations.push_back(newrelocation);
	}

	void RelocationsDirectory::addRelocationData(unsigned int ulRelocation, std::uint16_t wValue)
	{
		m_vRelocations[ulRelocation].vRelocData.push_back(wValue);
	}

/*	void RelocationsDirectory::removeRelocationData(unsigned int ulRelocation, std::uint16_t wValue)
	{
		// If you get an error with Borland C++ here you have two options: Upgrade your compiler
		// or use the commented line instead of the line below.
		m_vRelocations[ulRelocation].vRelocData.erase(std::remove(m_vRelocations[ulRelocation].vRelocData.begin(), m_vRelocations[ulRelocation].vRelocData.end(), wValue), m_vRelocations[ulRelocation].vRelocData.end());
	}
*/
	void RelocationsDirectory::removeRelocation(unsigned int index)
	{
		m_vRelocations.erase(m_vRelocations.begin() + index);
	}

	void RelocationsDirectory::removeRelocationData(unsigned int relocindex, unsigned int dataindex)
	{
		m_vRelocations[relocindex].vRelocData.erase(m_vRelocations[relocindex].vRelocData.begin() + dataindex);
	}
}

```

`debug_remover/src/pelib/ResourceDirectory.cpp`:

```cpp
/*
* ResourceDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory
* of PeLib.
*/

#include "retdec/pelib/ResourceDirectory.h"

namespace PeLib
{

// -------------------------------------------------- ResourceChild -------------------------------------------

	ResourceChild::ResourceChild() : child(nullptr)
	{
	}

	ResourceChild::ResourceChild(const ResourceChild& rhs)
	{
		entry = rhs.entry;
		if (dynamic_cast<ResourceNode*>(rhs.child))
		{
			ResourceNode* oldnode = static_cast<ResourceNode*>(rhs.child);

			child = new ResourceNode;
			child->uiElementRva = rhs.child->getElementRva();
			static_cast<ResourceNode*>(child)->header = oldnode->header;
			static_cast<ResourceNode*>(child)->children = oldnode->children;
		}
		else if (dynamic_cast<ResourceLeaf*>(rhs.child))
		{
			ResourceLeaf* oldnode = static_cast<ResourceLeaf*>(rhs.child);

			child = new ResourceLeaf;
			child->uiElementRva = rhs.child->getElementRva();
			static_cast<ResourceLeaf*>(child)->m_data = oldnode->m_data;
			static_cast<ResourceLeaf*>(child)->entry = oldnode->entry;
		}
		else
			child = 0;
	}

	ResourceChild& ResourceChild::operator=(const ResourceChild& rhs)
	{
		if (this != &rhs)
		{
			entry = rhs.entry;
			if (dynamic_cast<ResourceNode*>(rhs.child))
			{
				ResourceNode* oldnode = static_cast<ResourceNode*>(rhs.child);

				child = new ResourceNode;
				child->uiElementRva = rhs.child->getElementRva();
				static_cast<ResourceNode*>(child)->header = oldnode->header;
				static_cast<ResourceNode*>(child)->children = oldnode->children;
			}
			else if (dynamic_cast<ResourceLeaf*>(rhs.child))
			{
				ResourceLeaf* oldnode = static_cast<ResourceLeaf*>(rhs.child);

				child = new ResourceLeaf;
				child->uiElementRva = rhs.child->getElementRva();
				static_cast<ResourceLeaf*>(child)->m_data = oldnode->m_data;
				static_cast<ResourceLeaf*>(child)->entry = oldnode->entry;
			}
			else
				child = 0;
		}

		return *this;
	}

	ResourceChild::~ResourceChild()
	{
		delete child;
	}

	/**
	* Compares the resource child's id to the parameter dwId.
	* @param dwId ID of a resource.
	* @return True, if the resource child's id equals the parameter.
	**/
	bool ResourceChild::equalId(std::uint32_t dwId) const
	{
		return entry.irde.Name == dwId;
	}

	/**
	* Compares the resource child's name to the parameter strName.
	* @param strName ID of a resource.
	* @return True, if the resource child's name equals the parameter.
	**/
	bool ResourceChild::equalName(std::string strName) const
	{
		return entry.wstrName == strName;
	}

	/**
	* Returns true if the resource was given a name.
	**/
	bool ResourceChild::isNamedResource() const
	{
		return entry.wstrName.size() != 0;
	}

	/**
	* The children of a resource must be ordered in a certain way. First come the named resources
	* in sorted order, afterwards followed the unnamed resources in sorted order.
	**/
	bool ResourceChild::operator<(const ResourceChild& rc) const
	{
		if (this->isNamedResource() && !rc.isNamedResource())
		{
			return true;
		}
		else if (!this->isNamedResource() && rc.isNamedResource())
		{
			return false;
		}
		else if (this->isNamedResource() && rc.isNamedResource())
		{
			return this->entry.wstrName < rc.entry.wstrName;
		}
		else
		{
			return this->entry.irde.Name < rc.entry.irde.Name;
		}
	}

	/**
	* Returns the node's number of children.
	*/
	unsigned int ResourceChild::getNumberOfChildren() const
	{
		if (!child || child->isLeaf())
		{
			return 0;
		}

		auto *childNode = dynamic_cast<ResourceNode*>(child);
		return !childNode ? 0 : childNode->getNumberOfChildren();
	}

	/**
	* Returns a child of this child.
	*/
	ResourceChild* ResourceChild::getChildOfThisChild(std::size_t uiIndex)
	{
		if (!child || child->isLeaf())
		{
			return nullptr;
		}

		auto *childNode = dynamic_cast<ResourceNode*>(child);
		return !childNode ? nullptr : childNode->getChild(uiIndex);
	}

	/**
	* Returns a child of this child.
	*/
	const ResourceChild* ResourceChild::getChildOfThisChild(std::size_t uiIndex) const
	{
		if (!child || child->isLeaf())
		{
			return nullptr;
		}

		auto *childNode = dynamic_cast<const ResourceNode*>(child);
		return !childNode ? nullptr : childNode->getChild(uiIndex);
	}

	/**
	 * Returns ResourceElement associated with this ResourceChild. It can be either ResourceNode or ResourceLeaf.
	 *
	 * @return Associated ResourceElement.
	 */
	ResourceElement* ResourceChild::getNode()
	{
		return child;
	}

	/**
	 * Returns ResourceElement associated with this ResourceChild. It can be either ResourceNode or ResourceLeaf.
	 *
	 * @return Associated ResourceElement.
	 */
	const ResourceElement* ResourceChild::getNode() const
	{
		return child;
	}

	/**
	 * Sets ResourceElement associated with this ResourceChild. It can be either ResourceNode or ResourceLeaf.
	 *
	 * @param node ResourceElement to associate with this ResourceChild.
	 */
	void ResourceChild::setNode(ResourceElement* node)
	{
		child = node;
	}

	/**
	 * Returns the name of the node.
	 *
	 * @return Name of the node.
	 */
	std::string ResourceChild::getName() const
	{
		return entry.wstrName;
	}

	/**
	 * Returns the Name value of the node.
	 *
	 * @return Name value of the node.
	 */
	std::uint32_t ResourceChild::getOffsetToName() const
	{
		return entry.irde.Name;
	}

	/**
	 * Returns the OffsetToData value of the node.
	 *
	 * @return OffsetToData value of the node.
	 */
	std::uint32_t ResourceChild::getOffsetToData() const
	{
		return entry.irde.OffsetToData;
	}

	/**
	 * Sets the name of the node.
	 *
	 * @param strNewName New node name.
	 */
	void ResourceChild::setName(const std::string& strNewName)
	{
		entry.wstrName = strNewName;
	}

	/**
	 * Sets the Name value of the node.
	 *
	 * @param dwNewOffset Name value to set.
	 */
	void ResourceChild::setOffsetToName(std::uint32_t dwNewOffset)
	{
		entry.irde.Name = dwNewOffset;
	}

	/**
	 * Sets the OffsetToData value of the node.
	 *
	 * @param dwNewOffset OffsetToData value to set.
	 */
	void ResourceChild::setOffsetToData(std::uint32_t dwNewOffset)
	{
		entry.irde.OffsetToData = dwNewOffset;
	}

/*	unsigned int ResourceChild::size() const
	{
		return PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::size()
			   + child->size()
			   + (entry.wstrName.size() ? entry.wstrName.size() + 2 : 0);
	}
*/
// -------------------------------------------------- ResourceElement -------------------------------------------

	/**
	* Returns the RVA of a ResourceElement. This is the RVA where the ResourceElement can be
	* found in the file.
	* @return RVA of the ResourceElement.
	**/
	unsigned int ResourceElement::getElementRva() const
	{
		return uiElementRva;
	}

	ResourceElement::ResourceElement() : uiElementRva(0)
	{

	}

// -------------------------------------------------- ResourceLeaf -------------------------------------------

	/**
	* Checks if a ResourceElement is a leaf or not.
	* @return Always returns true.
	**/
	bool ResourceLeaf::isLeaf() const
	{
		return true;
	}

	/**
	* Reads the next resource leaf from the input file.
	* @param imageLoader An image loaded into the ImageLoader parser
	* @param uiRsrcRva RVA of the beginning of the resource directory.
	* @param uiOffset Offset of the resource leaf that's to be read.
	* @param sizeOfImage Size of the image.
	* @param resDir Resource directory.
	**/
	int ResourceLeaf::read(
			ImageLoader & imageLoader,
			std::uint32_t uiRsrcRva,
			std::uint32_t uiOffset,
			std::uint32_t sizeOfImage,
			ResourceDirectory* resDir)
	{
		// Invalid leaf.
		std::uint32_t uiRva = uiRsrcRva + uiOffset;
		if(uiRva > sizeOfImage)
			return ERROR_INVALID_FILE;

		// Load the resource data entry
		imageLoader.readImage(&entry, uiRva, sizeof(PELIB_IMAGE_RESOURCE_DATA_ENTRY));
		resDir->addOccupiedAddressRange(uiRva, uiRva + PELIB_IMAGE_RESOURCE_DATA_ENTRY::size() - 1);

		// Clear the resource data
		m_data.clear();

		// No data or invalid leaf
		if(entry.OffsetToData == 0 && entry.Size == 0)
			return ERROR_SKIP_RESOURCE;	// Be in sync with YARA
		if(entry.OffsetToData > sizeOfImage || entry.Size > sizeOfImage)
			return ERROR_NONE;
		if((uiRsrcRva + entry.OffsetToData) >= sizeOfImage || (uiRsrcRva + entry.OffsetToData + entry.Size) > sizeOfImage)
			return ERROR_NONE;

		// Data range overflow?
		if((uiRsrcRva + entry.OffsetToData) < uiRsrcRva || (uiRsrcRva + entry.OffsetToData + entry.Size) < uiRsrcRva)
			return ERROR_NONE;

		// Load the resource data
		m_data.resize(entry.Size);
		imageLoader.readImage(m_data.data(), entry.OffsetToData, entry.Size);

		// Add the data range to the occupied map
		if(entry.Size > 0)
			resDir->addOccupiedAddressRange(entry.OffsetToData, entry.OffsetToData + entry.Size - 1);
		return ERROR_NONE;
	}

	/**
	* Rebuilds the current resource leaf.
	* @param obBuffer OutputBuffer where the rebuilt resource leaf is stored.
	* @param uiOffset Offset of the resource leaf inside the resource directory.
	* @param uiRva RVA of the resource directory.
	**/
	void ResourceLeaf::rebuild(OutputBuffer& obBuffer, unsigned int uiOffset, unsigned int uiRva, const std::string&) const
	{
//		Log::debug() << std::hex << pad << "Leaf: " << uiOffset << std::endl;

//		obBuffer << entry.OffsetToData;
//		obBuffer << uiOffset;
		obBuffer.insert(uiOffset, entry.OffsetToData);
		obBuffer.insert(uiOffset + 4, entry.Size);
		obBuffer.insert(uiOffset + 8, entry.CodePage);
		obBuffer.insert(uiOffset + 12, entry.Reserved);

		for (unsigned int i=0;i<m_data.size();i++)
		{
			// If it is less than RVA, it means that data are out of directory
			// This is not ordinary but needs to be handled, otherwise few, usually packed samples won't work
			// Don't do nothing and let caller to make sure those data are present at the desired offset in the file
			if (entry.OffsetToData < uiRva)
				continue;

			obBuffer.insert(entry.OffsetToData - uiRva + i, m_data[i]);
		}
//		Log::debug() << "LeafChild: " << std::endl;
	}

	/**
	 * Recalculates the current node for directory with new RVA.
	 *
	 * @param uiCurrentOffset The current offset of the node in the new directory.
	 * @param uiNewRva The RVA of the new directory.
	 */
	void ResourceLeaf::recalculate(unsigned int& uiCurrentOffset, unsigned int uiNewRva)
	{
		uiCurrentOffset += PELIB_IMAGE_RESOURCE_DATA_ENTRY::size();
		setOffsetToData(uiCurrentOffset + uiNewRva);
		uiCurrentOffset += getSize();
	}

	void ResourceLeaf::makeValid()
	{
		entry.Size = static_cast<unsigned int>(m_data.size());
	}

/*	/// Returns the size of a resource leaf.
	unsigned int ResourceLeaf::size() const
	{
		return PELIB_IMAGE_RESOURCE_DATA_ENTRY::size() + m_data.size();
	}
*/

	/**
	* Returns a vector that contains the raw data of a resource leaf.
	* @return Raw data of the resource.
	**/
	std::vector<std::uint8_t> ResourceLeaf::getData() const
	{
		return m_data;
	}

	/**
	* Overwrites the raw data of a resource.
	* @param vData New data of the resource.
	**/
	void ResourceLeaf::setData(const std::vector<std::uint8_t>& vData)
	{
		m_data = vData;
	}

	/**
	* Returns the leaf's OffsetToData value. That's the RVA where the raw data of the resource
	* can be found.
	* @return The leaf's OffsetToData value.
	**/
	std::uint32_t ResourceLeaf::getOffsetToData() const
	{
		return entry.OffsetToData;
	}

	/**
	* Returns the leaf's Size value. That's the size of the raw data of the resource.
	* @return The leaf's Size value.
	**/
	std::uint32_t ResourceLeaf::getSize() const
	{
		return entry.Size;
	}

	/**
	* Returns the leaf's CodePage value.
	* @return The leaf's CodePage value.
	**/
	std::uint32_t ResourceLeaf::getCodePage() const
	{
		return entry.CodePage;
	}

	/**
	* Returns the leaf's Reserved value.
	* @return The leaf's Reserved value.
	**/
	std::uint32_t ResourceLeaf::getReserved() const
	{
		return entry.Reserved;
	}

	/**
	* Sets the leaf's OffsetToData value.
	* @param dwValue The leaf's new OffsetToData value.
	**/
	void ResourceLeaf::setOffsetToData(std::uint32_t dwValue)
	{
		entry.OffsetToData = dwValue;
	}

	/**
	* Sets the leaf's Size value.
	* @param dwValue The leaf's new Size value.
	**/
	void ResourceLeaf::setSize(std::uint32_t dwValue)
	{
		entry.Size = dwValue;
	}

	/**
	* Sets the leaf's CodePage value.
	* @param dwValue The leaf's new CodePage value.
	**/
	void ResourceLeaf::setCodePage(std::uint32_t dwValue)
	{
		entry.CodePage = dwValue;
	}

	/**
	* Sets the leaf's Reserved value.
	* @param dwValue The leaf's new Reserved value.
	**/
	void ResourceLeaf::setReserved(std::uint32_t dwValue)
	{
		entry.Reserved = dwValue;
	}

	ResourceLeaf::ResourceLeaf() : ResourceElement()
	{

	}

	ResourceLeaf::~ResourceLeaf()
	{

	}

// -------------------------------------------------- ResourceNode -------------------------------------------

	/**
	* Checks if a ResourceElement is a leaf or not.
	* @return Always returns false.
	**/
	bool ResourceNode::isLeaf() const
	{
		return false;
	}

	/**
	* Sorts the node's children and corrects the node's header.
	**/
	void ResourceNode::makeValid()
	{
		std::sort(children.begin(), children.end());
		header.NumberOfNamedEntries = static_cast<std::uint16_t>(std::count_if(
				children.begin(),
				children.end(),
				[](const auto& i) { return i.isNamedResource(); }
		));
		header.NumberOfIdEntries = static_cast<unsigned int>(children.size()) - header.NumberOfNamedEntries;
	}

	/**
	* Rebuilds the current resource node.
	* @param obBuffer OutputBuffer where the rebuilt resource node is stored.
	* @param uiOffset Offset of the resource node inside the resource directory.
	* @param uiRva RVA of the resource directory.
	* @param pad Used for debugging.
	**/
	void ResourceNode::rebuild(OutputBuffer& obBuffer, unsigned int uiOffset, unsigned int uiRva, const std::string& pad) const
	{
/*		Log::debug() << std::hex << pad << uiOffset << std::endl;

		Log::debug() << std::hex << pad << "header.Characteristics: " << header.Characteristics << std::endl;
		Log::debug() << std::hex << pad << "header.TimeDateStamp: " << header.TimeDateStamp << std::endl;
		Log::debug() << std::hex << pad << "header.MajorVersion: "  << header.MajorVersion << std::endl;
		Log::debug() << std::hex << pad << "header.MinorVersion: "  << header.MinorVersion << std::endl;
		Log::debug() << std::hex << pad << "header.NumberOfNamedEntries: "  << header.NumberOfNamedEntries << std::endl;
		Log::debug() << std::hex << pad << "header.NumberOfIdEntries: "  << header.NumberOfIdEntries << std::endl;
*/
		obBuffer.insert(uiOffset, header.Characteristics);
		obBuffer.insert(uiOffset + 4, header.TimeDateStamp);
		obBuffer.insert(uiOffset + 8, header.MajorVersion);
		obBuffer.insert(uiOffset + 10, header.MinorVersion);
		//Log::debug() << pad << "Children: " << children.size() << std::endl;
		obBuffer.insert(uiOffset + 12, header.NumberOfNamedEntries);
		obBuffer.insert(uiOffset + 14, header.NumberOfIdEntries);

		uiOffset += PELIB_IMAGE_RESOURCE_DIRECTORY::size();

		for (unsigned int i=0;i<children.size();i++)
		{
			// (i << 3) == i * 8
			unsigned int uiChildOffset = uiOffset + (i << 3);

			obBuffer.insert(uiChildOffset, children[i].entry.irde.Name);
			obBuffer.insert(uiChildOffset + 4, children[i].entry.irde.OffsetToData);

			if (children[i].entry.irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
			{
				unsigned int uiNameOffset = children[i].entry.irde.Name & ~PELIB_IMAGE_RESOURCE_NAME_IS_STRING;
				obBuffer.insert(uiNameOffset, (std::uint16_t)children[i].entry.wstrName.size());
				uiNameOffset += 2;

				for (unsigned int j = 0; j < children[i].entry.wstrName.size(); ++j)
				{
					obBuffer.insert(uiNameOffset, (std::uint16_t)children[i].entry.wstrName[j]);
					uiNameOffset += 2;
				}
			}

			if (children[i].entry.irde.OffsetToData & PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY)
				children[i].child->rebuild(obBuffer, children[i].entry.irde.OffsetToData & ~PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY, uiRva, pad);
			else
				children[i].child->rebuild(obBuffer, children[i].entry.irde.OffsetToData, uiRva, pad);
		}
	}

	/**
	 * Recalculates the current node and child nodes for directory with new RVA.
	 *
	 * @param uiCurrentOffset The current offset of the node in the new directory.
	 * @param uiNewRva The RVA of the new directory.
	 */
	void ResourceNode::recalculate(unsigned int& uiCurrentOffset, unsigned int uiNewRva)
	{
		// There is always directory and its entries at the beginning
		uiCurrentOffset += PELIB_IMAGE_RESOURCE_DIRECTORY::size();
		uiCurrentOffset += (PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::size() * getNumberOfChildren());

		for (unsigned int i = 0; i < getNumberOfChildren(); ++i)
		{
			// We need to store name of the named resource
			if (children[i].getOffsetToName() & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
			{
				children[i].setOffsetToName(PELIB_IMAGE_RESOURCE_NAME_IS_STRING | uiCurrentOffset);
				uiCurrentOffset = (unsigned int)(uiCurrentOffset + 2 + (children[i].getName().length() << 1));
			}

			// In case of non-leaf node, we recursively call this method on the current node
			if (children[i].getOffsetToData() & PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY)
			{
				children[i].setOffsetToData(PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY | uiCurrentOffset);
				children[i].getNode()->recalculate(uiCurrentOffset, uiNewRva);
			}
			else
			{
				children[i].setOffsetToData(uiCurrentOffset);
				children[i].getNode()->recalculate(uiCurrentOffset, uiNewRva);
			}
		}
	}

	/**
	* Reads the next resource node from the input file.
	* @param imageLoader An image loaded into the ImageLoader parser
	* @param uiRsrcRva RVA of the beginning of the resource directory.
	* @param uiOffset Offset of the resource node that's to be read.
	* @param sizeOfImage Size of the image.
	* @param resDir Resource directory.
	**/
	int ResourceNode::read(
			ImageLoader & imageLoader,
			std::uint32_t uiRsrcRva,
			std::uint32_t uiOffset,
			std::uint32_t sizeOfImage,
			ResourceDirectory* resDir)
	{
		//
		// Any error handling here must be in syn with YARA (Module: pe.c, Function: _pe_iterate_resources)
		//

		// Enough space to be a valid node?
		std::uint32_t uiRva = uiRsrcRva + uiOffset;
		if(uiRva > sizeOfImage)
			return ERROR_INVALID_FILE;

		// Read the resource node header
		if(imageLoader.readImage(&header, uiRva, PELIB_IMAGE_RESOURCE_DIRECTORY::size()) != PELIB_IMAGE_RESOURCE_DIRECTORY::size())
			return ERROR_INVALID_FILE;

		// FE015EB24B7EEA2907698A6D7142198644A757066DA4EB8D3A4B63900008CF5E
		//  * Invalid root resource directory
		// 7dfc75ade04a0deb55dfbf87baff2306e625c5280748856f69f2f43599615249
		//  * IMAGE_RESOURCE_DIRECTORY::Characteristics != 0
		//  * IMAGE_RESOURCE_DIRECTORY::NumberOfIdEntries == 0x8000
		// We artificially limit the allowed number of resource entries.
		// If exceeded, we don't stop resource parsing, but rather ignore the resource and move on
		// in order to be in sync with YARA
		unsigned int uiNumberOfEntries = header.NumberOfNamedEntries + header.NumberOfIdEntries;
		if((header.NumberOfNamedEntries > PELIB_MAX_RESOURCE_ENTRIES) ||
		   (header.NumberOfIdEntries > PELIB_MAX_RESOURCE_ENTRIES) ||
		   (uiNumberOfEntries > PELIB_MAX_RESOURCE_ENTRIES))
			return ERROR_SKIP_RESOURCE;

		// Add the total number of entries to the occupied range
		resDir->addOccupiedAddressRange(uiRva, uiRva + PELIB_IMAGE_RESOURCE_DIRECTORY::size() - 1);
		uiRva += PELIB_IMAGE_RESOURCE_DIRECTORY::size();

		// Windows loader check (PspLocateInPEManifest -> LdrpResGetResourceDirectory):
		// If the total number of resource entries goes beyond the image, the file is refused to run
		// Sample: 6318b0a1b57fc70bce5314aefb6cb06c90b7991afeae4e91ffc05ee0c88947d7
		// However, such sample can still be executed in WinXP-based emulator
		if ((uiRva + (uiNumberOfEntries * PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::size())) > sizeOfImage)
		{
			resDir->setLoaderError(LDR_ERROR_RSRC_OVER_END_OF_IMAGE);
			return ERROR_NONE;
		}

		resDir->insertNodeOffset(uiOffset);

		if (uiNumberOfEntries > 0)
		{
			resDir->addOccupiedAddressRange(uiRva, uiRva + uiNumberOfEntries * PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::size() - 1);
		}

		// Load all entries to the vector
		for (unsigned int i = 0; i < uiNumberOfEntries; i++)
		{
			ResourceChild rc;
			int childError;

			imageLoader.readImage(&rc.entry.irde, uiRva, PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::size());
			uiRva += PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::size();

			// If the resource name goes out of the image, then the image is claimed as corrupt by
			// Windows loader check (PspLocateInPEManifest -> LdrpResGetResourceDirectory)
			if(rc.entry.irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
			{
				if((rc.entry.irde.Name & PELIB_IMAGE_RESOURCE_RVA_MASK) > sizeOfImage)
				{
					resDir->setLoaderError(LDR_ERROR_RSRC_NAME_OUT_OF_IMAGE);
				}
			}

			// Check whether the resource data/subdirectory goes out of the image
			{
				if((rc.entry.irde.OffsetToData & PELIB_IMAGE_RESOURCE_RVA_MASK) > sizeOfImage)
				{
					// Is it a subdirectory?
					if(rc.entry.irde.OffsetToData & PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY)
					{
						resDir->setLoaderError(LDR_ERROR_RSRC_SUBDIR_OUT_OF_IMAGE);
						return ERROR_NONE;
					}
					else
					{
						resDir->setLoaderError(LDR_ERROR_RSRC_DATA_OUT_OF_IMAGE);
					}
				}
			}

			if (rc.entry.irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
			{
				// Enough space to read string length?
				if ((rc.entry.irde.Name & PELIB_IMAGE_RESOURCE_RVA_MASK) + 2 < sizeOfImage)
				{
					// Check whether we have enough space to read at least one character
					unsigned int uiNameOffset = rc.entry.irde.Name & PELIB_IMAGE_RESOURCE_RVA_MASK;
					if (uiRsrcRva + uiNameOffset + sizeof(std::uint16_t) > sizeOfImage)
					{
						return ERROR_INVALID_FILE;
					}

					std::uint16_t length = 0;
					std::uint32_t name_rva = uiRsrcRva + uiNameOffset;
					// Read the string length (first 2 bytes at start)
					imageLoader.readImage(&length, name_rva, sizeof(std::uint16_t));

					// Sanity check for pointer to junk data instead of valid string
					if (length <= 100)
					{
						// Read the resource name
						imageLoader.readStringRc(rc.entry.wstrName, name_rva);
					}
				}
			}

			// Detect cycles to prevent infinite recursion.
			if (resDir->hasNodeOffset(rc.entry.irde.OffsetToData & PELIB_IMAGE_RESOURCE_RVA_MASK))
			{
				return ERROR_NONE;
			}

			if (rc.entry.irde.OffsetToData & PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY)
			{
				rc.child = new ResourceNode;
			}
			else
			{
				rc.child = new ResourceLeaf;
			}

			// Read the child node
			childError = rc.child->read(imageLoader, uiRsrcRva, rc.entry.irde.OffsetToData & PELIB_IMAGE_RESOURCE_RVA_MASK, sizeOfImage, resDir);
			switch(childError)
			{
				case ERROR_NONE:             // If the resource was found to be OK, insert it to the list of children
					children.push_back(rc);
					break;

				case ERROR_SKIP_RESOURCE:    // Do not insert invalid resources; do not stop processing either
					break;

				default:
					return childError;
			}
		}

		return ERROR_NONE;
	}

	/**
	* Returns the number of children of the current node. Note that this number is the number
	* of defined children, not the value from the header.
	* @return Number of node's children.
	**/
	unsigned int ResourceNode::getNumberOfChildren() const
	{
		return static_cast<unsigned int>(children.size());
	}

	/**
	* Adds another child to the current node.
	* @return Newly created ResourceChild.
	**/
	ResourceChild* ResourceNode::addChild()
	{
		ResourceChild c;
		c.child = 0;
		children.push_back(c);
		return &children[getNumberOfChildren() - 1];
	}

	/**
	* Returns a node's child.
	* @param uiIndex Index of the child.
	* @return The child identified by uiIndex.
	**/
	ResourceChild* ResourceNode::getChild(std::size_t uiIndex)
	{
		return &children[uiIndex];
	}

	/**
	* Returns a node's child.
	* @param uiIndex Index of the child.
	* @return The child identified by uiIndex.
	**/
	const ResourceChild* ResourceNode::getChild(std::size_t uiIndex) const
	{
		return &children[uiIndex];
	}

	/**
	* Removes a child from the current node.
	* @param uiIndex Index of the child.
	**/
	void ResourceNode::removeChild(unsigned int uiIndex)
	{
		children.erase(children.begin() + uiIndex);
	}

	/**
	* Returns the name of a child.
	* @param uiIndex Index of the child.
	* @return Either the name of the specified child or an empty string.
	**/
	std::string ResourceNode::getChildName(unsigned int uiIndex) const
	{
		return children[uiIndex].getName();
	}

	/**
	* Returns the Name value of a child.
	* @param uiIndex Index of the child.
	* @return Name value of a child.
	**/
	std::uint32_t ResourceNode::getOffsetToChildName(unsigned int uiIndex) const
	{
		return children[uiIndex].getOffsetToName();
	}

	/**
	* Returns the OffsetToData value of a child.
	* @param uiIndex Index of the child.
	* @return OffsetToData value of a child.
	**/
	std::uint32_t ResourceNode::getOffsetToChildData(unsigned int uiIndex) const
	{
		return children[uiIndex].getOffsetToData();
	}

	/**
	* Sets the name of a child.
	* @param uiIndex Index of the child.
	* @param strNewName New name of the resource.
	**/
	void ResourceNode::setChildName(unsigned int uiIndex, const std::string& strNewName)
	{
		children[uiIndex].setName(strNewName);
	}

	/**
	* Sets the Name value of a child.
	* @param uiIndex Index of the child.
	* @param dwNewOffset New Name value of the resource.
	**/
	void ResourceNode::setOffsetToChildName(unsigned int uiIndex, std::uint32_t dwNewOffset)
	{
		children[uiIndex].setOffsetToName(dwNewOffset);
	}

	/**
	* Sets the OffsetToData value of a child.
	* @param uiIndex Index of the child.
	* @param dwNewOffset New OffsetToData value of the resource.
	**/
	void ResourceNode::setOffsetToChildData(unsigned int uiIndex, std::uint32_t dwNewOffset)
	{
		children[uiIndex].setOffsetToData(dwNewOffset);
	}

	/**
	* Returns the Characteristics value of the node.
	* @return Characteristics value of the node.
	**/
	std::uint32_t ResourceNode::getCharacteristics() const
	{
		return header.Characteristics;
	}

	/**
	* Returns the TimeDateStamp value of the node.
	* @return TimeDateStamp value of the node.
	**/
	std::uint32_t ResourceNode::getTimeDateStamp() const
	{
		return header.TimeDateStamp;
	}

	/**
	* Returns the MajorVersion value of the node.
	* @return MajorVersion value of the node.
	**/
	std::uint16_t ResourceNode::getMajorVersion() const
	{
		return header.MajorVersion;
	}

	/**
	* Returns the MinorVersion value of the node.
	* @return MinorVersion value of the node.
	**/
	std::uint16_t ResourceNode::getMinorVersion() const
	{
		return header.MinorVersion;
	}

	/**
	* Returns the NumberOfNamedEntries value of the node.
	* @return NumberOfNamedEntries value of the node.
	**/
	std::uint16_t ResourceNode::getNumberOfNamedEntries() const
	{
		return header.NumberOfNamedEntries;
	}

	/**
	* Returns the NumberOfIdEntries value of the node.
	* @return NumberOfIdEntries value of the node.
	**/
	std::uint16_t ResourceNode::getNumberOfIdEntries() const
	{
		return header.NumberOfIdEntries;
	}

	/**
	* Sets the Characteristics value of the node.
	* @param value New Characteristics value of the node.
	**/
	void ResourceNode::setCharacteristics(std::uint32_t value)
	{
		header.Characteristics = value;
	}

	/**
	* Sets the TimeDateStamp value of the node.
	* @param value New TimeDateStamp value of the node.
	**/
	void ResourceNode::setTimeDateStamp(std::uint32_t value)
	{
		header.TimeDateStamp = value;
	}

	/**
	* Sets the MajorVersion value of the node.
	* @param value New MajorVersion value of the node.
	**/
	void ResourceNode::setMajorVersion(std::uint16_t value)
	{
		header.MajorVersion = value;
	}

	/**
	* Sets the MinorVersion value of the node.
	* @param value New MinorVersion value of the node.
	**/
	void ResourceNode::setMinorVersion(std::uint16_t value)
	{
		header.MinorVersion = value;
	}

	/**
	* Sets the NumberOfNamedEntries value of the node.
	* @param value New NumberOfNamedEntries value of the node.
	**/
	void ResourceNode::setNumberOfNamedEntries(std::uint16_t value)
	{
		header.NumberOfNamedEntries = value;
	}

	/**
	* Sets the NumberOfIdEntries value of the node.
	* @param value New NumberOfIdEntries value of the node.
	**/
	void ResourceNode::setNumberOfIdEntries(std::uint16_t value)
	{
		header.NumberOfIdEntries = value;
	}

/*	/// Returns the size of a resource node.
	unsigned int ResourceNode::size() const
	{
		if (children.size())
		{
			Log::debug() << std::accumulate(children.begin(), children.end(), 0, accumulate<ResourceChild>) << std::endl;
			return PELIB_IMAGE_RESOURCE_DIRECTORY::size()
					 + std::accumulate(children.begin(), children.end(), 0, accumulate<ResourceChild>);
		}
		else
		{
			return 0;
		}
	}
*/

	ResourceNode::ResourceNode() : ResourceElement()
	{

	}

	ResourceNode::~ResourceNode()
	{

	}

// -------------------------------------------------- ResourceDirectory -------------------------------------------

	/**
	* Constructor
	*/
	ResourceDirectory::ResourceDirectory() : m_readOffset(0), m_ldrError(LDR_ERROR_NONE)
	{

	}

	/**
	* Returns the root node of the resource directory.
	* @return Root node of the resource directory.
	**/
	ResourceNode* ResourceDirectory::getRoot()
	{
		return &m_rnRoot;
	}

	/**
	* Reads the resource directory from a file.
	* @param imageLoader image loader
	**/
	int ResourceDirectory::read(ImageLoader & imageLoader)
	{
		std::uint32_t resDirRva = imageLoader.getDataDirRva(PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE);
		std::uint32_t sizeOfImage = imageLoader.getSizeOfImage();

		return m_rnRoot.read(imageLoader, resDirRva, 0, sizeOfImage, this);
	}

	/**
	* Returns the root node of the resource directory.
	* @return Root node of the resource directory.
	**/
	const ResourceNode* ResourceDirectory::getRoot() const
	{
		return &m_rnRoot;
	}

	/**
	* Get the error that was detected during resource parsing
	**/
	LoaderError ResourceDirectory::loaderError() const
	{
		return m_ldrError;
	}

	void ResourceDirectory::setLoaderError(LoaderError ldrError)
	{
		// Do not override an existing error
		if (m_ldrError == LDR_ERROR_NONE)
		{
			m_ldrError = ldrError;
		}
	}

	/**
	* Correctly sorts the resource nodes of the resource tree. This function should be called
	* before calling rebuild.
	**/
	void ResourceDirectory::makeValid()
	{
		m_rnRoot.makeValid();
	}

	/**
	* Rebuilds the resource directory.
	* @param vBuffer Buffer the source directory will be written to.
	* @param uiRva RVA of the resource directory.
	**/
	void ResourceDirectory::rebuild(std::vector<std::uint8_t>& vBuffer, unsigned int uiRva) const
	{
		OutputBuffer obBuffer(vBuffer);
		unsigned int offs = 0;
//		Log::debug() << "Root: " << m_rnRoot.children.size() << std::endl;
		m_rnRoot.rebuild(obBuffer, offs, uiRva, "");
	}

	/**
	 * Recalculates the resource directory for directory with new RVA.
	 *
	 * @param uiNewSize The size of the new directory. Is recalculated after the whole resource tree is traversed.
	 * @param uiNewRva The RVA of the new directory.
	 */
	void ResourceDirectory::recalculate(unsigned int& uiNewSize, unsigned int uiNewRva)
	{
		uiNewSize = 0;
		m_rnRoot.recalculate(uiNewSize, uiNewRva);
	}

	/**
	* Returns the size of the entire rebuilt resource directory. That's the size of the entire
	* structure as it's written back to a file.
	**/
/*	unsigned int ResourceDirectory::size() const
	{
		return m_rnRoot.size();
	}
*/
	/**
	* Writes the current resource directory back into a file.
	* @param strFilename Name of the output file.
	* @param uiOffset File offset where the resource directory will be written to.
	* @param uiRva RVA of the file offset.
	**/
	int ResourceDirectory::write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);

		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer, uiRva);

		ofFile.write(reinterpret_cast<const char*>(vBuffer.data()), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();

		return ERROR_NONE;
	}

	/**
	* Adds another resource type. The new resource type is identified by the ID dwResTypeId.
	* @param dwResTypeId ID which identifies the resource type.
	**/
	int ResourceDirectory::addResourceType(std::uint32_t dwResTypeId)
	{
		std::vector<ResourceChild>::iterator Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& i) { return i.equalId(dwResTypeId); }
		);
		if (Iter != m_rnRoot.children.end())
		{
			return ERROR_DUPLICATE_ENTRY;
			// throw Exceptions::EntryAlreadyExists(ResourceDirectoryId, __LINE__);
		}

		ResourceChild rcCurr;
		rcCurr.child = new ResourceNode;
		rcCurr.entry.irde.Name = dwResTypeId;
		m_rnRoot.children.push_back(rcCurr);

		return ERROR_NONE;
	}

	/**
	* Adds another resource type. The new resource type is identified by the name strResTypeName.
	* @param strResTypeName Name which identifies the resource type.
	**/
	int ResourceDirectory::addResourceType(const std::string& strResTypeName)
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& i) { return i.equalName(strResTypeName); }
		);
		if (Iter != m_rnRoot.children.end())
		{
			return ERROR_DUPLICATE_ENTRY;
//			throw Exceptions::EntryAlreadyExists(ResourceDirectoryId, __LINE__);
		}

		ResourceChild rcCurr;
		rcCurr.entry.wstrName = strResTypeName;
		rcCurr.child = new ResourceNode;
		m_rnRoot.children.push_back(rcCurr);

		return ERROR_NONE;
	}

	/**
	* Removes the resource type identified by the ID dwResTypeId.
	* @param dwResTypeId ID which identifies the resource type.
	**/
	int ResourceDirectory::removeResourceType(std::uint32_t dwResTypeId)
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& i) { return i.equalId(dwResTypeId); }
		);
		if (Iter == m_rnRoot.children.end())
		{
			return ERROR_ENTRY_NOT_FOUND;
//			throw Exceptions::ResourceTypeDoesNotExist(ResourceDirectoryId, __LINE__);
		}

		bool isNamed = false;
		if (Iter->isNamedResource()) isNamed = true;

		m_rnRoot.children.erase(Iter);

		if (isNamed) m_rnRoot.header.NumberOfNamedEntries = static_cast<std::uint16_t>(m_rnRoot.children.size());
		else m_rnRoot.header.NumberOfIdEntries = static_cast<std::uint16_t>(m_rnRoot.children.size());

		return ERROR_NONE;
	}

	/**
	* Removes the resource type identified by the name strResTypeName.
	* @param strResTypeName Name which identifies the resource type.
	**/
	int ResourceDirectory::removeResourceType(const std::string& strResTypeName)
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& i) { return i.equalName(strResTypeName); }
		);
		if (Iter == m_rnRoot.children.end())
		{
			return ERROR_ENTRY_NOT_FOUND;
		//	throw Exceptions::ResourceTypeDoesNotExist(ResourceDirectoryId, __LINE__);
		}

		bool isNamed = false;
		if (Iter->isNamedResource()) isNamed = true;

		m_rnRoot.children.erase(Iter);

		if (isNamed) m_rnRoot.header.NumberOfNamedEntries = static_cast<std::uint16_t>(m_rnRoot.children.size());
		else m_rnRoot.header.NumberOfIdEntries = static_cast<std::uint16_t>(m_rnRoot.children.size());

		return ERROR_NONE;
	}

	/**
	* Removes the resource type identified by the index uiIndex.
	* @param uiIndex Index which identifies the resource type.
	**/
	int ResourceDirectory::removeResourceTypeByIndex(unsigned int uiIndex)
	{
		bool isNamed = false;
		if (m_rnRoot.children[uiIndex].isNamedResource()) isNamed = true;

		m_rnRoot.children.erase(m_rnRoot.children.begin() + uiIndex);

		if (isNamed) m_rnRoot.header.NumberOfNamedEntries = static_cast<std::uint16_t>(m_rnRoot.children.size());
		else m_rnRoot.header.NumberOfIdEntries = static_cast<std::uint16_t>(m_rnRoot.children.size());

		return ERROR_NONE;
	}

	/**
	* Adds another resource to the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param dwResTypeId ID of the resource type.
	* @param dwResId ID of the resource.
	**/
	int ResourceDirectory::addResource(std::uint32_t dwResTypeId, std::uint32_t dwResId)
	{
		ResourceChild rcCurr;
		rcCurr.entry.irde.Name = dwResId;
		return addResourceT(dwResTypeId, dwResId, rcCurr);
	}

	/**
	* Adds another resource to the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param dwResTypeId ID of the resource type.
	* @param strResName Name of the resource.
	**/
	int ResourceDirectory::addResource(std::uint32_t dwResTypeId, const std::string& strResName)
	{
		ResourceChild rcCurr;
		rcCurr.entry.wstrName = strResName;
		return addResourceT(dwResTypeId, strResName, rcCurr);
	}

	/**
	* Adds another resource to the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param strResTypeName Name of the resource type.
	* @param dwResId ID of the resource.
	**/
	int ResourceDirectory::addResource(const std::string& strResTypeName, std::uint32_t dwResId)
	{
		ResourceChild rcCurr;
		rcCurr.entry.irde.Name = dwResId;
		return addResourceT(strResTypeName, dwResId, rcCurr);
	}

	/**
	* Adds another resource to the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param strResTypeName Name of the resource type.
	* @param strResName Name of the resource.
	**/
	int ResourceDirectory::addResource(const std::string& strResTypeName, const std::string& strResName)
	{
		ResourceChild rcCurr;
		rcCurr.entry.wstrName = strResName;
		return addResourceT(strResTypeName, strResName, rcCurr);
	}

	/**
	* Removes a resource from the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param dwResTypeIndex ID of the resource type.
	* @param dwResId ID of the resource.
	**/
	int ResourceDirectory::removeResource(std::uint32_t dwResTypeIndex, std::uint32_t dwResId)
	{
		return removeResourceT(dwResTypeIndex, dwResId);
	}

	/**
	* Removes a resource from the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param dwResTypeIndex ID of the resource type.
	* @param strResName Name of the resource.
	**/
	int ResourceDirectory::removeResource(std::uint32_t dwResTypeIndex, const std::string& strResName)
	{
		return removeResourceT(dwResTypeIndex, strResName);
	}

	/**
	* Removes a resource from the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param strResTypeName Name of the resource type.
	* @param dwResId ID of the resource.
	**/
	int ResourceDirectory::removeResource(const std::string& strResTypeName, std::uint32_t dwResId)
	{
		return removeResourceT(strResTypeName, dwResId);
	}

	/**
	* Removes a resource from the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param strResTypeName Name of the resource type.
	* @param strResName Name of the resource.
	**/
	int ResourceDirectory::removeResource(const std::string& strResTypeName, const std::string& strResName)
	{
		return removeResourceT(strResTypeName, strResName);
	}

	/**
	* Returns start offset of resource directory in file.
	**/
	unsigned int ResourceDirectory::getOffset() const
	{
		return m_readOffset;
	}

	/**
	* Returns the number of resource types.
	**/
	unsigned int ResourceDirectory::getNumberOfResourceTypes() const
	{
		return static_cast<unsigned int>(m_rnRoot.children.size());
	}

	/**
	* Returns the ID of a resource type which was specified through an index.
	* The valid range of the parameter uiIndex is 0...getNumberOfResourceTypes() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiIndex Index which identifies a resource type.
	* @return The ID of the specified resource type.
	**/
	std::uint32_t ResourceDirectory::getResourceTypeIdByIndex(unsigned int uiIndex) const
	{
		return m_rnRoot.children[uiIndex].entry.irde.Name;
	}

	/**
	* Returns the name of a resource type which was specified through an index.
	* The valid range of the parameter uiIndex is 0...getNumberOfResourceTypes() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiIndex Index which identifies a resource type.
	* @return The name of the specified resource type.
	**/
	std::string ResourceDirectory::getResourceTypeNameByIndex(unsigned int uiIndex) const
	{
		return m_rnRoot.children[uiIndex].entry.wstrName;
	}

	/**
	* Converts the ID of a resource type to an index.
	* @param dwResTypeId ID of the resource type.
	* @return Index of that resource type.
	**/
	int ResourceDirectory::resourceTypeIdToIndex(std::uint32_t dwResTypeId) const
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& i) { return i.equalId(dwResTypeId); }
		);
		if (Iter == m_rnRoot.children.end()) return -1;
		return static_cast<unsigned int>(std::distance(m_rnRoot.children.begin(), Iter));
	}

	/**
	* Converts the name of a resource type to an index.
	* @param strResTypeName ID of the resource type.
	* @return Index of that resource type.
	**/
	int ResourceDirectory::resourceTypeNameToIndex(const std::string& strResTypeName) const
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& i) { return i.equalName(strResTypeName); }
		);
		if (Iter == m_rnRoot.children.end()) return -1;
		return static_cast<unsigned int>(std::distance(m_rnRoot.children.begin(), Iter));
	}

	/**
	* Returns the number of resources of a specific resource type.
	* @param dwId ID of the resource type.
	* @return Number of resources of resource type dwId.
	**/
	unsigned int ResourceDirectory::getNumberOfResources(std::uint32_t dwId) const
	{
//		std::vector<ResourceChild>::const_iterator IterD = m_rnRoot.children.begin();
//		Log::debug() << dwId << std::endl;
//		while (IterD != m_rnRoot.children.end())
//		{
//			Log::debug() << IterD->entry.irde.Name << std::endl;
//			++IterD;
//		}

		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& i) { return i.equalId(dwId); }
		);
		if (Iter == m_rnRoot.children.end())
		{
			return 0xFFFFFFFF;
		}
		else
		{
			ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
			return static_cast<unsigned int>(currNode->children.size());
		}
	}

	/**
	* Returns the number of resources of a specific resource type.
	* @param strResTypeName Name of the resource type.
	* @return Number of resources of resource type strResTypeName.
	**/
	unsigned int ResourceDirectory::getNumberOfResources(const std::string& strResTypeName) const
	{
		auto Iter = std::find_if(
				m_rnRoot.children.begin(),
				m_rnRoot.children.end(),
				[&](const auto& i) { return i.equalName(strResTypeName); }
		);
		if (Iter == m_rnRoot.children.end())
		{
			return 0xFFFFFFFF;
		}
		else
		{
			ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
			return static_cast<unsigned int>(currNode->children.size());
		}
	}

	/**
	* Returns the number of resources of a resource type which was specified through an index.
	* The valid range of the parameter uiIndex is 0...getNumberOfResourceTypes() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiIndex Index which identifies a resource type.
	* @return The number of resources of the specified resource type.
	**/
	unsigned int ResourceDirectory::getNumberOfResourcesByIndex(unsigned int uiIndex) const
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiIndex].child);
		return static_cast<unsigned int>(currNode->children.size());
	}

	/**
	* Gets the resource data of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceData(std::uint32_t dwResTypeId, std::uint32_t dwResId, std::vector<std::uint8_t>& data) const
	{
		getResourceDataT(dwResTypeId, dwResId, data);
	}

	/**
	* Gets the resource data of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceData(std::uint32_t dwResTypeId, const std::string& strResName, std::vector<std::uint8_t>& data) const
	{
		getResourceDataT(dwResTypeId, strResName, data);
	}

	/**
	* Gets the resource data of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceData(const std::string& strResTypeName, std::uint32_t dwResId, std::vector<std::uint8_t>& data) const
	{
		getResourceDataT(strResTypeName, dwResId, data);
	}

	/**
	* Gets the resource data of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceData(const std::string& strResTypeName, const std::string& strResName, std::vector<std::uint8_t>& data) const
	{
		getResourceDataT(strResTypeName, strResName, data);
	}

	/**
	* Gets the resource data of a specific resource by index.
	* The valid range of the parameter uiResTypeIndex is 0...getNumberOfResourceTypes() - 1.
	* The valid range of the parameter uiResIndex is 0...getNumberOfResources() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceDataByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::vector<std::uint8_t>& data) const
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		currNode = static_cast<ResourceNode*>(currNode->children[uiResIndex].child);
		ResourceLeaf* currLeaf = static_cast<ResourceLeaf*>(currNode->children[0].child);

		data.assign(currLeaf->m_data.begin(), currLeaf->m_data.end());
	}

	/**
	* Sets the resource data of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceData(std::uint32_t dwResTypeId, std::uint32_t dwResId, std::vector<std::uint8_t>& data)
	{
		setResourceDataT(dwResTypeId, dwResId, data);
	}

	/**
	* Sets the resource data of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceData(std::uint32_t dwResTypeId, const std::string& strResName, std::vector<std::uint8_t>& data)
	{
		setResourceDataT(dwResTypeId, strResName, data);
	}

	/**
	* Sets the resource data of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceData(const std::string& strResTypeName, std::uint32_t dwResId, std::vector<std::uint8_t>& data)
	{
		setResourceDataT(strResTypeName, dwResId, data);
	}

	/**
	* Sets the resource data of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceData(const std::string& strResTypeName, const std::string& strResName, std::vector<std::uint8_t>& data)
	{
		setResourceDataT(strResTypeName, strResName, data);
	}

	/**
	* Sets the resource data of a specific resource by index.
	* The valid range of the parameter uiResTypeIndex is 0...getNumberOfResourceTypes() - 1.
	* The valid range of the parameter uiResIndex is 0...getNumberOfResources() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceDataByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::vector<std::uint8_t>& data)
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		currNode = static_cast<ResourceNode*>(currNode->children[uiResIndex].child);
		ResourceLeaf* currLeaf = static_cast<ResourceLeaf*>(currNode->children[0].child);
		currLeaf->m_data.assign(data.begin(), data.end());
	}

	/**
	* Gets the ID of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @return ID of the specified resource.
	**/
	std::uint32_t ResourceDirectory::getResourceId(std::uint32_t dwResTypeId, const std::string& strResName) const
	{
		return getResourceIdT(dwResTypeId, strResName);
	}

	/**
	* Gets the ID of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @return ID of the specified resource.
	**/
	std::uint32_t ResourceDirectory::getResourceId(const std::string& strResTypeName, const std::string& strResName) const
	{
		return getResourceIdT(strResTypeName, strResName);
	}

	/**
	* Gets the ID of a specific resource by index.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @return ID of the specified resource.
	**/
	std::uint32_t ResourceDirectory::getResourceIdByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex) const
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		return currNode->children[uiResIndex].entry.irde.Name;
	}

	/**
	* Sets the ID of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param dwNewResId New ID of the resource.
	**/
	void ResourceDirectory::setResourceId(std::uint32_t dwResTypeId, std::uint32_t dwResId, std::uint32_t dwNewResId)
	{
		setResourceIdT(dwResTypeId, dwResId, dwNewResId);
	}

	/**
	* Sets the ID of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param dwNewResId New ID of the resource.
	**/
	void ResourceDirectory::setResourceId(std::uint32_t dwResTypeId, const std::string& strResName, std::uint32_t dwNewResId)
	{
		setResourceIdT(dwResTypeId, strResName, dwNewResId);
	}

	/**
	* Sets the ID of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param dwNewResId New ID of the resource.
	**/
	void ResourceDirectory::setResourceId(const std::string& strResTypeName, std::uint32_t dwResId, std::uint32_t dwNewResId)
	{
		setResourceIdT(strResTypeName, dwResId, dwNewResId);
	}

	/**
	* Sets the ID of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param dwNewResId New ID of the resource.
	**/
	void ResourceDirectory::setResourceId(const std::string& strResTypeName, const std::string& strResName, std::uint32_t dwNewResId)
	{
		setResourceIdT(strResTypeName, strResName, dwNewResId);
	}

	/**
	* Sets the ID of a specific resource by index.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @param dwNewResId New ID of the specified resource.
	**/
	void ResourceDirectory::setResourceIdByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::uint32_t dwNewResId)
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		currNode->children[uiResIndex].entry.irde.Name = dwNewResId;
	}

	/**
	* Gets the Name of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @return Name of the specified resource.
	**/
	std::string ResourceDirectory::getResourceName(std::uint32_t dwResTypeId, std::uint32_t dwResId) const
	{
		return getResourceNameT(dwResTypeId, dwResId);
	}

	/**
	* Gets the Name of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @return Name of the specified resource.
	**/
	std::string ResourceDirectory::getResourceName(const std::string& strResTypeName, std::uint32_t dwResId) const
	{
		return getResourceNameT(strResTypeName, dwResId);
	}

	/**
	* Gets the name of a specific resource by index.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @return Name of the specified resource.
	**/
	std::string ResourceDirectory::getResourceNameByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex) const
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		return currNode->children[uiResIndex].entry.wstrName;
	}

	/**
	* Sets the name of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceName(std::uint32_t dwResTypeId, std::uint32_t dwResId, const std::string& strNewResName)
	{
		setResourceNameT(dwResTypeId, dwResId, strNewResName);
	}

	/**
	* Sets the name of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceName(std::uint32_t dwResTypeId, const std::string& strResName, const std::string& strNewResName)
	{
		setResourceNameT(dwResTypeId, strResName, strNewResName);
	}

	/**
	* Sets the name of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceName(const std::string& strResTypeName, std::uint32_t dwResId, const std::string& strNewResName)
	{
		setResourceNameT(strResTypeName, dwResId, strNewResName);
	}

	/**
	* Sets the name of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceName(const std::string& strResTypeName, const std::string& strResName, const std::string& strNewResName)
	{
		setResourceNameT(strResTypeName, strResName, strNewResName);
	}

	/**
	* Sets the name of a specific resource by index.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceNameByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, const std::string& strNewResName)
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		currNode->children[uiResIndex].entry.wstrName = strNewResName;
	}

	/**
	* Insert offset of loaded node.
	* @param nodeOffset Offset of loaded node.
	*/
	void ResourceDirectory::insertNodeOffset(std::size_t nodeOffset)
	{
		m_resourceNodeOffsets.insert(nodeOffset);
	}

	/**
	* Check if node with specified offset was loaded.
	* @param nodeOffset Offset of node.
	*/
	bool ResourceDirectory::hasNodeOffset(std::size_t nodeOffset) const
	{
		return m_resourceNodeOffsets.find(nodeOffset) != m_resourceNodeOffsets.end();
	}

	void ResourceDirectory::addOccupiedAddressRange(unsigned int start, unsigned int end)
	{
		m_occupiedAddresses.emplace_back(start, end);
	}

	const std::vector<std::pair<unsigned int, unsigned int>>& ResourceDirectory::getOccupiedAddresses() const
	{
		return m_occupiedAddresses;
	}
}

```

`debug_remover/src/pelib/RichHeader.cpp`:

```cpp
/**
 * @file RichHeader.cpp
 * @brief Class for rich header.
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#include <cstring>
#include <sstream>
#include <iomanip>
#include <array>
#include <unordered_map>
#include <algorithm>

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/RichHeader.h"

namespace PeLib
{
	// Map of richHeaderProductId -> ProductName
	const std::vector<std::string> productNames =
	{
		"Import        (old)",      // 0x00
		"Import",                   // 0x01
		"Linker510",                // 0x02
		"Cvtomf510",                // 0x03
		"Linker600",                // 0x04
		"Cvtomf600",                // 0x05
		"Cvtres500",                // 0x06
		"Utc11_Basic",              // 0x07
		"Utc11_C",                  // 0x08
		"Utc12_Basic",              // 0x09
		"Utc12_C",                  // 0x0A
		"Utc12_CPP",                // 0x0B
		"AliasObj60",               // 0x0C
		"VisualBasic60",            // 0x0D
		"Masm613",                  // 0x0E
		"Masm710",                  // 0x0F
		"Linker511",                // 0x10
		"Cvtomf511",                // 0x11
		"Masm614",                  // 0x12
		"Linker512",                // 0x13
		"Cvtomf512",                // 0x14
		"Utc12_C_Std",              // 0x15
		"Utc12_CPP_Std",            // 0x16
		"Utc12_C_Book",             // 0x17
		"Utc12_CPP_Book",           // 0x18
		"Implib700",                // 0x19
		"Cvtomf700",                // 0x1A
		"Utc13_Basic",              // 0x1B
		"Utc13_C",                  // 0x1C
		"Utc13_CPP",                // 0x1D
		"Linker610",                // 0x1E
		"Cvtomf610",                // 0x1F
		"Linker601",                // 0x20
		"Cvtomf601",                // 0x21
		"Utc12_1_Basic",            // 0x22
		"Utc12_1_C",                // 0x23
		"Utc12_1_CPP",              // 0x24
		"Linker620",                // 0x25
		"Cvtomf620",                // 0x26
		"AliasObj70",               // 0x27
		"Linker621",                // 0x28
		"Cvtomf621",                // 0x29
		"Masm615",                  // 0x2A
		"Utc13_LTCG_C",             // 0x2B
		"Utc13_LTCG_CPP",           // 0x2C
		"Masm620",                  // 0x2D
		"ILAsm100",                 // 0x2E
		"Utc12_2_Basic",            // 0x2F
		"Utc12_2_C",                // 0x30
		"Utc12_2_CPP",              // 0x31
		"Utc12_2_C_Std",            // 0x32
		"Utc12_2_CPP_Std",          // 0x33
		"Utc12_2_C_Book",           // 0x34
		"Utc12_2_CPP_Book",         // 0x35
		"Implib622",                // 0x36
		"Cvtomf622",                // 0x37
		"Cvtres501",                // 0x38
		"Utc13_C_Std",              // 0x39
		"Utc13_CPP_Std",            // 0x3A
		"Cvtpgd1300",               // 0x3B
		"Linker622",                // 0x3C
		"Linker700",                // 0x3D
		"Export622",                // 0x3E
		"Export700",                // 0x3F
		"Masm700",                  // 0x40
		"Utc13_POGO_I_C",           // 0x41
		"Utc13_POGO_I_CPP",         // 0x42
		"Utc13_POGO_O_C",           // 0x43
		"Utc13_POGO_O_CPP",         // 0x44
		"Cvtres700",                // 0x45
		"Cvtres710p",               // 0x46
		"Linker710p",               // 0x47
		"Cvtomf710p",               // 0x48
		"Export710p",               // 0x49
		"Implib710p",               // 0x4A
		"Masm710p",                 // 0x4B
		"Utc1310p_C",               // 0x4C
		"Utc1310p_CPP",             // 0x4D
		"Utc1310p_C_Std",           // 0x4E
		"Utc1310p_CPP_Std",         // 0x4F
		"Utc1310p_LTCG_C",          // 0x50
		"Utc1310p_LTCG_CPP",        // 0x51
		"Utc1310p_POGO_I_C",        // 0x52
		"Utc1310p_POGO_I_CPP",      // 0x53
		"Utc1310p_POGO_O_C",        // 0x54
		"Utc1310p_POGO_O_CPP",      // 0x55
		"Linker624",                // 0x56
		"Cvtomf624",                // 0x57
		"Export624",                // 0x58
		"Implib624",                // 0x59
		"Linker710",                // 0x5A
		"Cvtomf710",                // 0x5B
		"Export710",                // 0x5C
		"Implib710",                // 0x5D
		"Cvtres710",                // 0x5E
		"Utc1310_C",                // 0x5F
		"Utc1310_CPP",              // 0x60
		"Utc1310_C_Std",            // 0x61
		"Utc1310_CPP_Std",          // 0x62
		"Utc1310_LTCG_C",           // 0x63
		"Utc1310_LTCG_CPP",         // 0x64
		"Utc1310_POGO_I_C",         // 0x65
		"Utc1310_POGO_I_CPP",       // 0x66
		"Utc1310_POGO_O_C",         // 0x67
		"Utc1310_POGO_O_CPP",       // 0x68
		"AliasObj710",              // 0x69
		"AliasObj710p",             // 0x6A
		"Cvtpgd1310",               // 0x6B
		"Cvtpgd1310p",              // 0x6C
		"Utc1400_C",                // 0x6D
		"Utc1400_CPP",              // 0x6E
		"Utc1400_C_Std",            // 0x6F
		"Utc1400_CPP_Std",          // 0x70
		"Utc1400_LTCG_C",           // 0x71
		"Utc1400_LTCG_CPP",         // 0x72
		"Utc1400_POGO_I_C",         // 0x73
		"Utc1400_POGO_I_CPP",       // 0x74
		"Utc1400_POGO_O_C",         // 0x75
		"Utc1400_POGO_O_CPP",       // 0x76
		"Cvtpgd1400",               // 0x77
		"Linker800",                // 0x78
		"Cvtomf800",                // 0x79
		"Export800",                // 0x7A
		"Implib800",                // 0x7B
		"Cvtres800",                // 0x7C
		"Masm800",                  // 0x7D
		"AliasObj800",              // 0x7E
		"PhoenixPrerelease",        // 0x7F
		"Utc1400_CVTCIL_C",         // 0x80
		"Utc1400_CVTCIL_CPP",       // 0x81
		"Utc1400_LTCG_MSIL",        // 0x82
		"Utc1500_C",                // 0x83
		"Utc1500_CPP",              // 0x84
		"Utc1500_C_Std",            // 0x85
		"Utc1500_CPP_Std",          // 0x86
		"Utc1500_CVTCIL_C",         // 0x87
		"Utc1500_CVTCIL_CPP",       // 0x88
		"Utc1500_LTCG_C",           // 0x89
		"Utc1500_LTCG_CPP",         // 0x8A
		"Utc1500_LTCG_MSIL",        // 0x8B
		"Utc1500_POGO_I_C",         // 0x8C
		"Utc1500_POGO_I_CPP",       // 0x8D
		"Utc1500_POGO_O_C",         // 0x8E
		"Utc1500_POGO_O_CPP",       // 0x8F
		"Cvtpgd1500",               // 0x90
		"Linker900",                // 0x91
		"Export900",                // 0x92
		"Implib900",                // 0x93
		"Cvtres900",                // 0x94
		"Masm900",                  // 0x95
		"AliasObj900",              // 0x96
		"Resource",                 // 0x97
		"AliasObj1000",             // 0x98
		"Cvtpgd1600",               // 0x99
		"Cvtres1000",               // 0x9A
		"Export1000",               // 0x9B
		"Implib1000",               // 0x9C
		"Linker1000",               // 0x9D
		"Masm1000",                 // 0x9E
		"Phx1600_C",                // 0x9F
		"Phx1600_CPP",              // 0xA0
		"Phx1600_CVTCIL_C",         // 0xA1
		"Phx1600_CVTCIL_CPP",       // 0xA2
		"Phx1600_LTCG_C",           // 0xA3
		"Phx1600_LTCG_CPP",         // 0xA4
		"Phx1600_LTCG_MSIL",        // 0xA5
		"Phx1600_POGO_I_C",         // 0xA6
		"Phx1600_POGO_I_CPP",       // 0xA7
		"Phx1600_POGO_O_C",         // 0xA8
		"Phx1600_POGO_O_CPP",       // 0xA9
		"Utc1600_C",                // 0xAA
		"Utc1600_CPP",              // 0xAB
		"Utc1600_CVTCIL_C",         // 0xAC
		"Utc1600_CVTCIL_CPP",       // 0xAD
		"Utc1600_LTCG_C",           // 0xAE
		"Utc1600_LTCG_CPP",         // 0xAF
		"Utc1600_LTCG_MSIL",        // 0xB0
		"Utc1600_POGO_I_C",         // 0xB1
		"Utc1600_POGO_I_CPP",       // 0xB2
		"Utc1600_POGO_O_C",         // 0xB3
		"Utc1600_POGO_O_CPP",       // 0xB4
		"AliasObj1010",             // 0xB5
		"Cvtpgd1610",               // 0xB6
		"Cvtres1010",               // 0xB7
		"Export1010",               // 0xB8
		"Implib1010",               // 0xB9
		"Linker1010",               // 0xBA
		"Masm1010",                 // 0xBB
		"Utc1610_C",                // 0xBC
		"Utc1610_CPP",              // 0xBD
		"Utc1610_CVTCIL_C",         // 0xBE
		"Utc1610_CVTCIL_CPP",       // 0xBF
		"Utc1610_LTCG_C",           // 0xC0
		"Utc1610_LTCG_CPP",         // 0xC1
		"Utc1610_LTCG_MSIL",        // 0xC2
		"Utc1610_POGO_I_C",         // 0xC3
		"Utc1610_POGO_I_CPP",       // 0xC4
		"Utc1610_POGO_O_C",         // 0xC5
		"Utc1610_POGO_O_CPP",       // 0xC6
		"AliasObj1100",             // 0xC7
		"Cvtpgd1700",               // 0xC8
		"Cvtres1100",               // 0xC9
		"Export1100",               // 0xCA
		"Implib1100",               // 0xCB
		"Linker1100",               // 0xCC
		"Masm1100",                 // 0xCD
		"Utc1700_C",                // 0xCE
		"Utc1700_CPP",              // 0xCF
		"Utc1700_CVTCIL_C",         // 0xD0
		"Utc1700_CVTCIL_CPP",       // 0xD1
		"Utc1700_LTCG_C",           // 0xD2
		"Utc1700_LTCG_CPP",         // 0xD3
		"Utc1700_LTCG_MSIL",        // 0xD4
		"Utc1700_POGO_I_C",         // 0xD5
		"Utc1700_POGO_I_CPP",       // 0xD6
		"Utc1700_POGO_O_C",         // 0xD7
		"Utc1700_POGO_O_CPP",       // 0xD8
		"AliasObj1200",             // 0xD9
		"Cvtpgd1800",               // 0xDA
		"Cvtres1200",               // 0xDB
		"Export1200",               // 0xDC
		"Implib1200",               // 0xDD
		"Linker1200",               // 0xDE
		"Masm1200",                 // 0xDF
		"Utc1800_C",                // 0xE0
		"Utc1800_CPP",              // 0xE1
		"Utc1800_CVTCIL_C",         // 0xE2
		"Utc1800_CVTCIL_CPP",       // 0xE3
		"Utc1800_LTCG_C",           // 0xE4
		"Utc1800_LTCG_CPP",         // 0xE5
		"Utc1800_LTCG_MSIL",        // 0xE6
		"Utc1800_POGO_I_C",         // 0xE7
		"Utc1800_POGO_I_CPP",       // 0xE8
		"Utc1800_POGO_O_C",         // 0xE9
		"Utc1800_POGO_O_CPP",       // 0xEA
		"AliasObj1210",             // 0xEB
		"Cvtpgd1810",               // 0xEC
		"Cvtres1210",               // 0xED
		"Export1210",               // 0xEE
		"Implib1210",               // 0xEF
		"Linker1210",               // 0xF0
		"Masm1210",                 // 0xF1
		"Utc1810_C",                // 0xF2
		"Utc1810_CPP",              // 0xF3
		"Utc1810_CVTCIL_C",         // 0xF4
		"Utc1810_CVTCIL_CPP",       // 0xF5
		"Utc1810_LTCG_C",           // 0xF6
		"Utc1810_LTCG_CPP",         // 0xF7
		"Utc1810_LTCG_MSIL",        // 0xF8
		"Utc1810_POGO_I_C",         // 0xF9
		"Utc1810_POGO_I_CPP",       // 0xFA
		"Utc1810_POGO_O_C",         // 0xFB
		"Utc1810_POGO_O_CPP",       // 0xFC
		"AliasObj1400",             // 0xFD
		"Cvtpgd1900",               // 0xFE
		"Cvtres1400",               // 0xFF
		"Export1400",               // 0x100
		"Implib1400",               // 0x101
		"Linker1400",               // 0x102
		"Masm1400",                 // 0x103
		"Utc1900_C",                // 0x104
		"Utc1900_CPP",              // 0x105
		"Utc1900_CVTCIL_C",         // 0x106
		"Utc1900_CVTCIL_CPP",       // 0x107
		"Utc1900_LTCG_C",           // 0x108
		"Utc1900_LTCG_CPP",         // 0x109
		"Utc1900_LTCG_MSIL",        // 0x10A
		"Utc1900_POGO_I_C",         // 0x10B
		"Utc1900_POGO_I_CPP",       // 0x10C
		"Utc1900_POGO_O_C",         // 0x10D
		"Utc1900_POGO_O_CPP"        // 0x10E
	};

	// Array of visualStudioNameIndex -> name of Visual Studio
	const std::vector<std::string> visualStudioNames =
	{
		".NET Framework",               //  0
		".NET Core",                    //  1
		"Visual Studio 5.0 CvtRes.exe", //  2
		"Visual C++ 5.0",               //  3
		"Visual Studio 6.0",            //  4
		"Visual Basic 6.0",             //  5
		"Visual C++ 6.0",               //  6
		"Visual Studio 6.0 MASM",       //  7
		"Visual C++ 2002",              //  8
		"Visual C++ 2003",              //  9
		"Visual Studio 2005",           // 10
		"Visual Studio 2008",           // 11
		"Visual Studio 2010",           // 12
		"Visual C++ 2012",              // 13
		"Visual Studio 2012 MASM",      // 14
		"Visual C++ 2013",              // 15
		"Visual Studio 2013",           // 16
		"Visual C++ 2015",              // 17
		"Visual Studio 2015",           // 18
		"Visual C++ 2017",              // 19
		"Visual Studio 2017",           // 20
		"Visual C++ 2019",              // 21
		"Visual Studio 2019"            // 22
	};

	// Array of index -> Visual Studio Version
	const std::vector<std::string> visualStudioNames2 =
	{
		"Visual Studio 2003 v7.10",
		"Visual Studio 2005 v8.0",
		"Visual Studio 2008 v9.0",
		"",
		"Visual Studio 2010 v10.0",
		"Visual Studio 2010 v10.10",
		"Visual Studio 2012 v11.0",
		"Visual Studio 2013 v12.0",
		"Visual Studio 2013 v12.10",
		"Visual Studio 2015+"
	};

	// Key: Build number from RichHeader
	// Value: Pair of { visualStudioNameIndex, visualStudioVersionString }
 const std::unordered_map<size_t, std::pair<size_t, std::string>> visualStudioVersionMap
	{
		{  2204, {  0, "1.0 beta 1"             } }, //   0
		{  2914, {  0, "1.0 beta 2"             } }, //   1
		{  3512, {  0, "1.0 RC3"                } }, //   2
		{  3705, {  0, "1.0"                    } }, //   3
		{  4322, {  0, "1.1"                    } }, //   4
		{ 21213, {  0, "1.2 pre-alpha"          } }, //   5
		{ 30703, {  0, "1.2 alpha",             } }, //   6
		{ 40301, {  0, "2.0"                    } }, //   7
		{ 40426, {  0, "2.0"                    } }, //   8
		{ 40607, {  0, "2.0"                    } }, //   9
		{ 40903, {  0, "2.0"                    } }, //  10
		{ 41115, {  0, "2.0"                    } }, //  11
		{ 50110, {  0, "2.0"                    } }, //  12
		{ 50215, {  0, "2.0"                    } }, //  13
		{ 50601, {  0, "2.0"                    } }, //  14
		{ 50710, {  0, "4.5"                    } }, //  15
		{ 50932, {  0, "4.5.1"                  } }, //  16
		{ 50938, {  0, "4.5.1"                  } }, //  17
		{ 51090, {  0, "4.5.2"                  } }, //  18
		{ 51209, {  0, "4.5.2"                  } }, //  19
		{ 51641, {  0, "4.5.1"                  } }, //  20
		{ 51651, {  0, "4.5.2"                  } }, //  21
		{  1055, {  0, "4.6"                    } }, //  22
		{ 23902, {  1, "5.0"                    } }, //  23
		{  1668, {  2, "5.0"                    } }, //  24
		{  1720, {  2, "5.0"                    } }, //  25
		{  1735, {  2, "5.0"                    } }, //  26
		{  1803, {  2, "5.0"                    } }, //  27
		{  2080, {  2, "5.0"                    } }, //  28
		{  2090, {  2, "5.0"                    } }, //  29
		{  7008, {  3, "5.0"                    } }, //  30
		{  7022, {  3, "5.0 SP0"                } }, //  31
		{  7132, {  3, "5.2 SP1"                } }, //  32
		{  7274, {  3, "5.10 SP3"               } }, //  33
		{  7303, {  3, "5.10 SP3"               } }, //  34
		{  8022, {  3, "5.12"                   } }, //  35
		{  8034, {  3, "5.12"                   } }, //  36
		{  8078, {  3, "5.12"                   } }, //  37
		{  8124, {  3, "5.12"                   } }, //  38
		{  8152, {  3, "5.12"                   } }, //  39
		{  9049, {  3, "5.12"                   } }, //  40
		{  7291, {  4, "6.0"                    } }, //  41
		{  8041, {  5, "5.0"                    } }, //  42
		{  8047, {  6, "6.0"                    } }, //  43
		{  8167, {  4, "6.0"                    } }, //  44
		{  8168, {  4, "6.0"                    } }, //  45
		{  8169, {  4, "6.0"                    } }, //  46
		{  8349, {  6, "6.0"                    } }, //  47
		{  8350, {  6, "6.0"                    } }, //  48
		{  8397, {  6, "6.0"                    } }, //  49
		{  8447, {  6, "6.0 SP3"                } }, //  50
		{  8495, {  4, "6.0 SP3"                } }, //  51
		{  8569, {  6, "6.0 SP3"                } }, //  52
		{  8755, {  6, "6.0 SP3"                } }, //  53
		{  8769, {  6, "6.0 SP3"                } }, //  54
		{  8783, {  5, "5.0"                    } }, //  55
		{  8797, {  6, "6.0 SP4"                } }, //  56
		{  8798, {  6, "6.0 SP4"                } }, //  57
		{  8799, {  6, "6.0 SP4"                } }, //  58
		{  8804, {  6, "6.0 SP4"                } }, //  59
		{  8877, {  4, "6.0 SP4"                } }, //  60
		{  8943, {  6, "6.0 SP5 Processor Pack" } }, //  61
		{  8964, {  4, "6.0 SP5"                } }, //  62
		{  8966, {  6, "6.0 SP5"                } }, //  63
		{  9044, {  6, "6.0 SP5 Processor Pack" } }, //  64
		{  9738, {  4, "6.0 SP6"                } }, //  65
		{  9782, {  4, "6.0 SP6"                } }, //  66
		{  7299, {  7, "6.13 SP1"               } }, //  67
		{  8444, {  7, "6.14 SP3"               } }, //  68
		{  8803, {  7, "6.15 SP4"               } }, //  69
		{  8905, {  7, "6.15 SP4"               } }, //  70
		{  8491, {  8, "7.0"                    } }, //  71
		{  8800, {  8, "7.0"                    } }, //  72
		{  8830, {  8, "7.0"                    } }, //  73
		{  9030, {  8, "7.0 beta 1"             } }, //  74
		{  9037, {  8, "7.0"                    } }, //  75
		{  9043, {  8, "7.0"                    } }, //  76
		{  9111, {  8, "7.0"                    } }, //  77
		{  9162, {  8, "7.0"                    } }, //  78
		{  9177, {  8, "7.0"                    } }, //  79
		{  9178, {  8, "7.0"                    } }, //  80
		{  9210, {  8, "7.0 XP DDK"             } }, //  81
		{  9254, {  8, "7.0 beta 2"             } }, //  82
		{  9372, {  8, "7.0 RC1"                } }, //  83
		{  9466, {  8, "7.0"                    } }, //  84
		{  9955, {  8, "7.0 SP1"                } }, //  85
		{  2035, {  9, "7.10 beta"              } }, //  86
		{  2067, {  9, "7.10 beta"              } }, //  87
		{  2179, {  9, "7.10"                   } }, //  88
		{  2190, {  9, "7.10"                   } }, //  89
		{  2197, {  9, "7.10"                   } }, //  90
		{  2241, {  9, "7.10"                   } }, //  91
		{  3052, {  9, "7.10 Free Toolkit"      } }, //  92
		{  3077, {  9, "7.10"                   } }, //  93
		{  3088, {  9, "7.10"                   } }, //  94
		{  3310, {  9, "7.10"                   } }, //  95
		{  4017, {  9, "7.10"                   } }, //  96
		{  4031, {  9, "7.10 SDK"               } }, //  97
		{  4035, {  9, "7.10 SDK"               } }, //  98
		{  6030, {  9, "7.10 SP1"               } }, //  99
		{  6101, {  9, "7.10 SP1"               } }, // 100
		{ 30120, { 10, "8.0"                    } }, // 101
		{ 30701, { 10, "8.0"                    } }, // 102
		{ 31008, { 10, "8.0"                    } }, // 103
		{ 40310, { 10, "8.0 SDK"                } }, // 104
		{ 41204, { 10, "8.0"                    } }, // 105
		{ 50327, { 10, "8.0"                    } }, // 106
		{ 50608, { 10, "8.0"                    } }, // 107
		{ 50706, { 10, "8.0"                    } }, // 108
		{ 50727, { 10, "8.0"                    } }, // 109
		{ 60516, { 10, "8.0"                    } }, // 110
		{ 61001, { 10, "8.0 SP1 MFC Update"     } }, // 111
		{ 20413, { 11, "9.0"                    } }, // 112
		{ 21022, { 11, "9.0"                    } }, // 113
		{ 30718, { 11, "9.0"                    } }, // 114
		{ 30729, { 11, "9.0"                    } }, // 115
		{ 20115, { 12, "10.0"                   } }, // 116
		{ 21202, { 12, "10.0"                   } }, // 117
		{ 30311, { 12, "10.0"                   } }, // 118
		{ 30314, { 12, "10.0"                   } }, // 119
		{ 30319, { 12, "10.0"                   } }, // 120
		{ 30414, { 12, "10.0"                   } }, // 121
		{ 30716, { 12, "10.10 SP1"              } }, // 122
		{ 31118, { 12, "10.10 SP1"              } }, // 123
		{ 40219, { 12, "10.10 SP1"              } }, // 124
		{ 41118, { 13, "11.0"                   } }, // 125
		{ 50307, { 13, "11.0"                   } }, // 126
		{ 50323, { 13, "11.0"                   } }, // 127
		{ 50413, { 13, "11.0"                   } }, // 128
		{ 50522, { 13, "11.0"                   } }, // 129
		{ 50425, { 13, "11.0"                   } }, // 130
		{ 50503, { 13, "11.0"                   } }, // 131
		{ 50531, { 13, "11.0"                   } }, // 132
		{ 50612, { 13, "11.0"                   } }, // 133
		{ 50628, { 13, "11.0"                   } }, // 134
		{ 50709, { 13, "11.0"                   } }, // 135
		{ 50722, { 13, "11.0"                   } }, // 136
		{ 50727, { 13, "11.0"                   } }, // 137
		{ 50929, { 13, "11.0"                   } }, // 138
		{ 51016, { 13, "11.0"                   } }, // 139
		{ 51020, { 13, "11.0.1"                 } }, // 140
		{ 51106, { 13, "11.0.1"                 } }, // 141
		{ 51114, { 13, "11.0.2"                 } }, // 142
		{ 51204, { 13, "11.0.2"                 } }, // 143
		{ 60610, { 13, "11.0.3"                 } }, // 144
		{ 60930, { 14, "11.0"                   } }, // 145
		{ 60315, { 13, "11.0.2"                 } }, // 146
		{ 61030, { 13, "11.0.4"                 } }, // 147
		{ 61219, { 13, "11.0.5"                 } }, // 148
		{ 61232, { 13, "11.0"                   } }, // 149
		{ 65500, { 13, "11.0"                   } }, // 150
		{ 65501, { 13, "11.0"                   } }, // 151
		{ 20322, { 15, "12.0"                   } }, // 152
		{ 20403, { 15, "12.0"                   } }, // 153
		{ 20501, { 15, "12.0"                   } }, // 154
		{ 20617, { 15, "12.0"                   } }, // 155
		{ 20806, { 15, "12.0"                   } }, // 156
		{ 21005, { 15, "12.0 RTM"               } }, // 157
		{ 30102, { 15, "12.10"                  } }, // 158
		{ 40115, { 15, "12.10"                  } }, // 159
		{ 40116, { 15, "12.10"                  } }, // 160
		{ 40649, { 15, "12.0"                   } }, // 161
		{ 40660, { 15, "12.0"                   } }, // 162
		{ 40664, { 15, "12.0"                   } }, // 163
		{ 30110, { 16, "12.0.1"                 } }, // 164
		{ 30324, { 16, "12.0.2"                 } }, // 165
		{ 30501, { 16, "12.0.2"                 } }, // 166
		{ 30723, { 16, "12.0.3"                 } }, // 167
		{ 31101, { 16, "12.0.4"                 } }, // 168
		{ 40629, { 16, "12.0.5"                 } }, // 169
		{ 23007, { 17, "14.0"                   } }, // 170
		{ 23013, { 17, "14.0"                   } }, // 171
		{ 23026, { 17, "14.0"                   } }, // 172
		{ 23406, { 17, "14.0"                   } }, // 173
		{ 23524, { 17, "14.0"                   } }, // 174
		{ 23615, { 17, "14.0"                   } }, // 175
		{ 23506, { 17, "14.0.1"                 } }, // 176
		{ 23907, { 17, "14.0.1"                 } }, // 177
		{ 23917, { 17, "14.0 preview 2"         } }, // 178
		{ 23918, { 17, "14.0.2"                 } }, // 179
		{ 23927, { 17, "14.0.2"                 } }, // 180
		{ 24123, { 17, "14.0.3 RC"              } }, // 181
		{ 24210, { 17, "14.0.3"                 } }, // 182
		{ 24212, { 17, "14.0.3.b"               } }, // 183
		{ 24213, { 17, "14.0.3.d"               } }, // 184
		{ 24215, { 17, "14.0.3.d"               } }, // 185
		{ 24218, { 17, "14.0.3.d"               } }, // 186
		{ 24225, { 17, "14.0.3.d"               } }, // 187
		{ 24231, { 17, "14.0.3.d"               } }, // 188
		{ 24233, { 17, "14.0.3.d"               } }, // 189
		{ 24234, { 17, "14.0.3.d"               } }, // 190
		{ 24406, { 17, "14.0 preview 4"         } }, // 191
		{ 24425, { 17, "14.0 TFS Test VMs"      } }, // 192
		{ 22823, { 18, "14.0 RC"                } }, // 193
		{ 23107, { 18, "14.0"                   } }, // 194
		{ 24019, { 18, "14.0"                   } }, // 195
		{ 24116, { 18, "14.0"                   } }, // 196
		{ 24325, { 18, "14.0"                   } }, // 197
		{ 24610, { 18, "14.0"                   } }, // 198
		{ 24720, { 18, "14.0.1"                 } }, // 199
		{ 24723, { 18, "14.0.1.a"               } }, // 200
		{ 24728, { 18, "14.0.1.b"               } }, // 201
		{ 24730, { 18, "14.0.1.c"               } }, // 202
		{ 25025, { 18, "14.0"                   } }, // 203
		{ 25123, { 18, "14.0.2"                 } }, // 204
		{ 25125, { 18, "14.0.2"                 } }, // 205
		{ 25126, { 18, "14.0.2.a"               } }, // 206
		{ 25130, { 18, "14.0.2.b"               } }, // 207
		{ 25131, { 18, "14.0.2.b"               } }, // 208
		{ 25132, { 18, "14.0.2.c"               } }, // 209
		{ 25203, { 18, "14.0"                   } }, // 210
		{ 25224, { 18, "14.0"                   } }, // 211
		{ 25305, { 18, "14.0"                   } }, // 212
		{ 25420, { 18, "14.0.3"                 } }, // 213
		{ 25421, { 18, "14.0.3"                 } }, // 214
		{ 25422, { 18, "14.0.3.a"               } }, // 215
		{ 25424, { 18, "14.0.3.b"               } }, // 216
		{ 25425, { 18, "14.0.3.c"               } }, // 217
		{ 25431, { 18, "14.0.3.d"               } }, // 218
		{ 24629, { 19, "14.10 RC"               } }, // 219
		{ 25008, { 19, "14.10"                  } }, // 220
		{ 25017, { 19, "14.10"                  } }, // 221
		{ 25019, { 19, "14.10"                  } }, // 222
		{ 25508, { 19, "14.11"                  } }, // 223
		{ 25547, { 19, "14.11"                  } }, // 224
		{ 25711, { 19, "14.12"                  } }, // 225
		{ 26128, { 19, "14.12"                  } }, // 226
		{ 26131, { 19, "14.13"                  } }, // 227
		{ 26213, { 19, "14.13"                  } }, // 228
		{ 26706, { 19, "14.15"                  } }, // 229
		{ 26715, { 19, "14.15"                  } }, // 230
		{ 26726, { 19, "14.15"                  } }, // 231
		{ 27023, { 19, "14.16"                  } }, // 232
		{ 27024, { 19, "14.16"                  } }, // 233
		{ 27026, { 19, "14.16"                  } }, // 234
		{ 27027, { 19, "14.16"                  } }, // 235
		{ 27030, { 19, "14.16"                  } }, // 236
		{ 27031, { 19, "14.16"                  } }, // 237
		{ 27034, { 19, "14.16"                  } }, // 238
		{ 26304, { 20, "15.0.0 preview 1"       } }, // 239
		{ 26501, { 20, "15.0 Office tools"      } }, // 240
		{ 26504, { 20, "15.0"                   } }, // 241
		{ 26315, { 20, "15.0.0 preview 2"       } }, // 242
		{ 26323, { 20, "15.0.0 preview 3"       } }, // 243
		{ 26228, { 20, "15.0.x"                 } }, // 244
		{ 26403, { 20, "15.1.x"                 } }, // 245
		{ 26412, { 20, "15.2.0 preview 1"       } }, // 246
		{ 26419, { 20, "15.2.0 preview 2"       } }, // 247
		{ 26424, { 20, "15.2.0 preview 3"       } }, // 248
		{ 26430, { 20, "15.2.x"                 } }, // 249
		{ 26507, { 20, "15.3.0 preview 1"       } }, // 250
		{ 26510, { 20, "15.3.0 preview 1.1"     } }, // 251
		{ 26606, { 20, "15.3.0 preview 2"       } }, // 252
		{ 26608, { 20, "15.3.0 preview 2.1"     } }, // 253
		{ 26621, { 20, "15.3.0 preview 3"       } }, // 254
		{ 26711, { 20, "15.3.0 preview 4"       } }, // 255
		{ 26720, { 20, "15.3.0 preview 5"       } }, // 256
		{ 26724, { 20, "15.3.0 preview 6"       } }, // 257
		{ 26730, { 20, "15.3.x"                 } }, // 258
		{ 26732, { 20, "15.3.x"                 } }, // 259
		{ 26823, { 20, "15.4.0 preview 1"       } }, // 260
		{ 26906, { 20, "15.4.0 preview 2"       } }, // 261
		{ 26923, { 20, "15.4.0 preview 3"       } }, // 262
		{ 26929, { 20, "15.4.0 preview 4"       } }, // 263
		{ 27004, { 20, "15.4.x"                 } }, // 264
		{ 27009, { 20, "15.5.0 preview 1"       } }, // 265
		{ 27019, { 20, "15.5.0 preview 2"       } }, // 266
		{ 27102, { 20, "15.5.0 preview 3"       } }, // 267
		{ 27110, { 20, "15.5.0 preview 4"       } }, // 268
		{ 27128, { 20, "15.5.0 preview 5"       } }, // 269
		{ 27130, { 20, "15.5.x"                 } }, // 270
		{ 27205, { 20, "15.6.0 preview 1"       } }, // 271
		{ 27207, { 20, "15.0 MSI tools"         } }, // 272
		{ 27309, { 20, "15.6.0 preview 2"       } }, // 273
		{ 27323, { 20, "15.6.0 preview 3"       } }, // 274
		{ 27406, { 20, "15.6.0 preview 4"       } }, // 275
		{ 27413, { 20, "15.6.0 preview 5"       } }, // 276
		{ 27421, { 20, "15.6.0 preview 6"       } }, // 277
		{ 27428, { 20, "15.6.x"                 } }, // 278
		{ 27512, { 20, "15.7.0 preview 1"       } }, // 279
		{ 27520, { 20, "15.7.0 preview 2"       } }, // 280
		{ 27604, { 20, "15.7.0 preview 3"       } }, // 281
		{ 27617, { 20, "15.7.0 preview 4"       } }, // 282
		{ 27625, { 20, "15.7.0 preview 5"       } }, // 283
		{ 27701, { 20, "15.7.0 preview 6"       } }, // 284
		{ 27703, { 20, "15.7.x"                 } }, // 285
		{ 27705, { 20, "15.8.0 preview 1"       } }, // 286
		{ 27729, { 20, "15.8.0 preview 2"       } }, // 287
		{ 27825, { 20, "15.8.0 preview 3"       } }, // 288
		{ 27906, { 20, "15.8.0 preview 4"       } }, // 289
		{ 27924, { 20, "15.8.0 preview 5"       } }, // 290
		{ 28010, { 20, "15.8.x"                 } }, // 291
		{ 28016, { 20, "15.9.0 preview 1"       } }, // 292
		{ 28107, { 20, "15.9.0 preview 2"       } }, // 293
		{ 28128, { 20, "15.9.0 preview 3"       } }, // 294
		{ 28219, { 20, "15.9.0 preview 4"       } }, // 295
		{ 28302, { 20, "15.9.0 preview 5"       } }, // 296
		{ 28307, { 20, "15.9.x"                 } }, // 297
		{ 27706, { 21, "14.22"                  } }, // 298
		{ 27724, { 21, "14.22"                  } }, // 299
		{ 27807, { 21, "14.22"                  } }, // 300
		{ 27812, { 21, "14.22"                  } }, // 301
		{ 27821, { 21, "14.22"                  } }, // 302
		{ 27905, { 21, "14.22"                  } }, // 303
		{ 28117, { 21, "14.24"                  } }, // 304
		{ 28329, { 22, "16.0.0 preview 1"       } }, // 305
		{ 28408, { 22, "16.0.0 preview 1.1"     } }, // 306
		{ 28522, { 22, "16.0.0 preview 2"       } }, // 307
		{ 28529, { 22, "16.0.0 preview 2.1"     } }, // 308
		{ 28602, { 22, "16.0.0 preview 2.2"     } }, // 309
		{ 28608, { 22, "16.0.0 preview 3"       } }, // 310
		{ 28625, { 22, "16.0.0 preview 4"       } }, // 311
		{ 28701, { 22, "16.0.0 preview 4.1"     } }, // 312
		{ 28705, { 22, "16.0.0 preview 4.1.1"   } }, // 313
		{ 28711, { 22, "16.0.0 preview 4.2"     } }, // 314
		{ 28714, { 22, "16.0.0 preview 4.3"     } }, // 315
		{ 28721, { 22, "16.0.0 preview 4.4"     } }, // 316
		{ 28729, { 22, "16.0.0"                 } }, // 317
		{ 28803, { 22, "16.0.x"                 } }, // 318
		{ 28809, { 22, "16.1.0 preview 1"       } }, // 319
		{ 28822, { 22, "16.1.0 preview 2"       } }, // 320
		{ 28902, { 22, "16.1.0 preview 3"       } }, // 321
		{ 28917, { 22, "16.1.0"                 } }, // 322
		{ 28922, { 22, "16.1.1"                 } }, // 323
		{ 29001, { 22, "16.1.2"                 } }, // 324
		{ 29009, { 22, "16.1.3"                 } }, // 325
		{ 29020, { 22, "16.1.4"                 } }, // 326
		{ 29025, { 22, "16.1.5"                 } }, // 327
		{ 29102, { 22, "16.1.6"                 } }, // 328
		{ 29006, { 22, "16.2.0 preview 2"       } }, // 329
		{ 29021, { 22, "16.2.0 preview 3"       } }, // 330
		{ 29111, { 22, "16.2.0 preview 4"       } }, // 331
		{ 29123, { 22, "16.2.0"                 } }, // 332
		{ 29201, { 22, "16.2.1"                 } }, // 333
		{ 29209, { 22, "16.2.2"                 } }, // 334
		{ 29215, { 22, "16.2.3"                 } }, // 335
		{ 29230, { 22, "16.2.4"                 } }, // 336
		{ 29306, { 22, "16.2.5"                 } }, // 337
		{ 29311, { 22, "16.3.0 preview 4"       } }, // 338
		{ 29318, { 22, "16.3.0"                 } }, // 339
		{ 29324, { 22, "16.3.1"                 } }, // 340
		{ 29326, { 22, "16.3.2"                 } }, // 341
		{ 29403, { 22, "16.3.3"                 } }, // 342
		{ 29409, { 22, "16.3.4"                 } }, // 343
		{ 29411, { 22, "16.3.5"                 } }, // 344
		{ 29418, { 22, "16.3.6"                 } }, // 345
		{ 29424, { 22, "16.3.7"                 } }, // 346
		{ 29503, { 22, "16.3.8"                 } }, // 347
		{ 29509, { 22, "16.3.9"                 } }, // 348
		{ 29319, { 22, "16.4.0 preview 1"       } }, // 349
		{ 29430, { 22, "16.4.0 preview 3"       } }, // 350
		{ 29505, { 22, "16.4.0 preview 4"       } }, // 351
		{ 29512, { 22, "16.4.0 preview 5"       } }, // 352
		{ 29519, { 22, "16.4.0"                 } }, // 353
		{ 29609, { 22, "16.4.1"                 } }, // 354
		{ 29521, { 22, "16.5.0 preview 1"       } }  // 355
	};

namespace
{
	std::string makeSignature(std::uint32_t value)
	{
		std::stringstream signature;
		signature << std::hex << std::setfill('0') << std::setw(2 * sizeof(std::uint32_t)) << std::uppercase << value;
		return signature.str();
	}

	std::string makeSignature(std::uint32_t first, std::uint32_t second)
	{
		return makeSignature(first) + makeSignature(second);
	}
}

	RichHeader::RichHeader()
	{
		init();
	}

	RichHeader::~RichHeader()
	{

	}

	void RichHeader::init()
	{
		headerIsValid = false;
		validStructure = false;
		key = 0;
		noOfIters = 0;
		decryptedHeader.clear();
		records.clear();
	}

	void RichHeader::setValidStructure()
	{
		validStructure = (decryptedHeader.size() >= 4);
	}

	void RichHeader::getUserFriendlyProductName(PELIB_IMAGE_RICH_HEADER_RECORD & record)
	{
		// Product ID can be mapped to Product name 1:1. Just check if the ID is in range.
		record.ProductName = (record.ProductId < productNames.size()) ? productNames[record.ProductId] : "Unknown";

		// We can very well match build number to a Visual Studio build.
		// Exclude Visual Studio 2005 (v8.0), which has the same build number like Visual Studio 2012 (v11.0)
		// If the product ID is above 0x83, then it's clearly Visual Studio 2012.
		if (!(record.ProductId >= 0x83 && record.ProductBuild == 50727))
		{
			auto search = visualStudioVersionMap.find(record.ProductBuild);

			if (search != visualStudioVersionMap.end())
			{
				std::string VisualStudioName;

				// Get the name of the Visual Studio from the name index
				if (search->second.first < visualStudioNames.size())
					VisualStudioName = visualStudioNames[search->second.first];
				record.VisualStudioName = VisualStudioName + " v" + search->second.second;
			}
		}

		// If the Visual Studio was not known yet, estimate its version from the ProductID range
		if (record.VisualStudioName.empty())
		{
			std::array<uint32_t, 10> ProductIdRange = { 0x5A, 0x6D, 0x83, 0x97, 0x98, 0xB5, 0xC7, 0xD9, 0xEB, 0xFD };

			// Find the group by the product ID
			for (int index = ProductIdRange.size() - 1; index >= 0; index--)
			{
				if (record.ProductId >= ProductIdRange[index])
				{
					if (index < 9)
					{
						record.VisualStudioName = visualStudioNames2[index];
					}
					else
					{
						if (record.ProductBuild < 26304)
						{
							record.VisualStudioName = "Visual Studio 2015";
						}
						else if (record.ProductBuild < 28329)
						{
							record.VisualStudioName = "Visual Studio 2017";
						}
						else
						{
							record.VisualStudioName = "Visual Studio 2019+";
						}
					}
					break;
				}
			}
		}
	}

	/**
	 * @brief Checks if the decrypted header looks valid, if it does
	 *        then it analyses the header contents and saves it
	 *        into this->records
	 * 
	 * @param ignoreInvalidKey 
	 * @return true - the header looks valid
	 * @return false - header isn't valid
	 */
	bool RichHeader::analyze(bool ignoreInvalidKey)
	{
		bool hValid = true;
		size_t decSize = decryptedHeader.size();
		if (decSize < 4)
		{
			return false;
		}
		// Check if the start is "DanS" with 3 NULL
		// DWORDS padding into 16 byte paragraph
		else if (decryptedHeader[0] != 0x536e6144 ||
				decryptedHeader[1] != 0 ||
				decryptedHeader[2] != 0 ||
				decryptedHeader[3] != 0)
		{
			if (ignoreInvalidKey)
			{
				hValid = false;
			}
			else
			{
				return false;
			}
		}

		// Remember whether the header is valid
		headerIsValid = hValid;

		// Parse all products and their counts
		for (size_t i = 4; i + 1 < decSize; i += 2)
		{
			PELIB_IMAGE_RICH_HEADER_RECORD record;

			record.ProductId = (std::uint16_t)(decryptedHeader[i] >> 0x10);
			record.ProductBuild = (std::uint16_t)(decryptedHeader[i] & 0xFFFF);
			record.Count = decryptedHeader[i + 1];
			record.Signature = makeSignature(decryptedHeader[i], decryptedHeader[i + 1]);

			getUserFriendlyProductName(record);

			records.push_back(record);
		}

		return true;
	}

	void RichHeader::read(InputBuffer& inputbuffer, std::size_t uiSize, bool ignoreInvalidKey)
	{
		init();
		std::vector<std::uint32_t> rich;

		for (std::size_t i = 0, e = uiSize / sizeof(std::uint32_t); i < e; ++i)
		{
			std::uint32_t actInput;
			inputbuffer >> actInput;
			rich.push_back(actInput);
		}

		std::uint32_t sign[] = {0x68636952}; // "Rich"
		auto lastPos = rich.end();

		// try to find signature of rich header and key for decryption
		do
		{
			// Find the Rich header ending marker "Rich"
			auto richSignature = find_end(rich.begin(), lastPos, sign, sign + 1);
			if (richSignature == lastPos || richSignature + 1 == rich.end())
			{
				break;
			}

			lastPos = richSignature;
			key = *(richSignature + 1);
			decryptedHeader.clear();
			++noOfIters;

			// Start analyzing from the end - "Rich" marker
			// and move upwards to decrypted "DanS" marker
			for (auto it = std::make_reverse_iterator(richSignature); it < rich.rend(); ++it)
			{
				std::uint32_t decrypted_dword = *it ^ key;
				decryptedHeader.push_back(decrypted_dword);
				// "DanS" - 0x536e6144 signals the start (end) of the rich header
				if (decrypted_dword == 0x536e6144)
				{
					// Set the offset to "DanS"
					this->offset = std::distance(it + 1, rich.rend()) * 4;
					// Because we are analysing bottom up, reverse the vector
					std::reverse(decryptedHeader.begin(), decryptedHeader.end());
					break;
				}
			}
			setValidStructure();
		} while (!analyze());

		if (ignoreInvalidKey && noOfIters)
		{
			analyze(true);
		}
	}

	int RichHeader::read(
			std::istream& inStream,
			std::size_t uiOffset,
			std::size_t uiSize,
			bool ignoreInvalidKey)
	{
		IStreamWrapper inStream_w(inStream);

		if (!inStream_w)
		{
			return ERROR_OPENING_FILE;
		}

		const auto ulFileSize = fileSize(inStream_w);
		if (ulFileSize < uiOffset + uiSize)
		{
			return ERROR_INVALID_FILE;
		}

		inStream_w.seekg(uiOffset, std::ios::beg);
		std::vector<unsigned char> tableDump;
		tableDump.resize(uiSize);
		inStream_w.read(reinterpret_cast<char*>(tableDump.data()), uiSize);
		InputBuffer ibBuffer(tableDump);
		read(ibBuffer, uiSize, ignoreInvalidKey);

		return ERROR_NONE;
	}

	bool RichHeader::isHeaderValid() const
	{
		return headerIsValid;
	}

	bool RichHeader::isStructureValid() const
	{
		return validStructure;
	}

	std::uint64_t RichHeader::getOffset() const
	{
		return offset;
	}

	std::size_t RichHeader::getNumberOfIterations() const
	{
		return noOfIters;
	}

	std::uint32_t RichHeader::getKey() const
	{
		return key;
	}

	const std::uint32_t* RichHeader::getDecryptedHeaderItem(std::size_t index) const
	{
		return (index < decryptedHeader.size()) ? &decryptedHeader[index] : nullptr;
	}

	std::string RichHeader::getDecryptedHeaderItemSignature(std::size_t index) const
	{
		const auto *dhI = getDecryptedHeaderItem(index);
		return dhI ? makeSignature(*dhI) : "";
	}

	std::string RichHeader::getDecryptedHeaderItemsSignature(std::initializer_list<std::size_t> indexes) const
	{
		std::string result;

		for (const auto index : indexes)
		{
			result += getDecryptedHeaderItemSignature(index);
		}

		return result;
	}

	std::vector<std::uint8_t> RichHeader::getDecryptedHeaderBytes() const
	{
		std::vector<std::uint8_t> result(decryptedHeader.size() * sizeof(std::uint32_t));
		std::memcpy(result.data(), reinterpret_cast<const std::uint8_t*>(decryptedHeader.data()), result.size());
		return result;
	}

	RichHeader::richHeaderIterator RichHeader::begin() const
	{
		return records.begin();
	}

	RichHeader::richHeaderIterator RichHeader::end() const
	{
		return records.end();
	}
}

```

`debug_remover/src/pelib/SecurityDirectory.cpp`:

```cpp
/**
 * @file SecurityDirectory.cpp
 * @brief Class for security directory.
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#include "retdec/pelib/PeLibInc.h"
#include "retdec/pelib/SecurityDirectory.h"

namespace PeLib
{
	SecurityDirectory::SecurityDirectory() : m_ldrError(LDR_ERROR_NONE)
	{}

	unsigned int SecurityDirectory::calcNumberOfCertificates() const
	{
		return (unsigned int)m_certs.size();
	}

	const std::vector<unsigned char>& SecurityDirectory::getCertificate(std::size_t index) const
	{
		return m_certs[index].Certificate;
	}

	LoaderError SecurityDirectory::loaderError() const
	{
		return m_ldrError;
	}

	int SecurityDirectory::read(
			std::istream& inStream,
			unsigned int uiOffset,
			unsigned int uiSize)
	{
		IStreamWrapper inStream_w(inStream);

		m_ldrError = LDR_ERROR_NONE;

		if (!inStream_w)
		{
			return ERROR_OPENING_FILE;
		}

		std::uint64_t ulFileSize = fileSize(inStream_w);
		if (ulFileSize < uiOffset + uiSize)
		{
			m_ldrError = LDR_ERROR_DIGITAL_SIGNATURE_CUT;
			return ERROR_INVALID_FILE;
		}

		inStream_w.seekg(uiOffset, std::ios::beg);

		std::vector<unsigned char> vCertDirectory(uiSize);
		inStream_w.read(reinterpret_cast<char*>(vCertDirectory.data()), uiSize); // reads the whole directory

		// Verify zeroed certificates (00002edec5247488029b2cc69568dda90714eeed8de0d84f1488635196b7e708)
		if (std::all_of(vCertDirectory.begin(), vCertDirectory.end(), [](unsigned char item) { return item == 0; }))
		{
			m_ldrError = LDR_ERROR_DIGITAL_SIGNATURE_ZEROED;
			return ERROR_INVALID_FILE;
		}

		InputBuffer inpBuffer(vCertDirectory);

		unsigned bytesRead = 0;
		while (bytesRead < uiSize)
		{
			PELIB_IMAGE_CERTIFICATE_ENTRY cert;
			inpBuffer >> cert.Length;
			inpBuffer >> cert.Revision;
			inpBuffer >> cert.CertificateType;

			if ((cert.Length <= PELIB_IMAGE_CERTIFICATE_ENTRY::size() ||
				((cert.Revision != PELIB_WIN_CERT_REVISION_1_0) && (cert.Revision != PELIB_WIN_CERT_REVISION_2_0)) ||
				(cert.CertificateType != PELIB_WIN_CERT_TYPE_PKCS_SIGNED_DATA)))
			{
				return ERROR_INVALID_FILE;
			}

			cert.Certificate.resize(cert.Length - PELIB_IMAGE_CERTIFICATE_ENTRY::size());
			inpBuffer.read(reinterpret_cast<char*>(cert.Certificate.data()), cert.Certificate.size());

			bytesRead += cert.Length;
			m_certs.push_back(cert);
		}

		// save the offset and size for future checks
		this->offset = uiOffset;
		this->size = size;

		return ERROR_NONE;
	}

	std::uint64_t SecurityDirectory::getOffset() const
	{
		return offset;
	}

	std::uint64_t SecurityDirectory::getSize() const
	{
		return size;
	}
}

```

`debug_remover/src/utils/conversion.cpp`:

```cpp
/**
* @file src/utils/conversion.cpp
* @brief Implementation of the conversion utilities.
* @copyright (c) 2017 Avast Software, licensed under the MIT license
*/

#include <bitset>
#include <cstring>

#include "retdec/utils/conversion.h"
#include "retdec/utils/string.h"

namespace retdec {
namespace utils {

/**
 * From https://johnnylee-sde.github.io/Fast-unsigned-integer-to-hex-string/
 */
char* byteToHexString(uint8_t b, bool uppercase)
{
	static char result[3] = {'\0', '\0', '\0'};
	static const char digits[513] =
		"000102030405060708090A0B0C0D0E0F"
		"101112131415161718191A1B1C1D1E1F"
		"202122232425262728292A2B2C2D2E2F"
		"303132333435363738393A3B3C3D3E3F"
		"404142434445464748494A4B4C4D4E4F"
		"505152535455565758595A5B5C5D5E5F"
		"606162636465666768696A6B6C6D6E6F"
		"707172737475767778797A7B7C7D7E7F"
		"808182838485868788898A8B8C8D8E8F"
		"909192939495969798999A9B9C9D9E9F"
		"A0A1A2A3A4A5A6A7A8A9AAABACADAEAF"
		"B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF"
		"C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF"
		"D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF"
		"E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF"
		"F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF";
	static const char digitsLowerAlpha[513] =
		"000102030405060708090a0b0c0d0e0f"
		"101112131415161718191a1b1c1d1e1f"
		"202122232425262728292a2b2c2d2e2f"
		"303132333435363738393a3b3c3d3e3f"
		"404142434445464748494a4b4c4d4e4f"
		"505152535455565758595a5b5c5d5e5f"
		"606162636465666768696a6b6c6d6e6f"
		"707172737475767778797a7b7c7d7e7f"
		"808182838485868788898a8b8c8d8e8f"
		"909192939495969798999a9b9c9d9e9f"
		"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
		"b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
		"c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
		"d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
		"e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
		"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";

	const char* lut = uppercase ? digits : digitsLowerAlpha;
	std::size_t pos = b * 2;
	result[0] = lut[pos];
	result[1] = lut[pos+1];

	return &(result[0]);
}

/**
* @brief Convert 80-bit (10-byte) <tt>long double</tt> binary data (byte array)
*        into 64-bit (8-byte) <tt>double</tt> binary data.
*
* @param[out] dest 64-bit double to create.
* @param[in] src 80-bit long double to convert.
*/
void double10ToDouble8(std::vector<unsigned char> &dest,
		const std::vector<unsigned char> &src) {
	// Taken from:
	// http://blogs.perl.org/users/rurban/2012/09/reading-binary-floating-point-numbers-numbers-part2.html
	dest.clear();
	dest.resize(8, 0);

	int expo, i, sign;
	// exponents 15 -> 11 bits
	sign = src[9] & 0x80;
	expo = (src[9] & 0x7f)<< 8 | src[8];
	if (expo == 0) {
	nul:
		if (sign)
			dest[7] |= 0x80;
		return;
	}
	expo -= 16383;       // - bias long double
	expo += 1023;        // + bias for double
	if (expo <= 0)       // underflow
		goto nul;
	if (expo > 0x7ff) {  // inf/nan
		dest[7] = 0x7f;
		dest[6] = src[7] == 0xc0 ? 0xf8 : 0xf0 ;
		goto nul;
	}
	expo <<= 4;
	dest[6] = expo & 0xff;
	dest[7] = (expo & 0x7f00) >> 8;
	if (sign)
		dest[7] |= 0x80;
	// long double frac 63 bits => 52 bits src[7] &= 0x7f; reset intbit 63.
	for (i = 0; i < 6; ++i) {
		dest[i + 1] |= (i == 5 ? src[7] & 0x7f : src[i + 2]) >> 3;
		dest[i] |= (src[i + 2] & 0x1f) << 5;
	}
	dest[0] |= src[1] >> 3;
}

/**
* @brief Swap bytes for Intel x86 16-bit little-endian immediate.
*
* @param val Original value.
*
* @return Value with swapped bytes
*/
unsigned short byteSwap16(unsigned short val) {
	return (0xFF00 & val) >> 8 | (0xFF & val) << 8;
}

/**
* @brief Swap bytes for Intel x86 32-bit little-endian immediate.
*
* @param val Original value.
*
* @return Value with swapped bytes
*/
unsigned int byteSwap32(unsigned int val) {
	return (0xFF000000 & val) >> 24 |
		(0xFF0000 & val) >> 8 |
		(0xFF00 & val) << 8 |
		(0xFF & val) << 24;
}

/**
* @brief Swap bytes for Intel x86 16-bit little-endian immediate.
*
* @param val Original value.
*
* @return Value with swapped bytes or original value if its size is not 16.
*/
std::string byteSwap16(const std::string &val) {
	if (val.length() != 16)
		return val;

	return val.substr(8, 8) + val.substr(0, 8);
}

/**
* @brief Swap bytes for Intel x86 32-bit little-endian immediate.
*
* @param val Original value.
*
* @return Value with swapped bytes or original value if its size is not 32.
*/
std::string byteSwap32(const std::string &val) {
	if (val.length() != 32)
		return val;

	return val.substr(24, 8) + val.substr(16, 8) +
		val.substr(8, 8) + val.substr(0, 8);
}

/**
 * Convert hexadecimal string @c hexIn string into bytes.
 * There might be whitespaces in the string, e.g. "0b 84 d1 a0 80 60 40" is
 * the same as "0b84d1a0806040".
 */
std::vector<uint8_t> hexStringToBytes(const std::string& hexIn)
{
	std::vector<uint8_t> bytes;

	auto hex = removeWhitespace(hexIn);
	for (unsigned int i = 0; i < hex.length(); i += 2)
	{
		std::string byteString = hex.substr(i, 2);
		char byte = strtol(byteString.c_str(), nullptr, 16);
		bytes.push_back(byte);
	}

	return bytes;
}

} // namespace utils
} // namespace retdec

```

`debug_remover/src/utils/ord_lookup.cpp`:

```cpp
/**
 * @file src/fileformat/types/import_table/import_table.cpp
 * @brief Class for import table.
 * @copyright (c) 2017 Avast Software, licensed under the MIT license
 */

#include "retdec/utils/container.h"
#include "retdec/utils/conversion.h"
#include "retdec/utils/string.h"
#include "retdec/utils/ord_lookup.h"

namespace retdec {
namespace utils {

// Ordinal-name LUT for YARA compatible import hash computation.
// This must stay compatible with YARA's ord_lookup function

std::map<std::size_t, std::string> winsock32Map =
{
	{1, "accept"},
	{2, "bind"},
	{3, "closesocket"},
	{4, "connect"},
	{5, "getpeername"},
	{6, "getsockname"},
	{7, "getsockopt"},
	{8, "htonl"},
	{9, "htons"},
	{10, "ioctlsocket"},
	{11, "inet_addr"},
	{12, "inet_ntoa"},
	{13, "listen"},
	{14, "ntohl"},
	{15, "ntohs"},
	{16, "recv"},
	{17, "recvfrom"},
	{18, "select"},
	{19, "send"},
	{20, "sendto"},
	{21, "setsockopt"},
	{22, "shutdown"},
	{23, "socket"},
	{24, "GetAddrInfoW"},
	{25, "GetNameInfoW"},
	{26, "WSApSetPostRoutine"},
	{27, "FreeAddrInfoW"},
	{28, "WPUCompleteOverlappedRequest"},
	{29, "WSAAccept"},
	{30, "WSAAddressToStringA"},
	{31, "WSAAddressToStringW"},
	{32, "WSACloseEvent"},
	{33, "WSAConnect"},
	{34, "WSACreateEvent"},
	{35, "WSADuplicateSocketA"},
	{36, "WSADuplicateSocketW"},
	{37, "WSAEnumNameSpaceProvidersA"},
	{38, "WSAEnumNameSpaceProvidersW"},
	{39, "WSAEnumNetworkEvents"},
	{40, "WSAEnumProtocolsA"},
	{41, "WSAEnumProtocolsW"},
	{42, "WSAEventSelect"},
	{43, "WSAGetOverlappedResult"},
	{44, "WSAGetQOSByName"},
	{45, "WSAGetServiceClassInfoA"},
	{46, "WSAGetServiceClassInfoW"},
	{47, "WSAGetServiceClassNameByClassIdA"},
	{48, "WSAGetServiceClassNameByClassIdW"},
	{49, "WSAHtonl"},
	{50, "WSAHtons"},
	{51, "gethostbyaddr"},
	{52, "gethostbyname"},
	{53, "getprotobyname"},
	{54, "getprotobynumber"},
	{55, "getservbyname"},
	{56, "getservbyport"},
	{57, "gethostname"},
	{58, "WSAInstallServiceClassA"},
	{59, "WSAInstallServiceClassW"},
	{60, "WSAIoctl"},
	{61, "WSAJoinLeaf"},
	{62, "WSALookupServiceBeginA"},
	{63, "WSALookupServiceBeginW"},
	{64, "WSALookupServiceEnd"},
	{65, "WSALookupServiceNextA"},
	{66, "WSALookupServiceNextW"},
	{67, "WSANSPIoctl"},
	{68, "WSANtohl"},
	{69, "WSANtohs"},
	{70, "WSAProviderConfigChange"},
	{71, "WSARecv"},
	{72, "WSARecvDisconnect"},
	{73, "WSARecvFrom"},
	{74, "WSARemoveServiceClass"},
	{75, "WSAResetEvent"},
	{76, "WSASend"},
	{77, "WSASendDisconnect"},
	{78, "WSASendTo"},
	{79, "WSASetEvent"},
	{80, "WSASetServiceA"},
	{81, "WSASetServiceW"},
	{82, "WSASocketA"},
	{83, "WSASocketW"},
	{84, "WSAStringToAddressA"},
	{85, "WSAStringToAddressW"},
	{86, "WSAWaitForMultipleEvents"},
	{87, "WSCDeinstallProvider"},
	{88, "WSCEnableNSProvider"},
	{89, "WSCEnumProtocols"},
	{90, "WSCGetProviderPath"},
	{91, "WSCInstallNameSpace"},
	{92, "WSCInstallProvider"},
	{93, "WSCUnInstallNameSpace"},
	{94, "WSCUpdateProvider"},
	{95, "WSCWriteNameSpaceOrder"},
	{96, "WSCWriteProviderOrder"},
	{97, "freeaddrinfo"},
	{98, "getaddrinfo"},
	{99, "getnameinfo"},
	{101, "WSAAsyncSelect"},
	{102, "WSAAsyncGetHostByAddr"},
	{103, "WSAAsyncGetHostByName"},
	{104, "WSAAsyncGetProtoByNumber"},
	{105, "WSAAsyncGetProtoByName"},
	{106, "WSAAsyncGetServByPort"},
	{107, "WSAAsyncGetServByName"},
	{108, "WSACancelAsyncRequest"},
	{109, "WSASetBlockingHook"},
	{110, "WSAUnhookBlockingHook"},
	{111, "WSAGetLastError"},
	{112, "WSASetLastError"},
	{113, "WSACancelBlockingCall"},
	{114, "WSAIsBlocking"},
	{115, "WSAStartup"},
	{116, "WSACleanup"},
	{151, "__WSAFDIsSet"},
	{500, "WEP"}
};

std::map<std::size_t, std::string> oleaut32Map =
{
	{2, "SysAllocString"},
	{3, "SysReAllocString"},
	{4, "SysAllocStringLen"},
	{5, "SysReAllocStringLen"},
	{6, "SysFreeString"},
	{7, "SysStringLen"},
	{8, "VariantInit"},
	{9, "VariantClear"},
	{10, "VariantCopy"},
	{11, "VariantCopyInd"},
	{12, "VariantChangeType"},
	{13, "VariantTimeToDosDateTime"},
	{14, "DosDateTimeToVariantTime"},
	{15, "SafeArrayCreate"},
	{16, "SafeArrayDestroy"},
	{17, "SafeArrayGetDim"},
	{18, "SafeArrayGetElemsize"},
	{19, "SafeArrayGetUBound"},
	{20, "SafeArrayGetLBound"},
	{21, "SafeArrayLock"},
	{22, "SafeArrayUnlock"},
	{23, "SafeArrayAccessData"},
	{24, "SafeArrayUnaccessData"},
	{25, "SafeArrayGetElement"},
	{26, "SafeArrayPutElement"},
	{27, "SafeArrayCopy"},
	{28, "DispGetParam"},
	{29, "DispGetIDsOfNames"},
	{30, "DispInvoke"},
	{31, "CreateDispTypeInfo"},
	{32, "CreateStdDispatch"},
	{33, "RegisterActiveObject"},
	{34, "RevokeActiveObject"},
	{35, "GetActiveObject"},
	{36, "SafeArrayAllocDescriptor"},
	{37, "SafeArrayAllocData"},
	{38, "SafeArrayDestroyDescriptor"},
	{39, "SafeArrayDestroyData"},
	{40, "SafeArrayRedim"},
	{41, "SafeArrayAllocDescriptorEx"},
	{42, "SafeArrayCreateEx"},
	{43, "SafeArrayCreateVectorEx"},
	{44, "SafeArraySetRecordInfo"},
	{45, "SafeArrayGetRecordInfo"},
	{46, "VarParseNumFromStr"},
	{47, "VarNumFromParseNum"},
	{48, "VarI2FromUI1"},
	{49, "VarI2FromI4"},
	{50, "VarI2FromR4"},
	{51, "VarI2FromR8"},
	{52, "VarI2FromCy"},
	{53, "VarI2FromDate"},
	{54, "VarI2FromStr"},
	{55, "VarI2FromDisp"},
	{56, "VarI2FromBool"},
	{57, "SafeArraySetIID"},
	{58, "VarI4FromUI1"},
	{59, "VarI4FromI2"},
	{60, "VarI4FromR4"},
	{61, "VarI4FromR8"},
	{62, "VarI4FromCy"},
	{63, "VarI4FromDate"},
	{64, "VarI4FromStr"},
	{65, "VarI4FromDisp"},
	{66, "VarI4FromBool"},
	{67, "SafeArrayGetIID"},
	{68, "VarR4FromUI1"},
	{69, "VarR4FromI2"},
	{70, "VarR4FromI4"},
	{71, "VarR4FromR8"},
	{72, "VarR4FromCy"},
	{73, "VarR4FromDate"},
	{74, "VarR4FromStr"},
	{75, "VarR4FromDisp"},
	{76, "VarR4FromBool"},
	{77, "SafeArrayGetVartype"},
	{78, "VarR8FromUI1"},
	{79, "VarR8FromI2"},
	{80, "VarR8FromI4"},
	{81, "VarR8FromR4"},
	{82, "VarR8FromCy"},
	{83, "VarR8FromDate"},
	{84, "VarR8FromStr"},
	{85, "VarR8FromDisp"},
	{86, "VarR8FromBool"},
	{87, "VarFormat"},
	{88, "VarDateFromUI1"},
	{89, "VarDateFromI2"},
	{90, "VarDateFromI4"},
	{91, "VarDateFromR4"},
	{92, "VarDateFromR8"},
	{93, "VarDateFromCy"},
	{94, "VarDateFromStr"},
	{95, "VarDateFromDisp"},
	{96, "VarDateFromBool"},
	{97, "VarFormatDateTime"},
	{98, "VarCyFromUI1"},
	{99, "VarCyFromI2"},
	{100, "VarCyFromI4"},
	{101, "VarCyFromR4"},
	{102, "VarCyFromR8"},
	{103, "VarCyFromDate"},
	{104, "VarCyFromStr"},
	{105, "VarCyFromDisp"},
	{106, "VarCyFromBool"},
	{107, "VarFormatNumber"},
	{108, "VarBstrFromUI1"},
	{109, "VarBstrFromI2"},
	{110, "VarBstrFromI4"},
	{111, "VarBstrFromR4"},
	{112, "VarBstrFromR8"},
	{113, "VarBstrFromCy"},
	{114, "VarBstrFromDate"},
	{115, "VarBstrFromDisp"},
	{116, "VarBstrFromBool"},
	{117, "VarFormatPercent"},
	{118, "VarBoolFromUI1"},
	{119, "VarBoolFromI2"},
	{120, "VarBoolFromI4"},
	{121, "VarBoolFromR4"},
	{122, "VarBoolFromR8"},
	{123, "VarBoolFromDate"},
	{124, "VarBoolFromCy"},
	{125, "VarBoolFromStr"},
	{126, "VarBoolFromDisp"},
	{127, "VarFormatCurrency"},
	{128, "VarWeekdayName"},
	{129, "VarMonthName"},
	{130, "VarUI1FromI2"},
	{131, "VarUI1FromI4"},
	{132, "VarUI1FromR4"},
	{133, "VarUI1FromR8"},
	{134, "VarUI1FromCy"},
	{135, "VarUI1FromDate"},
	{136, "VarUI1FromStr"},
	{137, "VarUI1FromDisp"},
	{138, "VarUI1FromBool"},
	{139, "VarFormatFromTokens"},
	{140, "VarTokenizeFormatString"},
	{141, "VarAdd"},
	{142, "VarAnd"},
	{143, "VarDiv"},
	{144, "DllCanUnloadNow"},
	{145, "DllGetClassObject"},
	{146, "DispCallFunc"},
	{147, "VariantChangeTypeEx"},
	{148, "SafeArrayPtrOfIndex"},
	{149, "SysStringByteLen"},
	{150, "SysAllocStringByteLen"},
	{151, "DllRegisterServer"},
	{152, "VarEqv"},
	{153, "VarIdiv"},
	{154, "VarImp"},
	{155, "VarMod"},
	{156, "VarMul"},
	{157, "VarOr"},
	{158, "VarPow"},
	{159, "VarSub"},
	{160, "CreateTypeLib"},
	{161, "LoadTypeLib"},
	{162, "LoadRegTypeLib"},
	{163, "RegisterTypeLib"},
	{164, "QueryPathOfRegTypeLib"},
	{165, "LHashValOfNameSys"},
	{166, "LHashValOfNameSysA"},
	{167, "VarXor"},
	{168, "VarAbs"},
	{169, "VarFix"},
	{170, "OaBuildVersion"},
	{171, "ClearCustData"},
	{172, "VarInt"},
	{173, "VarNeg"},
	{174, "VarNot"},
	{175, "VarRound"},
	{176, "VarCmp"},
	{177, "VarDecAdd"},
	{178, "VarDecDiv"},
	{179, "VarDecMul"},
	{180, "CreateTypeLib2"},
	{181, "VarDecSub"},
	{182, "VarDecAbs"},
	{183, "LoadTypeLibEx"},
	{184, "SystemTimeToVariantTime"},
	{185, "VariantTimeToSystemTime"},
	{186, "UnRegisterTypeLib"},
	{187, "VarDecFix"},
	{188, "VarDecInt"},
	{189, "VarDecNeg"},
	{190, "VarDecFromUI1"},
	{191, "VarDecFromI2"},
	{192, "VarDecFromI4"},
	{193, "VarDecFromR4"},
	{194, "VarDecFromR8"},
	{195, "VarDecFromDate"},
	{196, "VarDecFromCy"},
	{197, "VarDecFromStr"},
	{198, "VarDecFromDisp"},
	{199, "VarDecFromBool"},
	{200, "GetErrorInfo"},
	{201, "SetErrorInfo"},
	{202, "CreateErrorInfo"},
	{203, "VarDecRound"},
	{204, "VarDecCmp"},
	{205, "VarI2FromI1"},
	{206, "VarI2FromUI2"},
	{207, "VarI2FromUI4"},
	{208, "VarI2FromDec"},
	{209, "VarI4FromI1"},
	{210, "VarI4FromUI2"},
	{211, "VarI4FromUI4"},
	{212, "VarI4FromDec"},
	{213, "VarR4FromI1"},
	{214, "VarR4FromUI2"},
	{215, "VarR4FromUI4"},
	{216, "VarR4FromDec"},
	{217, "VarR8FromI1"},
	{218, "VarR8FromUI2"},
	{219, "VarR8FromUI4"},
	{220, "VarR8FromDec"},
	{221, "VarDateFromI1"},
	{222, "VarDateFromUI2"},
	{223, "VarDateFromUI4"},
	{224, "VarDateFromDec"},
	{225, "VarCyFromI1"},
	{226, "VarCyFromUI2"},
	{227, "VarCyFromUI4"},
	{228, "VarCyFromDec"},
	{229, "VarBstrFromI1"},
	{230, "VarBstrFromUI2"},
	{231, "VarBstrFromUI4"},
	{232, "VarBstrFromDec"},
	{233, "VarBoolFromI1"},
	{234, "VarBoolFromUI2"},
	{235, "VarBoolFromUI4"},
	{236, "VarBoolFromDec"},
	{237, "VarUI1FromI1"},
	{238, "VarUI1FromUI2"},
	{239, "VarUI1FromUI4"},
	{240, "VarUI1FromDec"},
	{241, "VarDecFromI1"},
	{242, "VarDecFromUI2"},
	{243, "VarDecFromUI4"},
	{244, "VarI1FromUI1"},
	{245, "VarI1FromI2"},
	{246, "VarI1FromI4"},
	{247, "VarI1FromR4"},
	{248, "VarI1FromR8"},
	{249, "VarI1FromDate"},
	{250, "VarI1FromCy"},
	{251, "VarI1FromStr"},
	{252, "VarI1FromDisp"},
	{253, "VarI1FromBool"},
	{254, "VarI1FromUI2"},
	{255, "VarI1FromUI4"},
	{256, "VarI1FromDec"},
	{257, "VarUI2FromUI1"},
	{258, "VarUI2FromI2"},
	{259, "VarUI2FromI4"},
	{260, "VarUI2FromR4"},
	{261, "VarUI2FromR8"},
	{262, "VarUI2FromDate"},
	{263, "VarUI2FromCy"},
	{264, "VarUI2FromStr"},
	{265, "VarUI2FromDisp"},
	{266, "VarUI2FromBool"},
	{267, "VarUI2FromI1"},
	{268, "VarUI2FromUI4"},
	{269, "VarUI2FromDec"},
	{270, "VarUI4FromUI1"},
	{271, "VarUI4FromI2"},
	{272, "VarUI4FromI4"},
	{273, "VarUI4FromR4"},
	{274, "VarUI4FromR8"},
	{275, "VarUI4FromDate"},
	{276, "VarUI4FromCy"},
	{277, "VarUI4FromStr"},
	{278, "VarUI4FromDisp"},
	{279, "VarUI4FromBool"},
	{280, "VarUI4FromI1"},
	{281, "VarUI4FromUI2"},
	{282, "VarUI4FromDec"},
	{283, "BSTR_UserSize"},
	{284, "BSTR_UserMarshal"},
	{285, "BSTR_UserUnmarshal"},
	{286, "BSTR_UserFree"},
	{287, "VARIANT_UserSize"},
	{288, "VARIANT_UserMarshal"},
	{289, "VARIANT_UserUnmarshal"},
	{290, "VARIANT_UserFree"},
	{291, "LPSAFEARRAY_UserSize"},
	{292, "LPSAFEARRAY_UserMarshal"},
	{293, "LPSAFEARRAY_UserUnmarshal"},
	{294, "LPSAFEARRAY_UserFree"},
	{295, "LPSAFEARRAY_Size"},
	{296, "LPSAFEARRAY_Marshal"},
	{297, "LPSAFEARRAY_Unmarshal"},
	{298, "VarDecCmpR8"},
	{299, "VarCyAdd"},
	{300, "DllUnregisterServer"},
	{301, "OACreateTypeLib2"},
	{303, "VarCyMul"},
	{304, "VarCyMulI4"},
	{305, "VarCySub"},
	{306, "VarCyAbs"},
	{307, "VarCyFix"},
	{308, "VarCyInt"},
	{309, "VarCyNeg"},
	{310, "VarCyRound"},
	{311, "VarCyCmp"},
	{312, "VarCyCmpR8"},
	{313, "VarBstrCat"},
	{314, "VarBstrCmp"},
	{315, "VarR8Pow"},
	{316, "VarR4CmpR8"},
	{317, "VarR8Round"},
	{318, "VarCat"},
	{319, "VarDateFromUdateEx"},
	{322, "GetRecordInfoFromGuids"},
	{323, "GetRecordInfoFromTypeInfo"},
	{325, "SetVarConversionLocaleSetting"},
	{326, "GetVarConversionLocaleSetting"},
	{327, "SetOaNoCache"},
	{329, "VarCyMulI8"},
	{330, "VarDateFromUdate"},
	{331, "VarUdateFromDate"},
	{332, "GetAltMonthNames"},
	{333, "VarI8FromUI1"},
	{334, "VarI8FromI2"},
	{335, "VarI8FromR4"},
	{336, "VarI8FromR8"},
	{337, "VarI8FromCy"},
	{338, "VarI8FromDate"},
	{339, "VarI8FromStr"},
	{340, "VarI8FromDisp"},
	{341, "VarI8FromBool"},
	{342, "VarI8FromI1"},
	{343, "VarI8FromUI2"},
	{344, "VarI8FromUI4"},
	{345, "VarI8FromDec"},
	{346, "VarI2FromI8"},
	{347, "VarI2FromUI8"},
	{348, "VarI4FromI8"},
	{349, "VarI4FromUI8"},
	{360, "VarR4FromI8"},
	{361, "VarR4FromUI8"},
	{362, "VarR8FromI8"},
	{363, "VarR8FromUI8"},
	{364, "VarDateFromI8"},
	{365, "VarDateFromUI8"},
	{366, "VarCyFromI8"},
	{367, "VarCyFromUI8"},
	{368, "VarBstrFromI8"},
	{369, "VarBstrFromUI8"},
	{370, "VarBoolFromI8"},
	{371, "VarBoolFromUI8"},
	{372, "VarUI1FromI8"},
	{373, "VarUI1FromUI8"},
	{374, "VarDecFromI8"},
	{375, "VarDecFromUI8"},
	{376, "VarI1FromI8"},
	{377, "VarI1FromUI8"},
	{378, "VarUI2FromI8"},
	{379, "VarUI2FromUI8"},
	{401, "OleLoadPictureEx"},
	{402, "OleLoadPictureFileEx"},
	{411, "SafeArrayCreateVector"},
	{412, "SafeArrayCopyData"},
	{413, "VectorFromBstr"},
	{414, "BstrFromVector"},
	{415, "OleIconToCursor"},
	{416, "OleCreatePropertyFrameIndirect"},
	{417, "OleCreatePropertyFrame"},
	{418, "OleLoadPicture"},
	{419, "OleCreatePictureIndirect"},
	{420, "OleCreateFontIndirect"},
	{421, "OleTranslateColor"},
	{422, "OleLoadPictureFile"},
	{423, "OleSavePictureFile"},
	{424, "OleLoadPicturePath"},
	{425, "VarUI4FromI8"},
	{426, "VarUI4FromUI8"},
	{427, "VarI8FromUI8"},
	{428, "VarUI8FromI8"},
	{429, "VarUI8FromUI1"},
	{430, "VarUI8FromI2"},
	{431, "VarUI8FromR4"},
	{432, "VarUI8FromR8"},
	{433, "VarUI8FromCy"},
	{434, "VarUI8FromDate"},
	{435, "VarUI8FromStr"},
	{436, "VarUI8FromDisp"},
	{437, "VarUI8FromBool"},
	{438, "VarUI8FromI1"},
	{439, "VarUI8FromUI2"},
	{440, "VarUI8FromUI4"},
	{441, "VarUI8FromDec"},
	{442, "RegisterTypeLibForUser"},
	{443, "UnRegisterTypeLibForUser"}
};

/**
 * Lookup import name for given library name and ordinal number
 * @param libName library name
 * @param ordNum ordinal number
 * @param forceNameFromOrdinal
 * @return new string name
 */
std::string ordLookUp(const std::string& libName, const std::size_t& ordNum, bool forceNameFromOrdinal)
{
	std::string res;

	if(areEqualCaseInsensitive(libName, "ws2_32.dll") || areEqualCaseInsensitive(libName, "wsock32.dll"))
	{
		res = mapGetValueOrDefault(winsock32Map, ordNum);
	}
	else if (areEqualCaseInsensitive(libName, "oleaut32.dll"))
	{
		res = mapGetValueOrDefault(oleaut32Map, ordNum);
	}

	if(res.empty() && forceNameFromOrdinal)
		res = "ord" + std::to_string(ordNum);
	return res;
}

} // namespace utils
} // namespace retdec

```

`debug_remover/src/utils/string.cpp`:

```cpp
/**
* @file src/utils/string.cpp
* @brief String utilities.
* @copyright (c) 2017 Avast Software, licensed under the MIT license
*/

#include <algorithm>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <functional>
#include <regex>
#include <sstream>

#include "retdec/utils/conversion.h"
#include "retdec/utils/string.h"

namespace retdec {
namespace utils {

namespace {

/**
 * @brief Our alternative to std::isprint() which can be inconsistent for '\t'
 *        - true on windows, false on other systems.
 */
bool isPrintableChar(unsigned char c) {
	return std::isprint(c) && !std::iscntrl(c);
}

/**
* @brief Returns @c true if @c is non-printable character, @c false otherwise.
*/
bool isNonprintableChar(unsigned char c) {
	return !isPrintableChar(c);
}

/**
* @brief Returns @c true if @c is non-ASCII character, @c false otherwise.
*/
bool isNonasciiChar(unsigned char c) {
	return c > 0x7f;
}

/**
* @brief Replace all chars in @a str that satisfy condition @a predicate with
*        their hexadecimal values.
*/
std::string replaceChars(const std::string &str, bool (* predicate)(unsigned char)) {
	std::string prefix("\\x");
	std::string result;
	result.reserve(str.size() * 4);
	for (const auto c : str) {
		if (predicate(c)) {
			result += prefix + byteToHexString(c, false);
		} else {
			result += c;
		}
	}
	return result;
}

//
// ============================================================================
//

/**
* @brief Returns the number of hexadecimal digits that are needed to emit a
*        character with the given size (number of bits).
*/
std::size_t widthOf(std::size_t charSize) {
	// Two digits for 8-bit char, four digits for 16-bit char, etc.
	return charSize / 4;
}

/**
* @brief Is the given character within the range of ASCII characters?
*/
bool isASCII(WideCharType c) {
	// ASCII is a 7-bit code.
	return c < 128;
}

/**
* @brief Checks if the given character is printable.
*/
bool isPrintable(WideCharType c) {
	// Functions from <ctypes> do not work when the character does not fit into
	// 'unsigned char' (it's undefined behavior), so before calling them, we
	// have to ensure that the character is in the ASCII range.
	if (!isASCII(c)) {
		return false;
	}

	// std::isprint() returns true for all characters with an ASCII code
	// greater than 0x1f (US), except 0x7f (DEL). However, we also want to
	// consider other characters as printable in the form of escape sequences.
	return isPrintableChar(c) || std::isspace(c) || c == '\a' || c == '\b';
}

/**
* @brief Checks if the given character is either printable or the zero byte.
*/
bool isPrintableOrZeroByte(WideCharType c) {
	return isPrintable(c) || c == '\0';
}

/**
* @brief Checks if the given string has any unprintable characters.
*/
bool hasUnprintableChars(const WideStringType &str) {
	return std::find_if(
			str.begin(),
			str.end(),
			[](WideCharType c){return !isPrintable(c);}) == str.end();
}

/**
* @brief Checks if the only unprintable characters in the given string are zero
*        bytes.
*/
bool onlyUnprintableCharsAreZeroBytes(const WideStringType &str) {
	return std::find_if(
			str.begin(),
			str.end(),
			[](WideCharType c){return !isPrintableOrZeroByte(c);}) == str.end();
}

/**
* @brief Converts the given character into a hexadecimal representation to be
*        used in escaped C strings.
*
* @param[in] c Character to be converted.
* @param[in] charSize How large is actually the character in @a c (in bits)?
*
* For example, @c ';' is converted into @c "\x3b" when @c charSize is 8.
*/
std::string charToHexaStringRepr(WideCharType c, std::size_t charSize) {
	std::stringstream stringRepr;
	stringRepr << "\\x"
		<< std::setfill('0') << std::setw(widthOf(charSize))
		<< std::hex << c;
	return stringRepr.str();
}

/**
* @brief Can the given character be appended literally, i.e. without escaping
*        it?
*
* @param[in] c Character to be checked.
* @param[in] lastWasHex Was the last character a hexadecimal escape?
*/
bool canBeAppendedLiterally(WideCharType c, bool lastWasHex) {
	// Functions from <ctypes> do not work when the character does not fit into
	// 'unsigned char' (it's undefined behavior), so before calling them, we
	// have to ensure that the character is in the ASCII range.
	if (!isASCII(c)) {
		return false;
	}

	// Only printable characters can be appended literally. However, we have to
	// be careful when the last character output was a hexadecimal escape code,
	// in which case we cannot append hexadecimal digits explicitly (they may
	// be considered as a continuation of the previous character, e.g. "\x00a"
	// is a single character).
	return isPrintableChar(c) && (!lastWasHex || !std::isxdigit(c));
}

/**
* @brief Converts the given character into a representation usable in escaped C
*        strings.
*
* @param[in] c Character to be converted.
* @param[in] charSize How large is actually the character in @a c (in bits)?
* @param[int,out] lastWasHex Was the last character a hexadecimal escape?
* @param[in] forceHex Convert @a c into a hexadecimal escape sequence, even if
*                     it is printable.
*/
std::string charToEscapedCStringRepr(WideCharType c,
		std::size_t charSize, bool &lastWasHex, bool forceHex) {
	if (forceHex) {
		lastWasHex = true;
		return charToHexaStringRepr(c, charSize);
	}

	if (canBeAppendedLiterally(c, lastWasHex)) {
		lastWasHex = false;
		std::string repr;
		if (c == '"' || c == '\\') {
			repr += '\\';
		}
		repr += c;
		return repr;
	}

	// The following list of escape sequences is based on
	// http://en.cppreference.com/w/c/language/escape
	//
	// Note: Although ? (question mark) and ' (single quote) can be written as
	//       escape sequences (see the link above), we generate them normally
	//       because this makes the string more readable.
	lastWasHex = false;
	switch (c) {
		case '\a': return "\\a";
		case '\b': return "\\b";
		case '\f': return "\\f";
		case '\n': return "\\n";
		case '\r': return "\\r";
		case '\t': return "\\t";
		case '\v': return "\\v";
		default: break;
	}

	lastWasHex = true;
	return charToHexaStringRepr(c, charSize);
}

} // anonymous namespace

/**
* @brief Returns @c true if the given string is formed only by decimal digits.
*
* The empty string is considered to be composed only by digits.
*/
bool hasOnlyDecimalDigits(const std::string &str) {
	return std::all_of(str.begin(), str.end(),
		[](const unsigned char c) { return std::isdigit(c); });
}

/**
* @brief Returns @c true if the given string is formed only by hexadecimal
*        digits.
*
* The empty string is considered to be composed only by hexadecimal digits.
*/
bool hasOnlyHexadecimalDigits(const std::string &str) {
	return std::all_of(str.begin(), str.end(),
		[](const unsigned char c) { return std::isxdigit(c); });
}

/**
* @brief Returns @c true if the given string contains at least one
*        non-printable character.
*/
bool hasNonprintableChars(const std::string &str) {
	return std::any_of(str.begin(), str.end(),
		[](const unsigned char c) { return isNonprintableChar(c); });
}

/**
* @brief Returns @c true if the given string contains at least one
*        non-ASCII character.
*/
bool hasNonasciiChars(const std::string &str) {
	return std::any_of(str.begin(), str.end(),
		[](const unsigned char c) { return isNonasciiChar(c); });
}

/**
* @brief Checks if <tt>str1 < str2</tt> (case-insensitively).
*
* This function doesn't consider non-ASCII character sets.
*/
bool isLowerThanCaseInsensitive(const std::string &str1, const std::string &str2) {
	for (std::string::size_type i = 0, e = std::min(str1.size(), str2.size());
			i < e; ++i) {
		const unsigned char lc = str1[i];
		const unsigned char rc = str2[i];
		if (std::tolower(lc) < std::tolower(rc)) {
			return true;
		} else if (std::tolower(lc) > std::tolower(rc)) {
			return false;
		}
	}
	return str1.size() < str2.size();
}

/**
* @brief Checks if <tt>str1 == str2</tt> (case-insensitively).
*/
bool areEqualCaseInsensitive(const std::string &str1, const std::string &str2) {
	if (str1.size() != str2.size()) {
		return false;
	}

	for (std::string::size_type i = 0, e = str1.size(); i < e; ++i) {
		const unsigned char lc = str1[i];
		const unsigned char rc = str2[i];
		if (std::tolower(lc) != std::tolower(rc)) {
			return false;
		}
	}
	return true;
}

/**
* @brief Checks if the shorter string of @a str1 and @a str2 is a
*        case-insensitive prefix of the longer string.
*/
bool isShorterPrefixOfCaseInsensitive(const std::string &str1,
		const std::string &str2) {
	const auto minLen = std::min(str1.length(), str2.length());
	return areEqualCaseInsensitive(str1.substr(0, minLen), str2.substr(0, minLen));
}

/**
* @brief Checks if @a str contains @a sub.
*/
bool contains(const std::string &str, const std::string &sub) {
	return str.find(sub) != std::string::npos;
}

/**
* @brief Check if at least one string from @a subs is contained in @a str.
*/
bool containsAny(const std::string &str, const std::vector<std::string> &subs) {
	for (auto& s : subs) {
		if (contains(str, s)) {
			return true;
		}
	}
	return false;
}

/**
* @brief Find out if string contains another string, no matter the case.
*
* @param str String to search in.
* @param sub String to search for.
*
* @return @c true if string contains another string, @c false otherwise.
*/
bool containsCaseInsensitive(const std::string &str, const std::string &sub) {
	if (sub.empty()) {
		return true;
	}

	auto it = std::search(
		str.begin(), str.end(),
		sub.begin(), sub.end(),
		[](unsigned char ch1, unsigned char ch2) {
			return std::tolower(ch1) == std::tolower(ch2);
		}
	);
	return (it != str.end());
}

/**
* @brief Returns @c true if @a str contains at least one character from
*        @a chars, @c false otherwise.
*
* If @a chars is the empty string, it returns @c false.
*/
bool containsAnyOfChars(const std::string &str, const std::string &chars) {
	return str.find_first_of(chars) != std::string::npos;
}

/**
* @brief Returns @c true if @a str contains @a c, @c false otherwise.
*/
bool containsAnyOfChars(const std::string &str, std::string::value_type c) {
	return str.find_first_of(c) != std::string::npos;
}

/**
* @brief Converts all characters in @a str to lower case.
*
* For example, <tt>"Crazy Willy"</tt> is converted into <tt>"crazy willy"</tt>.
*/
std::string toLower(std::string str) {
	std::transform(str.begin(), str.end(), str.begin(),
		[](const unsigned char c) { return std::tolower(c); });
	return str;
}

/**
* @brief Converts all characters in @a str to upper case.
*
* For example, <tt>"Crazy Willy"</tt> is converted into <tt>"CRAZY WILLY"</tt>.
*/
std::string toUpper(std::string str) {
	std::transform(str.begin(), str.end(), str.begin(),
		[](const unsigned char c) { return std::toupper(c); });
	return str;
}

/**
* @brief Converts @a str to wide string.
*
* @param[in] str String for conversion.
* @param[in] length Length in bytes of one character in output string.
*                   If length is zero, function returns empty string.
*
* @return Converted string.
*/
std::string toWide(const std::string &str, std::string::size_type length) {
	if (!length) {
		return "";
	}

	const std::string padding(length - 1, '\0');
	std::string result;
	result.reserve(str.length() * length);
	for (auto c : str) {
		result += c + padding;
	}
	return result;
}

/**
* @brief Converts unicode @a bytes to ASCII string.
*
* @param[in] bytes Bytes for conversion.
* @param[in] nBytes Number of bytes.
*
* @return Converted string in ASCII.
*/
std::string unicodeToAscii(const std::uint8_t *bytes, std::size_t nBytes)
{
	std::stringstream result;
	if (!bytes || !nBytes)
	{
		return {};
	}
	if (nBytes & 1)
	{
		nBytes--;
	}

	for (std::size_t i = 0; i < nBytes; i += 2)
	{
		if (bytes[i] == 0 && bytes[i + 1] == 0)
		{
			break;
		}
		if (bytes[i + 1] == 0 && isPrintableChar(bytes[i]))
		{
			result << bytes[i];
		}
		else
		{
			const std::size_t maxC = (1 << (sizeof(std::string::value_type) * CHAR_BIT)) - 1;
			const auto val1 = intToHexString(bytes[i] & maxC);
			const auto val2 = intToHexString(bytes[i + 1] & maxC);
			result << "\\x" << std::setw(2) << std::setfill('0') << val1;
			result << "\\x" << std::setw(2) << std::setfill('0') << val2;
		}
	}

	return result.str();
}

/**
* @brief Converts unicode @a bytes to ASCII string.
*
* @param[in] bytes Bytes for conversion.
* @param[in] nBytes Number of bytes.
* @param[in] nRead Number of bytes read. Note that this doesn't have to be the length of returned string
*
* @return Converted string in ASCII.
*/
std::string unicodeToAscii(const std::uint8_t *bytes, std::size_t nBytes, std::size_t &nRead)
{
	std::stringstream result;
	if (!bytes || !nBytes)
	{
		return {};
	}
	if (nBytes & 1)
	{
		nBytes--;
	}

	std::size_t i;
	for (i = 0; i < nBytes; i += 2)
	{
		if (bytes[i] == 0 && bytes[i + 1] == 0)
		{
			i += 2;
			break;
		}
		if (bytes[i + 1] == 0 && isPrintableChar(bytes[i]))
		{
			result << bytes[i];
		}
		else
		{
			const std::size_t maxC = (1 << (sizeof(std::string::value_type) * CHAR_BIT)) - 1;
			const auto val1 = intToHexString(bytes[i] & maxC);
			const auto val2 = intToHexString(bytes[i + 1] & maxC);
			result << "\\x" << std::setw(2) << std::setfill('0') << val1;
			result << "\\x" << std::setw(2) << std::setfill('0') << val2;
		}
	}

	nRead = i;
	return result.str();
}

/**
* @brief Read up to @a maxBytes bytes as ASCII string.
*
* @param[in] bytes Bytes to read from.
* @param[in] bytesLen Length of @a bytes
* @param[in] offset Offset in bytes.
* @param[in] maxBytes Maximum of bytes to read. Zero indicates as much as possible.
* @param[in] failOnExceed If string isn't null terminated until @a maxBytes, an empty string is returned
*
* @return Converted string in ASCII.
*/
std::string readNullTerminatedAscii(const std::uint8_t *bytes, std::size_t bytesLen, std::size_t offset,
									std::size_t maxBytes, bool failOnExceed)
{
	std::string result;
	if (!bytes)
	{
		return {};
	}

	if (maxBytes == 0)
	{
		maxBytes = bytesLen;
	}
	else if (offset + maxBytes > bytesLen)
	{
		maxBytes = bytesLen;
	}
	else
	{
		maxBytes += offset;
	}

	std::size_t i;
	for (i = offset; i < maxBytes; i++)
	{
		if (bytes[i] == '\0')
		{
			break;
		}
		result.push_back(bytes[i]);
	}

	if (i == maxBytes && failOnExceed)
	{
		return {};
	}

	return replaceNonprintableChars(result);
}

/**
* @brief Trims the given string.
*
* @param[in] str String to be trimmed.
* @param[in] toTrim String of characters to be trimmed (removed) from the
*                   beginning and the end of @a str. By default, it contains
*                   all whitespace characters from the ASCII set.
*
* @return Trimmed string.
*
* For example, <tt>trim("  hey there  ", " ")</tt> returns <tt>"hey
* there"</tt>.
*/
std::string trim(std::string str, const std::string &toTrim) {
	// Based on
	// http://www.codeproject.com/Articles/10880/A-trim-implementation-for-std-string
	std::string::size_type pos = str.find_last_not_of(toTrim);
	if (pos != std::string::npos) {
		str.erase(pos + 1);
		pos = str.find_first_not_of(toTrim);
		if (pos != std::string::npos) {
			str.erase(0, pos);
		}
	} else {
		str.erase(str.begin(), str.end());
	}
	return str;
}

/**
* @brief Splits the given string by a separator.
*
* @param[in] str String to be splitted.
* @param[in] sep Separator to be used.
* @param[in] trimWhitespace If @c true, trims whitespace around the separated
*                           strings.
*
* For example,
* @code
* split("; a ; b ; c ;", ';', true)
* @endcode
* returns
* @code
* ["", "a", "b", "c", ""]
* @endcode
*/
std::vector<std::string> split(const std::string &str, char sep, bool trimWhitespace) {
	std::vector<std::string> result;
	std::stringstream ss(str);
	std::string item;
	while (std::getline(ss, item, sep)) {
		result.push_back(trimWhitespace ? trim(item) : item);
	}

	// If the input string ends with the separator, we have to add another
	// empty string to the result. Indeed, the above way throws it away.
	if (!str.empty() && str.back() == sep) {
		result.push_back("");
	}

	return result;
}

/**
* @brief Unifies line ends in the given string to LF.
*
* @return String @a str with unified line ends.

* In a greater detail, this function converts CRLF and CR inside @a str to LF.
*/
std::string unifyLineEnds(const std::string &str) {
	return replaceAll(replaceAll(str, "\r\n", "\n"), "\r", "\n");
}

/**
* @brief Returns @a str with backslashes before characters that need to be
*        quoted, specified in @a toBackslash.
*
* @param[in] str String to be backslashed.
* @param[in] toBackslash List of characters to be backslashed in @a str.
*
* By default, @a toBackslash include a single quote ('), double quote ("), backslash (\)
* and NUL (the zero byte).
*/
std::string addSlashes(const std::string &str, const std::string &toBackslash) {
	std::string result;
	for (const auto &c : str) {
		if (toBackslash.find(c) != std::string::npos) {
			result += "\\";
		}
		result += c;
	}
	return result;
}

/**
* @brief Replaces all occurrences of @a what with @a withWhat in @a str and
*        returns the resulting string.
*/
std::string replaceCharsWithStrings(const std::string &str, char what,
		const std::string &withWhat) {
	std::string result;
	for (const auto &c : str) {
		if (c == what) {
			result += withWhat;
		} else {
			result += c;
		}
	}
	return result;
}

/**
* @brief Retruns @c true if @a str ends with the suffix @a withWhat, @c false
*        otherwise
*/
bool endsWith(const std::string &str, const std::string &withWhat) {
	return (str.length() >= withWhat.length()) &&
		(str.compare(str.length() - withWhat.length(), withWhat.length(), withWhat) == 0);
}

/**
* @brief Retruns @c true if @a str ends with the suffix @a withWhat, @c false
*        otherwise
*/
bool endsWith(const std::string &str, char withWhat) {
	return !str.empty() && str.back() == withWhat;
}

/**
* @return @c true if @a str ends with any of the suffixes in @a withWhat,
         @c false otherwise
*/
bool endsWith(const std::string &str, const std::set<std::string>& withWhat)
{
	for (auto& s : withWhat)
	{
		if (endsWith(str, s))
		{
			return true;
		}
	}

	return false;
}

/**
* @brief Returns @c true if @a str has substring @a withWhat on index
*        @a position.
*/
bool hasSubstringOnPosition(const std::string &str,
		const std::string &withWhat, std::string::size_type position) {
	return (position < str.length()) && (str.length() - position >= withWhat.length()) &&
		(str.compare(position, withWhat.length(), withWhat) == 0);
}

/**
* @brief Returns @c true if @a str has substring @a withWhat in area
*        bordered by offsets @a start and @a stop.
*/
bool hasSubstringInArea(const std::string &str, const std::string &withWhat,
		std::string::size_type start, std::string::size_type stop) {
	if (start > stop) {
		return false;
	}

	const auto stopIndex = stop + 1;
	const auto stopIterator = stopIndex < str.size() ?
		str.begin() + stopIndex : str.end();
	return std::search(str.begin() + start, stopIterator, withWhat.begin(),
		withWhat.end()) != stopIterator;
}

/**
* @brief Returns @c true if @a str is composed solely of chars in @a chars, @c
*        false otherwise.
*
* If @a chars is the empty string, it returns @c false.
*/
bool isComposedOnlyOfChars(const std::string &str, const std::string &chars) {
	return str.find_first_not_of(chars) == std::string::npos;
}

/**
* @brief Returns @c true if @a str is composed solely of char @a c, @c false
*        otherwise.
*/
bool isComposedOnlyOfChars(const std::string &str, std::string::value_type c) {
	return str.find_first_not_of(c) == std::string::npos;
}

/**
* @brief Returns @c true if @a str is composed solely of strings @a ss, @c
*        false otherwise.
*
* Examples:
* @code
* isComposedOnlyOfStrings("abcd",   "abcd") -> true
* isComposedOnlyOfStrings("ababab", "ab")   -> true
* isComposedOnlyOfStrings("aaaaa",  "aa")   -> true
* isComposedOnlyOfStrings("",       "")     -> true
* isComposedOnlyOfStrings("ababab", "ba")   -> false
* isComposedOnlyOfStrings("hello",  "")     -> false
* @endcode
*/
bool isComposedOnlyOfStrings(const std::string &str, const std::string &ss) {
	if (str.empty()) {
		// The empty string can be composed only of the empty string.
		return ss.empty();
	}

	if (ss.empty()) {
		// No non-empty string can be composed only of the empty string.
		return false;
	}

	if (ss.size() > str.size()) {
		// A string cannot be formed only by strings of a greater length than
		// the string itself.
		return false;
	}

	if (str.size() % ss.size() == 0) {
		// It suffices to check that str is of the form ss ss ss (without the
		// spaces)...
		for (std::string::size_type i = 0, e = str.size(); i < e; i += ss.size()) {
			if (str.substr(i, ss.size()) != ss) {
				return false;
			}
		}
		return true;
	}

	// Both str and ss have to be composed only of a single character.
	return isComposedOnlyOfChars(str, ss[0]) && isComposedOnlyOfChars(ss, str[0]);
}

/**
* @brief Strips all directories from the given path.
*
* For example, <tt>stripDirs("/home/user/test.c")</tt> returns @c "test.c".
*
* TODO Implement the following functionality:
*      - paths on MS Windows ('\' vs '/')
*      - allow backslashed '/' in file names
*/
std::string stripDirs(const std::string &path) {
	std::size_t endPos = path.find_last_of('/');
	if (endPos + 1 < path.length()) {
		return path.substr(endPos + 1);
	}
	return path;
}

/**
* @brief Replaces all occurrences of @a from in @a str with @a to and returns
*        the string obtained in this way.
*
* If @a from is the empty string, it returns @a str.
*/
std::string replaceAll(const std::string &str, const std::string &from,
		const std::string &to) {
	if (from.empty())
		return str;

	std::string result(str);
	std::size_t startPos = 0;
	while ((startPos = result.find(from, startPos)) != std::string::npos) {
		result.replace(startPos, from.length(), to);
		startPos += to.length();
	}
	return result;
}

/**
* @brief Replaces non-printable characters in @a str with their hexadecimal
*        values.
*/
std::string replaceNonprintableChars(const std::string &str) {
	return replaceChars(str, isNonprintableChar);
}

/**
* @brief Replaces non-ASCII characters in @a str with their hexadecimal
*        values.
*/
std::string replaceNonasciiChars(const std::string &str) {
	return replaceChars(str, isNonasciiChar);
}

/**
* @brief Replaces non-alphanumeric characters in @a str with @a c.
*/
std::string replaceNonalnumCharsWith(const std::string &str, std::string::value_type c) {
	std::string result;
	for(const unsigned char s : str) {
		result += isalnum(s) ? s : c;
	}
	return result;
}

/**
* @brief Removes all whitespace from the given string.
*/
std::string removeWhitespace(std::string s) {
	s.erase(std::remove_if(s.begin(), s.end(),
		[](const unsigned char c) { return std::isspace(c); }), s.end());
	return s;
}

/**
* @brief Transform @a position in @c json into line and column location.
*
* @param json JSON string.
* @param position Byte distance from start of JSON string.
*
* @return Pair <tt>(line, column)</tt>.
*/
std::pair<std::size_t, std::size_t> getLineAndColumnFromPosition(const std::string &json,
		std::size_t position) {
	std::size_t line = 0;
	std::size_t column = 0;

	if (position >= json.size())
		return {line, column};

	for (std::size_t p = 0; p < position; ++p) {
		if (json[p] == '\r' && (p + 1) < json.size() && json[p + 1] == '\n') {
			++p;
			++line;
			column = 0;
		} else if (json[p] == '\n') {
			++line;
			column = 0;
		} else {
			++column;
		}
	}

	// column & line start at 1
	return {line + 1, column + 1};
}

/**
* @brief Checks if the string is a number.
*/
bool isNumber(const std::string &str) {
	if (str.length() < 1)
		return false;

	unsigned k = 0;
	if (str[0] == '-' || str[0] == '+')
		k++;

	for (unsigned i = k; i < str.length(); i++) {
		if (!isdigit(static_cast<unsigned char>(str[i])))
			return false;
	}

	return true;
}

/**
 * @brief Checks if the string is a valid C language identifier.
 *
 * Empty string is not valid identifier.
 */
bool isIdentifier(const std::string &str)
{
	if (str.empty())
		return false;

	if (str[0] != '_' && !isalpha(static_cast<unsigned char>(str[0])))
		return false;

	for (std::size_t i = 1; i < str.size(); ++i) {
		if (str[i] != '_' && !isalnum(static_cast<unsigned char>(str[i])))
			return false;
	}

	return true;
}

/**
 * @brief Checks if the string is printable.
 *
 * Empty string is considered printable. This is different from isNiceString
 * because this function considers only printable characters, not control ones.
 *
 * @param str input string
 * @return @c true if input string is printable, @c false otherwise.
 */
bool isPrintable(const std::string &str)
{
	for (unsigned char c : str) {
		if (!isPrintableChar(c)) {
			return false;
		}
	}

	return true;
}

/**
* @brief Removes @c n @c leading characters from the given string @c s and
*        returns the result.
*
* @param s String from which leading characters are tp be removed.
* @param leading Leading character to remove.
* @param n Max number of characters to remove. If not set, remove as much
*          as possible.
*/
std::string removeLeadingCharacter(const std::string &s, char leading, std::size_t n) {
	if (n == 0) {
		return s;
	}

	std::string ret(s);
	std::size_t counter = 0;
	while (ret[0] == leading) {
		ret.erase(0, 1);
		if (n == ++counter) {
			return ret;
		}
	}
	return ret;
}

/**
 * @return @c True if character @a c is a control character, @c false otherwise.
 */
bool isContolCharacter(char c) {
	return c=='\b' || c=='\f' || c=='\n' || c=='\r' || c=='\t' || c=='\v';
}

/**
 * @return @c True if character @a c is a nice character (printable or control).
 *         @c False otherwise.
 */
bool isNiceCharacter(unsigned char c) {
	return isPrintableChar(c) || isContolCharacter(c);
}

/**
* @brief Does the provided string seem nice, i.e ratio of printable characters
*        and escape sequences in the string is at least @p minRatio.
*
* @param str String to check.
* @param minRatio Minimum ratio of printable characters.
*
* @return @c True if the string seems nice, @c false otherwise.
*
* Empty string is never nice.
*/
bool isNiceString(const std::string &str, double minRatio) {
	assert(0.0 <= minRatio && minRatio <= 1.0);

	std::string s = str;
	if (!s.empty() && s.back() == '\00')
		s.pop_back();

	auto niceCharCount = std::count_if(s.begin(), s.end(), isNiceCharacter);
	return !s.empty() && (niceCharCount) >= (s.size() * minRatio);
}

/**
 * @return @c True if character @a c is a nice ASCII wide character.
 *         @c False otherwise.
 */
bool isNiceAsciiWideCharacter(unsigned long long c) {
	return c <= 0xff && isNiceCharacter(c);
}

/**
 * @brief Does the provided wide string consist only from ASCII characters and is nice?
 *        Nice string have ration of printable characters and escape sequences in the
 *        string is at least @p minRatio. Empty string is never nice.
 * @param str Wide string to check.
 * @param minRatio Minimum ratio of printable characters.
 * @return @c True if the string seems nice, @c false otherwise.
 */
bool isNiceAsciiWideString(const std::vector<unsigned long long> &str, double minRatio) {
	assert(0.0 <= minRatio && minRatio <= 1.0);

	auto s = str;
	if (!s.empty() && s.back() == 0)
		s.pop_back();

	auto niceCnt = std::count_if(s.begin(), s.end(), isNiceAsciiWideCharacter);
	return !s.empty() && (niceCnt) >= (s.size() * minRatio);
}

/**
* @brief Returns an indentation string containing the specified number of
*        characters.
*/
std::string getIndentation(std::size_t count, char c) {
	return std::string(count, c);
}

/**
* @brief Appends hexadecimal address to string (typically object name).
*
* @param n Reference to string.
* @param a Address to append.
*/
void appendHex(std::string &n, const long long a) {
	std::stringstream ss;
	ss << n << "_" << std::hex << a;
	n = ss.str();
}

/**
* @brief Appends hexadecimal address to string (typically object name).
*
* @param n Reference to string.
* @param a Address to append.
*/
void appendDec(std::string &n, const long long a) {
	std::stringstream ss;
	ss << n << "_" << std::dec << a;
	n = ss.str();
}

/**
* @brief Appends hexadecimal address to string and return new string.
*
* @param n Original to string.
* @param a Address to append.
*
* @return Copy of original string with hexadecimal address.
*/
std::string appendHexRet(const std::string &n, const long long a) {
	std::stringstream ss;
	ss << n << "_" << std::hex << a;
	return ss.str();
}

/**
* @brief Appends hexadecimal address to string and return new string.
*
* @param n Original to string.
* @param a Address to append.
*
* @return Copy of original string with hexadecimal address.
*/
std::string appendDecRet(const std::string &n, const long long a) {
	std::stringstream ss;
	ss << n << "_" << std::dec << a;
	return ss.str();
}

/**
* @brief Finds the last occurrence of the specified suffix and removes
*        everything from its start to the end.
*
* @param[out] n Reference to string.
* @param[in] suffix Suffix to find and remove.
*/
void removeSuffix(std::string &n, const std::string &suffix) {
	std::size_t found = n.rfind(suffix);
	if (found != std::string::npos) {
		n = n.substr(0, found);
	}
}

/**
* @brief Finds the last occurrence of the specified suffix and removes
*        everything from its start to the end.

* @param[in] n Source string.
* @param[in] suffix Suffix to find and remove.
*
* @return Copy of source string without suffix address.
*/
std::string removeSuffixRet(const std::string &n, const std::string &suffix) {
	std::string ret = n;
	std::size_t found = ret.rfind(suffix);
	if (found != std::string::npos) {
		ret = ret.substr(0, found);
	}
	return ret;
}

/**
* @brief Replaces all special symbols by their normalized equivalent.
*
* @param[in] name Input string.
*
* @return String with substituted special symbols.
*/
std::string normalizeName(const std::string &name) {
	std::string res;
	for (unsigned i = 0; i < name.length(); i++) {
		switch (name[i]) {
			case '<':
				res += "_lt_"; // less than
				break;
			case '>':
				res += "_gt_"; // great than
				break;
			case '[':
				res += "_lsb_"; // left square bracket
				break;
			case ']':
				res += "_rsb_"; // right square bracket
				break;
			case '(':
				res += "_lb_"; // left bracket
				break;
			case ')':
				res += "_rb_"; // right bracket
				break;
			case ',':
				res += "_comma_";
				break;
			case '~':
				res += "_destructor_";
				break;
			case '*':
				res += "_ptr_";
				break;
			case '&':
				res += "_ampersand_";
				break;
			case '=':
				res += "_eq_";
				break;
			case '!':
				res += "_not_";
				break;
			case '?':
				res += "_qm_"; // question mark
				break;
			case ' ':
			case '`':
			case '\'':
			case '@':
			case ':':
			case '\n':
			case '\r':
				res += '_';
				break;
			case '.':
				res += name[i];
				break;
			default:
				if (isalnum(static_cast<unsigned char>(name[i])))
					res += name[i];
				else
					res += '_';
				break;
		}
	}

	if (!res.empty() && isdigit(static_cast<unsigned char>(res[0]))) {
		res = "_" + res;
	}

	return res;
}

/**
 * TODO: Is this and @c normalizeName() really needed/wanted?
 * If so, can they be merged into one. If not remove them.
 */
std::string normalizeNamePrefix(const std::string &name)
{
	static const std::vector<std::string> prefixesToRemove = {
			"__GI_",
			"__isoc99_",
			"_isoc99_"};

	std::string ret = name;
	for (auto& p : prefixesToRemove)
	{
		if (startsWith(ret, p))
		{
			ret = ret.substr(p.size());
		}
	}
	return ret;
}

/**
* @brief Finds the first occurrence of @c c character in string @c str that is
*        outside of embedded lists delimited by @c pairs.
*
* @param[out] pos Character position of @c std::string::npos if character not
*                 found. Position is left unchanged, if @c true is returned.
* @param str String to find occerrences in.
* @param c Character to find.
* @param pairs Vector of delimiter pairs: @c <delim_start,delim_end>.
*
* @return @c False if substring before the first found occurrence is ok (delimiter
*         pairs match each other), @c true otherwise.
*
* The check is performed only before the occurrence is found, after that,
* string may not be ok. Only delimiter numbers are checked, not their correct
* positions. For example, this is malformed string because delimiters
* (<tt>"{}"</tt>) do not match before character <tt>','</tt> we search for:
* <tt>"{abc{},def"</tt>. However, this is currently ok (search for
* <tt>','</tt>, delimiters <tt>"{}()"</tt>): <tt>"{a(b}c),def"</tt>.
*/
bool findFirstInEmbeddedLists(std::size_t &pos, const std::string &str,
		char c, const std::vector<std::pair<char, char>> &pairs) {
	if (str.empty()) {
		pos = std::string::npos;
		return false;
	}

	std::map<std::pair<char, char>, unsigned> counters;
	for (const auto &p : pairs) {
		counters[p] = 0;
	}

	for (std::size_t i = 0; i < str.size(); ++i) {
		for (const auto &p : pairs) {
			if (str[i] == p.first) {
				++counters[p];
			}
			if (str[i] == p.second) {
				if (counters[p] > 0) {
					--counters[p];
				}
				else {
					return true;
				}
			}
		}

		if (str[i] == c) {
			bool ok = true;
			for (const auto &p : pairs) {
				if (counters[p] > 0) {
					ok = false;
					break;
				}
			}

			if (!ok) {
				continue;
			}

			pos = i;
			return false;
		}
	}

	for (const auto &p : pairs) {
		if (counters[p] > 0) {
			return true;
		}
	}

	pos = std::string::npos;
	return false;
}

std::string removeConsecutiveSpaces(const std::string& str)
{
	std::string ret = str;
	ret.erase(
			std::unique(ret.begin(), ret.end(),
					[](char a, char b) { return a == ' ' && b == ' '; } ),
			ret.end() );
	return ret;
}

/**
* @brief Returns the constant's value as an escaped C string.
*/
std::string asEscapedCString(const WideStringType& value, std::size_t charSize) {
	// Keep track whether the last character was written as a hexadecimal
	// escape.
	bool lastWasHex = false;

	// When the string has any unprintable characters, convert all its
	// characters into hexadecimal escape sequences.
	bool forceHex = hasUnprintableChars(value);

	// However, if the only unprintable characters are zero bytes, do not force
	// the hexadecimal escape because
	//
	//     "hello_world.f\x00"
	//
	// looks better than
	//
	//     "\x68\x65\x6C\x6C\x6F\x5F\x77\x6F\x72\x6C\x64\x2E\x66\x00"
	//
	if (onlyUnprintableCharsAreZeroBytes(value)) {
		forceHex = false;
	}

	// Perform the conversion.
	std::string escapedCString;
	for (auto c : value) {
		escapedCString += charToEscapedCStringRepr(c, charSize, lastWasHex, forceHex);
	}
	return escapedCString;
}

/**
 * Remove comments from string. Comment must start with a single @c commentChar
 * character and end on new line (i.e. '\n') character.
 * For example LLVM comment:
 *    %a = add i32 0, 0 ; this part will be removed
 * @param str         String from which to remove comments.
 * @param commentChar Character used to start the comment (e.g. ';').
 * @return String without comments.
 */
std::string removeComments(const std::string& str, char commentChar)
{
	std::string ret = str;
	bool ers = false;
	for (auto it = ret.begin(); it != ret.end(); )
	{
		if (*it == commentChar)
		{
			it = ret.erase(it);
			ers = true;
		}
		else if (*it == '\n')
		{
			ers = false;
			++it;
		}
		else if (ers)
		{
			it = ret.erase(it);
		}
		else
		{
			++it;
		}
	}
	return ret;
}

/**
 * Search for version stored in input string
 * @param input Input string
 * @return Found version or empty string if no version found.
 *
 * A version is considered to be a substring which consisting of numbers
 * (and dots). If input string contains more versions, result contains only
 * the first one.
 */
std::string extractVersion(const std::string& input)
{
	static std::regex e("([0-9]+\\.)+[0-9]+");
	std::smatch match;
	if (regex_search(input, match, e))
	{
		return match.str();
	}

	return std::string();
}

} // namespace utils
} // namespace retdec

```