Project Path: arc_cinit_WSAPatch_4urn39qn

Source Tree:

```txt
arc_cinit_WSAPatch_4urn39qn
├── CMakeLists.txt
├── ErrnoRestorer.h
├── LICENSE
├── Log.cpp
├── Log.h
├── README.md
├── README_zhs.md
├── TimeUtils.cpp
├── TimeUtils.h
├── WsaPatch.cpp
├── WsaPatch.h
├── macros.h
├── original.dll.win11.22h2
│   └── x86_64
│       ├── icu.dll
│       └── winhttp.dll
└── pic
    └── screenshot_20221202.png

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.23)
project(WsaPatch)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_C_STANDARD 11)

add_library(WsaPatch SHARED WsaPatch.cpp Log.cpp TimeUtils.cpp ErrnoRestorer.h)

```

`ErrnoRestorer.h`:

```h
//
// Created by Administrator on 2022.11.30.
//

#ifndef WSAPATCH_ERRNORESTORER_H
#define WSAPATCH_ERRNORESTORER_H

#include <windows.h>

class ErrnoRestorer {
public:
    ErrnoRestorer() : saved_errno_(GetLastError()) {}

    ~ErrnoRestorer() {
        SetLastError(saved_errno_);
    }

    // disable copy and assign

    ErrnoRestorer(const ErrnoRestorer &) = delete;

    ErrnoRestorer &operator=(const ErrnoRestorer &) = delete;

    ErrnoRestorer(ErrnoRestorer &&) = delete;

    ErrnoRestorer &operator=(ErrnoRestorer &&) = delete;

    // Allow this object to be used as part of && operation.
    explicit operator bool() const { return true; }

private:
    const DWORD saved_errno_;
};

#endif //WSAPATCH_ERRNORESTORER_H

```

`LICENSE`:

```
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>

```

`Log.cpp`:

```cpp
//
// Created by Administrator on 2022.11.30.
//

#include "Log.h"

volatile Log::LogHandler Log::mHandler = nullptr;

```

`Log.h`:

```h
//
// Created by Administrator on 2022.11.30.
//

#ifndef WSAPATCH_LOG_H
#define WSAPATCH_LOG_H

#include <cstdarg>
#include <cstdio>
#include <cstring>
#include <malloc.h>
#include <strsafe.h>

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

#ifdef ERROR
#define MACRO_PUSH_ERROR 1
#pragma push_macro("ERROR")
#undef ERROR
#endif

class Log {
public:
    enum class Level {
        UNKNOWN = 0,
        VERBOSE = 2,
        DEBUG = 3,
        INFO = 4,
        WARN = 5,
        ERROR = 6
    };
    using LogHandler = void (*)(Level level, const WCHAR *tag, const WCHAR *msg);
private:
    static volatile LogHandler mHandler;
public:
    static void format(Level level, const WCHAR *tag, _Printf_format_string_ const WCHAR *fmt, ...) {
        va_list varg1;
        LogHandler h = mHandler;
        if (h == nullptr || fmt == nullptr) {
            return;
        }
        WCHAR buffer[1024] = {};
                va_start(varg1, fmt);
        StringCchVPrintfW(buffer, 1024, fmt, varg1);
                va_end(varg1);
        h(level, tag, buffer);
    }

    static void logBuffer(Level level, const WCHAR *tag, const WCHAR *msg) {
        LogHandler h = mHandler;
        if (h == nullptr) {
            return;
        }
        h(level, tag, msg);
    }

    static inline LogHandler getLogHandler() noexcept {
        return mHandler;
    }

    static inline void setLogHandler(LogHandler h) noexcept {
        mHandler = h;
    }

    static constexpr const WCHAR *levelName(Level level) noexcept {
        switch (level) {
            case Level::UNKNOWN:
                return L"UNKNOWN";
            case Level::VERBOSE:
                return L"VERBOSE";
            case Level::DEBUG:
                return L"DEBUG";
            case Level::INFO:
                return L"INFO";
            case Level::WARN:
                return L"WARN";
            case Level::ERROR:
                return L"ERROR";
            default:
                return L"UNKNOWN";
        }
    }
};

#define LOGE(...)  Log::format(static_cast<Log::Level>(6), LOG_TAG, __VA_ARGS__)
#define LOGW(...)  Log::format(Log::Level::WARN, LOG_TAG, __VA_ARGS__)
#define LOGI(...)  Log::format(Log::Level::INFO, LOG_TAG, __VA_ARGS__)
#define LOGD(...)  Log::format(Log::Level::DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGV(...)  Log::format(Log::Level::VERBOSE, LOG_TAG, __VA_ARGS__)

#ifdef MACRO_PUSH_ERROR
#pragma pop_macro("ERROR")
#endif

#endif //WSAPATCH_LOG_H

```

`README.md`:

```md
# WSA patch for Windows 10

[中文版本](./README_zhs.md)

This is a patch for WSA to enable WSA (Windows Subsystem for Android) to run on Windows 10.

### Compatibility

Below is a list of versions of WSA and versions of Windows 10 that have been tested together.

| WSA version     | Windows version        |
|-----------------|------------------------|
| 2210.40000.7.0  | 10.0.19045.2311 (22H2) |
| 2211.40000.10.0 | 10.0.19045.2364 (22H2) |
| 2302.40000.9.0  | 10.0.19044.2728 (21H2) |

In theory, this should work with any version of Windows 10 version 2004 (20H1) and above. This is because every update since then has been very minor, and the build number even still shows as 19041 (20H1's build number) in some places, such as the desktop build number watermark if that is enabled.

### Instructions

1. Make sure your Windows version is at least Windows 10 22H2 10.0.19045.2311.
    - You can check your Windows version with command `winver`.
    - If your Windows version is lower than 10.0.19045.2311, please update your Windows to at least 10.0.19045.2311.
2. Get WSA appx zip. You can do this by following instructions in https://github.com/LSPosed/MagiskOnWSALocal
   (You need to "build" this yourself with your local WSL2).
3. Get "icu.dll" from Windows 11 22H2. Note that you MUST use icu.dll from Windows 11.
   The icu.dll from Windows 10 will NOT work.
   (I have made a copy of these DLLs in the original.dll.win11.22h2 dir. They are digitally signed by Microsoft.)
4. Build WsaPatch.dll with source code in this repo.
   (Build with MSVC toolchain, not MinGW or something else.)
5. Patch icu.dll: add WsaPatch.dll as an import DLL as icu.dll.
6. Copy patched icu.dll and WsaPatch.dll to WsaClient dir.
7. Patch AppxManifest.xml.
    1. Find TargetDeviceFamily node in AppxManifest.xml.
       ```xml
       <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.22000.120" MaxVersionTested="10.0.22000.120"/>
       ```

       Change the `MinVersion` from `10.0.22000.120` to `10.0` plus the OS Build number that appears in `winver`. For example, if `winver` shows `Version 21H2 (OS Build 19044.2728)`, you'd change it to `10.0.19044.2728`.

    2. Delete all nodes about "customInstall" extension (see below) in AppxManifest.xml.
       ```xml
       <rescap:Capability Name="customInstallActions"/>
       ```

       ```xml
       <desktop6:Extension Category="windows.customInstall">
           <desktop6:CustomInstall Folder="CustomInstall" desktop8:RunAsUser="true">
               <desktop6:RepairActions>
                   <desktop6:RepairAction File="WsaSetup.exe" Name="Repair" Arguments="repair"/>
               </desktop6:RepairActions>
               <desktop6:UninstallActions>
                   <desktop6:UninstallAction File="WsaSetup.exe" Name="Uninstall" Arguments="uninstall"/>
               </desktop6:UninstallActions>
           </desktop6:CustomInstall>
       </desktop6:Extension>
       ```

8. Run "Run.bat" to register your WSA appx.
9. You should be able to run WSA now.

If you don't want to build WsaPatch.dll and patch icu.dll yourself,
you can download the prebuilt binaries from the [release page](https://github.com/cinit/WSAPatch/releases).

### Notice

1. You can only install WSA on a NTFS partition, not on an exFAT partition.
2. You can NOT delete the WSA installation folder.
   What `Add-AppxPackage -Register .\AppxManifest.xml` does is to register an appx package with some existing unpackaged files,
   so you need to keep them as long as you want to use WSA.
   Check https://learn.microsoft.com/en-us/powershell/module/appx/add-appxpackage?view=windowsserver2022-ps for more details.
3. You need to register your WSA appx package before you can run WSA (the 8th step in the instructions).
   For [MagiskOnWSALocal](https://github.com/LSPosed/MagiskOnWSALocal) users, you need to run `Run.bat` in the extracted dir.
   If the script fails, you can take the following steps for diagnosis (admin privilege required):
    1. Open a PowerShell window and change working directory to your WSA directory.
    2. Run `Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Register .\AppxManifest.xml` in PowerShell.
       This should fail with an ActivityID, which is a UUID required for the next step.
    3. Run `Get-AppPackageLog -ActivityID <UUID>` in PowerShell.
       This should print the log of the failed operation.
    4. Check the log for the reason of failure and fix it.

#### About winhttp.dll

- WsaClient.exe does use GetProcAddress to get some functions from winhttp.dll.
- Some functions exist in winhttp.dll of Windows 11 22H2, but not in Windows 10 22H2.
- If you create a file `EnableDebugConsole` in WsaClient directory or set `wsapatch::kDebug` in [WsaPatch.cpp](WsaPatch.cpp) to true,
  you will see the following message from log console.
- If you copy a winhttp.dll from Windows 11 22H2 to WsaClient directory, WsaClient.exe will be able to find these functions.
- WSA will still run even if you don't copy a winhttp.dll with these symbols.

```text
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpRegisterProxyChangeNotification, result=NULL
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpUnregisterProxyChangeNotification, result=NULL
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpGetProxySettingsEx, result=NULL
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpGetProxySettingsResultEx, result=NULL
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpFreeProxySettingsEx, result=NULL
```

### Problems I met

1. When using WSA 2209.40000.26.0, I was able to run applications in WSA,
   but I was not able to connect to WSA ADB after enabling Developer Mode,
   since netstat shows that no process is listening on port 58526.
   After I upgraded to WSA 2210.40000.7.0, I was able to connect to WSA ADB.
2. The WSA settings window does not hava a draggable title,
   but you can move the WSA window if you hold the cursor left near the "minimize" button,
   or press Alt+Space, then click "Move" in the context
   menu. [#1](https://github.com/cinit/WSAPatch/issues/1) [#2](https://github.com/cinit/WSAPatch/issues/2)
3. If your WSA crashes(or suddenly disappears) when starting up, try to upgrade your Windows to Windows 10 22H2 10.0.19045.2311.
   (Someone has reported that WSA failed to start on 22H2 19045.2251, but worked after upgrading to 19045.2311.)

If you encounter any problems or have any suggestions, please open an issue or pull request.

### Screenshot

![screenshot](./pic/screenshot_20221202.png)

```

`README_zhs.md`:

```md
# 适用于 Windows 10 的 WSA 补丁

[English version](./README.md)

这是一个可以让 Windows 10 运行 WSA (Windows Subsystem for Android) 的补丁及其使用方法。

本人测试过 Windows 10 22H2 10.0.19045.2311 x64 + WSA 2210.40000.7.0 以及 10.0.19045.2364 + 2211.40000.10.0.

### 操作步骤

1. 将你的系统更新到 Windows 10 22H2 10.0.19045.2311 或更高版本.
    - 你可以通过 `winver` 命令查看您当前的 Windows 版本.
    - 如果您的 Windows 版本低于 10.0.19045.2311, 请将您的系统更新到 10.0.19045.2311 或以上.
2. 安装 WSL2 (我用的 Ubuntu 22.04 LTS, 当然你也可以选择你喜欢的发行版，下一步要用到).
3. 按照 https://github.com/LSPosed/MagiskOnWSALocal 的步骤，得到集成了 Magisk 的 WSA AppX 包.
    - 注：你需要在你的 WSL2 里进行操作，WSA 版本建议选 Insider Fast/Dev Channel.
4. 把你的 WSA AppX 包从 WSL2 里复制出来, 它应该是一个压缩包, 解压到你希望安装 WSA 的地方.
    - 位于 `MagiskOnWSALocal/output`, 文件名类似于 `WSA-with-magisk-stable-MindTheGapps_2210.40000.7.0_x64_Release-Nightly.7z`.
5. 用 Visual Studio 编译本仓库的代码，得到 WsaPatch.dll (用 MSVC 工具链编译，如果你不想自己编译，你可以去 release 里下).
6. 想办法从 Windows 11 22H2 的 System32 里复制一个 icu.dll 过来，找一个 PE32+ 编辑工具给它的导入表加一个 WsaPatch.dll.
    - 你必须用 Windows 11 22H2 里的 icu.dll, 因为 Windows 10 的 icu.dll 缺符号;
    - 如果你没有 Windows 11 22H2, 本仓库的 original.dll.win11.22h2 就有原版带微软签名的 icu.dll;
    - 如果你不想自己搞，你可以用 release 里已经修改过的 icu.dll.
7. 把编译好的 WsaPatch.dll 和修改过的 icu.dll 复制到 WSA 的 WsaClient 文件夹.
8. 按以下要求修改 AppxManifest.xml:
    1. 在 `AppxManifest.xml` 找到 `TargetDeviceFamily` 节点
       ```xml
       <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.22000.120" MaxVersionTested="10.0.22000.120"/>
       ```

       把 `MinVersion` 从 `10.0.22000.120` 改成 `10.0.19045.2311`.

    2. 在 `AppxManifest.xml` 删除 "customInstall" 相关节点，一共有两个.
       找到以下内容，然后删掉.

       ```xml
       <rescap:Capability Name="customInstallActions"/>
       ```

       ```xml
       <desktop6:Extension Category="windows.customInstall">
           <desktop6:CustomInstall Folder="CustomInstall" desktop8:RunAsUser="true">
               <desktop6:RepairActions>
                   <desktop6:RepairAction File="WsaSetup.exe" Name="Repair" Arguments="repair"/>
               </desktop6:RepairActions>
               <desktop6:UninstallActions>
                   <desktop6:UninstallAction File="WsaSetup.exe" Name="Uninstall" Arguments="uninstall"/>
               </desktop6:UninstallActions>
           </desktop6:CustomInstall>
       </desktop6:Extension>
       ```

9. 运行 `Run.bat` (需要管理员权限).

编译好的 WsaPatch.dll 和修改过的 icu.dll 可以从 [release 页面](https://github.com/cinit/WSAPatch/releases) 下载.

### 注意事项

1. WSA 只能安装在 NTFS 分区 (请勿安装在 exFAT 分区).
2. 在 `Add-AppxPackage -Register .\AppxManifest.xml` 完成 WSA 的安装后, 你原先解压 WSA 的文件夹不可以删除.
   因为 `Add-AppxPackage -Register .\AppxManifest.xml` 的作用是注册 appx 应用包，它只登记注册，不会复制文件.
   参考 https://learn.microsoft.com/en-us/powershell/module/appx/add-appxpackage?view=windowsserver2022-ps
3. 在解压 WSA 后第一次启动之前, 你需要注册 WSA appx 包 (上文第 9 步).
   对于 [MagiskOnWSALocal](https://github.com/LSPosed/MagiskOnWSALocal) 用户, 你只需要运行解压目录下的 `Run.bat` 即可.
   如果报错失败, 你可以进行以下操作进行错误诊断(需要管理员权限).
    1. 以管理员身份打开 PowerShell, 切换工作目录到 WSA 的解压目录.
    2. 在 PowerShell 中运行 `Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Register .\AppxManifest.xml`.
       该命令应该会失败并提供一个这次错误的 ActivityID (是个 UUID).
    3. 在 PowerShell 中运行 `Get-AppPackageLog -ActivityID <UUID>` 获取刚才的错误的日志.
    4. 根据日志的内容进行修复.

#### 关于 winhttp.dll

- WsaClient.exe 会用 GetProcAddress 从 winhttp.dll 动态获取一些符号.
- 有些符号是只有在 Windows 11 的 winhttp.dll 里才有，Windows 10 的 winhttp.dll 缺少这些符号.
- 如果你在 WsaClient 文件夹建一个名为 `EnableDebugConsole` 的文件(没有扩展名)或者把 [WsaPatch.cpp](WsaPatch.cpp) 里的 `wsapatch::kDebug` 改成 true,
  你能看到 GetProcAddress 有些结果是 NULL.
- 如果你找一个 Windows 11 22H2 的 winhttp.dll 放到 WsaClient 文件夹里(或者 WSA 安装目录)，WsaClient.exe 就能找到这些符号了.
- 但是不管 WsaClient.exe 能否找得到这些符号，它都能用.

```text
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpRegisterProxyChangeNotification, result=NULL
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpUnregisterProxyChangeNotification, result=NULL
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpGetProxySettingsEx, result=NULL
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpGetProxySettingsResultEx, result=NULL
12-10 16:16:29.474 W WsaPatch: -GetProcAddress: hModule=C:\WINDOWS\SYSTEM32\WINHTTP.dll(00007FFC64780000), lpProcName=WinHttpFreeProxySettingsEx, result=NULL
```

### 可能遇到的问题

1. 如果老版本的 WSA 2209.40000.26.0 开了开发者模式也连不上 ADB (端口没有进程监听), 更新到 WSA 2210.40000.7.0 就可以了.
2. 移动 WSA 的设置窗口可以通过按住窗口最小化按钮左边的一小块空白区域然后拖动, 也可以通过按快捷键 Alt+Space 然后点弹出菜单里的 "移动".
   [#1](https://github.com/cinit/WSAPatch/issues/1) [#2](https://github.com/cinit/WSAPatch/issues/2)
3. 如果你的 WSA 在启动时闪退且没有任何提示，请将 Windows 10 更新到 22H2 10.0.19045.2311 或更高版本.
   (有人反应过 WSA 在 22H2 19045.2251 闪退, 但更新到 22H2 19045.2311 就能用了).

如果你遇到了其他问题或者有什么建议，欢迎在 Issue/PR 中提出.

### 截图

![screenshot](./pic/screenshot_20221202.png)

```

`TimeUtils.cpp`:

```cpp
//
// Created by Administrator on 2022.11.30.
//

#include "TimeUtils.h"

#include <windows.h>

u64 currentTimeMillis() {
    FILETIME ft = {};
    GetSystemTimeAsFileTime(&ft);
    u64 ret = ft.dwHighDateTime;
    ret <<= 32;
    ret |= ft.dwLowDateTime;
    ret /= 10000LLU;
    return ret - 116444736000000000LLU;
}

u64 currentTimeSeconds() {
    return currentTimeMillis() / 1000LLU;
}

void timeMillisToUTCCalendar(u64 timeMillis, int *year, int *month, int *day, int *hour, int *minute, int *second, int *millisecond) {
    SYSTEMTIME st = {};
    FILETIME ft = {};
    u64 fileTime = (timeMillis + 116444736000000000LLU) * 10000LLU;
    ft.dwHighDateTime = (DWORD) (fileTime >> 32);
    ft.dwLowDateTime = (DWORD) fileTime;
    FileTimeToSystemTime(&ft, &st);
    if (year != nullptr) {
        *year = st.wYear;
    }
    if (month != nullptr) {
        *month = st.wMonth;
    }
    if (day != nullptr) {
        *day = st.wDay;
    }
    if (hour != nullptr) {
        *hour = st.wHour;
    }
    if (minute != nullptr) {
        *minute = st.wMinute;
    }
    if (second != nullptr) {
        *second = st.wSecond;
    }
    if (millisecond != nullptr) {
        *millisecond = st.wMilliseconds;
    }
}

static u64 gsTimeBiasSeconds = 0;
static bool gsTimeBiasSecondsInitialized = false;

s32 getLocalTimeBiasSeconds() {
    if (!gsTimeBiasSecondsInitialized) {
        TIME_ZONE_INFORMATION tzi = {};
        GetTimeZoneInformation(&tzi);
        gsTimeBiasSeconds = -tzi.Bias * 60LU;
        gsTimeBiasSecondsInitialized = true;
    }
    return gsTimeBiasSeconds;
}

void timeMillisToLocalCalendar(u64 timeMillis, int *year, int *month, int *day, int *hour, int *minute, int *second, int *millisecond) {
    u64 timeWithBias = timeMillis + getLocalTimeBiasSeconds() * 1000;
    timeMillisToUTCCalendar(timeWithBias, year, month, day, hour, minute, second, millisecond);
}

```

`TimeUtils.h`:

```h
//
// Created by Administrator on 2022.11.30.
//

#ifndef WSAPATCH_TIMEUTILS_H
#define WSAPATCH_TIMEUTILS_H

#include "macros.h"

u64 currentTimeMillis();

u64 currentTimeSeconds();

void timeMillisToLocalCalendar(u64 timeMillis, int *year, int *month, int *day, int *hour, int *minute, int *second, int *millisecond);

void timeMillisToUTCCalendar(u64 timeMillis, int *year, int *month, int *day, int *hour, int *minute, int *second, int *millisecond);

s32 getLocalTimeBiasSeconds();

#endif //WSAPATCH_TIMEUTILS_H

```

`WsaPatch.cpp`:

```cpp
#include "WsaPatch.h"

#include <string>
#include <string_view>

#include <windows.h>

#include "Log.h"
#include "ErrnoRestorer.h"
#include "TimeUtils.h"

static constexpr auto LOG_TAG = L"WsaPatch";

namespace wsapatch {

bool kDebug = false;

HINSTANCE gSelfInstance = nullptr;

HANDLE gConsoleOutput = INVALID_HANDLE_VALUE;
bool gConsoleIsAllocated = false;

HMODULE hNtdll = nullptr;
HMODULE hWsaClient = nullptr;

RTL_OSVERSIONINFOEXW gOsVersionInfo = {0};
bool gIsPatchVersionNumber = false;
bool gIsPatchProductType = false;

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

void defaultLogHandler(Log::Level level, const WCHAR *tag, const WCHAR *msg) {
    HANDLE handle = gConsoleOutput;
    if (handle == nullptr || handle == INVALID_HANDLE_VALUE) {
        return;
    }
    WCHAR buffer[1024] = {};
    u64 now = currentTimeMillis();
    const WCHAR *levelName = Log::levelName(level);
    // MM-dd HH:mm:ss.SSS [level] tag: msg
    int month = 0, day = 0, hour = 0, minute = 0, second = 0, millisecond = 0;
    timeMillisToLocalCalendar(now, nullptr, &month, &day, &hour, &minute, &second, &millisecond);
    StringCchPrintfW(buffer, _countof(buffer),
                     L"%02d-%02d %02d:%02d:%02d.%03d %c %s: %s\n",
                     month, day, hour, minute, second, millisecond,
                     WCHAR(*levelName), tag, msg);
    DWORD written = 0;
    WriteConsoleW(handle, buffer, static_cast<DWORD>(wcslen(buffer)), &written, nullptr);
}

using FuncRtlGetVersion = NTSYSAPI NTSTATUS(*)(PRTL_OSVERSIONINFOW lpVersionInformation);

NTSTATUS WINAPI FakeRtlGetVersion(PRTL_OSVERSIONINFOW lpVersionInformation) {
    // The minimal version is 10.0.22000.120 VER_NT_WORKSTATION
    LOGD(L"-FakeRtlGetVersion");
    DWORD size = lpVersionInformation->dwOSVersionInfoSize;
    memcpy(lpVersionInformation, &gOsVersionInfo, size);
    lpVersionInformation->dwOSVersionInfoSize = size;
    if (gIsPatchVersionNumber) {
        lpVersionInformation->dwBuildNumber = 22000;
    }
    if (gIsPatchProductType && size >= sizeof(OSVERSIONINFOEXW)) {
        ((PRTL_OSVERSIONINFOEXW) lpVersionInformation)->wProductType = VER_NT_WORKSTATION;
    }
    return STATUS_SUCCESS;
}

FARPROC WINAPI BadGetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName) {
    FARPROC result;
    if (hModule == hNtdll && lpProcName != nullptr && strcmp(lpProcName, "RtlGetVersion") == 0) {
        result = reinterpret_cast<FARPROC>(FakeRtlGetVersion);
        SetLastError(0);
    } else {
        result = GetProcAddress(hModule, lpProcName);
        if (result == nullptr) {
            ErrnoRestorer errnoRestorer;
            if (hModule != nullptr) {
                WCHAR buffer[1024] = {};
                GetModuleFileNameW(hModule, buffer, _countof(buffer));
                LOGW(L"-GetProcAddress: hModule=%s(%p), lpProcName=%hs, result=NULL", buffer, hModule, lpProcName);
            } else {
                LOGW(L"-GetProcAddress: hModule=NULL, lpProcName=%hs, result=NULL", lpProcName ? lpProcName : "NULL");
            }
        }
    }
    return result;
}

usize kPageSize = 0;

bool isAddressReadable(void *address) {
    if (kPageSize == 0) {
        SYSTEM_INFO si = {};
        GetSystemInfo(&si);
        kPageSize = si.dwPageSize;
    }
    void *pageBase = reinterpret_cast<void *>(reinterpret_cast<uintptr>(address) & ~(kPageSize - 1));
    MEMORY_BASIC_INFORMATION info = {};
    if (VirtualQuery(pageBase, &info, sizeof(info)) == 0) {
        return false;
    }
    return (info.Protect & PAGE_READONLY) != 0 || (info.Protect & PAGE_READWRITE) != 0;
}

int HookIATProcedure(HMODULE hModule, LPCSTR procName, FARPROC replacement) {
    if (hModule == nullptr || procName == nullptr || replacement == nullptr) {
        LOGE(L"HookIATProcedure: invalid arguments: hModule=%p, procName=%hs, replacement=%p",
             hModule, procName ? procName : "(NULL)", replacement);
        return 0;
    }
    LOGI(L"HookIATProcedure: start, hModule=%p, procName=%hs, replacement=%p", hModule, procName, replacement);
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) hModule;
    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS) ((BYTE *) hModule + pDosHeader->e_lfanew);
    PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)
            ((BYTE *) hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
    int count = 0;
    for (; pImportDesc->Name != 0; pImportDesc++) {
        PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA) ((BYTE *) hModule + pImportDesc->FirstThunk);
        PIMAGE_THUNK_DATA pOrgThunk = (PIMAGE_THUNK_DATA) ((BYTE *) hModule + pImportDesc->OriginalFirstThunk);
        for (; pThunk->u1.Function != 0; pThunk++, pOrgThunk++) {
            if (IMAGE_SNAP_BY_ORDINAL(pOrgThunk->u1.Ordinal)) {
                continue;
            }
            PIMAGE_IMPORT_BY_NAME pImport = (PIMAGE_IMPORT_BY_NAME) ((BYTE *) hModule + pOrgThunk->u1.AddressOfData);
            if (!isAddressReadable((char *) pImport->Name)) {
                LOGE(L"HookIATProcedure: pImport->Name is not readable: %p", pImport->Name);
                WCHAR buffer[1024] = {};
                GetModuleFileNameW(hModule, buffer, _countof(buffer));
                LOGE(L"HookIATProcedure: abort IAT hook, hModule=%s(%p), procName=%hs, replacement=%p",
                     buffer, hModule, procName, replacement);
                return -1;
            }
            if (strcmp((char *) pImport->Name, procName) == 0) {
                LOGI(L"HookIATProcedure: Found %hs at %p", procName, pThunk);
                DWORD oldProtect = 0;
                VirtualProtect(pThunk, sizeof(PVOID), PAGE_READWRITE, &oldProtect);
                pThunk->u1.Function = (DWORD_PTR) replacement;
                VirtualProtect(pThunk, sizeof(PVOID), oldProtect, &oldProtect);
                count++;
            }
        }
    }
    LOGI(L"HookIATProcedure: end, count=%d", count);
    return count;
}

void checkEnableDebugConsole() {
    WCHAR exePath[1024] = {};
    if (GetModuleFileNameW(nullptr, exePath, 1024) != 0) {
        std::wstring path = exePath;
        auto dirLen = path.find_last_of('\\');
        if (dirLen == std::wstring::npos) {
            dirLen = 0;
        }
        std::wstring enableDebugConsole = path.substr(0, dirLen) + L"\\EnableDebugConsole";
        if (GetFileAttributesW(enableDebugConsole.c_str()) != INVALID_FILE_ATTRIBUTES) {
            kDebug = true;
        }
    }
}

bool OnLoad(HINSTANCE hInstDLL) {
    gSelfInstance = hInstDLL;
    hNtdll = GetModuleHandleW(L"ntdll.dll");
    if (hNtdll == nullptr) {
        return false;
    }
    checkEnableDebugConsole();
    hWsaClient = GetModuleHandleW(L"WsaClient.exe");
    if (kDebug) {
        if (AllocConsole()) {
            gConsoleIsAllocated = true;
        }
        gConsoleOutput = CreateFileW(L"CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
        if (gConsoleOutput != INVALID_HANDLE_VALUE) {
            Log::setLogHandler(&defaultLogHandler);
        } else {
            std::wstring msg = std::wstring(L"Error CreateFileW CONOUT$, GetLastError=") + std::to_wstring(GetLastError());
            MessageBoxW(nullptr, msg.c_str(), L"wsapatch.dll", MB_OK | MB_ICONERROR);
        }
    }
    LOGD(L"OnLoad, hInstDLL=%p, hNtdll=%p, hWsaClient=%p", hInstDLL, hNtdll, hWsaClient);
    if (hWsaClient == nullptr) {
        // check if we are loaded into the correct process
        WCHAR filename[MAX_PATH];
        GetModuleFileNameW(nullptr, filename, MAX_PATH);
        // get lower case filename
        for (int i = 0; filename[i] != 0; i++) {
            filename[i] = towlower(filename[i]);
        }
        if (wcsstr(filename, L"\\wsaclinent.exe") == nullptr) {
            WCHAR buf[1024] = {};
            StringCbPrintfW(buf, 1024, L"GetModuleHandleW(L\"WsaClient.exe\") is NULL.\nIs wsapatch.dll loaded into wrong process?\n%s", filename);
            MessageBoxW(nullptr, buf, L"wsapatch.dll", MB_OK | MB_ICONERROR);
            return false;
        }
        return false;
    }
    LOGD(L"ntdll.dll = %p", hNtdll);
    LOGD(L"WsaClient.exe = %p", hWsaClient);
    FuncRtlGetVersion funcRtlGetVersion = reinterpret_cast<FuncRtlGetVersion>(GetProcAddress(hNtdll, "RtlGetVersion"));
    if (funcRtlGetVersion == nullptr) {
        LOGE(L"GetProcAddress(NTDLL.DLL, \"RtlGetVersion\") failed, GetLastError=%d", GetLastError());
        return false;
    }
    gOsVersionInfo.dwOSVersionInfoSize = sizeof(gOsVersionInfo);
    NTSTATUS status = funcRtlGetVersion(reinterpret_cast<PRTL_OSVERSIONINFOW>(&gOsVersionInfo));
    if (!NT_SUCCESS(status)) {
        LOGE(L"funcRtlGetVersion(&osVersionInfo) failed, status=%d", status);
        return false;
    }
    LOGD(L"RtlGetVersion: dwMajorVersion=%d, dwMinorVersion=%d, dwBuildNumber=%d, dwPlatformId=%d",
         gOsVersionInfo.dwMajorVersion, gOsVersionInfo.dwMinorVersion, gOsVersionInfo.dwBuildNumber, gOsVersionInfo.dwPlatformId);
    bool isWin11 = gOsVersionInfo.dwMajorVersion >= 10 && gOsVersionInfo.dwMinorVersion >= 0 && gOsVersionInfo.dwBuildNumber >= 22000;
    gIsPatchVersionNumber = !isWin11;
    gIsPatchProductType = (gOsVersionInfo.wProductType != VER_NT_WORKSTATION);
    if (!gIsPatchVersionNumber && !gIsPatchProductType) {
        LOGW(L"Windows 11 workstation detected, no need to patch");
        return true;
    }
    LOGD(L"Need to patch, gIsPatchVersionNumber=%d, gIsPatchProductType=%d", gIsPatchVersionNumber, gIsPatchProductType);
    int count = HookIATProcedure(hWsaClient, "GetProcAddress", reinterpret_cast<FARPROC>(&BadGetProcAddress));
    if (count == 0) {
        LOGE(L"HookIATProcedure failed, count=%d", count);
        return false;
    } else {
        LOGI(L"HookIATProcedure success, count=%d", count);
    }
    // auxiliary hooks
    // HookIATProcedure(GetModuleHandleW(L"winhttp.dll"), "GetProcAddress", reinterpret_cast<FARPROC>(&BadGetProcAddress));
    // HookIATProcedure(GetModuleHandleW(L"icu.dll"), "GetProcAddress", reinterpret_cast<FARPROC>(&BadGetProcAddress));
    return true;
}

void OnUnload() {
    HANDLE handle = gConsoleOutput;
    if (handle != nullptr && handle != INVALID_HANDLE_VALUE) {
        CloseHandle(handle);
        if (gConsoleIsAllocated) {
            FreeConsole();
            gConsoleIsAllocated = false;
        }
        gConsoleOutput = INVALID_HANDLE_VALUE;
    }
    gSelfInstance = nullptr;
}

}

EXPORT_C void NS_WsaPatch_UnusedSymbol() {
    // nothing
}

BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    // Perform actions based on the reason for calling.
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            return wsapatch::OnLoad(hInstDLL);
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            // no-op
            break;
        case DLL_PROCESS_DETACH:
            if (lpvReserved != nullptr) {
                // do not do cleanup if process termination scenario
                break;
            }
            wsapatch::OnUnload();
            break;
        default:
            break;
    }
    return true;
}

```

`WsaPatch.h`:

```h
#ifndef WSAPATCH_WSAPATCH_H
#define WSAPATCH_WSAPATCH_H

#include "macros.h"

EXPORT_C void NS_WsaPatch_UnusedSymbol();

#endif //WSAPATCH_WSAPATCH_H

```

`macros.h`:

```h
#include <stdint.h>

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef int64_t s64;

typedef size_t usize;
typedef ptrdiff_t isize;

typedef uintptr_t uintptr;

#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif


#if defined(_MSC_VER)
#define EXPORT __declspec(dllexport)
#elif defined(__GNUC__)
#define EXPORT __attribute__((visibility("default"), used))
#else
#error "Unsupported compiler"
#endif

#define EXPORT_C EXTERN_C EXPORT

```