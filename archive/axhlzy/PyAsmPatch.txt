Project Path: arc_axhlzy_PyAsmPatch_kc_803ze

Source Tree:

```txt
arc_axhlzy_PyAsmPatch_kc_803ze
├── AndroidPatch.py
├── AsmPatch.py
├── Config.py
├── MergeUtils.py
├── README.md
├── UnityPatch.py
└── files
    ├── demo
    │   ├── libil2cpp_cp32.so
    │   ├── libil2cpp_final.so
    │   ├── libil2cpp_merge.so
    │   └── test.py
    └── inject
        ├── jni
        │   ├── Android.mk
        │   ├── Application.mk
        │   └── inject.c
        ├── libs
        │   ├── arm64-v8a
        │   │   └── libinject.so
        │   └── armeabi-v7a
        │       └── libinject.so
        └── obj
            └── local
                ├── arm64-v8a
                │   ├── libinject.so
                │   └── objs
                │       └── inject
                │           ├── inject.o
                │           └── inject.o.d
                └── armeabi-v7a
                    ├── libinject.so
                    └── objs
                        └── inject
                            ├── inject.o
                            └── inject.o.d

```

`AndroidPatch.py`:

```py
from AsmPatch import AsmPatcher
from Config import *


class AndroidPatcher(AsmPatcher):
    def __init__(self, filePath, ARCH=ARCH_ARM):
        AsmPatcher.__init__(self, filePath, ARCH=ARCH_ARM)
        print("--------------------------------------------------------------------------")
        self.hookInit()

    def hookInit(self, log=True):
        self.fixGot(log=log)

    def getSymbolByName(self, name, mPtr=None):
        tmpRet = super(AndroidPatcher, self).getSymbolByName(name, mPtr)
        if tmpRet is not None:
            return tmpRet

    def fixGot(self, log):
        if self.lf.ctor_functions[0] is None:
            raise Exception("There is no ctor_functions")
        # 修改权限
        self.addHook(self.lf.ctor_functions[0].value, jmpType="B", printTips=False, printRegs=False)
        # 这个size其实可以填的很大，即使返回了-1，但是它是按照页来修改访问属性的，问题不大，所以返回-1表示我们已经覆盖了全部（超出了）
        self.mprotect(mPtr=functionsMap.get("GLOBAL_TABLE"), size=configSize["mProtect_size"], log=log)
        self.loadBaseToReg(reg="R9", log=True)
        self.relocationGot(reg="R9")
        self.endHook()

    # 获取 il2cpp base address
    # 代码执行到这里的时候我们知道当前的pc值以及当前代码静态的地址，所以我们相减即可得到当前的so基地址
    def loadBaseToReg(self, reg="R4", log=False):
        self.loadToReg(self.getPtr(self.currentPC + 7 * self._pSize), toReg="R1")
        self.patchASM("LDR R2,[R1]")
        self.patchASM("SUB R0,PC,R2")
        self.patchASM("MOV {},R0".format(reg))
        if log:
            self.patchASM("MOV R3,R0")
            self.android_log_print_reg(formart="soAddr -> %p")

    # while(GOT_TABLE[index]!=0x0){
    #       GOT_TABLE[index] += soAddr
    # }
    def relocationGot(self, reg="R9"):
        self.prepareStack(2)
        self.loadToReg(functionsMap.get("GOT_TABLE"), toReg="R5")
        self.patchASM("MOV R7,#0")
        self.patchASM("MOV R10,#0")
        # R5:存放指针 R6:存放具体值 R7:存放偏移 R8:CurrentPtr
        self.patchASM("ADD R8,R5,R7")
        self.patchASM("LDR R6,[R8]")
        self.patchASM("CMP R6,#0")
        # 标识结束，直接跳转到 endHook
        self.jumpTo(self.currentPC + self._pSize * 24, jmpType="BEQ", resetPC=False)
        self.patchASM("MOV R3,R8")
        self.patchASM("ADD R10,#1")
        self.saveRegToStack(fromReg="R6", index=0)
        self.patchASM("ADD R6,R6,{}".format(reg))
        self.saveRegToStack(fromReg="R6", index=1)
        self.android_log_print_reg(formart="GOT relocation %p ---> %p ---> %p")
        self.patchASM("STR R6,[R8]")
        self.patchASM("ADD R7,R7,#4")
        self.jumpTo(self.currentPC - self._pSize * 26, jmpType="B", resetPC=False)
        self.patchASM("MOV R3,R10")
        self.android_log_print_reg(formart="Finished GOT relocation all:%d")
        self.restoreStack(2)

    # 修改PC附近RWX
    def mprotect(self, mPtr=None, size=4096, prot=7, log=False):
        if mPtr is None:
            self.patchASM("MOV R2,PC")
        else:
            self.loadToReg(self.getPtr(mPtr), toReg="R2")
        self.prepareStack(3)
        self.patchASM("MOV R1,R2,LSR#12")
        self.patchASM("MOV R0,R1,LSL#12")
        self.saveRegToStack(fromReg="R0", index=0)
        self.patchASM("MOV R1,#{}".format(size))
        self.saveRegToStack(fromReg="R1", index=1)
        self.patchASM("MOV R2,#{}".format(prot))
        self.saveRegToStack(fromReg="R2", index=2)
        self.jumpTo(self.getRelocation("mprotect"), jmpType="REL", reg="R3", resetPC=False)
        self.patchASM("MOV R3,R0")
        if log:
            self.android_log_print_reg(formart="mprotect ret = %d  args : %p %p %p")
        self.restoreStack(3)

    def strcmp(self, fromSR1, fromSR2, toReg="R0"):
        if str(fromSR1).startswith("R"):
            if str(fromSR1) != "R0":
                self.patchASM("MOV {},{}".format("R0", fromSR1))
        elif type(fromSR1) is str:
            # 填写一个具体的字符串的情况
            self.loadToReg(self.getStr(fromSR1), toReg="R0")
        if str(fromSR2).startswith("R"):
            if str(fromSR2) != "R1":
                self.patchASM("MOV {},{}".format("R1", fromSR2))
        elif type(fromSR2) is str:
            self.loadToReg(self.getStr(fromSR2), toReg="R1")
        self.jumpTo(self.getRelocation("strcmp"), jmpType="REL", reg="R2", resetPC=False)
        if toReg != "R0":
            self.patchASM("MOV {},R0".format(toReg))

    def strcat(self, str0, str1, toReg="R0"):
        if str(str0).startswith("R") and str(str0) != "R0":
            self.patchASM("MOV {},{}".format("R0", str0))
        elif type(str0) is str:
            self.loadToReg(self.getStr(str0), toReg="R0")
        if str(str1).startswith("R") and str(str0) != "R1":
            self.patchASM("MOV {},{}".format("R1", str0))
        elif type(str1) is str:
            self.loadToReg(self.getStr(str1), toReg="R1")
        self.jumpTo(self.getRelocation("strcat"), jmpType="REL", reg="R3", resetPC=False)
        if toReg != "R0":
            self.patchASM("MOV {},R0".format(toReg))

    def strlen(self, fromSR="R0", toReg="R0"):
        if str(fromSR).startswith("R"):
            if str(fromSR) != "R0":
                self.patchASM("MOV {},{}".format("R0", fromSR))
        elif type(fromSR) is str:
            self.loadToReg(self.getStr(fromSR), toReg="R0")
        self.jumpTo(self.getRelocation("strlen"), jmpType="REL", reg="R2", resetPC=False)
        if toReg != "R0":
            self.patchASM("MOV {},R0".format(toReg))

    def calloc(self, count, size, toReg="R0"):
        self.patchASM("MOV R0,#{}".format(count))
        self.patchASM("MOV R1,#{}".format(size))
        self.jumpTo(self.getRelocation("calloc"), jmpType="REL", reg="R12", resetPC=False)
        if toReg != "R0":
            self.patchASM("MOV {},R0".format(toReg))

    def malloc(self, size, toReg="R0"):
        self.patchASM("MOV R0,#{}".format(size))
        self.jumpTo(self.getRelocation("malloc"), jmpType="REL", reg="R12", resetPC=False)
        if toReg != "R0":
            self.patchASM("MOV {},R0".format(toReg))

    def free(self, fromReg="R1"):
        self.patchASM("MOV R0,{}".format(fromReg))
        self.jumpTo(self.getRelocation("free"), jmpType="REL", reg="R12", resetPC=False)

    def android_log_print_msg(self, prio=3, tag="ZZZ", msg="Called"):
        self.patchASM("MOV R0, #{}".format(prio))
        self.loadToReg(self.getStr(tag), toReg="R1")
        self.loadToReg(self.getStr(msg), toReg="R2")
        self.jumpTo(self.getRelocation("__android_log_print"), jmpType="REL", reg="R3", resetPC=False)

    # 依次对R3,sp,sp#4,sp#8... 进行参数传递
    def android_log_print_reg(self, prio=3, tag="ZZZ", formart="---> %p"):
        self.patchASM("MOV R0, #{}".format(prio))
        self.loadToReg(self.getStr(tag), toReg="R1")
        self.loadToReg(self.getStr(formart), toReg="R2")
        self.jumpTo(self.getRelocation("__android_log_print"), jmpType="REL", reg="R4", resetPC=False)

    # 封装一层,参数传递使用R0依次往后(不受限于R0-R3参数传递)
    def android_log_print_mix(self, formart="---> %p", countArgs=1, prio=3, tag="ZZZ"):
        self.saveEnv(simple=True)
        if countArgs <= 1:
            self.patchASM("MOV R3,R0")
            self.android_log_print_reg(formart=formart, prio=prio, tag=tag)
        else:
            self.prepareStack(countArgs - 1)
            for i in range(1, countArgs - 1):
                self.saveRegToStack("R{}".format(i), i - 1)
            self.android_log_print_reg(formart=formart, prio=prio, tag=tag)
            self.restoreStack()
        self.restoreEnv(simple=True)

    def callFunction(self, mPtr, *args):
        for i in range(0, len(args)):
            if i <= 3:
                if type(args[i]) == str:
                    self.loadToReg(self.getStr(args[i]), "R{}".format(i - 1))
                elif type(args[i]) == int:
                    self.patchASM("MOV R{},{}".format("R{}".format(i - 1), args[i]))
            else:
                argL = len(args) - 4
                self.prepareStack(argL)
                for t in range(argL, len(args)):
                    self.loadToReg(mPtr=self.getPtr(mPtr), toReg="R4")
                    self.saveRegToStack(fromReg="R4", index=t - 4)
                self.restoreStack()
        self.jumpTo(mPtr, jmpType="BL", resetPC=False, reg="R4")

```

`AsmPatch.py`:

```py
#
#  @Author      lzy <axhlzy@live.cn>
#  @HomePage    https://github.com/axhlzy
#  @CreatedTime 2021/09/30 18:42
#  @Des         Use keystone,capstone,lief to patch arm32
#

import os

import capstone
import lief
from keystone import keystone

from Config import ARCH_ARM, functionsMap, configSize, gotMap, hookedFunctions, ARCH_ARM64, preFuncMap


class AsmPatcher:

    def __init__(self, filePath, ARCH=ARCH_ARM):

        self.filePath = filePath
        self.fileName = os.path.basename(filePath)
        self.fileDIR = os.path.abspath(filePath)
        self.lf = lief.parse(filePath)

        self.currentPC = 0
        self.currentPtr = functionsMap.get("GLOBAL_TABLE")
        self.currentStr = functionsMap.get("STR_TABLE")
        self.currentGOT = functionsMap.get("GOT_TABLE")
        self.currentTramp = functionsMap.get("trampolines")
        self.currentCodes = functionsMap.get("textCodes")

        self.mapPtr = {}
        self.mapStr = {}

        self._pSize = ARCH
        self._AllocSpSize = 0
        self._lastPC = 0
        self._jumpBackPC = 0
        self._returnAddr = 0
        self._codeContainer = [[], [], [], [], [], [], [], [], []]
        self._extraFixData = [{}, {}, {}, {}, {}, {}, {}, {}, {}]
        self._recordFromToLOG = []

        if ARCH == ARCH_ARM:
            self.cs = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
            self.ks = keystone.Ks(keystone.KS_ARCH_ARM, keystone.KS_MODE_ARM)
        elif ARCH == ARCH_ARM64:
            # self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
            # self.ks = keystone.Ks(keystone.KS_ARCH_ARM64, keystone.KS_MODE_ARM)
            raise Exception("Todo  -.-")
        else:
            raise Exception("Todo  -.-")

        # 我们需要使用到的导出函数（主要是一些系统函数，如果有没有，我们需要自己去添加需要的lib以及添加导出项）
        # print("\nCurrent Needed Libraries : ")
        # for name in self.lf.libraries:
        #     print("\t[*] " + name)
        # if not self.Jumper.lf.has_library("liblog.so"):
        #     self.Jumper.lf.add_library("liblog.so")

    def resetPC(self, PC):
        self.currentPC = PC

    # 计算地址偏移
    def calOffset(self, fromAddr, toAddr, offset=2):
        if fromAddr == 0:
            return str(hex((toAddr & 0xFFFFFFFF)))
        else:
            return str(hex((toAddr - (fromAddr + self._pSize * offset) & 0xFFFFFFFF)))

    def calOffsetToList(self, fromAddr, toAddr=0, offset=2):
        tmpStr = str(self.calOffset(fromAddr, toAddr, offset)).lstrip('0x')
        while tmpStr.__len__() < 8:
            tmpStr = "0" + tmpStr
        tmpList = list(bytearray.fromhex(tmpStr))
        # arm32 小端存储
        if self._pSize == ARCH_ARM:
            tmpList.reverse()
        return tmpList

    def getAsmFromList(self, mList, startAddr=0x1000):
        retList = []
        for i in self.cs.disasm(bytes(mList), startAddr):
            retList.append("{} {}".format(i.mnemonic, i.op_str))
        return retList

    def getAsmFromAddress(self, address=0, length=1):
        if address == 0:
            address = self.currentPC
        return self.getAsmFromList(self.lf.get_content_from_virtual_address(address, 4 * length), address)

    def patchList(self, mList):
        self.lf.patch_address(self.currentPC, mList)
        self.currentPC += mList.__len__()

    def patchASM(self, asm="nop", labName=None):
        if labName is not None:
            self.preLabel(labName)
        self.patchList(self.ks.asm(asm)[0])

    def preLabel(self, labName):
        preFuncMap[0].setdefault(labName, self.currentPC)

    # use like this " B #lable1 /bne #lable2 "
    def preAsm(self, asm="nop", labName=None):
        if labName is not None:
            self.preLabel(labName)
        preFuncMap[1].setdefault(asm, self.currentPC)
        self.patchASM("nop")

    def preAsmEnable(self):
        for func in preFuncMap[1].items():
            opStr = str(func[0]).split("#")[0]
            opSub = str(func[0]).split("#")[1]
            opNum = 0
            for label in preFuncMap[0].items():
                if label[0] == opSub:
                    opNum = self.calOffset(func[1], label[1], offset=0)
            if opNum == 0:
                raise Exception("Label Not Found")
            tmpPC = self.currentPC
            self.resetPC(func[1])
            self.patchASM("{} #{}".format(opStr, opNum))
            self.currentPC = tmpPC
        preFuncMap[0].clear()
        preFuncMap[1].clear()

    def saveEnv(self, fpReg="R11", simple=False):
        if not simple:
            self.patchASM("push {r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, lr}")
            self.patchASM("MRS R11, CPSR")
            self.patchASM("MOV R12, SP")
            self.patchASM("STMFD SP!, {R11,R12}")
            self.patchASM("MOV {},SP".format(fpReg))
        else:
            self.patchASM("push {r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, lr}")

    def restoreEnv(self, simple=False):
        if not simple:
            self.patchASM("LDMFD SP!, {R11,R12}")
            self.patchASM("MSR CPSR, R11")
            self.patchASM("pop {r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, lr}")
        else:
            self.patchASM("pop {r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, pc}")

    def saveCode(self, codeIndex=0, insLength=3, fromPtr=None):
        if fromPtr is None:
            fromPtr = self.currentPC
        self._codeContainer[codeIndex] = self.lf.get_content_from_virtual_address(fromPtr, self._pSize * insLength)

    def restoreCode(self, codeIndex=0, needFix=True):

        def getType(insStr):
            # 修复 LDR (其实这一步的修复也可以像后面一样直接把pc用r12来替换) / LDR R0, =(byte_125A8C9 - 0x357B18)
            if insStr.find("ldr") != -1 and insStr.find("pc") != -1 and insStr.find("#") != -1:
                return "ldr1"
            # 修复 LDR / LDR R0, [PC,R0]
            elif insStr.find("ldr") != -1 and insStr.find("pc") != -1 and insStr.find("#") == -1:
                return "ldr2"
            # MOV/ADD/SUB PC 相关的指令
            elif (insStr.find("mov") != -1 or insStr.find("add") != -1 or insStr.find("sub") != -1) and insStr.find(
                    "pc") != -1:
                return "fixPC"
            # 修复 BNE/BEQ
            elif insStr.find("bne") == 0 or insStr.find("beq") == 0:
                return "fixBneBeq"
            # 修复 BL/BLX and 修复 B/BX (排除 bl rx的情况)
            elif ((insStr.find("bl") != -1 or insStr.find("blx") != -1) or (insStr.find("b") != -1 or insStr.find("bx") != -1)) \
                    and insStr.find("r") == -1 and insStr.find("sp") == -1:
                return "fixBJmp"
            else:
                return "default"

        # 修复该条指令需要用到几条指令
        def getTypePatchSize(insStr):
            tmpType = getType(insStr)
            if tmpType == "default": return 1
            if tmpType == "ldr1": return 3
            if tmpType == "ldr2": return 4
            if tmpType == "fixPC": return 7
            if tmpType == "fixBneBeq": return 2
            if tmpType == "fixBJmp": return 1

        def fixLDR(insStr):
            # tmpCodeContainer.extend(self.ks.asm(tmpInsList[index].replace("pc", "r12"))[0])
            tmpLdrPC = self._extraFixData[codeIndex]["fromAddress"] + self._pSize * (index + 2) + eval(
                insStr[insStr.find("#") + 1:insStr.find("]")])
            tmpReg = insStr[insStr.find("ldr ") + 4:insStr.find(", [")]
            self.patchASM("LDR {}, [PC,#0]".format(tmpReg))
            self.jumpTo(self.currentPC + self._pSize * 2, jmpType="B", resetPC=False)
            self.patchList(self.calOffsetToList(self.currentPC - 4, tmpLdrPC, 1))

        def fixPC(insStr):
            # 零时用一下就懒得移动SP，直接把R12放在SP的上面
            self.patchASM("STR R12,[SP,#-0x4]")
            fixAddr = self.addGOT(self._extraFixData[codeIndex]["fromAddress"] + self._pSize * (index + 2))
            self.loadToReg(fixAddr, toReg="R12")
            self.patchASM("LDR R12,[R12]")
            self.patchASM(insStr.replace("pc", "r12"))
            self.patchASM("LDR R12,[SP,#-0x4]")

        def fixBeqBne(insStr):
            tmpOffset = insStr.split("#")[1]
            if insStr.find("beq") == 0:
                tItem = insStr.replace("beq", "bne").replace(tmpOffset, hex(self._pSize * 4))
            else:
                tItem = insStr.replace("bne", "beq").replace(tmpOffset, hex(self._pSize * 4))
            self.patchASM(tItem)
            tmpToAddr = self._extraFixData[codeIndex]["fromAddress"] + self._pSize * index + eval(tmpOffset) - configSize["offset"]
            self.jumpTo(tmpToAddr - self._pSize * 2, jmpType="LDR", resetPC=False)

        def fixBJmp(insStr):
            # eval(item.split("#")[1]) 原本的 BL 已经被修正过了，所以这里得修复一下跳转 多了一次offset （- configSize["offset"]）
            toAddress = self._extraFixData[codeIndex]["fromAddress"] + self._pSize * index + eval(
                insStr.split("#")[1]) - configSize["offset"]
            jmpType = "REG" if (insStr.find("bl") != -1 or insStr.find("blx") != -1) else "LDR"
            # 默认计算了pc偏移的，然而bl本身就是一个简单的加法，所以这里的toAddress需要减去2个_pSize
            self.jumpTo(toAddress - self._pSize * 2, jmpType=jmpType, reg="R12", resetPC=False)

        def default(insStr):
            self.patchASM(insStr)

        operation = {'ldr1': fixPC,  # fixLDR
                     'ldr2': fixPC,
                     'fixPC': fixPC,
                     'fixBneBeq': fixBeqBne,
                     'fixBJmp': fixBJmp,
                     'default': default
                     }
        tmpInsList = self.getAsmFromList(self._codeContainer[codeIndex])
        if needFix:
            # 逐条解析保存的指令并修复指令
            for index in range(0, len(tmpInsList)):
                operation[getType(tmpInsList[index])](tmpInsList[index])
        else:
            self.patchList(self._codeContainer[codeIndex])

    def save(self, name=None):
        # 检查范围
        if self.currentGOT > self.getSymbolByName("GOT_TABLE") + configSize["GOT_TABLE"] \
                or self.currentPtr > self.getSymbolByName("STR_TABLE") + configSize["STR_TABLE"] \
                or self.currentPtr > self.getSymbolByName("GLOBAL_TABLE") + configSize["GLOBAL_TABLE"] \
                or self.currentTramp > self.getSymbolByName("trampolines") + configSize["trampolines"]:
            raise Exception("Out of inject size")
        if self.currentCodes > self.getSymbolByName("textCodes") + configSize["textCodes"]:
            print("textCodes may be exceeded here")

        # 保存在传入so的目录下，未填写名称则默认在原名称后面添加一个N
        if name is None:
            oldNameSp = self.fileName.split(".")
            newName = oldNameSp[0] + "N." + oldNameSp[1]
            path = self.fileDIR.replace(self.fileName, newName)
        else:
            path = os.path.dirname(self.filePath) + "\\" + name
        self.lf.write(path)
        print("\nSave libil2cpp.so to " + path)
        return path

    # codeIndex 保存被覆盖的几条指令
    # jmpType   跳转方式: b bl rel ldr
    # reg       ldr 跳转借用的寄存器(请选择没有使用到的寄存器)
    # reSetPC   是否把pc指向跳转过去的位置
    def jumpTo(self, toAddress=0, fromAddress=0, codeIndex=-1, jmpType="LDR", reg="R12", resetPC=True,
               resetBackPC=False, showLog=False):
        if fromAddress != 0:
            self.resetPC(fromAddress)
        else:
            fromAddress = self.currentPC

        if toAddress == 0:
            toAddress = self._returnAddr

        # BL 跳转范围操过,修改跳转方式为 REG
        if jmpType == "BL" or jmpType == "B":
            try:
                self.checkJmpRange(fromAddress, toAddress)
            except:
                _jmpType = "REG" if jmpType == "BL" else "LDR"
                tmpStr = hex(fromAddress) + " ---> " + hex(toAddress) + "\t" + jmpType + " ---> " + _jmpType
                jmpType = _jmpType
                print("[*] Fixed {}".format(tmpStr))

        # 记录原本被替换的AsmCode
        def SaveCode():
            if jmpType == "B" or jmpType == "BL":
                # 记录函数返回地址
                if resetBackPC:
                    self._jumpBackPC = fromAddress + self._pSize * 1
                if codeIndex != -1:
                    self.saveCode(codeIndex, 1)
            elif jmpType == "LDR":
                if resetBackPC:
                    self._jumpBackPC = fromAddress + self._pSize * 3
                if codeIndex != -1:
                    self.saveCode(codeIndex, 3)

            self._extraFixData[codeIndex] = {"fromAddress": fromAddress, "toAddress": toAddress, "jmpType": jmpType,
                                             "reg": reg, "resetPC": resetPC, "resetBackPC": resetBackPC,
                                             "showLog": showLog}

        def JMP_B():
            self.checkJmpRange(self.currentPC, toAddress)
            SaveCode()
            self._returnAddr = self.currentPC + self._pSize * 1
            self.patchASM("B #{}".format(self.calOffset(self.currentPC - 4 * 2, toAddress)))  # B/BL 本就是从当前位置算起
            if showLog:
                print('\n[*] Patch Code TYPE : JMP_B')
                tmpPC = self.currentPC - 4
                print("\t" + hex(tmpPC) + " " + self.getAsmFromList(self._codeContainer[codeIndex])[0]
                      + "\t--->\t" + self.getAsmFromAddress(tmpPC)[0])

        def JMP_BL():
            self.checkJmpRange(self.currentPC, toAddress)
            SaveCode()
            self._returnAddr = self.currentPC + self._pSize * 1
            self.patchASM("BL #{}".format(self.calOffset(self.currentPC - 4 * 2, toAddress)))
            if showLog:
                print('\n[*] Patch Code TYPE : JMP_BL')
                tmpPC = self.currentPC - 4
                print("\t" + hex(tmpPC) + " " + self.getAsmFromList(self._codeContainer[codeIndex])[0]
                      + "\t--->\t" + self.getAsmFromAddress(tmpPC)[0])

        def JMP_BEQ():
            self.checkJmpRange(self.currentPC, toAddress)
            self.patchASM("BEQ #{}".format(self.calOffset(self.currentPC - 4 * 2, toAddress)))

        def JMP_BNE():
            self.checkJmpRange(self.currentPC, toAddress)
            self.patchASM("BNE #{}".format(self.calOffset(self.currentPC - 4 * 2, toAddress)))

        def JMP_LDR():
            SaveCode()
            self._returnAddr = self.currentPC + self._pSize * 3
            self.patchASM("LDR {},[PC]".format(reg))
            self.patchASM("ADD PC,{}".format(reg))
            self.patchList(self.calOffsetToList(self.currentPC - 4, toAddress))  # 起点算的是pc的位置(上一条)，而不是当前位置

            if showLog:
                print('\n[*] Patch Code TYPE : JMP_LDR')
                tmpPC = self.currentPC - 4 * 3
                listPatch = self.lf.get_content_from_virtual_address(tmpPC + 4 * 2, 4)
                listPatchCP = listPatch.copy()
                listPatchCP.reverse()
                listStr = ""
                for i in listPatchCP:
                    listStr += hex(i)
                listStr = "0x" + listStr.replace("0x", "").lstrip("0")

                tmpSrcCode = self.getAsmFromList(self._codeContainer[codeIndex])
                print("\t" + hex(tmpPC + 4 * 0) + " " + tmpSrcCode[0]
                      + "\t\t\t\t    \t" + self.getAsmFromAddress(tmpPC + 4 * 0)[0])
                print("\t" + hex(tmpPC + 4 * 1) + " " + tmpSrcCode[1]
                      + "\t\t\t\t--->\t" + self.getAsmFromAddress(tmpPC + 4 * 1)[0])
                print("\t" + hex(tmpPC + 4 * 2) + " " + tmpSrcCode[2]
                      + "\t\t\t    \t" + str(listPatch) + "  " + listStr)

        def JMP_REG():
            SaveCode()
            self._returnAddr = self.currentPC + self._pSize * 5
            self.patchASM("LDR {},[PC,#4]".format(reg))
            self.patchASM("ADD {},PC,{}".format(reg, reg))
            self.jumpTo(self.currentPC + self._pSize * 2, jmpType="B", resetPC=False)
            self.patchList(self.calOffsetToList(self.currentPC - 8, toAddress))
            self.patchASM("BLX {}".format(reg))

        def JMP_REL():
            self.patchASM("LDR {}, [PC,#0xC]".format(reg))
            self.patchASM("ADD {}, PC, {}".format(reg, reg))
            self.patchASM("LDR {}, [{}]".format(reg, reg))
            self.patchASM("BLX {}".format(reg))
            self.jumpTo(self.currentPC + self._pSize * 2, jmpType="B", resetPC=False)
            self.patchList(self.calOffsetToList(self.currentPC - 8, toAddress, 0))

        switch = {'LDR': JMP_LDR,  # 远距离的B
                  'REG': JMP_REG,  # 远距离的BL
                  'REL': JMP_REL,  # 跳转GOT
                  'BEQ': JMP_BEQ,
                  'BNE': JMP_BNE,
                  'BL': JMP_BL,
                  'B': JMP_B}
        switch.get(jmpType, JMP_B)()
        if resetPC:
            self.currentPC = toAddress

    def loadToReg(self, mPtr, toReg="R0", fix=1):
        self.patchASM("LDR {}, [PC,#4]".format(toReg))
        self.patchASM("ADD {}, PC, {}".format(toReg, toReg))
        self.jumpTo(self.currentPC + self._pSize * 2, jmpType="B", resetPC=False)
        self.patchList(self.calOffsetToList(self.currentPC - 4, mPtr, fix))

    def saveRegToMem(self, fromReg="R0", toPtr=0x0, tmpReg="R12"):
        self.patchASM("LDR {}, [PC,#8]".format(tmpReg))
        self.patchASM("ADD {}, PC, {}".format(tmpReg, tmpReg))
        self.patchASM("STR {}, [{}]".format(fromReg, tmpReg))
        self.jumpTo(self.currentPC + self._pSize * 2, jmpType="B", resetPC=False)
        self.patchList(self.calOffsetToList(self.currentPC - 4, toPtr, 0))

    def addGOT(self, mPtr, des=None):
        self._lastPC = self.currentPC
        self.resetPC(self.currentGOT)
        tmpAddr = self.currentGOT
        self.patchList(self.calOffsetToList(0, mPtr))
        self.currentGOT = self.currentPC
        self.currentPC = self._lastPC
        tmpKey = mPtr if des is None else des
        gotMap.setdefault(tmpKey, tmpAddr)
        return tmpAddr

    def getPtr(self, mPtr):
        for item in self.mapPtr.items():
            if item[1] == mPtr:
                return item[0]
        # 保存jumper中的_currentPC
        self._lastPC = self.currentPC
        # 修改jumper中的保存jumper中的_currentPC指向 GLOBAL_TABLE 当前位置
        self.resetPC(self.currentPtr)
        # 临时记录 currentPtr
        tmpAddr = self.currentPtr
        # 修改值
        self.patchList(self.calOffsetToList(0, mPtr))
        # 修改后指针加一赋值给 AsmCommon 中的 currentPtr（下次使用）
        self.currentPtr = self.currentPC
        # 恢复修改后的jumper中的 currentPC
        self.currentPC = self._lastPC
        # 记录在在字典中 mapPtr
        self.mapPtr.setdefault(tmpAddr, mPtr)
        # print("[*] Added Ptr {} ---> {}".format(hex(tmpAddr), hex(mPtr)))
        return tmpAddr

    def getStr(self, mStr, useCache=True):
        # 查找已有字符串的情况，不再走添加流程
        if useCache:
            for itemC in self.mapStr.items():
                if itemC[1] == mStr:
                    print("[*] Get string at " + str(hex(itemC[0])) + "\t" + mStr)
                    return itemC[0]
                    # for itemP in self.mapPtr.items():
                    #     if itemP[1] == itemC[0]:
                    #         return itemP[0]
        # 保存jumper中的currentPC
        self._lastPC = self.currentPC
        # 字符编码为 utf-8
        listStr = list(mStr.encode(encoding="utf-8"))
        # 字符串末尾补零
        listStr.append(0x0)
        # 四字节对齐
        # for i in range(0, 4 - listStr.__len__() % 4):
        #     listStr.append(0x0)
        # 修改jumper中的保存jumper中的currentPC指向 STR_TABLE 当前位置
        self.resetPC(self.currentStr)
        # 临时记录 currentPtr 字符串开始位置
        tmpAddr = self.currentStr
        # 存入String的值
        self.patchList(listStr)
        # 记录在在字典中 mapStr
        self.mapStr.setdefault(tmpAddr, mStr)
        # 修改后指针加一赋值给 AsmCommon 中的 currentStr（下次使用）
        self.currentStr = self.currentPC
        # 恢复修改后的jumper中的 currentPC
        self.currentPC = self._lastPC
        # 保存 string 到 GLOBAL_TABLE
        self.getPtr(self.currentStr - listStr.__len__())
        print("[*] Create string at " + str(hex(tmpAddr)) + "\t" + mStr)
        return tmpAddr

    def getAddrByExpName(self, expName):
        return self.lf.get_symbol(expName).value

    def getRelocation(self, expName):
        return self.lf.get_relocation(expName).address

    # 调用 addHook 之后 currentPC 指向了我们写代码的位置
    def addHook(self, fromPtr, jmpType="LDR", printTips=True, printRegs=False, needFix=True):
        if type(fromPtr) == str:
            fromPtr = self.getSymbolByName(fromPtr)
        self._recordFromToLOG = [fromPtr, self.currentTramp, jmpType]
        if hookedFunctions.get(fromPtr) is not None:
            raise Exception("Ptr:{} is Already Hooked".format(hex(fromPtr)))

        print("addHook {} ---> {}\t{}\n----------".format(hex(self._recordFromToLOG[0]), hex(self._recordFromToLOG[1]),
                                                          self._recordFromToLOG[2]))

        self.jumpTo(self.currentTramp, fromPtr, codeIndex=0, jmpType=jmpType, reg="R12", resetPC=True, resetBackPC=True)
        self.saveEnv()
        if printTips:
            self.jumpTo(self.getSymbolByName("printTips", mPtr=fromPtr), jmpType="BL", resetPC=False)
        # 读取hook时候的registers
        if printRegs:
            self.jumpTo(self.getSymbolByName("printRegs"), jmpType="BL", resetPC=False)
        # 跳转真实hook代码
        self.jumpTo(self.currentCodes, jmpType="BL", resetPC=False)
        self.restoreEnv()
        self.restoreCode(codeIndex=0, needFix=needFix)
        self.jumpTo(self._jumpBackPC, fromAddress=self.currentPC, jmpType=jmpType, reg="R12", resetPC=False)
        self.currentTramp = self.currentPC
        self.currentPC = self.currentCodes
        self.patchASM("STMFD SP!, {LR}")

    def endHook(self):
        self.patchASM("LDMFD SP!, {PC}")
        self.currentCodes = self.currentPC
        hookedFunctions.setdefault(self._recordFromToLOG[0], self._recordFromToLOG[1])
        print("--------------------------------------------------------------------------")

    def addReplace(self, fromPtr, jmpType="LDR"):
        if type(fromPtr) == str:
            fromPtr = self.getSymbolByName(fromPtr)
        if hookedFunctions.get(fromPtr) is not None:
            raise Exception("Ptr:{} is Already Hooked".format(hex(fromPtr)))
        print("addReplace {} ---> {}\t{}\n----------".format(hex(self._recordFromToLOG[0]), hex(self._recordFromToLOG[1]), self._recordFromToLOG[2]))
        self.jumpTo(fromAddress=fromPtr, toAddress=self.currentCodes, jmpType=jmpType, resetPC=True)
        self.patchASM("STMFD SP!, {LR}")

    def endReplace(self):
        self.patchASM("LDMFD SP!, {PC}")
        self.currentCodes = self.currentPC
        hookedFunctions.setdefault(self._recordFromToLOG[0], self._recordFromToLOG[1])
        print("--------------------------------------------------------------------------")

    # 获取进入hook之前的寄存器值
    #      0   1   2   3   4   5   6   7   8   9  10  11  12  13   14   15
    # 期望 r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, lr, CPSR, SP
    # 实际 CPSP SP r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, sl, fp, ip, lr
    def getArg(self, regIndex=0, toReg="R0", defFP="R11"):
        if regIndex not in range(0, 16):
            raise Exception("ArrayIndexOutOfBoundsException")
        offset = 4 * (regIndex + 2) if regIndex < 14 else 4 * (regIndex - 14)
        self.patchASM("LDR {},[{},#{}]".format(toReg, defFP, offset))

    # 修改进入hook之前的reg值(r0 write back to r12[regIndex])
    def setArg(self, regIndex=0, fromReg="R0", defFP="R11"):
        if regIndex not in range(0, 16):
            raise Exception("ArrayIndexOutOfBoundsException")
        offset = 4 * (regIndex + 2) if regIndex < 14 else 4 * (regIndex - 14)
        self.patchASM("STR {},[{},#{}]".format(fromReg, defFP, offset))

    def saveRegToStack(self, fromReg="R0", index=0):
        self.patchASM("STR {},[SP,#{}]".format(fromReg, self._pSize * index))

    def loadFromStack(self, toReg="R0", index=0):
        self.patchASM("LDR {},[SP,#{}]".format(toReg, self._pSize * index))

    def prepareStack(self, useSpCount=10):
        self.patchASM("SUB SP,SP,#{}".format(self._pSize * useSpCount))
        self._AllocSpSize = useSpCount

    def restoreStack(self, useSpCount=None):
        if useSpCount is None:
            useSpCount = self._AllocSpSize
            self._AllocSpSize = None
        self.patchASM("ADD SP,SP,#{}".format(self._pSize * useSpCount))

    def getSymbolByName(self, name, mPtr=None):

        def prepareFunctions():
            # 只构建一次,后续再用到都直接返回函数地址
            if functionsMap.get(str(name)) is None and name == "printRegs":
                tmpPC = self.currentPC
                self.resetPC(self.currentCodes)
                self.recordSymbol("printRegs", self.currentPC)
                self.saveEnv(simple=True)
                # 一共十六个参数 R3传递一个参数 剩下的15个使用堆栈
                self.prepareStack(15)
                # ANDROID_LOG_UNKNOWN = 0 ANDROID_LOG_DEFAULT = 1 ANDROID_LOG_VERBOSE = 2 ANDROID_LOG_DEBUG = 3 ANDROID_LOG_INFO = 4 ANDROID_LOG_WARN = 5 ANDROID_LOG_ERROR = 6 ANDROID_LOG_FATAL = 7 ANDROID_LOG_SILENT = 8
                self.patchASM("MOV {},#{}".format("R0", 6))
                # R0=>3 R1=>p"ZZZ" R2=>p"---> %p %p %p %p" R3=>R0 SP=>R1 SP,[#4]=>R2 SP,[#8]=>R3
                self.loadToReg(self.getStr("ZZZ"), toReg="R1")
                self.loadToReg(self.getStr(
                    " \n\t\tR0~R3:\t%p %p %p %p \n\t\tR4~R10:\t%p %p %p %p %p %p %p \n\t\tFP:%p IP:%p LR:%p SP:%p CPSR:%p"),
                    toReg="R2")
                # R11/FP + 3*pSize -> R3
                # 结合 def getArg(self, regIndex=0, toReg="R0", defFP="R11") 上面的堆栈情况注释来看这段代码
                self.patchASM("ADD R3,R11,#{}".format(3 * self._pSize))
                self.patchASM("LDMIA R3,{R4,R5,R6,R7,R8,R9,r10}")
                self.patchASM("STMIA SP,{R4,R5,R6,R7,R8,R9,r10}")
                self.patchASM("ADD R3,R11,#{}".format(3 * self._pSize + 7 * self._pSize))
                self.patchASM("LDMIA R3,{R4,R5,R6,R7,R8,R9}")
                self.patchASM("ADD R3,SP,#{}".format(7 * self._pSize))
                self.patchASM("STMIA R3,{R4,R5,R6,R7,R8,R9}")
                self.getArg(regIndex=14, toReg="R4")
                self.getArg(regIndex=13, toReg="R5")
                self.patchASM("ADD R3,SP,#{}".format((6 + 7) * self._pSize))
                self.patchASM("STMIA R3,{R4,R5}")
                self.getArg(regIndex=0, toReg="R3")
                self.jumpTo(self.getRelocation("__android_log_print"), jmpType="REL", reg="R4", resetPC=False)
                self.restoreStack(15)
                self.restoreEnv(simple=True)
                self.currentCodes = self.currentPC
                self.resetPC(tmpPC)
            # 每个函数参数不一致每次构建不同的并返回(如果想让它一直,那前面必然有一个堆栈或者是内存读写,还是会多一个调用)
            elif mPtr is not None and name == "printTips":
                tmpPC = self.currentPC
                tmpCode = self.currentCodes
                self.resetPC(self.currentCodes)
                self.recordSymbol("printTips", self.currentPC)
                self.saveEnv(simple=True)
                # 准备参数
                if mPtr in functionsMap.values():
                    for item in functionsMap.items():
                        if item[1] == mPtr:
                            self.loadToReg(self.getStr(item[0]), toReg="R3")
                            self.loadToReg(self.getPtr(item[1]), toReg="R4")
                            break
                else:
                    self.loadToReg(self.addGOT(mPtr=mPtr), toReg="R3")
                    self.patchASM("LDR R3,[R3]")
                    self.loadToReg(self.getPtr(mPtr), toReg="R4")
                # 准备日志调用
                self.prepareStack(1)
                self.patchASM("MOV {},#{}".format("R0", 6))
                self.loadToReg(self.getStr("ZZZ"), toReg="R1")
                if mPtr in functionsMap.values():
                    self.loadToReg(self.getStr("Called %s at %p"), toReg="R2")
                else:
                    self.loadToReg(self.getStr("Called %p ---> %p"), toReg="R2")
                self.patchASM("LDR R4,[R4]")
                self.saveRegToStack("R4", index=0)
                self.jumpTo(self.getRelocation("__android_log_print"), jmpType="REL", reg="R4", resetPC=False)
                self.restoreStack(1)
                self.restoreEnv(simple=True)
                self.currentCodes = self.currentPC
                self.resetPC(tmpPC)
                return tmpCode

        tmpRet = prepareFunctions()
        return tmpRet if tmpRet is not None else functionsMap.get(str(name))

    def setFunctionRet(self, pFunction, pRet, fixOffset=False):
        if fixOffset:
            pFunction += configSize["offset"]
        self.resetPC(pFunction)
        self.patchASM("MOV R0, #{}".format(pRet))
        self.nop(self.currentPC)

    def nop(self, pFunction=None, fixOffset=False):
        if fixOffset:
            pFunction += configSize["offset"]
        if pFunction is not None:
            self.resetPC(pFunction)
        self.patchASM("BX LR")

    def addBP(self, mPtr=None):
        if mPtr is not None:
            self.resetPC(self.currentPC)
        # FE FF FF EA    死循环
        self.patchASM("b #0")

    @staticmethod
    def checkJmpRange(ptrFrom, ptrTo):
        # B指令和BL指令最大跳转距离是 ±32M (bits[23:0]是立即数空间,指令最低两位都为 0,去除一个符号位，即为2^25)
        if abs(ptrFrom - ptrTo) >= 32 * 1024 * 1024:
            raise Exception("Out of Jump range (|{} - {}| = {} > {})".format(hex(ptrFrom), hex(ptrTo),
                                                                             hex(abs(ptrFrom - ptrTo)),
                                                                             hex(32 * 1024 * 1024)))

    @staticmethod
    def getGotByName(name):
        if name is not None:
            return gotMap.get(str(name))

    @staticmethod
    def recordSymbol(name, ptr):
        functionsMap.setdefault(name, ptr)
        print("[*] recordSym ---> {}\t{}".format(str(name).ljust(15, " "), hex(ptr)))

```

`Config.py`:

```py
ARCH_ARM = 4
ARCH_ARM64 = 8

configSize = {"GLOBAL_TABLE": 2000, "STR_TABLE": 2000, "GOT_TABLE": 2000, "trampolines": 2000, "textCodes": 5000,
              "GOT_TABLE_fill": 500, "mProtect_size": 1024 * 40, "offset": 0}
hookedFunctions = {}
functionsMap = {}
stringMap = {}
gotMap = {}
preFuncMap = [{}, {}]

```

`MergeUtils.py`:

```py
#
#  @Author      lzy <axhlzy@live.cn>
#  @HomePage    https://github.com/axhlzy
#  @CreatedTime 2021/09/30 18:42
#  @Des         Use lief to merge two so files
#

import os
import lief

from Config import configSize, functionsMap


class MergeUtils:
    def __init__(self, path1,
                 path2=r"C:\Users\pc\PycharmProjects\SoInject\files\inject\libs\armeabi-v7a\libinject.so"):
        self.path1 = path1
        self.path2 = path2
        self.lf_1 = lief.parse(path1)
        self.lf_2 = lief.parse(path2)
        self.text = self.lf_1.get_section(".text")
        self.vAddr = None
        self.section = None

    def mergeSecs(self):
        self.vAddr = -1
        return {".text": self.mergeSection(".text"),
                ".rodata": self.mergeSection(".rodata"),
                ".data": self.mergeSection(".data")}

    def recordCommon(self):
        # 记录合并后需要用到的导出地址
        self.recordSymbol("GLOBAL_TABLE", self.getSym2("GLOBAL_TABLE"))
        self.recordSymbol("STR_TABLE", self.getSym2("STR_TABLE"))
        self.recordSymbol("GOT_TABLE", self.getSym2("GOT_TABLE"))
        self.recordSymbol("trampolines", self.getSym2("trampolines"))
        self.recordSymbol("textCodes", self.getSym2("textCodes"))

        # 导出函数初始化
        self.recordSymbol("il2cpp_init", self.getSym1("il2cpp_init"), fix=False)
        self.recordSymbol("il2cpp_alloc", self.getSym1("il2cpp_alloc"), fix=False)
        self.recordSymbol("il2cpp_free", self.getSym1("il2cpp_free"), fix=False)
        self.recordSymbol("il2cpp_string_new", self.getSym1("il2cpp_string_new"), fix=False)

        # 其他函数
        self.recordSymbol("unicode_to_utf8", self.getSym2("unicode_to_utf8"), fix=False)

        print("--------------------------------------------------------------------------")

    # 合并整个段
    def mergeSeg(self):
        # self.lf_1.add_exported_function(0x5465D8, "SettingsMenuIn")
        self.vAddr = self.lf_1.add(self.lf_2.segments[1]).virtual_address
        print("[*] mergeSeg => " + self.lf_2.segments[1] + " => " + self.vAddr)
        retPath = self.save("libil2cpp_merge.so")
        self.recordCommon()
        return retPath

    # 合并指定节
    def mergeSection(self, section=".text"):
        # 添加了导出函数就会崩溃
        self.section = section

        tmpList = []
        for index in range(0, configSize["GOT_TABLE_fill"]):
            tmpList += [0x0, 0x0, 0x0, 0x0]
        self.lf_2.patch_address(self.lf_2.get_symbol("GOT_TABLE").value, tmpList)
        self.lf_2.write(r"C:\Users\pc\AppData\Local\Temp\libinjectTMP.so")
        self.lf_2 = lief.parse(r"C:\Users\pc\AppData\Local\Temp\libinjectTMP.so")

        # 先保存一下再打开重新回去vAddr
        self.text = self.text
        tempOff = self.lf_1.get_section(".text").virtual_address
        self.lf_1.add(self.lf_2.get_section(section))
        retPath = self.save("libil2cpp_merge.so")

        configSize["offset"] = self.text.virtual_address - tempOff
        injectSize = self.text.size
        self.vAddr = self.lf_1.get_section(section).virtual_address
        print("--------------------------------------------------------------------------")
        print("[*] mergeSection => " + section + " => " + str(hex(self.vAddr)))
        print("--------------------------------------------------------------------------")
        self.recordCommon()
        return retPath

    def getSym1(self, symName):
        return self.lf_1.get_symbol(symName).value

    def getSym2(self, symName):
        if self.section is None:
            return self.vAddr + self.lf_2.get_symbol(symName).value
        else:
            return self.vAddr + (
                    self.lf_2.get_symbol(symName).value - self.lf_2.get_section(self.section).virtual_address)

    @staticmethod
    def recordSymbol(name, ptr, fix=True):
        if str(name) in ("GLOBAL_TABLE", "STR_TABLE", "trampolines", "textCodes", "GOT_TABLE") or not fix:
            functionsMap.setdefault(name, ptr)
            print("[*] recordSym ---> {}\t{}".format(str(name).ljust(15, " "), hex(ptr)))
        else:
            functionsMap.setdefault(name, ptr + configSize["offset"])
            print("[*] recordSym ---> {}\t{} ---> {}".format(str(name).ljust(25, " "), hex(ptr).ljust(10, " "),
                                                             hex(ptr + configSize["offset"])))

    def recordSymbols(self, maps):
        for name in maps.keys():
            self.recordSymbol(name, maps.get(name))
        print("-------------------------------------")

    @staticmethod
    def getSymbolByName(name):
        return functionsMap.get(name)

    def save(self, name="libil2cppN.so"):
        savePath = os.path.dirname(self.path1) + "/" + name
        self.lf_1.write(savePath)
        return savePath

```

`README.md`:

```md
# PyAsmPatch
Use lief, keystone and capstone to manually inline hook elf(libil2cpp.so) file

 # 当前已完成功能
 1. 合并编译出的so中的指定节到我们待修改的so（MergeUtils中提供的 recordSymbols 屏蔽掉合并后函数地址的变化）
 2. UnityJumper.addHook 后当前pc已经准在了待写代码的位置，写完代码调用 UnityJumper.endHook() 
 3. addHook中也支持查看hook位置的Regs值(printRegs=True),具体实现是读取进入hook代码前对所有用户态寄存器保存在堆栈的值(R11/FP)
 4. Hook InitArray 的第一个函数（Unity是hook il2cpp_init），在此处获取基址，并将GOT_TABLE中的每一项加上这个基址重新写回，0标识结束
 5. LDR 指令修复,其他PC相关指令后续再说  TODO .....
 6. 封装一些常用的函数 android_log_print mprotect callFunction Unity.JNI(单个参数没问题，多参数有bug)
 
 ## TIPS:
 1. ins.addGOT() 和 ins.addPtr() : 
     - addGOT 添加到 GOT_TABLE 启动时候会加基地址，用作blx Rx
     - addPtr 添加到 GLOBAL_TABLE ，仅用作存储，但是在 recordSymbol中也会用到addPtr,此处的调用会调用 addGOT
 2. ins.addBP() 添加一个死循环，IDA调式BUG的时候使用 (或者ins.resetPC(0x12345678) 后使用)
     
 详见：
 https://bbs.pediy.com/thread-269601.htm
 
 
```
C:\ProgramData\Anaconda3\envs\APKUtils\python.exe C:\Users\pc\PycharmProjects\SoInject\scripts\射击之王_com_gzcc_zttnl_sjzw.py
[*] mergeSection => .inject => 0x1e8c000

[*] recordSym ---> GLOBAL_TABLE   	0x1e8dd28
[*] recordSym ---> STR_TABLE      	0x1e8e1dc
[*] recordSym ---> GOT_TABLE      	0x1e8e690
[*] recordSym ---> trampolines    	0x1e8d874
[*] recordSym ---> textCodes      	0x1e8d3c0


[*] recordSym ---> il2cpp_string_new        	0x1bd130   ---> 0x1be130
[*] recordSym ---> FindClass                	0xaea06c   ---> 0xaeb06c
[*] recordSym ---> GetStaticMethodID        	0xaea9d4   ---> 0xaeb9d4
[*] recordSym ---> CallStaticVoidMethod     	0xaebdb8   ---> 0xaecdb8
[*] recordSym ---> ShowSettings             	0xb69d4c   ---> 0xb6ad4c
[*] recordSym ---> ShowSettings1            	0xb69db4   ---> 0xb6adb4
[*] recordSym ---> readArgsReg    	0x1e8d3c0
[*] Create string at 0x1e8e1d8	ZZZ
[*] Create string at 0x1e8e1dc	
Break at 0x0 Registers ---> 
R0~R3:	%p %p %p %p 
R4~R10:	%p %p %p %p %p %p %p 
FP:%p IP:%p LR:%p SP:%p CPSR:%p
[*] Get string at 0x1e8e1d8	ZZZ
[*] Create string at 0x1e8e24c	mprotect ret = %d  args : %p %p %p
[*] Get string at 0x1e8e1d8	ZZZ
[*] Create string at 0x1e8e26f	soAddr -> %p
[*] Get string at 0x1e8e1d8	ZZZ
[*] Create string at 0x1e8e27c	GOT relocation %p ---> %p ---> %p
[*] Get string at 0x1e8e1d8	ZZZ
[*] Create string at 0x1e8e29e	Finished GOT relocation all:%d
[*] Get string at 0x1e8e1d8	ZZZ
[*] Create string at 0x1e8e2bd called this function
[*] Get string at 0x1e8e1d8	ZZZ
[*] Create string at 0x1e8e2e1	Text CAllED

```


后续可能的用法：

可以考虑用这种方式 直接静态遍历text段 找出所有的 svc 并 hook 代理掉
```
LOAD:0000000000534D00 C8 07 80 D2                 MOV             X8, #0x3E ; '>'
LOAD:0000000000534D04 01 00 00 D4                 SVC             0
LOAD:0000000000534D08 1F 04 40 B1                 CMN             X0, #1,LSL#12
LOAD:0000000000534D0C 00 94 80 DA                 CINV            X0, X0, HI
LOAD:0000000000534D10 88 EC 00 54                 B.HI            loc_536AA0
LOAD:0000000000534D14 C0 03 5F D6                 RET
```


```

`UnityPatch.py`:

```py
from AndroidPatch import AndroidPatcher
from Config import *


class UnityPatcher(AndroidPatcher):

    def __init__(self, filePath, ARCH=ARCH_ARM):
        AndroidPatcher.__init__(self, filePath, ARCH=ARCH)
        # gotMap add Got Functions
        for item in functionsMap.items():
            self.addGOT(int(item[1]), item[0])

    def hookInit(self, log=True):
        self.fixGot(log=log)
        self.fixU16ToU8()
        self.getSymbolByName("replaceStrInner")

    def fixGot(self, log):
        # 修改权限
        self.addHook(self.lf.get_symbol("il2cpp_init").value, jmpType="B", printTips=False, printRegs=False)
        self.mprotect(mPtr=functionsMap.get("GLOBAL_TABLE"), size=configSize["mProtect_size"], log=log)
        self.loadBaseToReg(reg="R9", log=True)
        self.relocationGot(reg="R9")
        self.endHook()

    def getSymbolByName(self, name, mPtr=None):
        tmpRet = super(UnityPatcher, self).getSymbolByName(name, mPtr)
        if tmpRet is not None:
            return tmpRet
        # 字符替换函数 (这个函数是在init的时候提前创建且仅创建一遍，不能在andHook内部去创建)
        if functionsMap.get(str(name)) is None and name == "replaceStrInner":
            tmpPC = self.currentPC
            tmpCode = self.currentCodes
            self.resetPC(self.currentCodes)
            self.recordSymbol("replaceStrInner", self.currentPC)
            self.saveEnv(simple=True)
            # R5 ShowLOG | R6 CmpResult |R7 pointer | R8 srcU8 | R9 cmpStart | R10 cmpEnd
            self.patchASM("MOV R5,R3")
            self.patchASM("MOV R7,R1")
            self.patchASM("MOV R8,R0")
            self.patchASM("MOV R9,R1")
            self.patchASM("MOV R10,R2")

            self.patchASM("CMP R5,#0x2")
            self.preAsm("BNE #loopStart")
            self.patchASM("MOV R3,R8")
            self.android_log_print_reg(formart="[*] SRC ---> %s")
            self.preAsm("B #loopOver")

            # if R6 + offset != R10
            self.patchASM("CMP R7,R10", labName="loopStart")
            # 跳转到 循环完成依旧没有匹配
            self.preAsm("BEQ #loopOver")
            self.strcmp(fromSR1="R7", fromSR2="R8", toReg="R6")
            self.strlen(fromSR="R7", toReg="R0")
            self.patchASM("ADD R7,R7,#1")
            self.patchASM("ADD R7,R7,R0")
            # 判断字符串相等，跳转到使用R7构造u16并返回
            self.patchASM("CMP R6,#0")
            self.preAsm("BEQ #foundEq")
            self.strlen(fromSR="R7", toReg="R0")
            self.patchASM("ADD R7,R7,#1")
            self.patchASM("ADD R7,R7,R0")
            # 跳转到下次循环
            self.preAsm("B #loopStart")

            # 使用R7构造u16并返回
            self.patchASM("CMP R5,#0x1", labName="foundEq")
            self.preAsm("BNE #jmpOver")
            self.prepareStack(1)
            self.patchASM("MOV R3,R8")
            self.saveRegToStack(fromReg="R7", index=0)
            self.android_log_print_reg(formart="[*] replace : %s ---> %s")
            self.patchASM("MOV R0,R7")
            self.restoreStack()
            # 跳转到最后返回的位置
            self.preAsm("B #jmpOver")

            # 循环完成依旧没有匹配
            self.patchASM("MOV R0,R8", labName="loopOver")

            # 最后返回的位置
            self.preLabel("jmpOver")
            self.jumpTo(functionsMap.get("il2cpp_string_new"), jmpType="REG", resetPC=False)
            self.preAsmEnable()
            self.restoreEnv(simple=True)
            self.currentCodes = self.currentPC
            self.resetPC(tmpPC)
            return tmpCode

    # fix unicode_to_utf8
    def fixU16ToU8(self, jmpType="B"):
        tmpPC = self.currentPC
        tmpFixBase = self.getSymbolByName("unicode_to_utf8")
        if jmpType == "LDR":
            self.saveCode(fromPtr=tmpFixBase + 0x28, codeIndex=3, insLength=2)
            self.jumpTo(toAddress=self.currentTramp, fromAddress=tmpFixBase + 0x24, jmpType=jmpType)
            self.jumpTo(self.getRelocation("calloc"), jmpType="REL", reg="R12", resetPC=False)
            self.restoreCode(codeIndex=3, needFix=False)
            self.jumpTo(toAddress=tmpFixBase + 0x30, resetPC=False, jmpType="LDR")
        elif jmpType == "B":
            self.jumpTo(toAddress=self.currentTramp, fromAddress=tmpFixBase + 0x24, jmpType=jmpType)
            self.jumpTo(self.getRelocation("calloc"), jmpType="REL", reg="R12", resetPC=False)
            self.jumpTo(toAddress=tmpFixBase + 0x28, resetPC=False, jmpType=jmpType)
        self.currentTramp = self.currentPC
        self.currentPC = tmpPC

    def getJValueArray(self, *args):
        # 四字节对齐
        tmpCPC = self.currentPC
        self.currentStr += (4 - self.currentStr % 4)
        self.resetPC(self.currentStr)
        tmpRetPtr = self.currentStr
        self.getPtr(tmpRetPtr)
        tmpList = [0x12, 0x34, 0x56, 0x78,
                   0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00,
                   eval(hex(len(args))), 0x00, 0x00, 0x00]
        for index in range(0, len(args)):
            # struct jValue[]
            # ptr.add(0xC)  ===>    arrayLength
            # ptr.add(0x10) ===>    第一个参数
            # ptr.add(0x18) ===>    第二个参数 (每个参数之前差8字节,前四字节为值 [后四个字节可能为TYPE(后四字节猜的)])
            if type(args[index]) is int:
                tmpList.extend(self.calOffsetToList(0, args[index], 0))
                tmpList.extend([0x00, 0x00, 0x00, 0x00])
            elif type(args[index]) is str:
                # 这里是有问题的,这里填写的str是静态的的地址,即使运行时候修复了也会崩,猜测可能会用到后四字节
                tmpList.extend(self.calOffsetToList(0, self.getStr(args[index]), 4))
                tmpList.extend([0x00, 0x00, 0x00, 0x00])
            elif type(args[index]) is bool:
                tmpList.extend([0x1 if args[index] else 0x0, 0x00, 0x00, 0x00])
                tmpList.extend([0x00, 0x00, 0x00, 0x00])
        tmpList.extend([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])  # 0填充
        self.patchList(tmpList)
        self.currentStr = self.currentStr + len(tmpList)
        print("[*] Create JValueArray {} ---> {}".format(hex(tmpRetPtr), tmpList))
        self.currentPC = tmpCPC
        return tmpRetPtr

    def FindClass(self, clsName):
        self.getU16(clsName)
        self.jumpTo(functionsMap.get("FindClass"), jmpType="BL", resetPC=False)
        self.patchASM("MOV R4,R0")

    def GetStaticMethodID(self, funcName, sign):
        self.getU16(funcName)
        self.patchASM("MOV R5,R0")
        self.getU16(sign)
        self.patchASM("MOV R6,R0")
        self.patchASM("MOV R0,R4")
        self.patchASM("MOV R1,R5")
        self.patchASM("MOV R2,R6")
        self.jumpTo(functionsMap.get("GetStaticMethodID"), jmpType="BL", resetPC=False)
        self.patchASM("MOV R5,R0")

    def CallStaticVoidMethod(self, clsName, funcName, sign, *args):
        self.FindClass(clsName)
        self.GetStaticMethodID(funcName, sign)
        self.patchASM("MOV R0,R4")
        self.patchASM("MOV R1,R5")
        # args operation
        if len(args) != 0:
            self.loadToReg(self.getJValueArray(*args), toReg="R2")
        else:
            # 不是用到args时一定得将R2写成0，不然R2之前可能有不可预期的值，进入Call之后对jValue解析就会崩溃
            self.patchASM("MOV R2,#0")
        self.jumpTo(functionsMap.get("CallStaticVoidMethod"), jmpType="BL", resetPC=False)

    def getU16(self, mStr, reg="R0"):
        self.loadToReg(self.getStr(mStr), reg)
        self.jumpTo(functionsMap.get("il2cpp_string_new"), jmpType="BL", resetPC=False)
        if reg != "R0":
            self.patchASM("MOV {},R0".format(reg))

    # Use R0 - R4 /  use fromReg > R4
    def convertToU8(self, toReg="R0", fromReg="R0"):
        # 固定一个位置存放未初始化变量
        self.loadToReg(self.getPtr(0xFFFFFFF0), toReg="R2")
        self.patchASM("MOV R4,R2")
        # 拿到 U16长度
        self.patchASM("LDR {},[{},#0x8]".format("R3", fromReg))
        # 长度乘以二
        self.patchASM("ADD R1,{},{}".format("R3", "R3"))
        # u16开始位置
        self.patchASM("ADD R0,{},#0xC".format(fromReg))
        self.jumpTo(self.getSymbolByName("unicode_to_utf8"), jmpType="BL", reg="R3", resetPC=False)
        self.patchASM("LDR {},[R4]".format(toReg))
        # 把这个指针放在 R2
        self.patchASM("MOV R1,R4")

    # 用来进行汉化，记录一个 key-value
    def recordStringMap(self, tmpMap):
        tmpStrStart = self.currentStr
        for item in tmpMap.items():
            stringMap.setdefault(item[0], item[1])
            self.getStr(item[0], useCache=False)
            self.getStr(item[1], useCache=False)
        tmpStrEnd = self.currentStr
        return tmpStrStart, tmpStrEnd

    # retStr:存放字典映射关系
    # fromReg:我们需要处理的字符串放在哪里(传入u8)
    # toReg:处理后的字符串放在那里(传出u8/u16)
    # use R0 - R3
    def getReplaceStr(self, argReg="R0", retReg="R0", Obj=None):
        self.convertToU8(fromReg=argReg, toReg="R0")
        if type(Obj) is dict:
            # 返回替换值 并打出日志
            ret = self.recordStringMap(Obj)
            self.loadToReg(ret[0], toReg="R1")
            self.loadToReg(ret[1], toReg="R2")
            self.patchASM("MOV R3,#{}".format(1))
        else:
            # 只显示原字符串并
            self.patchASM("MOV R3,#{}".format(2))
        # 返回了一个字符串 起始位置 和 结束位置
        self.jumpTo(self.getSymbolByName("replaceStrInner"), jmpType="BL", resetPC=False)
        if retReg != "R0":
            self.patchASM("MOV {},R0".format(retReg))

```

`files/demo/test.py`:

```py
import os

from MergeUtils import MergeUtils
from UnityPatch import UnityPatcher

if __name__ == '__main__':
    ins = MergeUtils(os.getcwd()+"/libil2cpp_cp32.so")
    newSoPath = ins.mergeSection(".inject")

    ins.recordSymbols({"FindClass": 0xA0CB0C, "GetStaticMethodID": 0xA0DAE4, "CallStaticVoidMethod": 0xA0F360})

    ins.recordSymbol("Sub", 0x9EFD38)
    ins.recordSymbol("OnPopulateMesh+140", 0x9EE45C)

    # ins.recordSymbol("ShowAdsReward", 0x13c297c)
    # ins.recordSymbol("UpdateModule", 0x63f46c)
    # ins.recordSymbol("reward", 0x120ee68)

    ins = UnityPatcher(newSoPath)
    repStr = ({"惊吓彩蛋": "惊喜彩蛋", "contact@gameresort.com": "axhlzy@live.cn", "版本 2.12": " ", "有问题或评论吗？": " "})

    ins.addHook(ins.getSymbolByName("OnPopulateMesh+140"), printRegs=False, printTips=False)
    ins.getArg(0, toReg="R5")
    ins.getReplaceStr(repDic=repStr, argReg="R5", retReg="R0", LogType=1)
    ins.setArg(0, fromReg="R0")
    ins.endHook()

    # ins.addHook(ins.getSymbolByName("Sub"), printRegs=False)
    # ins.android_log_print_msg(msg="描述 : called this function")
    # # android_log_print_reg 从R3开始,多余的参数使用堆栈传参 prepareStack saveRegToStack restoreStack
    # # 以下为一个简单的demo 几句话即可完成 log 带堆栈传参的调用
    # ins.loadToReg(ins.getPtr(ins.getSymbolByName("Sub")), toReg="R3")
    # ins.patchASM("LDR R3,[R3]")
    # ins.loadToReg(ins.getStr("Sub"), toReg="R4")
    # ins.prepareStack(1)
    # ins.saveRegToStack(reg="R4", index=0)
    # ins.android_log_print_reg(formart="called from %p (%s)")
    # ins.restoreStack(1)
    # ins.CallStaticVoidMethod("com/ironsource/unity/androidbridge/AndroidBridge", "onResume", "()V", 0)
    # ins.endHook()

    # saveArg1 = ins.getPtr(0xffffff1)
    # saveArg2 = ins.getPtr(0xffffff2)
    # rewardFunc = ins.addGOT(ins.getSymbolByName("reward"))
    #
    # ins.addHook("ShowAdsReward", printRegs=True, printTips=True)
    # ins.getArg(regIndex=1, toReg="R1")
    # ins.saveRegToMem(fromReg="R1", toPtr=saveArg1)
    # ins.patchASM("MOV R1,#0x1")
    # ins.saveRegToMem(fromReg="R1", toPtr=saveArg2)
    # ins.endHook()
    #
    # ins.addHook("UpdateModule", printRegs=False, printTips=False)
    # ins.loadToReg(saveArg2, toReg="R0")
    # ins.patchASM("LDR R1,[R0]")
    # ins.patchASM("CMP R1,#0x1")
    # ins.preAsm("BNE #jmpEnd")
    # ins.patchASM("MOV R3,#0")
    # ins.patchASM("STR R3,[R0]")
    # ins.loadToReg(mPtr=saveArg1, toReg="R0")
    # ins.patchASM("LDR R0,[R0]")
    # ins.loadToReg(mPtr=rewardFunc, toReg="R12")
    # ins.patchASM("LDR R12,[R12]")
    # ins.patchASM("MOV R1,#0")
    # ins.patchASM("MOV R2,#0")
    # ins.patchASM("MOV R3,#0")
    # ins.patchASM("BLX R12")
    # ins.patchASM(labName="jmpEnd")
    # ins.preAsmEnable()
    # ins.endHook()

    ins.save("libil2cpp_final.so")

```

`files/inject/jni/Android.mk`:

```mk
# 一个Android.mk file首先必须定义好LOCAL_PATH变量。
# 它用于在开发树中查找源文件。在这个例子中，宏函数’my-dir’, 
# 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。
LOCAL_PATH := $(call my-dir)
# CLEAR_VARS由编译系统提供，
# 指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等...),除LOCAL_PATH 。这是必要的，
# 因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。
include $(CLEAR_VARS)
LOCAL_ARM_MODE := arm
# LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。
# 注意编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为'foo'的共享库模块，将会生成'libfoo.so'文件。
LOCAL_MODULE    := inject
# LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，
# 因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。
LOCAL_SRC_FILES := inject.c
# BUILD_EXECUTABLE 		表示以一个可执行程序的方式进行编译
# BUILD_SHARED_LIBRARY 	表示动态链接库的方式进行编译
# BULID_STATIC_LIBRARY		静态库文件
include $(BUILD_SHARED_LIBRARY)



# 引用系统静态库		LOCAL_STATIC_LIBRARIES += libxxx
# 引用系统动态库		LOCAL_SHARED_LIBRARIES += liblog
# 引用第三方动态库		LOCAL_LDFLAGS := -L$(LOCAL_PATH)/lib/ -ltest3
# 引用第三方静态库		LOCAL_LDFLAGS := $(LOCAL_PATH)/lib/libtest2.a

```

`files/inject/jni/Application.mk`:

```mk
#### 0APP_ABI := arm64-v8a 后面接的是需要生成的.so平台文件，
#### APP_PLATFORM :=后面接的是使用SDK的最低等级
APP_ABI := arm64-v8a,armeabi-v7a
APP_PLATFORM := android-16

```

`files/inject/jni/inject.c`:

```c
#include <stdio.h>
#include <stdlib.h>

__attribute__((section (".inject")))
int unicode_to_utf8(const uint16_t *p, int size, uint8_t **out){
    int charsCount = size / sizeof(uint16_t);
    uint8_t *result = (uint8_t *)calloc(charsCount * 3 + 1,sizeof(char));
    uint8_t *tmp = result;
    for (int i = 0; i < charsCount; i++){
        uint16_t u16char = p[i];
        if (u16char < 0x0080) {
            // u16char <= 0x007f
            // U- 0000 0000 ~ 0000 07ff : 0xxx xxxx
            *tmp = (uint8_t) (u16char & 0x00FF);  // 取低8bit
            tmp += 1;
            continue;
        }
        if (u16char >= 0x0080 && u16char <= 0x07FF) {
            // * U-00000080 - U-000007FF:  110xxxxx 10xxxxxx
            *tmp = (uint8_t) (((u16char >> 6) & 0x1F) | 0xC0);
            tmp += 1;
            *tmp = (uint8_t) ((u16char & 0x3F) | 0x80);
            tmp += 1;
            continue;
        }
        if (u16char >= 0xD800 && u16char <= 0xDBFF) {
            // * U-00010000 - U-001FFFFF: 1111 0xxx 10xxxxxx 10xxxxxx 10xxxxxx
            uint32_t highSur = u16char;
            uint32_t lowSur = p[++i];
            uint32_t codePoint = highSur - 0xD800;
            codePoint <<= 10;
            codePoint |= lowSur - 0xDC00;
            codePoint += 0x10000;
            *tmp = (uint8_t)  ((codePoint >> 18) | 0xF0);
            tmp += 1;
            *tmp = (uint8_t)  (((codePoint >> 12) & 0x3F) | 0x80);
            tmp += 1;
            *tmp = (uint8_t)  (((codePoint >> 06) & 0x3F) | 0x80);
            tmp += 1;
            *tmp = (uint8_t)  ((codePoint & 0x3F) | 0x80);
            tmp += 1;
            continue;
        }
        {
            // * U-0000E000 - U-0000FFFF:  1110xxxx 10xxxxxx 10xxxxxx
            *tmp = (uint8_t)  (((u16char >> 12) & 0x0F) | 0xE0);
            tmp += 1;
            *tmp = (uint8_t)  (((u16char >> 6) & 0x3F) | 0x80);
            tmp += 1;
            *tmp = (uint8_t)  ((u16char & 0x3F) | 0x80);
            tmp += 1;
            continue;
        }
    }
    *tmp = '\0';
    *out = result;
    return 0;
}

__attribute__((section (".inject")))
void GLOBAL_TABLE(){
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
}

__attribute__((section (".inject")))
void STR_TABLE(){
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
}

__attribute__((section (".inject")))
void GOT_TABLE(){
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");

}

__attribute__((section (".inject")))
void trampolines(){
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
}

__attribute__((section (".inject")))
void textCodes(){
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
}

```

`files/inject/obj/local/arm64-v8a/objs/inject/inject.o.d`:

```d
C:/Users/pc/PycharmProjects/SoInject/files/inject/obj/local/arm64-v8a/objs/inject/inject.o: \
  C:\Users\pc\PycharmProjects\SoInject\files\inject\jni\inject.c

```

`files/inject/obj/local/armeabi-v7a/objs/inject/inject.o.d`:

```d
C:/Users/pc/PycharmProjects/SoInject/files/inject/obj/local/armeabi-v7a/objs/inject/inject.o: \
  C:\Users\pc\PycharmProjects\SoInject\files\inject\jni\inject.c

```