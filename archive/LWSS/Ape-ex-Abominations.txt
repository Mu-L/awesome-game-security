Project Path: arc_LWSS_Ape-ex-Abominations_ygk15de5

Source Tree:

```txt
arc_LWSS_Ape-ex-Abominations_ygk15de5
├── CMakeLists.txt
├── README.md
├── Write
├── evdev-mirror
├── extract.sh
├── gdb.sh
├── inject.sh
├── modules
│   ├── m0dular
│   └── vmread
├── reload.sh
├── setuphooks.sh
└── src
    ├── Interfaces.cpp
    ├── Interfaces.h
    ├── Main.cpp
    ├── Netvars.cpp
    ├── Netvars.h
    ├── Signatures.h
    ├── features
    │   ├── Aimbot.cpp
    │   ├── Aimbot.h
    │   ├── Bhop.cpp
    │   ├── Bhop.h
    │   ├── DumbExploits.cpp
    │   ├── DumbExploits.h
    │   ├── Glow.cpp
    │   └── Glow.h
    ├── globals.h
    ├── m0dular
    ├── sdk
    │   ├── BaseStruct.h
    │   ├── CBaseEntity.h
    │   ├── CClientState.h
    │   ├── CGlobalVars.h
    │   ├── CInput.h
    │   ├── ClientClass.h
    │   ├── Definitions.h
    │   ├── OffPtr.h
    │   ├── QAngle.h
    │   ├── UtlMemory.h
    │   ├── Vector.h
    │   └── bf_write.h
    ├── utils
    │   ├── Handles.cpp
    │   ├── InputSystem.cpp
    │   ├── InputSystem.h
    │   ├── Logger.cpp
    │   ├── Logger.h
    │   ├── Math.h
    │   ├── Memutils.cpp
    │   ├── Memutils.h
    │   ├── Wrappers.h
    │   └── minitrace.h
    └── vmread

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.8)
project(Ape-ex)
set(CMAKE_CXX_STANDARD 17)
include(CheckCXXCompilerFlag)

foreach(COMP_ARG "-Weverything -Wall -Wno-zero-as-null-pointer-constant -Wno-sign-conversion" "-Wno-covered-switch-default" "-Wno-c++98-compat" "-Wno-padded" "-Wno-c++98-compat-pedantic" "-Wno-weak-vtables" "-Wno-documentation-unknown-command" "-Wno-old-style-cast" "-Wno-float-equal" "-Wno-unused-command-line-argument -Wno-reserved-id-macro -Wno-cast-align -Wno-exit-time-destructors -Wno-global-constructors")
  CHECK_CXX_COMPILER_FLAG("${COMP_ARG}" ARG_SUPPORTED)
  if(ARG_SUPPORTED)
    set(WARNING_ARGS "${WARNING_ARGS} ${COMP_ARG}")
  endif()
endforeach(COMP_ARG)

message("Supported warning args: ${WARNING_ARGS}")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${WARNING_ARGS} -pedantic -ldl -fpic -isystem${CMAKE_SOURCE_DIR}/modules -DMVERBOSE=0 -DNUM_THREADS=4 -DMEMUTILS_CUSTOM_RW -DPATTERN_SCAN_PAGE_SCAN")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -O0 -g")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -s -fvisibility=hidden -fvisibility-inlines-hidden")

set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS}")

if(NOT CMAKE_BUILD_TYPE)
	message(STATUS "No build type selected, default to Release")
	set(CMAKE_BUILD_TYPE RELEASE)
endif(NOT CMAKE_BUILD_TYPE)

if(USE_EAC_LAUNCHER)
  message("Using EAC Launcher")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DUSE_EAC_LAUNCHER=1")
endif()

if(MTR_ENABLED)
  message("Enabling minitrace")
  set(CMAKE_C_FLAGS "${CMAKE_CXX_FLAGS} -DMTR_ENABLED=1")
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DMTR_ENABLED=1")
endif()

if(BUILD_WITH_SANITIZERS)
	message("Enabling ASan")
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize=address")
endif(BUILD_WITH_SANITIZERS)

foreach(SFILE "threading.cpp" "semaphores.cpp" "atomic_lock.cpp" "mutex.cpp" "pattern_scan.cpp")
  list(APPEND SOURCE_FILES_CXX "${CMAKE_SOURCE_DIR}/modules/m0dular/utils/${SFILE}")
endforeach(SFILE)

foreach(SFILE "src/*.cpp" "src/utils/*.cpp" "src/sdk/*.cpp" "src/features/*.cpp" "modules/vmread/hlapi/*.cpp")
  file(GLOB GLOB_FILES "${CMAKE_SOURCE_DIR}/${SFILE}")
  list(APPEND SOURCE_FILES_CXX ${GLOB_FILES})
endforeach(SFILE)

file(GLOB_RECURSE SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/*.c")

list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/vmread/example.c")
list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/vmread/vmmem.c")
list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/vmread/kmem.c")
list(REMOVE_ITEM SOURCE_FILES_C "${CMAKE_SOURCE_DIR}/modules/vmread/intmem.c")
list(REMOVE_ITEM SOURCE_FILES_CXX "${CMAKE_SOURCE_DIR}/modules/vmread/example.cpp")

message("Source files: ${SOURCE_FILES_CXX}")
message("Source files(C): ${SOURCE_FILES_C}")

find_package(Threads)

include_directories(${INCLUDE_DIRS})

add_library(Ape-ex SHARED ${SOURCE_FILES_CXX} ${SOURCE_FILES_C} "${CMAKE_SOURCE_DIR}/modules/vmread/intmem.c")
target_link_libraries(Ape-ex dl ${CMAKE_THREAD_LIBS_INIT})
target_compile_definitions(Ape-ex PUBLIC LMODE=MODE_QEMU_INJECT)

add_executable(Ape-ex-ex ${SOURCE_FILES_CXX} ${SOURCE_FILES_C} "${CMAKE_SOURCE_DIR}/modules/vmread/vmmem.c")
target_link_libraries(Ape-ex-ex dl ${CMAKE_THREAD_LIBS_INIT})
target_compile_definitions(Ape-ex-ex PUBLIC LMODE=MODE_EXTERNAL)

```

`README.md`:

```md
# Ape-ex Abominations

DMA cheat

For QEMU/vfio use.


Requires evdev-mirror kernel module for input.



### Credits
[Heep042](https://github.com/Heep042) For his qemu library and research.

[Sndix example](https://github.com/Sndix/Apex-Legends-Simple-Glow)

```

`extract.sh`:

```sh
#!/usr/bin/env bash

qemu_pid=$(pidof qemu-system-x86_64)
filename="$(pwd)/build/libApe-ex.so"

if grep -q "$filename" /proc/"$qemu_pid"/maps; then
    sudo gdb -n -q -batch \
  	-ex "set logging on" \
  	-ex "set logging file /dev/null" \
  	-ex "set logging redirect on" \
    -ex "attach $qemu_pid" \
    -ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
    -ex "set \$dlclose = (int(*)(void*)) dlclose" \
    -ex "set \$library = \$dlopen(\"$filename\", 6)" \
    -ex "call \$dlclose(\$library)" \
    -ex "call \$dlclose(\$library)" \
    -ex "detach"
    -ex "quit"
else
	echo "Ape-ex is not injected!"
fi


```

`gdb.sh`:

```sh
#!/bin/bash
# Starts a GDB session on Qemu,
# Sets a couple of things up and then you can use GDB normally

qemu_pid=$(pidof qemu-system-x86_64)
if [ -z "$qemu_pid" ]; then
    /bin/echo -e "\e[31mQemu needs to be open...\e[0m"
    exit 1
fi

#https://www.kernel.org/doc/Documentation/security/Yama.txt
sudo echo "2" | sudo tee /proc/sys/kernel/yama/ptrace_scope # Only allows root to inject code. This is temp until reboot.

echo "Qemu PID: " $qemu_pid

(sudo echo -e "set \$dlopen = (void*(*)(char*, int)) dlopen\n" \
"set \$dlmopen = (void* (*)(long int, char*, int)) dlmopen\n" \
"set \$dlinfo = (int (*)(void*, int, void*)) dlinfo\n" \
"set \$malloc = (void* (*)(long long)) malloc\n" \
"set \$dlerror = (char* (*)(void)) dlerror\n" \
""; cat) | sudo gdb -p $qemu_pid
```

`inject.sh`:

```sh
#!/usr/bin/env bash

qemu_pid=$(pidof qemu-system-x86_64)
filename="$(pwd)/build/libApe-ex.so"

if grep -q "$filename" /proc/"$qemu_pid"/maps; then
    /bin/echo -e "\\e[33mApe-ex is already injected... Aborting...\\e[0m"
    exit
fi

sudo gdb -n -q -batch \
  	-ex "set logging on" \
  	-ex "set logging file /dev/null" \
  	-ex "set logging redirect on" \
    -ex "attach $qemu_pid" \
    -ex "set \$dlopen = (void*(*)(char*, int)) dlopen" \
    -ex "set \$library = \$dlopen(\"$filename\", 1)" \
    -ex "quit"

```

`reload.sh`:

```sh
#!/usr/bin/env bash

cd build/
make -j$(nproc)
cd ..
sudo bash extract.sh
sleep 2
sudo bash inject.sh

```

`setuphooks.sh`:

```sh
#!/bin/bash

echo "Setting up local git hooks..."
git config --local core.hooksPath .githooks/

```

`src/Interfaces.cpp`:

```cpp
#include "Interfaces.h"
#include "utils/Logger.h"
#include "utils/Memutils.h"
#include "sdk/BaseStruct.h"
#include "m0dular/utils/pattern_scan.h"
#include "globals.h"

typedef void* (*InstantiateInterfaceFn) ();

struct InterfaceReg
{
    InstantiateInterfaceFn m_CreateFn;
    const char *m_pName;
    InterfaceReg *m_pNext;
};


bool Interfaces::FindInterfaces( const char *moduleName ) {
    uintptr_t createInterfaceFunc = PatternScan::FindPattern("48 89 5C 24 08 48 89 6C 24 10 48 89 74 24 18 57 48 83 EC ?? 48 8B 1D ?? ?? ?? ?? 48 8B FA 48", moduleName);
    if( !createInterfaceFunc ){
        return false;
    }
    uintptr_t interfaceList = GetAbsoluteAddressVm( *process, createInterfaceFunc + 20, 3, 7 );

    char buffer[256];
    for( uintptr_t interface = (uintptr_t)process->Read<InterfaceReg*>(interfaceList);
         interface && interface != (uintptr_t)process->Read<InterfaceReg*>( interface + OFFSET_OF(&InterfaceReg::m_pNext) );
         interface = (uintptr_t)process->Read<InterfaceReg*>( interface + OFFSET_OF(&InterfaceReg::m_pNext) )
       ){
        Logger::Log("Interface: %p - ", (void*)interface);
        VMemRead( &process->ctx->process, process->proc.dirBase, (uint64_t)buffer, process->Read<uintptr_t>(interface + OFFSET_OF(&InterfaceReg::m_pName)), 256 );
        Logger::Log("InterfaceName : %s\n", buffer);
    }

    return true;
}

```

`src/Interfaces.h`:

```h
#pragma once
#include "vmread/hlapi/hlapi.h"

namespace Interfaces
{
    bool FindInterfaces( const char *moduleName );
}

```

`src/Main.cpp`:

```cpp
#include "vmread/hlapi/hlapi.h"
#include "utils/Logger.h"
#include "Interfaces.h"
#include "Netvars.h"
#include "utils/Memutils.h"
#include "features/Aimbot.h"
#include "features/Bhop.h"
#include "features/Glow.h"
#include "features/DumbExploits.h"
#include "sdk/CBaseEntity.h"
#include "sdk/CGlobalVars.h"
#include "utils/Memutils.h"
#include "globals.h"
#include "utils/Wrappers.h"
#include "utils/minitrace.h"
#include "utils/InputSystem.h"

#include "m0dular/utils/threading.h"
#include "m0dular/utils/pattern_scan.h"

#include <unistd.h> //getpid
#include <thread>
#include <atomic>
#include <csignal>
#include <numeric>
#include <thread>
#include <chrono>
#include <iostream>
//#include <tclDecls.h>

//#define USE_EAC_LAUNCHER

#ifdef USE_EAC_LAUNCHER
#define PROCNAME "EasyAntiCheat_"
#define MODNAME "EasyAntiCheat_launcher.exe"
#else
#define PROCNAME "r5apex.exe"
#define MODNAME "R5Apex.exe"
#endif

#include "Signatures.h"

static thread_t mainThread;
static thread_t inputSystemThread;

#if (LMODE() == MODE_EXTERNAL())

int main() {
    while (running) {
        char c = (char) getchar();

        if (c == 'Q')
            break;
    }

    return 0;
}

#endif

typedef std::chrono::high_resolution_clock Clock;

static bool sigscanFailed = false;

static void *ThreadSignature(const Signature *sig) {
    MTR_SCOPED_TRACE("Initialization", "ThreadedSignature");

    *sig->result = PatternScan::FindPattern(sig->pattern, sig->module);

    if (!*sig->result) {
        Logger::Log("Failed to find pattern {%s}\n", sig->pattern);
        sigscanFailed = true;
    }

    return nullptr;
}


static void *MainThread(void *) {
    Logger::Log("Main Loaded.\n");
    pid_t pid;

#if (LMODE() == MODE_EXTERNAL())
    FILE *pipe = popen("pidof qemu-system-x86_64", "r");
    fscanf(pipe, "%d", &pid);
    pclose(pipe);
#else
    pid = getpid();
#endif

#ifdef MTR_ENABLED
    Logger::Log("Initialize performance tracing...\n");
    mtr_init("/tmp/ape-ex-trace.json");
    MTR_META_PROCESS_NAME("Ape-ex");
#endif

    Threading::InitThreads();

    try {
        Logger::Log("doing shit\n");
        MTR_BEGIN("Initialization", "InitCTX");
        WinContext ctx(pid);
        MTR_END("Initialization", "InitCTX");

        MTR_BEGIN("Initialization", "FindProcesses");
        ctx.processList.Refresh();
        for (auto &i : ctx.processList) {
            if (!strcasecmp(PROCNAME, i.proc.name)) {
                Logger::Log("\nFound Apex Process %s(PID:%ld)", i.proc.name, i.proc.pid);
                PEB peb = i.GetPeb();
                short magic = i.Read<short>(peb.ImageBaseAddress);
                uintptr_t translatedBase = VTranslate(&i.ctx->process, i.proc.dirBase, peb.ImageBaseAddress);
                Logger::Log("\tWinBase:\t%p\tBase:\t%p\tQemuBase:\t%p\tMagic:\t%hx (valid: %hhx)\n", (void *) peb.ImageBaseAddress, (void *) i.proc.process,
                            (void *) translatedBase,
                            magic, (char) (magic == IMAGE_DOS_SIGNATURE));
                process = &i;

                for (auto &o : i.modules) {
                    if (!strcasecmp(MODNAME, o.info.name)) {
                        apexBase = o.info.baseAddress;
                        for (auto &u : o.exports)
                            Logger::Log("\t\t%lx\t%s\n", u.address, u.name);
                    }
                }

            }
        }
        MTR_END("Initialization", "FindProcesses");

        if (!process) {
            Logger::Log("Could not Find Apex Process/Base. Exiting...\n");
            goto quit;
        }

        auto t1 = Clock::now();

        MTR_BEGIN("Initialization", "FindOffsets");
        Threading::QueueJobRef(Interfaces::FindInterfaces, MODNAME);
        Threading::QueueJobRef(Netvars::CacheNetvars, MODNAME);
        //Netvars::PrintNetvars(*process, MODNAME);

        for (const Signature &sig : signatures)
            Threading::QueueJobRef(ThreadSignature, &sig);

        Threading::FinishQueue(true);
        MTR_END("Initialization", "FindOffsets");

        if (sigscanFailed) {
            Logger::Log("One of the sigs failed. Stopping.\n");
            goto quit;
        }

        // Print some sig stuff - useful for reclass analysis etc
        Logger::Log("Localplayer: %p\n", (void *) GetLocalPlayer());
        Logger::Log("LocalplayerPtr: %p\n", (void *) localPlayerPtr);
        Logger::Log("(Linux)Localplayer: %p\n", (void *) &localPlayer);
        Logger::Log("Entlist: %p\n", (void *) entList);
        Logger::Log("GlobalVars: %p\n", (void *) globalVarsAddr);
        Logger::Log("input: %p\n", (void *) inputAddr);
        Logger::Log("clientstate: %p\n", (void *) clientStateAddr);
        Logger::Log("forcejump: %p\n", (void *) forceJump);

        auto t2 = Clock::now();
        printf("Initialization time: %lld ms\n", (long long) std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count());

        Logger::Log("Starting Main Loop.\n");

        static int lastFrame = 0;
        static int lastTick = 0;
        static bool updateWrites = false;

        // these buffers wont get re-allocated, getting the address of em' here is fine.
        userCmdArr = process->Read<uintptr_t>(inputAddr + OFFSET_OF(&CInput::m_commands));
        verifiedUserCmdArr = process->Read<uintptr_t>(inputAddr + OFFSET_OF(&CInput::m_verifiedCommands));
        //goto quit;
        while (running) {
            globalVars = process->Read<CGlobalVars>(globalVarsAddr);

            // read first 0x344 bytes of clientstate (next member we want after 0x344 is over 100k bytes away)
            VMemRead(&process->ctx->process, process->proc.dirBase, (uint64_t) &clientState, clientStateAddr, 0x344);
            netChan = process->Read<CNetChan>((uint64_t) clientState.m_netChan);

            /* Per Tick Operations */
            updateWrites = (globalVars.tickCount != lastTick || globalVars.framecount != lastFrame);
            // reset fakelag if we arent ingame
            /*if (clientState.m_signonState != SIGNONSTATE_INGAMEAPEX)
                process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);*/

            if (updateWrites) {
                /* -=-=-=-=-=-=-=-=-= Tick Operations -=-=-=-=-=-=-=-=-=-=-= */
                MTR_SCOPED_TRACE("MainLoop", "Tick");

                int entityCount = process->Read<int>(apexBase + 0x1adac1c); // TODO: fix and sig

                if (!entityCount || entityCount > 50000) {
                    entityCount = 100; // hardcoded to 100 as item esp is disabled
                }
                InputSystem::InputSystem();

                validEntities.clear();

                for (int ent = 0; ent < entityCount; ent++) {
                    uintptr_t entity = GetEntityById(ent);
                    if (!entity) continue;

                    bool isPlayer = IsPlayer(entity);

                    if (!isPlayer) {
                        if (!IsProp(entity)) continue;
                    }

                    validEntities.push_back(ent);
                    entities[ent].Update(entity);
                    entities[ent].SetPlayerState(isPlayer);
                }
                localPlayer.Update(GetLocalPlayer());

                //Vector localPos = localPlayer.eyePos;
                //Logger::Log("Local eyepos: (%f/%f/%f)\n", localPos[0], localPos[1], localPos[2]);
                Exploits::Speedhack();

                Aimbot::Aimbot();
                Bhop::Bhop(localPlayer);
                Bhop::Strafe();
                /*int32_t commandNr= process->Read<int32_t>(clientStateAddr + OFFSET_OF(&CClientState::m_lastUsedCommandNr));
                int32_t targetCommand = (commandNr - 1) % 300;
                CUserCmd userCmd = process->Read<CUserCmd>(userCmdArr + targetCommand * sizeof(CUserCmd));
                QAngle recoil = Aimbot::RecoilCompensation();

                sway_history.insert({commandNr, recoil});
                */


                /* -=-=-=-=-=-=-=-=-= Frame Operations -=-=-=-=-=-=-=-=-=-=-= */
                MTR_SCOPED_TRACE("MainLoop", "Frame");

                Glow::Glow();
                Exploits::ServerCrasher();
                lastFrame = globalVars.framecount;

                /* -=-=-=-=-=-=-=-=-= Memory Operations -=-=-=-=-=-=-=-=-=-=-= */

                MTR_SCOPED_TRACE("MainLoop", "WriteBack");
                WriteList writeList(process);
                for (size_t i : validEntities) {
                    if (!entities[i].GetPlayerState()) // Do not write item structs; race condition problem
                        continue;

                    entities[i].WriteBack(writeList);
                }

                localPlayer.WriteBack(writeList);

                writeList.Commit();

                lastTick = globalVars.tickCount;
            }
            std::this_thread::sleep_for(std::chrono::microseconds(2000));
        }

        // reset these values to properly reset after exiting the cheat
        //process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);
        //process->Write<float>(timescale, 1.0f); // reset speedhack // reset speedhack

        Logger::Log("Main Loop Ended.\n");
    } catch (VMException &e) {
        Logger::Log("Initialization error: %d\n", e.value);
    }

    quit:
    running = false;

    Threading::FinishQueue(true);
    Threading::EndThreads();

#ifdef MTR_ENABLED
    mtr_flush();
    mtr_shutdown();
#endif

    Logger::Log("Main Ended.\n");

    return nullptr;
}

static void __attribute__((constructor)) Startup() {
    //inputSystemThread = Threading::StartThread(InputSystem::InputSystem, nullptr, false);
    mainThread = Threading::StartThread(MainThread, nullptr, false);
}

static void __attribute__((destructor)) Shutdown() {
    Logger::Log("Unloading...");

    running = false;

    //Threading::JoinThread(inputSystemThread, nullptr);
    Threading::JoinThread(mainThread, nullptr);

    Logger::Log("Done\n");
}

```

`src/Netvars.cpp`:

```cpp
#include "Netvars.h"
#include "utils/Logger.h"
#include "utils/Memutils.h"
#include "sdk/ClientClass.h"
#include "m0dular/utils/pattern_scan.h"
#include "globals.h"

bool Netvars::PrintNetvars( WinProcess &process, const char *moduleName ) {
    uintptr_t clientHeadAddr = PatternScan::FindPattern("[48 8B 1D *?? ?? ?? ??] 48 85 DB 74 32 48 8B F7",
                                                        moduleName); // xref "ClientDLL_InitRecvTableMgr: overflowed" ; one jump above
    if( !clientHeadAddr ){
        return false;
    }

    Logger::Log("Printing Netvars...\n");
    uintptr_t recvTable;
    int32_t propNum;
    uint32_t offset;
    PropType propType;
    uintptr_t prop;
    char buffer[256];

    for(uintptr_t cClass = (uintptr_t)process.Read<uintptr_t>(clientHeadAddr);
        cClass;
        cClass = (uintptr_t)process.Read<ClientClass*>( cClass + OFFSET_OF(&ClientClass::next) ) ){

        VMemRead( &process.ctx->process, process.proc.dirBase, (uint64_t)buffer, process.Read<uintptr_t>( cClass + OFFSET_OF( &ClientClass::networkName ) ), 256 );
        Logger::Log( "ClientClass: %p - Network Name: %s\n", (void*)cClass, buffer );
        recvTable = (uintptr_t)process.Read<RecvTable*>( cClass + OFFSET_OF( &ClientClass::recvTable ) );
        propNum = process.Read<int32_t>( recvTable + OFFSET_OF( &RecvTable::numOfProps ) );
        Logger::Log("\tPropNum: %d\n", propNum);

        for( int i = 0; i < propNum; i++ ){
            prop = process.Read<uintptr_t>(process.Read<uintptr_t>( recvTable + OFFSET_OF( &RecvTable::pProps ) ) + (i * sizeof(uintptr_t) ));
            propType = process.Read<PropType>( prop + OFFSET_OF( &RecvProp::dataType ) );
            offset = process.Read<uint32_t>( prop + OFFSET_OF( &RecvProp::offset ) );
            VMemRead( &process.ctx->process, process.proc.dirBase, (uint64_t)buffer, process.Read<uintptr_t>( prop + OFFSET_OF( &RecvProp::name ) ), 256 );
            Logger::Log("\tProp: %s(%s) - @%x\n", buffer, PropType2String( propType ), offset );
        }

    }

    return true;
}

void Netvars::CacheNetvars( const char *moduleName ) {
    //uintptr_t clientHeadAddr = PatternScan::FindPattern("[48 8B 1D *?? ?? ?? ??] 48 8B AC 24", moduleName);
    //uintptr_t clientHeadAddr = PatternScan::FindPattern("[48 8B 1D *?? ?? ?? ??] 48 85 DB 74 32 48 8B", moduleName); // xref "ClientDLL_InitRecvTableMgr: overflowed" ; one jump above
    uintptr_t clientHeadAddr = PatternScan::FindPattern("[48 8B 1D *?? ?? ?? ??] 48 85 DB 74 32 48 8B F7",
                                                        moduleName); // xref "ClientDLL_InitRecvTableMgr: overflowed" ; one jump above
    if( !clientHeadAddr ){
        Logger::Log("Failed to get clientHeadAddr\n");
        return;
    } else {
        Logger::Log("Clienthead @ %p\n", (void*)clientHeadAddr);
    }
    uintptr_t recvTable;
    int32_t propNum;
    uint32_t offset;
    PropType propType;
    uintptr_t prop;
    char className[256];
    char propName[256];

    for(uintptr_t cClass = (uintptr_t)process->Read<uintptr_t>(clientHeadAddr);
        cClass;
        cClass = (uintptr_t)process->Read<ClientClass*>( cClass + OFFSET_OF(&ClientClass::next) ) ){

        VMemRead( &process->ctx->process, process->proc.dirBase, (uint64_t)className, process->Read<uintptr_t>( cClass + OFFSET_OF( &ClientClass::networkName ) ), 256 );
        recvTable = (uintptr_t)process->Read<RecvTable*>( cClass + OFFSET_OF( &ClientClass::recvTable ) );
        propNum = process->Read<int32_t>( recvTable + OFFSET_OF( &RecvTable::numOfProps ) );

        for( int i = 0; i < propNum; i++ ){
            prop = process->Read<uintptr_t>(process->Read<uintptr_t>( recvTable + OFFSET_OF( &RecvTable::pProps ) ) + (i * sizeof(uintptr_t) ));
            offset = process->Read<uint32_t>( prop + OFFSET_OF( &RecvProp::offset ) );
            VMemRead( &process->ctx->process, process->proc.dirBase, (uint64_t)propName, process->Read<uintptr_t>( prop + OFFSET_OF( &RecvProp::name ) ), 256 );
            netvars[className][propName] = offset;
        }
    }
    Logger::Log("Netvars Cached.\n");
}
```

`src/Netvars.h`:

```h
#pragma once
#include "vmread/hlapi/hlapi.h"

#include <unordered_map>

namespace Netvars
{
    bool PrintNetvars( WinProcess &process, const char *moduleName );
    void CacheNetvars( const char *moduleName );

    inline std::unordered_map<std::string, std::unordered_map<std::string, uint32_t>> netvars;
}


```

`src/Signatures.h`:

```h
#pragma once

struct Signature
{
    uintptr_t* result;
    const char* module;
    const char* pattern;

    template<typename T>
    Signature(T& ref, const char* p, const char* m)
    : result((uintptr_t*)&ref), module(m), pattern(p) {}
};

inline const Signature signatures[] = {
    // Xref "Script_GetTitan" it should look like a cvar register, go into function right under string, then the 2nd function in that
        Signature(entList, "[48 8D 05 *?? ?? ?? ??] 44 2B", MODNAME), // 48 8D 05 ? ? ? ? 44 2B
        //Signature(localPlayerId, "[48 8D 15 ?? ?? ?? ??] 33 FF 49 8B D0", MODNAME),
        //Signature(localPlayerPtr, "[48 89 05 *?? ?? ?? ??] 48 85 C9 74 0D", MODNAME),
    Signature(globalVarsAddr, "F3 0F 59 CF E8 ?? ?? ?? ?? [48 8B 05 **?? ?? ?? ??] 48 85 C0 74", MODNAME), // xref for "VoiceCommVolume" - should be in same block at the bottom.
    Signature(inputAddr, "[48 8D 0D *?? ?? ?? ??] FF 90 ?? ?? ?? ?? FF 15 ?? ?? ?? ?? 3B", MODNAME), // xref for "OnRenderStart->CViewRender::SetUpView" - should be a few lines below that string
    Signature(clientStateAddr, "[48 8D 05 *?? ?? ?? ??] 48 03 C8 E8 ?? ?? ?? ?? E9", MODNAME),
        Signature(timescale, "[F3 0F 11 ?? *?? ?? ?? 01] F3 0F 10 ?? ?? ?? ?? 01 F3 0F 11 ?? ?? ?? ?? 01 44 89", MODNAME),
        Signature(forceJump, "[8b 0d *?? ?? ?? ??] c6 05 ?? ?? ?? ?? 00 f6 c1 03 75 ?? 80 3d ?? ?? ?? ?? 00 74 ?? 83 cb 02", MODNAME),
};
```

`src/features/Aimbot.cpp`:

```cpp
#include "Aimbot.h"
#include "Glow.h"
#include "../utils/Logger.h"

#include "../utils/Math.h"
#include "../utils/Wrappers.h"
#include "../utils/minitrace.h"


#define SMOOTH_TYPE 0
#define SMOOTH_TYPE_FAST 0

#define val 0.5f

static void RecoilCompensation(const QAngle &viewAngle, QAngle &angle) {
    QAngle recoil = localPlayer.aimPunch;

    angle -= recoil;
}

float randFloat(float min, float max) {

    return min + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (max - min)));
}

static void ApplyErrorToPoint(Vector *point, float margin = 5.0f) { // applying error to angle causes issues on long range
    Vector error;
    error->x = randFloat(-1, 1);
    error->y = randFloat(-1, 1);
    //error->z = randFloat(-1, 1);
    error *= margin;

    *point += error;
}

static void SwayCompensation(const QAngle &viewAngle, QAngle &angle) {
    QAngle dynamic = localPlayer.swayAngles;
    QAngle sway = dynamic - viewAngle;
    sway.Normalize();

    angle -= sway;
}

static void SpreadCompensation(uintptr_t weapon) { // needs fix
    process->Write<float>(weapon + 0x141c, -1.0f);
    process->Write<float>(weapon + 0x1420, -1.0f);
}

void Smooth(QAngle &angle, QAngle &viewAngle) {
    float smooth = std::min(0.99f, val);

    QAngle delta = angle - viewAngle;
    delta.Normalize();
    Math::Clamp(delta);

    if (delta.Length() < 0.1f)
        return;


    if (SMOOTH_TYPE == SMOOTH_TYPE_FAST) {
        float coefficient = (1.0f - smooth) / delta.Length() * 4.0f;
        coefficient = powf(coefficient, 2.0f) * 10.0f;
        coefficient = std::max(0.05f, coefficient);
        coefficient = std::min(1.0f, coefficient);

        delta.v = delta.v * coefficient;
    } else {
        delta.v = delta.v * (1.0f - smooth);
        if (delta.Length() < 2.0f) {
            delta.v = delta.v + (delta.v * delta.Length());
        }
    }

    delta.Normalize();
    angle = viewAngle + delta;
}

void VelocityPrediction(CBaseEntity *entity, uintptr_t weapon, float distance, float bulletVelocity, Vector &result) {
    // divided into two parts: charge rifle (no bullet drop) and other weapons (not done yet)
    Vector enemyVelocity = entity->velocity;

    float projectileGravityScale = process->Read<float>(weapon + 0x1D34);

    float time = distance / bulletVelocity;
    if (time == INFINITY || time == NAN) {
        time = 0;
    }

    //Logger::Log("time: %f\n", time);
    if (time < globalVars.intervalPerTick) {
        //Logger::Log("setting to 0: %f\n", globalVars.intervalPerTick);
        time = 0.0f;
    }

    result->x += time * enemyVelocity->x;
    result->y += time * enemyVelocity->y;

    // v25 = (((*(weapon + 0x1C98) * *(gravity + 0x1A)) * 0.5) * (*(weapon + 0x1B2C) / *(weapon + 0x1C90))) / *(weapon + 0x1C90)
    //result->z += (enemyVelocity->z * time) + ((projectileGravityScale * 750.0f * 0.5 * powf(time, 2.0f)) / bulletVel); // Game prediction

    result->z += ((enemyVelocity->z * time) + ((projectileGravityScale * 750.0f) * 0.5 * powf(time, 2.0f)));
    result->z -= 1.0f;

    ApplyErrorToPoint(&result); // maybe apply error on relative head position?
}

void Aimbot::Aimbot() {
    static Vector prevPosition[101];
    MTR_SCOPED_TRACE("Aimbot", "Run");

    static int lastEntity = -1;
    static int lastEntityIndex = -1;
    static uintptr_t plastEntity = 0;
    if (!localPlayer)
        return;

    static int iterations = 0;

    if (!pressedKeys[KEY_LEFTALT] && clientState.m_signonState == SIGNONSTATE_INGAMEAPEX) {

        // if we cannot run aimbot and we arent speedhacking reset fakelag
        //if (!(pressedKeys & KEY_ALT))
        //process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);
        iterations++;
        if (iterations > 5) {
            aimbotEntity = 0;
            lastEntity = -1;
            return;
        }
    } else if (pressedKeys[KEY_LEFTALT]) {
        iterations = 0;
    }

    QAngle localAngles = localPlayer.viewAngles;
    Vector localEye = localPlayer.eyePos;

    uintptr_t weapon = GetActiveWeapon(localPlayer);

    float bulletVel = process->Read<float>(weapon + 0x1D2C);
    if (bulletVel == 1.0f) { // 1.0f is fists.
        //Logger::Log("Not aimbotting on fists\n");
        return;
    }

    CBaseEntity *closestEnt = nullptr;
    float closest = __FLT_MAX__;
    float closestDist = __FLT_MAX__;
    Vector closestHeadPos;
    int closestID;
    if (lastEntity > validEntities.size())
        lastEntity = -1;

    if (lastEntity != -1) {
        CBaseEntity &tmp = entities[validEntities[lastEntity]];

        if (tmp && plastEntity && tmp.GetBaseClass().address != plastEntity) {
            tmp.Update(plastEntity);
        }

        if (!tmp
            || tmp == localPlayer
            || tmp.GetTeamNum() == localPlayer.GetTeamNum()
            || tmp.GetBleedoutState() != 0
            || tmp.GetLifestate() != 0
            || !tmp.GetPlayerState()) {
            lastEntity = -1;
        }
    }

    for (size_t entID = 0; entID < validEntities.size(); entID++) {
        CBaseEntity &entity = entities[validEntities[entID]];
        if (!entity) {
            continue;
        }

        if (entity == localPlayer
            || entity.GetTeamNum() == localPlayer.GetTeamNum()
            || entity.GetBleedoutState() != 0
            || entity.GetLifestate() != 0
            || !entity.GetPlayerState()) {
            continue;
        }

        Vector headpos = GetBonePos(entity, 12, entity.origin);
        float dist = localEye.DistTo(headpos);
        float distFactor = Math::DistanceFOV(localAngles, QAngle(headpos - localEye), dist);
        float angleFov = Math::AngleFOV(localAngles, QAngle(headpos - localEye));

        if (angleFov > 45.0f) {
            continue;
        }

        //float distFactor = Math::AngleFOV(localAngles, QAngle(headpos - localEye));
        if (distFactor < closest && (lastEntity == -1 || entID == lastEntity)) {
            closest = distFactor;
            closestEnt = &entity;
            plastEntity = closestEnt->GetBaseClass().address;
            lastEntityIndex = closestEnt->index;
            closestDist = dist;
            closestHeadPos = headpos;
            closestID = entID;
        }
    }

    if (lastEntity != -1) {
        CBaseEntity &tmp = entities[validEntities[lastEntity]];
        closestEnt = &tmp;
    }

    if (!closestEnt) {
        //Logger::Log("Couldn't find an ent to shoot\n");
        return;
    }
    lastEntity = closestID;

    aimbotEntity = closestEnt->GetBaseClass().address;

    VelocityPrediction(closestEnt, weapon, closestDist, bulletVel, closestHeadPos);

    for (size_t entID = 0; entID < validEntities.size(); entID++) {
        CBaseEntity &entity = entities[validEntities[entID]];
        if (!entity
            || entity == localPlayer
            || entity.GetTeamNum() == localPlayer.GetTeamNum()
            || entity.GetBleedoutState() != 0
            || entity.GetLifestate() != 0
            || !entity.GetPlayerState()) {
            continue;
        }
        prevPosition[entID] = entity.origin;
    }

//#define SILENT_AIM

#ifdef SILENT_AIM
    // if we can not fire, dont try to do silent aim (since the shot will be delayed, and aimbot will not work correctly - maybe account for tihs later?)
    if (process->Read<float>(weapon + 0x7B0) > globalVars.curtime)
        return;

    if (netChan.m_chokedCommands < 2) {
        process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), std::numeric_limits<double>::max());
    }
    else {
        int32_t commandNr= process->Read<int32_t>(clientStateAddr + OFFSET_OF(&CClientState::m_lastUsedCommandNr));
        int32_t targetCommand = (commandNr - 1) % 300;

        CUserCmd userCmd = process->Read<CUserCmd>(userCmdArr + targetCommand * sizeof(CUserCmd));

        // manipulate usercmd here
        QAngle oldAngle = userCmd.m_viewAngles;

        QAngle aimAngle(closestHeadPos - userCmd.m_eyePos);
        if (aimAngle.IsZero() || !aimAngle.IsValid())
            return;

        //SwayCompensation(oldAngle, aimAngle, commandNr);

        aimAngle.Normalize();
        Math::Clamp(aimAngle);

        Math::CorrectMovement(&userCmd, oldAngle, userCmd.m_forwardmove, userCmd.m_sidemove);

        userCmd.m_viewAngles = aimAngle;
        userCmd.m_tickCount = globalVars.tickCount;
        userCmd.m_buttons |= IN_ATTACK;

        process->Write<CUserCmd>(userCmdArr + targetCommand * sizeof(CUserCmd), userCmd);
        process->Write<CUserCmd>(verifiedUserCmdArr + targetCommand * sizeof(CVerifiedUserCmd), userCmd);

        process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);
    }

#else
    QAngle aimAngle(closestHeadPos - localEye);

    if ((aimAngle->x == 0 && aimAngle->y == 0 && aimAngle->z == 0) || !aimAngle.IsValid()) {
        return;
    }

    //SpreadCompensation(weapon); // $wag

    SwayCompensation(localAngles, aimAngle);
    Smooth(aimAngle,
           localAngles); // seems like they introduced a server-side fair-fight like anti-cheat with season4 which bans u for not being nice, so lets at least be a bit human

    aimAngle.Normalize();
    Math::Clamp(aimAngle);
    localPlayer.viewAngles = aimAngle;

    //process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);

#endif

}

```

`src/features/Aimbot.h`:

```h
#pragma once


#include "../sdk/QAngle.h"

namespace Aimbot {
    void Aimbot();
    //extern QAngle RecoilCompensation();
}

```

`src/features/Bhop.cpp`:

```cpp
#include "Bhop.h"
#include "../utils/Wrappers.h"
#include "../utils/Math.h"

void Bhop::Bhop(CBaseEntity &localplayer) {
    if (!(pressedKeys[KEY_SPACE])) {
        return;
    }

    if (localplayer.GetFlags() & FL_ONGROUND) {
        process->Write<int>(forceJump, 6);
    }
}

void Bhop::Strafe() {
    return;

    if (netChan.m_chokedCommands < 2) {
        process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), std::numeric_limits<double>::max());
    } else {
        int32_t commandNr = process->Read<int32_t>(clientStateAddr + OFFSET_OF(&CClientState::m_lastUsedCommandNr));
        int32_t targetCommand = (commandNr - 2) % 300;

        // manipulate usercmd
        CUserCmd cmd = process->Read<CUserCmd>(userCmdArr + targetCommand * sizeof(CUserCmd));
        cmd.m_sidemove = 250.0f;

        // write usercmd
        process->Write<CUserCmd>(userCmdArr + targetCommand * sizeof(CUserCmd), cmd);
        process->Write<CUserCmd>(verifiedUserCmdArr + targetCommand * sizeof(CVerifiedUserCmd), cmd);
        process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);

    }

    if (netChan.m_chokedCommands < 2) {
        process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), std::numeric_limits<double>::max());
    } else {
        int32_t commandNr = process->Read<int32_t>(clientStateAddr + OFFSET_OF(&CClientState::m_lastUsedCommandNr));
        int32_t targetCommand = (commandNr - 2) % 300;

        CUserCmd cmd = process->Read<CUserCmd>(userCmdArr + targetCommand * sizeof(CUserCmd));
        static bool leftRight;

        static QAngle oldAngle;
        QAngle newAngle = cmd.m_viewAngles;

        QAngle delta = oldAngle - newAngle;
        float mousedx = delta->x / 0.022f; // m_pitch
        //Logger::Log("")
        float mousedy = delta->y / 0.022f; // m_yaw

        bool inMove = cmd.m_buttons & IN_FORWARD || cmd.m_buttons & IN_BACK || cmd.m_buttons & IN_MOVELEFT || cmd.m_buttons & IN_MOVERIGHT;
        Vector velocity = localPlayer.velocity;
        if (cmd.m_buttons & IN_FORWARD && velocity.Length() <= 50.0f)
            cmd.m_forwardmove = 250.0f;

        float yaw_change = 0.0f;
        if (velocity.Length() > 50.f)
            yaw_change = 30.0f * fabsf(30.0f / velocity.Length());


        if (cmd.m_buttons & IN_ATTACK)
            yaw_change = 0.0f;

        QAngle viewAngles = localPlayer.viewAngles;

        if (!(localPlayer.GetFlags() & FL_ONGROUND) && !inMove) {
            Logger::Log("do strafe\n");
            if (leftRight || mousedx > 1) {
                viewAngles->y += yaw_change;
                cmd.m_sidemove = 250.0f;
                Logger::Log("right\n");
            } else if (!leftRight || mousedx < 1) {
                viewAngles->y -= yaw_change;
                cmd.m_sidemove = -250.0f;
                Logger::Log("left\n");

            }

            leftRight = !leftRight;
        }

        viewAngles.Normalize();

        Math::Clamp(viewAngles);

        //Math::CorrectMovement(&cmd, viewAngles, cmd.m_forwardmove, cmd.m_sidemove);
        oldAngle = cmd.m_viewAngles;

        cmd.m_viewAngles = viewAngles;
        process->Write<CUserCmd>(userCmdArr + targetCommand * sizeof(CUserCmd), cmd);
        process->Write<CUserCmd>(verifiedUserCmdArr + targetCommand * sizeof(CVerifiedUserCmd), cmd);

        process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);
    }
}

```

`src/features/Bhop.h`:

```h
#pragma once

#include "../sdk/CBaseEntity.h"
#include "../sdk/CInput.h"

namespace Bhop {
    void Bhop( CBaseEntity &localplayer );
    void Strafe();
}
```

`src/features/DumbExploits.cpp`:

```cpp
#include "DumbExploits.h"
#include "../sdk/CClientState.h"
#include "../globals.h"
#include "../utils/Memutils.h"

namespace Exploits {
    void Speedhack() {
        return;
        if (netChan.m_chokedCommands < 15 && !pressedKeys[KEY_SPACE] && !pressedKeys[41])
            process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), std::numeric_limits<double>::max());
        else
            process->Write<double>(clientStateAddr + OFFSET_OF(&CClientState::m_nextCmdTime), 0.0);


        if (pressedKeys[KEY_W] && pressedKeys[KEY_X]) {
            process->Write<float>(timescale, 5.0f);
        } else {
            process->Write<float>(timescale, 1.0f);
        }

        return;
        static bool bSwitch = false;
        static bool activated = true;

        if (!(globalVars.tickCount % 20)) {
            activated = true;
        }
        if (!(globalVars.framecount % 40) && activated) {
            bSwitch = !bSwitch;
        }

        static int last = 0;
        Vector vel = localPlayer.velocity;
        float speed = vel.Length();
        const float target = 800.0f;

        float velFactor = 0.0f;

        if (!(localPlayer.GetFlags() & FL_ONGROUND)) {
            velFactor = 4000.0f;
        }
        velFactor += target;

        if (speed == 0.0f)
            return;

        float factor = velFactor / speed;
        if (factor < 1.0f) {
            factor = 1.0f;
        }

        if (factor > 3.0f) {
            factor = 5.0f;
        }

        if (pressedKeys[KEY_W] && pressedKeys[KEY_LEFTCTRL] && pressedKeys[KEY_X] && bSwitch && netChan.m_chokedCommands < 12) {
            process->Write<float>(timescale, factor);
        } else if (!pressedKeys[KEY_W] || !pressedKeys[KEY_LEFTCTRL] || !pressedKeys[KEY_C]) {
            activated = false;
            process->Write<float>(timescale, 1.0f);
        } else {
            process->Write<float>(timescale, 1.0f);
        }

    }

    // first concept didnt work shiet
    void ServerCrasher() {
        return;

        // set voicestream buffer to 0x3000 bytes into the reliable stream so we have a big buffer to works with
        // since the reliableStream is like 260k bytes
        netChan.m_streamVoice.m_data = (void *) ((uintptr_t) netChan.m_streamReliable.m_data + 0x3000);
        netChan.m_streamVoice.m_dataBytes = netChan.m_streamReliable.m_dataBytes - 0x3000;
        netChan.m_streamVoice.m_dataBits = netChan.m_streamVoice.m_dataBytes * 8;

        // also change the UtlMemory buffer accordingly
        netChan.m_voiceDataBuffer.m_memory = netChan.m_streamVoice.m_data;
        netChan.m_voiceDataBuffer.m_allocationCount = netChan.m_streamVoice.m_dataBytes;

        // maximum datagram size
        uint8_t data[0x40010];
        memset(data, 0, 0x40010);

        // either write 0x1000 away from max datagram size, or whatever the curent stream size is
        int32_t bytesToWrite = std::min(0x40010 - 0x3000/* - (netChan.m_sendStream.m_curBit / 8)*/, netChan.m_streamVoice.m_dataBytes);
        if (bytesToWrite <= 0)
            return;

        // change the curbit to reflect the amount of bytes we are writing
        netChan.m_streamVoice.m_curBit = bytesToWrite * 8;

        // write 0xFF to get an invalid message - server will print the whole packet
        data[bytesToWrite - 2] = 0xFF;

        // write our data into the buffer ingame and then write the netchannel to reflect our changes
        VMemWrite(&process->ctx->process, process->proc.dirBase, (uint64_t) data, (uint64_t) netChan.m_streamVoice.m_data, bytesToWrite);
        process->Write<CNetChan>((uint64_t) clientState.m_netChan, netChan);
    }
}
```

`src/features/DumbExploits.h`:

```h
#pragma once 

#include <cstdint>

namespace Exploits {
    void Speedhack(); 
    
    // just for me (flaw) to test random netchannel shit for now, dont mind
    void ServerCrasher();
}
```

`src/features/Glow.cpp`:

```cpp
#include "Glow.h"

#include "../utils/Wrappers.h"
#include "../sdk/CBaseEntity.h"
#include "../utils/minitrace.h"


static Vector teamColors[] = {
        {150, 0,   0}, // red
        {0,   150, 0}, // green
        {0,   100, 0}, // dark green
        {130, 0,   0}, // dark red
        {0,   0,   125}, // dark blue
        {0,   0,   150}, // blue
        {120, 0,   120}, // purpleish
        {150, 150, 150}, // idk
        {255, 255, 255}, // white
        {0,   200, 200}, // cyan
        {255, 128, 0}, // pink
        {255, 255, 0}, // yellow
        {100, 50,  0}, // brown
        {96,  96,  96}, // grey
        {0,   0,   255}, // bright blue
        {255, 0,   0}, // bright red
        {0,   255, 0}, // bright green
        {50,  100, 0}, // dark slime
        {100, 100, 0}, // dank yellow
        {0,   150, 150}, // dark teal
        {255, 0,   255}, // hot pink - 20
        {255, 0,   255}, // hot pink - 20
};

Vector getHealthColor(CBaseEntity Entity) {
    Vector result;
    const float multiplier = 1.00; //number we multiply our health by to get our colors(multiply our health by 2.55 to give a number we then use for the color. since 255 is the max of any color for our esp ie. 100 full health * 2.55 = 255 or max color)

    int red, green, blue, alpha;    //colors we will solve for based on our entities health
    int health = Entity.health;    //get entities health

    red = 100 - (health * multiplier);    //find red value (no health = max red, full health = no red)
    green = health * multiplier;    //find green value (full health = max green, no health = no green)
    blue = 0;    //no blue on color scale red to green
    alpha = 255;    //max alpha

    Vector Color(red, green, blue);    //create color and fill it with values
    return Color;    //return color

}

static void WriteItemGlow(CBaseEntity &entity, Vector &colors) {
    // Write members of struct independently to avoid race conditions

    process->Write<bool>(entity.bGlowEnable.GetAddress(), true);

    process->Write<float>(entity.glowDistance.GetAddress(), __FLT_MAX__);
    process->Write<float>(entity.glowFarFadeDist.GetAddress(), __FLT_MAX__);
    process->Write<float>(entity.glowLifetime.GetAddress(), __FLT_MAX__);

    process->Write<float>(entity.glowOutline1.GetAddress(), __FLT_MAX__);
    process->Write<float>(entity.glowOutline2.GetAddress(), __FLT_MAX__);
    process->Write<float>(entity.glowOutline3.GetAddress(), __FLT_MAX__);

    process->Write<Vector>(entity.glowCol.GetAddress(), colors);


    //process->Write<int>(entity.glowOutline.GetAddress(), 0x4D407D7E);
}

static void WriteGlow(CBaseEntity &entity, Vector &colors, float distance) {
    entity.bGlowEnable = true; // Enabling the Glow
    entity.iGlowEnable = 1; // Enabling the Glow

    entity.glowCol = colors;

    entity.glowInside1 = __FLT_MAX__; // Setting the time of the Glow to be the Max Float value so it never runs out
    entity.glowInside2 = __FLT_MAX__; // Setting the time of the Glow to be the Max Float value so it never runs out
    entity.glowInside3 = __FLT_MAX__; // Setting the time of the Glow to be the Max Float value so it never runs out
    entity.glowOutline1 = __FLT_MAX__; // Setting the time of the Glow to be the Max Float value so it never runs out
    entity.glowOutline2 = __FLT_MAX__; // Setting the time of the Glow to be the Max Float value so it never runs out
    entity.glowOutline3 = __FLT_MAX__; // Setting the time of the Glow to be the Max Float value so it never runs out

    entity.glowFarFadeDist = __FLT_MAX__;
    entity.glowDistance = __FLT_MAX__; //Set the Distance of the Glow to Max float value so we can see a long Distance
    entity.glowLifetime = __FLT_MAX__;
}

void Glow::Glow() {
    for (size_t entID = 0; entID < validEntities.size(); entID++) {

        CBaseEntity &entity = entities[validEntities[entID]];
        if (entity.GetPlayerState()) {
            if (entity.GetBaseClass().address == localPlayer) {
                /*Vector color = Vector(0, 0, 60);

                WriteGlow(entity, color, 0.0f);*/
                continue;
            }

            if (entity.GetTeamNum() == localPlayer.GetTeamNum())
                continue;

            if (entity.GetBaseClass().address == aimbotEntity) {
                Vector color = Vector(0, 0, 100);

                WriteGlow(entity, color, 0.0f);
                continue;
            }

            if (entity.GetBleedoutState() != 0) {
                Vector color = Vector(48, 48, 48);

                WriteGlow(entity, color, 0.0f);
                continue;
            }
            Vector color = getHealthColor(entity);
            WriteGlow(entity, color, 0.0f);
        } else {
            Vector color = Vector(1, 1, 1);
            /* lol fuck this shit not gonna deal with race conditions anymore */
            //WriteItemGlow(entity, color);
            continue;
        }
    }
}

void Glow::GlowPlayer(CBaseEntity &entity, Vector &colors) {
    WriteGlow(entity, colors, 100);
}
```

`src/features/Glow.h`:

```h
#pragma once
#include <cstdint>
#include "../sdk/Vector.h"
#include "../sdk/CBaseEntity.h"

class CBaseEntity;

namespace Glow {
    void Glow();

    void GlowPlayer(CBaseEntity &entity, Vector &colors);
}

```

`src/globals.h`:

```h
#pragma once

#include "vmread/hlapi/hlapi.h"
#include "sdk/CBaseEntity.h"
#include "sdk/CInput.h"
#include "sdk/Definitions.h"
#include "sdk/CGlobalVars.h"
#include "sdk/CClientState.h"
#include <vector>
#include <cstdint>
#include <deque>
#include <map>
#include <linux/input-event-codes.h>

inline std::vector<size_t> validEntities;
inline CBaseEntity entities[50000];

inline CBaseEntity localPlayer;
inline uintptr_t aimbotEntity;
inline uintptr_t entList;
inline uintptr_t globalVarsAddr;
inline uintptr_t clientStateAddr;
inline uintptr_t inputAddr;
inline uintptr_t timescale;
inline uintptr_t forceJump;
inline int localPlayerId;
inline uintptr_t localPlayerPtr;

inline uintptr_t userCmdArr;
inline uintptr_t verifiedUserCmdArr;

inline CGlobalVars globalVars;
inline CNetChan netChan;
inline CClientState clientState;

inline WinProcess *process;

inline uintptr_t apexBase;

inline uintptr_t EACGameClient;

inline bool pressedKeys[500]; // keyboard is 0-256 and mouse is > 256, so let's make the array unreasonably big to avoid overwriting other data

inline bool running = true;

inline std::map<int, QAngle> sway_history;
```

`src/sdk/BaseStruct.h`:

```h
#pragma once

#include <cstddef>

// https://stackoverflow.com/questions/12811330/c-compile-time-offsetof-inside-a-template
template <typename T, typename M> M get_member_type(M T::*);
template <typename T, typename M> T get_class_type(M T::*);

template <typename T,
        typename R,
        R T::*M
>
constexpr std::size_t offset_of()
{
    return reinterpret_cast<std::size_t>(&(((T*)nullptr)->*M));
}

// Compile-time Offset in class ( Usage: OFFSET_OF(&classname::x) )
#define OFFSET_OF(m) offset_of<decltype(get_class_type(m)), decltype(get_member_type(m)), m>()

```

`src/sdk/CBaseEntity.h`:

```h
#pragma once
#include "BaseStruct.h"
#include "OffPtr.h"
#include "QAngle.h"
#include "../Netvars.h"
#include "Definitions.h" // so u can use flags
#include "../utils/Logger.h"

#define CBASE_ENTITY_OFFSETS(HANDLER)           \
    HANDLER(int, 0x8, index)                    \
    HANDLER(Vector, 0x140, velocity)            \
    HANDLER(Vector, 0x140, absVelocity)         \
    HANDLER(Vector, 0x14C, origin)              \
    HANDLER(Vector, 0x14C, absOrigin)           \
    HANDLER(int, 0x310, iGlowEnable)            \
    HANDLER(bool, 0x380, bGlowEnable)           \
    HANDLER(float, 0x2FC, glowFarFadeDist)      \
    HANDLER(Vector, 0x1D0, glowCol)             \
    HANDLER(float, 0x2e0, glowDistance)         \
    HANDLER(float, 0x2D0, glowInside1)          \
    HANDLER(float, 0x2D8, glowInside2)          \
    HANDLER(float, 0x2E0, glowInside3)          \
    HANDLER(float, 0x2D4, glowOutline1)         \
    HANDLER(float, 0x2DC, glowOutline2)         \
    HANDLER(float, 0x2E4, glowOutline3)         \
    HANDLER(float, 0x2E8, glowLifetime)         \
    HANDLER(int, 0x3F0, teamNum)                \
    HANDLER(int, 0x1308, id)                    \
    HANDLER(Vector, 0x414, localAngles)         \
    HANDLER(uintptr_t, 0xEE0, boneMatrix)       \
    HANDLER(uintptr_t, 0x1944, activeWeapon)    \
    HANDLER(QAngle, 0x2308 , aimPunch)          \
    HANDLER(QAngle, 0x23C0, swayAngles)         \
    HANDLER(QAngle, 0x23D0, viewAngles)         \
    HANDLER(int, 0x3E0, health)                 \
    HANDLER(Vector, 0x1DA8, eyePos)             \


    //HANDLER(Vector, 0x1C04, eyePos)             \ OLD
    /*HANDLER(Vector, 0x4264, eyePos)             \*/

#define CONSTRUCTOR_HANDLER(type, offset, name) , name(baseClass)
#define DEFINE_HANDLER(type, offset, name) OffPtr<type, offset> name;
#define WRITE_BACK_HANDLER(type, offset, name) name.WriteBack(writeList);

class CBaseEntity
{
  private:
    char rBuf[0x2400];
    ProcessBaseClass baseClass;
    bool isPlayer = false;
  public:

    CBaseEntity(uintptr_t addr = 0)
        : baseClass(rBuf, addr) CBASE_ENTITY_OFFSETS(CONSTRUCTOR_HANDLER)
    {
    }

    const ProcessBaseClass& GetBaseClass()
    {
        return baseClass;
    }

    void Update(uintptr_t newAddress = 0)
    {
        if (newAddress)
            baseClass.address = newAddress;
        process->Read(baseClass.address, rBuf, sizeof(rBuf));
    }

    void SetPlayerState(bool state = true) {
        isPlayer = state;
    }

    bool GetPlayerState() {
        return isPlayer;
    }

    void WriteBack(WriteList& writeList)
    {
        CBASE_ENTITY_OFFSETS(WRITE_BACK_HANDLER);
    }

    inline bool operator==(const CBaseEntity &o)
    {
        return baseClass.address == o.baseClass.address;
    }

    inline bool operator==(uintptr_t addr)
    {
        return baseClass.address == addr;
    }

    inline operator bool() const
    {
        return baseClass.address;
    }

    inline int GetBleedoutState() {
        static uint32_t offset = Netvars::netvars["CPlayer"]["m_bleedoutState"];
        if( !offset ) {
            Logger::Log("Can't find Netvar [\"CPlayer\"][\"m_bleedoutState\"]!\n");
            return -1;
        }
        return process->Read<int>( baseClass.address + offset );
    }

    inline int GetLifestate() {
        static uint32_t offset = Netvars::netvars["CPlayer"]["m_lifeState"];
        if( !offset ) {
            Logger::Log("Can't find Netvar [\"CPlayer\"][\"m_lifeState\"]!\n");
            return -1;
        }
        return process->Read<int>( baseClass.address + offset );
    }

    inline int GetFlags() {
        static uint32_t offset = Netvars::netvars["CPlayer"]["m_fFlags"];
        if( !offset ) {
            Logger::Log("Can't find Netvar [\"CPlayer\"][\"m_fFlags\"]!\n");
            return -1;
        }
        return process->Read<int>( baseClass.address + offset );
    }

    inline int GetTeamNum() {
        static uint32_t offset = Netvars::netvars["CBaseEntity"]["m_iTeamNum"];
        if( !offset ){
            Logger::Log("Can't find Netvar [\"CBaseEntity\"][\"m_iTeamNum\"]!\n");
            return -1;
        }

        return process->Read<int>( baseClass.address + offset );
    }

    CBASE_ENTITY_OFFSETS(DEFINE_HANDLER)
};

```

`src/sdk/CClientState.h`:

```h
#pragma once

#include "BaseStruct.h"
#include "Vector.h"
#include "UtlMemory.h"
#include "bf_write.h"

#include <cstdint>

class CNetChan;

class CClientState
{
public:
	char pad_0000[96]; //0x0000
	class CNetChan* m_netChan; //0x0060
	char pad_0068[48]; //0x0068
	int32_t m_signonState; //0x0098
	char pad_009C[4]; //0x009C
	double m_nextCmdTime; //0x00A0
	uint32_t m_serverCount; //0x00A8
	uint32_t m_currentSequence; //0x00AC
	char pad_00B0[168]; //0x00B0
	int32_t m_deltaTick; //0x0158
	char pad_015C[12]; //0x015C
	uint32_t m_playerSlot; //0x0168
	char pad_016C[8]; //0x016C
	char m_mapFileName[64]; //0x0174
	char m_levelNameShort[64]; //0x01B4
	char m_levelName[260]; //0x01F4
	char pad_02F8[4]; //0x02F8
	int32_t m_highestClientIndex; //0x02FC
	char pad_0300[64]; //0x0300
	int32_t m_maxClients; //0x0340
	char pad_0344[100748]; //0x0344
	int32_t m_lastUsedCommandNr; //0x18CD0
	char pad_18CD8[60]; //0x18CD8
	Vector m_viewAngles; //0x18D18
	char gimmeMore[0x1000];
}; //Size: 0x18D24

class CNetChan
{
public:
	char pad_0000[4]; //0x0000
	uint32_t m_outSeqNr; //0x0004
	uint32_t m_inSeqNr; //0x0008
	uint32_t m_outSeqNrAck; //0x000C
	uint32_t m_chokedCommands; //0x0010
	char pad_0014[16]; //0x0014
	int32_t m_socket; //0x0024
	char pad_0028[8]; //0x0028
	bf_write m_streamReliable; //0x0030
	CUtlMemory m_reliableDataBuffer; //0x0050
	bf_write m_streamUnreliable; //0x0068
	CUtlMemory m_unreliableDataBuffer; //0x0088
	bf_write m_streamVoice; //0x00A0
	CUtlMemory m_voiceDataBuffer; //0x00C0
	char pad_00D8[4]; //0x00D8
	uint32_t m_maxReliablePayloadSize; //0x00DC
	double m_lastReceived; //0x00E0
	double m_connectTime; //0x00E8
	int32_t m_rate; //0x00F0
	char pad_00F4[4]; //0x00F4
	double m_clearTime; //0x00F8
	char pad_0100[8]; //0x0100
	int32_t m_signonState; //0x0108 only display 4 and 8
	char pad_010C[108]; //0x010C
	CClientState* m_clientState; //0x0178
	char pad_0180[64]; //0x0180
	void* m_sendBuffer; //0x01C0
	bf_write m_sendStream; //0x01C8
}; //Size: 0x01E8
```

`src/sdk/CGlobalVars.h`:

```h
#pragma once

class CGlobalVars
{
public:
    double realtime;
    int32_t framecount; //0x0008
    float absoluteframetime; //0x000C
    float curtime; //0x0010
    float N00000047; //0x0014
    float N00000018; //0x0018
    float N0000004A; //0x001C
    float N00000019; //0x0020
    float N0000004D; //0x0024
    float N0000001A; //0x0028
    char pad_002C[4]; //0x002C
    float N0000001B; //0x0030
    char pad_0034[12]; //0x0034
    int32_t tickCount; //0x0040
    float intervalPerTick; //0x0044
}; //Size: 0x0048

```

`src/sdk/CInput.h`:

```h
#pragma once

#include "BaseStruct.h"
#include "Vector.h"

#include <cstdint>

class CUserCmd
{
public:
	uint32_t m_commandNumber; //0x0000
	uint32_t m_tickCount; //0x0004
	float m_curtime; //0x0008
	QAngle m_viewAngles; //0x000C
	QAngle m_aimDirection; //0x0018
	float m_forwardmove; //0x0024
	float m_sidemove; //0x0028
	float m_upmove; //0x002C
	uint32_t m_buttons; //0x0030
	int32_t m_impulse; //0x0034
	char pad_0038[332]; //0x0038
	uint32_t m_randomSeed; //0x0184
	char pad_0188[8]; //0x0188
	vec3 m_eyePos; //0x0190
	char pad_019C[196]; //0x019C
	uint32_t m_prevTickcount; //0x0260 -- same as curr
	uint32_t m_nextTickcount; //0x0264
	char pad_01E0[8];
	float m_frametime; //0x0270
	char pad_01EC[12];
}; //Size: 0x0280


class CVerifiedUserCmd : public CUserCmd
{
public:
    uint64_t m_crc64; //0x01F8
}; //Size: 0x0200

class CInput
{
public:
    char pad_0000[32]; //0x0000
    float m_frametime; //0x0020
    float m_prevFrametime; //0x0024
    char pad_0028[136]; //0x0028
    uint32_t m_buttonBits; //0x00B0
    char pad_00B4[8]; //0x00B4
    float m_pingHoldStartTime; //0x00BC
    float m_somethingPing; //0x00C0 0.0 when not pinging.
    char pad_00C4[11]; //0x00C4
    bool m_cameraIsOrthographic; //0x00CF
    Vector m_previousViewAngles; //0x00D0
    char pad_00DC[12]; //0x00DC
    float m_lastForwardMove; //0x00E8 -1.0 -> 1.0
    int32_t m_clearInputState; //0x00EC
    CUserCmd* m_commands; //0x00F0 // Does not change or go null
    CVerifiedUserCmd* m_verifiedCommands; //0x00F8 // Does not change or go null
}; //Size: 0x0100


```

`src/sdk/ClientClass.h`:

```h
#pragma once

#include "BaseStruct.h"


// credits for some of this: https://www.unknowncheats.me/forum/1570870-post10.html
enum PropType : int
{
    INT =0,
    FLOAT,
    VECTOR,
    VECTORXY,
    STRING,
    ARRAY,
    QUATERNION,
    INT64,
    DATATABLE,
    NUM_SEND_PROP_TYPES,
    //Possible new ones
    TIME,
    TICKS,
};

inline const char *PropType2String( PropType type ){
    switch( type ){
        case INT:
            return "INT";
        case FLOAT:
            return "FLOAT";
        case VECTOR:
            return "VECTOR";
        case VECTORXY:
            return "VECTORXY";
        case STRING:
            return "STRING";
        case ARRAY:
            return "ARRAY";
        case QUATERNION:
            return "QUATERNION";
        case INT64:
            return "INT64";
        case DATATABLE:
            return "DATATABLE";
        case NUM_SEND_PROP_TYPES:
            return "NUM_SEND_PROP_TYPES";
        case TIME:
            return "TIME";
        case TICKS:
            return "TICKS";
        default:
            return "UNKNOWN PROP-TYPE!";
    }
}

class RecvProp
{
public:
    PropType dataType; //0x0000
    uint32_t offset; //0x0004
    char pad_0008[24]; //0x0008
    class recvTable* dataRecvTable; //0x0020
    char* name; //0x0028
    char pad_0030[56];
};

class propArray
{
public:
    class RecvProp* prop[1024]; //0x0000
};

class RecvTable
{
public:
    char pad_0000[8]; //0x0000
    class propArray* pProps; //0x0008
    int32_t numOfProps; //0x0010
    char pad_0014[4]; //0x0014
};

class ClientClass
{
public:
    void* createFn; //0x0000
    void* createEventFn; //0x0008
    char* networkName; //0x0010
    class RecvTable* recvTable; //0x0018
    class ClientClass* next; //0x0020
    char pad_0028[8]; //0x0028
    char* name;
};

```

`src/sdk/Definitions.h`:

```h
#pragma once

#define MULTIPLAYER_BACKUP 300

#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#define M_PI_F		((float)(M_PI))	// Shouldn't collide with anything.
#define M_PHI		1.61803398874989484820 // golden ratio

// NJS: Inlined to prevent floats from being autopromoted to doubles, as with the old system.
#ifndef RAD2DEG
#define RAD2DEG( x )  ( (float)(x) * (float)(180.f / M_PI_F) )
#endif

#ifndef DEG2RAD
#define DEG2RAD( x )  ( (float)(x) * (float)(M_PI_F / 180.f) )
#endif

#define TICK_INTERVAL			(globalVars.intervalPerTick)
#define TIME_TO_TICKS( dt )		( (int)( 0.5f + (float)(dt) / TICK_INTERVAL ) )
#define TICKS_TO_TIME( t )		( TICK_INTERVAL *( t ) )


// random Source engine things that don't need their own file.

#define SIGNONSTATE_NONE		0	// no state yet, about to connect
#define SIGNONSTATE_CHALLENGE	1	// client challenging server, all OOB packets
#define SIGNONSTATE_CONNECTED	2	// client is connected to server, netchans ready
#define SIGNONSTATE_NEW			3	// just got serverinfo and string tables
#define SIGNONSTATE_PRESPAWN	4	// received signon buffers
#define SIGNONSTATE_SPAWN		5	// ready to receive entity packets
#define SIGNONSTATE_FULL		6	// we are fully connected, first non-delta packet received
#define SIGNONSTATE_CHANGELEVEL	7	// server is changing level, please wait
#define SIGNONSTATE_INGAMEAPEX  8   // In Game Apex ( Note: The Lobby is literally a server )


#define IN_ATTACK		(1 << 0) // 1
#define IN_JUMP			(1 << 1) // 2
#define IN_DUCK			(1 << 2) // 4
#define IN_FORWARD		(1 << 3) // 8
#define IN_BACK			(1 << 4) // 16
#define IN_USE			(1 << 5) // 32
#define IN_CANCEL		(1 << 6) // 64
#define IN_LEFT			(1 << 7) // 128
#define IN_RIGHT		(1 << 8) // 256
#define IN_MOVELEFT		(1 << 9) // 512
#define IN_MOVERIGHT	(1 << 10) // 1024
#define IN_UNKNOWN		(1 << 11) // 2048
#define IN_RELOAD		(1 << 12) // 4096
#define IN_SWAPGUN		(1 << 13) // 8k // Used with IN_USE to pick stuff up
#define IN_UNKNOWN2		(1 << 14) // 16k
#define IN_SPRINT		(1 << 15) // 32k
#define IN_ZOOM 		(1 << 16) // 64k // Right click
/*
#define IN_SPEED		(1 << 17) // 128k	// Player is holding the speed key
#define IN_WALK			(1 << 18)	// Player holding walk key
#define IN_ZOOM			(1 << 19)	// Zoom key for HUD zoom
#define IN_WEAPON1		(1 << 20)	// weapon defines these bits
#define IN_WEAPON2		(1 << 21)	// weapon defines these bits
#define IN_BULLRUSH		(1 << 22)
#define IN_GRENADE1		(1 << 23)	// grenade 1
#define IN_GRENADE2		(1 << 24)	// grenade 2
*/

#define FL_ONGROUND				(1<<0)	// At rest / on the ground
/*
#define FL_DUCKING				(1<<1)	// Player flag -- Player is fully crouched
#define FL_WATERJUMP			(1<<2)	// player jumping out of water
#define FL_ONTRAIN				(1<<3)	// Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_INRAIN				(1<<4)	// Indicates the entity is standing in rain
#define FL_FROZEN				(1<<5)	// Player is frozen for 3rd person camera
#define FL_ATCONTROLS			(1<<6)	// Player can't move, but keeps key inputs for controlling another entity
#define FL_CLIENT				(1<<7)	// Is a player
#define FL_FAKECLIENT			(1<<8)	// Fake client, simulated server side; don't send network messages to them
// NON-PLAYER SPECIFIC (i.e., not used by GameMovement or the client .dll ) -- Can still be applied to players, though
#define FL_INWATER				(1<<9)	// In water
*/
```

`src/sdk/OffPtr.h`:

```h
#pragma once
#include "../../modules/vmread/hlapi/hlapi.h" // WinProcess

extern WinProcess* process;

template<typename T, size_t off>
struct OffPtr;

class ProcessBaseClass
{
  protected:
    template<typename T, size_t off>
    friend struct OffPtr;

    char* readBuf;
  public:
    uintptr_t address;

    ProcessBaseClass(char* rBuf, uintptr_t addr = 0)
        : readBuf(rBuf), address(addr) {}
};

template<typename T, size_t off>
struct OffPtr
{
    const ProcessBaseClass& baseClass;
    bool dirty = false;

    OffPtr(const ProcessBaseClass& base)
        : baseClass(base) { }

    OffPtr(const ProcessBaseClass& base, size_t& maxOff)
        : OffPtr(base)
    {
        maxOff = maxOff > off ? maxOff : off;
    }

    constexpr T& GetDirect() const
    {
        return *(T*)((uintptr_t)baseClass.readBuf + off);
    }

    constexpr operator T() const
    {
        return GetDirect();
    }

    inline auto& operator=(const T& v)
    {
        GetDirect() = v;
        dirty = true;
        return *this;
    }

    inline size_t GetOffset() {
        return off;
    }

    inline uintptr_t GetAddress() {
        return (uintptr_t) (baseClass.address + off);
    }

    inline void WriteBack(WriteList& writeList)
    {
        if (dirty)
            writeList.Write(baseClass.address + off, GetDirect());
        dirty = false;
    }
};

```

`src/sdk/QAngle.h`:

```h
#pragma once

#include "Vector.h"
#include "math.h"

enum {
    PITCH = 0,    // up / down
    YAW,        // left / right
    ROLL        // fall over
};

class QAngleByValue;
class QAngle {
public:
    Vector v;

    QAngle()
        : v() {}

    QAngle(const Vector& fv)
        : v(fv.GetAngles(true)) {}

    inline auto operator->() {
        return v.operator->();
    }

    inline auto& operator[](size_t idx) {
        return v[idx];
    }

    inline void Normalize() {
        v.NormalizeAngles<3>(-180.f, 180.f);

        while (v->x > 89.0f)
            v->x -= 180.0f;

        while (v->x < -89.0f)
            v->x += 180.0f;

        v->z = 0;
    }

    inline float Length() const {
        return v.Length();
    }

    inline bool IsValid() const {
        return !isnan(v[0]) && !isnan(v[1]) && !isnan(v[2]);
    }

    inline bool IsZero() const {
        return v->x == v->y == v->z == 0.f;
    }

    inline auto operator+(const QAngle& o) const {
        QAngle ret = *this;
        ret.v += o.v;
        return ret;
    }

    inline auto operator-(const QAngle& o) const {
        QAngle ret = *this;
        ret.v -= o.v;
        return ret;
    }

    inline auto operator*(const QAngle& o) const {
        QAngle ret = *this;
        ret.v *= o.v;
        return ret;
    }

    inline auto operator/(const QAngle& o) const {
        QAngle ret = *this;
        ret.v /= o.v;
        return ret;
    }

    inline auto& operator+=(const QAngle& o) {
        v += o.v;
        return *this;
    }

    inline auto& operator-=(const QAngle& o) {
        v -= o.v;
        return *this;
    }

    inline auto& operator*=(const QAngle& o) {
        v *= o.v;
        return *this;
    }

    inline auto& operator/=(const QAngle& o) {
        v /= o.v;
        return *this;
    }

};

```

`src/sdk/UtlMemory.h`:

```h
#pragma once

#include <cstdint>

// lol wer relaly dont need all the funcs etc since we are external and cant call them anyways
class CUtlMemory
{
public:
	void* m_memory; //0x0000
	int64_t m_allocationCount; //0x0008
	int64_t m_growSize; //0x0010
}; //Size: 0x0018
```

`src/sdk/Vector.h`:

```h
#pragma once
#include "m0dular/math/vector.h"

#define FastSqrt(x)            (sqrtf)(x)
#define VALVE_RAND_MAX 0x7fff

using Vector = vec3;

```

`src/sdk/bf_write.h`:

```h
#pragma once
#include "BaseStruct.h"
#include "Vector.h"

#include <cstdint>

class bf_write
{
public:
	void* m_data; //0x0000
	int32_t m_dataBytes; //0x0008
	int32_t m_dataBits; //0x000C
	int32_t m_curBit; //0x0010
	bool m_overflow; //0x0014
	bool m_assertOnOverflow; //0x0015
	char pad_0016[2]; //0x0016
	char* m_debugName; //0x0018
}; //Size: 0x0020
```

`src/utils/Handles.cpp`:

```cpp
#include "m0dular/utils/handles.h"
#include "../globals.h"

ModuleInfo Handles::GetModuleInfo(const char *module)
{
    WinDll *moduleInfo = process->GetModuleInfo(module);

    if (!moduleInfo)
        return { nullptr, 0, 0 };

    return { (void *)moduleInfo, moduleInfo->info.baseAddress, moduleInfo->info.sizeOfModule };
}

```

`src/utils/InputSystem.cpp`:

```cpp
#include "InputSystem.h"

// https://github.com/LWSS/evdev-mirror

// This struct is the same at <linux/input.h>
struct input_value {
    uint16_t type;
    uint16_t code;
    int32_t value;
};

void InputSystem::InputSystem() {
    static int fd = open("/dev/input/evdev-mirror", O_RDONLY /*| O_NONBLOCK*/);
    struct input_value input;

    if (fd < 0) {
        Logger::Log("Error opening evdev-mirror! (%d), %d\n", fd, errno);
        return;
    }

    while (running) {
        // if zero bytes, keep goin...
        ssize_t n = read(fd, &input, sizeof(input_value));

        static ssize_t s = sizeof(input_value);

        if (n == -1 || n != s) {
            break;
        }

        if (input.type == EV_KEY && input.value >= 0 && input.value <= 2) {
            pressedKeys[input.code] = input.value > 0;
        }
        //Logger::Log("Key: %d - state: %d\n", input.code, input.value);
        //std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}
```

`src/utils/InputSystem.h`:

```h
#ifndef APE_EX_INPUTSYSTEM_H
#define APE_EX_INPUTSYSTEM_H

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <chrono>
#include <thread>
#include <errno.h>

#include "../globals.h"

namespace InputSystem {
    extern void InputSystem();
}


#endif //APE_EX_INPUTSYSTEM_H

```

`src/utils/Logger.cpp`:

```cpp
#include "Logger.h"

#include <cstdio> // setbuf, fopen, fclose..
#include <cstdarg> // va_list, va_start, va_arg, va_end
#include <string.h>
#include <fstream>
//LMODE
#include "vmread/definitions.h"

#if (LMODE() != MODE_EXTERNAL())
#define LOGFILE_NAME "/tmp/apex.log"
#endif

void Logger::Log( const char *format, ... ) {
    char buffer[4096];
    FILE *logFile;
#if (LMODE() == MODE_EXTERNAL())
    logFile = stdout;
#else
    static bool bFirst = true;

    if ( bFirst ) {
        logFile = fopen(LOGFILE_NAME, "w"); // create new log
        bFirst = false;
        if (logFile)
            fprintf(logFile, "--Start of log--\n");
    } else {
        logFile = fopen(LOGFILE_NAME, "a"); // append to log
    }

    if (!logFile)
        return;
#endif

    va_list args;
    va_start(args, format);
    vsnprintf(buffer, 4096, format, args);
    fprintf(logFile, buffer);
    va_end(args);
    fflush(logFile);
#if (LMODE() != MODE_EXTERNAL())
    fclose(logFile);
#endif
}

```

`src/utils/Logger.h`:

```h
#pragma once

namespace Logger {
    void Log( const char *format, ... );
}

```

`src/utils/Math.h`:

```h
#include "../sdk/Vector.h"
#include "../sdk/QAngle.h"
#include "../utils/Logger.h"
#include "../sdk/CInput.h"
#include "../sdk/Definitions.h"

namespace Math {

    inline void Clamp(QAngle &angles) {
        if (angles[YAW] > 180.0f) {
            angles[YAW] = 180.0f;
        } else if (angles[YAW] < -180.0f) {
            angles[YAW] = -180.0f;
        }

        if (angles[PITCH] > 89.0f) {
            angles[PITCH] = 89.0f;
        } else if (angles[PITCH] < -89.0f) {
            angles[PITCH] = -89.0f;
        }
        angles[ROLL] = 0.0f;
    }

    inline float AngleFOV(const QAngle &viewAngle, const QAngle &aimAngle) {
        QAngle delta = viewAngle - aimAngle;
        delta.Normalize();
        float fov = delta.Length();
        if (fov > 180.0f)
            fov -= 360.0f;

        fov = fabsf(fov);
        return fov;
    }

    inline float DistanceFOV(const QAngle &viewAngle, const QAngle &aimAngle, const float distance) {
        float angleFOV = AngleFOV(viewAngle, aimAngle);
        angleFOV /= 90.0f;

        float distanceFOV = angleFOV * distance;

        return distanceFOV;
    }

    inline void CorrectMovement(CUserCmd* cmd, QAngle oldAngles, float oldForward, float oldSide) {
        float deltaAngles;
        float f1;
        float f2;

        if (oldAngles->y < 0.f)
            f1 = 360.0f + oldAngles->y;
        else
            f1 = oldAngles->y;

        if (cmd->m_viewAngles->y < 0.0f)
            f2 = 360.0f + cmd->m_viewAngles->y;
        else
            f2 = cmd->m_viewAngles->y;

        if (f2 < f1)
            deltaAngles = abs(f2 - f1);
        else
            deltaAngles = 360.0f - abs(f1 - f2);

        deltaAngles = 360.0f - deltaAngles;

        cmd->m_forwardmove = cos(DEG2RAD(deltaAngles)) * oldForward + cos(DEG2RAD(deltaAngles + 90.f)) * oldSide;
        cmd->m_sidemove = sin(DEG2RAD(deltaAngles)) * oldForward + sin(DEG2RAD(deltaAngles + 90.f)) * oldSide;        
    }
}

```

`src/utils/Memutils.cpp`:

```cpp
#include "m0dular/utils/memutils.h"
#include "../globals.h"

//TODO: Add thread-local process selection
void ReadMem(void* destination, void* source, size_t size)
{
    process->Read((uint64_t)source, destination, size);
}

void WriteMem(void* destination, void* source, size_t size)
{
    process->Write((uint64_t)destination, source, size);
}

```

`src/utils/Memutils.h`:

```h
#pragma once
#include "vmread/hlapi/hlapi.h"
#include "Logger.h"

inline uintptr_t GetAbsoluteAddressVm( WinProcess &proc, uintptr_t instructionPtr, int offset, int size ) {
    if( !instructionPtr ){
        return 0;
    }
    return instructionPtr + proc.Read<int>( instructionPtr + offset ) + size;
}

```

`src/utils/Wrappers.h`:

```h
#pragma once

#include "../globals.h"

#include "../sdk/CBaseEntity.h"
#include "../sdk/Vector.h"
#include "../sdk/QAngle.h"
#include "Logger.h"

struct BoneMatrix {
    char __buff_0x00[0xC];//0x00
    float x;//0xC
    char __buff_0x10[0xC];//0x10
    float y;//0x1c
    char __buff_0x20[0xC];//0x20
    float z;//0x2c
};

inline Vector GetBonePos(CBaseEntity &entity, int bone, const Vector &origin) {
    uintptr_t p_matrix = entity.boneMatrix;

    if (!p_matrix)
        return Vector();

    BoneMatrix matrix = process->Read<BoneMatrix>(p_matrix + bone * sizeof(BoneMatrix));
    Vector bonePos = Vector(matrix.x, matrix.y, matrix.z);
    bonePos += origin;

    return bonePos;
}

inline uintptr_t GetEntityById(ssize_t ent) {
    uintptr_t baseEntity = process->Read<uintptr_t>(entList);

    if (!baseEntity || !ent) {
        return (uintptr_t) NULL;
    }

    return process->Read<uintptr_t>(entList + (ent << 5));
}

inline uintptr_t GetActiveWeapon(CBaseEntity &entity) {
    uintptr_t weapon = entity.activeWeapon;
    if (!weapon)
        return 0;
    //Logger::Log("Weapon ptr: %p\n", (void*)weapon);

    weapon &= 0xFFFF;

    if (!weapon)
        return 0;
    //Logger::Log("ID: %i\n", weapon);

    return GetEntityById(weapon);
}

inline uintptr_t GetLocalPlayerById() {
    localPlayerId = process->Read<int>(apexBase + 0x1060b44); // TODO: sig this

    for (int ent = 1; ent < 100; ent++) {
        uintptr_t entity = GetEntityById(ent);
        if (!entity)
            continue;

        int tmpId = process->Read<int>(entity + 0x8);
        if (tmpId == localPlayerId) {
            return entity;
        }
    }
    return 0;
}

inline uintptr_t GetLocalPlayer() {
    //uintptr_t localPlayerPtr = process->Read<uintptr_t>(apexBase + 0x22E3078);
    //return localPlayerPtr;
    return GetLocalPlayerById();
}


inline bool IsPlayer(uintptr_t entity) {
    char buffer[20];
    VMemRead(&process->ctx->process, process->proc.dirBase, (uint64_t) buffer, process->Read<uintptr_t>(entity + 0x518), 20);
    if (buffer[0] == '\0')
        return false;

    return !strcmp(buffer, "player");
}

inline bool IsProp(uintptr_t entity) {
    static bool doOnce = false;
    if (!doOnce) {
        doOnce = true;
        int entityCount = process->Read<int>(apexBase + 0xC016EA0);
        for (int ent = 1; ent < entityCount; ent++) {
            char buffer[32];
            uintptr_t p_entity = GetEntityById(ent);
            if (!p_entity) continue;

            VMemRead(&process->ctx->process, process->proc.dirBase, (uint64_t) buffer, process->Read<uintptr_t>(p_entity + 0x518), 20);

            int mask = process->Read<int>(p_entity + 0x270);
            //Logger::Log("string: %s, id: %i, mask: %i\n", buffer, ent, mask);
        }

    }
    char buffer[20];

    VMemRead(&process->ctx->process, process->proc.dirBase, (uint64_t) buffer, process->Read<uintptr_t>(entity + 0x518), 20);
    if (buffer[0] == '\0')
        return false;
    bool state = !strcmp(buffer, "prop_survival");

    if (state) {
        //Logger::Log("%p is a prop\n", entity);
    }
    return state;
}
```

`src/utils/minitrace.h`:

```h
#pragma once

#define MTR_SCOPED
#include "m0dular/submodules/minitrace/minitrace.h"
#ifdef MTR_ENABLED
#define MTR_SCOPED_TRACE(cat, name) auto scopedTrace = MTRScopedTrace(cat, name);
#else
#define MTR_SCOPED_TRACE(cat, name)
#endif

```