Project Path: arc_weak1337_NO_ACCESS_Protection_7xcm2ola

Source Tree:

```txt
arc_weak1337_NO_ACCESS_Protection_7xcm2ola
├── NO_ACESS Protect
│   ├── NO_ACESS Protect.sln
│   ├── NO_ACESS Protect.vcxproj
│   ├── NO_ACESS Protect.vcxproj.filters
│   ├── NO_ACESS Protect.vcxproj.user
│   ├── main.cpp
│   ├── protect.cpp
│   └── protect.h
├── NO_ACESS Protect.sln
└── README.md

```

`NO_ACESS Protect.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31729.503
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NO_ACESS Protect", "NO_ACESS Protect\NO_ACESS Protect.vcxproj", "{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Debug|x64.ActiveCfg = Debug|x64
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Debug|x64.Build.0 = Debug|x64
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Debug|x86.ActiveCfg = Debug|Win32
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Debug|x86.Build.0 = Debug|Win32
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Release|x64.ActiveCfg = Release|x64
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Release|x64.Build.0 = Release|x64
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Release|x86.ActiveCfg = Release|Win32
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B6F7060D-B896-4850-912C-32B6C17AFBC1}
	EndGlobalSection
EndGlobal

```

`NO_ACESS Protect/NO_ACESS Protect.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31729.503
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NO_ACESS Protect", "NO_ACESS Protect\NO_ACESS Protect.vcxproj", "{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Debug|x64.ActiveCfg = Debug|x64
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Debug|x64.Build.0 = Debug|x64
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Debug|x86.ActiveCfg = Debug|Win32
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Debug|x86.Build.0 = Debug|Win32
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Release|x64.ActiveCfg = Release|x64
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Release|x64.Build.0 = Release|x64
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Release|x86.ActiveCfg = Release|Win32
		{3D446505-97BA-4EFF-ABD1-D51559CAE0BA}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B6F7060D-B896-4850-912C-32B6C17AFBC1}
	EndGlobalSection
EndGlobal

```

`NO_ACESS Protect/NO_ACESS Protect.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3d446505-97ba-4eff-abd1-d51559cae0ba}</ProjectGuid>
    <RootNamespace>NOACESSProtect</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions>/LTCG /OPT:NOREF %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="protect.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h" />
    <ClInclude Include="protect.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NO_ACESS Protect/NO_ACESS Protect.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Headerdateien\protect">
      <UniqueIdentifier>{dea67bd7-5c4e-41e4-ad19-f31b54f1d1a4}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="protect.cpp">
      <Filter>Headerdateien\protect</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="protect.h">
      <Filter>Headerdateien\protect</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NO_ACESS Protect/NO_ACESS Protect.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`NO_ACESS Protect/main.cpp`:

```cpp
#include "protect.h"

int main() {
	protect::initialize();
	/*
		main code
	*/
	system("pause");
}
```

`NO_ACESS Protect/protect.cpp`:

```cpp
#include "protect.h"


void test_func() {
	printf("HELLO FROM .text func!\n");
}

#pragma optimize("", off) //Disable it so it doesn't get inlined
#pragma section(".0dev", execute, read, write) //Write so we can erase encryption func
#pragma comment(linker,"/SECTION:.0dev,ERW")
#pragma code_seg(push, ".0dev")

uint8_t encryption_key;

PIMAGE_SECTION_HEADER get_section_by_name(const char* name) {
	uint64_t modulebase = (uint64_t)GetModuleHandleA(0);
	PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS)(modulebase + ((PIMAGE_DOS_HEADER)modulebase)->e_lfanew);
	PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt);
	for (int i = 0; i < nt->FileHeader.NumberOfSections; ++i, ++section) {
		if (!_stricmp((char*)section->Name, name))
			return section;
	}
	return nullptr;
}

void encrypt_section(PIMAGE_SECTION_HEADER section) {
	uint64_t modulebase = (uint64_t)GetModuleHandleA(0);
	int valid_page_count = section->Misc.VirtualSize / 0x1000; //If section is smaller than page size skip it
	for (int page_idx = 0; page_idx < valid_page_count; page_idx++)
	{
		uintptr_t address = modulebase + section->VirtualAddress + page_idx * 0x1000;
		printf("Encrypted: %p\n", address);
		DWORD old;
		VirtualProtect((LPVOID)address, 0x1000, PAGE_EXECUTE_READWRITE, &old);
		for (int off = 0; off < 0x1000; off += 0x1) {
			*(BYTE*)(address + off) = _rotr8((*(BYTE*)(address + off) + 0x10) ^ encryption_key, 69);
		}
		VirtualProtect((LPVOID)address, 0x1000, PAGE_NOACCESS, &old);
	}
}

bool rip_in_legit_module(uint64_t rip) {
	PPEB peb = (PPEB)__readgsqword(0x60);
	PPEB_LDR_DATA ldr = peb->Ldr;
	PLDR_DATA_TABLE_ENTRY module = NULL;
	PLIST_ENTRY list = ldr->InMemoryOrderModuleList.Flink;
	while (list != NULL && list != &ldr->InMemoryOrderModuleList) {
		module = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
		PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((uint64_t)module->DllBase + ((PIMAGE_DOS_HEADER)module->DllBase)->e_lfanew);
		if ((rip >= (uint64_t)module->DllBase) && (rip <= (uint64_t)module->DllBase + nt->OptionalHeader.SizeOfImage))
		{
			return true;
		}
		list = list->Flink;
	}
	return false;
}

LONG WINAPI handler(struct _EXCEPTION_POINTERS* ExceptionInfo) {
	if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
		DWORD old;
		//ExceptionInformation[1] holds the invalid referenced memory address
		uint64_t page_start = (uint64_t)ExceptionInfo->ExceptionRecord->ExceptionInformation[1];
		page_start = page_start - (page_start % 0x1000);
		//Before we decrypt our page we want to verify the RIP that caused the violation. If it's not valid someone trys to forcefully decrypt the pages
		if (!rip_in_legit_module(ExceptionInfo->ContextRecord->Rip))
			return EXCEPTION_CONTINUE_SEARCH; //Force crash the program
		VirtualProtect((LPVOID)page_start, 0x1000, PAGE_READWRITE, &old);//Set write protection to decrypt
		for (int off = 0; off < 0x1000; off += 0x1) {
			*(BYTE*)(page_start + off) = (_rotl8(*(BYTE*)(page_start + off),69) ^ encryption_key) - 0x10;
		}
		VirtualProtect((LPVOID)page_start, 0x1000, PAGE_EXECUTE_READ, &old);//Set original protection
		printf("Decrypted %p rip %p\n", page_start, ExceptionInfo->ContextRecord->Rip);
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	return EXCEPTION_CONTINUE_SEARCH;
}




 void protect::initialize()  {
	srand(time(NULL));
	encryption_key = rand() % 255 + 1; //Generate a small decryption key
	AddVectoredExceptionHandler(1, handler); //Handler will handle decryption and access rights
	encrypt_section(get_section_by_name(".text")); 
	//We won't use memset since this will unnecessarily decrypt a page
	for (int i = 0; i < (uint64_t)rip_in_legit_module - (uint64_t)encrypt_section; i+= 0x1) {
		*(uint8_t*)((uint64_t)encrypt_section + i) = 0;
	}
	//Tests 1: Dereference an address that has NO_ACCESS
	printf("%x\n", *(BYTE*)(test_func));
	//Tests 2: Call a func that in a NO_ACCESS region
	test_func();
	system("pause");
}
#pragma code_seg(pop, ".0dev")
#pragma optimize("", on)

```

`NO_ACESS Protect/protect.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <vector>
#include <winternl.h>
namespace protect {
	void initialize();
}
```

`README.md`:

```md
# NO_ACCESS_Protection
This is a technique that I found while reversing Halos anticheat. They encrypt the text section and set the protection to NO_ACCESS. The pages will be decrypted on first access. If the RIP, that referenced the memory, is outside of a valid module it will fail and will crash the process after some time. 
With this they can prevent:
- basic signature scanning (access violation + rip check)
- cheat engine veh debugger
- full process dumping (since you can encrypt the pages again)

```