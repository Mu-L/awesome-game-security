Project Path: arc_weak1337_NvidiaApi_i3a8mk08

Source Tree:

```txt
arc_weak1337_NvidiaApi_i3a8mk08
├── NvidiaApi
│   ├── NvidiaApi.vcxproj
│   ├── NvidiaApi.vcxproj.filters
│   ├── NvidiaApi.vcxproj.user
│   ├── main.cpp
│   ├── nvapi.h
│   ├── nvapi_internal.cpp
│   └── nvapi_public.cpp
├── NvidiaApi.sln
└── README.md

```

`NvidiaApi.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32014.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NvidiaApi", "NvidiaApi\NvidiaApi.vcxproj", "{25331934-8360-4E5F-87A5-A9A930E83D7F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{25331934-8360-4E5F-87A5-A9A930E83D7F}.Debug|x64.ActiveCfg = Debug|x64
		{25331934-8360-4E5F-87A5-A9A930E83D7F}.Debug|x64.Build.0 = Debug|x64
		{25331934-8360-4E5F-87A5-A9A930E83D7F}.Debug|x86.ActiveCfg = Debug|Win32
		{25331934-8360-4E5F-87A5-A9A930E83D7F}.Debug|x86.Build.0 = Debug|Win32
		{25331934-8360-4E5F-87A5-A9A930E83D7F}.Release|x64.ActiveCfg = Release|x64
		{25331934-8360-4E5F-87A5-A9A930E83D7F}.Release|x64.Build.0 = Release|x64
		{25331934-8360-4E5F-87A5-A9A930E83D7F}.Release|x86.ActiveCfg = Release|Win32
		{25331934-8360-4E5F-87A5-A9A930E83D7F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {97AC02C9-D501-408B-A79D-B92D65CBD198}
	EndGlobalSection
EndGlobal

```

`NvidiaApi/NvidiaApi.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{25331934-8360-4e5f-87a5-a9a930e83d7f}</ProjectGuid>
    <RootNamespace>NvidiaApi</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DisableSpecificWarnings>4996</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="nvapi_internal.cpp" />
    <ClCompile Include="nvapi_public.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="nvapi.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NvidiaApi/NvidiaApi.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Ressourcendateien">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Headerdateien\nvidia">
      <UniqueIdentifier>{918258d5-2b44-4b5d-a90b-6ad6933b2036}</UniqueIdentifier>
    </Filter>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="nvapi_public.cpp">
      <Filter>Headerdateien\nvidia</Filter>
    </ClCompile>
    <ClCompile Include="nvapi_internal.cpp">
      <Filter>Headerdateien\nvidia</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="nvapi.h">
      <Filter>Headerdateien\nvidia</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NvidiaApi/NvidiaApi.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`NvidiaApi/main.cpp`:

```cpp
#include <Windows.h>
#include "nvapi.h"
int main() {
	
	SetConsoleTitleA("Nvidia Api");

	nvapi::pub::nvmlInit_v2();

	uint64_t handle;
	nvapi::pub::nvmlDeviceGetHandleByIndex_v2(&handle);

	std::string uuid;
	nvapi::pub::nvmlDeviceGetUUID((uint64_t*)handle, uuid);

	std::string devname;
	nvapi::pub::nvmlDeviceGetName((uint64_t*)handle, devname);

	printf("LEAKED: [%s]  -> %s\n", devname.c_str(),  uuid.c_str() );

	system("pause");
	return 0;
}
```

`NvidiaApi/nvapi.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <d3dkmthk.h>
#include <d3d11.h>
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "dxgi.lib")
namespace nvapi {
	
	extern uint32_t* nvidia_buffer;

	namespace pub{
		void nvmlInit_v2();
		void nvmlInitWithFlags(int flags);
		bool nvmlDeviceGetHandleByIndex_v2(uint64_t* out);
		void nvmlDeviceGetUUID(uint64_t* adapter, std::string& uuid);
		void nvmlDeviceGetName(uint64_t* adapter, std::string& name);
	}

	struct nv_adapter_info {
		uint32_t adapter_handle;
		uint32_t adapter_private;
	};

	static nv_adapter_info nvidia_adapters[10];
	static uint32_t private_nvidia_handle;

	namespace internal {

		NTSTATUS escape(uint32_t main_adapter, D3DKMT_ESCAPETYPE type, uint32_t size, uintptr_t private_data);
		int make_call(int handle, int handle2, int id, uint64_t* argbuffer, int buffersize);
		int make_call2(int adapter, int handle, int val1, int val2, int id, uint64_t* argbuffer, int buffersize);

		bool collect_adapters();
		bool init_variables();
		bool prepare_handle(uint32_t* adapterinfo);
		void get_uuid_internal(uint64_t* adapter, std::string& uuid);
		void get_name_internal(uint64_t* adapter, std::string&name);
	}

}
```

`NvidiaApi/nvapi_internal.cpp`:

```cpp
#include "nvapi.h"

struct query_basic_adapter {
	uint32_t signature;
	uint32_t size;
	uint32_t command;
	uint32_t unk3;
	uint8_t unkbuffer[0xA391];
};

bool nvapi::internal::collect_adapters() {
	printf("ENTERING %s\n", __FUNCTION__);
	D3DKMT_ENUMADAPTERS2 adapters = { 0 };

	D3DKMTEnumAdapters2(&adapters);

	if (!adapters.NumAdapters)
	{
		printf("Couldn't find any adapters!\n");
		return false;
	}

	adapters.pAdapters = (D3DKMT_ADAPTERINFO*)malloc(adapters.NumAdapters + 0x14);

	if (D3DKMTEnumAdapters2(&adapters))
	{
		printf("D3DKMTEnumAdapters2 failed!\n");
		return false;
	}
	
	for (int i = 0; i < adapters.NumAdapters - 1; i++) {
		nvidia_adapters[i].adapter_handle = adapters.pAdapters[i].hAdapter;
	}
	return true;

}

NTSTATUS nvapi::internal::escape(uint32_t main_adapter, D3DKMT_ESCAPETYPE type, uint32_t size, uintptr_t private_data) {

	D3DKMT_ESCAPE data = { 0 };
	data.hAdapter = main_adapter;
	data.Type = type;
	data.pPrivateDriverData = (void*)private_data;
	data.PrivateDriverDataSize = size;

	return D3DKMTEscape(&data);

}

int nvapi::internal::make_call(int handle, int handle2, int id, uint64_t* argbuffer, int buffersize) {
	DWORD* buffer = (DWORD*)malloc(buffersize + 0x44);
	memset(buffer, 0, buffersize + 0x44);
	buffer[0] = 0x4E564441;
	buffer[1] = 0x10002;
	buffer[2] = buffersize + 0x44;
	buffer[3] = 0x4E562A2A;
	buffer[4] = 0x500002B;
	buffer[12] = handle;
	buffer[13] = handle2;
	buffer[14] = id;
	buffer[15] = buffersize;


	memcpy((void*)((uintptr_t)buffer + 0x44), (void*)argbuffer, buffersize);

	NTSTATUS status = internal::escape(nvapi::nvidia_adapters[0].adapter_handle, D3DKMT_ESCAPE_DRIVERPRIVATE, buffersize + 0x44, (uintptr_t)buffer);
	if (status)
		return status;
	memcpy((void*)argbuffer, (void*)((uintptr_t)buffer + 0x44), buffersize);

	return buffer[16];
}

int nvapi::internal::make_call2(int adapter, int handle, int val1, int val2, int id, uint64_t* argbuffer, int buffersize) {
	DWORD* buffer = (DWORD*)malloc(buffersize + 0x48);
	memset(buffer, 0, buffersize + 0x48);
	buffer[0] = 0x4E564441;
	buffer[1] = 0x10002;
	buffer[2] = buffersize + 0x48;
	buffer[3] = 0x4E562A2A;
	buffer[4] = 0x500002A;
	buffer[12] = handle;
	buffer[13] = val1;
	buffer[14] = val2;
	buffer[15] = id;
	buffer[16] = buffersize;

	memcpy((void*)((uintptr_t)buffer + 0x48), (void*)argbuffer, buffersize);
	NTSTATUS status = internal::escape(nvapi::nvidia_adapters[0].adapter_handle, D3DKMT_ESCAPE_DRIVERPRIVATE, buffersize + 0x48, (uintptr_t)buffer);
	if (status)
		return status;

	memcpy((void*)argbuffer, (void*)((uintptr_t)buffer + 0x48), buffersize);

	return buffer[17];
}

struct query_private_handle {
	uint32_t unk1;
	uint32_t unk2;
	uint32_t unk3;
	uint32_t unk4;
	uint32_t unk5;
	uint32_t unk6;
	uint32_t unk7;
	uint32_t unk8;
	uint32_t unk9;
	uint32_t unk10;
	uint32_t unk11;
	uint32_t unk12;
	uint32_t unk13;
	uint32_t unk14;
	uint32_t unk15;
	uint32_t unk16;
	uint32_t unk17;
	uint32_t unk18;
	uint32_t unk19;

};

int retrieve_private_handle(uint32_t* handle) {

	query_private_handle query_private = { 0 };
	query_private.unk1 = 0x4E564441;
	query_private.unk2 = 0x10002;
	query_private.unk3 = 0x4C;
	query_private.unk4 = 0x4E562A2A;
	query_private.unk5 = 0x500002A;
	query_private.unk16 = 0x41;
	query_private.unk17 = 4;

	if (nvapi::internal::escape(nvapi::nvidia_adapters[0].adapter_handle, D3DKMT_ESCAPE_DRIVERPRIVATE, 0x4C, (uintptr_t)&query_private))
		return 1;
	*handle = query_private.unk19;
	return query_private.unk18;


}




bool nvapi::internal::init_variables() {
	
	int error = retrieve_private_handle(&nvapi::private_nvidia_handle);
	
	if (error)
	{
		printf("Couldn't retrieve private handle!\n");
		return false;
	}
	return true;
}

uint32_t global_index = 0xA55A0000;

void get_index(uint32_t* idx) {
	uint32_t current = global_index;
	global_index += 0x10;
	*idx = current;
	return;
}

bool nvapi::internal::prepare_handle(uint32_t* adapterinfo) {
	printf("ENTERING : %s\n", __FUNCTION__);

	if (!adapterinfo[4]) {
		adapterinfo[3] = 1;
		adapterinfo[4] = 1;
	}

	uint32_t init = adapterinfo[6];
	if (!init) {

		if (!adapterinfo || !adapterinfo[4] || adapterinfo[6] || !adapterinfo[3])
			return false;

		uint32_t idx;
		get_index(&idx);
		uint32_t buffer[0x40 / 4] = { 0 };
		
		uint32_t error = 0;
		if (error = internal::make_call2(nvapi::nvidia_adapters[0].adapter_handle, nvapi::private_nvidia_handle, nvapi::private_nvidia_handle, idx, 0x80, (uintptr_t*)buffer, 0x40))
		{
			printf("make_call2 failed with error : %x\n", error);
			return false;
		}

		uint32_t result;
		if (error = internal::make_call(nvapi::private_nvidia_handle, idx, 0x800289, (uint64_t*)&result, 4))
		{
			printf("make_call failed with error : %x\n", error);
			return false;
		}
	}
	
	return true;
}



void nvapi::internal::get_uuid_internal(uint64_t* adapter, std::string& uuid) {
	printf("ENTERING : %s\n", __FUNCTION__);
	uint32_t idx;
	get_index(&idx);
	DWORD old = idx - 0x10;
	DWORD idk = 0;
	uint32_t error = 0;
	if (error = internal::make_call2(nvapi::nvidia_adapters[0].adapter_handle, nvapi::private_nvidia_handle, old, idx, 0x2080, (uintptr_t*)&idk, 4))
	{
		printf("make_call2 failed with error : %x\n", error);
		return;
	}

	uint32_t buffer[0x10C / 4] = { 0 };

	if (error = internal::make_call(nvapi::private_nvidia_handle, idx, 0x2080014A, (uintptr_t*)&buffer, 0x10C))
	{
		printf("make_call2 failed with error : %x\n", error);
		return;
	}
	
	uuid = (char*)(&buffer[3]);

}

void nvapi::internal::get_name_internal(uint64_t* adapter, std::string& name) {
	printf("ENTERING : %s\n", __FUNCTION__);
	uint32_t buffer[0x10C / 4] = { 0 };
	uint32_t error = 0;
	if (error = internal::make_call(nvapi::private_nvidia_handle, 0xA55A0000 + 0x10, 0x20800110, (uintptr_t*)&buffer, 0x84)) //We can use previous discovered handle
	{
		printf("make_call failed with error : %x\n", error);
		return;

	}
	name = (char*)(&buffer[1]);
}
```

`NvidiaApi/nvapi_public.cpp`:

```cpp
#include "nvapi.h"

uint32_t* nvapi::nvidia_buffer;

void nvapi::pub::nvmlInitWithFlags(int flags) {

	nvapi::nvidia_buffer = (uint32_t*)malloc(0xB5D66 * 4);

	memset((void*)nvapi::nvidia_buffer, 0, sizeof(0xB5D66 * 4));

	//DeviceIoNotNeeded
	if (!internal::collect_adapters())
		return;
	internal::init_variables();

}

void nvapi::pub::nvmlInit_v2()
{
	pub::nvmlInitWithFlags(0);
}

bool nvapi::pub::nvmlDeviceGetHandleByIndex_v2(uintptr_t* out) {
	uint64_t address = (uintptr_t)nvapi::nvidia_buffer;
	*out = address;
	return internal::prepare_handle((uint32_t*)(address + 0x38));
}

void nvapi::pub::nvmlDeviceGetUUID(uint64_t* adapter, std::string& uuid) {

	internal::get_uuid_internal(adapter, uuid);

}

void nvapi::pub::nvmlDeviceGetName(uint64_t* adapter, std::string& name) {

	internal::get_name_internal(adapter, name);

}
```

`README.md`:

```md
# NvidiaApi

Nvidia Api is a reversal of the latest nvml.dll.

Nvml.dll allows developers to query Devicename, UUID and similar values.
Most people that try to spoof these values just delete the dll from their system.

This project shows that it's possible to retrieve these values even without the dll.

Remarks:
This was developed for version 511.79. Future or older versions might differ!

![Output](https://i.gyazo.com/19ad1675998a47ea3f795085373efd4d.png)

```