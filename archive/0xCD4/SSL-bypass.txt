Project Path: arc_0xCD4_SSL-bypass_zs4o0sph

Source Tree:

```txt
arc_0xCD4_SSL-bypass_zs4o0sph
├── README.md
└── root_bypass.js

```

`README.md`:

```md
# Universal Android Security Bypass Suite

A universal, non-customized Frida script for bypassing security mechanisms in Android applications. This script works out-of-the-box across different Android versions and applications without requiring app-specific modifications.

> **Important:** This is a universal bypass script, not a customized solution. It's designed to work across different Android versions and applications without modifications.

> **Note about Stability:** As with any universal bypass solution, crashes may occur:
> - Some applications may crash on first attempt - retry 2-3 times
> - If persistent crashes occur, try:
>   - Restarting the target application
>   - Relaunching Frida
>   - Clearing app data/cache
>   - Running with `-f` flag instead of `-F`
> - Success rate varies by application and protection mechanisms

## Core Features

### Universal Compatibility
- Works across all Android versions (5.0 - 14.0+)
- No app-specific customization needed
- Framework-agnostic implementation
- Automatic detection and bypass of security features

### Key Bypass Mechanisms
1. **Universal Root Detection Bypass**
   - Common root file path checks
   - Package manager detection
   - System property checks
   - Runtime command execution
   - Build property modifications

2. **Universal SSL Pinning Bypass**
   - TrustManager implementation
   - WebView SSL error handling
   - OkHttp certificate pinning
   - Universal SSL context modification

3. **Universal Memory Protection**
   - Generic memory range protection
   - Cross-version memory access handling
   - Basic memory restriction bypasses

## Limitations

### Known Limitations
1. **Root Detection**
   - May not bypass highly customized root detection
   - Some app-specific root checks might still work
   - Custom hardware attestation not bypassed

2. **SSL Pinning**
   - Custom certificate validation may require additional handling
   - Some advanced pinning techniques might not be bypassed
   - Network security configuration overrides may vary

3. **General**
   - No bypass for hardware-backed security features
   - Some app-specific security measures might remain
   - Not designed for highly sophisticated protection mechanisms

### What This Script Won't Do
- Bypass hardware-based security
- Handle app-specific custom implementations
- Bypass sophisticated anti-tampering
- Override hardware attestation
- Bypass custom security frameworks

## Usage

### Basic Setup
```bash
# Load the script
frida -U -l root_bypass.js -f com.target.application
```


## Technical Details

### Universal Design Principles
- Framework-agnostic hooks
- Generic bypass implementations
- No app-specific logic
- Minimal dependencies
- Cross-version compatibility

### Implementation Approach
- Uses common Android APIs
- Implements basic security bypasses
- Focuses on universal detection methods
- Avoids version-specific code
- Maintains simplicity for reliability

## Security Notice

This universal bypass script is intended for:
- Security research
- Penetration testing
- Vulnerability assessment

**Important:** 
- This is not a silver bullet
- Some protections may remain active
- Advanced security measures might require custom solutions
- Always test thoroughly in your specific use case

## Advantages of Universal Approach
- Works immediately without customization
- No need for app-specific modifications
- Consistent behavior across apps
- Easy to maintain and update
- Reliable base functionality

## Limitations of Universal Approach
- Cannot handle all edge cases
- May miss app-specific protections
- Limited to common security measures
- Basic protection bypass only
- No advanced feature handling

## Best Practices
1. Use as initial bypass attempt
2. Monitor for unhandled protections
3. Consider supplementing with custom code if needed
4. Test thoroughly on target application
5. Be aware of limitations
6. For crash handling:
   - Always try multiple attempts
   - Monitor logcat for specific errors
   - Consider timing of script injection
   - Use appropriate Frida launch flags

## License & Usage
For legitimate security research and authorized testing only. Users are responsible for compliance with applicable laws and regulations.
```

`root_bypass.js`:

```js
/**
 * Universal Android Security Bypass Suite
 *
 * Frida script for security testing and penetration testing of Android applications.
 * For authorized security research and penetration testing only.
 *
 * Features:
 * - SSL/Certificate Pinning Bypass (20+ libraries)
 * - Root Detection Bypass (native & Java level)
 * - Frida Detection Bypass
 * - Burp Certificate Installation
 *
 * Optimizations:
 * - Regex-based pattern matching for improved performance
 * - Consolidated SSL bypass functions (removed 460+ lines of duplication)
 * - Efficient root path/package detection
 * - Consistent error handling and logging
 */

setTimeout(function() {
    if (!Java.available) {
        console.log("[!] Java API not available — this script only supports Android.");
        console.log("[!] You appear to be running on iOS. Use an iOS-specific SSL bypass script instead.");
        console.log("[!] Suggested alternatives:");
        console.log("[!]   - objection: objection -g <bundle_id> explore -> ios sslpinning disable");
        console.log("[!]   - ssl-kill-switch2 (Cydia/Sileo tweak)");
        console.log("[!]   - iOS Frida scripts using ObjC.classes (SecTrustEvaluate, NSURLSession hooks)");
        return;
    }

    Java.perform(function() {
        console.log("[*] Starting SSL Bypass Suite v2.0 (Optimized)");

        const bypassStatus = {
            ssl: false,
            root: false,
        };

        // ============================================================================
        // CONFIGURATION: Root Detection Indicators
        // ============================================================================

        const ROOT_FILES = [
           "/data/local/bin/su",
           "/data/local/su",
           "/data/local/xbin/su",
           "/dev/com.koushikdutta.superuser.daemon/",
           "/sbin/su",
           "/system/app/Superuser.apk",
           "/system/bin/failsafe/su",
           "/system/bin/su",
           "/su/bin/su",
           "/system/etc/init.d/99SuperSUDaemon",
           "/system/sd/xbin/su",
           "/system/xbin/busybox",
           "/system/xbin/daemonsu",
           "/system/xbin/su",
           "/system/sbin/su",
           "/vendor/bin/su",
           "/cache/su",
           "/data/su",
           "/dev/su",
           "/system/bin/.ext/su",
           "/system/usr/we-need-root/su",
           "/system/app/Kinguser.apk",
           "/data/adb/magisk",
           "/sbin/.magisk",
           "/cache/.disable_magisk",
           "/dev/.magisk.unblock",
           "/cache/magisk.log",
           "/data/adb/magisk.img",
           "/data/adb/magisk.db",
           "/data/adb/magisk_simple",
           "/init.magisk.rc",
           "/system/xbin/ku.sud",
           "/data/adb/ksu",
           "/data/adb/ksud",
           "/data/adb/ksu.apk",
           "/data/adb/ksud.apk",
           "/data/adb/magisk.apk",
           "/data/adb/magisk_simple.apk",
           "/data/adb/magisk.img",
           "/data/adb/magisk.db",
        ];

        const ROOT_PACKAGES = [
            "com.noshufou.android.su",
            "com.noshufou.android.su.elite",
            "eu.chainfire.supersu",
            "com.koushikdutta.superuser",
            "com.thirdparty.superuser",
            "com.yellowes.su",
            "com.koushikdutta.rommanager",
            "com.koushikdutta.rommanager.license",
            "com.dimonvideo.luckypatcher",
            "com.chelpus.lackypatch",
            "com.ramdroid.appquarantine",
            "com.ramdroid.appquarantinepro",
            "com.topjohnwu.magisk",
            "me.weishu.kernelsu",
            "com.devadvance.rootcloak",
            "com.devadvance.rootcloakplus",
            "de.robv.android.xposed.installer",
            "com.saurik.substrate",
            "com.zachspong.temprootremovejb",
            "com.amphoras.hidemyroot",
            "com.amphoras.hidemyrootadfree",
            "com.formyhm.hiderootPremium",
            "com.formyhm.hideroot",
            "me.phh.superuser",
            "eu.chainfire.supersu.pro",
            "com.kingouser.com"
        ];

        const ROOT_BINARIES = new Set([
            "su", "busybox", "supersu", "Superuser.apk", "KingoUser.apk",
            "SuperSu.apk", "magisk", "magisk64", "magiskhide", "magiskboot"
        ]);

        const ROOT_PROPERTIES = new Map([
            ["ro.build.selinux", "1"],
            ["ro.debuggable", "0"],
            ["service.adb.root", "0"],
            ["ro.secure", "1"],
            ["ro.build.tags", "release-keys"],
            ["ro.build.type", "user"]
        ]);

        const SENSITIVE_PROPS = new Set([
            "ro.secure",
            "ro.debuggable",
            "ro.build.fingerprint",
            "service.adb.root"
        ]);

        // ============================================================================
        // CONFIGURATION: Java Classes & Logging
        // ============================================================================

        const JavaClasses = {
            SSLContext: Java.use("javax.net.ssl.SSLContext"),
            Runtime: Java.use("java.lang.Runtime"),
            File: Java.use("java.io.File"),
            PackageManager: Java.use("android.app.ApplicationPackageManager"),
            ProcessBuilder: Java.use("java.lang.ProcessBuilder")
        };

        const LOG_LEVEL = {
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3
        };

        const CURRENT_LOG_LEVEL = LOG_LEVEL.INFO;

        const CONFIG = {
            enableSSLBypass: true,
            enableRootBypass: true,
            enableDetailedLogs: false,
            blockAllRootCommands: true,
            allowedRootCommands: new Set(["getprop"]), // Whitelist certain commands
        };

        // Optimized root path checking using regex
        const ROOT_FILES_REGEX = new RegExp(ROOT_FILES.map(p => p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'));
        const ROOT_PACKAGES_REGEX = new RegExp(ROOT_PACKAGES.join('|'));

        // Utility function for efficient root path detection
        function isRootPath(path) {
            if (!path) return false;
            return ROOT_FILES_REGEX.test(path);
        }

        function isRootPackage(pkg) {
            if (!pkg) return false;
            return ROOT_PACKAGES_REGEX.test(pkg);
        }

        function log(level, message, error) {
            if (level >= CURRENT_LOG_LEVEL) {
                switch(level) {
                    case LOG_LEVEL.DEBUG:
                        console.log("[D] " + message);
                        break;
                    case LOG_LEVEL.INFO:
                        console.log("[*] " + message);
                        break;
                    case LOG_LEVEL.WARN:
                        console.log("[!] " + message);
                        break;
                    case LOG_LEVEL.ERROR:
                        console.error("[E] " + message);
                        if (error) console.error(error.stack || error);
                        break;
                }
            }
        }

        // ============================================================================
        // SSL/TLS CERTIFICATE PINNING BYPASS
        // ============================================================================

        function setupSSLBypass() {
            console.log("[+] Setting up SSL bypass...");
            try {
                bypassCertificateValidation();
                bypassOkHttp();
                bypassTrustKit();
                bypassWebViewClient();
                bypassCertificatePinning();
                bypassHttpsURLConnection();
                bypassTrustManagerImpl();
                bypassOpenSSL();
                bypassPhoneGap();
                bypassIBMMobileFirst();
                bypassAppcelerator();
                bypassAppmattus();
                bypassBoye();

                bypassStatus.ssl = true;
                console.log("[+] SSL pinning bypass completed");
                return true;
            } catch(e) {
                console.log("[-] SSL Bypass failed:", e);
                return false;
            }
        }

        function bypassCertificateValidation() {
            try {
                const X509TrustManager = Java.use("javax.net.ssl.X509TrustManager");
                const CustomTrustManager = Java.registerClass({
                    name: "com.custom.TrustManager",
                    implements: [X509TrustManager],
                    methods: {
                        checkClientTrusted: function() {},
                        checkServerTrusted: function() {},
                        getAcceptedIssuers: function() { return []; }
                    }
                });

                const SSLContext_init = JavaClasses.SSLContext.init.overload(
                    "[Ljavax.net.ssl.KeyManager;", 
                    "[Ljavax.net.ssl.TrustManager;", 
                    "java.security.SecureRandom"
                );

                SSLContext_init.implementation = function(keyManager, trustManager, secureRandom) {
                    SSLContext_init.call(this, keyManager, [CustomTrustManager.$new()], secureRandom);
                };
            } catch(e) {
                console.log("[-] Certificate validation bypass failed");
            }
        }

        function bypassOkHttp() {
            try {
                const CertificatePinner = Java.use("okhttp3.CertificatePinner");
                
                CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, certificates) {
                    return;
                };

                CertificatePinner.check$okhttp.implementation = function(hostname, certificates) {
                    return;
                };
            } catch(e) {
                console.log("[-] OkHttp bypass failed:", e);
            }
        }

        function bypassTrustKit() {
            console.log("[*] Setting up TrustKit bypass...");
            let bypassCount = 0;

            // Helper function to handle TrustKit class hooks
            const hookTrustKitClass = (className, methodName, overloadTypes = null) => {
                try {
                    const targetClass = Java.use(className);
                    const method = overloadTypes ? 
                        targetClass[methodName].overload(...overloadTypes) :
                        targetClass[methodName];

                    method.implementation = function(...args) {
                        const hostname = args[0] || "unknown";
                        console.log(`[+] Bypassing ${className}.${methodName} for: ${hostname}`);
                        return methodName.includes("verify") ? true : undefined;
                    };
                    bypassCount++;
                    return true;
                } catch(e) {
                    if (!e.toString().includes("ClassNotFoundException")) {
                        console.log(`[-] Failed to hook ${className}.${methodName}:`, e);
                    }
                    return false;
                }
            };

            // TrustKit hostname verifier bypasses
            hookTrustKitClass(
                "com.datatheorem.android.trustkit.pinning.OkHostnameVerifier",
                "verify", 
                ["java.lang.String", "javax.net.ssl.SSLSession"]
            );

            hookTrustKitClass(
                "com.datatheorem.android.trustkit.pinning.OkHostnameVerifier",
                "verify",
                ["java.lang.String", "java.security.cert.X509Certificate"]
            );

            // TrustKit certificate pinning bypass
            hookTrustKitClass(
                "com.datatheorem.android.trustkit.pinning.PinningTrustManager",
                "checkServerTrusted"
            );

            // Additional TrustKit bypasses
            hookTrustKitClass(
                "com.datatheorem.android.trustkit.TrustKit",
                "initializeWithNetworkSecurityConfiguration"
            );

            hookTrustKitClass(
                "com.datatheorem.android.trustkit.reporting.BackgroundReporter",
                "reportCertificateError"
            );

            if (bypassCount > 0) {
                console.log(`[+] Successfully set up ${bypassCount} TrustKit bypasses`);
            } else {
                console.log("[*] TrustKit not found in app (this is normal)");
            }
        }

        function bypassWebViewClient() {
            try {
                const WebViewClient = Java.use("android.webkit.WebViewClient");
                
                WebViewClient.onReceivedSslError.overload(
                    "android.webkit.WebView",
                    "android.webkit.SslErrorHandler",
                    "android.net.http.SslError"
                ).implementation = function(webView, handler, error) {
                    handler.proceed();
                };
            } catch(e) {
                console.log("[-] WebViewClient bypass failed:", e);
            }
        }

        function bypassCertificatePinning() {
            try {
                const UnverifiedCertError = Java.use("javax.net.ssl.SSLPeerUnverifiedException");
                UnverifiedCertError.$init.implementation = function(message) {
                    try {
                        const stackTrace = Java.use("java.lang.Thread").currentThread().getStackTrace();
                        const exceptionStack = stackTrace.findIndex(stack =>
                            stack.getClassName() === "javax.net.ssl.SSLPeerUnverifiedException"
                        );

                        if (exceptionStack >= 0) {
                            const callingStack = stackTrace[exceptionStack + 1];
                            const className = callingStack.getClassName();
                            const methodName = callingStack.getMethodName();

                            return this.$init("SSL verification bypassed");
                        }
                    } catch(e) {
                        console.log("[-] Stack trace analysis failed:", e);
                    }

                    return this.$init(message);
                };
            } catch(e) {
                console.log("[-] Certificate pinning bypass failed:", e);
            }
        }

        function bypassHttpsURLConnection() {
            try {
                const HttpsURLConnection = Java.use("javax.net.ssl.HttpsURLConnection");

                HttpsURLConnection.setSSLSocketFactory.implementation = function(SSLSocketFactory) {
                    log(LOG_LEVEL.DEBUG, "Bypassing HttpsURLConnection.setSSLSocketFactory");
                    return;
                };

                HttpsURLConnection.setHostnameVerifier.implementation = function(hostnameVerifier) {
                    log(LOG_LEVEL.DEBUG, "Bypassing HttpsURLConnection.setHostnameVerifier");
                    return;
                };

                HttpsURLConnection.setDefaultHostnameVerifier.implementation = function(hostnameVerifier) {
                    log(LOG_LEVEL.DEBUG, "Bypassing HttpsURLConnection.setDefaultHostnameVerifier");
                    return;
                };

                console.log("[+] HttpsURLConnection bypass");
            } catch(e) {
                console.log("[ ] HttpsURLConnection bypass not applicable");
            }
        }

        function bypassTrustManagerImpl() {
            try {
                const ArrayList = Java.use("java.util.ArrayList");
                const TrustManagerImpl = Java.use("com.android.org.conscrypt.TrustManagerImpl");

                TrustManagerImpl.checkTrustedRecursive.implementation = function(a1, a2, a3, a4, a5, a6) {
                    log(LOG_LEVEL.DEBUG, "Bypassing TrustManagerImpl.checkTrustedRecursive");
                    return ArrayList.$new();
                };

                TrustManagerImpl.verifyChain.implementation = function(untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) {
                    log(LOG_LEVEL.DEBUG, `Bypassing TrustManagerImpl.verifyChain: ${host}`);
                    return untrustedChain;
                };

                console.log("[+] TrustManagerImpl (Android 7+) bypass");
            } catch(e) {
                console.log("[ ] TrustManagerImpl bypass not applicable");
            }
        }

        function bypassOpenSSL() {
            let bypassCount = 0;

            // OpenSSLSocketImpl Conscrypt
            try {
                const OpenSSLSocketImpl = Java.use("com.android.org.conscrypt.OpenSSLSocketImpl");
                OpenSSLSocketImpl.verifyCertificateChain.implementation = function(certRefs, JavaObject, authMethod) {
                    log(LOG_LEVEL.DEBUG, "Bypassing OpenSSLSocketImpl Conscrypt");
                };
                bypassCount++;
            } catch(e) {}

            // OpenSSLEngineSocketImpl Conscrypt
            try {
                const OpenSSLEngineSocketImpl = Java.use("com.android.org.conscrypt.OpenSSLEngineSocketImpl");
                OpenSSLEngineSocketImpl.verifyCertificateChain.overload("[Ljava.lang.Long;", "java.lang.String").implementation = function(a, b) {
                    log(LOG_LEVEL.DEBUG, `Bypassing OpenSSLEngineSocketImpl: ${b}`);
                };
                bypassCount++;
            } catch(e) {}

            // OpenSSLSocketImpl Apache Harmony
            try {
                const OpenSSLSocketImplHarmony = Java.use("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
                OpenSSLSocketImplHarmony.verifyCertificateChain.implementation = function(asn1DerEncodedCertificateChain, authMethod) {
                    log(LOG_LEVEL.DEBUG, "Bypassing OpenSSLSocketImpl Apache Harmony");
                };
                bypassCount++;
            } catch(e) {}

            if (bypassCount > 0) {
                console.log(`[+] OpenSSL bypasses (${bypassCount} variants)`);
            } else {
                console.log("[ ] OpenSSL bypasses not applicable");
            }
        }

        function bypassPhoneGap() {
            try {
                const PhoneGapSSL = Java.use("nl.xservices.plugins.sslCertificateChecker");
                PhoneGapSSL.execute.overload("java.lang.String", "org.json.JSONArray", "org.apache.cordova.CallbackContext").implementation = function(a, b, c) {
                    log(LOG_LEVEL.DEBUG, `Bypassing PhoneGap sslCertificateChecker: ${a}`);
                    return true;
                };
                console.log("[+] PhoneGap sslCertificateChecker bypass");
            } catch(e) {
                console.log("[ ] PhoneGap bypass not applicable");
            }

            // Apache Cordova WebViewClient
            try {
                const CordovaWebViewClient = Java.use("org.apache.cordova.CordovaWebViewClient");
                CordovaWebViewClient.onReceivedSslError.overload("android.webkit.WebView", "android.webkit.SslErrorHandler", "android.net.http.SslError").implementation = function(obj1, obj2, obj3) {
                    log(LOG_LEVEL.DEBUG, "Bypassing Apache Cordova WebViewClient");
                    obj2.proceed();
                };
                console.log("[+] Apache Cordova WebViewClient bypass");
            } catch(e) {
                console.log("[ ] Apache Cordova bypass not applicable");
            }
        }

        function bypassIBMMobileFirst() {
            let bypassCount = 0;

            // IBM MobileFirst pinTrustedCertificatePublicKey
            try {
                const WLClient = Java.use("com.worklight.wlclient.api.WLClient");

                WLClient.getInstance().pinTrustedCertificatePublicKey.overload("java.lang.String").implementation = function(cert) {
                    log(LOG_LEVEL.DEBUG, `Bypassing IBM MobileFirst (string): ${cert}`);
                    return;
                };

                WLClient.getInstance().pinTrustedCertificatePublicKey.overload("[Ljava.lang.String;").implementation = function(cert) {
                    log(LOG_LEVEL.DEBUG, `Bypassing IBM MobileFirst (array): ${cert}`);
                    return;
                };
                bypassCount += 2;
            } catch(e) {}

            // IBM WorkLight HostNameVerifierWithCertificatePinning
            try {
                const HostNameVerifier = Java.use("com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning");

                HostNameVerifier.verify.overload("java.lang.String", "javax.net.ssl.SSLSocket").implementation = function(a, b) {
                    log(LOG_LEVEL.DEBUG, `Bypassing IBM WorkLight (SSLSocket): ${a}`);
                    return;
                };

                HostNameVerifier.verify.overload("java.lang.String", "java.security.cert.X509Certificate").implementation = function(a, b) {
                    log(LOG_LEVEL.DEBUG, `Bypassing IBM WorkLight (cert): ${a}`);
                    return;
                };

                HostNameVerifier.verify.overload("java.lang.String", "[Ljava.lang.String;", "[Ljava.lang.String;").implementation = function(a, b, c) {
                    log(LOG_LEVEL.DEBUG, `Bypassing IBM WorkLight (strings): ${a}`);
                    return;
                };

                HostNameVerifier.verify.overload("java.lang.String", "javax.net.ssl.SSLSession").implementation = function(a, b) {
                    log(LOG_LEVEL.DEBUG, `Bypassing IBM WorkLight (SSLSession): ${a}`);
                    return true;
                };
                bypassCount += 4;
            } catch(e) {}

            if (bypassCount > 0) {
                console.log(`[+] IBM MobileFirst/WorkLight bypasses (${bypassCount} variants)`);
            } else {
                console.log("[ ] IBM MobileFirst/WorkLight not applicable");
            }
        }

        function bypassAppcelerator() {
            try {
                const AppceleratorPinning = Java.use("appcelerator.https.PinningTrustManager");
                AppceleratorPinning.checkServerTrusted.implementation = function() {
                    log(LOG_LEVEL.DEBUG, "Bypassing Appcelerator PinningTrustManager");
                };
                console.log("[+] Appcelerator bypass");
            } catch(e) {
                console.log("[ ] Appcelerator bypass not applicable");
            }
        }

        function bypassAppmattus() {
            let bypassCount = 0;

            try {
                const CertTransInterceptor = Java.use("com.appmattus.certificatetransparency.internal.verifier.CertificateTransparencyInterceptor");
                CertTransInterceptor.intercept.implementation = function(a) {
                    log(LOG_LEVEL.DEBUG, "Bypassing Appmattus CertificateTransparencyInterceptor");
                    return a.proceed(a.request());
                };
                bypassCount++;
            } catch(e) {}

            try {
                const CertTransTrustManager = Java.use("com.appmattus.certificatetransparency.internal.verifier.CertificateTransparencyTrustManager");

                CertTransTrustManager.checkServerTrusted.overload("[Ljava.security.cert.X509Certificate;", "java.lang.String").implementation = function(certs, str) {
                    log(LOG_LEVEL.DEBUG, "Bypassing Appmattus TrustManager (2 args)");
                };

                CertTransTrustManager.checkServerTrusted.overload("[Ljava.security.cert.X509Certificate;", "java.lang.String", "java.lang.String").implementation = function(certs, str, str2) {
                    log(LOG_LEVEL.DEBUG, "Bypassing Appmattus TrustManager (3 args)");
                    return Java.use("java.util.ArrayList").$new();
                };
                bypassCount += 2;
            } catch(e) {}

            if (bypassCount > 0) {
                console.log(`[+] Appmattus bypasses (${bypassCount} variants)`);
            } else {
                console.log("[ ] Appmattus not applicable");
            }
        }

        function bypassBoye() {
            try {
                const BoyeVerifier = Java.use("ch.boye.httpclientandroidlib.conn.ssl.AbstractVerifier");
                BoyeVerifier.verify.implementation = function(host, ssl) {
                    log(LOG_LEVEL.DEBUG, `Bypassing Boye AbstractVerifier: ${host}`);
                };
                console.log("[+] Boye AbstractVerifier bypass");
            } catch(e) {
                console.log("[ ] Boye bypass not applicable");
            }
        }

        // ============================================================================
        // ROOT DETECTION BYPASS
        // ============================================================================

        function bypassBuildProps() {
            try {
                const Build = Java.use("android.os.Build");
                Build.PRODUCT.value = "gracerltexx";
                Build.MANUFACTURER.value = "samsung";
                Build.BRAND.value = "samsung";
                Build.DEVICE.value = "gracerlte";
                Build.MODEL.value = "SM-N935F";
                Build.HARDWARE.value = "samsungexynos8890";
                Build.FINGERPRINT.value = "samsung/gracerltexx/gracerlte:8.0.0/R16NW/N935FXXS4BRK2:user/release-keys";
                Build.BOARD.value = "universal8890";
                Build.HOST.value = "SWHE";
                Build.ID.value = "R16NW";
                Build.TYPE.value = "user";
                Build.TAGS.value = "release-keys";
                
                Java.use("android.os.SystemProperties").get.overload('java.lang.String').implementation = function(key) {
                    if (key.includes("qemu") || key.includes("goldfish") || key.includes("sdk") || key.includes("generic")) {
                        return "";
                    }
                    return this.get(key);
                };
            } catch (e) {
                console.log("[-] Build properties hook failed:", e);
            }
        }

        function setupRootBypass() {
            console.log("[+] Initializing Enhanced Root Detection Bypass...");
            try {
                // Wrap package manager check in a try-catch
                try {
                    const currentApplication = Java.use("android.app.ActivityThread").currentApplication();
                    if (currentApplication) {
                        const context = currentApplication.getApplicationContext();
                        if (context) {
                            const pm = context.getPackageManager();
                            if (pm) {
                                ROOT_PACKAGES.forEach(pkg => {
                                    try {
                                        pm.getPackageInfo(pkg, 0);
                                        log(LOG_LEVEL.DEBUG, `Found root package: ${pkg}`);
                                    } catch(e) {
                                        // Package not found - good
                                    }
                                });
                            }
                        }
                    }
                } catch(e) {
                    console.log("[-] Package manager check failed - app context not ready");
                }

                // Continue with other bypasses even if package manager check fails
                bypassNativeFileOperations();
                bypassBuildProps();  // <-- Now defined!
                bypassShellCommands();
                bypassRuntimeExec();
                enhancedFileBypass();
                bypassSystemProperties();
                bypassProcessBuilder();
                bypassBufferedReader();
                bypassSecureHardware();
                
                bypassStatus.root = true;
                return true;
            } catch(e) {
                console.error("[!] Root Bypass Error:", e);
                return false;
            }
        }

        function bypassNativeFileOperations() {
            try {
                const fopen = Module.findExportByName("libc.so", "fopen");
                if (fopen) {
                    Interceptor.attach(fopen, {
                        onEnter(args) {
                            this.filePath = args[0].readUtf8String();
                        },
                        onLeave(retval) {
                            if (retval.toInt32() !== 0 && isRootPath(this.filePath)) {
                                log(LOG_LEVEL.DEBUG, `Blocked fopen: ${this.filePath}`);
                                retval.replace(ptr(0x0));
                            }
                        }
                    });
                }

                const access = Module.findExportByName("libc.so", "access");
                if (access) {
                    Interceptor.attach(access, {
                        onEnter(args) {
                            this.filePath = args[0].readUtf8String();
                        },
                        onLeave(retval) {
                            if (retval.toInt32() === 0 && isRootPath(this.filePath)) {
                                log(LOG_LEVEL.DEBUG, `Blocked access: ${this.filePath}`);
                                retval.replace(ptr(-1));
                            }
                        }
                    });
                }

                const sysPropGet = Module.findExportByName("libc.so", "__system_property_get");
                if (sysPropGet) {
                    Interceptor.attach(sysPropGet, {
                        onEnter(args) {
                            this.key = args[0].readCString();
                            this.ret = args[1];
                        },
                        onLeave(retval) {
                            if (SENSITIVE_PROPS.has(this.key)) {
                                const safeValue = this.key.includes("fingerprint") ? 
                                    "google/crosshatch/crosshatch:10/QQ3A.200805.001/6578210:user/release-keys" : "0";
                                const ptrSafe = Memory.allocUtf8String(safeValue);
                                Memory.copy(this.ret, ptrSafe, safeValue.length + 1);
                            }
                        }
                    });
                }
            } catch (e) {
                console.log("[-] Native hooks partial failure:", e);
            }
        }

        function enhancedFileBypass() {
            try {
                const UnixFileSystem = Java.use("java.io.UnixFileSystem");
                UnixFileSystem.checkAccess.implementation = function(file, access) {
                    const filename = file.getAbsolutePath();
                    if (isRootPath(filename)) {
                        log(LOG_LEVEL.DEBUG, `Blocked file access: ${filename}`);
                        return false;
                    }
                    return this.checkAccess(file, access);
                };
                console.log("[+] UnixFileSystem bypass");
            } catch (e) {
                console.log("[-] UnixFileSystem hook failed:", e);
            }
        }

        function bypassShellCommands() {
            try {
                const ProcessImpl = Java.use("java.lang.ProcessImpl");
                ProcessImpl.start.implementation = function(cmdarray, env, dir, redirects, redirectErrorStream) {
                    const cmd = cmdarray[0].toString();
                    const arg = cmdarray.length > 1 ? cmdarray[1].toString() : "";

                    // Block package manager checks for root packages
                    if (cmd === "pm" && arg === "list" && cmdarray.length > 2) {
                        if (isRootPackage(cmdarray[2].toString())) {
                            log(LOG_LEVEL.DEBUG, `Blocked pm list: ${cmdarray[2].toString()}`);
                            cmdarray[0] = Java.use("java.lang.String").$new("");
                        }
                    }

                    // Block sensitive commands
                    if ((cmd === "mount") ||
                        (cmd === "getprop" && SENSITIVE_PROPS.has(arg)) ||
                        (cmd.includes("which") && arg === "su")) {
                        log(LOG_LEVEL.DEBUG, `Blocked command: ${cmd} ${arg}`);
                        cmdarray[0] = Java.use("java.lang.String").$new("");
                    }

                    return this.start.call(this, cmdarray, env, dir, redirects, redirectErrorStream);
                };
                console.log("[+] ProcessImpl.start bypass");
            } catch (e) {
                console.log("[-] Shell command hook failed:", e);
            }
        }

        function bypassRuntimeExec() {
            try {
                const Runtime = Java.use("java.lang.Runtime");

                // Optimized command blocking with regex
                const BLOCKED_CMD_PATTERNS = /getprop|mount|build\.prop|id|sh|su|which/i;

                function shouldBlockCommand(cmd) {
                    const cmdLower = cmd.toLowerCase();
                    return ROOT_BINARIES.has(cmdLower) ||
                           isRootPackage(cmdLower) ||
                           BLOCKED_CMD_PATTERNS.test(cmd);
                }

                const execOverloads = [
                    ["[Ljava.lang.String;"],
                    ["java.lang.String"],
                    ["java.lang.String", "[Ljava.lang.String;"],
                    ["[Ljava.lang.String;", "[Ljava.lang.String;"],
                    ["[Ljava.lang.String;", "[Ljava.lang.String;", "java.io.File"],
                    ["java.lang.String", "[Ljava.lang.String;", "java.io.File"]
                ];

                execOverloads.forEach(overload => {
                    try {
                        Runtime.exec.overload(...overload).implementation = function() {
                            let cmd = arguments[0];
                            if (Array.isArray(cmd)) {
                                cmd = cmd[0];
                            }

                            if (shouldBlockCommand(cmd.toString())) {
                                log(LOG_LEVEL.DEBUG, `Blocked Runtime.exec: ${cmd}`);
                                return this.exec.call(this, "echo");
                            }
                            return this.exec.apply(this, arguments);
                        };
                    } catch(e) {
                        // Overload may not exist in this Android version
                    }
                });
                console.log("[+] Runtime.exec bypasses");
            } catch(e) {
                console.log("[-] Runtime.exec hooks failed:", e);
            }
        }

        function bypassSystemProperties() {
            try {
                const SystemProperties = Java.use("android.os.SystemProperties");
                
                SystemProperties.get.overload('java.lang.String').implementation = function(key) {
                    if (ROOT_PROPERTIES.has(key)) {
                        return ROOT_PROPERTIES.get(key);
                    }
                    if (key.includes("qemu") || key.includes("goldfish") || key.includes("sdk")) {
                        return "";
                    }
                    return this.get(key);
                };
            } catch(e) {
                console.log("[-] System properties hook failed:", e);
            }
        }

        function bypassBufferedReader() {
            try {
                Java.use("java.io.BufferedReader").readLine.overload("boolean").implementation = function() {
                    const text = this.readLine.overload("boolean").call(this);
                    if (text && text.indexOf("ro.build.tags=test-keys") > -1) {
                        return text.replace("ro.build.tags=test-keys", "ro.build.tags=release-keys");
                    }
                    return text;
                };
            } catch(e) {
                console.log("[-] BufferedReader hook failed:", e);
            }
        }

        function bypassProcessBuilder() {
            try {
                const BLOCKED_CMDS = /getprop|mount|build\.prop|id|su/i;

                JavaClasses.ProcessBuilder.start.implementation = function() {
                    const cmd = this.command.call(this);

                    const hasBlockedCmd = Array.from(cmd).some(c => BLOCKED_CMDS.test(c.toString()));

                    if (hasBlockedCmd) {
                        log(LOG_LEVEL.DEBUG, `Blocked ProcessBuilder: ${Array.from(cmd).join(' ')}`);
                        this.command.call(this, ["echo"]);
                        return this.start.call(this);
                    }

                    return this.start.call(this);
                };

                console.log("[+] ProcessBuilder bypass");

                // Check for ProcessManager (older Android versions)
                Java.perform(function() {
                    try {
                        if (Java.available) {
                            const loadedClasses = Java.enumerateLoadedClassesSync();
                            if (loadedClasses.includes("java.lang.ProcessManager")) {
                                bypassProcessManager();
                            }
                        }
                    } catch(e) {
                        log(LOG_LEVEL.DEBUG, "ProcessManager not available");
                    }
                });

            } catch(e) {
                console.log("[-] ProcessBuilder hook failed:", e);
            }
        }

        function bypassProcessManager() {
            if (!JavaClasses.ProcessManager) return;

            try {
                const variants = [
                    {
                        params: ["[Ljava.lang.String;", "[Ljava.lang.String;", "java.io.File", "boolean"],
                        method: "exec"
                    },
                    {
                        params: ["[Ljava.lang.String;", "[Ljava.lang.String;", "java.lang.String", 
                                "java.io.FileDescriptor", "java.io.FileDescriptor", 
                                "java.io.FileDescriptor", "boolean"],
                        method: "exec"
                    }
                ];

                variants.forEach(variant => {
                    if (JavaClasses.ProcessManager[variant.method]) {
                        JavaClasses.ProcessManager[variant.method].overload(...variant.params)
                        .implementation = function() {
                            const cmd = arguments[0];
                            if (Array.isArray(cmd) && cmd.some(c => 
                                c.indexOf("getprop") !== -1 || 
                                c === "mount" || 
                                c.indexOf("build.prop") !== -1 || 
                                c === "id" || 
                                c === "su")) {
                                arguments[0] = ["echo"];
                            }
                            return this[variant.method].apply(this, arguments);
                        };
                    }
                });
            } catch(e) {
                console.log("[-] ProcessManager hooks failed:", e);
            }
        }

        function bypassSecureHardware() {
            Java.perform(function() {
                try {
                    if (Java.available) {
                        const loadedClasses = Java.enumerateLoadedClassesSync();
                        if (loadedClasses.includes("android.security.keystore.KeyInfo")) {
                            const KeyInfo = Java.use("android.security.keystore.KeyInfo");
                            KeyInfo.isInsideSecureHardware.implementation = function() {
                                return true;
                            };
                        }
                    }
                } catch(e) {
                    console.log("[-] SecureHardware hook not available");
                }
            });
        }

        // ============================================================================
        // BURP SUITE CERTIFICATE INTERCEPTOR
        // ============================================================================

        function setupBurpInterceptor() {
            console.log("");
            console.log("[.] Setting up Burp Certificate Interceptor");

            try {
                const CertificateFactory = Java.use("java.security.cert.CertificateFactory");
                const FileInputStream = Java.use("java.io.FileInputStream");
                const BufferedInputStream = Java.use("java.io.BufferedInputStream");
                const X509Certificate = Java.use("java.security.cert.X509Certificate");
                const KeyStore = Java.use("java.security.KeyStore");
                const TrustManagerFactory = Java.use("javax.net.ssl.TrustManagerFactory");
                const SSLContext = Java.use("javax.net.ssl.SSLContext");

                // Try multiple certificate file paths
                const certPaths = [
                    "/data/local/tmp/cert-der.crt",
                    "/data/local/tmp/burp.der",
                    "/data/local/tmp/burp.crt",
                    "/data/local/tmp/cacert.der",
                    "/data/local/tmp/cacert.crt"
                ];

                let fileInputStream = null;
                let certPath = null;

                // Try each certificate path
                for (const path of certPaths) {
                    try {
                        fileInputStream = FileInputStream.$new(path);
                        certPath = path;
                        console.log("[+] Found certificate at: " + path);
                        break;
                    } catch(err) {
                        console.log("[o] Certificate not found at: " + path);
                    }
                }

                if (!fileInputStream) {
                    console.log("[-] No certificate found. Please push the Burp certificate to one of these locations:");
                    console.log(certPaths.join("\n"));
                    return false;
                }

                console.log("[+] Loading Burp CA from: " + certPath);
                const cf = CertificateFactory.getInstance("X.509");
                const bufferedInputStream = BufferedInputStream.$new(fileInputStream);
                const ca = cf.generateCertificate(bufferedInputStream);
                bufferedInputStream.close();

                const certInfo = Java.cast(ca, X509Certificate);
                console.log("[o] Burp CA Info: " + certInfo.getSubjectDN());

                // Create a KeyStore containing our trusted CAs
                console.log("[+] Creating KeyStore for Burp CA...");
                const keyStoreType = KeyStore.getDefaultType();
                const keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry("ca", ca);
                
                // Create a TrustManager that trusts the CAs in our KeyStore
                console.log("[+] Creating TrustManager for Burp CA...");
                const tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
                const tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
                tmf.init(keyStore);
                console.log("[+] TrustManager ready");

                // Force accept all hostnames
                const NullHostnameVerifier = Java.registerClass({
                    name: 'org.webkit.android.NullHostnameVerifier',
                    implements: [Java.use('javax.net.ssl.HostnameVerifier')],
                    methods: {
                        verify: function (hostname, session) {
                            console.log('[+] Bypassing hostname verification: ' + hostname);
                            return true;
                        }
                    }
                });

                // Prepare the custom TrustManager
                const TrustAllCerts = Java.registerClass({
                    name: 'org.webkit.android.TrustAllCerts',
                    implements: [Java.use('javax.net.ssl.X509TrustManager')],
                    methods: {
                        checkClientTrusted: function(chain, authType) {},
                        checkServerTrusted: function(chain, authType) {},
                        getAcceptedIssuers: function() { return []; }
                    }
                });

                console.log("[+] Setting up SSL context and hostname verifier...");
                
                // Override SSL context
                SSLContext.init.overload(
                    "[Ljavax.net.ssl.KeyManager;", 
                    "[Ljavax.net.ssl.TrustManager;", 
                    "java.security.SecureRandom"
                ).implementation = function(keyManager, trustManager, secureRandom) {
                    console.log("[+] Intercepting SSLContext.init...");
                    SSLContext.init.overload(
                        "[Ljavax.net.ssl.KeyManager;", 
                        "[Ljavax.net.ssl.TrustManager;", 
                        "java.security.SecureRandom"
                    ).call(this, keyManager, [TrustAllCerts.$new()], secureRandom);
                    console.log("[+] Custom TrustManager installed");
                };

                // Set hostname verifier
                const HttpsURLConnection = Java.use("javax.net.ssl.HttpsURLConnection");
                HttpsURLConnection.setDefaultHostnameVerifier.implementation = function(hostnameVerifier) {
                    console.log("[+] Setting NullHostnameVerifier...");
                    return this.setDefaultHostnameVerifier(NullHostnameVerifier.$new());
                };

                console.log("[+] Burp certificate installation completed");
                return true;
            } catch(e) {
                console.log("[-] Burp certificate setup failed:", e);
                return false;
            }
        }

        // ============================================================================
        // FRIDA DETECTION BYPASS
        // ============================================================================

        function hookFrida() {
            try {
                console.log("[*] Setting up Frida detection bypasses...");
                let bypassSuccess = true;

                // Ptrace bypass
                try {
                    const ptracePtr = Module.findExportByName("libc.so", "ptrace");
                    if (ptracePtr) {
                        Interceptor.attach(ptracePtr, {
                            onEnter(args) {
                                this.returnSuccess = true;
                            },
                            onLeave(retval) {
                                if (this.returnSuccess) {
                                    retval.replace(0);  // Success return value
                                }
                            }
                        });
                        console.log("[+] Ptrace bypass installed");
                    }
                } catch(e) {
                    console.log("[-] Ptrace bypass failed:", e);
                    bypassSuccess = false;
                }

                // Process name detection bypass
                try {
                    const openPtr = Module.findExportByName("libc.so", "open");
                    if (openPtr) {
                        Interceptor.attach(openPtr, {
                            onEnter(args) {
                                const path = args[0].readUtf8String();
                                if (path.includes("/proc/") && path.includes("/maps")) {
                                    this.shouldModify = true;
                                }
                            },
                            onLeave(retval) {
                                if (this.shouldModify && retval != -1) {
                                    // Filter out Frida-related memory maps
                                    const sensitivePatterns = [
                                        "frida",
                                        "gum-js-loop",
                                        "gmain",
                                        "linjector",
                                        "frida-agent",
                                        "frida-helper",
                                        "magisk",
                                        "xposed",
                                        "substrate"
                                    ];

                                    const fd = retval.toInt32();
                                    const originalMap = new File(fd, "r").readAll().toString();
                                    
                                    // Filter out lines containing sensitive patterns
                                    const filteredMap = originalMap.split('\n')
                                        .filter(line => !sensitivePatterns.some(pattern => 
                                            line.toLowerCase().includes(pattern)))
                                            .join('\n');

                                    // Replace the original file descriptor with filtered content
                                    new File(fd, "w").write(filteredMap);
                                }
                            }
                        });
                        console.log("[+] Process maps bypass installed");
                    }
                } catch(e) {
                    console.log("[-] Process maps bypass failed:", e);
                    bypassSuccess = false;
                }

                // String pattern detection bypass
                try {
                    const patterns = ["frida", "gum-js-loop", "gmain", "linjector"];
                    const strstr = Module.findExportByName("libc.so", "strstr");
                    if (strstr) {
                        Interceptor.attach(strstr, {
                            onEnter(args) {
                                const haystack = args[0].readUtf8String();
                                const needle = args[1].readUtf8String();
                                if (patterns.some(pattern => 
                                    needle.toLowerCase().includes(pattern) || 
                                    haystack.toLowerCase().includes(pattern))) {
                                    this.shouldModify = true;
                                }
                            },
                            onLeave(retval) {
                                if (this.shouldModify) {
                                    retval.replace(ptr(0));  // Return null for matches
                                }
                            }
                        });
                        console.log("[+] String pattern bypass installed");
                    }
                } catch(e) {
                    console.log("[-] String pattern bypass failed:", e);
                    bypassSuccess = false;
                }

                // Port scanning detection bypass
                try {
                    const connect = Module.findExportByName("libc.so", "connect");
                    if (connect) {
                        Interceptor.attach(connect, {
                            onEnter(args) {
                                const sockAddr = args[1];
                                if (sockAddr) {
                                    const sa_family = sockAddr.add(1).readU8();
                                    if (sa_family === 2) { // AF_INET
                                        const port = sockAddr.add(2).readU16();
                                        // Known Frida ports
                                        const suspiciousPorts = new Set([
                                            27042, // Default Frida
                                            27043, // Frida
                                            23946, // Frida server
                                            27047  // Frida helper
                                        ]);

                                        if (suspiciousPorts.has(port)) {
                                            console.log(`[!] Blocked connection to suspicious port: ${port}`);
                                            this.shouldBlock = true;
                                        }
                                    }
                                }
                            },
                            onLeave(retval) {
                                if (this.shouldBlock) {
                                    retval.replace(-1); // Connection failed
                                }
                            }
                        });
                        console.log("[+] Port scanning bypass installed");
                    }
                } catch(e) {
                    console.log("[-] Port scanning bypass failed:", e);
                    bypassSuccess = false;
                }

                global.fridaStatus = bypassSuccess;
                return bypassSuccess;

            } catch(e) {
                console.log("[-] Fatal error in Frida bypass:", e);
                global.fridaStatus = false;
                return false;
            }
        }

        // ============================================================================
        // MAIN SETUP & EXECUTION
        // ============================================================================

        function setupBypass() {
            try {
                const results = {
                    ssl: setupSSLBypass(),
                    root: setupRootBypass(),
                    burp: setupBurpInterceptor(),
                    frida: hookFrida()
                };
                
                if (CONFIG.enableDetailedLogs) {
                    log(LOG_LEVEL.DEBUG, "Detailed bypass results:", results);
                }

                return results;
            } catch(e) {
                log(LOG_LEVEL.ERROR, "Bypass setup failed", e);
                return {};
            }
        }

        try {
            const results = setupBypass();

            // Add detailed error reporting
            Object.entries(results).forEach(([type, success]) => {
                if (!success) {
                    console.log(`[-] ${type.toUpperCase()} bypass failed`);
                }
            });

            console.log("\n[*] Status:", Object.entries(results)
                .map(([k, v]) => `${k}: ${v ? "✓" : "✗"}`)
                .join(", "));

        } catch(err) {
            console.error("[!] Critical Error:", err.stack || err);
        }

    });
    
}, 0);  
```